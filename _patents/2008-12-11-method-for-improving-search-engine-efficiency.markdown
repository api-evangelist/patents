---
title: Method for improving search engine efficiency
abstract: In a method for improving the efficiency of a search engine in accessing, searching and retrieving information in the form of documents stored in document or content repositories, the search engine comprises an array of search nodes hosted on one or more servers. An index of the stored document is created. The search engine processes a user search query and returns a result set of query-matching documents. The index of the search engine is configured on the basis of one or more document properties and partitioned, replicated and distributed over the array of the search nodes. The search queries are processed on the basis of the distributed index. The method realizes a framework for distributing the index of a search engine across several hosts in a computer cluster, relying on three orthogonal mechanisms for index distribution, namely index partitioning, index replication, and assignment of replicas to hosts. In this manner, different ways of configuring the index of a search engine are obtained and provide a much improved resource usage and performance, combined with any desired level of fault tolerance.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08799264&OS=08799264&RS=08799264
owner: Microsoft Corporation
number: 08799264
owner_city: Redmond
owner_country: US
publication_date: 20081211
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This Nonprovisional application claims priority under 35 U.S.C. \u00a7119(e) on U.S. Provisional Application No(s). 61\/013,705 filed on Dec. 14, 2007, the entire contents of which are hereby incorporated by reference.","The present invention concerns a method for improving search engine efficiency with respect to accessing, searching and retrieving information in the form of documents stored in document or content repositories, wherein an indexing subsystem of the search engines crawls the stored documents and generates an index thereof, wherein applying a user search query to the index shall return a result set of at least some query-matching documents to the user, and wherein the search engine comprises an array of search nodes hosted on one or more servers.","Particularly the invention discloses how to build a new framework for index distribution on a search engine, and even more particularly on an enterprise search engine.","Building a search engine is challenging for several reasons:\n\n","To satisfy the above three requirements, search engines use sophisticated methods for distributing their indices across a possibly large cluster of hosts.","An overview and discussion of the prior art relevant to the present invention shall now be given. All literature references are identified by abbreviations in parenthesis at the appropriate location in the following. A full bibliography is given in an appendix at the end of the description.","In order to improve the efficiency of search systems there has recently been much research on distribution of search engine indices. Early work concerned how to distribute posting lists and explored the trade-off between distributing posting lists based on index terms (herein also called keywords) versus documents [Bad01, MMR00, RNB98, TGM93, CKE90, MWZ06]. The present invention takes as its point of departure the insight that making a global choice between these two alternatives is suboptimal because the statistical properties of keywords and documents vary in a typical search environment, as exemplified below.\n\n","In order to better understand the prior art, a brief discussion of a search engine architecture as known in the art and currently used shall be given with reference to , which shows a block diagram of a search engine as will be known to persons skilled in the art, its most important subsystems, and its interfaces respectively to a content domain, i.e. the repository of documents that may be subjected to a search, and a client domain comprising all users posing search queries to the search engine for retrieval of query-matching documents from the content domain.","The search engine  of the present invention, as known in the art, comprises various subsystems -. The search engine can access document or content repositories located in a content domain or space wherefrom content can either actively be pushed into the search engine, or using a data connector be pulled into the search engine. Typical repositories include databases, sources made available via ETL (Extract-Transform-Load) tools such as Informatica, any XML-formatted repository, files from file servers, files from web servers, document management systems, content management systems, email systems, communication systems, collaboration systems, and rich media such as audio, images and video. Retrieved documents are submitted to the search engine  via a content API (Application Programming Interface) . Subsequently, documents are analyzed in a content analysis stage , also termed a content pre-processing subsystem, in order to prepare the content for improved search and discovery operations. Typically, the output of this content analysis stage  is an XML representation of the input document. The output of the content analysis is used to feed the core search engine . The core search engine  can typically be deployed across a farm of servers in a distributed manner in order to allow for large sets of documents and high query loads to be processed. The core search engine  accepts user requests and produces lists of matching documents. The document ordering is usually determined according to a relevance model that measures the likely importance of a given document relative to the query. In addition, the core search engine  can produce additional metadata about the result set, such as summary information for document attributes. The core search engine  in itself comprises further subsystems, namely an indexing subsystem for crawling and indexing content documents and a search subsystem for carrying out search and retrieval proper. Alternatively, the output of the content analysis stage  can be fed into an optional alert engine . The alert engine  will have stored a set of queries and can determine which queries that would have been satisfied by the given document input. A search engine can be accessed from many different clients or applications which typically can be mobile and computer-based client applications. Other clients include PDAs and game devices. These clients, located in a client space or domain, submit requests to a search engine query or client API . The search engine  will typically possess a further subsystem in the form of a query analysis stage  to analyze and refine the query in order to construct a derived query that can extract more meaningful information. Finally, the output from the core search engine  is typically further analyzed in another subsystem, namely a result analysis stage  in order to produce information or visualizations that are used by the clients. Both stages  and  are connected between the core search engine  and the client API , and in case the alert engine  is present, it is connected in parallel to the core search engine  and between the content analysis stage  and the query and result analysis stages ; .","In order to improve the search speed of a search engine International published application WO00\/68834 proposes a search engine with two-dimensional linearly scalable parallel architecture for searching a collection of text documents D, wherein the documents can be divided into a number of partitions d, d, . . . , d, wherein the collection of documents D is pre-processed in a text filtration system such that a pre-processed document collection Dand corresponding pre-processed partitions d, d, . . . , dare obtained, wherein an index I can be generated from the document collection D such that for each previous pre-processed partition d, d, . . . , da corresponding index i, i, . . . , iis obtained, wherein searching a partition d of the document collection D takes place with a partition-dependent data set d, where 1\u2266k\u2266n, and wherein the search engine comprises data processing units that form sets of nodes connected in a network. A first set of nodes comprises dispatch nodes N, a second set of nodes search nodes N and a third set of nodes indexing nodes N. The search nodes N are grouped in columns which via the network are connected in parallel between the dispatch nodes N and an indexing node N. The dispatch nodes N are adapted for processing search queries and search answers, the search nodes N are adapted to contain search software, and the indexing nodes N are adapted for generally generating indexes I for the search software. Optionally, acquisition nodes N are provided in a fourth set of nodes and adapted for processing the search answers, thus relieving the dispatch nodes of this task. The two-dimensional scaling takes place respectively with a scaling of the data volume and a scaling of the search engine performance through a respective adaptation of the architecture.","The schematic layout of this scalable search engine architecture is shown in , illustrating the principle of two-dimensional scaling. An important benefit of this architecture is that the query response time is essentially independent of catalogue size, as each query is executed in parallel on all search nodes N. Moreover, the architecture is inherently fault-tolerant such that faults in individual nodes will not result in a system breakdown, only in a temporary reduction of the performance.","Although the architecture shown in  provides a multilevel data and functional parallelism such that large volumes of data can be searched efficiently and very fast by a large number of users simultaneously, it is encumbered with certain drawbacks and hence far from optimal. This is due to the fact that the row and column architecture is based on a mechanical and rigid partition scheme, which does not take account of modalities in the keyword distribution and the user behaviour, as expressed by frequency distributions of search terms or keywords, and access patterns.","Further, U.S. Pat. No. 7,293,016 B1 (Shakib & al., assigned to Microsoft Corporation) discloses how to arrange indexed documents in an index according to a static ranking and partitioned according to that ranking. The index partition is scanned progressively, starting with a partition containing those documents with the highest static rank, in order to locate documents containing a search word, and a score is computed based on a present set of documents located thus far in the search and on basis of the range of static ranks to a next partition to be scanned. The next partition is scanned to locate the documents containing a search word when the calculated score is above a target score. A search can be stopped when no more relevant results will be found in the next partition.","US published patent application No. 2008\/033943 A1 (Richards & al., assigned to BEA Systems, Inc.) concerns a distributed search system with a central queue of document-based records wherein a group of nodes is assigned to different partitions, indexes for a group of documents are stored in each partition, and the nodes in the same partition independently process document-based records from the central queue in order to construct the indexes.","Existing prior art does not provide a design framework built on the general notions of keyword and query distribution properties and thus does not achieve the flexibility of this design, with resulting performance improvements and reduction in resource requirements.","A specific concern has been growth of the index, and several specific techniques that gracefully handle on-line index construction have been developed [BCL06]. These techniques are orthogonal to the framework resulting from applying the method according to the present invention, as shall be apparent from a detailed description thereof.","The present invention does not take specific ranking algorithms into account since it is assumed that the user always wants all query results. However, these ideas can be extended in a straightforward manner to some of the recently developed ranking algorithms [RPB06, AM06, LLQ07] and algorithms for novel query models [CPD06, LT1T07, ZS07, DEFS06, TKT06, JRMG06, YJ06, KCMK06]. Algorithms for finding the best matching query results when combining matching functions have also been the focus of much research [PZSD96, Fag99, MYL02]. These techniques are, however, orthogonal to an index distribution framework as realized by the method of the present invention, and they can also be incorporated easily.","The techniques employed by the present invention for query processing with partitioned posting lists are based on fundamental ideas drawn from parallel database systems [DGG86]; however, parallel database systems were developed for database management systems that store structured data, whereas the focus of the present invention is on enterprise and Internet search where search queries are executed over collections of often unstructured or semi-structured documents.","There is also prior art concerning text query processing in peer-to-peer systems where the goal is to coordinate loosely coupled hosts with an emphasis to find query results without broadcasting a query to all hosts in the network [RV03, LLH03, ODODg02, SMwW03CAN02, KRo02, SL02, TXM03, TXD03, BJR03, TD04]. The main assumption of these prior art publications concerns the degree of coupling between the hosts, and this is different from the initial conception of the present invention which assumes that all hosts are tightly coupled and are under control of a single entity, for example, in a cluster in an enterprise data center, which is the dominant architecture today. The conceptual framework on which the present invention builds, maps directly onto this architecture by assuming a tightly coupled set of hosts.","In view of the shortcomings and disadvantages of the above-mentioned prior art, it is a major object of the present invention to provide a method that significantly enhances the performance of a search engine.","Another object of the present invention is to configure the index of a search engine and specifically an enterprise search engine on basis of recognizing that keywords and documents will differ both with regard to intrinsic as well as to extrinsic properties, for instance such as given by modalities in search and access patterns.","Finally, it is an object of the present invention to optimize an index configuration with regard to inherent features of the search system itself as well as to its operating environment.","The above-mentioned objects as well as further features and advantages are realized according to the present invention with a method that is characterized by configuring the index of the search engine on basis of one or more document properties, and at least one of a fault-tolerance level, a required search performance, document meta-properties, and an optimal resource utilization;","partitioning the index; replicating the index; distributing the thus partitioned and replicated index over the array of search nodes, such that index partitions and replicas thereof are assigned to said one or more servers hosting the array of search nodes, and processing search queries on the basis of the distributed index.","Further features and advantages of the present invention shall be apparent from the appended dependent claims.","In order to describe the present invention in full, some assumptions and preliminaries shall be discussed. Then the new framework for index distribution enabled by the method according to the present invention is discussed.","For the present invention, a simplified model of a search engine is introduced. The notation used is summarized in Table 1.",{"@attributes":{"id":"p-0036","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Notations Used in this Patent Application"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Symbol","Explanation"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["\u03ba","keyword"]},{"entry":["K = {\u03ba, . . . , \u03ba}","set of keywords"]},{"entry":["D = {d, . . . , d}","set of documents"]},{"entry":["u","a URL"]},{"entry":["n","number of different keywords"]},{"entry":["m","number of documents"]},{"entry":["(\u03ba, u)","an occurrence"]},{"entry":["PL(k)","posting list of keyword k"]},{"entry":["|PL(k)|","size of the positing list of keyword k"]},{"entry":["q","a query"]},{"entry":["QueryResult(q)","result of processing query q"]},{"entry":["\u03c9","query workload (\u03c9: 2\u2192 R)"]},{"entry":["\u03bb(q)","interarrival rate of query q under workload \u03c9"]},{"entry":["h","host"]},{"entry":["H = {h, . . . , h}","set of hosts"]},{"entry":["o","number of hosts"]},{"entry":["r, c","number of rows and columns, respectively"]},{"entry":["buc","performance of host"]},{"entry":["numPartitions(\u03ba)","number of components of keyword \u03ba"]},{"entry":["occLoc((\u03ba, u))","number of the component where occurrence (\u03ba, u)"]},{"entry":[{},"is located"]},{"entry":["numReplicas(\u03ba)","number of replicas of keyword \u03ba"]},{"entry":["hostAssign(\u03ba, i, j)","host that stores component-replica i of component"]},{"entry":[{},"j of keyword \u03ba"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"One has a set of keywords K={\u03ba, . . . , \u03ba} and a set of documents D={d, . . . , d}. Each document d is a list of keywords, and is identified by a unique identifier called a URL. An occurrence is a tuple (\u03ba, u) which indicates that the document associated with the URL u contains the keyword \u03ba. A document record is a tuple (u, date) that indicates that the document associated with the URL u was created at a given date.","In practice, an occurrence contains other data, for example the position of the keyword in the document or data that are useful for determining the ranking of the document in the output of a query. Also, a document has other associated metadata besides the document record, for example an access control list. Neither of these issues are important for the aspects of the index which are the focus of the following discussion.","The index of a search engine consists of sets of occurrences and a set of document records. There is one set of occurrences for each keyword \u03ba, hereinafter called the posting set of keyword \u03ba. The posting set of keyword \u03ba contains all occurrences of keyword \u03ba, and it contains only occurrences of keyword \u03ba. To be consistent with the prior art, posting sets are presumed to be ordered in a fixed order (for example, lexicographically by URL), and the ordered posting set of a keyword k will be referred to as the posting list PL(\u03ba) of keyword \u03ba in the following disclosure. The set of document records contains one document record for each document, and it only contains document records.","Now search queries and query processing shall be discussed in some detail. Users issue queries; and a query q consists of a set of keywords q={\u03ba, . . . , \u03ba} K. The present invention adopts a model for a query in which a user would like to find every document that contains all the keywords in the query. One can assume that the arrival time of each query q follows an exponential distribution and thus can be characterized by a single parameter \u03bb, the interarrival rate of query q. Note that this probabilistic model of queries implies that queries are independent. A query workload \u03c9 is a function that associates with each query q\u03b52an arrival rate \u03bb(q). From a query workload one can compute the arrival rate \u03bb(\u03ba) of each keyword \u03ba by summing over all the queries that contain \u03ba, formally",{"@attributes":{"id":"p-0041","num":"0045"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["\u03bb","\u03c9"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}},{"munder":{"mo":"\u2211","mrow":{"mrow":[{"mi":"q","mo":"\u2208","msup":{"mn":"2","mi":"K"}},{"mi":["\u03ba","q"],"mo":"\u2208"}],"mo":","}},"mo":"\u2062","mrow":{"msub":{"mi":["\u03bb","\u03c9"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"q"}}}],"mo":"="}}}},"The following simplified way of logically processing a query q={\u03ba, . . . , \u03ba} shall be assumed. For each keyword \u03baits posting list PL(\u03ba) is retrieved for i\u03b5{1, . . . , l}, and their intersection in the URL fields are computed. Formally, the following relational algebra expression computes the query result QueryResult(q) for query q={\u03ba, . . . , \u03ba}:\n\nQueryResult()=\u03c0(\u03ba)\u2229 . . . \u2229 \u03c0(\u03ba)\n\nThere are more sophisticated ways of defining QueryResult(q); for example, the user may only want to see a subset of QueryResult(q), and also may want to see this subset in ranked order.\n","Physical Setup","The present invention assumes a cluster of workstations modelled as a set of hosts H={h, . . . , h} [ACPtNt95]. Further, each host h is assumed to have a single disk with a fixed amount of storage space of DiskSize units. Note that for ease of explanation, the translation of the abstract unit of storage into a concrete unit such as bytes has been omitted in the model. Each occurrence is assumed to have a fixed size of 1 unit. For a keyword \u03ba and its posting list PL(\u03ba) the size of the posting list |PL(\u03ba)|, is defined as the number of occurrences in PL(\u03ba).","Each host h is assumed to be capable of an associated overall performance that allows it to retrieve buc(h) units of storage within latencyBound milliseconds; this number is an aggregated unit that incorporates CPU speed, the amount of main memory available, and the latency and transfer rate of the disk of the host. Further, in the following, all hosts are assumed to have identical performance, and thus the dependency of buc(h) on h can be dropped and reference just be made to buc as the number of units that any host can retrieve within latencyBound milliseconds.","A framework for index distribution shall now be discussed. Specifically, the framework or architecture as realized according to the method of the present invention encompasses three aspects, viz. partitioning, replication and host assignment, as set out below.","Partitioning","For each keyword, its posting list is partitioned into one or more components. This partitioning of the posting lists into components is done in order to be able to distribute the posting lists across multiple hosts such that all components can be retrieved in parallel.","Replication","For each keyword, each of its components is replicated a certain number of times resulting in several component-replicas for each component. Component-replicas are created for several reasons. The first reason for replication is fault-tolerance; in case a host that stores a component fails, the component can be read from another host. The second reason for replication is improved performance because queries can retrieve a component from anyone of the hosts on which the component is replicated and thus load can be balanced.","Host Assignment","After partitioning and replication, each component-replica of a posting list is assigned to a host, but with the assignment subject to the restriction that no two component-replicas of the same component and the same partition are assigned to the same host. The host assignment enables the location of components to be optimized globally across keywords. One could for example co-locate components of keywords that appear commonly together in queries to reduce the cost of query processing.","Now the corresponding three parts of the index distribution framework according to the method of the present invention shall be introduced.\n\n","For the first part, select a function numPartitions(\u2022) that takes as input a keyword \u03ba and returns the number of components into which posting list PL(\u03ba) is partitioned; the resulting components are C(\u03ba), C(\u03ba), . . . , C(\u03ba). Also select a function occLoc(\u2022) that takes as input an occurrence and outputs the number of the component in which this occurrence is located. Thus, if occLoc((\u03ba, u))=i, then (\u03ba, u)\u03b5C(\u03ba). Note that if (\u03ba, u)\u03b5PL(\u03ba), 1\u2266occLoc((\u03ba, u))\u2266numPartitions(\u03ba) holds.","For the second part, select a function numReplicas(\u2022) that takes as input a keyword \u03ba and returns the number of component-replicas of the partitions of the posting list of \u03ba. The original component is included in the number of component-replicas. Thus for a keyword \u03ba, there exist numReplicas(\u03ba)\u00b7numPartitions(\u03ba) component-replicas. If the right numPartitions(\u03ba) components are combined, then they together comprise PL(\u03ba); for any component C(\u03ba) one can find numReplicas(\u03ba) identical component-replica. In particular, if in workload \u03c9 keyword \u03ba has arrival rate \u03bb(\u03ba), and one uniformly balances the load between numReplicas(\u03ba) component-replica, then the arrival rate for this keyword for each of the component-replicas will be",{"@attributes":{"id":"p-0056","num":"0063"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"msub":{"mi":["\u03bb","\u03c9"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}},{"mi":"numReplicas","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}}]},"mo":"."}}}},"For the third part select a function hostAssign(\u03ba, i, j) that takes as input a keyword \u03ba, a replica number i and a component number j and returns the host that stores component-replica i of component j of the posting list in PL(\u03ba). Note that two identical component-replicas (that are replicas of each other) must be mapped to different hosts. Formally, hostAssign(\u03ba, i, j)\u2260hostAssign(\u03ba, i, j) must hold for j\u03b5{1, . . . , numPartitions(k)} and i, i\u03b5{1, . . . , numPartitions(\u03ba)} with i\u2260i.",{"@attributes":{"id":"p-0058","num":"0065"},"figref":"FIGS. 3 and 4","sub":["1","2","3","4","5 ","1","2","5"]},"An instantiation of the three functions numPartitions(\u2022) numReplicas(\u2022) and hostAssign (\u03ba, ij) shall be called a search engine index configuration.","Given the framework as disclosed above, the physical model for processing a query q can now be introduced. Processing a query q involves three steps:\n\n","Now these three steps shall in turn be addressed.","For the first step, note that function hostAssign(\u03ba, ij) encodes for each keyword \u03ba the set of hosts where all the component-replicas of the posting list of \u03ba are stored.","For the second step, each host involved in processing query q (as selected in the first step) retrieves all its local component-replicas for all keywords involved in the query.","For the third step, each host will first intersect the local component-replica of all the keyword. Then the results of the local intersections are processed further to complete computation of QueryResult(q).","Now the problem of index design can be defined as follows. A set of hosts that has associated storage space DiskSize and performance buc is given. Also given is a set of keywords with posting lists PL(\u03ba), . . . , PL(\u03ba) that have sizes |PL(\u03ba)|, . . . , |PL(\u03ba)|, as well as a query workload \u03c9.","For the index design problem one needs to find functions numPartitions(\u2022), numReplicas(\u2022), and hostAssign such that the expected latency of answering a query q is below latencyBound, where the expectation is over the set of all possible query sequences.","In the following a discussion of some embodiments shall be given by specific and exemplary instantiations thereof.","1. AllTheWeb Rows and Columns","The AllTheWeb Rows and Columns architecture (in homage to the AllTheWeb search system as described in the introduction hereinabove) is a trivial instantiation of the framework, cf.  which renders the mapping functions for host assignment. In this architecture, there is a matrix of hosts consisting of r rows and c columns. One can visualize this matrix as follows:",{"@attributes":{"id":"p-0070","num":"0080"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"h","mrow":{"mn":["1","1"],"mo":","}}},{"msub":{"mi":"h","mrow":{"mn":["1","2"],"mo":","}}},{"mi":"\u22ef"},{"msub":{"mi":"h","mrow":{"mn":"1","mo":",","mi":"c"}}}]},{"mtd":[{"msub":{"mi":"h","mrow":{"mn":["2","1"],"mo":","}}},{"msub":{"mi":"h","mrow":{"mn":["2","2"],"mo":","}}},{"mi":"\u22ef"},{"msub":{"mi":"h","mrow":{"mn":"2","mo":",","mi":"c"}}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22f0"},{"mi":"\u22ee"}]},{"mtd":[{"msub":{"mi":"h","mrow":{"mi":"r","mo":",","mn":"1"}}},{"msub":{"mi":"h","mrow":{"mi":"r","mo":",","mn":"2"}}},{"mi":"\u22ef"},{"msub":{"mi":"h","mrow":{"mi":["r","c"],"mo":","}}}]}]}}}}}},"Using a hash function on URLs which is independent of the keyword, the postings of any keyword are approximately evenly partitioned into c components. Each component is then replicated within the column, one component-replica for each row, resulting in r component-replicas. To reconstruct the posting list of a keyword, one host from each column needs to be accessed, but it is not necessary to select these hosts all from the same row, and this flexibility simplifies query load balancing between hosts and improves fault tolerance.","To make the connection to the notation of the framework as realized by the method of the present invention, the three above-mentioned functions must be instantiated. First, due to the row and column schema, one has that for all keywords \u03ba\u03b5K, numPartitions(\u03ba)=c, and numReplicas(\u03ba)=r hold, and for all URLs u and \u03ba, \u03ba\u03b5K the following must hold:\n\noccLoc((\u03ba))=occLoc((\u03ba)),\n\ni.e. for a URL u, the function occLoc((\u03ba, u)) is independent of the keyword \u03ba. The function hostAssign is also quite simple. Let hostAssign(\u03ba, ij)=(ij), where i is the row of the host and j indicates the column of the host in the r\u00d7c matrix. Note that if the number of columns c is suitably chosen, then all the component-replicas of any single keyword \u03ba can be read in parallel within the latencyBound. The smallest number c is the following:\n",{"@attributes":{"id":"p-0073","num":"0083"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"c","mo":"=","mrow":{"munder":{"mi":["max","\u03ba"]},"mo":"\u2062","mrow":{"mrow":{"mo":["\u2308","\u2309"],"mfrac":{"mrow":{"mo":"\uf603","mrow":{"mi":"PL","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}}},"mi":"buc"}},"mo":"."}}}}}},"When performing query processing in the AllTheWeb Rows and Columns architecture as shown in , only one host in each column needs to be involved even for multi-keyword queries since the function occLoc((\u03ba, u)) is independent of \u03ba.","However, AllTheWeb Rows and Columns has several disadvantages. Firstly, the number of hosts accessed for a keyword \u03ba is independent of the length of \u03ba's posting list; c hosts must always be accessed even for keywords with very short posting lists. Secondly, AllTheWeb Rows and Columns does not take keyword popularity in the query workload into account; every component is replicated r times even if the associated keyword is accessed only quite infrequently. Thirdly, changes in the physical setup for AllTheWeb Rows and columns are constrained to additions of hosts in multiples of c or r at once, resulting in an additional row or an additional column in the architecture.","Addition of a new (c host) row is relatively straightforward; addition of a new (r host) column, however, is non-trivial. To illustrate this point, consider an instance of AllTheWeb Rows and Columns with r rows and c columns and which uses associated function occLocc(\u2022) with range {1, . . . , c}. When adding another row, a new function occLoc\u2032(\u2022) with range {1, . . . , c+1} must be selected, and in general\n\noccLoc((\u03ba))\u2260occLoc\u2032((\u03ba)),\n\nwill hold, so all posting lists need to be repartitioned according to occLoc\u2032(\u2022), which basically results in re-building of the whole index.\n","2. Fully Adaptive Rows and Columns","Now, a solution according to the present invention that takes into account both the difference in the sizes of posting lists and the difference in popularity of keywords in the query shall be described. The essence of this novel solution is that one instantiates AllTheWeb Rows and Columns differently for each keyword: Each keyword may have a different number of rows and columns. In other words, applying the method of the present invention shall provide a solution with fully adaptive rows and columns.","Consider a keyword \u03ba. Start with an instantiation of numPartitions(\u03ba). Since each host can only retrieve buc units while satisfying the global query latency requirement of latencyBound, PL(\u03ba) is partitioned into",{"@attributes":{"id":"p-0080","num":"0090"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"numPartitions","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}},{"mo":["\u2308","\u2309"],"mfrac":{"mrow":{"mo":["\uf603","\uf604"],"mrow":{"mi":"PL","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}}},"mi":"buc"}}],"mo":"="}}},"br":{}},"The question now is how many component-replicas should be created for a keyword \u03ba. Recall that component-replicas are created for fault tolerance and in order to distribute the query workload across hosts. To tolerate f unavailable hosts, numReplicas(\u03ba)\u2267f is enforced. To balance the query workload, posting lists of popular keywords (in the query workload) are replicated more often than posting lists of rare keywords. So the number of replicas is made inversely proportional to the arrival rate of the keyword in the workload.","By making numPartitions(\u03ba) and numReplicas(\u03ba) different for each keyword \u03ba, one obtains a number of rows and columns that is specific for each keyword. The number of columns still indicates the number of partitions, and the number of rows indicates the number of replicas for each partition. However, keywords with long posting lists have many columns, and keywords with short posting lists have few columns. Popular keywords have many rows, unpopular keywords have few rows. As compared to AllTheWeb Rows and Columns, Fully Adaptive Rows and Columns results in less imbalance in the sizes of the components for different keywords. Thus one has achieved that each component-replica is now normalized in the sense that each component-replica has approximately the same size (up to a difference of buc) and has approximately the same arrival rate.","There are many different ways of assigning component-replicas to hosts. Given o hosts, one possibility would be to hash each keyword \u03ba onto one of the numbers from 1 to o, and then to assign the components sequentially (mod o) to hosts. Conceptually, for a keyword \u03ba this embeds \u03ba's specific matrix with numPartitions(\u03ba) columns and numReplicas(\u03ba) rows sequentially into the o hosts. Formally, the assignment function has the following form. Let keywHash(\u2022) be a function from K to {1, . . . , o} with the property that",{"@attributes":{"id":"p-0084","num":"0094"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":{"mi":"keywHash","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}},"mo":"=","mi":"i"}}},"mo":"=","mfrac":{"mn":"1","mi":"o"}},"mo":","}}},"br":[{},{}],"in-line-formulae":[{},{}],"i":["i,j","i\u2212","j\u2212","o, "]},"where i\u03b5{1, . . . , numReplicas(\u03ba)} and j\u03b5{1, . . . , numPartitions(\u03ba)},","With this instantiation of hostAssign, the question now is how many component-replicas will be assigned to a host. With Fully Adaptive Rows and Columns the following simple theorem shows that there will not be much imbalance between two hosts with respect to the number of component-replicas.","Theorem 1","Let s be the total number of component-replicas created over all keywords \u03ba, formally",{"@attributes":{"id":"p-0089","num":"0099"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"s","mo":"=","mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["\u03ba","K"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"numPartitions","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}},{"mi":"numReplicas","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}}],"mo":"\u00b7"}}}}}},"Let o be the number of hosts, and assume hostAssign is defined as in the previous paragraph, and assume that s=\u03a9(o). Then the maximum number of component-replicas at each host h\u03b5H is \u0398(s\/o), i.e. the maximum number of component-replicas assigned to any host is on the order of the mean number of component-replicas assigned to any host.","Proof","Follows from bounds on balls into bins [MR95].","To retrieve the posting list of a keyword \u03ba in processing a search query, select any one host from each of the numPartitions(\u03ba) \u201cvirtual columns\u201d of \u03ba's matrix; thus the number of different possibilities for choosing this set is numPartitions(\u03ba).","Processing queries with multiple keywords in Fully Adaptive Rows and Columns is much more expensive than in AllTheWeb Rows and Columns. For example, consider a keyword query q={\u03ba, \u03ba} where numPartitions(\u03ba)\u2260numPartitions(\u03ba). Since keywords \u03baand \u03baare partitioned differently, the posting list of say, \u03ba, must be repartitioned to match the partitioning of \u03ba, an expensive operation. In addition, there is no guarantee that any components of \u03baand \u03baare co-located at the same host.","3. Two-Class Rows and Columns","A third instantiation of the framework as realized by the method of the present invention is a special case of Fully Adaptive Rows and Columns that results in much simpler (and cheaper) query processing. As in AllTheWeb Rows and Columns, it is assumed that r\u00b7c hosts are arranged in the usual matrix of hosts.","For Two-Class Rows and Columns, the keyword is classified along two axes. The first axis is the size of the posting list, where keywords are partitioned into short and long keywords based on the size of their posting lists. The second axis is the arrival rate of the keywords in the query workload where keywords are partitioned into popular and unpopular keywords based on their arrival rate. This results in four different classes of keywords:\n\n","This instantiation of the two functions numPartitions(\u2022) and numReplicas(\u2022) from the present framework for the different classes of keywords is shown in Table 2. Note that compared to Fully Adaptive Rows and Columns, in Two-Class Rows and Columns there are only four different types of matrices as depicted in , where the level of fault-tolerance f=2.",{"@attributes":{"id":"p-0099","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Classification of Keywords: Functions (numPartitions(\u03ba),"},{"entry":"numReplicas(\u03ba))"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Posting List",{}]},{"entry":[{},"Length"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Short","Long"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Arrival","Unpopular","(1, f)","(c, f)"]},{"entry":[{},"Rate","Popular","(1, r)","(c, r)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"Let keywHash(\u2022) be as defined and disclosed in connection with the discussion of fully adaptive Rows and Columns hereinabove. Let rowHash(\u2022,\u2022) be a function from K\u00d7{1, . . . , f} to {1, . . . , r} such that rowHash(\u03ba, i)\u2260rowHash(\u03ba, i) for i, i\u03b5{1, . . . , r}. How the component-replicas of a keyword are assigned to hosts depends on the class of the keyword.\n\n","Similar to the previous section, the following theorem can be proved.","Theorem 2","Let s be the total number of component-replicas created over all keywords \u03ba, (independent of the class of \u03ba), formally",{"@attributes":{"id":"p-0104","num":"0126"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"s","mo":"=","mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["\u03ba","K"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"numPartitions","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}},{"mi":"numReplicas","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03ba"}}],"mo":"\u00b7"}}}}}},"Let o be the number of hosts, and assume hostAssign is defined as in the previous paragraph. Then the maximum number of component-replicas at each host h\u03b5H is \u0398(s\/o), i.e. the maximum number of component-replicas assigned to any host is on the order of the mean number of component-replicas assigned to any host.","Proof","Follows from bounds on balls into bins [MR95].","Given the functions hostAssign(\u03ba,\u2022,\u2022) for the different classes of keywords, query processing in Two-Class Rows and Columns is not very complicated, and there are usually many choices of how to process a query. Table 3 describes how to process a query q={\u03ba, \u03ba} with two keywords; query processing for queries with more than two keywords is analogues.","The set of possible sets of hosts to choose for query processing is straightforward given this discussion.",{"@attributes":{"id":"p-0110","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Query Processing for Pairs of Keywords in Two-Class Rows and Columns"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u03ba, \u03ba","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["SU, SU","The posting list for any SU keyword just resides on a single host. Assuming"]},{"entry":[{},"without loss of generality that |PL(\u03ba)| < |PL(\u03ba)|, read the posting list for"]},{"entry":[{},"keyword \u03baand sent it to the host where the posting list for keyword \u03ba"]},{"entry":[{},"resides."]},{"entry":["SU, LU","Partition the posting list of \u03baon-the-fly and send it to all the hosts in the"]},{"entry":[{},"row where \u03bais stored."]},{"entry":["SU, LP","The posting list of \u03bais partitioned, but not the posting list of \u03ba. Thus one"]},{"entry":[{},"must partition the posting list of \u03baon-the-fly and send it to all the hosts in"]},{"entry":[{},"the row where \u03bais stored."]},{"entry":["SU, SP","There are two possibilities. If both the posting list of \u03baand a replica of the"]},{"entry":[{},"posting list \u03bareside on the same column, then perform the intersection"]},{"entry":[{},"locally at the host where the posting list of \u03baresides. Otherwise, either send"]},{"entry":[{},"any of the component-replicas of keyword \u03bato the host where \u03baresides or vice"]},{"entry":[{},"versa."]},{"entry":["LU, LU","The posting lists of both keywords are already partitioned (recall that they"]},{"entry":[{},"are partitioned using the same hashing function, a hash on the URL of the"]},{"entry":[{},"document). Thus one can intersect the corresponding component-replica; e.g."]},{"entry":[{},"the first component-replica of the posting list of keyword \u03bawith the first"]},{"entry":[{},"component-replica of the posting list of keyword \u03baand so on."]},{"entry":["LU, LP","There exists a row where a replica of both posting lists resides and the"]},{"entry":[{},"intersection of the partitions of the two posting lists can happen locally at"]},{"entry":[{},"each host of this row."]},{"entry":["LU, SP","Take any of the hosts where the posting list of \u03baresides, partition the"]},{"entry":[{},"posting list and send it to the row where the posting list of \u03bahas been"]},{"entry":[{},"partitioned."]},{"entry":["LP, LP","Note that for all LP keywords components and component-replicas have been"]},{"entry":[{},"created according to AllTheWeb Rows and Columns and thus query"]},{"entry":[{},"processing can proceed as in AllTheWeb Rows and Columns."]},{"entry":["LP, SP","Partition the posting list of \u03baand then send it to the hosts in one of the rows."]},{"entry":["SP, SP","If both posting lists already reside on the same column, then one can choose"]},{"entry":[{},"one of these hosts and perform the intersection locally. Otherwise, either"]},{"entry":[{},"send the posting list of \u03bato one of the hosts where the posting list of \u03ba"]},{"entry":[{},"resides, or vice versa."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Based on the instantiation framework as provided by the method of the present invention and discussed hereinabove, a few practical considerations will be outlined in the following.","Firstly, applying the method of the present invention allows an extension of the search system framework that permits each keyword to have more than a single row-and-column instance. This shall be described immediately below.","In the above-mentioned embodiments there has so far assumed that for each keyword \u03ba there are two functions numPartitions(\u03ba) and numReplicas(\u03ba). However, for performance reasons, one may partition with a keyword \u03ba in more than one way and possibly have a different number of replicas for the different partitionings. For example, in Two-Class Rows and Columns, the posting list for an SP keyword \u03bais replicated across one column. In addition to the current replication, the posting list of \u03bamight have been partitioned across one row, because \u03baoften co-occurs with a second LP keyword \u03bathat is partitioned across all rows.","This extension can be characterized by associating sets of functions from the resulting framework with each keyword applying the method of the invention; for example, a keyword \u03ba could have two sets of functions {numPartitions(\u03ba), numReplicas(\u03ba)} and {numPartitions(\u03ba), numReplicas(\u03ba)}. The number of sets could be keyword-dependent. This greatly increases the possible choices for query processing. However, this extension formally shall not be introduced formally herein since it is conceptually straightforward.","Secondly, a person skilled in the art shall realize that applying the method of the invention to creating frameworks for real search systems, including enterprise search systems, may allow for various optimizations thereof. Such optimizations shall take the method of the present invention as their point of departure, but their reduction of practice is considered to lie outside the scope of the present invention, and they shall hence not be elaborated further herein.","The method of the present invention realizes a framework for distributing the index of a search engine across several hosts in a computing cluster. The framework as disclosed distinguishes three orthogonal mechanisms for distributing a search index: Index partitioning, index replication, and assignment of replicas to hosts. Instantiations of these mechanisms yield different ways of distributing the index of a search engine, including popular methods from the literature and novel methods that by far outperform the prior art in terms of resource usage and performance while achieving the same level of fault tolerance.","Further the method of the present invention for the first time recognizes that different keywords and different documents in a search engine might have different properties (such as length or frequency of access). The framework realized by applying the method of the present invention creates a configuration of the index of a search engine according to these properties. The framework also serves to outline how to process queries for the space of configurations made possible by its realizations.","Instantiations of this framework moreover lead to existing index configurations disclosed in prior art as well as novel index configurations that are not possible in the prior art.",{"@attributes":{"id":"p-0119","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":["[ACPtNt95] Thomas E. Anderson, David E. Culler, David A. Patterson, and the NOW team. A case for NOW (networks of workstations). 15(l)54-64, February 1995.","[AM06] Vo Ngoc Anh and Alistair Moffat. Pruned query evaluation using pre-computed impacts. In Efthimis N. Efthimiadis, Susan T. Dumais, David Hawking, and Kalervo J\u00e4rvelin, editors, , pages 372-379. ACM, 2006.","[Bad01] C. S. Badue. Distributed query processing using partitioned inverted files. Master's thesis, Federal University of Minas Gerais, 2001.","[BCL06] Stefan B\u00fcttcher, Charles L. A. Clarke, and Brad Lushman. Hybrid index maintenance for growing text collections. In Efthimis N. Efthimiadis, Susan T. Dumais, David Hawking, and Kalervo J\u00e4rvelin, editors, , pages 356-363. ACM, 2006.","[BJRS03] Mayank Bawa, Roberto J. Bayardo Jr., Sridhar Rajagopalan, and Eugene J. Shekita. Make it fresh, make it quick: searching a network of personal webservers. In , pages 577-586, 2003.","[CAN02] Francisco Matias Cuenca-Acuna and Thu D. Nguyen. Text-based content search and retrieval in ad-hoc P2P communities. In Enrico Gregori, Ludmila Cherkasova, Gianpaolo Cugola, Fabio Panzieri, and Gian Pietro Picco, editors, NETWORKING Workshops, volume 2376 of , pages 220-234. Springer, 2002.","[CKE+90] Cringean, Janey K., Roger England, Manson, Gordon A., and Peter Willett. Parallel text searching in serial files using a processor farm. In , Access Methods, pages 429-453, 1990.","[CPD06] Soumen Chakrabarti, Kriti Puniyani, and Sujatha Das. Optimizing scoring functions and indexes for proximity search in type-annotated corpora. In Les Carr, David De Roure, Arun Iyengar, Carole A. Goble, and Michael Dahlin, editors, , pages 717-726. ACM, 2006.","[DEFS06] Pavel A. Dmitriev, Nadav Eiron, Marcus Fontoura, and Eugene J. Shekita. Using annotations in enterprise search. In Les Carr, David De Roure, Arun Iyengar, Carole A. Goble, and Michael Dahlin, editors, , pages 811-817. ACM, 2006.","[DGG+86] David J. DeWitt, Robert H. Gerber, Goetz Graefe, Michael L. Heytens, Krishna B. Kumar, and M. Muralikrishna. GAMMA\u2014A high performance dataflow database machine. In 12, pages 228-237, 1986.","[Fag99] Ronald Fagin. Combining fuzzy information from multiple systems. 58(1):83-99, 1999.","[JRMG06] Rosie Jones, Benjamin Rey, Omid Madani, and Wiley Greiner. Generating query substitutions. In Les Carr, David De Roure, Arun Iyengar, Carole A. Goble, and Michael Dahlin, editors, , pages 387-396. ACM, 2006.","[KCMK06] Reiner Kraft, Chi-Chao Chang, Farzin Maghoul, and Ravi Kumar. Searching with context. In Les Carr, David De Roure, Arun Iyengar, Carole A. Goble, and Michael Dahlin, editors, , pages 477-486. ACM, 2006.","[Kro02] Amr Z. Kronfol. FASD: A fault-tolerant, adaptive, scalable, distributed search engine, Dec. 20, 2002.","[LLH+03] Li, Loo, Hellerstein, Kaashoek, Karger, and Morris. On the feasibility of peer-to-peer web indexing and search. In --(), , volume 2, 2003.","[LLQ+07] Yu-Ting Liu, Tie-Yan Liu, Tao Qin, Zhi-Ming Ma, and Hang Li. Supervised rank aggregation. In , pages 481-489. ACM, 2007.","[LT1T07] Gang Luo, Chunqiang Tang, and Ying li Tian. Answering relationship queries on the web. In , pages 561-570. ACM, 2007.","[MMR00] Andy MacFarlane, Julie A. McCann, and Stephen E. Robertson. Parallel search using partitioned inverted files. In , pages 209-220, 2000.","[MR95] Rajeev Motwani and Prabhakar Raghavan. . Cambridge University Press, 1995.","[MWZ06] Alistair Moffat, William Webber, and Justin Zobel. Load balancing for term-distributed parallel retrieval. In Efthimis N. Efthimiadis, Susan T. Dumais, David Hawking, and Kalervo J\u00e4rvelin, editors, , pages 348-355. ACM, 2006.","[MYL02] Meng, Yu, and Liu. Building efficient and effective metasearch engines. 34, 2002.","[ODODG02] 1977 Omprakash D. (Omprakash Dev) Gnawali. A keyword-set search system for peer-to-peer networks. Master's thesis, Massachusetts Institute of Technology, Dept. of Electrical Engineering and Computer Science, 2002.","[PZSD96] Michael Persin, Justin Zobel, and Ron Sacks-Davis. Filtered document retrieval with frequency-sorted indexes. 47(10):749-764, 1996.","[RNB98] B. Ribeiro-Neto and R. Barbosa. Query performance for tightly coupled distributed digital libraries. In , pages 182-190, June 1998.","[RPB06] Matthew Richardson, Amit Prakash, and Eric Brill. Beyond pagerank: machine learning for static ranking. In Les Carr, David De Roure, Arun Iyengar, Carole A. Goble, and Michael Dahlin, editors, , pages 707-715. ACM, 2006.","[RV03] Patrick Reynolds and Amin Vahdat. Efficient peer-to-peer keyword searching. In Markus Endler and Douglas C. Schmidt, editors, , volume 2672 of , pages 21-40. Springer, 2003.","[SL02] Yipeng Shen and Dik Lun Lee. An MDP-based peer-to-peer search server network. In Tok Wang Ling, Umeshwar Dayal, Elisa Bertino, Wee Keong Ng, and Angela Goh, editors, , pages 269-278. IEEE Computer Society, 2002.","[SMwW+03] Torsten Suel, Chandan Mathur, Jo wenWu, Jiangong Zhang, Alex Delis, Mehdi Kharrazi, Xiaohui Long, and Kulesh Shanmugasundaram. ODISSEA: A peer-to-peer architecture for scalable web search and information retrieval. In Vassilis Christophides and Juliana Freire, editors, , pages 67-72, 2003.","[TD04] Chunqiang Tang and Sandhya Dwarkadas. Hybrid global-local indexing for efficient peer-to-peer information retrieval. In , pages 211-224. USENIX, 2004.","[TGM93] A. Tomasic and H. Garcia-Molina. Performance of inverted indices in shared-nothing distributed text document information retrieval systems [selected best paper]. In (PDIS '93), pages 8-17, Los Alamitos, Calif., USA, January 1993. IEEE Computer Society Press.","[TKT06] Taro Tezuka, Takeshi Kurashima, and Katsumi Tanaka. Toward tighter integration of web search with a geographic information system. In Les Carr, David De Roure, Arun Iyengar, Carole A. Goble, and Michael Dahlin, editors, , pages 277-286. ACM, 2006.","[TXD03] Chunqiang Tang, Zhichen Xu, and Sandhya Dwarkadas. Peer-to-peer information retrieval using self-organizing semantic overlay networks. In Anja Feldmann, Martina Zitterbart, Jon Crowcroft, and David Wetherall, editors, , pages 175-186. ACM, 2003.","[TXM03] Chunqiang Tang, Zhichen Xu, and Mallik Mahalingam. psearch: information retrieval in structured overlays. 33(1):89-94, 2003.","[YJ06] Beverly Yang and Glen Jeh. Retroactive answering of search queries. In Les Carr, David De Roure, Arun Jyengar, Carole A. Goble, and Michael Dahlin, editors, , pages 457-466. ACM, 2006.","[ZS07] Jiangong Zhang and Torsten Suel. Efficient search in large textual collections with redundancy. In , pages 411-420. ACM, 2007."]}}],"heading":["PRIOR ART","APPENDIX","References"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"p":["The present invention shall be better understood when the following detailed discussion of its general background and actual embodiments is read in conjunction with the appended drawing figures of which",{"@attributes":{"id":"p-0028","num":"0032"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0034"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0031","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0032","num":"0036"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0033","num":"0037"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
