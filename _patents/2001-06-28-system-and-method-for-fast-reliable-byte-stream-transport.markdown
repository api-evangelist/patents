---
title: System and method for fast, reliable byte stream transport
abstract: Reliable byte stream transfer protocols play an important role in modern networks. The present invention implements such a protocol using credits for flow control and negative acknowledgements for reliable delivery. The credit mechanism uses credit transfer in installments and is immune to the losses or corruptions of intermediate credit installments. Negative acknowledgements are used to solicit the retransmission of data stream component. The present invention provides full compatibility at the programming interface with reliable byte transfer protocols, such as TCP, and also allows full interoperability among hosts running the aforesaid standard protocol or the protocol of the present invention.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07305486&OS=07305486&RS=07305486
owner: 
number: 07305486
owner_city: 
owner_country: 
publication_date: 20010628
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","CONCLUSIONS, RAMIFACATIONS, AND SCOPE OF INVENTION"],"p":["This application claims priority from the following U.S. Provisional Application, the disclosure of which is incorporated herein by reference in its entirely for all purposes:","U.S. Provisional Patent Application Ser. No. 60\/215,337 in the name of Kanad Ghose and Peter Sulatycke, entitled, \u201cSystem and Method for Improving Reliable Byte Stream Transport Protocol Performance\u201d, filed Jun. 30, 2000.","This invention relates to digital packet transmission, and particularly to a method for fast, reliable byte stream transport in communication environments.","A computer network ties a number of computers, terminals and wireless devices together for the exchange of information. These computers, terminals and wireless devices are also called nodes of the network. The main protocol suite in use in computer networks, including the Internet, is TCP\/IP. TCP stands for Transmission Control Protocol and IP stands for Internet Protocol. The IP protocol suite provides point-to-point datagram delivery and is potentially unreliable. These protocols are defined by the Internet Engineering Task Force, specifications available at www.ietf.org. The TCP protocol runs on top of IP and implements reliable end-to-end delivery of byte streams between nodes. In addition, TCP has facilities in place to ensure the in-order, reliable delivery of information.","TCP's View of the Network","TCP is designed to cope with networks that are potentially unreliable. In fact, TCP makes the following assumptions about the network:\n\n","These assumed characteristics of the network have driven the features that are in today's TCP standard.","TCP's Artifacts for Coping with the Assumed Network Characteristics","To cope with these assumed characteristics of the network, TCP employs the following mechanisms to guarantee end-to-end reliable byte stream transport:\n\n","These mechanisms do not come for free: a substantial protocol overhead results when the above mechanism are used, manifesting in the form of high end-to-end delays.","Specifically, the overhead results from the following:\n\n","This protocol overhead severely limits the latency and bandwidth of networks. When TCP was originally developed the software overhead was very small compared to the overall time because networks speeds were slow. Today this has changed; the speed of modern networks has dramatically increased relative to the processing power of networking nodes. Thus TCP software overhead is now a significant portion of the overall end-to-end communication delay. This relative increase in software overhead severely restricts the performance of modern networks and prevents the full potential of networking hardware from being realized. Even with its poor latency characteristics, TCP remains the networking protocol of choice due to its support for client-server applications, large installed base and its compatibility with legacy code. In fact, compatibility is often even more important than performance. For example, modern low-latency technologies such as ATM, implement TCP on top of their native protocols just to gain compatibility with existing networking software. To exploit the capabilities of modern high-end networking hardware, it is essential to reduce the overhead in the TCP protocol.","Over the years, some of the inefficiencies of TCP have been recognized and a variety of improvements to the protocol have been suggested. Some of the techniques proposed for speeding up TCP have showed up as Requests for Comments (RFCs) with the Internet Engineering Task Force (IETF accessible at URL: http:\\\\www.ietf.org) and are fairly well-known. What follows is a summary of the more common approaches taken to improve TCP performance.\n\n","All of these mechanisms are piece-meal fixes to solve the inefficiencies associated with the windowing mechanism of TCP and thus have had limited success. None of these techniques reduce the overhead from TCP's windowing mechanism or retransmission timers. This overhead severely limits the latency and bandwidth of modern LANs. Thus there is a significant opportunity to design a reliable byte stream transport system that has significantly less overhead than TCP. In so doing, the full potential of modern low-latency network technologies can be attained.","One of main reasons for TCP's significant overhead is that its design is based on older unreliable network technology. Today's networking technologies are more reliable than the assumptions made by TCP. This is particularly the case in local area networks (LANs). In modern networking technologies, the following scenario exists:\n\n","Many of these scenarios are also valid for quality conscious switched networks larger than LANs. Thus it would be advantageous to take a more optimistic approach, consistent with the above observations for a modern networks, and provide a reliable byte stream transport system with less software overhead. This in turn would greatly improve end-to-end latency and effective bandwidth within modern networks.","It would also be advantageous to make this new transport system fully compliant with the current application programming interface (API) of TCP. This would allow all current client-server networking applications to run without any change or recompilation.","It would also be advantageous to provide a mechanism that can distinguish between packets meant for standard TCP and the new byte stream transport system and forward the data to the corresponding transport system. This would allow full interoperability with hosts running traditional TCP implementations or the new byte stream transport system.","Most efforts to improve TCP have been piecemeal. The real problem is in TCP's flow control windowing scheme, retransmit timeout mechanism and associated overhead. In accordance with the present invention, the TCP windowing scheme is abandoned in favor of a more efficient credit and NACK-based flow control mechanism.","Fundamental to this invention is the notion of using credits for flow control (i.e., the process of regulating data flow between the sender and receiver). Credits, also called buffer-to-buffer credits, are issued from the receiver to the sender prior to data transmission. Credits are indicative of buffer space available at the receiver for holding data received from the sender. The credit issued by a receiver to a sender indicates the amount of data the sender can transmit to the receiver safely without causing buffer overflows at the receiver. As soon as data sets corresponding to the credit issued by the receiver have been transmitted, the credits are considered to be consumed and further transmission stops until additional credits are received from the receiver.","Credits have been widely used at the link layer of ATM to control congestion and flow control. Credit-based flow control is also used by the Fibre Channel standard, as specified on the Fibre Channel committee's web site at the URL: http:\/\/www.fibrechannel.org. These credits mechanisms are mainly used at all intermediate nodes between a sender and receiver to reduce the effect of congestion.","In U.S. Pat. No. 5,432,824, \u201cCredit\/Rate-Based System for Controlling Traffic in a Digital Communication Network\u201d, Zheng et al. describes a combined credit and rate-based system to control traffic in a digital communication network. Credits are used to sense congestion along all the links, each link can modify the system. The credits in combination with congestion bit flags are used to control the sending rate.","In U.S. Pat. No. 4,475,192, \u201cData Packet Flow Control Scheme for Switching Networks\u201d, Fernow et al. describes another credit based system that uses credits to sense conditions along all link paths.","Additionally, in U.S. Pat. No. 5,528,591, \u201cEnd-To-End Credit-Based Flow Control System in a Digital Communication Network\u201d, a credit technique is used to reduce buffer requirements at intermediate ATM node buffers.","Unlike these systems, the present invention uses a credit mechanism for end-to-end flow control. Additionally, NAKs are used to indicate the necessary retransmission of lost or corrupted packets, while credits provide implicit acknowledgements. More information about ATM's use of credits can be found in, \u201cCredit-Based Flow Control for ATM Networks\u201d, by Kung et al., appearing in IEEE Network Magazine, Mar.\/Apr. 1995, pp. 40-48.","Instead of using the windowing mechanism and per-packet acknowledgements, which are standard for traditional TCP, the present invention uses buffer-to-buffer credits to implement flow control and negative acknowledgements to implement reliable delivery. Buffer credits sent explicitly to the sender from the receiver also function as implicit acknowledgements of bytes received successfully using credits received earlier.","The basic idea behind using buffer-to-buffer credits for implementing flow control is simple: as part of the connection setup, the initiator and responder exchange credits. Alternatively, credits may be exchanged after connection setup as a step distinct from the connection setup process but prior to the flow of any data bytes. A credit received by the initiator (or the responder) indicates the number of bytes that the initiator (or the responder) can send to the responder (or the initiator) before any acknowledgement\u2014either explicit or implicit\u2014arrives from the receiver. In essence, the credits are indicative of the buffer space available at the receiver. As bytes are transmitted, the credits on hand at the sending side are appropriately debited. If the credits available on hand drops to zero, the sender stops transmitting momentarily. Transmission resumes, as the credits are replenished explicitly with the arrival of a further round of credits from the receiver. These credits also serve as an implicit acknowledgement of the correct receipt of the bytes transmitted using the prior credit values.","A smooth flow is maintained by replenishing the senders credit (partially) before the credits on hand at the sending end are exhausted. If this is not done, the sender operates in a stop-and-go mode, seriously degrading the data flow rate. When packets are corrupted or lost, the receiver requests an explicit retransmission of the packets from the sender by sending one or more negative acknowledgements (NACKs) for the lost packets. When a predetermined number of NACKs are outstanding the transmission of available credits are reduced or delayed. This prevents excessive credits being sent when the quality of the communications link degrades, congestion occurs or when load problems occur at the receiver.","The present invention extends the use of credits and NACKs to simplify buffer management (allocation and deallocation) considerably at both ends. Credit management and buffer management in the present invention is considerably simpler, faster and smarter compared to the window and buffer management overhead of the standard TCP implementation: this is one of the factors that contribute in lowering the end-to-end latency and improving overall application-level performance. In the present invention, the credits issued by the receiver are used by the sender to transmit a sequence of bytes. To maintain a smooth flow of data between the sender and the receiver, credit installments (referred hereafter as \u201ccredit units\u201d) are sent from the receiver to the sender at predetermined instances in an attempt to ensure that the sender is not waiting for credit installments to continue sending data. The initial credit issued by the receiver as well as subsequent credit units each indicate a numbered range of bytes in the byte sequence that can be transmitted using that credit unit. The arrival of a credit unit from the receiver simply extends the range of bytes in the byte sequences (as indicated by prior credits) that the sender can transmit.","The present invention achieves the bulk of its performance gains through the use of the following mechanisms:\n\n","Additionally, the fact that the credit-based flow control is decoupled from the NACK retransmission mechanism improves performance and transmission responsiveness. This is quite unlike TCP, which tightly couples flow control and its retransmission mechanism together. The ACKs from TCP's retransmission mechanism are not only used for retransmission but also to modify the flow control's sliding window. This coupling degrades performance by complicating the system. Additionally, this coupling makes TCP slow to respond to the load of the receiver because its flow control is modified by feedback from ACKs. The present invention is much more responsive because its flow control is directly and quickly modified by credits instead of a feedback process.","Accordingly, several objects and advantages of the invention are:\n\n","It is noted, that while the present invention is particularly directed to improve the performance of the TCP protocol, there is nothing contained herein which would limit its use thereto. Any type of reliable byte stream transport protocol is amenable to processing in accordance with the system of the present invention. For example, this invention can replace the flow control and retransmission mechanism of any reliable byte stream transport protocol while maintaining the protocol's API compliance.","The invention described herein is a system that provides a reliable byte stream transport system that is significantly faster than TCP while being 100% API compliant with TCP. In addition, this invention provides full interoperability with traditional TCP implementations. This interoperability feature is optional and the transport protocol described in the invention can be used on its own. Hosts running the present invention within a LAN or larger networks that have the delivery characteristics of the modern LANs can exploit its full performance potential and at the same time they can also communicate with hosts that run traditional TCP, both within the LAN and outside the LAN. Note, that even though the present invention is integrated into the traditional TCP\/IP stack some one skilled in the art could easily integrate the present invention for implementing reliable transport using credits and NACKs into any reliable byte stream transport protocol. Similarly a person skilled in the art can also adapt the parallel stack scheme of the present invention to maintain compliance at the application level with a plurality of alternative implementations of reliable transport protocols.","A Generic Network Incorporating the Present Invention",{"@attributes":{"id":"p-0042","num":"0078"},"figref":"FIG. 1","b":["100","140","130","130"]},"all hosts within , such as  and ","all hosts within , such as  and ","all hosts between  and , such as  and ,  and ,  and ,  and ","The interconnect , can consist of any networking interconnect, including but not limited to: ethernet (shared media or switched), fibre channel, Myrinet, ATM or wireless. In addition, interconnect  can consist of any combination of networking interconnect technologies. Any given host within  or , may have multiple concurrent connections to other hosts within  or . This includes multiple independent connections to the same host, multiple connections to independent hosts or any combination of the two.","When the hosts within , such as  and , communicate with each other over interconnect  they use the standard TCP transport protocol. When the hosts within , such as  and , communicate with each over interconnect  they use the present invention. When the hosts within  communicate over interconnect  with the hosts within , the host within  uses TCP and the host within  uses the present invention. As will be shown in , even though the hosts within  use the present invention they are still able to communicate with the hosts within  that use TCP.","Connection Setup","Before hosts can send data between themselves they first must setup a connection. Connections in the present invention are duplex. The protocol described in this invention can also be adapted by a person skilled in the arts to half-duplex connections. In TCP this is done with a 3-way handshake between the two connecting hosts. The preferred embodiment of the present invention also uses the same 3-way handshake as TCP to setup connections. At connection time, the hosts indicate what reliable transport protocol they are running, such as, but not limited to, TCP or the present invention. This information is embedded in the headers during the connection setup exchange. Alternatively, the hosts may be statically preconfigured to indicate what protocols they are running. This information is then recorded for future reference. If both hosts are executing TCP, then they use TCP. If one host only has TCP and the other host has the present invention installed then the hosts use these respective methods. If both hosts have the present invention, then the present invention is used and an initial credit exchange is sent as part of the 3-way handshake. Credits are representative of the number of bytes available in the receiving buffers of a host. The initial credit amount sent is equal to a fraction of the receiving buffer size. Someone skilled in the art could easily use a different connection mechanism and credit exchange but this is the preferred approach because it is fully compliant with existing TCP implementations and imposes minimal changes on TCP.","Various packet types used in the credit and NACK-based protocol described in the present invention (such as, but not limited to: a packet containing data, a packet containing only credits, NACKs, packets containing embedded credits) are identified to the receiving side by using appropriate information within the packet header component specific to the aforesaid protocol or in other predetermined fields of the packet. Alternatively, unused fields within the header of standard protocols, such as TCP, can be used to contain part or all of packet identification information. Where part of the packet identification information is kept within unused fields in the header of the standard protocol, the remaining identification information can be kept within the header component specific to the credit and NACK-based protocol of the invention or in other predetermined fields of the packet.","Packet Flow Paths For Sending A Packet",{"@attributes":{"id":"p-0050","num":"0086"},"figref":["FIG. 2","FIG. 3","FIGS. 2 and 3","FIG. 2","FIG. 3"]},"The phrase \u201csending data bytes\u201d, \u201csending bytes\u201d, \u201ctransmitting bytes\u201d or \u201ctransmitting data bytes\u201d and their obvious variations as used in this document implies not only the transmission of the data bytes in question but also the transmission of additional information, such as headers or trailers or both, along with such data.",{"@attributes":{"id":"p-0052","num":"0088"},"figref":["FIG. 2","FIG. 2"],"b":["200","200","200","210","200","210"]},"Data from the higher-level send buffer  is then read by an outgoing packet filter . The outgoing packet filter  inspects the incoming data to determine which protocol stack should process the packet. If the outgoing data is destined for a host running TCP then outgoing packet filter  passes the packet to a standard TCP send stack . If the outgoing data is destined for a host running the present invention then the outgoing packet filter  passes the packet to the present invention's optimized send stack . Since each outgoing data is associated with a remote host that has already gone through the connection setup, the protocol used by the remote host is already known. Using this information, the outgoing packet filter  can easily determine if the packet should be sent to the standard TCP send stack  or the present invention's optimized send stack . The sending side puts in appropriate information within the header of the packet being sent to indicate to the receiving side what protocol stack is used to send out the packet. The receiving side uses this information to implement the packet filtering function shown in . This information can be embedded in the header in a variety of ways, including the use of unused flag fields in the standard header, the use of optional fields in the standard header or using specialized headers for the packets going down the optimized stack, with the specialized headers being interpreted through the use of preconfigured information about the connection.","If the data packet enters the standard TCP send stack , then the data packet is processed just as if the present invention were not in place and standard TCP were running. If the data packet enters the optimized send stack , then the data packet is processed by an optimized byte stream transport system that uses credits and NACKs without using a window-based flow control mechanism. This optimized send stack  will later be described in detail. The optimized send stack , the standard TCP send stack  and the outgoing packet filter  form what is commonly called a parallel stack; independent packets move in parallel down one of the two stacks. The parallel stack allows the present invention to communicate with hosts that have the present invention executing while also allowing communication with hosts that are just running TCP.","When the optimized send stack  and the standard TCP send stack  are finished processing their respective packets, they are sent to a common lower level send functions . The common lower level send functions  includes internet protocol (IP) and link level send functionality. The common lower level send function  is not new or part of the present invention. It currently exists in all TCP\/IP networked devices. The common lower level send function  then sends the packet data onto interconnect  and from there is will reach the remote host.","The present invention can be further enhanced by modifying the way checksums are computed during the sending of packets. In current TCP\/IP implementations checksum calculations are performed several times in the TCP and IP layers, often in a distributed fashion causing repeated data movements. For the present invention, TCP and IP checksums are both computed in one place, within the common lower level send functions . This conserves the amount of data movement in the course of checksum calculations. If the hardware frame checksum can be relied upon to detect data integrity, as in the case of LANs with minimal hops, checksumming can totally be eliminated. Thus the present invention abandons checksum computations for packets moving through the optimized send stack  when hardware frame checksum can be relied upon. Information is included in the headers of the packets exchanged during the connection setup to indicate when traditional TCP and IP checksums are abandoned in favor of the above described methods for performing checksums. For traffic coming down the standard TCP send stack , TCP and IP checksums are implemented as in standard TCP\/IP.","Packet Flow Paths For Receiving A Packet",{"@attributes":{"id":"p-0057","num":"0093"},"figref":["FIG. 3","FIG. 2"],"b":["130","300","300","300","300","310"]},"The incoming packet filter  is very similar to outgoing packet filter . The incoming packet filter  inspects incoming packets and determines which protocol receive stack should process the packets. If the packet is associated with a host that is using standard TCP for network communication then incoming packet filter  passes the packet to a standard receive TCP stack . If the packet is associated with a host running the present invention then the incoming packet filter  passes the packet to the present invention's optimized receive stack . As in the outgoing packet filter , the incoming packet filter  determines what the remote host is using by looking at information that was embedded in the packet header on the sending side, as described earlier.","The standard receive TCP stack  is not new or part of the present invention. It currently exists in all TCP\/IP networked devices. If the packet enters the standard TCP receive stack , then the packet is processed just as if the present invention were not in place and standard TCP was running instead. This allows a host that uses the present invention to communicate with hosts that are using just TCP. If the packet enters the present invention's optimized receive stack , then the packet is processed by the present invention's optimized byte stream transport system that uses credits and NACKs without using a window flow control mechanism. This optimized receive stack  will later be described in detail. The optimized receive stack  and the standard receive stack  form a parallel stack. The parallel stack allows the present invention to communicate with hosts that have the present invention executing while also allowing communication with hosts that are just running TCP.","When the optimized receive stack  and the standard TCP receive stack  are finished processing their respective packets, the resulting data is sent to a common higher level receive buffer . The common higher level receive buffer  usually resides in kernel memory but it also could possibly exist in user memory or network interface card (NIC) memory. A data receive operation  then receives data from the common higher level receive buffer . The data receive operation  is called from some process or thread. Separate packets may be associated with different processes or threads. As with the data send , all processes access the data receive operation  with the same API. The same API is used regardless of which stack, the optimized receive stack  or the standard TCP receive stack , processes the incoming packet. This enables the present invention to maintain 100% API compliance. Data receive operation  and higher-level receive buffer  currently exist in all TCP\/IP networked devices; they are not new or part of the present invention. They are just shown to clearly indicate how the present invention integrates with current networking software.","The present invention can be further enhanced by modifying the way checksums are computed during the receiving of packets. In current TCP\/IP implementations checksum calculations are performed several times in the TCP and IP layers, often in a distributed fashion causing repeated data movements. For the present invention, TCP and IP checksums are both computed in one place, within the common low level receive functions . This conserves the amount of data movement in the course of checksum calculations. If the hardware frame checksum can be relied upon to detect data integrity, as in the case of LANs with minimal hops, checksumming can totally be eliminated. Thus the present invention abandons checksum computations for packets moving through the optimized receive stack  when hardware frame checksum can be relied upon. Information is included in the headers of the packets exchanged during the connection setup to indicate when traditional TCP and IP checksums are abandoned in favor of the above described methods for performing checksums. If the checksum verification fails for any packet destined for the optimized receive stack  they are dropped prior to entry into that stack and the NACK generation process described later is directly invoked to speed up retransmission. For traffic coming up the standard receive TCP stack , TCP and IP checksums are implemented as in standard TCP\/IP.","Even though  and  depict the present invention within a parallel stack containing TCP, other protocol stacks could be used in place of TCP. This would enable the present invention to be 100% compatible with other communication protocols. Additionally, if it can be assumed the communicating nodes both contain the present invention, then the present invention does not have to function within the parallel stack to be API compliant with TCP. In this case, a single stack with only the present invention can be used. However, this condition can not always be guaranteed and thus the use of the parallel stack is preferred. This ensures that a communicating node containing the present convention can communicate with communicating nodes without the present invention.","The Reliable Transport Method: Optimized Sending and Receiving Functions","The present invention is a method for implementing a fast, reliable byte stream delivery that can be used within communicating protocols, as in TCP or other reliable byte stream transport protocols. In the communication system implemented by the present invention, there is the notion of a sending host and a receiving host. The sending host uses an already open connection to send a stream of consecutively numbered bytes to the receiving host. The data to be sent originates from an application and gets deposited into higher-level send buffer  (such as a socket buffer, in TCP) as a result of one or more calls to an application-level routine for sending the data. The data then gets moved from the high-level send buffer  within the sending host to the receiving host by a sending method. The sending method breaks down the data sequence in the higher level buffer into a series of packets. This part of the sending process is not new but provided by the existing functions within TCP. The formation of a packet also includes the addition of adding appropriate TCP header information and checksums for validating the integrity of a packet, using well-known methods, as in TCP. In the present invention, two sending stacks are used\u2014the standard TCP send stack  and the optimized send stack , as shown in  and as described earlier.  depicts the main steps in the optimized sending method (shown as the optimized send stack , in ) of the current invention. Header and checksum generation steps are excluded in this description because standard methods are used.","When the data arrives at the receiving host, the low level receive functions  and incoming packet filter  deliver the packets to a method that implements reliable, in-order delivery, called the receiving stack. The steps for validating the integrity of the packet (using methods such as checksum verification) is not shown in . This step is generally implemented as the first step of the receiving protocol using techniques that are well known. In the present invention, there are two receiving methods that implement reliable delivery in conjunction with methods at the sending host. One is the standard receive stack  and the other is the optimized receive stack  ().  depicts the main steps of the method of implementing the optimized receive stack  in the present invention. The steps of  deposit data received in packets in byte-order into the higher-level receive buffer  (such as a socket buffer in TCP). Data is retrieved from this buffer through data receive operation  by the application running on the receiving host. This is done through one or more calls to an application-level receiving routine.","In describing the optimized send stack  and the optimized receive stack  that implement reliable delivery in the present invention, the following terminology is used:","The term \u201creceived byte sequence\u201d or \u201csequence received\u201d or \u201csequence of received bytes\u201d all indicate the bytes received consecutively, starting with the first byte sent. It excludes bytes beyond the last byte in the sequence (i.e., the highest numbered byte in this sequence) that may have arrived before earlier bytes (i.e., lower numbered bytes) that are not part of the received sequence.","The term \u201cpacket\u201d refers to a group of consecutively numbered bytes that are grouped together and sent out as an indivisible unit by the reliable byte stream transport system at the sending side.","Hereafter, the term \u201csending process\u201d or \u201csending method\u201d describes the steps implemented in the optimized send stack  () of the present invention.","Also hereafter, the term \u201creceiving process\u201d or \u201creceiving method\u201d refers to the steps that implement the optimized receive stack  () of the present invention.","The terms \u201csender\u201d and \u201creceiver\u201d are also used to describe the entities that invoke (directly or indirectly) the sending and receiving processes, respectively.","In the present invention, data flow between the sender and receiver is regulated using credits for sending bytes that are issued from the receiver to the sender. For a given amount of credit issued to the sender by the receiver, the sender can send out a byte sequence whose length in bytes can be at most equal to the amount specified in the credits. Credits generally correspond to or are a function of the buffer space available at the receiver for holding incoming data. In the preferred embodiment of this invention, credits are in the form of a starting and ending byte. This enables the present invention to easily cope with lost credit installments. If a credit is lost, the sending node can infer the correct number of credits from the next credit installment.","As soon as a given number of consecutive bytes, with a given set of byte numbers, are transmitted from the sender to the receiver for the first time, the amount of credit held (in bytes) by the sender (maintained in a counter variable called \u201ccredits on hand\u201d) are decremented by the amount of bytes sent. If the same byte sequence is retransmitted (at a subsequent time), credits on hand is not impacted. Further credits, also called, \u201ccredit installments\u201d, to allow the sender to send further bytes beyond what was already sent, are sent from the receiver to the sender to maintain a smooth flow of data from the sender to the receiver. By delaying the sending of credit installments or by changing the byte range covered by a credit unit, the receiver can regulate the amount of data a sender can send. This mechanism can be used to cope with congestion in the network. Credit installments are generally piggybacked with data packets in the opposite direction. When traffic does not exist in the opposite direction or is momentarily absent, credit installments can be sent out using special control packets, as follows. These control packets do not require credits for transmission. For each connection, the receiver maintains a \u201ccredit installment generation timer\u201d (CIGT). This timer is initialized to some predetermined value initially and counts down to zero. After carrying out actions that are appropriate when the value of the CIGT falls to zero, this timer is reinitialized to a predetermined value, possibly different from the earlier one. In general, when this timer expires, and if credit installments can be given to the sender, the receiver sends the credit installment to the sender using a special control packet that does not require any credits on hand for transmission. A condition that causes credit installments not to be given to the sender can be the existence of network congestion as evidenced by, but not limited to, the generation of a predetermined number of NACKs (see below) during a predetermined time interval. ( describes how the expiration of the CIGT is handled.)","The present invention also uses \u201cnegative acknowledgements\u201d (also called NAKs or NACKs) to indicate the sender to retransmit one or more consecutive groups of data bytes, as one or more packets. Such NACKs are sent by the receiver when packets get lost or dropped (when they fail to pass the data integrity test) as control packets. The former case is explicitly shown in  while the latter case is not explicitly shown in the following figures because it occurs within the lower level receive functions  depicted in  (i.e. with the IP layer when TCP\/IP is used). In general, a single NACK from the receiver can solicit the contents of several consecutive packets from the sender. To simplify the implementation, it is useful to solicit the contents of exactly one packet using a unique NACK.","The sender maintains for each connection, a local variable, \u201clast_byte_sent\u201d, that records the number of the highest numbered byte it has sent thus far. This variable is used mainly for bookkeeping at the sending side. This is initialized appropriately at the time of establishing the connection.","For each connection, a receiver may set up and maintain one or more timers for each NACK it has sent to the sender. NACKs are sent as a special control packets. For such control packets, credits are not required by the receiver (from the sender) for sending the NACK. An obvious possibility is to piggyback NACKs with normal traffic in the reverse direction\u2014this is not the preferred option because of possible delays in transmission.","A receiver also maintains a variable, \u201cnew_bytes_received\u201d to record the amount of bytes it received in strict sequence of byte numbers since it sent out a credit installment to the sender. Bytes that are not part of the received sequence do not affect the value of this variable. The receiver also maintains a variable \u201clast_byte_received_in_sequence\u201d to record the number of the highest numbered byte it has received in sequence (without any missing bytes in-between) from the sender. This variable is used to determine the extent of bytes that were received strictly in sequence and also the absence of one or more bytes in the received sequence. The size of the credit installment (which can be static or adapted dynamically) is maintained in a counter variable \u201ccredit unit\u201d at the receiver.","Credit installments are also indirectly used to serve as an indirect acknowledgement for prior bytes that were successfully received in order. The sender uses this indirect acknowledgement to deallocate the prior bytes to free up buffer space at the sender. The overall flow control scheme may also use explicit acknowledgements sent on a periodic basis to inform the sender on the status of the transmitted packets. This feature is particularly useful in letting the sender know that the last fragments of a byte stream have been delivered properly to the receiver. A variety of standard and obvious implementations of such acknowledgements can be used. Such explicit acknowledgements can also be used to let the sending end know what data byte ranges can be safely dropped from retransmission buffers at the sending end since they do not have to be retransmitted. Credit installments are not sent out if there are pending NACKs for any bytes that will be deallocated by the sender on the receipt of the credit installment. A routine OK_to_send_credit is implemented by the receiver to determine if NACKs are outstanding for any bytes that will be acknowledged by the current credit installment being sent. If no such NACKs are outstanding, this function returns a true value (=yes) as an answer. This function may also be implemented to return a false value when congestion is present in the network, as evidenced, for instance, but not limited to, by the generation of a predetermined number of NACKs during a predetermined time interval.","There can be several variations in determining when credits should be generated and sent (corresponding to decision Step  or  in the descriptions given later). These variations can be but are not limited to, the following conditions under which credits can be generated and sent:\n\n","The main steps in the sending method are as shown in  and are now described in detail. This sending method starts out with Step  that takes a sequence of bytes delivered from outgoing packet filter  (of ). Step  also adds appropriate header information, leaving off data data integrity checking information, which are added within the common lower level send functions  (). In the next step, Step , the size of the data (say, s) in the data received in Step  is compared against the amount of credits on hand, stored in variable \u201ccredits_on_hand\u201d. If sufficient credits are unavailable (i.e., when s exceeds credits_on_hand), the transmission is deferred till credit installments arrive from the receiver. This deferment may be implemented either as a busy waiting loop or a operating system process suspension. The latter is the preferred option. If sufficient amount of credits are on hand for the sender, as tested in Step , credits_on_hand is decremented by the size of the data (s in this case) in Step . In Step , the \u201clast_byte_sent\u201d variable for the connection is updated by incrementing it by the size of the data. In Step , it is determined if traffic is moving in the opposite direction for possible piggybacking of credits. If no opposite traffic is occurring Step  is executed. Otherwise, the series of steps collectively shown as Step  are executed. If credits need to be sent for traffic in the opposite direction, Step  piggybacks credits on the outgoing traffic. This series of steps starts with Step , where a check is made to see if the value of new_bytes_received exceeds or equals the value of credit unit and if the routine OK_to_send_credits returns a true value. If this is the case, a credit unit is generated and piggybacked with the outgoing data packet (using Steps ,  and ). If the test of Step  fails, the sending method proceeds on to Step . Note that all of the variables within Step  are associated with the communication connection going in the opposite direction.","In Step , the credit_installment_generation timer is reset and restarted with an appropriate value. In Step , the amount of the credit installment, as main tained in the variable credit_unit, is piggybacked into the outgoing packet. The piggybacking involves not only the embedding of the value of the credit installment amount, but also the embedding of the address (sequence number) of the first byte expected to be sent using this credit installment. This can be done in a variety of ways, such as encoding of the value into the acknowledgement field specified in the standard TCP header with appropriate changes to the header flags or as an optional header or as a combination of both. The second approach is preferred. Finally, the credit installment piggybacking steps are completed in Step  by decrementing\/consuming new_bytes_received with the value in credit_units.","The sending process continues with Step  with the sending of the packet to the common lower layer protocol  (that do not implement reliable delivery). Processing then continues to Step . To allow this packet to be retransmitted at a later time when a NACK is received for the data bytes within this packet, the starting address of the bytes and the size of the packet is recorded in some appropriate data structure in the next step, Step . The completion of Step  terminates the sending method.","The Receiving Method","The steps of the receiving process are shown in . The receiving process of the present invention starts with Step , when the incoming packet filter  () hands over a packet to the optimized receive stack  (). Step  completes by evaluating the amount of data bytes in the packet in a variable s and processing continues to Step .","The steps for handling a piggybacked credit installment or credit only installment is collectively shown as Step  and comprises Steps , ,  and . In Step , a check is made to determine if the packet being processed contains a credit installment. If a credit installment is discovered, the value of credits_on_hand at the receiver is updated by incrementing it with the value of the credit_installment, as shown in step . The arrival of the credit installment also calls for the deallocation of packets sent earlier from the receiver in the opposite direction. This is implemented in Step , and processing continues with Step . Step  determines if the packet was a credit only installment. If the packet was a credit only packet the receive stack processing is complete. If the packet also contains data processing continues to Step . If Step  determines that the packet does not contain any credit installments, processing continues with Step . Note that steps with collective Step  are only executed if traffic is also occurring in the opposite direction. Thus the variables with Step  are associated with communication going in the opposite direction.","The deallocation of packets in Step  uses a simple rule to use the address of the first byte expected to be sent using the credit installment (that comes as part of the piggybacked information) as an indication of prior series of bytes received in order. There are several obvious ways of doing this. The preferred approach is to deallocate bytes numbered X through (X+CU\u22121) when the credit installment is received for sending bytes numbered (X+K) through (X+K+CU\u22121), where CU is the size of the credit unit and K is an appropriately chosen constant, either fixed or variable, dependent on the dynamics of the system. The value of K is chosen to regulate the data flow in the system and thus serves as one means for coping with any congestion in the system. Increasing the value of K effectively delays the arrival of credits for subsequent transmissions.","The series of steps collectively shown as Step  are processed when the packet arrives in order to extend the receive sequence. This occurs when the tests of Steps  and  fail. In Step , a test is made to determine if the arrival of the packet being processed does implies the loss of any prior bytes that were not known thus far as being lost. (For bytes known to be lost\u2014or delayed\u2014local data structures are maintained to record their identity.) If new bytes are not implied as missing, the processing continues with the next step, Step . In this step, a test is made to determine if any of data received was for an outstanding NACK. If no data was received for an outstanding NACK, as indicated by the failure of the test of Step , the packet being processed simply extend the received sequence, in which case the processing continues to Step  and then Step . In Step , the value of last_byte_received_in _sequence is incremented by the size of the packet. If both the tests of Steps  and  have failed, Step  updates the value of new_bytes_received with the size of the packet received and processing terminates with the deposition of the packet in the higher level receive buffer  () and the data in the packet is made accessible to the application on the receiving side, in Step .","If the arrival of the packet being processed implies the loss of other prior bytes that were not known to be lost, as ascertained by the test of Step , processing continues with Steps  and , which together collectively shown as Step  describe the generation of a NACK to the sender for these missing bytes. In this case, processing terminates after Step  with the deposition of the packet into the higher level buffer  (), in Step , with no new packets being made accessible to the application. This is because the packet being processed arrived before one or more prior expected packets. Step  sends out a NACK for the newly-discovered missing bytes and records this fact in some appropriate data structure. In Step , a NACK timer is added and started for the NACK sent. Further, for the NACK sent, a NACK counter is set to some fixed value, say N. If N NACKs have already been sent for a given range of missing bytes when the NACK timer expires, these bytes are considered permanently lost and the connection is reset, as described later in . For the case described in this paragraph, the processing terminates with the transfer of the packet being received into the higher level receive buffer  (), with no access given to the packet's content in the buffer from the higher level application.","If the test of Step  passes, the packet being received makes up part of a sequence of bytes that was already determined to be missing, and processing continues with Step . In Step , the NACK timer for the packet being processed and its associated counter are both removed and processing continues to Step . In Step , the system determines whether the arrival of the packet extends the length of the received sequence. If the received sequence is extended, then the last_byte_received_in_sequence is updated to the number of the last byte in the extension in Step . Processing then continues to Step , where new_bytes_received is updated with the size of the extension. Processing then continues to Step , where the packet being processed is moved into the higher level receive buffer  () and access to the bytes that extend the received sequence in this buffer is enabled to the application. If the arrival of the packet being processed did not extend the received sequence, as determined in Step , the packet is simply moved into the higher level receive buffer  () in Step , but its contents are not made accessible to the application.","Handling NACK Timeouts",{"@attributes":{"id":"p-0088","num":"0125"},"figref":["FIG. 6","FIG. 6"]},"In Step , a test is made to determine if any receiving process is in progress. If this is the case, further processing is deferred, in Step  until such receiving processes complete and processing continues with Step . If the test of Step  fails, processing continues with Step , in which a test is made to determine if the packets corresponding to the bytes in the missing packets arrived.","In Step , a test is made to determine if packets came in bearing the bytes indicated by the NACKs whose timers expired. If this test succeeds, processing continues with Step , otherwise; processing continues with Step . In Step , the NACK timers for the packets that arrived with missing bytes (including possibly, some timers that have not expired), are removed, along with their associated counter. Simultaneously, any queued interrupt events for any timer removed are cancelled. Processing then proceeds to Step  were it is determined if the arrival of the new packet(s) extend the length of the received sequence. If the received sequence is extended, then the last_byte_received_in_sequence is updated to the number of the last byte in the extension in Step . Additionally, new_bytes_received is updated with the size of the extension in Step . Processing then continues to Step , where the packet being processed is moved into the higher level receive buffer  () and access to the bytes that extend the received sequence in this buffer is enabled to the application. If the arrival of the packet being processed did not extend the received sequence, as determined in Step , processing moves to Step . In this case, the packet is simply moved into the higher level receive buffer  () in Step , but its contents are not made accessible to the application. Processing then continues with Step .","In Step , the NACK counter associated with the remaining NACK timers that expired are decremented by one. If any associated counter falls below zero, as tested in Step , this implies that N NACKs have already been sent out for the corresponding bytes and they did not result in the reception of such bytes. In that case, an error is signalled and the connection is reset, Step , terminating the handling of NACK timer expiration. If the decremented NACK counters are all higher than or equal to zero, as determined in Step , the corresponding NACKs are resent and the existing expired NACK timers are reset and restarted in Step . The processing completes with Step .","Processing the Arrival of a NACK","The steps involved in the processing of a NACK are described in . This starts with Step , which forms one or more packets with the missing bytes and appropriate headers. Processing then continues to and terminates with Step . In Step  the packets with the missing bytes are sent using a subset of the steps shown in , starting at Step , followed by the compound Step  and ending with Step . Steps , , ,  and  are ignored because credits are not needed to resend data that has been sent previously.","Processing the Credit Installment Generation Timer Expiration","The steps for handling the expiration of a credit installment generation timer is shown in . This begins with Step , which determines if credit installments can be sent, i.e., if new_bytes_received is higher than or equal to credit_unit and the routine OK_to_send_credits returns a true value. If a credit installment can be sent, processing continues with Step , otherwise it continues with Step . In Step , the credit installment and associated information is used to form a packet, which is then sent out as a control packet in Step . Processing then continues to Step . The sending of control packets is not regulated by credits.","In Step , which terminates the processing of the handling of the CIGT expiration, the credit_installment_generation_timer is reset and restarted.","Accordingly, the reader will see that the reliable byte stream transport system of this invention enables very low end-to-end latency between nodes in a communication network. The very low latency of this invention is directly attributable to its low software overhead from the use of credits and NACKs. The latency of this invention is so low that it is nearly identical to transport systems that do not guarantee reliable, in-order delivery of byte streams. Not only does this invention reduce latency but it also utilizes the available bandwidth within a communication link more effectively, enabling more data to be transferred at any given time. In addition, the parallel stack of this invention enables the present invention to be 100% API compliant with other protocols, especially TCP. This invention remains transparent to the TCP applications, which run without any change. At the same time it maintains full compliance with TCP connections that do not use the present invention. Thus enabling applications to communicate at a speed several times faster than what is achieved by conventional implementations of TCP, fully tapping the potentials of modern networking hardware. This invention has other unique advantages. Since the present invention has very low software overhead, CPU utilization of this invention is very low. This frees the CPU up for other important tasks. Load reduction is especially important with modern servers. Additionally, low CPU utilization means the present invention uses less power, making it ideal for mobile device with limited battery life.","Another distinct advantage of this invention is that it is well suited for communication networks of today and tomorrow. As network speeds continue to increase at a faster rate than the processing power of CPUs, low software overhead transport systems will become increasing important. Traditional transport systems, such as the sliding window mechanism in TCP, do not scale in performance with increasing network speeds.","Another advantage of this invention is that it is independent from the underlying physical network. For example, the present invention can run on top of Ethernet, Gigabit Ethernet, ATM, Fibre Channel and wireless-based networks, just to name a few. Wireless-based networks can support such devices as: PDAs, cellular phones and laptops.","While several presently preferred embodiments of the present novel invention have been described in detail herein, many modifications and variations will now become apparent to those skilled in the art. For example, there is not reason that the present invention can not be used with transport protocols other than TCP. The present invention can replace any reliable byte stream transport system of any protocol. This includes protocols specification that have not been defined to date. It is our intent therefore, to be limited only by the scope of the appending claims and not by the specific details presented by way of illustration.","Additionally, someone skilled in the art could easily build the present invention with minor changes in its software implementation. For example, instead of using a 3-way handshake method to establish a connection between communication nodes, any type of connection method can be used. Additionally, the manner in which initial credits are exchanged between the communication nodes can vary. In some cases, it is preferred to imbed the initial credits within the connection establishment method by using free fields. In other cases, it is preferred to exchange initial credits after connection establishment by sending a credit only transmission. In addition, an initial credit amount can be assumed by the receiver during connection establishment. Furthermore, initial transmission of bytes can start earlier by allowing a predetermined number of initial bytes to be sent without any credits present. This is possible because it can be assumed a receive buffer has a minimum amount of available storage.","In the present invention, the arrival of subsequent credit installments indirectly acknowledges the reception of data sent earlier by the sender. The sender can then deallocate the acknowledged data from its buffer. This is the preferred embodiment. An alternative embodiment will be to send explicit acknowledgements from the receiver to the sender, requiring the use of additional information to identify the explicit acknowledgement to the sending side.","In the present invention, the preferred embodiment is to give credits for the transmission of each bytes with each credit measure corresponding to a single byte. Some obvious variations would be to use a different measure for the credits where each credit measure corresponds to multiples or submultiples of bytes.","In addition, the manner in which credits are consumed at a sender node in this invention is not tied to decrementing a counter. Any method that consumes credits when the sender transmits bytes is represented in this invention. Furthermore, credits do not have to represent single bytes but can represent multiple bytes and even packets. Additionally, the amount of credits consumed by the sender is variable. Credits can be delayed or reduced if momentary congestion or communication errors are detected. For example, if a predetermined number of NACKs have been sent by the receiver, all transmissions of credits can be delayed until some of the missing packets are received.","Additionally, someone skilled in the art could easily implement the NACK mechanism so that NACKs represent more than one set of consecutive missing or corrupted bytes. In the preferred embodiment, NACKs represent only one set of consecutive missing or corrupted bytes. This is done to minimize the amount of software overhead."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0033","num":"0069"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0034","num":"0070"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0035","num":"0071"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0036","num":"0072"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0073"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0038","num":"0074"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0039","num":"0075"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0040","num":"0076"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
