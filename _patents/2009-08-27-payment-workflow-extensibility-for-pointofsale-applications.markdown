---
title: Payment workflow extensibility for point-of-sale applications
abstract: Architecture that employs a software development kit and an add-in model to collect payment data and communicate with payment processors in a point-of-sale (POS) application to meet new requirements in new markets. Data gathered from an add-in and from the POS application can be combined and then communicated to the payment processor. The payment method can be determined and payment processing routed to different payment processors based on data and schema of data collected is also described. An add-in can also programmatically obtain information from the POS application information about a transaction and authorize a payment. A payment collecting/processing API is the interface between the POS application tender logic and payment collecting/processing logic and defines how a payment collecting/processing add-in interacts with the POS application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08655733&OS=08655733&RS=08655733
owner: Microsoft Corporation
number: 08655733
owner_city: Redmond
owner_country: US
publication_date: 20090827
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["A point-of-sale (POS) application is typically used in retail stores to replace traditional cash registers. The POS application automates transaction processing from start to finish for various types of transactions such as sales, returns, work orders, layaways, and quotes. In addition, the POS application streamlines inventory management and reporting, makes it easy to track customer information, and maintains detailed customer history.","Payment data collecting and payment processing are core parts of retail sales transactions performed by a POS application. Within a POS application, the store owner can create a set of pre-defined payment methods and associate a set of supported hardware. Each payment method is pre-defined by payment format, an associated payment processor, and properties required by that payment processor. The payment format identifies a set of options applicable to a specific type of payment, such as payments toward customer accounts, cash payments, credit and debit card payments, check payments, vouchers payments, and others. For example, for a debit card payment format, the payment processor typically utilizes properties such as debit card number, expiration date, cash back limit, cash back fee, and a PIN. This is in contrast for a credit card payment format, where the payment processor usually utilizes properties such as, credit card number, expiration date, and credit card security code (e.g., CVV\u2014card verification value), etc.","Each supported piece of payment hardware gathers partial or all required properties for certain payment methods. For example, a PIN pad is designed to gather an encrypted PIN data block from the customer with using a keypad. A magnetic stripe reader (MSR) obtains credit card account and expiration date from the magnetic stripe attached to a plastic card when the customer swipes the card through the device. An intelligent combination (\u201ccombo\u201d) device, which has its own onboard workflow, can function as both an MSR and a PIN pad at the same time.","At specified times when no hardware is utilized, a retail application can prompt the cashier to manually input payment data in lieu of getting the payment data automatically from hardware. Once all required payment data is gathered, the retail application communicates the payment data and amount desired to the payment processor, and then receives payment authorization.","Payment format and payment processor requirements vary greatly from jurisdiction to jurisdiction and can change over time. The POS product needs to have the necessary built-in support for collecting payment data and communicating the payment data to the payment processors in each jurisdiction where the product will be used. However, as the product expands and serves retail businesses in new markets, there is currently no way for the POS product to support new payment requirements in the new markets without requiring a new release of the POS application.","The following presents a simplified summary in order to provide a basic understanding of some novel embodiments described herein. This summary is not an extensive overview, and it is not intended to identify key\/critical elements or to delineate the scope thereof. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.","The disclosed architecture provides extensibility in point-of-sale (POS) payment processing systems in support of changing conditions such as new hardware and software not originally considered in the product distribution. A software development kit (SDK) is included in the product distribution that facilitates the definition of one or more APIs (application programming interfaces) in the distribution and the creation of add-in modules in a POS application after distribution to meet new requirements in new markets by employing the add-ins for collecting payment data and communicating with a payment processor. The architecture also facilitates the ability to determine a payment method and route payment processing to different processors based on data and schema of the data collected, as well as for an add-in module to programmatically obtain from the POS application information about a transaction and then authorize payment.","The add-in modules are computer programs that support the collection of payment data from specific hardware and the proper formatting of the data according to payment processor requirements. The add-in modules can be developed by third-party developers for customized POS applications in markets not initially designed to support the out-of-box POS application. The disclosed add-in model provides longterm viability for the POS application after development and deployment since the add-in modules can thereafter provide the mechanism to support new payment formats, new hardware, and payment processors rather than updating the POS application itself.","To the accomplishment of the foregoing and related ends, certain illustrative aspects are described herein in connection with the following description and the annexed drawings. These aspects are indicative of the various ways in which the principles disclosed herein can be practiced and all aspects and equivalents thereof are intended to be within the scope of the claimed subject matter. Other advantages and novel features will become apparent from the following detailed description when considered in conjunction with the drawings.","The disclosed architecture describes methods that can be used during a transaction with or in a point-of-sale (POS) application through one or more add-in modules (also referred to herein as add-ins). An add-in is software (e.g., extension, plug-in, etc.) developed and implemented to interact with the POS application using an API (application programming interface). APIs can be developed utilizing a software development kit (SDK) that the disclosed architecture includes with the product distribution. An API can be developed and exposed via which the POS application can collect the desired payment data through a payment data collecting add-in, which can be a hardware or UI (user interface) add-in. Payment data are values for all the properties that define a payment format. A payment processor is an independent entity appointed by a merchant that verifies that the payment data that is collected by the merchant and relays the information back to the merchant about whether the process is successful or not. This verification process is sometimes referred as payment authorization (or settlement).","The POS application can communicate with different payment processor add-ins to obtain payment authorization, in addition to built-in functionality. The add-ins can be developed and deployed after the retail POS application is released. By doing so, payment collecting\/processing functionality can be expanded as desired when the retail application is sold in new markets that have different payment requirements, as well as different hardware support and processing requirements.","The extensibility can be realized in a payment data collection phase and\/or payment data authorization (or in-settlement) phase. Moreover, the different methods described herein allow extended payment data collection and\/or authorization functionality to work with each other or with pre-defined\/built-in payment data collection or authorization functionality in the POS application.","For example, a gift card scanner add-in and a gift card payment processor add-in can be developed and registered with the POS application using the aforementioned SDK APIs to support a gift card payment format. The payment format is a way to classify a payment into different categories, each of which has a definitive set of properties. For example, a credit card payment format can include properties such as credit card number, card holder name, expiration date, etc., while a check payment format can include properties such as check number, bank routing number, bank account number, etc. The gift card scanner add-in can be designed to communicate with a device that is connected with a computer via a hardware interface such as serial connector interface (e.g., USB-universal serial bus).","When a gift card in the form of a smartcard is inserted into the device, information such as account number, user name, and postal code, can be collected by the gift card scanner add-in and communicated to the POS application. The gift card payment processor add-in can be designed to communicate with a payment processor that issues the smartcard, maintains records of balance and transaction details, and provides a verification service.","When a transaction occurs with the POS application, and the customer elects to use the gift card as the payment method, payment data is collected and assembled with a transaction total and sent to the payment processor for authorization. The payment method is a way to define a relationship between the payment format and the payment processor. For example, a merchant can define a payment method called \u201cMerchant Credit Card\u201d, which accepts payment data of a credit card payment format, and then communicates the payment data to a Merchant payment processor for verification. As used herein, the phrase \u201cpayment processor\u201d is intended to mean a separate organization or entity that handles payment of a transaction. Accordingly, the Merchant payment processor is a separate organization that handles transaction payments for Merchant. Certain payment formats can be processed by more than one payment processor, such as credit card and debit card, while other payment formats can only be processed by a specific payment processor (e.g., a Merchant issued gift card).","Given that the POS application includes a generic set of interfaces to communicate with payment add-ins and a way to communicate errors to the end user, the POS application does not need to know the details about what payment data needs to be gathered for this particular payment processor and\/or how to support the hardware for this particular payment format.","Another example is where information is gathered without the participation of any add-ins, and the information is then processed through one or more payment processor add-ins.","Yet another example of typical process of payment collection and processing is where the POS application gathers standard track information from supported hardware, such as a magnetic stripe reader (MSR), when a consumer swipes a credit card through the MSR. The POS application can then further display a UI dialog for the cashier to fill in the credit card security information (e.g., CVV\u2014card verification value) obtained from the credit card. The POS application can then assemble the data gathered from both hardware and UI, and amount information from the current transaction into a predefined format for a payment processor and send the data to the payment processor backend to authorize the payment.","Still an example of a payment format specific to certain jurisdiction is a gift card that embeds data in a smartcard chip, which can only be scanned by a corresponding smartcard reader. The data on the card includes customer information, account number, etc., and can only be processed by a payment processor that provides service in that market. For this scenario, which may not apply to other geographic markets, it may not be desirable for the POS application to provide functionality that supports certain hardware and\/or payment formats.","Generally, the disclosed architecture provides the ability to employ an SDK and an add-in model to collect payment data and communicate with payment processors in the POS application to meet new requirements in new markets. Additionally, the architecture provides the ability to combine data gathered from an add-in and from the POS application, and then communicate with the payment processor. For example, an intelligent combination (\u201ccombo\u201d) device can be utilized that provides multiple different input mechanisms (e.g., MSR, PIN pad, etc.) for receiving user information in different formats such as account information, access code, confirmation input for a transaction, etc. These intelligent combo devices are typically facing the customer (\u201ccustomer-facing input device\u201d) so that the customer can swipe a card, input a code, and\/or provide a signature. These multi-function devices are referred to herein as hydra devices. The hydra device then communicates this customer input information in the different formats or a single format to the POS application. Since the hydra device employs multiple functionalities, the device interface to the POS application can employ more than one service object. The ability to determine the payment method and route payment processing to different payment processors based on data and schema of data collected is also described.","An add-in can also programmatically obtain transaction information from the POS application and authorize a payment. The payment processing API is the interface between the POS application tender logic and payment processing logic. The payment processing API defines how a payment processing add-in interacts with the POS application. The payment data collecting API is the interface between payment data collecting logic and the POS application tender logic. The payment data collecting API defines how a payment data collecting add-in interacts with the POS application.","Reference is now made to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding thereof. It may be evident, however, that the novel embodiments can be practiced without these specific details. In other instances, well known structures and devices are shown in block diagram form in order to facilitate a description thereof. The intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the claimed subject matter.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 1","b":["100","100","102","104","106","108","108","106","104","100","110","104"],"sub":"1-N"},"The add-in module  can be a payment collection module that collects the payment data from POS components (e.g., POS hardware, POS input software, etc.) and\/or via a UI. Alternatively, the add-in module  can be a payment authorization module that processes authorization of the payment data as part of the transaction. The add-in modules  can include the payment collection module and the payment authorization module, as well as other add-ins for supporting existing and new market requirements.","The POS application  generates POS data related to the transaction and the add-in module  can also generate add-in data related to the transaction. The POS data and the add-in data can be combined, formatted, and transmitted to a payment processor. The add-in module  can obtain transaction information (e.g., account, amount, etc.) from the POS application  and authorize payment based on the obtained transaction information.","The POS application  routes payment data to a specific payment processor based on add-in data of the add-in module  and a defined schema of the add-in data. The add-in module  registers with the POS application as a hardware add-in. The POS application  can execute the add-in module  based on a format of the payment data. Additionally, the add-in module  can communicate a portion of the transaction data of the transaction to a payment processor. These and other novel aspects are described in detail herein.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2","b":["200","106","200","102","104","106","108","200","202","104","204","104"]},"The POS application  generates POS data and the payment collection add-in module  generates add-in data. The POS data and the add-in data can be combined and transmitted to a payment processor by the POS application . The POS application  can route the payment data to a specific payment processor based on the add-in data and the schema of the add-in data. The POS application  executes the payment processing add-in module  based on the format of the payment data. The POS application  can also format the payment data according to a predefined payment data schema in response to selection of a payment method by a user.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3"},"In the POS application, a typical workflow that involves payment data collecting and processing is referred to as tender. In a transaction, tender occurs after all items a customer is about to purchase are added to the purchase list, and the total amount is then calculated. Once the total is calculated, the customer is able to select one or more payment methods available to make payment of the total. After the payment method and the amount to be paid by the payment method is set, the POS application then gathers the payment data for each payment method and verifies if the payment is valid. For cash payments, this can involve checking the authenticity of the bill. For a credit card payment method, this can involve gathering payment data from the UI\/hardware, and validating that the card holder has a sufficient account balance to pay the amount elected with a payment processor. Once all payment methods elected are verified, the tender completes successfully, and the transaction is posted.","The disclosed payment data collection portion of the transaction is extended through module add-ins. With a defined set of APIs now exposed by the POS application in accordance with the disclosed architecture, the POS application can host other computer programs which interact to provide the desired functions \u201con demand\u201d. For example, payment data can be collected by using an add-in, rather than the POS application itself.","A payment collecting add-in module can register with the POS application at setup. When needed, or during POS application startup, the add-in module can then be loaded. When a specific payment format indicates that payment data is to be collected by the payment add-in module, the add-in module is executed by POS application. The add-in module then communicates back to POS application with the information collected (the payment data of the specific payment format).","Alternatively, the payment collecting add-in module can also register with POS application as a hardware add-in. When the POS application starts and hardware attached to computer is scanned, the add-in module can be loaded and queried if the specific payment hardware is available. If so, and a specific payment format is indicated such that this particular hardware is used to gather the payment data, the add-in module is executed by POS application, and the data is collected and communicated to the POS application.","The hydra device is utilized in retail operations where the customer manually interacts to input personal information such as account and PIN, for example, and includes its own workflow. For example, the device stores its own workflow to allow the customer to select among several payment methods and, then make payment and provide a signature according to the selected method. In other words, the hydra device can integrate MSR, PIN pad, and signature functionality into one device, operate a program that guides a customer through a workflow, and allows the device to work with POS application.","The disclosed architecture facilitates integration of the hydra device or other similar devices into POS application through one or more add-in modules. Once the add-in module registers with the POS application, the module is queried at POS application startup to check if the hydra device is attached. If attached, at tender, a UI is presented to direct partial or full amount of total cost to the device. Using an API, the POS application can then communicate with the add-in module and send the amount to be charged to the device.","The device then presents and allows the customer to select a payment format to use (e.g., debit card, credit card, etc.), and gather payment data (e.g., card tracking information) using the built-in MSR or encrypted PIN block utilized with a built-in PIN pad. Once the payment data is gathered, the add-in module communicates back to the POS application. The POS application uses the payment data to determine what payment method to use and verifies with a payment processor that the payment method is approved. Once verified, the POS application notifies the add-in module of the result and collects the customer signature, if needed.","The disclosed architecture also provides a payment data schema. The payment data schema is a data schema that defines how the payment data is assembled and communicated between different parts of the POS application, such as payment collecting logic, POS tender logic, and payment processing logic. For example, an XML (extensible markup language) schema can include all the properties of the payment data as its elements, or a data class that includes all the properties of payment data as its members.","With one or more of the APIs and the payment data schema definition, an add-in module can communicate back which payment format the customer selected, and which payment method is to be used with that payment format. For example, an interface can be exposed that allows add-in module to query payment methods the POS application has setup, and allows an add-in to define the mapping between payment methods and payment format the POS application supports. The payment data schema defined can also detail which element to be used to communicate the customer selection for the payment method back to the POS application. An element of the payment data schema can also indicate how to interpret the payment data collected so that the POS application can understand and reformat data, if desired, to get the payment data verified with the payment processor.","In addition to a more complex device that includes its own workflow, an API can also be provided that supports extension of the payment data collection for simple devices or manual inputs. For example, the POS application usually has built-in support for reading track- and track- data from a credit card. An add-in module can be designed to read the additional information stored in track-. Once this add-in module is registered with the POS application to be used with a credit card payment format, all payment methods that have a credit card payment format can use this new add-in module to collect payment data, which includes information of the third track. An add-in module can be designed to directly communicate with the hardware and get track information. Alternatively, the add-in module can be a UI add-in and request manual input for the data of track-.","The POS application can also combine data from multiple sources to meet the requirements of a payment processor. For example, a hardware add-in can gather track information about a credit card, the POS application gathers the card security information from the UI, combines both information, and then sends the information to the credit card payment processor that uses the card security information for verification.","Another extension of a payment data collecting add-in module is to gather preset payment data with a token or password from a \u201cvirtual wallet\u201d. For example, a secure website can offer a web service to store payment data, such as a credit card number and track information details, which can be retrieved by a user ID and password pair. An add-in module can be developed by the website or third party to prompt the customer to enter the user ID and password on a secondary display, or self checkout kiosk, retrieve the payment data from the web service, and then communicate back to the POS application that hosts the add-in.","The workflow extended to include complex hardware add-ins and hardware\/UI add-ins for payment data collecting is illustrated in . More specifically, tender starts, and at , a calculation is made to determine if the total of all payment (PMT) methods equals the total requested. If not, at , another computation is made to determine if an add-in is to be used that supports multiple payment methods. If not, flow is to , the customer selects a payment method. At , the amount to be paid by the payment method is selected. At , a computation is made to determine if to use an add-in for payment collection. If so, flow is to  employ a hardware\/UI add-in to collect the payment data. Flow is then to  to send the amount and payment data to a payment processor. At , a computation is made to determine if the payment is authorized. If authorized, flow is back to  to process the next transaction. If payment is not authorized by the payment processor, flow is from  to  where the amount for this method is cleared. Flow is then back to  to process the next transaction.","At , if an add-in module is not to be used for payment data collection, flow is to  to collect the payment data via the hardware\/UI. Flow is then to  to send the amount and payment data to a payment processor. Going back to , the computation is made to determine if an add-in is to be used that supports multiple payment methods. If yes, flow is to  to set the subtotal for the add-in payment method. At , the payment method is selected. At , payment data is collected from the hardware\/UI. At , the selected payment method is mapped to a predefined payment method. Flow is then to  to send the amount and payment data to a payment processor. Flow then follows the previously described steps. At , the computation is made to determine if the total of all payment methods equals the total requested. If yes, the tender process can then end.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 4","b":["400","402","104","404","406","402","402","404","402","406","402","404","406","402"]},"When a transaction total is calculated and the user elects to send the amount to the device , the POS application  sends an amount request (e.g., ISetAmountRequest) with the specific amount to the device . Once the device  receives the request, the device  continues with its workflow and collects payment data. The workflow on the device  can involve the customer swiping a card, selecting the payment format, selecting a cash back amount, etc. Once the payment data is collected, the add-in module  sends an authorization response (e.g., IAuthorizationDataResponse) to the POS application . The POS application  gets the payment data from the authorization response and sends the payment data to a payment processor .","Once the payment processor  verifies the payment data, the POS application  relays the response back to the add-in module  via an authorization confirmation request (e.g., IAuthorizationConfirmationRequest). Depending on the result, the device workflow terminates or waits for a further request of the customer signature. If the POS application  determines that the payment format needs a signature, the POS application  sends a signature request (e.g., ISignatureRequest). Upon receiving the request, the add-in module  then collects the signature data and sends the signature data back to the POS application  via a response (e.g., ISignatureResponse).","The transaction is then posted, and a reset request (e.g., IResetRequest) is sent to the device  to re-initialize the device  for the next transaction. When the POS application  shuts down, the POS application sends a close request (e.g., ICloseRequest) to the device  to shut down the device .",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 5","b":["500","500"]},"The schema  is defined to include the following elements: SchemaGUID, which uniquely identifies that this schema is designed for a specific customer input device. An Amount element is the total that the customer elects to pay. A PaymentMethodCode element defines the payment method to use for this specific transaction. For example, the customer chooses the payment format on the device workflow. The add-in then maps the payment format to the specific POS payment method before sending the payment data to the POS application. Other elements can be provided, such as for track data (e.g., MSRTrackData), type of currency (e.g., CurrencyType), merchant number (e.g., MerchantNumber), transaction number (e.g., TransactionNumber), PIN pad number (e.g., PINPadNumber), cash back amount (e.g., CashBackAmount), any surcharge amount (e.g., SurchargeAmount), and encrypted PIN data (e.g., EncryptedPIN).","One way to send payment data from the add-in to the POS application is to define a data structure, such as a class, that holds certain data members. Another way is to define an XML schema and serialize the payment data into an XML data block. Once received, the POS application de-serializes the XML block and uses the data, as necessary.","The disclosed extensible architecture allows an add-in developer to define a custom payment data schema as long as the custom schema can be uniquely identified and there is mutual understanding of the schema between the payment data collection add-in and the payment processing add-in.","Following is a description of schema driven payment processor selection in a POS application. As previously described, payment data can be collected in different ways. The POS application is typically released with certain built-in support for commonly used hardware that can gather the payment data, such as the MSR for track data and PIN pad for encrypted pin block. Additionally, the POS application typically offers a UI that allows a user to gather payment data manually, as an alternative. This kind of UI can be a form that allows user to enter a credit card number and\/or CVV, for example.","By utilizing the disclosed add-in architecture in the POS application, the POS application can host different types of add-ins to gather payment data, such as a hydra device add-in that has its own workflow and allows payment data gathering for different payment methods, or a simple hardware\/UI add-in that does not include its own workflow. Note also that payment data can be collected via different techniques. The techniques can be combined to complement each other and meet payment processor requirements.","The POS application can also be distributed with built-in support for commonly used payment processors. In order to meet the need of new markets and new payment format requirements, the disclosed add-in API architecture can be defined so that the POS application can host add-ins to communicate with new payment processors that support new payment formats.","Following are example scenarios as to how a POS application can be designed to extend payment workflow with a payment data collection add-in and payment processing add-in.","In a first typical POS application with built-in hardware support, the POS application can gather credit card payment information, and using a standard UI, the POS application can collect the security code of the credit card by manual input from users. The POS application then sends the complete payment data to the payment processor associated with the payment method selected by the user.","In a second example scenario, a hardware add-in can be developed and registered with the POS application to read data from a formatted card (or generally, an input medium). Once the card data is gathered, a UI add-in or built-in UI from the POS application can further gather additional information for this payment format. The POS application then sends the complete payment data to the payment processor.","In a third example scenario, a hardware add-in can be developed to support the hydra device (e.g., customer-facing input device) and its device workflow. Using a predefined payment data schema, the POS application can communicate with the add-in to obtain the payment data and the payment method that map to the payment format selected by the user. The POS application can further interpret data, combine with payment data from other payment data collecting sources, format the payment data properly, and then send to the payment processor having a payment method indicated by data in the predefined schema.","In a fourth example scenario, a hardware add-in can be developed to support a newly emerging device on the market. In this example, there is no predefined payment data schema offered by the POS add-in architecture that describes all the payment data for certain payment format that can be gathered by this new device. However, the POS add-in architecture defines certain required elements for a payment data schema so that the POS application can differentiate predefined schema offered by POS add-in architecture from extended schema offered by a third party. For example, the POS application in this example can require that all third party schema has at least two elements, a SchemaGUID that uniquely identifies a payment data schema (regardless if defined by POS add-in architecture or third party), a PaymentMethod that identifies the payment method to be used for payment data formatted with this schema and an amount that indicates the total amount to be verified for this payment method.","A payment data schema, uniquely identified by a value for SchemaGUID, is co-defined and published by the hardware add-in developer and a payment processor. The payment processor or developer can offer a payment processor add-in that can understand the data collected by the hardware add-in and communicate the data to the payment processor for verification.","Once both add-ins register with the POS application, a new payment method is configured for the payment format described by the new device, and the payment processor add-in is employed. In addition, the hardware add-in will be setup so that when communicating with the POS application, the co-defined value is used for the SchemaGUID, and the payment method that uses the payment processor add-in is used for the PaymentMethod.","The POS application then loads the hardware add-in to gather payment data for the new device. The POS application then attempts to interpret the payment data gathered with the SchemaGUID that is a baseline for all payment data schema. Given that the payment data SchemaGUID does not match any predefined payment data schema, the POS application then passes the entire payment data to the designated payment method set by the PaymentMethod. Given that the payment method is configured to use the payment processing add-in that understands the payment data schema, the add-in then interprets the payment data and communicates with the payment processor for verification.","Note that it can be the case where the payment processing add-in determines that the payment data is incomplete. In this situation, the add-in can prompt user with for further input via the add-in UI.","In accordance with the disclosed architecture, a payment processing add-in can be developed for a specific payment format such as a customer account. In this example, however, there is no particular hardware requirement. Once this add-in is registered with the POS application, a new payment method can be configured for this payment format, which utilizes the add-in for verification.","During tender, the user can elect to use this payment method for payment. When selected, the POS application formats basic payment data using the predefined payment data schema, which in this example only includes two required elements (a SchemaGUID defined by the POS SDK and an Amount), and send the basic payment data to the payment processing add-in. Using the predefined SchemaGUID, the payment processing add-in recognizes that more payment data needs to be gathered. The add-in then prompts the user to input information that the payment processor requires, such as customer name, address, ID, etc. Alternatively, using an exposed SDK API, the add-in can query the customer data for the current transaction and construct the payment data without prompting the user for manual input.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 6","FIG. 7"],"b":["600","602","604","606","608","610","608","612"]},"Going back to , the computation is made to determine if an add-in is to be used that supports multiple payment methods. If not, flow is to  to set the subtotal for the add-in payment method. At , the payment method is selected. At , payment data is collected from the hardware\/UI. At , the selected payment method is mapped to a predefined payment method.","Flow from , , and  is then to , block , to determine if to use an internal payment method. If yes, flow is to  to deserialize the payment data. At , the payment amount and payment data collected is sent to the payment processor. At , a computation is made for authorization by the payment processor. If authorized, flow is to block  of . If not authorized, flow is from  to  to clear the amount for the payment method. Flow is then to block  of .","If not selecting an internal payment method, at , flow is to  to serialize the payment data. At , the payment data blob is sent to the payment processor add-in. At , the add-in collects additional payment information, if necessary. Flow is then to  or the authorization process, as previously described.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 8","b":["800","800","802","804","806","808","810","812","808","802","814","816","808","814"]},"The payment data can be combined and\/or reformatted via an associated process  for routing and processing by the built-in payment processor(s) . Alternatively, the payment data received from one or more of the add-in components  can be sent directly (without combining and\/or reformatting) to a payment processor add-in  (via an add-in API). Where the payment data from one of the add-in components  is incomplete or not present, payment information such as amount and\/or customer account  can be obtained from the POS application . Additionally, where the payment data passed to the payment processor add-in  is incomplete, additional payment information can be obtained via a payment collection UI .",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 9","b":["900","900","900","902","904","906"]},"To the credit card payment processor the payment method appears to be defined by the POS application. Similarly, to the debit card payment processor the payment method appears to be defined by the POS application. The POS application knows how to redirect the payment data collected. Moreover, based on the schema, the POS application determines that the payment is for a credit card or a debit card and sends the payment data to the mapped payment processor. In addition to credit card and debit card, other selectable payment options can include cash, check, card brand-, card brand-, gift certificate, store credit, open payment framework (OPF).","Following is sample payment data formatted as an XML data block according to a schema defined by the SDK, for example, the schema defined in .",{"@attributes":{"id":"p-0089","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\\ \u201c1.0\\\u201d encoding=\\\u201cutf-16\\\u201d?>"]},{"entry":[{},"<AuthorizationDataStructure"]},{"entry":[{},"xmlns:xsi=\\\u201chttp:\/\/www.w3.org\/2001\/XMLSchema-instance\\\u201d"]},{"entry":[{},"xmlns:xsd=\\\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\\\u201d>"]},{"entry":[{},"\u2003\u2003<SchemaGuid>AE9A41C4-8147-4b27-9690-7C05D67F7927<\/"]},{"entry":[{},"\u2003\u2003SchemaGuid>"]},{"entry":[{},"\u2003\u2003<AcquiringBankNumber>123456<\/AcquiringBankNumber>"]},{"entry":[{},"\u2003\u2003<Amount>10.9<\/Amount>"]},{"entry":[{},"\u2003\u2003<CashBackAmount>0<\/CashBackAmount>"]},{"entry":[{},"\u2003\u2003<SurchargeAmount>0<\/SurchargeAmount>"]},{"entry":[{},"\u2003\u2003<CurrencyType>123<\/CurrencyType>"]},{"entry":[{},"\u2003\u2003<EncryptedPin \/>"]},{"entry":[{},"\u2003\u2003<MerchantNumber>789012345678<\/MerchantNumber>"]},{"entry":[{},"\u2003\u2003<MsrTrackData1 \/>"]},{"entry":[{},"\u2003\u2003<MsrTrackData2>;xxxxxxxxxxxxxxxx=xxxxxxxxxxxxxxxx?<\/"]},{"entry":[{},"\u2003\u2003MsrTrackData2>"]},{"entry":[{},"\u2003\u2003<MsrTrackData3 \/>"]},{"entry":[{},"\u2003\u2003<MsrTrackData4 \/>"]},{"entry":[{},"\u2003\u2003<PinPadNumber>3456<\/PinPadNumber>"]},{"entry":[{},"\u2003\u2003<PosTransactionNumber>0002<\/PosTransactionNumber>"]},{"entry":[{},"\u2003\u2003<StandardIndustryClassification>7890<\/"]},{"entry":[{},"\u2003\u2003StandardIndustryClassification>"]},{"entry":[{},"\u2003\u2003<StoreNumber>9012<\/StoreNumber>"]},{"entry":[{},"\u2003\u2003<TerminalSerialNumber>00000001<\/Terminal SerialNumber>"]},{"entry":[{},"\u2003\u2003<TimeZone>900<\/TimeZone>"]},{"entry":[{},"\u2003\u2003<TransactionCode>20<\/TransactionCode>"]},{"entry":[{},"\u2003\u2003<ZipCode>45678<\/ZipCode>"]},{"entry":[{},"\u2003\u2003<PaymentMethodCode>Credit Card<\/PaymentMethodCode>"]},{"entry":[{},"\u2003\u2003<AdditionalSecurityInfo \/>"]},{"entry":[{},"<\/AuthorizationDataStructure>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Included herein is a set of flow charts representative of exemplary methodologies for performing novel aspects of the disclosed architecture. While, for purposes of simplicity of explanation, the one or more methodologies shown herein, for example, in the form of a flow chart or flow diagram, are shown and described as a series of acts, it is to be understood and appreciated that the methodologies are not limited by the order of acts, as some acts may, in accordance therewith, occur in a different order and\/or concurrently with other acts from that shown and described herein. For example, those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events, such as in a state diagram. Moreover, not all acts illustrated in a methodology may be required for a novel implementation.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 10","b":["1000","1002","1004"]},{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 11","FIG. 10"],"b":["1100","1102","1104","1106","1108","1110","1112"]},{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 12","FIG. 10"],"b":["1200","1202","1204","1206","1208","1210"]},"As used in this application, the terms \u201ccomponent\u201d and \u201csystem\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, a processor, a hard disk drive, multiple storage drives (of optical, solid state, and\/or magnetic storage medium), an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and\/or thread of execution, and a component can be localized on one computer and\/or distributed between two or more computers. The word \u201cexemplary\u201d may be used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs.","Referring now to , there is illustrated a block diagram of a computing system  operable to execute POS application extensibility in accordance with the disclosed architecture. In order to provide additional context for various aspects thereof,  and the following discussion are intended to provide a brief, general description of the suitable computing system  in which the various aspects can be implemented. While the description above is in the general context of computer-executable instructions that can run on one or more computers, those skilled in the art will recognize that a novel embodiment also can be implemented in combination with other program modules and\/or as a combination of hardware and software.","The computing system  for implementing various aspects includes the computer  having processing unit(s) , a system memory , and a system bus . The processing unit(s)  can be any of various commercially available processors such as single-processor, multi-processor, single-core units and multi-core units. Moreover, those skilled in the art will appreciate that the novel methods can be practiced with other computer system configurations, including minicomputers, mainframe computers, as well as personal computers (e.g., desktop, laptop, etc.), hand-held computing devices, microprocessor-based or programmable consumer electronics, and the like, each of which can be operatively coupled to one or more associated devices.","The system memory  can include volatile (VOL) memory  (e.g., random access memory (RAM)) and non-volatile memory (NON-VOL)  (e.g., ROM, EPROM, EEPROM, etc.). A basic input\/output system (BIOS) can be stored in the non-volatile memory , and includes the basic routines that facilitate the communication of data and signals between components within the computer , such as during startup. The volatile memory  can also include a high-speed RAM such as static RAM for caching data.","The system bus  provides an interface for system components including, but not limited to, the memory subsystem  to the processing unit(s) . The system bus  can be any of several types of bus structure that can further interconnect to a memory bus (with or without a memory controller), and a peripheral bus (e.g., PCI, PCIe, AGP, LPC, etc.), using any of a variety of commercially available bus architectures.","The computer  further includes storage subsystem(s)  and storage interface(s)  for interfacing the storage subsystem(s)  to the system bus  and other desired computer components. The storage subsystem(s)  can include one or more of a hard disk drive (HDD), a magnetic floppy disk drive (FDD), and\/or optical disk storage drive (e.g., a CD-ROM drive DVD drive), for example. The storage interface(s)  can include interface technologies such as EIDE, ATA, SATA, and IEEE 1394, for example.","One or more programs and data can be stored in the memory subsystem , a removable memory subsystem  (e.g., flash drive form factor technology), and\/or the storage subsystem(s)  (e.g., optical, magnetic, solid state), including an operating system , one or more application programs , other program modules , and program data .","The one or more application programs , other program modules , and program data  can include the modules, APIs, and components of the system  of , the modules, APIs, and components of the system  of , the API  of , the schema  of , the data flow  of , the hardware add-in UI  of , and the methods represented by the flow charts of , -, and -, for example.","Generally, programs include routines, methods, data structures, other software components, etc., that perform particular tasks or implement particular abstract data types. All or portions of the operating system , applications , modules , and\/or data  can also be cached in memory such as the volatile memory , for example. It is to be appreciated that the disclosed architecture can be implemented with various commercially available operating systems or combinations of operating systems (e.g., as virtual machines).","The storage subsystem(s)  and memory subsystems ( and ) serve as computer readable media for volatile and non-volatile storage of data, data structures, computer-executable instructions, and so forth. Computer readable media can be any available media that can be accessed by the computer  and includes volatile and non-volatile media, removable and non-removable media. For the computer , the media accommodate the storage of data in any suitable digital format. It should be appreciated by those skilled in the art that other types of computer readable media can be employed such as zip drives, magnetic tape, flash memory cards, cartridges, and the like, for storing computer executable instructions for performing the novel methods of the disclosed architecture.","A user can interact with the computer , programs, and data using external user input devices  such as a keyboard and a mouse. Other external user input devices  can include a microphone, an IR (infrared) remote control, a joystick, a game pad, camera recognition systems, a stylus pen, touch screen, gesture systems (e.g., eye movement, head movement, etc.), and\/or the like. The user can interact with the computer , programs, and data using onboard user input devices  such a touchpad, microphone, keyboard, etc., where the computer  is a portable computer, for example. These and other input devices are connected to the processing unit(s)  through input\/output (I\/O) device interface(s)  via the system bus , but can be connected by other interfaces such as a parallel port, IEEE 1394 serial port, a game port, a USB port, an IR interface, etc. The I\/O device interface(s)  also facilitate the use of output peripherals  such as printers, audio devices, camera devices, and so on, such as a sound card and\/or onboard audio processing capability.","One or more graphics interface(s)  (also commonly referred to as a graphics processing unit (GPU)) provide graphics and video signals between the computer  and external display(s)  (e.g., LCD, plasma) and\/or onboard displays  (e.g., for portable computer). The graphics interface(s)  can also be manufactured as part of the computer system board.","The computer  can operate in a networked environment (e.g., IP-based) using logical connections via a wired\/wireless communications subsystem  to one or more networks and\/or other computers. The other computers can include workstations, servers, routers, personal computers, microprocessor-based entertainment appliances, peer devices or other common network nodes, and typically include many or all of the elements described relative to the computer . The logical connections can include wired\/wireless connectivity to a local area network (LAN), a wide area network (WAN), hotspot, and so on. LAN and WAN networking environments are commonplace in offices and companies and facilitate enterprise-wide computer networks, such as intranets, all of which may connect to a global communications network such as the Internet.","When used in a networking environment the computer  connects to the network via a wired\/wireless communication subsystem  (e.g., a network interface adapter, onboard transceiver subsystem, etc.) to communicate with wired\/wireless networks, wired\/wireless printers, wired\/wireless input devices , and so on. The computer  can include a modem or other means for establishing communications over the network. In a networked environment, programs and data relative to the computer  can be stored in the remote memory\/storage device, as is associated with a distributed system. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.","The computer  is operable to communicate with wired\/wireless devices or entities using the radio technologies such as the IEEE 802.xx family of standards, such as wireless devices operatively disposed in wireless communication (e.g., IEEE 802.11 over-the-air modulation techniques) with, for example, a printer, scanner, desktop and\/or portable computer, personal digital assistant (PDA), communications satellite, any piece of equipment or location associated with a wirelessly detectable tag (e.g., a kiosk, news stand, restroom), and telephone. This includes at least Wi-Fi (or Wireless Fidelity) for hotspots, WiMax, and Bluetooth\u2122 wireless technologies. Thus, the communications can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices. Wi-Fi networks use radio technologies called IEEE 802.11x (a, b, g, etc.) to provide secure, reliable, fast wireless connectivity. A Wi-Fi network can be used to connect computers to each other, to the Internet, and to wire networks (which use IEEE 802.3-related media and functions).","Referring now to , there is illustrated a schematic block diagram of a computing environment  that supports payment workflow extensibility. The environment  includes one or more client(s) . The client(s)  can be hardware and\/or software (e.g., threads, processes, computing devices). The client(s)  can house cookie(s) and\/or associated contextual information, for example.","The environment  also includes one or more server(s) . The server(s)  can also be hardware and\/or software (e.g., threads, processes, computing devices). The servers  can house threads to perform transformations by employing the architecture, for example. One possible communication between a client  and a server  can be in the form of a data packet adapted to be transmitted between two or more computer processes. The data packet may include a cookie and\/or associated contextual information, for example. The environment  includes a communication framework  (e.g., a global communication network such as the Internet) that can be employed to facilitate communications between the client(s)  and the server(s) .","Communications can be facilitated via a wire (including optical fiber) and\/or wireless technology. The client(s)  are operatively connected to one or more client data store(s)  that can be employed to store information local to the client(s)  (e.g., cookie(s) and\/or associated contextual information). Similarly, the server(s)  are operatively connected to one or more server data store(s)  that can be employed to store information local to the servers .","What has been described above includes examples of the disclosed architecture. It is, of course, not possible to describe every conceivable combination of components and\/or methodologies, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the novel architecture is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 6","FIG. 7"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 12","FIG. 10"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
