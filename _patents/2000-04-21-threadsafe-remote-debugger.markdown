---
title: Thread-safe remote debugger
abstract: A thread-safe debugging system and method including a thread-safe debug service library and a thread-safe remote control library residing on at least one client computer system. The client and server libraries provide APIs which allow multi-threaded applications executing on the client computer system to take advantage of debug services in a thread-safe and dynamic manner. The remote control library provides third party applications the capability to initiate and manage the debug services on the client dynamically and remotely. The debug services may include providing debug output, listing the one or more debug objects in the multi-threaded application, listing the state of each debug object, turning on or off any debug object by name or pattern, directing the debug output to a remote location, allowing multiple remote diagnostic applications to view the debug output of the application, and logging statistical or performance information. The debug print function provides debug output for one or more threads of the multi-threaded application such that the debug output of each thread remains distinct from the debug output of the other threads. Thread safety may be ensured through the use of thread-safe mechanisms such as locks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07779390&OS=07779390&RS=07779390
owner: Oracle America, Inc.
number: 07779390
owner_city: Redwood City
owner_country: US
publication_date: 20000421
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF SEVERAL EMBODIMENTS","FIG. ","A Typical Computer System","FIG. ","A Computer Network","FIG. ","A Thread-Safe Debugging System","FIG. ","A Thread-Safe Debugging System Including Debug Objects","FIG. ","A Thread-Safe Debugging System"],"p":["1. Field of the Invention","The present invention relates generally to computer software. More particularly, the present invention relates to software for debugging computer programs.","2. Description of the Relevant Art","The field of network management involves the management of networked devices, often remotely. A computer network is a linked group of two or more computers. Generally, networks may be classified as Local-Area Networks (LANs) or Wide-Area Networks (WANs). In a LAN, the computers or devices are typically connected together within a \u201clocal\u201d area such as a home, office, or group of offices. In a WAN, the computers or devices are typically separated by a greater distance and are often connected via telephone\/communication lines, radio waves, or other suitable means of connection.","Networks are usually classified using three properties: topology, protocol, and architecture. Topology specifies the geometric arrangement of the network. Common topologies are bus, ring, and star configurations. A network's protocol specifies a common set of rules and\/or signals, such as Ethernet or Token Ring, which the networked devices use to communicate with each other. A network's architecture typically specifies one of the two major types of network architecture: peer-to-peer or client\/server. In a peer-to-peer networking configuration, there is no server, and computers simply connect with each other in a workgroup to share files, printers, services, and Internet access. Client\/server networks often include a domain controller to which all of the networked computers log on. This server may provide various services such as centrally routed Internet access, e-mail, file sharing, printer access, and security services.","Many types of devices may be managed over a network, such as printers, scanners, phone systems, copiers, and many other devices and appliances configured for network operation. Typically, such devices are managed via requests and events. A request is a message sent to a managed object. A request may be sent by a manager application to a managed object to query the object about a particular parameter associated with the object. A request may also be sent to a managed object to modify a parameter of the object. Alternately, an event is a message originating with a managed object. Events may be sent by managed objects to signal some change of state of the managed object, or to communicate information about the managed object. Managing such devices tends to require that the data types of each device's control parameters and signals be well defined. For example, a networked printer might have a Boolean status parameter which indicates whether the device is currently on or off and a control parameter which turns the printer on or off. A manager application may send a request to determine the on\/off status of the printer. Then, once the status is determined, say, to be off, a subsequent request may be sent to modify the control parameter to turn the printer on. The printer may also be capable of generating an alert signal indicating, for example, that the toner level is low. In this case, an event communicating that fact may be sent by the managed object (the printer) to the appropriate manager application.","The network management software should be able to read and write these data correctly in order to manage the device. To do this, information about the data is required. Such information is referred to as metadata, or \u201cdata about data.\u201d Metadata may typically describe what type of data (string, integer, Boolean, structure) an object has and how the data are formatted. Metadata is essential for understanding information related to managed devices, as well as information stored in data warehouses. Typically, network management software manages a given device by storing and manipulating a representation of its pertinent data as a software object, herein referred to as a \u201cmanaged object.\u201d This object is the virtual representation of the device on the network.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 1","FIG. 1"],"i":["a ","a","a","a","b","n","b","a","a","b","n"],"b":["156","151","152","153","154","155","108","150","170","160","150","170","171","171","171","160","170","108","150","108","160","161","161","161","160","170","160","150"]},"One TMN approach to managing objects over a network is the Simple Network Management Protocol (SNMP), a set of protocols for managing complex networks. SNMP works by sending messages, called protocol data units (PDUs), to different parts of a network. SNMP-compliant devices, called agents, store data about themselves in Management Information Bases (MIBs) and return this data to the SNMP requesters. The metadata used by SNMP to describe managed object data variables includes the variable title, the data type of the variable (e.g. integer, string), whether the variable is read-only or read-write, and the value of the variable. SNMP works over the TCP\/IP (Transport Control Protocol\/Internet Protocol) communication stack. SNMP also uses UDP over IP, and also may support TCP over IP. It is widely held, however, that SNMP was developed as a simple \u201cquick fix\u201d and was never intended to be a permanent solution to network management. Consequently, one problem with SNMP is that the information it specifies is neither detailed nor well-organized enough to adequately serve the expanding needs of modern networking.","Another example of a TMN network management protocol is the Common Management Information Protocol (CMIP). In the U.S. the CMIP protocol is primarily run over TCP\/IP, while in Europe it is generally run over the OSI (Open Systems Interconnection) communication stack and was designed to replace SNMP and address SNMP's shortcomings by providing a larger, more detailed network manager. Its basic design is similar to SNMP: Management requests, management responses, and notifications are employed to monitor a network. These correspond to SNMP's PDUs. CMIP, however, contains eleven types of messages, compared to SNMP's five types of PDUs.","In CMIP, variables are seen as complex and sophisticated data structures with many attributes. These include: variable attributes, which represent the variable's characteristics (e.g., its data type, whether it is writable); variable behaviors, or the actions of that variable that can be triggered; and notifications, or event reports generated by the variable whenever a specified event occurs (e.g., a terminal shutdown would cause a variable notification event).","As a comparison, SNMP only employs variable attributes and notifications, but not variable behaviors. One of the strongest features of the CMIP protocol is that its variables not only relay information to and from the terminal (as in SNMP), but they can also be used to perform tasks that would be impossible under SNMP. For instance, if a terminal on a network cannot reach its fileserver for a predetermined number of tries, then CMIP can notify the appropriate personnel of the event. With SNMP, a user would need to explicitly keep track of the number of unsuccessful attempts to reach the fileserver. CMIP thus results in a more efficient network management system, as less work is required by a user to keep updated on the status of the network.","A significant disadvantage of the CMIP protocol is that it requires more system resources than SNMP, often by a factor of ten. Thus, any move to CMIP from SNMP requires a dramatic upgrade in network resources. Another disadvantage with CMIP is that it is very difficult to program; the variable metadata includes so many different components that few programmers are generally able to use the variables to their full potential.","Both of the above protocols have been implemented in a number of programming languages, such as C, C++, and Java\u2122. However, network management software which takes advantage of SNMP or CMIP must be written specifically for the language of the protocol implementation. In other words, SNMP-based and CMIP-based network management software is dependent upon a particular programming language and protocol implementation.","GDMO (Guidelines for Definition of Managed Objects) is a standard for defining objects in a network in a consistent way. With a consistent \u201clanguage\u201d for describing such objects as workstations, LAN servers, and switches, programs can be written to control or sense the status of network elements throughout a network. GDMO prescribes how a network product manufacturer must describe the product formally so that others can write programs that recognize and deal with the product. Using GDMO with ASN1, descriptions may be made of the class or classes of the object, how the object behaves, its attributes, and classes that it may inherit.","GDMO is part of the CMIP and also the guideline for defining network objects under TMN. The object definitions created using GDMO and related tools form a Management Information Base (MIB). GDMO uses Abstract Syntax Notation One (ASN1) as the rules for syntax and attribute encoding when defining the objects. Abstract Syntax Notation One is a language that defines the way data is sent across dissimilar communication systems. ASN1 ensures that the data received is the same as the data transmitted by providing a common syntax for specifying application layer (e.g., program-to-program communications) protocols. Each communications system contains a similar ASN1 encoding\/decoding scheme written in the language used on that particular system. When one system wants to send data to another, the first system encodes the data into ASN1, sends the data, and the second system receives and decodes the data using the decoder written in the language used on that system.","In response to the difficulties presented by SNMP and CMIP, the Object Management Group (OMG) and Joint Inter-Domain Management (JIDM) have defined Interface Definition Language (IDL) for network management, which is used to access object instance data and may be used across a plurality of programming languages and across a plurality of platforms. JIDM IDL allows programmers to write only one set of interfaces for a particular object across multiple programming languages, rather than having to write a new set of interfaces for each programming language.","A middleware standard used extensively in network management is the Common Object Request Broker Architecture (CORBA), which is provided by the Object Management Group (OMG). CORBA specifies a system that provides interoperability between objects in a heterogeneous, distributed environment and in a way transparent to the programmer. Its design is based on the OMG Object Model, which defines common object semantics for specifying the externally visible characteristics of objects in a standard and implementation-independent way. In this model, clients request services from objects (which will also be called servers) through a well-defined interface. This interface is specified in the OMG Interface Definition Language (IDL).","In CORBA, a client accesses an object by issuing a request to the object. The request is an event, and it carries information including an operation, the object reference of the service provider, and actual parameters, if any. The object reference is an object name that reliably defines an object.","A central component of CORBA is the Object Request Broker (ORB). The ORB encompasses the communication infrastructure necessary to identify and locate objects, handle connection management, and deliver data. In general, the ORB is not required to be a single component; it is simply defined by its interfaces. The basic functionality provided by the ORB includes passing the requests from clients to the object implementations on which they are invoked. The ORB acts as the middleware between clients and servers. In the CORBA model, a client can request a service without knowing anything about what servers are attached to the network. The various ORBs receive the requests, forward them to the appropriate servers, and then hand the results back to the client.","In CORBA, a client first looks up the object (server) it wants to communicate with. The ORB, as a result of the lookup operation, returns an object reference (a handle) of the server to the client. The client then uses the object reference to invoke operations on the object as a function call in the chosen programming language. The ORB intercepts the client request, collects the information about the operation and the request parameter values, encodes it in IIOP, and sends it to the object (server). The ORB on the object side (server) translates the request into a programming language specific function call on the server object. The server object then processes the request and returns a response, if any. The ORB intercepts the response, encodes the response and its parameters into IIOP, and sends it to the client. The ORB on the client side then returns the response to the client as the return value of the function call originally made as part of issuing the request.","In many cases, CORBA gateways to specific services may be developed to manage specific network traffic, such as requests and events. Typically, these gateways are designed as single-threaded programs. However, increasingly, the benefits of multi-threading are desired for applications and server programs related to network management.","Multi-Threaded Applications","A thread is an encapsulation of the flow of control in a program. Most programs are single-threaded; they only execute one path through their code at a time. Multi-threaded programs may have several threads running through different code paths simultaneously. Multi-threading typically means sharing a single CPU between multiple threads in a way designed to minimize the time required to switch threads. This is accomplished by sharing as much as possible of the program execution environment between the different threads so that very little state needs to be saved and restored when changing threads. Furthermore, if a computer has multiple CPUs and a program has multiple threads, multiple threads of the program may be run on separate CPUs concurrently. Thus multi-threading allows applications to scale with the number of CPUs, as well.","Multi-threading differs from multi-tasking in that threads share more of their environment with each other than do tasks under multi-tasking. Threads may be distinguished only by the value of their program counters and stack pointers while sharing a single address space and set of global variables. Often, there is very little protection of one thread from another, in contrast to multi-tasking. Multi-threading can thus be used for very fine-grained multi-tasking at the level of a few instructions and therefore can hide latency by keeping the processor busy after one thread issues a long-latency instruction on which subsequent instructions in that thread depend.","In a typical process in which multiple threads are used, zero or more threads may actually be running at any one time. This depends on the number of CPUs used by the computer on which the process is running, and also on how the threads system is implemented. A machine with n CPUs may run no more than n threads in parallel, but it may give the appearance of running many more than n threads simultaneously by sharing the CPUs among threads.","A context switch between two threads in a single process is considerably more efficient than a context switch between two processes. In addition, the fact that all data except for stack and registers are shared between threads makes them a natural vehicle for expressing tasks that may be broken down into subtasks that may be run cooperatively. Global variables and resources are shared between threads within the same process. Each thread has its own stack.","In many ways, the use of threads provides benefits over the use of processes in that threads are more efficient to create, switching between threads in the same process is much more efficient than switching processes, and there is easier sharing of resources between threads. Context switching among threads is very efficient in that there are no page or segment table manipulations, no flushing of the associative memory cache (when switching among threads sharing an address space), and no copying of data when exchanging messages among threads of the same address space.","As used herein, \u201cthread-safe\u201d refers to the property that a program may safely use or be used by multiple threads to avoid, for example, data inconsistencies, access collisions, coherency problems, and other errors. When multiple threads share resources, access to the resources should be synchronized to ensure thread-safety. One way this may be accomplished is through the use of a mutual exclusion (mutex) object. A mutual exclusion object allows multiple threads to synchronize access to shared resources. A mutex has two states: locked and unlocked. Once a mutex has been locked by a thread, other threads attempting to lock it will be blocked. When the locking thread unlocks (releases) the mutex, one of the blocked threads may acquire (lock) it and proceed. When managed object events and responses are delivered to a client manager application using multiple threads, synchronization and serialization of the event and response deliveries may become problematic in that the use of different threads to deliver sequential events may introduce chronological inconsistencies due to differing thread execution times. In other words, if a first event is sent using a first thread, and a subsequent second event is sent using a second thread, then depending upon the execution times of the two threads, the second event may actually be delivered prior to the first event.","TMN applications, like most other software applications, require testing and debugging. However, typical debugging methods require that the application be stopped to reconfigure for debugging, such as by a command-line switch. This is often unacceptable for applications which are required to be operable twenty-four hours per day, seven days per week. Generally, debuggers are required to reside on the same computer as the running application. This restriction may be problematic for applications run in the field where software expertise may not be locally available. Also, debuggers are generally sold as components of a development toolkit under a development license, but most field applications are used under a deployment\/runtime license, and so debugging capabilities may not be available. Finally, debuggers which are not designed specifically for multi-threaded applications may not be able to handle debug output from multiple threads concurrently without mangling the output, i.e., the debug output messages from the multiple threads may not remain distinct.","Therefore, improved systems and methods for debugging multi-threaded applications are desired.","The problems outlined above are in large part solved by various embodiments of a thread-safe debugging system and method as disclosed herein. The system may include a thread-safe client debug service and a thread-safe dynamic remote control debug service, referred to as a remote control service, both of which reside on a client computer system with the client application to be debugged. The debug service and the remote control service may provide application programming interfaces (APIs) which allow multi-threaded applications executing on the client computer system to take advantage of debug services in a thread-safe and dynamic manner. One or more debug objects may be associated with one or more components of the multi-threaded application. Each component may be responsible for a particular task or set of tasks, such as database access, interaction with users, interaction with a CORBA bus, etc. The debug services may include providing debug output, listing the debug objects in the multi-threaded application, listing the state of each debug object, turning on or off any debug object by name or pattern, directing the debug output to a remote location, allowing multiple remote diagnostic applications to view the debug output of the application, and logging statistical or performance information.","The remote control service may provide a network protocol interface through which one may initiate and manage the debug services on the client computer system after initiation of the multi-threaded application. In other words, the debug services may be remotely and dynamically controlled. In contrast to previous solutions which require a command-line switch to be specified to turn debug services on or off when launching the program that is sought to be debugged, with the system and method described herein, debug services may be switched on or off after program execution has begun. This capability is especially important for applications such as network management applications that are expected to be available at all times and without interruption in service. Furthermore, in one embodiment, debug services may be switched on or off for a program running on the client computer system by issuing commands (e.g., control requests) from a third party application over a network.","In one embodiment, the remote control service may be operable to allow third party applications to switch the debug services on and off for each of the corresponding components of the multi-threaded application by referencing each of the corresponding debug objects, such as by specifying the name of each desired debug object. The remote control service may also allow one to switch the debug services on and off for a set of the corresponding components of the multi-threaded application by specifying a pattern to select a set of the debug objects by name, such as with the use of character wild cards. This capability allows one to specify groups of debug objects to receive particular debug commands.","The debug services may include a thread-safe debug print function. In one embodiment, the debug print function is operable on the client computer system independently of the remote control service. The debug print function may provide debug output for one or more threads of the multi-threaded application such that the debug output of each thread remains distinct from the debug output of the other threads. In other words, debug output from different threads may be presented such that the output is not interleaved or otherwise garbled. In one embodiment, the debug output of each of the one or more threads executing the multi-threaded application may be directed to an output target, such as a standard output terminal or a file. In one embodiment, the debug output may be directed to one or more recipient computer systems coupled to the client computer system. For example, the debug output may be directed to a diagnostic tool on a recipient computer system for analysis of problems encountered during the execution and debugging of the multi-threaded application.","Thread safety may be ensured throughout the debugging system through the use of thread-safe mechanisms such as locks. In one embodiment, for example, the debug output of each thread may be kept distinct by associating a mutex (mutual exclusion) lock with each output target. When a thread in the application invokes the print function to send the debug output to an output target, it may first acquire the associated mutex lock, then send the debug information to the output target, and finally, release the mutex lock. Since only one thread may acquire the mutex lock at a given time, other threads trying to acquire the mutex lock to send debug information to the output target must wait until that lock is released by the current thread owning the lock.","In one embodiment, the debug object class may be i18n-enabled to provide for debug output in a plurality of languages. The term \u201ci18n\u201d refers to internationalization, which is the process of designing an application so that it can be adapted to different languages and regions without requiring engineering changes.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawing and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","Turning now to the drawings, is an illustration of a typical, general-purpose computer system  which is suitable for implementing various embodiments of the system and method for network management as disclosed herein. The computer system  includes at least one central processing unit (CPU) or processor . The CPU  is coupled to a memory  and a read-only memory (ROM) . The memory  is representative of various types of possible memory media: for example, hard disk storage, floppy disk storage, removable disk storage, or random access memory (RAM). The terms \u201cmemory,\u201d \u201cmemory medium,\u201d and \u201cstorage medium\u201d may include an installation medium, e.g., a CD-ROM or floppy disk, a computer system memory such as DRAM, SRAM, EDO RAM, etc., or a non-volatile memory such as a magnetic media, e.g., a hard drive or optical storage. The memory medium may include other types of memory as well, or combinations thereof. In addition, the memory medium may be located in a first computer in which the programs are executed, or may be located in a second different computer which connects to the first computer over a network. In the latter instance, the second computer provides the program instructions to the first computer for execution.","As shown in , typically the memory  permits two-way access: it is readable and writable. The ROM , on the other hand, is readable but not writable. The memory  and\/or ROM  may store instructions and\/or data which implement all or part of the system and method described in detail herein, and the memory  and\/or ROM  may be utilized to install the instructions and\/or data. In various embodiments, the computer system  may take various forms, including a personal computer system, desktop computer, laptop computer, palmtop computer, mainframe computer system, workstation, network appliance, network computer, Internet appliance, personal digital assistant (PDA), embedded device, smart phone, television system, or other suitable device. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device having a processor which executes instructions from a memory medium.","The CPU  may be coupled to a network . The network  is representative of various types of possible networks: for example, a local area network (LAN), wide area network (WAN), or the Internet. The system and method for network management as disclosed herein may therefore be implemented on a plurality of heterogeneous or homogeneous networked computer systems  through one or more networks . The CPU  may acquire instructions and\/or data for implementing system and method for network management as disclosed herein over the network .","Through an input\/output bus , the CPU  may also coupled to one or more input\/output devices that may include, but are not limited to, video monitors or other displays, track balls, mice, keyboards, microphones, touch-sensitive displays, magnetic or paper tape readers, tablets, styluses, voice recognizers, handwriting recognizers, printers, plotters, scanners, and any other devices for input and\/or output. The CPU  may acquire instructions and\/or data for implementing the system and method for network management as disclosed herein through the input\/output bus .","The computer system  is operable to execute one or more computer programs. The computer programs may comprise operating system or other system software, application software, utility software, Java\u2122 applets, and\/or any other sequence of instructions. Typically, an operating system performs basic tasks such as recognizing input from the keyboard, sending output to the display screen, keeping track of files and directories on the disk, and controlling peripheral devices such as disk drives and printers. Application software runs on top of the operating system and provides additional functionality. Because applications take advantage of services offered by operating systems, and because operating systems differ in the services they offer and in the way they offer the services, an application must usually be designed to run on a particular operating system. The computer programs are stored in a memory medium or storage medium such as the memory  and\/or ROM , or they may be provided to the CPU  through the network  or I\/O bus .","In one embodiment, the computer programs executable by the computer system  may be implemented in an object-oriented programming language. In an object-oriented programming language, data and related methods can be grouped together or encapsulated to form an entity known as an object. All objects in an object-oriented programming system belong to a class, which can be thought of as a category of like objects which describes the characteristics of those objects. Each object is created as an instance of the class by a program. The objects may therefore be said to have been instantiated from the class. The class sets out variables and methods for objects which belong to that class. The definition of the class does not itself create any objects. The class may define initial values for its variables, and it normally defines the methods associated with the class (i.e., includes the program code which is executed when a method is invoked.) The class may thereby provide all of the program code which will be used by objects in the class, hence maximizing re-use of code which is shared by objects in the class.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 2","FIG. 2"],"b":["206","108","108","202","206","206","206","206","206","202","108"],"i":["a","b","c"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 3","FIG. 3"],"b":["208","206","204","206","206","202","108"]},"In one embodiment, the debug service library  may provide debug services to debug a multi-threaded application which is executable on the client computer system . In one embodiment, the application is written in C++ or another suitable programming language. In one embodiment, the debug service has a C++ API. The various debug services are discussed in greater detail below.","An application using only the debug service  cannot be remotely and dynamically controlled or diagnosed. After such an application has already started, there is no standard way to turn on\/off the debugging. This can only be done statically at the startup time by supplying the turn on\/off parameters, which then are used by the application to internally enable\/disable the debugging.","Note that an application using the remote control service must also use the debug service. In other words, use of the debug service is a prerequisite to use the remote control service. An application using the remote control service allows third-party applications to issue text commands over a network connection to the remote control service. Such text commands accomplish the task of dynamically and remotely turning on\/off the debugging, statistical or performance logging, listing debug objects, or other debug services.","The thread-safe remote control library  may provide a network protocol interface (text commands sent over the network) through which a remote third party application may initiate and manage the debug services on the client computer system  after initiation of the multi-threaded application. In other words, the debug services may be remotely and dynamically controlled. In contrast to previous solutions which require a command-line switch to be specified to turn debug services on or off when launching the program that is sought to be debugged, with the system and method described herein, debug services may be switched on or off after program execution has begun. Furthermore, in one embodiment, debug services may be switched on or off for a program running on the client computer system  by issuing commands from the server computer system .","The debug services may include a thread-safe debug print function. In one embodiment, the debug print function is operable on the client computer system  independently of the remote control service . The debug print function may provide debug output for one or more threads of the multi-threaded application such that the debug output of each thread remains distinct from the debug output of the other threads. In other words, debug output from different threads may be presented such that the output is not interleaved or otherwise garbled. In one embodiment, the debug output of each of the one or more threads executing the multi-threaded application may be directed to an output target, such as a standard output terminal or a file.","Thread safety may be ensured throughout the debugging system through the use of thread-safe mechanisms such as locks. In one embodiment, for example, the debug output of each thread may be kept distinct by associating a mutex (mutual exclusion) lock with each output target. When a thread in the application invokes the print function to send the debug output to an output target, it may first acquire the associated mutex lock, then send the debug information to the output target, and finally, release the mutex lock. Since only one thread may acquire the mutex lock at a given time, other threads trying to acquire the mutex lock to send debug information to the output target must wait until that lock is released by the current thread owning the lock.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 4","FIG. 3"],"b":["208","404","402","408","206","404","208","402"]},"Each of the debug objects  may be operable to provide debug services for the corresponding component  of the multi-threaded application . As discussed below, the debug services may include listing the debug objects in the application, listing the state of each debug object, turning on or off any debug object by name or pattern, directing the debug output to a remote location, allowing multiple remote diagnostic applications to view the debug output of the application, and logging statistical or performance information. As  illustrates, the debug service library  and the remote control library  may both reside on the client computer system , which may be communicatively coupled to the server computer system . The remote control library  may provide an interface through which the client-side debug services may be managed remotely and dynamically.","In one embodiment, the remote control service provided by the remote control library may allow a third party application to switch the debug services on and off for each of the corresponding components of the multi-threaded application  by referencing each of the corresponding debug objects , such as by specifying the name of each desired debug object . The remote control service may also allow third party applications to switch the debug services on and off for a set of the corresponding components of the multi-threaded application  by specifying a pattern to select a set of the debug objects  by name, such as with the use of character wild cards. A wild card is a special symbol that stands for one or more characters. Many operating systems and applications support wildcards for identifying files and directories. This enables one to select multiple files with a single specification. For example, the asterisk (*) is a wild card that stands for any combination of letters. The file specification m* refers to all files that begin with m. Similarly, the specification m*.doc refers to all files that start with m and end with .doc. This capability allows the third party applications to specify groups of debug objects  to receive particular debug commands.","In one embodiment, the remote control service may also be operable to allow third party applications to list all the debug objects  in the multi-threaded application and to list a state of each of the debug objects . For example, in various embodiments the state may include information such as the destination of debug output generated by the debug object , whether the debug object is \u201con\u201d or \u201coff,\u201d and information regarding the execution of the corresponding component of the application . In other words, the state may include the values of attributes of a debug object . The remote control service may be further operable to switch the debug services on and off after initiation of the multi-threaded application . This is in contrast to the requirement of many debuggers to be switched on or off at the startup of the application to be debugged, such as by command-line switches. In other words, the remote control service may allow for dynamic configuration of the debug services after the application  begins executing. This capability is especially important for applications such as network management applications that are expected to be available at all times and without interruption in service.","The debug services may provide an application programming interface (API) to be used by applications . The application  may call an initialization function of the debug API to initialize a remote control service. The remote control service may then begin listening for control requests on a port number specified as an argument of the function call. Control requests may control a given debug object  or set of debug objects . For example, a debug object  may be enabled or disabled (i.e., turned on or off) via a control request from a third party application running on the server computer system . When a remote control service receives a control request, it parses the request and determines which of the debug objects  are the target of the request. The third party application may maintain an internal list of debug objects  in the application . After finding the target debug object or objects  in the list, the third party application may apply the control request to them.","In one embodiment, the debug services may include profiling the execution of the multi-threaded application , tracing program execution through the multi-threaded application , and collecting run-time statistics on the execution of the multi-threaded application . The debug services may further include logging statistical and performance information on the execution of the multi-threaded application .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 5","FIG. 5","FIG. 5","FIG. 4"],"b":["206","202","504","206","202","408","206","402","402","404","208","404","402","206","204","202","408","204","404"]},"In one embodiment, the output target for debug output may include one or more computer systems coupled to the client computer system, such as the recipient computer systems . The output target may include one or more remote diagnostic tools running on the recipient computer systems . For example, the debug output may be directed to a diagnostic tool on a recipient computer system  for analysis of problems encountered during the execution and debugging of the application .","In one embodiment, the debug object class may be i18n-enabled to provide for debug output in a plurality of languages. The term \u201ci18n\u201d refers to internationalization, which is the process of designing an application so that it can be adapted to different languages and regions without requiring engineering changes. The term internationalization is often abbreviated as i18n, because in the English language there are 18 letters between the first and last letters of the word \u201cinternationalization.\u201d","Various embodiments may further include receiving or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Suitable carrier media may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network  and\/or a wireless link.","While the present invention has been described with reference to particular embodiments, it will be understood that the embodiments are illustrated and that the invention scope is not so limited. Any variations, modifications, additions and improvements to the embodiments described are possible. These variations, modifications, additions and improvements may fall within the scope of the invention as detailed within the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 1","i":"b "},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
