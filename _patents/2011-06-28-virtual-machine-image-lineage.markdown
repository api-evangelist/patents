---
title: Virtual machine image lineage
abstract: Techniques are described for tracking and maintaining the lineage of virtual machines (VMs). As applications are built or compiled, information about the makeup or elements of the applications is captured. As applications are installed on VMs, that information is also captured. As the VMs are deployed to hosts, decommissioned, migrated between hosts, etc., that information is also maintained. Therefore, it is possible to trace relations between live VMs (and/or hosts they execute on) and the elements of applications installed on the VMs. For example, if an element is a source code file, it may be possible to link that source code file with particular hosts or VMs. Or, it may be possible to determine whether a given host or VM has a dependency on an application element. Given a dataset of lineage information, a wide range of previously unavailable information can be obtained.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924930&OS=08924930&RS=08924930
owner: Microsoft Corporation
number: 08924930
owner_city: Redmond
owner_country: US
publication_date: 20110628
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["Recently, software has been run in virtualized hardware environments called virtual machines (VMs). A VM may have a virtual disk image that functions as a virtual hard drive. That is, the VM image (VMI) is a file that a virtualization layer may use to boot a VM, may contain a guest operating system and other software to run within the operating system. A VMI may be duplicated and each duplicate may serve as the virtual disk for its own VM instance. In other words, there may be many VMs running respective copies of a same VMI. Therefore, these VMs are likely running at least some of the same software found on the original VMI.","A problem, not previously appreciated, is that there has been no way to conveniently understand which VMs currently have which pieces of software, which hosts of VMs are linked to which source code files (of applications thereon), and so forth. While it may be possible to manually examine a VMI and identify software installed therein, there is no systematic way to accomplish this in an environment where software is often recompiled and reinstalled on VMIs, and where VMs using the VMIs are constantly deployed, redeployed, deleted, instantiated, etc. For example, in a cloud hosting environment or a data center, in response to current network of computing conditions, or in response to changing user requirements, new VM instances (having specific target software) may be created and started, old VM instances may be shut down, and\/or VM instances (and their VMIs) may be moved from one host to another host. Persons interested in a particular software application may not be able to quickly assess exactly which hosts are running which pieces of the software. Similarly, persons managing the cloud or data center may, for diagnostic or performance reasons, desire to know which software is on which hosts.","Moreover, detailed information about the software on VMs may be limited. For example, it may at times be desirable to know exactly which source code files contributed to the software installed on a VM\/VMI. Where VMs have been employed, there has been no way to quickly obtain answers to questions such as \u201cwhich hosts currently have VMs with software built from source code file F?\u201d, or \u201cwhich source code files contributed to the VM-based software on host H?\u201d","Techniques related to tracking VM-software lineages are discussed below.","The following summary is included only to introduce some concepts discussed in the Detailed Description below. This summary is not comprehensive and is not intended to delineate the scope of the claimed subject matter, which is set forth by the claims presented at the end.","Techniques are described for tracking and maintaining the lineage of virtual machines (VMs). As applications are built or compiled, information about the makeup or elements of the applications is captured. As applications are installed on VMs, that information is also captured. As the VMs are deployed to hosts, decommissioned, migrated between hosts, etc., that information is also maintained. Therefore, it is possible to trace relations between live VMs (and\/or hosts they execute on) and the elements of applications installed on the VMs. For example, if an element is a source code file, it may be possible to link that source code file with particular hosts or VMs. Or, it may be possible to determine whether a given host or VM has a dependency on an application element. Given a dataset of lineage information, a wide range of previously unavailable information can be obtained.","Many of the attendant features will be explained below with reference to the following detailed description considered in connection with the accompanying drawings.","Virtualization Overview",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 1","FIG. 1"],"b":["100","102","104","106","108","110","112","100","114","114","114","114"]},"The virtualization layer  may be of any variety of known or future implementations, such as Hyper-V Server\u2122, VMWare ESX Server\u2122, Xen, Oracle VM\u2122, etc. The architecture of the virtualization layer may a hosted type, with a virtual machine monitor (VMM) running on a host operating system, or a bare-metal type with a hypervisor or the like running directly on the hardware  of the computer . As used herein, the term \u201cvirtual machine\u201d refers to a system-type virtual machine that simulates any specific hardware architecture (e.g., x86) able to run native code for that hardware architecture; to the guest, the virtual machine may be nearly indistinguishable from a hardware machine. Virtual machines discussed herein are not abstract or process-type virtual machines such as Java Virtual Machines.","The virtualization layer  performs the basic function of managing the virtual machines  and sharing of the hardware  by both itself and the virtual machines . Any of a variety of techniques may be used to isolate the virtual machines  from the hardware . In one embodiment, the virtualization layer may provide different isolated environments (i.e., partitions or domains) which correspond to virtual machines . Some of the virtualization layer  such as shared virtual device drivers, inter virtual machine communication facilities, and virtual machine management APIs (application programming interfaces), may run in a special privileged partition or domain, allowing for a compact and efficient hypervisor. In other embodiments, functionality for virtual machine management and coherent sharing of the hardware  may reside in a monolithic on-the-metal hypervisor.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2","b":["100","114","140","100","142","114","114","140","140","114","140","141","100","100","140","114","140"]},"The virtualization layer  manages execution of the virtual machine , handling certain calls to the guest's kernel, hypercalls, etc., and coordinating the virtual machine 's access to the underlying hardware . As the guest operating system (sometimes called \u201cguest\u201d) and its software run, the virtualization layer  may maintain state of the guest on the virtual disk image ; when the guest, or an application run by the guest, writes data to \u201cdisk\u201d, the virtualization layer  translates the data to the format of the virtual disk image  and writes to the image.","The virtualization layer  may perform a process  for shutting down the virtual machine . When an instruction is received to stop the virtual machine , the state of the virtual machine  and its guest is saved to the virtual disk image , and the executing virtual machine  process (or partition) is deleted. A specification of the virtual machine  may remain for a later restart of the virtual machine .","Software Deployed to Virtual Machines",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3","b":["180","182","184","186","187","186","189","186","186"]},"In practice, the developer  writes programming language source code (e.g., Java code, C++ code, C# code, markup\/declarative language code, etc.) in a programming language and source code is stored in the source code files . The source code files may be managed by a revision control system . A compiler  then compiles the source code files , forming one or more executable files or programs (application ), possibly packaged in a deployment package  or the like. Again, the system of  is used only for an example. The lineage-tracking techniques described herein may also be used to track source code that is interpreted; no compiling or deployment packages are used. For example, the application  may be in the form of one or more script files that are written and installed as-is on VMIs (where there are executed by an interpreter), XML files with declarative code such as XaML (extensible application markup language), and other forms of applications comprised of or built from programming language code. As will be discussed next, the generic application  may be installed in VMIs and run in VMs.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4","b":["192","140","102","114","140","102","210","114","192","182","186","140","102","114"]},"VM Lineage",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 5","FIG. 5","FIG. 5","FIG. 5"]},"Regarding the tracking of application elements on VMIs, any of a variety of techniques may be used to track which applications  (and application elements) are installed on which VMIs . In one embodiment, the development environment  not only builds applications but is configured to build VMIs and install applications on VMIs. The development environment  may issue a signal or message when a new VMI is created and when an application is installed on a VMI. In another embodiment, a software deployment tool  takes a specified VMI (e.g., a VHD file), mounts the VMI to access its file system, and installs the application from deployment package. At that time, the software deployment tool  may issue a communication that indicates the application installed and the VMI on which it was installed. In another embodiment, a patching service  applies software patches to VMIs, either through an executing VM and its guest, or directly to VMIs. In yet another embodiment, a cloud fabric  may install an application on a VMI.","By whatever means, when an application is installed on a VMI, at step  input is received indicating which application is installed to (or removed from) which VMI. At step , this information is recorded in a lineage tracking repository , which is described later.","Regarding the tracking of VMIs (or VMs using copies of the VMIs) on hosts, again, a variety of means may be used. In one embodiment, an install manager  installs VMIs on hosts where they become VM instances. In another embodiment, the cloud fabric  may create a VM instance of a VMI by copying the VMI, instantiating a VM that uses the VMI, and starting the VM. In this case the cloud fabric  reports which VM or VMI is created\/deleted on which host. A virtual machine management system may perform similar functions. In yet another embodiment, hosts may issue communications indicating which VMs are running VMIs copied from which original or base VMIs. At step  input is received indicating that a specific VMI (or copy thereof) has been installed (or deleted) on a specific host. For example, a host might send a network message indicating which VMs are active or available to run on the host (possibly including identifiers of the correspond VMIs). At step  one or more host-VMI linkages are recorded (or deleted, as the case may be) in the lineage tracking repository .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 6","FIG. 6","FIG. 6"],"b":["240","260","260","192","194","260","140","186","260","140","260"]},"On the right side of , the lineage tracking repository  stores information indication which components can be traced to which other components. A series of tables store links between the components. Tables A, B, and C store information identifying the components. A source code table A stores identifiers of existing source code files (or other application elements). The source code table A may also or alternatively store information indicating which application elements correspond to which applications (for discussion, where an application element or source code files is mentioned in , an application built therefrom may be used as well). In one embodiment, table A may store application manifest files or other files that indicate the application elements of applications. The table A may also provide metadata about application elements, such as when they were created or last revised, their current revision number, the developer who authored the application elements, etc.","Another table B stores identifiers of particular VMI files; each VMI may have a globally unique identifier. Metadata associated with a VMI may also be stored, such as its location, its history, role, etc. Table C stores a list of hosts that may be running VMs including VMs using VMIs listed in table B. The information stored in tables A, B, and C may take different forms; the tables are merely used for convenience. In one embodiment, relations stored in relation tables A, B implicitly define the components they link.","Table A stores links between particular application elements (e.g., source code files) and particular VMIs. In one embodiment, Table A is implemented as a first table that indicates which application elements correspond to which applications, and a second table that indicate which applications are installed on which VMIs. When links between application elements and applications are available, it may be possible to identify which VMIs are linked to which application elements. For example, it may be possible to determine that VMI-j has application-a, that application-a is built from source code file-s, and that therefore the lineage of VMI-j is logically linked to source code file-s. Moreover, it may be possible to identify all of the VMIs that are so linked to the source code file-s.","In addition to the information linking particular VMIs to particular applications and\/or application elements, a table B stores information linking particular hosts to deployed copies of the particular VMIs (i.e., VMs using copies of the particular VMIs). In one embodiment, the original VMIs are \u201cgolden image\u201d VMIs, which are copied and deployed as VMs. In another embodiment, each VMI is a unique deployed VMI of a VM, and the lineage tracking repository  tracks which deployed VMIs have which applications and\/or application elements.","In sum, the lineage tracking repository  may be updated when: new applications are deployed; old VMIs are taken out of service or deleted; new applications are built and installed on VMIs; new VMs are formed, etc. At any given time, the repository will substantially reflect the current set of deployed VMs and the software installed therein.","Consider the following example described with reference to . A source code file-i is used to build application-a. Application-a is then installed on VMI-j and VMI-. Links in table A link source code file-i (and\/or application-a) with VMI-j and VMI-. VMI-j (or a copy thereof) is started with a VM on host-k, and VMI- is started in VMs on host- and host-, respectively, and corresponding entries are made in table B.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7","b":["102","280","102","1","280","282","282","282"]},"In one embodiment, the VM management component  pushes out any VM changes as they occur. When a new VM instance using a VMI is created or deleted on a host, that host transmits a corresponding message. In another embodiment, a management server  may periodically poll the hosts and request information about which VMIs are on the hosts. In yet another embodiment, a combination of approaches are used, including pushing, pulling, recording VMIs when they are deployed or migrated, and so forth. The management server  or equivalent receives the VM lists  or other information about VMI-host associations, and stores them in the lineage tracking repository .","In another embodiment, if a virtualization management suite is used to manage virtual machines, and in particular to control deployment and placement of VMs, the repository may be updated by the management suite each time the suite moves a VM, adds or creates a new VM, deploys a VM, deletes a VM, changes a VMs operational state, and so forth.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 8","b":["240","284","284","300","302","300","304","300","300","300","300","306","240","308","240"]},"A request  might be intended to identify all hosts having VMs that have software installed that includes or was compiled with a source code file specified in the request . The request is translated into a query, for example a JOIN between tables A and B, and the query is executed. The result is a list of hosts that have VMs that are linked to the source code file.","A request  might request the identities of all of the source code files or applications modified in the last month that are on a host or set of hosts defined in the request . For example, the request the applications and\/or source code files on all hosts that have experienced an unexpected reboot in the last 24 hours (assuming such information is tracked). By using (e.g., intersecting) the appropriate sets of links (e.g., VM-VMI links, VM-hosts links, application\/element-VMI links, etc.), it is possible to identify the subset of hosts with the specified files.","A request  might also be formed as or coupled with a command. For example, a set of VMs, hosts, etc., may be identified, and that set may be passed to a VM management system to perform a management operation, such as shutting down VMs, changing VM settings, etc. Any known type of VM operation may be provided with parameters obtained from the lineage tracking repository .","Requests might also be used for other purposes, such as finding which VMs have out-of-date version of applications, which application elements are in common among a set of specific VMs (e.g., VMs with a specific condition or a user-specified list of hosts or VMs).","Implementation details provided above may be varied significantly while still allowing for tracking lineage of VMs. Generally, any means of automatically linking VMs to the assets thereon may be used. For example, the lineage of a VM can be automatically discovered or inferred by inspecting the VM's virtual machine disk image. When certain application elements are found to be present in a VM, e.g., specific dynamically loaded libraries, configuration files, binary executables having specific version numbers, etc., that VM can be linked to other VMs. What is notable is that as VMs are deployed, cloned, deleted or shutdown, and so forth, links between the VMs and the software thereon are maintained. Moreover, details of the makeup of the software may also be tracked. By using a relational data model it is possible to perform efficient searches, however other models may be used.","Embodiments and features discussed above can be realized in the form of information stored in volatile or non-volatile computer or device readable media. This is deemed to include at least media such as optical storage (e.g., compact-disk read-only memory (CD-ROM)), magnetic media, flash read-only memory (ROM), or any current or future means of storing digital information. The stored information can be in the form of machine executable instructions (e.g., compiled executable binary code), source code, bytecode, or any other information that can be used to enable or configure computing devices to perform the various embodiments discussed above. This is also deemed to include at least volatile memory such as random-access memory (RAM) and\/or virtual memory storing information such as central processing unit (CPU) instructions during execution of a program carrying out an embodiment, as well as non-volatile media storing information that allows a program or executable to be loaded and executed. The embodiments and features can be performed on any type of computing device, including portable devices, workstations, servers, mobile wireless devices, and so on."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present description will be better understood from the following detailed description read in light of the accompanying drawings, wherein like reference numerals are used to designate like parts in the accompanying description.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
