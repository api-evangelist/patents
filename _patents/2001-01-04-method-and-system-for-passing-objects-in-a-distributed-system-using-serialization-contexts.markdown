---
title: Method and system for passing objects in a distributed system using serialization contexts
abstract: A system consistent with the present invention reduces the number of redundant class descriptors that are sent during remote method calls by using serialization contexts. “Serialization contexts” are dictionary objects that map a class descriptor to a corresponding integer handle. When possible, the integer handle, rather than the full class descriptor, is passed, saving processing time in RMI calls.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07296275&OS=07296275&RS=07296275
owner: Sun Microsystems, Inc.
number: 07296275
owner_city: Menlo Park
owner_country: US
publication_date: 20010104
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates generally to data processing systems and, more particularly, to passing serialized versions of objects in a distributed system.","Distributed systems can be made up of various components, including both hardware and software. A distributed system (1) allows its users to share services and resources over a network of many devices; (2) provides programmers with tools and programming patterns that allow development of robust, secured distributed systems; and (3) simplifies the task of administering the distributed system.","A distributed system can be implemented using an object-oriented programming language, such as Java\u2122. The Java\u2122 programming language is typically compiled into a platform-independent format, using a bytecode instruction set, which can be executed on any platform supporting the Java\u2122 virtual machine. The Java\u2122 programming language is described in greater detail in by James Gosling, Bill Joy, and Guy Steele, Addison-Wesley, 1996, which is incorporated herein by reference. Java\u2122 and Jave-based trademarks are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.","Distributed systems require that programs running in different address spaces be able to communicate with each other. In a system using an object-oriented programming language, such as the Java\u2122 programming language, this communication can be achieved by passing an \u201cobject,\u201d which represents an item or instance manipulated by the system, from one program to another. In such a system, a \u201cclass\u201d provides a template for the creation of objects having characteristics of that class. The objects in each class share certain characteristics or attributes determined by the class. A class thus defines the type of an object. Objects are typically created dynamically during system operation. Methods associated with a class are generally invoked on the objects of the same class or subclass.","In a Java\u2122 distributed system, an object is referred to as being remote when its methods can be invoked from another address space, typically a Java\u2122 virtual machine on a different computer. A remote object is described by one or more remote interfaces, which are Java\u2122 interfaces that declare the methods of the remote object. Remote Method Invocation (RMI) is used to invoke a method of a remote interface on a remote object. RMI is explained in, for example, the Remote Method Invocation Specification, Sun Microsystems, Inc. (1997), which is incorporated herein by reference.","As part of RMI, Java\u2122 objects are passed between a client and a server. Before being passed, a Java\u2122 object is converted into a serialized representation of itself. The serialized representation of the object contains enough information to enable the recipient to identify and verify the Java\u2122 class from which the contents of the object were saved and to restore the contents to a new instance. A serialized object contains two main parts: the object data and a class descriptor. The class descriptor describes the content and format of the object data.","When a serialized object is passed, the object data and the class descriptor are transmitted across the network. Although the object data may change over time, the class descriptor remains the same. Therefore, multiple remote method calls can result in passing the same class descriptor multiple times to a recipient who already has a copy of the class descriptor. This is expensive in terms of processing time as well as wasted network bandwidth. It is therefore desirable to reduce the number of times that a class descriptor is sent to a recipient.","Systems and methods consistent with the present invention reduce the number of redundant class descriptors that are sent during remote method calls by using serialization contexts. \u201cSerialization contexts\u201d are dictionary objects that map a class descriptor to a corresponding integer handle and, on the receiving end, map the integer handle back to the class descriptor. When possible, the integer handle, rather than the full class descriptor, is passed, saving processing time in RMI calls.","A method consistent with the present invention passes a first object and a second object, both instances of a class, in distinct remote method calls in a distributed system. The first object is passed from a sender to a recipient with a descriptor of the class and a handle corresponding to the descriptor. The handle and the descriptor are stored by the recipient. The second object is then passed from the sender to the recipient with the handle, and the recipient uses the handle to determine the descriptor.","A system consistent with the present invention reduces the number of redundant class descriptors that are sent during remote method calls by using serialization contexts. \u201cSerialization contexts\u201d are dictionary objects that map a class descriptor to a corresponding integer handle. When possible, the integer handle, rather than the full class descriptor, is passed, saving processing time in RMI calls.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","100","102","104","106","106"]},"Client computer  includes a memory , a secondary storage device , a central processing unit (CPU) , an input device , and a video display . The memory  includes a Java\u2122 runtime system . The Java\u2122 runtime system  includes a Java\u2122 virtual machine , and a Java\u2122 remote method invocation (RMI) system . The RMI system  contains one or more serialization contexts . Memory  also includes a program  running on client computer .","Server computer  includes a memory , a secondary storage device , a central processing unit (CPU)  an input device , and a video display . The memory  includes a Java\u2122 runtime system . The Java\u2122 runtime system  includes a Java\u2122 virtual machine , and the Java\u2122 remote method invocation (RMI) system . The RMI system  contains one or more serialization contexts . Memory  also includes a program  running on server computer , and one or more objects .","Using RMI, objects can be passed between client computer  and server computer . For example, a program  running on client computer  can invoke a method on an object  stored in the memory  of server computer . Client computer  would use RMI system  to convert the method call, including an identification of the remote method and any parameters, into a byte stream that is sent to server computer  via network . Server computer , upon receiving the byte stream, would use its RMI system to convert the byte stream into executable bytecode and initiate the invocation of the method on the remote object. If the method results in a return value, server computer  would convert the return value to a byte stream using its RMI system, and transmit the byte stream to the client computer .","The byte streams contain serialized versions of Java\u2122 objects, e.g. parameters or return values. A serialized object contains two main parts: the object data and a class descriptor. The class descriptor describes the content and format of the object data. Object serialization is explained in, for example, the Java\u2122 Object Serialization Specification, which is incorporated herein by reference.","Within a single remote method call, a class descriptor is sent with the first object of that type that is serialized, subsequent objects of that type in the same remote method call refer to the class descriptor with a \u201cback reference\u201d (i.e., an integer handle).","Serialization Contexts","In a serialized object, the class descriptor provides the full name of the class and its serialization ID, which uniquely identifies the class. The serialization ID is a 64-bit hash of the class name, interface class names, methods, and fields. Each class descriptor is an instance of the Java\u2122 class ObjectStreamClass, defined as follows:",{"@attributes":{"id":"p-0025","num":"0024"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class ObjectStreamClass"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static ObjectStreamClass lookup(Class cl);"]},{"entry":[{},"public String getName( );"]},{"entry":[{},"public Class forClass( );"]},{"entry":[{},"public ObjectStreamField[ ] getFields( );"]},{"entry":[{},"public long getSerialVersionUID( );"]},{"entry":[{},"public String toString( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Serialization contexts can be used to pass the class descriptors of serialized objects. As explained above, serialization contexts are dictionary objects that map a class descriptor to a corresponding integer handle. When possible, the integer handle, rather than the full class descriptor, is passed, saving processing time in RMI calls.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["124","144","202","206","204","208","126","146"]},"RMI system  of client computer  contains serialization context , which consists of outgoing handle table  and incoming handle table , and RMI system  of server computer  contains serialization context , which consists of outgoing handle table  and incoming handle table . Each incoming handle table has one or more entries including a handle and a class descriptor. Each outgoing handle table has one or more entries, the entries including a flag, a handle, and a class descriptor. The flag in each outgoing handle table entry is a boolean value indicating whether the corresponding handle\/class descriptor pair is \u201ccommitted.\u201d If a handle\/class descriptor pair in an outgoing handle table is committed, it is known to be saved in the corresponding incoming handle table of the serialization context pair. For example, if the committed flag in an entry in outgoing handle table  is true, then the corresponding class descriptor\/handle pair has been stored in incoming handle table . If the committed flag is false, incoming handle table  may or may not contain the corresponding class descriptor\/handle pair. The use of the committed flag will be described in further detail below with reference to .",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 2","FIG. 4"],"b":["126","102","146","104","302","124","144"]},"When the sender wishes to send a class descriptor to the recipient, the sender checks to see if the descriptor is already defined in the outgoing handle table  of serialization context  (step ). If so, and if the committed flag is true, as detailed with reference to one embodiment in  below, the sender retrieves the handle corresponding to the class descriptor from the outgoing handle table  of serialization context , and sends the handle rather than the full class descriptor to the recipient (step ). The recipient then uses the handle to look up the class descriptor in the incoming handle table  of serialization context . If the class descriptor that the sender wishes to send is not in the outgoing handle table  of serialization context , the sender sends both the class descriptor and a new handle (step ). For subsequent calls, the sender can send just the handle to the recipient.","Handshake",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 4","FIG. 3"],"b":["302","124","144","402","404","406","408","410","412"]},"If the recipient does not have the serialization context corresponding to the context ID received, or if the recipient receives a null ID, the recipient creates a new serialization context (step ) and sends the new context ID to the sender (step ). The sender then knows that, if it receives the same context ID that it sent, it can use the proposed serialization context. Otherwise, the sender should create a new serialization context with the new context ID and use that instead.","Using Committed Flags to Enhance Two-Way Communications",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 5","FIG. 3"],"b":["306","202","208"]},"To use the committed flag in this way, the sender first checks to see if the class descriptor is in the outgoing handle table  of serialization context  (step ). If so, then the sender checks the value of the corresponding committed flag (step ). If the committed flag is true, the sender can send the handle, knowing that the class descriptor\/handle pair is stored in the recipient's incoming handle table  (step ).","If the class descriptor is not in the outgoing handle table  of serialization context , the sender creates a new entry, with a new handle and a committed flag set to false, in outgoing handle table  (step ) and sends the new handle and class descriptor to the recipient (step ). The recipient stores the new class descriptor\/handle pair in incoming handle table  (step ). The sender would also send both the class descriptor and the handle to the recipient if the class descriptor is in outgoing handle table , but the committed flag is false (steps  & ). The recipient would simply discard any duplicate handle\/class descriptor pairs received.","Handle Acknowledgment-Arguments","To rely on the committed flags as described above, there must be a way to update the flags in both the sender's outgoing handle table and the recipient's outgoing handle table. This updating can be done using the arguments sent from the sender to the recipient and the return values returned from the recipient to the sender.","When an argument, including data and a class descriptor\/handle pair, is sent from a sender (e.g., program  running on client computer ) to a recipient (e.g., program  running on server computer ), the recipient uses the class descriptor or handled to recreate the argument data and carry out the method call.","As part of this process, the recipient enters any new handle\/class descriptor pairs into the incoming handle table . In one embodiment, this updating occurs before the method call can return successfully to the client. Therefore, when the remote method call is successfully returned to the original sender, the handle\/class descriptor pair is implicitly acknowledged, and the sender can set the corresponding committed flag in the outgoing handle table 202 to true.","Handle Acknowledgment-Return Values","Class descriptors used by the recipient (e.g., program  running on server computer ) to send return values to the sender (e.g., program  running on client computer ) require an explicit acknowledgment. The recipient has no way of knowing whether the sender successfully stored the handle\/class descriptor pair sent with the return value in the incoming handle table . To acknowledge that the incoming handle table  has been updated, the sender sends an explicit acknowledgment of its successful receipt of the handle\/class descriptor pair with its next call to the recipient. The acknowledgment can be delayed in this way because the recipient only needs the acknowledgment if there are future communications between the sender and the recipient.","Garbage Collection","Serialization contexts can get quite large. If a pair of tables is no longer needed, memory space can be saved by deleting the tables. Preferably, this \u201cgarbage collection\u201d is made possible by using the globally unique ID codes corresponding to each serialization context pair. A table that maps serialization contexts to their unique ID codes can be maintained by, for example, RMI system  or RMI system . Space in this table is \u201cleased,\u201d meaning that after a set amount of time has passed, a serialization context\/unique ID code pairing is deleted from the table. Each time a serialization context is accessed by an object, e.g., a program running on client computer  or server computer , the lease time is reset. Therefore, serialization contexts will automatically be available for a set amount of time between uses. After the set amount of time expires and a serialization context is deleted, a new table is created when a client wishes to communicate with the server, as described in .","Other embodiments of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and examples be considered as exemplary only, with a true scope and spirit of the invention being indicated by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["This invention is pointed out with particularity in the appended claims. The above and further advantages of this invention may be better understood by referring to the following description taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
