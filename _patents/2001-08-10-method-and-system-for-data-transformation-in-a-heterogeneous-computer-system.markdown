---
title: Method and system for data transformation in a heterogeneous computer system
abstract: A data transformation system includes clients, which initiate requests for transformation of data between first and second data formats. The system also includes peer transformation servers having data converters and graphs of available transformations between input and output data formats of such servers. The graph includes unidirectional edges, which extend between corresponding pairs of the formats. The servers collectively include one or more converters for each of the edges. The servers receive the requests and select plural intermediate transformations from the first format to plural intermediate formats, and a final transformation from an intermediate format to the second format. Each of the intermediate and final transformations is associated with a corresponding one of the edges. The servers initiate the converters corresponding to the selected transformations, in order to obtain and dispose the data in the second format. A communication network provides communication among the client and servers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07065588&OS=07065588&RS=07065588
owner: Chaavi, Inc.
number: 07065588
owner_city: Pittsburgh
owner_country: US
publication_date: 20010810
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The invention relates to systems for transforming data, such as, for example, a file or document format, from one data format to another data format and, in particular, to such systems for use in a heterogeneous computer system. The invention also relates to methods for transforming data.","2. Background Information","Most computer systems are a heterogeneous environment of software, hardware and communication networks. Electronic data is generated by a user employing software known as applications (e.g., word processors) or by devices (e.g., digital cameras, electrocardiogram machines). The electronic data is often referred to as a document or a file. This electronic data may be displayed (e.g., word-processing document, image file, video file), played (e.g., voice file, music file), processed or sent to another point in the computer system to be displayed, played, processed, printed, or transmitted (e.g., by facsimile).","Regardless of its purpose, the electronic data undergoes numerous transformations using a variety of software and hardware. Often, during each of these steps, the language (or the format) of the electronic data is interpreted and then transformed to different format, which is suitable for the next step in the transformation. Sometimes, interpretation of the data format may not be necessary when the data is simply encoded or encapsulated perhaps for transmission across the network or encrypted for security. Quite often, the transformation may be accomplished by an expert in interpreting and translating the electronic data, such as, for example, voice transcriptions and filling standard forms in an office environment. In essence, electronic document transformation is essential and ubiquitous in a networked world. The required transformations may be completely automatic, as is the case, for example, when an e-mail message\/attachment undergoes numerous transformations in a sequence decided by pre-configured sequencing of software and hardware tools. The transformation may also be initiated by a user, for example, as in the transformation of word processing documents to PDF (Portable Document Format) or through printing of such documents by a printer.","Not all transformations are always straightforward or even feasible. Rapid innovations in information technology have resulted in the proliferation of newer and better representations and delivery of data. Usually, each new representation of data requires yet another set of software and\/or hardware solutions to transform the data. Hence, there may be a substantial delay in acquiring such solutions and updating a computer system. This problem is further complicated by the heterogeneity of the computer infrastructure. This heterogeneity is the result of varied computing platforms based on different architectures (e.g., x86 architecture of most PCs, PowerPC architecture of Macs, a variety of RISC and CISC architectures of servers from SUN and IBM), a variety of operating systems for these architectures (e.g., Windows, MacOS, SunOS, Linux, IBM AIX) and a variety of applications using these operating systems. The same heterogeneity exists within input and\/or output devices such as printers, facsimiles, medical instruments and wireless devices.","The imposition of standards on data representations and formats can alleviate some of this problem. However, standards are very few and far between mainly because most information technology manufacturers deem it advantageous to develop proprietary formats. Also, no single standard can effectively deal with all possible combinations of formats even for a limited application area such as word-processing.","Using a standard intermediate format in a two-stage transformation system for electronic documents is widely known. For example, in an Electronic Data Interchange (EDI) system, where the creator knows the formats, the transformation system can be a two-step system. See U.S. Pat. Nos. 5,202,977; and 5,701,423. The reliability of such systems can be ensured if and only if all the file input formats of interest can be reliably transformed to one known format, which, in turn, can be transformed to the desired output format. In some systems where the formats are known, or publicly known, this is a feasible scheme, although it requires a centralized transformation system with a completely defined software\/hardware environment. Centralized systems, however, are vulnerable to failure and are hard to scale and manage with increasing load.","The application which generates a file is often best suited for interpreting it and, in many cases, transforming the file to other standard formats (e.g., files created by Microsoft Word (MS Word) can best be read by MS Word and translated into Rich Text Format (RTF)). Thus, the use of native applications may be a better solution than the use of third-party software, which may cause some loss or modification of content during interpretation and translation. While best suited for the task, native or first-party software may be prohibitively expensive, especially if a majority of the users are only using the software to view files in a specific format. In such a case, using an instance of the software as a service to convert files to a common readable format provides a cost-effective technique for sharing information.","In addition, third-party software may be faster, cheaper and\/or provide a wider range of document formats than native applications. Further, the loss\/modification of content may be acceptable depending upon the purpose of the final document. U.S. Pat. Nos. 6,092,114 and 5,283,887 disclose the use of native and third-party applications in a centralized transformation system in an e-mail environment, in which the transformation process is a single-step process using a known application. The process of discovering any change in availability of new transformation applications is through static configuration files (i.e., files that cannot be updated while the server is operational) at a central server (i.e., one master controlling server).","One step transformations based upon static configuration files are a problem because software versions and electronic file formats are being rapidly upgraded. This results in incompatibility between versions of the same application. For example, a PowerPoint version 4 document is not compatible with the latest PowerPoint version in Office2000. One has to first use Office97 to convert the former document to an intermediate format that can then be converted to the latter format. Thus, there is an ever increasing volume of legacy documents that become unreadable unless one has access to the original application that created it. Also, some applications preclude the simultaneous use of multiple versions on the same computer.","U.S. Pat. No. 5,251,314 discloses multiple application versions, in which a single application performs the same transformation. The substeps required for a full transformation are pre-determined and stored in centralized static configuration files. The available transformations are also centrally stored. Recovery of the original file is provided.","U.S. Pat. Nos. 5,251,314; 5,299,304; and 5,513,323 disclose the use of plural applications or stages to perform a more complex transformation through a series of conversions. The system of U.S. Pat. No. 5,251,314 finds out whether a requested transformation can actually be performed and in how many stages. This determination is used to a priori decide whether to proceed with the requested transformation. In a real system, the number of stages of transformation is not the only issue in deciding which sequence of transformation is more efficient or less expensive. U.S. Pat. No. 5,513,323 discloses a similar problem except that the goal is to find the sequence with the least cost. A fixed cost is associated with each primitive transformation and a sequence of primitive transformations is chosen.","Ockerbloom, J., \u201cMediating Among Diverse Data Formats,\u201d Carnegie Mellon University, pp. 1\u2013145 (1998), discloses a conversion system including clients, servers, and mediators called type brokers. The servers provide data and perform operations on the data, such as conversions, method executions and attribute fetches. The clients retrieve data and request operations on the data. The type brokers take client requests and find servers that return data and operation results that clients seek.","There is room for improvement in methods and systems for transforming data in heterogeneous computer systems.","In summary, the task of transforming documents is costly, tedious and time-consuming. Many people regularly face this problem. This is especially true inside an organization where the transformation needs may be specific to the type of documents that are handled daily. There is no known solution that systematically manages this problem inside a networked organization or for loosely connected communities on the Internet. Ideally, such a system should be able to grow as the transformation needs of an organization increases, new document formats and software are introduced, and existing software versions change.","This need and others is met by the present invention which provides a data transformation system and method. A plurality of peer transformation servers each include a plurality of data converters and a representation of available data transformations between a plurality of input and output data formats. The graph includes unidirectional edges, which extend between corresponding pairs of the formats, and the transformation servers collectively include one or more of the data converters for each of the edges. The transformation servers are adapted to receive requests from clients for transformation of data and select at least one intermediate data transformation from the first data format to at least one intermediate data format, and a final data transformation from the intermediate data format to the second data format. Each of the intermediate and final data transformations is associated with a corresponding one of the edges. The transformation servers are also adapted to initiate a plurality of the data converters corresponding to the selected intermediate and final data transformations, in order to obtain the data in the second data format.","As one aspect of the invention, a data transformation system for use in a heterogeneous computer system comprises: at least one client adapted to initiate a request for transformation of data in a first data format to data in a second data format; a plurality of peer transformation servers, each of the transformation servers including a plurality of data converters and a representation of available data transformations between a plurality of input data formats associated with at least some of the transformation servers and a plurality of output data formats associated with at least some of the transformation servers, the representation including a plurality of unidirectional edges, with each one of the edges extending from one of the input and output data formats to another of the input and output data formats, the transformation servers collectively including at least one of the data converters for each of the edges, at least one of the transformation servers adapted to receive the request for transformation of data and select at least one intermediate data transformation from the first data format to at least one intermediate data format and a final data transformation from the intermediate data format to the second data format, with each of the intermediate and final data transformations being associated with a corresponding one of the edges, the at least one of the transformation servers adapted to initiate a plurality of the data converters corresponding to the selected intermediate and final data transformations, in order to obtain the data in the second data format, and dispose the data in the second data format; and a communication network adapted to provide communication among the transformation servers and the client.","As a further aspect of the invention, a data transformation system for use in a heterogeneous computer system comprises: at least one client adapted to initiate a request for transformation of data in a first data format to data in a second data format; a plurality of peer transformation servers, each of the peer transformation servers comprising: means for receiving the request, a plurality of data converter means for converting data in a data format to data in another data format, means for representing data transformations between a plurality of input data formats associated with at least some of the peer transformation servers and a plurality of output data formats associated with at least some of the peer transformation servers, the means for representing including a plurality of unidirectional edges, with each one of the edges extending from one of the input and output data formats to another of the input and output data formats, the peer transformation servers collectively including at least one of the data converter means for each of the edges, means responsive to the received request for selecting at least one intermediate data transformation from the first data format to at least one intermediate data format and a final data transformation from the intermediate data format to the second data format, with each of the intermediate and final data transformations being associated with a corresponding one of the edges, means for initiating a plurality of the data converter means corresponding to the selected intermediate and final data transformations, in order to obtain the data in the second data format, and means for disposing the data in the second data format; and means for providing communication among the peer transformation servers and the client.","As another aspect of the invention, a method for transforming data in a heterogeneous computer system comprises: initiating a request for transformation of data in a first data format to data in a second data format; communicating the request over a communication network; receiving the request in one of a plurality of peer transformation servers; including with each of the peer transformation servers a plurality of data converters and a representation of data transformations between a plurality of input data formats associated with at least some of the peer transformation servers and a plurality of output data formats associated with at least some of the peer transformation servers; including with the representation a plurality of unidirectional edges, with each one of the edges extending from one of the input and output data formats to another of the input and output data formats; providing at least one of the data converters for each of the edges; selecting at least one intermediate data transformation from the first data format to at least one intermediate data format; selecting a final data transformation from the intermediate data format to the second data format; initiating a plurality of the data converters corresponding to the selected intermediate and final data transformations, in order to obtain the data in the second data format; and disposing the data in the second data format.","As a further aspect of the invention, a method for representing data transformation capabilities and selecting a data transformation for a heterogeneous computer system comprises the steps of: forming a graph to represent a plurality of data transformations between a plurality of input data formats and a plurality of output data formats; including with the graph a plurality of unidirectional edges, with each one of the edges representing a capacity to transform from one of the input and output data formats to another of the input and output data formats; associating with some of the unidirectional edges at least one edgelet each of which represents a data converter for a corresponding one of the some of the unidirectional edges; associating with at least one of the unidirectional edges a plurality of edgelets each of which represents a data converter for a corresponding one of the at least one of the unidirectional edges; and selecting at least one of the data converters.","As another aspect of the invention, a data transformation server for use in a heterogeneous computer system comprises: means for receiving a request for transformation of data in a first data format to data in a second data format; a plurality of data converters, each of which transforms data from one data format to another data format; means for storing a graph to represent a plurality of data transformations between a plurality of input data formats and a plurality of output data formats, the graph including a plurality of unidirectional edges, with each one of the edges representing a capacity to transform from one of the input and output data formats to another of the input and output data formats, some of the unidirectional edges including at least one edgelet each of which represents one of the data converters for a corresponding one of the some of the unidirectional edges, at least one of the unidirectional edges including a plurality of edgelets each of which represents one of the data converters for a corresponding one of the at least one of the unidirectional edges; means for initiating at least one of the data converters, in order to obtain the data in the second data format; and means for disposing the data in the second data format.","The following are non-limiting definitions of various terms employed herein.","Application: A software package, possibly coupled with specific hardware, capable of reading an input data format, such as a file or document format, and producing one, of possibly many, output data formats.","Monolithic Conversion: A direct, one-step conversion from a source format to a destination format with no intervening steps (e.g., from WordPerfect to PDF).","Glass Box Conversion: Conversion of a file where the converting application is aware of extensive details about the file's format; in particular, the converter can diagnose the results of a conversion for quality.","Black Box Conversion: Conversion of a file where the converting application does not know sufficient details about the file's format in order for the converter to diagnose the quality of conversion.","Wrapper: An application shell, which hides the details of conversion from the Electronic Transformation Server (ETS), and provides a model of conversion execution that the ETS can manipulate to provide consistent quality of service. A wrapper is associated with only one application and\/or device. There can be many wrappers for the same application to provide different types of conversions.","Converter: a combination of wrapper and application which provides a conversion (e.g., xyz.com:application\/WORDPERFECT:application\/PDF signifies that the server on xyz.com is able to convert a WordPerfect document to a PDF document). A converter enables a monolithic conversion.","Node: a specific document format which might include, for example, the version of the application producing the document, and the operating system.","Edge: a connection between two nodes, which reflects the existence of one or more converters that are able to convert a document in the source format into a document in the target format. Edges are \u201cdirected\u201d in that an edge connecting node \u201cA\u201d to node \u201cB\u201d does not imply the reverse conversion of node \u201cB\u201d to node \u201cA\u201d. Such a reversing ability is denoted by a second edge from node \u201cB\u201d to node \u201cA\u201d.","Edgelet: Any converter that performs the conversion specified by an edge. There can be more than one edgelet associated with an edge denoting that the conversion implied by an edge can be performed by more than one converter. An edgelet is associated with one wrapper.","Transformation graph: a collection of \u201cnodes\u201d and \u201cedges,\u201d with no isolated nodes and no duplicated edges.","Transformation: the complete sequence of conversions employed to obtain the desired end format, given the starting format (e.g., the sequence WordPerfect\u2192POSTSCRIPT\u2192PDF to achieve the transformation of a WordPerfect document into a PDF document). This is equivalent to the existence of a \u201cdirected\u201d path connecting one node to another node (i.e., two nodes denoting the starting format and the target format).","Server: Software that provides specific services to requesters, generally called clients.","Client: Software that enables an agent, human or otherwise, to obtain services from a server. A client may be embedded in other applications, such as a web client, to provide web-based transformation services directly to users.","ETS (Electronic Transformation Server): Software that provides the transformation service. Zero or more wrappers may be managed by an ETS.","Instance: refers to a specific running ETS (e.g., a single copy of an ETS executing on a single hardware\/software platform). An ETS can, as needed, become the \u201cclient\u201d of another server. There can be plural instances of an ETS running on a single hardware\/software platform.","ETMS: The web of connected ETS instances comprises the Electronic Transformation Management System (ETMS).","IPC (Inter-Process Communication): A software-based mechanism by which two programs can communicate with each other (e.g., a wrapper sends a message to the ETS when it has completed a conversion).","Acquisition: The manner in which data, a file or other electronic data is acquired by an ETS instance.","Disposition: The manner in which data, a file or other electronic data is delivered to the intended recipient (e.g., another application, a user).","Document format: Document format can be defined in a number of ways such as, for example: (1) application specific, which is generally, but not necessarily, proprietary (e.g., MS Word, WordPerfect); (2) standard format (e.g., HTML, RTF); and (3) media (e.g., facsimile, printed page). Each such format is a legitimate document starting or ending format in the ETMS. Thus, for example, a legitimate request is to transform a facsimile message into a WordPerfect file.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 1","b":["1","2","3","4","5","6","7","8","2","3","4","1","8","6","8","8","1","5","1","2","1","1","10","5","4","1","11"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 2","b":["20","21","22","23","22","24","20","22","25","23","26","22","25","27","23","23","28","29","30","30","31","30","20","22"]},"As discussed herein, there may be alternatives to the exemplary sequence of events, such as, for example, the manner in which the request  is acquired by the ETS instance and the specific disposition requirements.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 3","FIG. 1","FIG. 1"],"b":["40","41","42","43","44","45","44","45","46","47","41","42","43","1","2","3","4"]},"An ETS instance provides file transformation services and is capable of initiating, administering and terminating a transformation. A transformation can be provided using wrappers under the direct control of an ETS (e.g., ) or under the control of the ETS' peer (e.g., ETSs ,). In the exemplary embodiment, an instance publishes or informs its peers about the conversions it can provide and accepts requests for specific transformations or conversions from its peers. However, each ETS can impose specific authentication and authorization (and other security) requirements that, if not satisfied by the peer ETS, can result in a refusal of information or service.","For a specific transformation, the requesting or initiating instance acts as the \u201cclient\u201d of the responding ETS. Since these roles can be reversed between any pair of ETSs (even for a single transformation request), an ETMS  may be composed of a collection of peer-to-peer related ETSs ,,. ETS instances discover other instances in various ways, such as, for example, from a configuration file on startup, from re-reading an updated configuration file, or by receiving messages from a peer ETS. An ETS can acquire the file to be converted in a wide variety of ways and can dispose of the results in a wide variety of ways. For example, an ETS might receive a \u201cfile\u201d from a facsimile transmission and return the transformed result (of a facsimile to PDF transformation, for instance) as an e-mail message. These varying behaviors are handled by allowing clients to specify different delivery dispositions, ranging from, for example, file transfers to e-mail. Each ETS instance manages zero or more wrappers that provide the primitive transformation service. If an ETS, such as , has no wrapper under its control, then all transformation services it provides are executed using the services provided by its peers, such as  and . If an ETS has wrappers under its control, then its transformation services can result from using either those wrappers or else wrappers from its peers depending on, for example, demand, quality or cost.","Since an ETS can have multiple peers, transformations and wrappers, any particular transformation request can be satisfied in many ways. A suitable graph representation is employed to help decide what transformations an ETS can provide and how it provides this transformation subject to a variety of conditions, such as, for example, costs, transmission latencies, and quality of conversion. The exemplary transformation graph  shown in  consists of nodes ,,,,, representing document formats (e.g., Word, PowerPoint (PPT), PostScript (PS), Portable Document Format (PDF), Rich Text Format (RTF) and text) which are linked if there is a service that can convert from one format to another. This conversion may be local (e.g., using a wrapper controlled by the local ETS) or remote (e.g., using a wrapper controlled by another ETS). Hence, in , a Word-to-PS transformation employs only a single conversion step, , while a PowerPoint to text transformation employs a PowerPoint-to-RTF, an RTF-to-Word and a Word-to-text sequence of conversion steps ,  and , respectively.","Each of the available conversions ,,,, is represented in the graph  by a directed link (e.g., one with an arrow at one end) and is called an edge. There can be several ways in which an edge may be traversed (e.g., there may be several wrappers each providing the same conversion service, several ETS peers providing the same service). Here, all such multiplicities are shown by a single edge, and the issue of which specific service to employ is delegated to a different step. The exemplary transformation graph  differs from known prior transformation graphs by representing the capacity for a document conversion rather than the actual application that will perform the conversion. The existence of any edge in a transformation graph represents any number (e.g., one or more) of available conversions. For example, the graph  collapses several available PS to PDF converters (e.g., GhostScript, Adobe Acrobat) into the single PS to PDF edge . The actual mechanics of picking a specific wrapper are performed in a separate step (e.g., as discussed below in connection with ).","Thus, the exemplary graph  consists of nodes \u2013 and directed edges \u2013 between such nodes. Those nodes represent a particular file format or type. An edge from one node to another node indicates that it is possible to perform that particular transformation. A list of all nodes and edges are maintained as a primary graph.","As discussed above in connection with , wrappers serve as an interface between the ETS instances and applications and\/or devices. Wrappers may be employed to \u201ccoerce\u201d (as discussed below) applications to provide conversion services that they were not necessarily designed to provide. Wrappers can range from simple software \u201cscripts\u201d to procedures involving a \u201chuman-in-the-loop\u201d. Simple scripts instruct the application to open the document, convert it, save the conversion, and quit. At the other extreme, a specific conversion might require a human agent to launch the application, open the document within the application, interactively perform the conversion, and save or distribute the resulting document in the new format. Thus, part or all of the application may be a human agent.","At the lowest level of the ETMS hierarchy are the applications (and\/or in certain cases devices such as, for example, printers or facsimile machines). Although applications and devices are lowest in the hierarchy of , they are the engines of the transformation service since they perform the actual conversion. The rest of the ETMS is employed to manage and mediate the conversion facilities provided by the applications. The application, which generated the file, is often best suited for interpreting it and, in many cases, also transforming the file to other formats. Thus, employing native applications may be a better solution than using third-party software, which may cause some loss or modification of content during interpretation and translation.","However, third-party software may be faster, cheaper or provide a wider range of document formats than native applications. Further, the loss in fidelity or modification of content may be acceptable depending upon the purpose of the final document. Hence, applications may be of several types: (1) original (i.e., the application which produced the source document); (2) next-generation (i.e., a newer version of the original application which is able to read documents created by previous versions); and (3) third party applications (e.g., third party software packages which are able to perform one or more specific conversions).","Both static (i.e., known ahead of time and either fixed or changing only very sporadically) and dynamic information (i.e., information obtained as a consequence of repeated use) about an application are employed to determine the \u201cbest\u201d application to use. The initial assumption is that the originating application (i.e., the specific version of the specific application on a specific operating system) is best suited for a conversion. This assumption is modified based on experience and the trade-off(s) made by, or on behalf of, the requester. Thus, for example, the requester may choose a less expensive, less accurate conversion using a third party application rather than the originating application.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 5","b":["70","72","74","72","76","70","78","80"]},"The communication module  handles incoming requests and produces appropriate responses. The communication module  also generates appropriate requests to other ETS instances  on the communication network . As shown in , the communication module  exchanges information mainly with the communication modules \u2032 of other ETSs or clients, and handles requests using two subsystems: an Initiator  transmits requests, and a Responder  handles incoming requests. For example, the Initiator ,\u2032 of one ETS , communicates with the Responder \u2032, of the other ETS ,, respectively.","Referring again to , acquisition of the transformation request  and file  of  normally happens through the communication module  in which case it is merely a pass-through mechanism to the transformation module . The ETS  also has another mechanism of acquiring requests and files through its local file system. The communication module , in turn, hands over the request  to the transformation module .","The security module  sets up this ETS' security requirements and deals with the authentication and authorization of peer ETSs, such as . The communication module  accepts or rejects an incoming connection depending upon the security parameters.","The transformation module  performs the transformation of a given electronic input to the desired output. The transformation module  directly deals with the local application wrapper subsystem  to execute the atomic (single-step) conversions. For conversions employing a remote ETS instance, the transformation module  manages the conversion and employs the communication module  to interact with other ETS(s). The transformation module  gets the requests from the communication module  or the acquisition subsystem (not shown). The results of transformation are handed over by the transformation module  to the disposition subsystem (not shown) of the disposition module , which appropriately packages the results and manages the process to return the result, as negotiated, between the two ETSs ,.","The graph module  manages the graph representation and services queries, on the graph itself, from the transformation module . While the mechanics of obtaining information from a peer ETS are left to the communication module , the management of how a particular transformation request can best be carried out is the central role of the graph module . The graph module  also updates statistics on performance and failures as reported by the transformation module .","During startup, after a crash or otherwise, the crash recovery module  checks if there are any incomplete transformation tasks pending as a result of a prior system shutdown. This module  also queues any incomplete tasks for transformation after the startup sequence is completed.","The state information module  tracks suitable information in short term memory (e.g., RAM) and long-term memory (e.g., disk) for correct operation of the ETS  both during normal operations and for recovery from system shutdown.","The wrapper subsystem controller module  manages the communication between the transformation module  and the actual wrappers , that are locally available to the ETS . The communication is asymmetric in the sense that the controller  to wrapper , communication may be different from wrapper to controller communications. Specifically, the Inter-Process Communication (IPC) module  takes care of wrapper to controller communication in most cases. The controller subsystem  may exist without the application wrapper subsystem .","The application wrapper subsystem  is a collection of one or more wrappers ,, each of which behaves exactly the same way as far as the controller subsystem  is concerned. The wrappers , accept conversion requests from the transformation module , obtain the input file  () from the specified location, deposit the results in the specified location, and report the status of the conversion (success or failure) to the transformation module .","Wrappers present a uniform representation of a conversion to the ETS by hiding all the details of conversions in a particular OS. This takes care of heterogeneity to a large extent. So far as an ETS is concerned, the interface to one converter is like the interface to any other converter. The wrapper invokes the application to obtain the requested service and returns status information to the ETS.","Initialization involves six general steps. First, the init module  reads the configuration file (CF) , which is maintained on local disk . The behavior of the ETS  can be controlled via the configuration file . Preferably, a \u201cnormal\u201d text file is employed which contains name-value pairs where the name is one of the parameters which control the behavior of the ETS  and the value specifies the desired behavior.","The configuration file  is read on start-up before any other actions are taken. If changes to the configuration are to be made, two mechanisms are available to re-configure the ETS : (1) shutdown and re-start; and (2) sending a message to the running ETS. The details of the mechanism for sending such a message are dependent on the operating system and can range from sending a signal (on Unix type systems) to directly logging on the ETS' console (not shown) and issuing a re-configure command or sending an IPC message to re-configure the ETS.","The configuration file  has suitable options (a table of exemplary parameters is shown in Table 1) which may be grouped into the following sections: (1) General: this contains the very basic parameters of the ETS instance, such as, for example, ETS identifier, and available resources; (2) Directories: working directories of the ETS for storing information or files; (3) Disposition: control parameters for disposition of the results of the transformation; (4) Security: these control the authentication mechanism(s) to use, the keys for such mechanisms, the default polices, and allow\/deny lists and trusted ETS hosts within the ETMS; (5) Peer-to-Peer: known peer ETS instances and other policies such as whether to transmit global information, knowledge about other peers; (6) Wrappers: these specify which wrappers to use, basic wrapper costs and other optional information for wrapper invocation, such as the number of times a wrapper may be invoked before being considered faulty; (7) Cost Weights: weights assigned to the different cost components used for cost calculations; (8) Resources: limits on shared resources (e.g., printers, memory, disk-space) (this list may be expanded depending on the specific needs of the wrappers, such as, for example, facsimile and scanners); (9) Transformation Orders: these specify the variables that control how to treat transformations including, for example, default timeouts and failure tolerances; (10) IPC: these select which IPC mechanism to use and the parameters employed by the selected mechanism; (11) Mail: mail handling parameters; and (12) Maintenance: these specify various maintenance and housekeeping variables such as, for example, logging, the administrator and the mailer to use.",{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Configuration File Parameters"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameter",{},{},{}]},{"entry":"Class"},{"entry":["(Sub-","Parameter","Parameter"]},{"entry":["class)","Name(s)","value","Comments"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["General",{},{},"Basic configuration"]},{"entry":[{},{},{},"parameters"]},{"entry":[{},"ETS ID","ETS0001","A character string identifier"]},{"entry":[{},{},{},"for the ETS"]},{"entry":[{},"ETS port","9080","TCP\/IP port number where"]},{"entry":[{},"number",{},"the ETS listens for incoming"]},{"entry":[{},{},{},"requests"]},{"entry":[{},"Host IP","192.168.1.2","IP address of the Host"]},{"entry":[{},"address",{},"Operating System"]},{"entry":[{},"Clean on","Yes\/No","Whether to clean-up"]},{"entry":[{},"Startup",{},"temporary files during startup"]},{"entry":[{},"Copy on","Yes\/No","Whether to copy the resulting"]},{"entry":[{},"Fail",{},"failed file to the given"]},{"entry":[{},{},{},"destination"]},{"entry":[{},"Compressor","Zip\/Unzip","Compression\/decompression"]},{"entry":[{},{},{},"software to use in rotating the"]},{"entry":[{},{},{},"log file"]},{"entry":[{},"Loopback","127.0.0.1","IP address of the Host OS"]},{"entry":[{},"Address",{},"used to communicate with"]},{"entry":[{},{},{},"itself"]},{"entry":[{},"Console","9081","TCP\/IP port number for"]},{"entry":[{},"Port",{},"interactive chat with the ETS"]},{"entry":[{},{},{},"(used for monitoring\/"]},{"entry":[{},{},{},"debugging)"]},{"entry":[{},"Max Idle","60","Maximum number of seconds"]},{"entry":[{},"Time",{},"allowed before the responder"]},{"entry":[{},{},{},"disconnects"]},{"entry":["Direc-",{},{},"Working directories for"]},{"entry":["tories",{},{},"various purposes"]},{"entry":[{},"Home","\/home\/ETS\/ET","The root directory of ETS;"]},{"entry":[{},"Directory","S0001","every other directory is"]},{"entry":[{},{},{},"relative to this directory"]},{"entry":[{},"Received","received","Directory where incoming"]},{"entry":[{},"Directory",{},"files are stored; the actual"]},{"entry":[{},{},{},"directory will be"]},{"entry":[{},{},{},"\/home\/ETS\/ETS0001\/"]},{"entry":[{},{},{},"received"]},{"entry":[{},"Working","working","Directory to store"]},{"entry":[{},"Directory",{},"intermediate files of the"]},{"entry":[{},{},{},"transformation"]},{"entry":[{},"Succeeded","succeeded","Final successful results are"]},{"entry":[{},"Directory",{},"stored here"]},{"entry":[{},"Failed","failed","Final failed results are stored"]},{"entry":[{},"Directory",{},"here"]},{"entry":[{},"Temporary","temp","Temporary directory for ETS"]},{"entry":[{},"Directory"]},{"entry":[{},"Log","log","Log files are stored here"]},{"entry":[{},"Directory"]},{"entry":["Disposi-",{},{},"Disposition control"]},{"entry":["tion",{},{},"parameters"]},{"entry":[{},"Will hold","Yes\/No","Whether the ETS will hold"]},{"entry":[{},{},{},"the results"]},{"entry":[{},"Will Return","Yes\/No","Whether the ETS will return"]},{"entry":[{},{},{},"the results"]},{"entry":[{},"Hold Time","1 hr","Time to hold the result before"]},{"entry":[{},{},{},"the file is purged (hold"]},{"entry":[{},{},{},"disposition)"]},{"entry":[{},"Max Return","5","How many times the ETS"]},{"entry":[{},"Attempts",{},"will try to return the result"]},{"entry":[{},{},{},"before giving up"]},{"entry":[{},"Return","1 minute","Time interval between"]},{"entry":[{},"Retry",{},"attempting to return result"]},{"entry":[{},"Interval",{},"again"]},{"entry":["Security",{},{},"Authentication\/Authorization"]},{"entry":[{},{},{},"related parameters"]},{"entry":[{},"Default","P or D","If P then permit if not"]},{"entry":[{},"policy",{},"explicitly denied; if D then"]},{"entry":[{},{},{},"deny if not explicitly"]},{"entry":[{},{},{},"permitted"]},{"entry":["Permit list","IP address,","192.168.1.15,","ETSs which are permitted to"]},{"entry":[{},"ETS ID","ETS0021","use the service"]},{"entry":["Deny list","IP address,","192.168.2.76,","ETSs which are not permitted"]},{"entry":[{},"ETS ID","ETS1234","to use the service"]},{"entry":["Author-","Auth file","Auth_file","File name of list of authorized"]},{"entry":["ized","name",{},"hosts list; each line of this file"]},{"entry":["Host list",{},{},"contains an IP address, and"]},{"entry":[{},{},{},"ETS ID pair values for all"]},{"entry":[{},{},{},"hosts which can access this"]},{"entry":[{},{},{},"ETS"]},{"entry":[{},"Authoriza-","1a7r64x0pW15","A random secret string for"]},{"entry":[{},"tion key",{},"authorization"]},{"entry":[{},"Authoriza-","MD5","Type of authorization to use"]},{"entry":[{},"tion type"]},{"entry":["Peer-to-",{},{},"Peer-to-peer control"]},{"entry":["Peer",{},{},"parameters"]},{"entry":[{},"Master","Yes\/No","Whether it is a master server"]},{"entry":[{},{},{},"itself"]},{"entry":[{},"Master","192.168.1.25","The master server which"]},{"entry":[{},"server",{},"knows about all peers"]},{"entry":[{},"Global","Yes\/No","Propagate global graph info"]},{"entry":[{},"graph",{},"or only local graph info"]},{"entry":[{},"Multicast","192.168.1.90","Officially assigned multicast"]},{"entry":[{},"Address",{},"address"]},{"entry":[{},"Cascade","5","Number of times to forward"]},{"entry":[{},"TTL",{},"message"]},{"entry":[{},"Propagate","Yes\/No","In cascade queries whether to"]},{"entry":[{},"query",{},"propagate the query or"]},{"entry":[{},{},{},"terminate"]},{"entry":[{},"Repoll Time","15 min","How often to re-poll peers; if"]},{"entry":[{},{},{},"0 then no repoll"]},{"entry":["Peer","Peer file","Peer_file","File name of list of hosts;"]},{"entry":["Host list","name",{},"each line of this file contains"]},{"entry":[{},{},{},"an IP address, and ETS ID"]},{"entry":[{},{},{},"pair values; these are ETSs,"]},{"entry":[{},{},{},"which it can use to get service"]},{"entry":[{},{},{},"from"]},{"entry":[{},"Failed Peers","Peers.fail","List of peers which have"]},{"entry":[{},"file",{},"failed"]},{"entry":["Wrappers",{},{},"Parameters for wrappers"]},{"entry":[{},"Wrapper","10 min","Time interval for polling for"]},{"entry":[{},"polling",{},"new wrappers in the wrappers"]},{"entry":[{},{},{},"directory; if 0 then no polling"]},{"entry":[{},{},{},"is allowed"]},{"entry":[{},"Wrapper","wrappers","Directory where the wrappers"]},{"entry":[{},"Directory",{},"are installed"]},{"entry":[{},"Built-ins","built-ins","Directory where built-ins are"]},{"entry":[{},"Directory",{},"installed"]},{"entry":[{},"Wrapper","5","Weight assigned to a failure;"]},{"entry":[{},"Failure",{},"successes are always assigned"]},{"entry":[{},"Weight",{},"a weight of 1"]},{"entry":[{},"Local Time-","20","Number of seconds before a"]},{"entry":[{},"out",{},"local time-out occurs"]},{"entry":[{},"Remote","60","Number of seconds before a"]},{"entry":[{},"Time-out",{},"remote time-out occurs"]},{"entry":[{},"Max Time-","3","Maximum time outs allowed"]},{"entry":[{},"outs",{},"for each wrapper"]},{"entry":[{},"Max","5","Maximum number of failures"]},{"entry":[{},"Failures",{},"allowed for a wrapper"]},{"entry":[{},"Max count","5","Maximum number of"]},{"entry":[{},{},{},"wrappers to check for picking"]},{"entry":[{},{},{},"best wrapper"]},{"entry":["Cost",{},{},"Weights assigned to different"]},{"entry":["Weights",{},{},"cost components"]},{"entry":[{},"Edgelet","5"]},{"entry":[{},"failure count"]},{"entry":[{},"Local or","3"]},{"entry":[{},"Remote"]},{"entry":[{},"Quality","2"]},{"entry":[{},"Per kilobyte","2"]},{"entry":[{},"Per","1"]},{"entry":[{},"invocation"]},{"entry":["Resources",{},{},"Global values of available"]},{"entry":[{},{},{},"resources"]},{"entry":[{},"Printers","1","Number of printers available"]},{"entry":[{},"Memory","100 Mb","Amount of main memory"]},{"entry":[{},{},{},"available"]},{"entry":[{},"Disk","1 Gb","Amount of disk space"]},{"entry":[{},{},{},"available"]},{"entry":["Transfor-",{},{},"Parameters controlling"]},{"entry":["mation",{},{},"transformation orders"]},{"entry":["Orders",{},{}]},{"entry":[{},"Transforma-","10 min","Default time-out for a"]},{"entry":[{},"tion Time-",{},"transformation order"]},{"entry":[{},"out",{}]},{"entry":[{},"Max","4","Maximum number of"]},{"entry":[{},"Transforma-",{},"transformation attempts to be"]},{"entry":[{},"tion",{},"made per edge"]},{"entry":[{},"Attempts ",{}]},{"entry":[{},"Transforma-","T0001.tof","Where the transformation"]},{"entry":[{},"tions Orders",{},"order is stored on disk (in"]},{"entry":[{},"File",{},"working directory)"]},{"entry":[{},"Keep","Yes\/No","Whether to store"]},{"entry":[{},"Transforma-",{},"transformation orders which"]},{"entry":[{},"tion orders",{},"have completed successfully"]},{"entry":["IPC",{},{},"Inter-Process Communication"]},{"entry":[{},{},{},"parameters"]},{"entry":[{},"IPC","npipeipc.py","Which IPC command to use"]},{"entry":[{},"command"]},{"entry":[{},"IPC Pipe","\/tmp\/ETSPIPE","The named pipe to use for"]},{"entry":[{},"Path",{},"IPC"]},{"entry":[{},"IPC port","9082","Which tcp\/ip port to use"]},{"entry":[{},"File IPC","\/home\/ETS\/ET","If file IPC is used, where to"]},{"entry":[{},"Directory","S0001\/fileipc","find the files indicating a"]},{"entry":[{},{},{},"message"]},{"entry":[{},"File IPC","2","How many seconds elapse"]},{"entry":[{},"Time",{},"before checking for file-based"]},{"entry":[{},{},{},"IPC messages"]},{"entry":["Mail",{},{},"Mail handling parameters"]},{"entry":[{},"Mail","sendmail","Which mail transfer agent to"]},{"entry":[{},"Transfer",{},"use locally"]},{"entry":[{},"Agent"]},{"entry":[{},"Mail Relay","xyz.com","Which site to use to relay"]},{"entry":[{},{},{},"mail"]},{"entry":[{},"Mail","\/home\/ETS\/ET","Where to store messages that"]},{"entry":[{},"Message file","S0001\/mail","could not be sent"]},{"entry":["Mainten-",{},{},"Administration and"]},{"entry":["ance",{},{},"maintenance related"]},{"entry":[{},{},{},"parameters"]},{"entry":[{},"Manager","John Smith","Name of manager"]},{"entry":[{},"Notify","Yes\/No","Whether to send messages to"]},{"entry":[{},"Manager",{},"the manager when special"]},{"entry":[{},{},{},"events take place"]},{"entry":[{},"Manager's","js@xyz.com","Where to send messages to"]},{"entry":[{},"e-mail",{},"the manager"]},{"entry":[{},"address"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Second, after reading the configuration file , initializing the logging subsystem (not shown) includes opening the log file, and archiving previous logs.","In the third step, the communication module  is initialized. This module is set up so that the ETS  may query other ETSs in the system to build-up initial lists of ETSs it can use for transformation services. During this time, the ETS can also receive similar queries from other ETSs. However, the ETS still cannot entertain any Transformation request because the transformation module  is not yet set up do so.","Fourth, the security module  is initialized by setting up the list of hosts that are denied permission to access the ETS (Deny Host List) and the hosts which are permitted to access the ETS (Permit Host List). If so configured, other ETSs are queried for their knowledge regarding other ETSs. If new ETSs are found, then those are added to the Peer Host list (i.e., if the new ETS is not in the Deny Host List from the configuration file ). The Authorized Host list contains some hosts from the Permit Host list and any other hosts which are not in the Deny Host list and yet allowed because of the default security policy.","In the fifth step, the IPC module  is initialized. This module is responsible for local communication from the wrappers , to the wrapper subsystem controller module .","Finally, the transformation module  is started. This module, then, essentially runs the rest of the time as the core controlling module.","Authorization and authentication in the ETMS (i.e., the community of ETSs) is delegated in the sense that an ETS authenticates and authorizes another ETS and depends on the latter to control access (user or application) to itself. Authentication means establishing that the entity is indeed the entity it claims to be, while authorization determines what an authenticated entity is permitted to do. Authentication can take a number of approaches, such as, for example, to permit the negotiation of authentication methods between two ETSs ,. In this approach, on initial negotiation, each side sends its preferred method to the other. Each then replies positively or negatively. The response to a negative reply can be to refuse connection or to suggest another authorization technique. This negotiation (or \u201cchat\u201d) proceeds until both sides agree on the method to be used. Then, depending on the agreed method, other exchanges take place to establish each party's identities to the other's satisfaction. There are many known methods ranging from simple clear text passwords (the least secure) to much more secure one-time passwords. In the first case, the initiator is asked to send a password that is compared to the password expected by the responder. If they match, the responder authenticates the initiator. The reverse authentication is similar where the initiator authenticates the responder. The same password is used repeatedly. After a password is changed, both parties in the transaction update their information. Secure one-time password authentication is similar, but the password is never re-used. Although exemplary authentication techniques are disclosed, a wide range of authentication methods may be employed.","While there are a wide range of authorization techniques, the model used in the exemplary ETMS is a simple permit\/deny model. This model has three elements: a permit list, a deny list, and a global default policy (these are defined in the Security section of the configuration file  and are set by the init module ). The permit list defines those ETSs that are allowed to use this ETS . The deny list is employed to establish ETS(s) to whom services are refused. The global setting defines the default policy: permit if not explicitly denied, or deny if not explicitly permitted. While all three are configuration parameters, it is generally recommended that intranets use the restricted deny-then-permit policy, while Internet service providers might choose the permit-then-deny approach.","The communication module  deals with external communication (i.e., with remote peers or clients). As shown in , the communication module  performs two principal simultaneous roles: the responder  and the initiator . All communications started by an ETS (e.g., peer ETS A ) to another (e.g., peer ETS B ) take place between ETS A's initiator  and ETS B's responder \u2032.","The responder  continuously looks for any incoming request for one of the various services that the ETS  is capable of providing. Once a request is made, the responder  decodes the request and passes the request on to the transformation module  of . The responder  deals with the following exemplary service requests: (1) peer request; (2) request for graph; (3) status request of prior transformation request; (4) cancellation of prior transformation request; (5) transformation request; (6) receive a file that has been transformed by the initiator; (7) send a file that has been transformed by the responder; and (8) notification as to success and failure when necessary.","For most cases, the initiator  of a communication is an instance of the ETS and is embedded in the communication module . However, when external software needs to contact an ETS, the initiator  can be used all by itself to generate the appropriate requests to the ETS. The initiator  may sleep and awaken whenever an ETS instance needs to communicate with an external entity, whether it is a client application or another ETS instance.","The communication between the initiator ,\u2032 of one ETS instance and the responder ,\u2032 of another ETS instance is symmetric. That is, the initiator generates the request, which the responder expects. Before every request can be made, an Open Connection step is employed during which security related negotiations are completed. Only after this initial \u201cchat\u201d does an ETS instance continue with the actual request. The following table illustrates the symmetry between what the initiator  sends and what the responder \u2032 receives:",{"@attributes":{"id":"p-0114","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Initiator\/Responder Communications"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Initiator","Responder","Comments"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Open","Accept Connection","can initiate a security negotiation"]},{"entry":["Connection",{},"before accepting the connection"]},{"entry":["Send Peers","Peer Request","may be refused according to policy"]},{"entry":["Send Graph","Graph Request","request local conversion capabilities"]},{"entry":[{},{},"or all known capabilities"]},{"entry":["Send Status","Status Request","for a previous transformation"]},{"entry":[{},{},"request"]},{"entry":["Cancel","Cancel Request","for a previous transformation"]},{"entry":[{},{},"request"]},{"entry":["Transform","Transformation","request for a file transformation"]},{"entry":[{},"Request","service"]},{"entry":["Send File","File Request","result of a previous transformation"]},{"entry":[{},{},"request"]},{"entry":["Receive File","Returning Request","wait to receive a file"]},{"entry":["Notification","Notification Request","a notification about some event"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Of these communications, the Transformation request is the main engine of the transformation service. This request depends upon the topology of the graph (e.g.  of ) and the operations provided by the graph module  of . The rest of the requests are mainly administrative in nature. The Peer request, Graph request and Status request are employed to obtain information from an ETS. The Cancel request and the Transformation request lead to some action on the part of the ETS. The Send and Receive File requests involve a transfer of the result (or an intermediate result) file. Each incoming request is characterized by suitable arguments.","In the case where a client initiates the request instead of an ETS, the same information is employed.","Once a responder \u2032 receives a request from an initiator , it reacts to the request in a manner specific to each of the requests. As discussed below, every multi-step interaction employs an acknowledgement whereby the responder returns a positive acknowledgment (ACK) or a negative acknowledgement (NACK) indicating that it is OK to proceed or to stop the request, respectively.","For the Open Connection request, once the communication network connection is open, the two sides authenticate each other, as discussed above. The responder confirms with an ACK and a time stamp of when it was last started (booted up) and then waits for other requests from the initiator. The initiator may employ the time-stamp if that information is old. The initiator either sends requests or closes the connection depending on its reaction to the authentication exchanges.","For a Peer request, the initiator  of ETS  may request a list of peers known to the responder \u2032 of ETS . (Similarly, initiator \u2032 of ETS  may request a list of known peers from the responder  of ETS . According to the policy established by the administrator of the responder, the list may be sent to the initiator  of ETS . Otherwise, a NACK is sent. The ETS  maintains this list in the Peer Host list.","The Graph request returns a local or global graph as requested. A global graph contains all conversion services known by the responder. A local graph contains all services the responder controls locally. The list of valid wrappers (with appropriate information, such as costs) is sent to the initiator.","The Status request first checks the validity of the request by confirming a transformation ID as sent by the initiator and confirming that the host ID matches the host id stored for the transformation ID. Second, if the request is valid, then the current status of the transformation is returned. Otherwise, a NACK is sent.","The Cancel request first checks the validity of the request by confirming the transformation ID as sent by the initiator and confirming that the host ID matches the host id stored for the transformation ID. Second, if the request is valid, then the transformation identified by the ID is cancelled and a positive acknowledgement is sent. Otherwise, a NACK is sent.","The Transformation request is sent to the ETS responder along with the following information: (a) source type of the file, (b) the desired destination type, (c) the disposition of the file and the relevant disposition argument, (d) the acquisition parameter, and, if applicable, (e) the file encoding type.","As shown in , the following steps are performed in response to receiving, at , a Transformation request. At , the feasibility of the Transformation request is checked (as discussed below in connection with , whether the ETS has the ability to perform the transformation, and whether the disposition type and acquisition types are acceptable). If not feasible, then a NACK is returned at . Otherwise, if the transformation is feasible, then a unique identifier or a key (transformation ID) is generated for future reference to the request and is sent back to the initiator along with an ACK at . The host id of the initiator is also stored for this Transformation request to confirm the validity of any future requests pertaining to this transformation ID. Next, at , the file is received from the initiator and decoded. At , the optimal transformation path (OTP) is determined as discussed below in connection with . Next, at , the transformation order is created and entered, at , into the transformation queue ( of ). Then, at , the transformation is performed. Finally, at , the result is returned along with the success or failure status of the transformation.","The above steps may be coarsely classified as acquisition (steps ,,), disposition (step ), and those using the transformation module  (steps ,,,). The above steps happen in a detached fashion. After the file is received, the connection may be closed depending on the disposition requirements and re-established, later, when the transformation module  finishes the task.","In the Send File request, the initiator asks the responder to return (send) the results of a previous transformation request from the initiator. The initiator sends the transformation ID with this request. The Send File request includes the following steps: (1) the validity of the request is checked by confirming the transformation ID as sent by the initiator (and confirming that the host ID matches with the one previously stored for the transformation ID); (2) if the request is valid, then the status of the transformation is checked; (3) if not done, a PENDING response is returned; (4) otherwise, a response indicating the status of the transformation is returned along with the size and encoding of the resulting file. The initiator responds with an ACK or a NACK. If a NACK, the transformation request is disposed; and (5) if an ACK is received, the file is sent to the initiator and the transformation request is disposed.","For the Receive File request, the initiator asks the responder to accept (receive) the results of a previous transformation request from the responder. The initiator sends the transformation ID with the request. The Receive File request includes the following steps: (1) the initiator sends the request along with the transformation ID, the transformation status, and the size and encoding of the resulting file; (2) the responder checks the validity of the request by confirming the transformation ID as sent by the initiator and confirming that the host ID matches with the one stored for the transformation ID. If the request is valid, then an ACK is sent and the responder waits to receive the file. Otherwise, a NACK is sent; and (3) the initiator sends the file to the responder.","The Notification request is used either for: sending a message to the administrator in the event of a failure, or for sending a message to another ETS in the event of a transformation failure. The former is used when a catastrophic failure occurs or when various time-outs expire without any relevant response. Here, the initiator sends a transformation ID of the order, which resulted in the failure and a text message.","Although an exemplary set of commands is disclosed, further commands to extend the functionality can be added to the above list. In addition, the list of arguments to each of the commands can also be extended to accommodate a particular situation. For example, a unique ID can be added to the transformation request parameters which then can be used by the responder to modify the behavior of a particular transformation or a subset of the converters.","The file to be transformed by an ETS may be acquired or disposed of in a variety of ways.  summarizes the various paths of such acquisition and disposal. For a client  on a different operating system (OS)  than that of the ETS instance , all communication happens over the external network link . Otherwise, for client software  in the same OS  as the ETS instance , the file transfer may happen through the local OS file system . The client  and the ETS  are suitably connected by an internal \u201cnetwork\u201d link . Similarly, disposition can happen through both the external network link  (which may be the same as the link ) or the local file system . In the case of disposition, the results may also be packaged in such a way that a standard client  (e.g., mail system, facsimile, printer) on another OS  can also accept the transformed file. A standard client does not need to understand the rest of the ETS protocol.","For acquisition, a file may be available either in the file system  or via the computer network ,, which results in the file being sent to the file system . The two approaches are distinguished in the transformation request by the type of the acquisition and its parameters. If the type is NETWORK, then a pure number is the argument which represents the SIZE of the file to be received over the network . If the type is COPY, then the argument is a character string, which defines the location of the file in the file system , in order that the ETS  can obtain it from the specified location. Typically, file transfer over the network  is employed. The COPY acquisition type is useful when both the requesting application and the ETS instance  are under the same operating system. This is because both the requesting application and the ETS instance must have access to same file system. A shared file system (not shown), residing on an entirely different host on the network can also be used when both the client and the ETS have appropriate permissions to access the file system over the network.","If the original source of the file is some other hardware device (e.g., facsimile, scanner), then an intermediate agent (not shown) is responsible for the acquisition of the bits and depositing them on the network pipe (not shown) or in the file system . Note, however, that by using the COPY acquisition method on operating systems that deal with hardware devices in a uniform way (such as Unices), any hardware device can become the direct source of a file.","Furthermore, any input file may be encoded for various reasons (e.g., compression (reducing disk space and network traffic), transmission (sending binary 8-bit data over a 7-bit link)). This is accomplished via the encoding argument in the Transformation request.","Similar to the acquisition case, the results of the transformation may be disposed of in a variety of ways. Certain transformations may impose rigid requirements on the type of final output generated. For example, a print request (e.g., a transformation of the form <source mime type> <postscript printer>) to local printer  necessarily results in the output being on some form of \u201chard copy\u201d such as paper, and its disposition necessarily requires physical \u201chard copy\u201d transmission. Similar to the acquisition case, certain hardware devices may be the targets of the final disposition by using the COPY disposition type where, if the operating system supports it, the COPY destination is the hardware device rather than a conventional disk file.","On the other hand, for the more general case in which the final result is in the form of a traditional computer file, the mechanisms to return the file are also varied. While there are a very large number of methods of acquiring the source file for a transformation and a similarly large number of methods for disposing of the results of the transformation, the most common of these are shown in . For simplicity of illustration, the initial connection, authentication, and other exchanges between the initiator (I) and the responder (R) are not shown. In , ETS is the original requestor or initiator I and ETS is the original responder R. Except as noted, the communication process is ideal in the sense that potential negative acknowledgement(s) (NACK(s)) are not shown.",{"@attributes":{"id":"p-0136","num":"0135"},"figref":"FIG. 9A","b":["160","1","2","162","1","1","2","164","1","2","166","2","167"]},"At this point, ETS processes the transformation order just received from ETS. When the transformation order has been completed on ETS, it opens a connection to ETS and sends the RECEIVE command along with the transformation ID, the status of the transformation, and the resulting file-size to ETS at . If this is acceptable to ETS (i.e., the ID is correct and it is able to receive the file), then ETS sends an ACK to ETS at . ETS sends the file to ETS at . The ETS sends an ACK (not shown), and both sides close the connection. Finally, ETS cleans-up all information about this transformation order.","The HOLD disposition method  is shown in . In this method, ETS requests ETS to hold on to the results of the transformation. Implicitly, ETS will, at a later time, initiate a connection and request that ETS return the result by using a SEND command (Send File request). The two sides negotiate the maximum amount of time that ETS will hold the result after which ETS is free to clean up the transformation order. At , ETS sends a transformation request with the HOLD disposition method, the number of minutes it would like ETS to hold the result before it is free to clean up, and the file-size. If this is acceptable to ETS, it returns an ACK, which contains the maximum time that ETS is willing to hold the result, along with a transformation ID at . If the response from ETS (i.e., the amount of time it is willing to hold the result) is acceptable, ETS sends the file to ETS at . Otherwise, ETS and ETS close the connection. After , ETS sends an ACK (not shown) to ETS, and both sides close the connection at .","Within the agreed upon HOLD time, ETS initiates a connection with ETS to retrieve the result. ETS sends a SEND command with the transformation ID at . If the transformation for this ID has not yet been completed, then ETS returns a NACK (not shown) with the PENDING response message. On the other hand, if the transformation for this ID has been completed, then ETS sends an ACK, the conversion status, and the resulting file-size at . If this is acceptable to ETS (i.e., it is able to receive the file), then ETS sends an ACK to ETS at . ETS sends the file to ETS at . The ETS sends an ACK (not shown), both sides close the connection, and ETS cleans-up all information about this transformation order.","The COPY disposition method  is shown in . In this method, in which the two sides share a common file system, ETS requests ETS to copy the final file transformation to the given file location. If the underlying operating system permits the operation, the COPY method may be employed to send the result to a device (such as a facsimile machine or a printer) by specifying the device as the final destination path. ETS sends a transformation request with the COPY disposition method, the file-path to where the final result should be placed as the disposition argument, and the file-size at . If this is acceptable to ETS (i.e., ETS has write permission on the relevant destination path), then it returns an ACK along with a transformation ID at . ETS sends the file to ETS at . The ETS sends an ACK (not shown), and both sides close the connection at . When the transformation order has been completed on ETS, at , it copies the final result to the given destination  (e.g., disk, printer). If a mail address was specified along with the transformation request, then mail (not shown) is sent indicating the status of the result. Finally, ETS cleans-up all information about this transformation order.","The WAITING disposition method  is shown in . In this method, the initiator indicates that it would keep the network connection open until the transformation is completed. At that point, the responder returns the results using the open connection. ETS sends a transformation request with the WAITING disposition method and the file-size at . If this is acceptable to ETS, it returns an ACK along with a transformation ID at . ETS sends the file to ETS at . The ETS sends an ACK (not shown), and ETS waits with the connection still open at . When the transformation order has been completed on ETS, it sends the RECEIVE command to the waiting ETS along with the transformation ID, the status of the transformation and the resulting file-size at . If this is acceptable to ETS (i.e., the ID is correct and it is able to receive the file), then ETS sends an ACK to ETS at . ETS sends the file to ETS at . The ETS sends an ACK (not shown), and ETS cleans-up all information about this transformation order.","The MAIL disposition method  is shown in . In this method, the ETS initiator indicates that the ETS responder should return the results of the transformation to the initiator as a mail message (i.e., e-mail). ETS sends a Transformation request with the MAIL disposition method, the mail address as the disposition argument, and the file-size at . As a security decision, the host part of the mail address can be fixed at the initiator's host address in order that a third party transfer is not possible. If this is acceptable to ETS, then it returns an ACK along with a transformation ID at . ETS sends the file to ETS at . The ETS sends an ACK (not shown), and both sides close the connection at . When the transformation order has been completed on ETS, it creates a mail message whose contents are the status of the conversion and the resulting file is packaged as an enclosure. The mail is then sent at  to the designated address through a suitable mail transfer agent (MTA) . Finally, ETS cleans-up all information about this transformation order.",{"@attributes":{"id":"p-0143","num":"0142"},"figref":["FIG. 10A","FIG. 10B"],"b":["260","261","266","261","262","263","264","265","266","261","262","263","266","264","265","268","265","266","263"]},"Each edge is unique in a transformation graph and is further composed of one or more edgelets. Each edgelet represents a unique application wrapper (either locally available or remotely available). Consider the six wrappers \u2013 shown in  belonging to two different ETS instances (e.g., Instance A  is under Linux OS and Instance B  is under Windows OS). The wrappers \u2013 are as follows, for ETS A , : PS to PDF; : PS to Text; : WP (WordPerfect) to Text; and : WP to PDF, and for ETS B , : WP to Text, and : WP to PS.","The corresponding transformation graph , after merging together the wrappers \u2013 from each of the ETSs (A and B) ,, is shown in . There are two edgelets (wrappers ,) corresponding to the edge representing the conversion from WordPerfect (WP) to Text. In addition to edge , there is another way (edges  and ) of transforming a WordPerfect file to PDF via an intermediate format (i.e., PS). Thus, a WP to PDF transformation can be performed in two ways: a direct method, and a two-step conversion sequence.","If, however, the two exemplary WordPerfect applications are considered different (e.g., because one may want to distinguish between the Linux version and the Windows version), the two nodes corresponding to the WordPerfect format cannot be merged into a single node and the resulting graph would be different (not shown).","Each edgelet may also be associated with attributes employed for graph operations, and statistical and cost calculations. For example, these attributes include: (1) the number of times that the wrapper corresponding to the edgelet failed; (2) whether the edgelet is local or remote; (3) if local, whether it is built-in or not; (4) the speed; (5) fidelity; (6) monetary cost of the conversion; and (7) if remote, the speed of the network link.","In summary, an edge represents the capacity to perform a conversion, while an edgelet represents the actual agency (converter) through which the transformation is performed. The data stored by each structure reflects this division. The edge consists of the source and destination types, and an ordered list of one or more edgelets.","The actual ordering of an edgelet list is subject to the ETS instance and may change to accommodate reliability, scalability and the like. This capacity is noted in the Edgelet Pick algorithm  (). The edgelet, in turn, includes information useful for executing the associated wrapper: invocation costs, wrapper path, and the current state of the wrapper (IDLE or not).","The graph module  of  also maintains a list of any edgelets that have failed too many times. Initially, this list is empty. Edgelets are inserted in this list during the operation of the ETS instance when they fail too many times (as discussed below in connection with updating the transformation order).","The transformation graph (e.g.,  of ) may also be represented as an adjacency matrix. An adjacency matrix is a square matrix where each row and each column represents a unique type. The matrix is initially filled with zeros. A logic zero (0) entry indicates that no conversion path exists between the file type indicated by the row to the file type indicated by the column. A logic one (1) is entered for the case where a one-step conversion path exists. An entry of one in the matrix also denotes that there is an edge in the corresponding graph. As a special case, a one is also entered for the trivial case of self-transformability (e.g., a PDF to PDF conversion is trivial, if not unnecessary, and no wrapper is really required).  shows an exemplary Adjacency Matrix , A, for the wrappers \u2013 of .","As shown in , a second matrix R, Reachability Matrix , is created from the first matrix, A . This new matrix, R, has the same dimension as the matrix A except that an entry of one (1) indicates that the particular transformation is possible using zero or more conversions. Preferably, a version of the Floyd-Warshall algorithm (see Cormen, T. H., et al., Introduction to Algorithms, pp. 552\u2013565, The MIT Press, McGraw Hill Book Company, ISBN 0-262-03141-8) employs a dynamic programming method to obtain the Reachability Matrix R. The process is known as finding the transitive-closure of the Adjacency Matrix A. The idea of this algorithm is based on the observation that the Reachability Matrix R can be incrementally constructed by finding two-step conversion paths using some intermediate format. There can be two paths from one format type, i (a row entry in the matrix), to another format type, j (a column entry in the matrix): (a) the corresponding entry, r, is already one, or (b) a path exists from the source type, i, to another intermediate type, k, and a path exists from the intermediate type, k, to the destination type, j.","Since there are n types of formats, by performing the above steps for all possible format types (i.e., k takes a value from 1 through n), the algorithm is guaranteed to find the Reachability Matrix R. The algorithm  is shown in . First, at , set matrix R=matrix A, and set temporary matrix T=NULL (all zeros). At , set k=1. Set i=1 at , and set j=1 at . Set the entry tin matrix T as follows: t=rOR (rAND r) at . Increment j by 1 at . If j is less than or equal to n at , then go to step . Otherwise, increment i by 1 at . If i is less than or equal to n, then go to step . Otherwise, set matrix R=matrix T at , and increment k by 1 at . If k is less than or equal to n at , then go to step . Otherwise, the algorithm  is completed at .","Ordinarily, the algorithm  can become very time consuming for very large matrices (e.g., order of (n) in the worst case), but since this is done very infrequently (i.e., only when the graph changes), this is usually of no consequence. There are many known techniques to speed up the computation if needed.","A feasibility check for a given transformation from a source type to destination type merely employs a lookup in the Reachability Matrix. This can be done very fast and, hence, one can rule out any infeasible transformation request as soon as the request is made. For example, in the Reachability Matrix  of , PPT to Text is feasible, and Word to PPT is not feasible.","All ETSs in a peer network know the entire graph and the corresponding Reachability Matrix as long the security requirements allow each ETS to get the graph of every other ETS in the system.","The ETS employs a three-stage algorithm () to obtain Quality-of-Service (QOS), reliability, and scalability. The three-stage transformation process includes: (1) a fast feasibility check; (2) Optimal Path selection (); and (3) selecting the best edgelet or the converter (). Initially, each ETS instance publishes its available services to its peers in the form of a graph wherein each node is a labeled document format type. The edge, if it exists, represents the existence of at least one converter able to convert from one node format type to the other node format. The Reachability Matrix is also constructed. The three-step transformation path selection is efficient from a service point of view in that the validity of requests may be determined relatively quickly even when the graph is large and there are many edges in the graph.","In the exemplary method, the graph is defined only over the different format types with a single edge between two format types if and only if there is at least one edgelet that performs the necessary conversion between those two types. An alternative formulation would be to define the graph over all the combination of mime types and converters. However, this could, potentially, lead to a very large graph and since graph algorithms tend to degrade rapidly based on the number of edges and nodes in them, keeping the graph small pays off in terms of efficiency (both disk and\/or memory storage of the graph and computation).","In order to use the exemplary three-step process, a pre-requisite is the calculation of the Reachability Matrix () that is computed easily from the Adjacency Matrix (), although this computation might be expensive. However, there are features of this matrix multiplication that can be used to reduce the expense of the computation. In any case, this is a startup expense (or re-startup) which can be amortized over the many transformation requests that an ETS is expected to receive. Given this pre-requisite Reachability Matrix, the three exemplary steps are summarized below.","First, a high-speed check of the feasibility of the requested transformation(s) is made employing a Reachability Matrix lookup. This matrix is constructed when the transformation graph is created or modified and can be used to very efficiently determine if the requested destination format can be obtained from the given source format using any combination of available converters. Second, the optimal path is selected (i.e., the series of edges of the graph that must be traversed in order to achieve the feasible transformation request). An optimal path is one that has the least \u201ccost\u201d of the set of feasible paths. Third, for each edge on the transformation path identified in the second step, above, select a specific converter from the set of available converters to traverse the edge. The ETS instance determines which transformation would be the best based on a dynamic vector of attributes characterizing each converter. This may be solved in linear time, which is based upon the count of edgelets for the edge.","Wrappers may be added or deleted while the ETS is running. The most common examples are when the system administrator adds\/deletes a wrapper, a new peer is discovered (as discussed below in connection with dynamic updating), a peer shuts down, or when a peer informs the ETS that a wrapper is added\/deleted. Wrapper deletion also takes place when the converter determines that a wrapper has failed too many times and must be removed. In any case, the graph needs to be updated. Adding\/deleting edges is the consequence of adding\/deleting edgelets, since an edge represents one or more edgelets.","For edgelet addition, the steps include: (1) finding the corresponding edge in the graph; (2) if there is no edge, then creating a new edge and recomputing the Adjacency Matrix, A, and recomputing the Reachability Matrix, R; and (3) adding to the list of edgelets for the edge.","For edge\/edgelet deletion, the steps include: (1) finding the corresponding edge in the graph; (2) deleting the edgelet from the list of edgelets; and (3) if the list becomes empty, then deleting the edge and, also, recomputing the Adjacency Matrix, A, and recomputing the Reachability Matrix, R.",{"@attributes":{"id":"p-0164","num":"0163"},"figref":"FIG. 14","b":["330","332","334","336","1","338","2","340","1"]},{"@attributes":{"id":"p-0165","num":"0164"},"figref":"FIG. 14","b":["1","2","340","342","2","343","356","1","344","346","1","1","1","348","350","1"]},"Otherwise, at , determine whether edgelet e is in edge E. Edgelets are grouped together in edges, which represent a single conversion service (e.g., a Postscript\u2192PDF conversion). If an ETS instance knows of one or more edgelets that perform that conversion service, then its transformation graph possesses an edge of the corresponding type. Thus, if edgelet e is not present at , then add edgelet e to the edge E at . Regardless, at , determine if there are any unexamined edgelets left in G. If there are, at , then go back to step  of the Graph Merge algorithm . Otherwise, at , compute the Reachability Matrix before completing the algorithms , at . Steps , , , , , and  define an Edgelet Add algorithm .","Referring to , for Optimal Transformation Path (OTP) selection, the following information is given: (1) a pair of source and destination file format types; and (2) a list of forbidden edges (i.e., those edges that have failed too many times for this transformation order). The objective is to find the optimal path (i.e., a list of edges) using a suitable Shortest Path algorithm. In this embodiment, a variation of the Breadth-First Search (BFS) algorithm (Cormen et al., Introduction to Algorithms, pp. 469\u201375; 532\u201335) is used, although any suitable graph algorithm may be employed. In one embodiment of the present invention, ETS transformations are predicated on minimum wrapper count. That is, the transformation should, ideally, traverse the minimum possible number of edges.","Consider the problem of getting from format type A to format type D (in which the numbers in parentheses refer to cost). Try: (1)A\u2192(10)B\u2192(20)C\u2192(30)D; versus: (2)A\u2192(70)D. In this example, one would prefer the first route because there is no inherent penalty (e.g., the cost is 60 versus 70) in going through B and C to get to D. However, if there is a penalty to simply visiting intermediate points (i.e., intermediate conversions), then the direct path can turn out to be less expensive. This principle is employed in the OTP determination algorithm , which guarantees a shortest path if such a path is available. The exemplary Breadth-First Search progresses as follows. A transformation graph G, a start node S, a target node T, and a list of forbidden edges FE are assumed to be known. Edges are \u201cforbidden\u201d in the case of a conversion failure. If a conversion fails with a specific edge (i.e., all available wrappers on this edge have failed for this request), then that corresponding edge is marked as being forbidden.","Referring to , at , a new Node list, NN, is initialized including the source node S. The predecessor of node S is set to null (Pred(S)=NULL), and the node S is marked as unsearched and not visited. This node list is a queue of nodes to be visited by the Breadth-First Search. The predecessor table is employed to look up the node, which was searched directly before the target node, and to construct an optimal path in the final step. Also, the Adjacent Node list AN is set to NULL, and the Target Node is set to T.","Then, at , it is determined if there are any unsearched nodes in Node list NN. If no, then the search failed at . Otherwise, at , the next unsearched node, n, is picked in Node list NN, and node n is marked as searched. At , a list is made of the adjacent edges of node n, by finding all the out-directed edges of n, where n is the source node. Next, at , all the edges are removed which match any of the edges in the forbidden list FE. Then, at , the Adjacent Node list AN is set to the target nodes of all the found edges. An adjacent node has an edge in common with n, for example, if there is a path from Postscript to PDF, then PDF is adjacent to Postscript. If Adjacent Node list AN is empty at , then go back to step . Otherwise, at , pick the next node n\u2032 from the Adjacent Node list AN.","Next, at , the Node list NN is checked to find if node n\u2032 is visited already. If so, at , then node n\u2032 is removed from Adjacent Node list AN and that list is rechecked at step , to determine if the list is empty. Otherwise, if node n\u2032 was not visited, then it is marked as visited at . Also, the predecessor of n\u2032 is set to n (i.e., Pred(n\u2032)=n) and node n\u2032 is added to the Node list NN. Then, at , if node n\u2032 is equal to the target node T, then stop and execute the Backtrace algorithm  of . Otherwise, the Adjacent Node list AN is rechecked at step .","The Backtrace algorithm  of  begins by initializing the Path list P with the target node T, and setting a node t equal to target node T at . Then, at , the node t is set equal to Pred[t] (i.e., predecessor of node t). Next, at , add node t to the beginning of path list P. Then, at , if node t is the same as the source node S, then output the path list at , before completing the algorithm  at . Otherwise, resume execution at step . The output of the Backtrace algorithm  is an ordered list of edges, which represent the sequence of steps to be performed to accomplish the requested transformation.",{"@attributes":{"id":"p-0173","num":"0172"},"figref":["FIG. 17","FIG. 5"],"b":["420","92","92","76","422","102","96","424","426","104","106","102","96","96","428","430","432","434","436"]},"As shown in , there are two main purposes of the transformation module  during normal operation after the initialization phase of : (1) queue processing , which includes creating and queuing transformation orders as new transformation requests  are received; and (2) processing transformation orders .","Transformation orders  are created and entered (in response to a transformation order event (TOE) ) in the queue processing  as discussed above at steps  and  of . Each transformation order  has global (i.e., pertaining to the transformation order as a whole) and edge information associated with it. Global information is for the entire transformation order, which contains parameters such as, for example, transformation ID, source\/destination types, state, and the current Optimal Transformation Path (OTP). Some of the information is static (i.e., it does not change during the transformation process) and some is dynamic (e.g., state, Current Edge, failed edge-list). Also, for each edge in the current OTP, there is a separate record containing edge-based information. Again, some of the edge information are static and some other information are dynamic. Most of the data in the transformation order  is non-volatile (i.e., it is stored on the disk). When dynamic information changes, the information is written to the disk. The transformation orders may be deleted, at , after the request successfully completes. This is controlled by a parameter in the configuration file. Otherwise, the transformation order is deemed to have failed and the failure is handled at , or is requeued in the queue processing at . Volatile information only exists temporarily during the transformation process. Table 3 shows the exemplary transformation order parameters.",{"@attributes":{"id":"p-0176","num":"0175"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Transformation Order Parameters"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameter",{},{},{}]},{"entry":["Class","Parameter","Static or"]},{"entry":["Sub-class","Name","Dynamic","Comments"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Global",{},{},"Global parameters for the entire"]},{"entry":[{},{},{},"transformation order"]},{"entry":["(Non-",{},{},"Permanently stored on the disk"]},{"entry":"volatile"},{"entry":[{},"Transforma-","S","An identifier for the"]},{"entry":[{},"tion ID",{},"transformation order for"]},{"entry":[{},{},{},"referencing to this order"]},{"entry":[{},"Host Addr","S","Address of the requesting host"]},{"entry":[{},"Mail Addr","S","Mail address for notification of"]},{"entry":[{},{},{},"failure"]},{"entry":[{},"State","D","Current state:"]},{"entry":[{},{},{},"IDLE\/BUSY\/WAITING\/"]},{"entry":[{},{},{},"CONVSEND"]},{"entry":[{},"sMT","S","Source mime type (format type)"]},{"entry":[{},"dMT","S","Destination mime type"]},{"entry":[{},"Disposition","S","Disposition Type"]},{"entry":[{},"Disp","S","Disposition Argument: mail"]},{"entry":[{},"Argument",{},"address, device, file path for"]},{"entry":[{},{},{},"copying; the actual argument"]},{"entry":[{},{},{},"depends on the disposition type"]},{"entry":[{},"Encoding","S","Encoding type used for the file;"]},{"entry":[{},{},{},"the file may be sent encoded by"]},{"entry":[{},{},{},"the requester and may need to be"]},{"entry":[{},{},{},"decoded before transformation"]},{"entry":[{},{},{},"can begin"]},{"entry":[{},"Start Time","D","Last Time a conversion in a"]},{"entry":[{},{},{},"transformation order was"]},{"entry":[{},{},{},"initiated"]},{"entry":[{},"Return","D","Number of times failed"]},{"entry":[{},"Attempts",{},"attempting to return result"]},{"entry":[{},"Return File","D","The location and name of the"]},{"entry":[{},"Path",{},"result file; after the completion"]},{"entry":[{},{},{},"of the transformation the file is"]},{"entry":[{},{},{},"taken from here and disposed"]},{"entry":[{},{},{},"according to disposition type and"]},{"entry":[{},{},{},"argument given"]},{"entry":[{},"Trans Status","D","Pending\/Failed\/Success"]},{"entry":[{},"OTP","D","List of Edges in the Optimal"]},{"entry":[{},{},{},"Transformation path"]},{"entry":[{},"Current","D","Current Edge in OTP to be"]},{"entry":[{},"Edge",{},"executed"]},{"entry":[{},"Current","D","Current wrapper under"]},{"entry":[{},"Edgelet",{},"consideration"]},{"entry":[{},"Failed Edge","D","List of edges that have failed"]},{"entry":[{},"List",{},"during this transformation order;"]},{"entry":[{},{},{},"used to calculate OTP"]},{"entry":["(Volatile)",{},{},"Stored in the memory but lost"]},{"entry":[{},{},{},"after a system crash"]},{"entry":[{},"Time-Out","D","A link to the current timer used"]},{"entry":[{},"handle",{},"for time-out event"]},{"entry":["Edge",{},{},"Parameters for each edge in the"]},{"entry":[{},{},{},"Optimal Transformation Path"]},{"entry":["(Non-",{},{},"Permanently stored in disk"]},{"entry":"Volatile"},{"entry":[{},"Edge Id","S","Id of the edge in the OTP"]},{"entry":[{},"sMT","S","Source format type"]},{"entry":[{},"dMT","S","Destination format type"]},{"entry":[{},"Source file-","D","Size of the source file"]},{"entry":[{},"size"]},{"entry":[{},"Edge try","D","How many times the edge has"]},{"entry":[{},"counts",{},"been tried"]},{"entry":[{},"Last edgelet","D","Id of the last edgelet tried"]},{"entry":[{},"Id",{},"unsuccessfully"]},{"entry":[{},"Current","D","Id of the current edgelet under"]},{"entry":[{},"Edgelet",{},"consideration"]},{"entry":[{},"Remote ID","D","If the current edgelet is remote"]},{"entry":[{},{},{},"then the remote ETS sends a"]},{"entry":[{},{},{},"Transformation ID when a"]},{"entry":[{},{},{},"request is submitted; this is the"]},{"entry":[{},{},{},"Remote ID entry (NULL if it is"]},{"entry":[{},{},{},"local)"]},{"entry":[{},"Failed","D","List of failed edgelets for this"]},{"entry":[{},"Edgelet Ids",{},"edge"]},{"entry":[{},"Num","S","When a poll of the state of the"]},{"entry":[{},"Timeouts",{},"current edgelet returns"]},{"entry":[{},{},{},"PENDING then how many time-"]},{"entry":[{},{},{},"outs to allow before declaring"]},{"entry":[{},{},{},"that the edgelet has failed"]},{"entry":[{},"Result file","D","The result file if successful"]},{"entry":["(Volatile)",{},{},"Stored in memory only"]},{"entry":[{},"Statistics","D","Conversion time, network"]},{"entry":[{},{},{},"latency"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The parameters in the transformation order  are initialized as follows. First, set the static data: (Transformation ID, Host Address, Mail Address, sMT, dMT, Disposition, Disposition Argument, and Encoding). Then, set the dynamic data (State=IDLE; Start Time=actual start time; Return Attempts=0; Return File Path=NULL; Transformation Status=PENDING; OTP=list of edges in the current OTP; Current Edge=First edge in the OTP; Current Edgelet=NULL; Failed Edge list=NULL; and Time-out handle=link to a timer). Next, for each edge in the OTP, set the following static data for each edge record (set Edge Id from the OTP, sMT, dMT, Num Timeouts (from configuration file )). Next, for each edge in the OTP, set the following dynamic data for each edge record (for the first edge set the source file-size, for the rest it is zero; Edge try counts=0; Last Edgelet Id=NULL; Current Edgelet=NULL; Remote ID=NULL; Failed Edgelet lists=NULL; and Result file=NULL).","All transformation orders  are placed in a first-in-first-out (FIFO) queue  by the queue algorithm . During the actual processing of transformation orders , the elements of this FIFO queue might be re-arranged (as discussed below), but only to avoid extreme conditions. Hence, in most cases, orders  are processed in the sequence they were received.","The transformation module  is responsible for: (1) at , executing each of the conversions, for each of the transformation orders , in sequence, and transmitting the conversion request to the wrapper subsystem  of , in order to execute the conversion; and (2) at , receiving feedback from the wrapper subsystem  as to the success or failure of the specific conversion, and updating the transformation orders, in order that the next step in the sequence can take place. The operation of the transformation module  is intimately tied to the operation of the wrapper subsystem . Specifically, for reliability purposes, the transformation module  is aware of the resource requirements and conflicts involved in invoking the exemplary wrappers , and behaves accordingly. Also, at , the transformation module  suitably detects any failures in the wrappers , and initiates any necessary actions.","The queue processing  checks the FIFO queue  for any free transformation order , which can be scheduled for the next step in the conversion. This leads to the execution of an edgelet (for some of the transformation orders ) which, in turn, leads to a request to the wrapper controller  for executing the wrapper. When a wrapper finishes execution, the wrapper controller  informs the transformation order update  to update the state of a particular transformation order in preparation for the next step. At this point, the transformation order update  determines one of the following: (1) a transformation has completed successfully, in which case the order is removed from the FIFO queue  and the disposition module  is informed of the same; (2) the transformation order has failed, in which case the order is removed from the queue  and a failure is reported at ; or (3) the step has succeeded or failed and the order is re-queued  for further processing.","The key event, which triggers the processes of , is the transformation order event (TOE) . This event may be generated in one of two ways: (1) a new transformation request  arrives and is entered in the FIFO queue ; or (2) the transformation order update  system finishes execution (primarily because a wrapper has finished execution).","When a wrapper belongs to a remote ETS (not shown), the nature of the sequence of steps remains the same, except that the request  is communicated to the remote ETS through the communication module  of . The results are communicated back to the transformation module  using the IPC  of .","The queue processing  schedules the transformation orders  by checking the FIFO queue  whenever a TOE  is received. As mentioned above, in order for this process to be effective, the queue processing algorithm  takes into account the resource requirements and the edgelets' availability.","Each edgelet has certain resources it might require before it can be activated. The resources available to an ETS can also vary over time, either due to changes in its configuration file  () or due to the fact that other edgelets, currently active, have their own resource requirements. On the other hand, it is also necessary to ensure that a particular transformation request  will eventually run (i.e., to ensure that a resource intensive edgelet will eventually obtain the resources it needs and will never be permanently starved). A resource management (RM) module  (of the transformation module  of ) ensures this as follows. ETS resources consist of a text label and an associated quantity, which defines how much of the labeled resource is available. The administrator sets the quantity during configuration. These quantities are a factor in determining how many instances of an edgelet can run at any one time. On boot up, when the inventory of edgelets is being made, an edgelet is queried about the services it provides and the resources it requires to provide the services. The resources required by the edgelet are defined by the same labels used by the ETS node, along with a quantity indicating the amount used during invocation. These labels and quantities are administrator-defined. While they represent real system resources, they need not reflect the actual physical resources provided by the OS (e.g., the administrator may choose to limit the resources given to the ETS).","When an edgelet is invoked at , the necessary resources are removed from the ETS' resource pool. These resources are returned to the pool when the edgelet completes. If the resources are not available at invocation time, then the edgelet's invocation is deferred until later. If the ETS does not have adequate resources to ever run an edgelet, then that edgelet is not added to the inventory (and the corresponding edgelets are not added to the edges in the graph). Thus, every edgelet in the inventory is guaranteed to be able to run given the sum total of all resources available to the ETS.","In the exemplary embodiment, before an edgelet can be used, the corresponding wrapper meets two requirements: (1) it is IDLE; and (2) the resources it needs are available in the global pool. If the edgelet is idle and the resources are available, then the edgelet is activated and the resources it needs are removed from the global pool. Upon deactivation these resources are freed (but not necessarily returned to the global ETS pool, as discussed below). If the edgelet is not idle, then the transformation is re-queued.","On the other hand, if the edgelet is idle, but adequate resources are not available, then the transformation order  and the edgelet are locked and the former removed from the transformation FIFO queue . As each currently active edgelet is deactivated, its freed resources, instead of being returned to the global pool, are maintained in a reserved pool. Eventually, it is possible that all available resources are in the reserved pool. At this time, the locked edgelet is, by the above guarantee, able to run.","The final aspect to ensuring non-starvation is the handling of the transformation FIFO queue  as discussed below in connection with the Edgelet Pick algorithm  of . In summary, before any transformation orders from the FIFO queue  are considered, the locked transformation order and edgelet are considered, if they exist. Thus, the moment an edgelet is deactivated, its resources are returned (and added to the reserved pool). If the reserved pool is adequate for the locked edgelet, then it is activated.","The wrappers, which are invoked at , need resources from the limited global pool of resources. These resources need to be allocated properly to avoid any resource contention or starvation. Printers and other such devices, memory, and disk-space are the normal elements of the resource pool. Each application associated with the local wrappers is also considered a limited resource. Some can be invoked only once and others can be invoked several times. This number is obtained by querying the wrappers as discussed below.","There are three classes of resource pools defined by the ETS according to usage: (1) an Unused Pool (which can be used by any of the wrappers); (2) a Reserved Pool (which can be used only by reserved transformation orders); and (3) an In-Use Pool (which are locked by the executing wrapper).","The FIFO queue  can hold a suitable number of transformation orders, but there is a special reserved slot , which contains only one reserved transformation order (TO). A transformation order can be reserved when it becomes difficult to meet its resource requirements and needs special attention in order to avoid waiting indefinitely for resources to free up. This is where the Reserved Pool of resources plays a role. Whenever there is a reserved transformation order, the resources freed by wrappers on completion are put in the Reserved Pool, which can only be used by the reserved transformation order.",{"@attributes":{"id":"p-0192","num":"0191"},"figref":["FIG. 19","FIG. 20"],"b":["472","474","472","444","476","452","478","479","452","474","486","478","476","482","484","474","484","478"]},"The Edgelet Pick algorithm  of  works on non-reserved transformation orders. First, at , the Current Edge is obtained from the edge record of the Transformation Order, and the Current Edgelet is set equal to NULL. Then, at , the Best Edgelet is picked for the edge by employing the Best Edgelet algorithm  of . This selection is based on one of many types of cost calculations performed on the vector of attributes. By changing the way the cost is calculated, one can tune the order in which the edgelets are chosen. For example, for a relatively very high speed of service, one may choose only the faster third-party applications and\/or those applications which are local or nearer to the controlling server.","Next, at , if an edgelet is not found, then the Edge Failure algorithm  of  is invoked at . Otherwise, if the corresponding edgelet (wrapper plus application or device) is not local at , then the Transformation Order State is set to CONVSEND (Table 3) and the Remote Edgelet algorithm  is invoked at  as discussed below. Otherwise, if the corresponding edgelet is local, then it is determined at  if the corresponding wrapper is busy. If so, then the routine stops at . Otherwise, at , it is determined if the edgelet is reserved by some other transformation order. If so, then the routine stops at  for the current transformation order and the algorithm continues at  of . Otherwise, the resource requirements of the edgelet are determined at . Then, if the resources are available from Unused Pool at , the Local Edgelet algorithm  is invoked at  as discussed below. Otherwise, at , if there is another reserved transformation order in the slot  of , then the routine stops at . Otherwise, the transformation order is marked as reserved at  (and put in the reserved slot ) after which the routine stops at .",{"@attributes":{"id":"p-0195","num":"0194"},"figref":"FIG. 21","b":["493","493","520","522","524","526","527","522"]},"There are two kinds of failed edgelets: (1) those discovered during processing of the transformation order under consideration, which are stored in the failed edgelet list  of  (Table 3) of the transformation order; and (2) those found to be have failed too many times are considered useless, which are and kept in a separate list  in the graph module . Both the lists , are considered here.","Otherwise, if the edgelet is not in one of the failed edgelet lists, then the edgelet count is incremented and the weight, CW, is calculated at . The weight is determined as a function of static costs for the edge plus costs that are a function of the file being converted using that edge (e.g., some values may be a function of file-size). Once the resulting cost vector has been calculated, it is stored as a normalized value (e.g., the square root of the sum of the squares of the individual values). This is based on one of many types of cost calculations performed on the vector of attributes. By changing the way the cost is calculated, one can tune the order in which the edgelets are chosen. For example, for a relatively very high speed of service, one may choose only the faster third-party applications and\/or the applications which are local or nearer to the controlling server.","Next, at , it is determined if the calculated weight CW is less than W. If so, then W is set to CW and the Best Edgelet is set to edgelet e at . If not (or after ), at , if the edgelet count is greater than a Max Count (as defined by the configuration file  of ), then the Best Edgelet is output at  (which can be NULL). Otherwise, step  is repeated.","As discussed above, there are two edgelet invocation algorithms: local  and remote  of . For the Local Edgelet algorithm , the steps are as follows. If the edgelet is reserved, then allocate the resources from the Reserved Pool to the wrapper and put the resources in the InUse Pool. Otherwise, allocate the resources from the Unused Pool to the wrapper and put the resources in the InUse Pool. Next, the wrapper is invoked. Invocation of the wrapper is discussed below. Essentially, invocation involves providing suitable information to the wrapper such that it can provide suitable feedback for the transformation order update  of . Finally, a local timer is started and the local invocation is completed.","The Remote Edgelet algorithm  steps are as follows. First, a Transformation request is created with sMT (source format type) and dMT (destination format type) (Table 3) of the Edge under consideration. The Disposition type is set to a configurable option (e.g., RETURN, WAIT), the file-size is set, and the IPC command and argument are set. This is similar to local wrapper invocation, except that this information is not sent to the remote ETS. The transformation module  of  keeps a lookup table of transformation requests sent to a remote ETS. When a query is made by the local ETS or a request is sent by the remote ETS, the IPC commands are used to communicate it to the transformation module . Next, the Transformation request is sent to the remote ETS. Then, the remote timer is started and the remote invocation is completed. Again, at this point, the feedback messages are sent to the transformation order update  of , which suitably acts and interprets the messages.","As shown in , updating the transformation order is dependent on the events that happen after the invocation of the wrapper. The generation of these events is tied to the wrapper subsystem  of  and the wrapper failure model (as discussed below) that is employed. One of five events, U\u2013U, of interest to the transformation order update  of , can occur as shown at . One of these events ,,,, is detected at . For the first event U , a local wrapper's invocation fails immediately, or, in the case of remote wrappers, a negative acknowledgement (NACK) is received as a result of a transformation request. For the second event U , a local wrapper's invocation is successful, or for remote wrappers, a positive acknowledgement (ACK) is received from the remote ETS. The third event U  occurs, if the results are returned by the remote ETS for remote wrappers, or if the local conversion completes successfully for local wrappers. The fourth event U  occurs if a local conversion is unsuccessful, or if a message is sent back by the remote ETS with a failure notice. The fifth event U  occurs if the IPC  of  fails and, thus, cannot communicate back to the transformation module . The last event  is a significant failure of the system and the administrator is first notified, various data are cleaned up, and the ETS is shutdown.","The overall process used by the transformation order update  is shown in . If the event type is U , then the U algorithm  is applied before exiting at . Otherwise, one of the appropriate algorithms ,,, is applied to the corresponding event ,,,, respectively. Finally, after the U\u2013U algorithms ,,,, a TOE  is generated at .",{"@attributes":{"id":"p-0203","num":"0202"},"figref":["FIG. 22B","FIG. 22A","FIG. 5","FIG. 5","FIG. 18"],"b":["558","1","544","570","572","574","576","578","580","570","582","110","529","584","586","586","528","450","588"]},"For the algorithm  for the event U  of , the transformation order state is set to BUSY.",{"@attributes":{"id":"p-0205","num":"0204"},"figref":["FIG. 22C","FIG. 22A","FIG. 18","FIG. 18"],"b":["562","3","548","590","592","594","596","598","600","602","592","604","606","608","446","94","610","612","604","614","616","618","450","620"]},"As shown in , in the case of the event U , the state of the transformation order is set to IDLE at , and the U algorithm  is performed as discussed above in connection with .","In the case of the event U  of , the algorithm  notifies the administrator, the ETS instance is cleaned up, all data is written to the disk, and the ETS instance is shut down.","During execution of the Edgelet Pick algorithm  of , it is possible that no proper wrappers are found for an Edge. In this case, the Edge Failure algorithm  of  is invoked at . The Edge Failure algorithm  is part of the transformation order update  of . First, at , a local or remote repoll is performed for new wrappers. If a repoll of remote ETSs is not allowed, then only local wrappers would be discovered. Next, at , if new wrappers are found (or if any old wrappers are missing), then the Graph Merge algorithm  of  is executed at . Then, at , it is determined if at least one new edgelet got added to the Edge under consideration. If so, then the transformation order is re-queued ( of ) at  and then a TOE  is generated at . Otherwise, if no edgelet was added to the Edge, then the Edge is added to the forbidden edge list, FE, associated with the graph module  of  at . This step is also executed if no new edgelet was added to the Edge under consideration at . Next, the old transformation order is removed from the queue  at  and the OTP is recalculated at . Then, at , if the OTP does not exist, then the Transformation Status is set to FAILED at , and a failure is reported and cleaned up at , before a TOE  is generated at . Otherwise, if an OTP exists at , then the old transformation order is modified with the new OTP at  and is re-queued ( of ) in the transformation order queue at . Finally, a TOE  is generated at .","If an edge fails (i.e., there are no edgelets left on that edge because they have all failed), then a configuration parameter of the configuration file  of  (Table 1) controls the subsequent behavior. If the configuration parameter is set to repoll, then all the known ETS instances are re-interrogated to see if additional ETS instances have come alive or if known ETSs have new (i.e., previously unknown) edgelets. If so, the transformation path is recalculated and the transformation proceeds. If not, then the transformation fails.","Edgelets are preferably weighted by using dynamic vectors. A dynamic vector consists of a set of costs, which are updated in response to messages from other ETS instances. A dynamic vector can consist of static, dynamic and functional costs. A static cost is a cost that is not changed by the ETS itself\u2014these costs are determined by querying the wrapper at startup. Dynamic costs may be initialized at startup, but then change as the ETS accumulates information during its operation. For example, a heavily used edgelet may have its cost increased in order to reflect scalability concerns. An unreliable wrapper may see its cost increase to discourage the ETS from using that wrapper. Functional costs are costs that are a function of the converter and the file being converted. An example of a functional cost would be a cost per megabyte for converting a file. The cost profile is determined within the configuration file , from each wrapper and by events triggering cost updates.","Costs are stored as vectors or ordered lists of costs where the position determines the costs' meaning. For example, an edgelet's cost may be a vector of reliability cost, initial invocation cost and network distance cost. When an edgelet's cost is evaluated, it is given a specific file. The cost vector for that specific file\/edgelet interaction is determined. This vector is then normalized to determine the aggregate cost of the operation.","An exemplary list of cost vector items include: (1) edgelet failure count (EFC): EFC can take both negative and positive values (if negative, its effect is to reduce overall cost); (2) Local or Remote (R): R=0 for a local edgelet and R=1 for remote edgelet; (3) quality of conversion (Q): this value can be set by the administrator or can be dynamically updated using an external agent; and (4) File-size (FS): obtained from the file to be converted (this is not necessarily the same as the original file since the intermediate files may be of different sizes).","An exemplary calculation of a Cost vector is shown in Equation 1:\n\nCost=()+()+()+(COST_PER_KB)+(\u00d7COST_PER_INVOCATION)\u2003\u2003(Eq. 1)\n\nwherein:\n","W, W, W, Wand Ware weights for EFC, R, Q, FS and Invocation, respectively. These weights may be pre-set in the configuration file  by the administrator to assign a relative importance to each of the cost components.","COST_PER_KB is cost per each kilobyte of data to be converted.","COST_PER_INVOCATION is the cost of using the wrapper (and its associated application). Both these latter two quantities are obtained through a wrapper query.","Such exemplary cost calculations can also be extended to the edge cost calculations in addition to edgelet cost calculations. This cost information can then be used in the OTP determination algorithm  of  in order to further optimize the path selection process. In this manner, one can force the path selection process to pick a path, which is not necessarily the shortest in terms of number of steps, but which is perhaps lower in terms of overall monetary cost.","The wrapper controller module  of  is responsible for: (1) interpreting and forwarding requests (of exemplary wrappers , for information or for invocation) from the transformation module ; (2) interpreting feedback from the wrappers , (after they have completed the task given) through the IPC ; and (3) sending the feedback information to the transformation module .","The exemplary communications between the wrapper , and the ETS  are asymmetrical. Communications from the ETS to a wrapper are via spawning (if the wrapper is external to the ETS), a remote transformation request initiation, or a function call (if the wrapper is a built-in). On the other hand, all communications from the wrapper , to the ETS  are accomplished via the mechanisms of the IPC . The precise details of the IPC mechanisms to be used are dependent on the particular operating system and the configuration selected. An exemplary generic method is to pass three arguments to each wrapper during invocation (in addition to the arguments employed to perform the conversion): the IPC which performs the messaging (to the ETS ) on behalf of the wrapper ,, and two arguments for that IPC. The two latter arguments provide the information to the IPC  needed to perform its task. The first identifies, for example, the appropriate port (for TCP\/IP based IPC), pipe-name (for named-pipe based IPC), and directory (file-based IPC) to be used to send the message. The second argument is the path to the file to be used to record the message in the event of a failure. This can happen if the ETS  shuts down between sending a conversion request to the wrapper , and the wrapper completing the corresponding conversion. In this case, the IPC  appends the message to the given message file, which is read when the ETS  boots up the next time.","Given the central role of IPC in an ETS, it is important to be able to ascertain whether the IPC  is functioning correctly. To this end, each IPC mechanism defines a self-test mechanism which can be invoked by the ETS  and which returns a definitive answer as to whether the IPC mechanism is functioning. This self-test mechanism (or IPC ping) is employed whenever a transformation request, which has been successfully sent, times-out. At this point, the ETS  has two hypotheses about the wrapper , corresponding to the edgelet: (1) that it is still working; or (2) that it has finished, but is unable to communicate with the ETS  because of an IPC failure. The self-test feature enables the ETS  to establish which of these two hypotheses is correct.","If the first hypothesis is correct, then a STATUS request to the IPC command will result in an IPC message (pending, completed successfully or completed unsuccessfully). On the other hand, a non-response suggests that the second hypothesis might be correct. Since the IPC  is central to the functioning of an ETS, the self-test confirms this hypothesis. A self-test failure results in the immediate shutdown of the ETS . The IPC self-test is used in the edgelet\/wrapper invocation algorithms , of .","As discussed above, wrappers serve as an interface between the ETS instance and applications. Wrappers are employed to \u201ccoerce\u201d applications to provide conversion services that they were not necessarily designed to provide. Wrappers can range from simple software \u201cscripts\u201d to \u201chuman-in-the-loop\u201d wrappers. Simple scripts instruct the application to open the document, convert it, save the conversion and quit. At the other extreme, a specific conversion might require a human agent to launch the application, open the document within the application, interactively perform the conversion and save the resulting new document.","The wrappers are designed to be queried for static information about their capabilities, cost information and resource requirements, and dynamic information about the state and status of conversions. When queried, a wrapper returns the following exemplary static information: (1) Conversion type: Source type and Destination type; (2) Application name: the name of the application it employs (e.g., MS Word, Ghostscript); (3) Resources: a list of parameter name=value pairs (e.g., PRINTER=1, MEMORY=20 Mb, and NUM_INVOCATION=3, which states that the application can have a maximum of three concurrent invocations); and (4) Costs: a list of parameter name=value pairs (e.g., COST_PER_KBYTE=1, and COST_PER_INVOCATION=2). The wrapper, when queried, also returns the following exemplary dynamic information: Conversion Status: COMPLETED\/FAILED\/PENDING for each conversion request.","There are three types of wrappers known to the ETS : (1) built-in: these are internal to the ETS; (2) script: these are the most common local wrappers for complex applications and are external to the ETS; and (3) remote: wrappers belonging to other ETS instances. The first two types are referred to as local wrappers since they are directly accessible to the ETS.","An example of wrapper invocation is as follows. If the wrapper is local, a command line is constructed to contain: (1) ipcMessageSender: Name of the IPC command; (2) ipcPort: Port number for IPC communication; (3) ipcMessageFile: Message file for IPC; (4) TOID: Id of the transformation order; (5) EdgeletID: Id of the edgelet; (6) SrcPath: location of the source file; (7) DestPath: location of the destination file; (8) SrcType: source format type; and (9) DestType: Destination format type. A system call to execute the wrapper with this command is issued. If this fails, then the edgelet is immediately marked as failed and removed. If the local wrapper is built-in, then the wrapper is invoked as a function call, with exactly the same parameters as above, and an error return is treated again exactly as above. If the edgelet is remote, then a transformation request is sent to the remote ETS.","Internally, the wrapper maintains two types of information. The first type is the number of times that the application associated with the wrapper is active. Each time a wrapper is successfully invoked it increases this number by one. Similarly, this number is decremented when the application completes the conversion either successfully or unsuccessfully. The number of times an application can be invoked is limited by a parameter obtained by querying the wrapper (NUM_INVOCATION). Usually, this number is one for most applications, but for some applications this number can be greater than one. Second, for each conversion request, the wrapper maintains a table of invocations. For each invocation entry, the wrapper keeps all the information that is passed to it (e.g., src type, dest type, transformation ID, IPC, conversion status). When a query is made as to the status of the conversion, the wrapper compares the transformation ID passed in the query to one in the table and reports accordingly. The conversion status can be COMPLETED, FAILED or PENDING. Alternatively, this functionality can also be built into the ETS instead of the wrapper. In this case, the ETS maintains this information for all local wrappers (or edgelets).","When either a local or remote wrapper is invoked ( or , respectively, of ), a non-failure results in both the transformation order and the edgelet being placed in the BUSY state. If the edgelet is remote, on invocation, the transformation order is put into a CONVSEND state. The transition from this state occurs when the edgelet sends an IPC message indicating a successful request transmission or its failure. The result is the same as above\u2014a success results in transition to the BUSY state, and a failure results in the edgelet being removed immediately and the transformation order remains in the IDLE state. In all three cases, the transformation module  of  starts a timer. The timer duration depends on whether this is a remote or a local edgelet. This duration is also modified as the ETS  learns more about the specific edgelet.","When a conversion is completed, all three types of edgelets (built-in, script, and remote) return a message to the transformation module  via the IPC  indicating the status of the conversion. Then, the transformation order is transitioned to the IDLE state, its internal step count is moved to the next edge, and appropriate statistics are recorded. Similarly, the edgelet is transitioned to the IDLE state and its statistics are updated. On a failure, the transformation order is transitioned to the IDLE state and the failed edgelet list  of  is updated to include this failed edgelet. The edgelet is similarly transitioned to the idle state and its statistics are updated to reflect the failure.","On the other hand, if the timer expires before an IPC message is received by the wrapper controller  of , then the transformation module  issues a STATUS request to the wrapper through the wrapper controller . A failure to receive a response to the STATUS request leads to a check if the IPC  is at fault. If it is functioning correctly, then the edgelet is deemed to have failed and is removed from the system (i.e., this is treated like an initial invocation failure). If, however, the STATUS response indicates that the conversion is still PENDING, another timer is set and the transformer waits. This process of setting timers, checking status and repeating on a PENDING response is terminated by checking if the number of timeouts exceeds a configuration constant (i.e., a number, Max Time-outs, that is established in the configuration file ).","Finally, the length of the timer is adjusted depending on the statistics collected over time. For example, as experience is gained, edgelets known to be slow have their timeouts lengthened. The reverse is not the case (i.e., fast edgelets do not have their timeouts reduced). As another example, the timeouts can be adjusted to allow for parameters specific to the transformation request such as the source mime type (i.e., certain input formats may be harder to convert, and, thus, take longer), size of file, or source-target format type interactions.","In general, prior known transformations were either monolithic (meaning that only one type of atomic conversion was being performed), or knowledgeable (meaning that the material within the converted file could be examined by the system). The exemplary ETS  manages a diverse set of file formats in the absence of a common scheme for identifying good or bad conversions. In addition, the interaction between diverse transformation applications and files can result in a successful conversion with one application, even though the conversion failed with another application.","Faults can occur at several points along the transformation process. In particular, the exemplary ETMS system  of  distinguishes between the failure of the application, the wrapper, the document, the document-application combination and the ETS instance. In addition, the ETS  distinguishes a component failure from failures in the communication method used between the components. This is achieved using a \u201cblack box\u201d conversion model. This approach incorporates operating system diagnostics with a qualified failure model which allows making reasonable guesses that a problem is unique to a file, unique to a converter, or unique to an interaction between the file and the converter. If the wrapper invocation fails, then this is a significant failure and the wrapper is taken offline and an operator is notified. If the application fails, then the wrapper informs the ETS instance of the failure along with any associated information it might be able to extract from the application. The ETS  uses this information with a leaky bucket fault counter for the conversion. If the application fails too often, then it is taken offline and an operator is notified. Finally, the ETS  determines if the communication channel between the wrapper and the ETS instance has failed. Since this is a generic failure (i.e., all wrappers will experience this failure), an operator is notified and the ETS  is shutdown.",{"@attributes":{"id":"p-0233","num":"0232"},"figref":"FIG. 24","b":["660","1","4","1","662","2","664","3","666","4","668"]},"TO  through TO  are referred to as Termination Options.  also shows the events U , U , U , U  and U  of . First, at , the wrapper is invoked. If invocation leads to immediate failure at  (event U ), then terminate with TO . Otherwise, a successful invocation (event U ) is followed by waiting for a response at . If a response is received at  and if the conversion completes successfully at  (event U ), then terminate with TO . Otherwise, if the conversion fails at  (event U ), then terminate with TO . On the other hand, if no response is received at  and if a time-out occurs during the conversion at , then it is determined if too many time-outs occurred (given by max wrapper time-outs in the configuration file) at . If max time-outs have occurred at  (event U ), then terminate with TO . Otherwise, the wrapper is queried about the status of the conversion at . If the status check does not return at , then check the IPC mechanism  of  using its self-test feature at . If the IPC self-test succeeds at  (event U ), then terminate with TO . Otherwise, if the IPC self-test fails at  (event U ), then terminate with TO . Otherwise, when a status check returns at  and the status is not pending at , then it is determined if there was a conversion complete (success) at  (event U ). If so, then terminate with TO . Otherwise, when a status check returns with a conversion failed at  (event U ), then terminate with TO . Otherwise, when a status check returns with a conversion pending at , return and wait for another timeout at .","In order to gracefully return to its current state when an ETS is shut down or when it crashes, suitable information about a transformation request is kept both in RAM and on disk. On startup, the crash recovery module  of  is responsible for returning to a known state. It does so by reading the disk-based store of transformation orders and processes each of them. The Current Edge and Current Edgelet fields of the transformation order provide the necessary information about the stage in the OTP of the transformation order.","The crash recovery mechanism  of  employs some of the algorithms in transformation order update . First, at , the transformation orders file is read and the next transformation order is picked at . Then, if no orders are left at , a TOE  is generated at . Otherwise, if the transformation order state is IDLE at , then that transformation order is re-queued at  and step  is repeated. Otherwise, if the transformation order state is BUSY at , then the conversion status of the wrapper is checked at . If the conversion status is available at , then the status is obtained. Otherwise, the transformation order State is set to IDLE at , the transformation order is re-queued at , and step  is repeated. Otherwise, after , if the conversion status is PENDING at , then the timer is started at , and step  is repeated. Otherwise, if the conversion status is COMPLETED at , then algorithm U  of  is applied at  after which step  is repeated. Otherwise, if the conversion status is FAILED at , then the algorithm U  of  is applied at , after which step  is repeated. Otherwise, step  is repeated.","The State Information Tracking module  of  manages various housekeeping variables that are relevant to a specific transformation request, and ensures that these variables are synchronized between primary storage (e.g., the working memory of the ETS ) and secondary storage (e.g., disk files). While the former function is merely one of convenience, the latter is critical when recovering from system shutdown\u2014either due to an orderly shutdown or to catastrophic failures (i.e., system crashes). Both features are achieved in this module  by ensuring that any writes (i.e., changes) to a variable are immediately reflected both in system working memory (RAM) and in the disk file.","The information which is permanently stored by the ETS  includes: (1) the configuration file : this may be updated as and when necessary by the administrator; (2) Authorized host list file: a list of all the authorized hosts which are allowed to access this ETS; (3) Peer list file, which contains all the hosts that this ETS is allowed to access; (4) Transformation orders file: this disk file of transformation orders is updated every time any of the transformation order records change (disposed transformation orders are removed from this file and are logged in the logging subsystem) (not shown)); (5) Intermediate results files: employed for incomplete transformation orders; and (6) edgelet performance statistics.","Information which is kept only during the operation of the ETS instance includes: (1) the failed edgelet lists , of ; (2) the failed Edge list; (3) the Adjacency and the Reachability Matrices; (4) remote transformation orders table: a lookup table of transformation requests sent by the ETS  to any remote ETSs; and (5) the transformation graph: a list of edges and their associated edgelets. The statistics on the edgelets are also kept both in RAM and on disk. This can be reloaded on boot-up.","Discovery of peer ETSs is accomplished through several mechanisms. First, the configuration file  lists the known servers (and their authentication keys and mechanisms). Second, a single known server (via the configuration file ) can be queried for all the other servers known by it. In this case, the initiator can request that the remote server send its list of known ETSs. Thus, the single known server can lead to the discovery of the potentially full set. This, however, can be restricted (and hence the approach can fail) if an ETS is configured to not propagate such information. Third, by employing Peer-to-Peer Updating, ETSs can be authorized to send out (and receive) information about themselves and other known peers using IP multicast methods.","When an ETS instance starts up, it queries known ETS instances (however discovered) for their transformation graphs. The request can be for only local converters (i.e., edgelets that are under the direct control of the responding ETS) or global (i.e., all conversions known to the ETS). However, a global response is not mandatory (i.e., the responding ETS may be configured to only respond with local edgelets). The requesting ETS cannot infer whether a given edgelet is local or remote\u2014the responding ETS simply guarantees that it is able to perform the corresponding conversion.","When an ETS fails (or shuts down), peer ETS instances can discover this fact directly if a multi-cast message is sent or indirectly via a non-response to a subsequent request. In either case, the receiving ETS reacts by pruning its graph of all edgelets provided by the sending ETS and, if the resulting graph has edges with no edgelets left, pruning the graph of such edges. An ETS may retain a list of failed peers that may be re-queried on need. That is, if a pruned graph results in the potential removal of an edgelet, these peers may be re-queried in the event that they were restarted between the time of failure and the present time. In all these cases, the Adjacency and Reachability Matrices are recomputed when an edge is removed (or added).","Finally, the list of known peers can be changed for any ETS by editing the configuration file  and sending a \u201creconfigure\u201d message to the ETS . The details of the mechanism for sending such a message are dependent on the operating system and can range from sending a signal (on Unix type systems) to directly logging on the ETS's console and issuing a re-configure command.","In order to propagate information between ETS instances, several methods may be employed. The multicast method employs facilities in the TCP\/IP protocol that enable interested and registered entities to collectively share information by transmitting only one packet instead of N\u22121 packets (where there are N interested and registered entities). The use of this facility employs support from the underlying operating system and the acquisition of a registered multicast address from an appropriate authority such as the Internet Assigned Numbers Authority (IANA) as the ETS multi-cast address. Each ETS desiring to send a message to other (not specifically known) peers, sends a UDP message in a specified format to this multi-cast address. Each ETS desirous of receiving such messages registers such a desire using standard TCP\/IP mechanisms. Upon receipt of such a message, each ETS re-multicasts such a message if necessary. This is determined by a counter in the UDP packet (called time-to-live) which is a small integer (selected by the sending ETS) and which is decremented each time the message is propagated (e.g., when the counter reaches 0, it is no longer propagated). Since multi-cast UDP is not inherently safe (i.e., the message is not guaranteed to be delivered), these messages are simply advisory. The UDP multicast messages contain information that the sender considers valuable.","An alternative mechanism that does not rely on specialized facilities is to propagate the update information by passing a message to a limited number of \u201cnearest\u201d neighbors who, in turn, propagate the information to their nearest neighbors and so on. In order to bring closure to this process, a time-to-live (TTL) counter is employed, which counter is incremented on each transmission. Thus, the initial transmission might set the TTL counter to 5, the next transmission to 4, and so on. However, an ETS instance may choose not to propagate it any further and terminate it unilaterally. Otherwise, the ETS instances receiving a message with a TTL of 0 do not re-transmit and the process comes to closure.","Wrappers can be added or deleted independent of the operation of the ETS instance. Detection of wrapper addition\/deletion can happen in the following ways: (1) shutdown and restart: the usual boot sequence takes care of the problem smoothly; (2) by sending a special message to the running ETS to re-initialize itself: the method of sending the message depends on the facilities provided by the underlying mechanism (Signals are used when they are available since they are easy to use in a secure manner. When they are not, authorized administrators can connect to the running ETS and explicitly issue a reinitialize command. This is, in general, more complicated and less secure than the first method.); (3) after an Edge Failure by repolling the local wrappers directory; (4) repolling the wrappers directory periodically after a fixed time interval; (5) a multicast message is sent by the peers; (6) a wrapper fails catastrophically during execution; and (7) stale cache: every time a remote ETS communicates it sends a timestamp of its last boot; if this timestamp does not match the number in the table of the local Peer Host list, then the ETS repolls the remote ETS.","Quality of Service is provided by various mechanisms. First, each converter possesses a vector of attributes. The elements of this vector can be static (i.e., they are not changed during the operation of the ETS) or dynamic (i.e., they are changed as the knowledge of the converter increases over time). Attributes can include, for example, direct cost (i.e., the amount billed for using the converter), the quality of the conversion, and the time needed for the conversion. These attributes are changed either due to data collected by the instance \u201cautomatically\u201d or through user interaction. For example, the quality of the converter may be a \u201cfigure of merit\u201d obtained from the evaluation of previous users of this converter.","Second, redundancy plays a role in optimal choice of converters and transformations. Diverse conversion applications have divergent behaviors when transforming files. In particular, a single transformation from type A to type B may be successfully executed by one application and fail outright when handled by another application. In addition, random factors during execution can cause a conversion to fail. Reliability is enhanced by allowing both redundant and diverse converters and ETS instances to exist at any time. In this fashion, a conversion can be repeated with one or more different converters in case of failure. Otherwise, if no converters remain, then the edge is removed from the transformation graph and a new transformation path is determined. If no such path exists, then the request cannot be satisfied (and a failure message is returned to the original requester).","Third, in addition to exploiting redundancy, the process of picking alternate converters can be used to provide a scalable service. The number of services available does not affect the transformation graph, only the pick process. Scalable services can be provided by intelligently picking a choice for a conversion service. If a service is being heavily used, then redundant services can be brought on line in order that transformations can be distributed to these alternative instances.","An important characteristic of the exemplary ETS  is its ability to transform data from a set of input devices in their \u201cnative\u201d formats to other formats. The ETS  uses suitable combinations of one or more of original software applications, appropriate translators, or discovered optimal sequences of translators that are best suited to this transformation from source format to target format. The primary objective of providing such a service is efficient viewing, archiving, and classifying of information generated for consumption in a heterogeneous network of producers and consumers of information.","As office automation becomes more commonplace, the need for general-purpose acquisition, transformation and disposition services becomes more apparent. In particular, transformation services may be employed by all the following applications: personal document transformation, Product Data Management (PDM) systems, enterprise document management, workflow systems, e-mail, calendar software, supply-chain management, and automated voice transcriptions and delivery. Each form of software may employ a different delivery mechanism. For example, a PDM system or Document Management System (DMS) may want converted files copied to a specific location on a networked drive, while e-mail systems should receive results as e-mail packages.","As an infrastructure service, the exemplary ETS  has the capacity to interact with a variety of file transfer systems. The ETS treats file transfer as a necessary part of the service, and does not explicitly distinguish between an ETS instance and other clients for the purpose of file return. The results of a transformation requested by an ETS instance (or a transformation requested by a client (e.g., a user, another application)) may be returned via a wide variety of methods (e.g., e-mail, surface mail, network copy, local copy, held for future retrieval).","Engineering applications, just as in the case of office applications, have been one of an evolution of different types of applications, formats and versions over the last 20 years. Different versions of these applications have proliferated across different departments and organizations over time. Even when standards such IGES (International Graphic Exchange Standard) were used there were variations of interpretations of the standards. The problem of varied formats and versions led to the problem of inter-operability of the different applications as integrated suites of tools. The National Institute for Standards and Technology (NIST)\u2014sponsored PDES\/STEP (Product Data Exchange Standard\/Standard Transfer Exchange Protocol) effort addresses this part of the interoperability problem. However, even with these standards interoperability is a vexing problem. Based on an NIST sponsored study by Research Technology Institute (RTI), the auto industry incurs about $1 billion in transformation costs and its efforts to achieve inter-operability every year in its supply chain. The costs of mitigation of translations are about $100 million, while the second order costs in terms of rework and redesign are the rest of those costs. Most of the mitigation costs are in the area of creating and using point-to-point translators manually and tuning these translators. This does not include costs of translation of office applications as there are no special efforts expended in this area, which are generally left to the individual user. Thus, the effect of the improper transformation problem in the engineering industry is very large. The exemplary ETS  provides the ability to manage current and future transformations by using the original applications themselves or by using existing translators and their variants to create the desired target formats for viewing, archiving and classifying engineering product information.","The medical domain also has a network of consumers and producers of information. However, the producers and consumers of information, even for a given patient, change over time, and are across several institutional and geographic boundaries. The medical domain provides an interesting set of challenges for the ETS  in that it requires the linkage of a number of testing and diagnostic devices such as electrocardiograph, MRI, ultrasound and x-rays. Those devices generate data and produce outputs for consumption locally. However, these pieces of information are not easily available to others outside the medical organization without either making a copy or else requesting a copy from other medical entities. In addition, there are differences in the formats and other information that are used in the exchange of information among hospitals, laboratories, doctors' offices and payers (generally insurance companies). Further, the issue of transmitting data using a secure mechanism (e.g., communication channels and encryption) makes the availability of all of the information about a patient to the consumer of the information (generally the care provider) even more complicated. Thus, the transformation and transmission of appropriate information needs to be streamlined in order to be readable through a number of delivery devices (e.g., telephones, computers, handheld devices). The exemplary ETS  as a transformation server can be interposed as a service between such devices and the consumers and producers of patient information. Medical information is different from engineering information as all information generated on the patient is part of the entire history of the patient, and the data, once created, does not change. Hence, any information on a patient once transformed to human readable form can be stored for future use indefinitely. This problem can be solved with the ETS  through easy task delivery from a repository that stores the transformed information. Again, the ETS  provides an infrastructure solution to medical transformation service which is critical to the distribution of patient information produced across many institutional and geographical boundaries to the appropriate information consumers.","Because of the ad hoc introduction of computers and manual archiving processes of digital documents, there is the potential loss of very large amounts of valuable information. This problem is even more acute considering the number of versions and models of machines and their software and other compatibility issues. The exemplary ETS  provides an infrastructure management solution where different policies of archiving along with standardized formats of storage for different classes of documents are provided as an integral part of the work process. As documents are generated, their archival mechanisms can be triggered through the ETS to insert the document in a suitable repository for immediate and indefinite availability.","Other such ETS transformation servers may be suitably customized by a particular industry to reflect the tools employed in that industry.","The same argument for the need for transformation services can be used for document\/information delivery through multiple and different modes such as e-mail, web based delivery and wireless devices. In the case of specific domains, such as legal, bio-informatics and government domains, as was described for the engineering and medical domains, the exemplary ETS  can be suitably employed.","Spoken language translations have become an important aspect of communication because of increased globalization of Information Technology. A popular free language translator is Babelfish which can translate between a number of European languages. One can incorporate such language translators in the exemplary ETSs to convert, for example, English text to French text. This can be useful in e-mail systems which go across language borders.","Computer languages, such as, for example, Java, C, and Fortran, are also as varied as the spoken languages. Often, there is a need for translating computer software written in one language to another language to maintain compatibility. One of the simplest and often used translations is to convert a software program written in, for example, C language to the machine language (or binary code) for a specific hardware\/OS platform (e.g., Linux running on an Intel x86 platform). Whenever, there is a need to manage the language translation process, the exemplary ETS can be employed to automate it.","In one embodiment of the invention, a transformation request includes a file of voice data and a unique identifier, which identifies the person, application or device which originated the voice data. Upon receipt of this transformation request, including the voice data file and the unique identifier, a selected converter at one of the ETSs obtains a voice profile from a suitable data repository (e.g., disk) and employs the voice profile and a suitable voice-to-text application to convert the voice data file to text data. The voice profile may also include disposition instructions for the original voice data file and the resulting text data file.","A voice-to-text application, such as IBM's ViaVoice, first needs to be \u201ctrained\u201d to properly recognize a person's voice. The voice profile is an application specific representation of the typical characteristics of a particular voice. This voice profile can then be stored in some suitable data repository. So, in addition to the voice data, such a converter needs to know the voice profile of the person, application or device. The exemplary ETS employs the unique identifier to extract the correct voice profile from the repository and hand it over to the wrapper along with the voice file for conversion to text. Upon completion of the conversion to text, the ETS disposes of the result in the specified manner. Default methods of disposition of the resultant text and the original voice files can also be stored in the repository along with the voice profile data. It is likely that the format of the voice file needed by the converter may not be the same as the source of the voice data. In this case, the transformation process may need suitable conversion steps for voice format translations before conversion to text.","The voice data is often generated by a person, but in certain cases voice data may be generated (synthesized) by a device or a software application. Such devices or applications are becoming more common where voice based interfaces are becoming more common. In such a case, the unique identifier identifies the voice profile of the device or application instead of a person.","In another embodiment of the invention, one of the data formats may be a facsimile message having a predefined format, such as a laboratory medical report with a plurality of entry fields. A transformation request includes the facsimile message, a unique identifier to identify the format of the report, and a type field to define an output report having a plurality of fields. Upon receipt of this transformation request, including the facsimile message, the unique identifier and the type field, a selected converter at one of the ETSs extracts data from the entry fields of the laboratory medical report and populates the data in the fields of the output report.","Although exemplary transformations provided by the ETSs are disclosed, a wide range of transformations may be performed. For example, there may be many different combinations of wrappers. If only one edge is needed for the transformation, then the edgelet may either be remote or local with respect to the ETS. If two edges are needed for the transformation, then there are four different possibilities: (1) both edgelets are local; (2) the first edgelet is local and the second edgelet is remote; (3) the first edgelet is remote and the second edgelet is local; and (4) both edgelets are remote with respect to the ETS. Here, remote means that the edgelet is on a different ETS, which may be physically right next to the first ETS.","While for clarity of disclosure reference has been made herein to the exemplary printer  for displaying or outputting information, it will be appreciated that such information may be stored, computer modified, or combined with other data. All such processing shall be deemed to fall within the terms \u201cdisplay\u201d or \u201cdisplaying\u201d as employed herein.","It will be appreciated that while reference has been made to the exemplary host machine , a wide range of other processors such as, for example, mainframe computers, mini-computers, workstations, personal computers (PCs), microcomputers, Personal Digital Assistants, and other single or multiple microprocessor-based computers may be employed.","Devices which have embedded micro-controllers such as, for example, printers and facsimile machines, and devices with embedded operating systems such as, for example, gaming-machines and MP3 music players, can also have scaled-down versions of the ETS. In this fashion, these devices can become part of the ETMS' peer network and perform suitable conversions. Thus, a transformation request may be sent directly to a printer, facsimile machine, gaming-machine, MP3 player or other device employing the ETS.","It will also be appreciated that while reference has been made to the exemplary communication network , a wide range of communication mechanisms between clients and ETSs may be employed such as, for example, a local area network (LAN), a wide area network (WAN), intranet, extranet, global communication network, wireless communication system or network, and the Internet.","While specific embodiments of the invention have been described in detail, it will be appreciated by those skilled in the art that various modifications and alternatives to those details could be developed in light of the overall teachings of the disclosure. Accordingly, the particular arrangements disclosed are meant to be illustrative only and not limiting as to the scope of the invention which is to be given the full breadth of the appended claims and any and all equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A full understanding of the invention can be gained from the following description of the preferred embodiments when read in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 9A\u20139E"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 10B","FIG. 10A"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 11B","FIG. 11A"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 12A"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 12B","FIG. 12A"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 17","FIG. 5"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 18","FIG. 5"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 19","FIG. 5"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 22A"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIGS. 22B and 22C"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 25","FIG. 5"]}]},"DETDESC":[{},{}]}
