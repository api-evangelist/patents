---
title: Method and system for receiving commands using a scoreboard on an infiniband host channel adaptor
abstract: A method for processing commands on a host channel adapter includes a host channel adapter receiving data from a host connected to the host channel adapter. The command includes an instruction, identification of packet data, and a length field. The host channel adapter extracts a length of the command from the length field, generates a scoreboard mask based on the length, where the scoreboard mask includes unused bits in the scoreboard preset, and sets, with each portion of the data received, a corresponding bit in a scoreboard. The host channel adapter further determines that the size of the data received for the command matches the length using the scoreboard, issues a kick on the host channel adapter when a size of the data received for the command matches the length, executes, in response to the kick, the instruction on a pipeline, and sends the packet data on a network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08589610&OS=08589610&RS=08589610
owner: Oracle International Corporation
number: 08589610
owner_city: Redwood Shores
owner_country: US
publication_date: 20110531
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application contains subject matter that may be related to the subject matter in the following U.S. patent applications, which are both assigned to a common assignee and are both incorporated by reference in their entirety: \u201cMethod and System for Infiniband\u00ae Host Channel Adapter Quality of Service\u201d Ser. No. 13\/149,449 filed on May 31, 2011; and \u201cMethod and System for Temporary Data Unit Storage on Infiniband\u00ae Host Channel Adapter\u201d Ser. No. 13\/149,483 filed on May 31, 2011.","The Infiniband\u00ae network includes nodes that communicate through a channel-based switched fabric (Infiniband\u00ae is a registered trademark of Infiniband Trade Association, located in Beaverton, Oreg.). For example, the nodes may be a host, an input\/output subsystem, or a router which connects to another network. The switched fabric is made of a collection of switches, routers, and links that connect a set of channel adapters. The channel adapters form an interface between the switched fabric and the nodes. The channel adapter of the host is referred to as a host channel adapter. The channel adapter of an I\/O subsystem is referred to as a target channel adapter.","In Infiniband\u00ae, two processes communicate using a queue pair. A queue pair includes a send queue and a receive queue. Specifically, in order for a process to send a message to another process, the process posts the message to the send queue. The host channel adapter sends the message in the form of packets to the channel adapter having the receive queue. Each packet that is sent may include a packet sequence number. Logic associated with the receive queue ensures that packets are processed in a particular order using the packet sequence number.","Infiniband\u00ae supports operations such as remote direct memory access (RDMA) read and write operation. Specifically, a requested process may send a request in the message for the receiver to store data and\/or return data. In response, the remote node's channel adapter includes functionality to store and\/or return the requested data to the requesting process.","In general, in one aspect, the invention relates to a method for processing commands on a host channel adapter. The method includes a host channel adapter receiving data in a command from a host connected to the host channel adapter. The command includes an instruction, identification of packet data, and a length field. The host channel adapter extracts a length of the command from the length field in the data, generates a scoreboard mask based on the length, where the scoreboard mask comprises unused bits in the scoreboard preset, and sets, with each portion of the data received, a bit in a scoreboard to identify the portion of data received. The host channel adapter further determines that the size of the data received for the command matches the length using the scoreboard by performing a bitwise \u201cor\u201d operation on the scoreboard and the scoreboard mask to obtain a result, and determining that all bits of the result are set. The host channel adapter further issues a kick on the host channel adapter when a size of the data received for the command matches the length, executes, in response to the kick, the instruction on a pipeline to initiate sending the packet data, and sends the packet data on a network.","In general, in one aspect, the invention relates to a host channel adapter that includes a physical collect buffer including a payload buffer configured to store a payload of a command, a header buffer configured to store a header of the command, a scoreboard field configured to store a scoreboard for tracking the portion of the command that is received, and a scoreboard mask field configured to store a scoreboard mask for masking bits of the scoreboard based on a length of the command. The host channel adapter further includes a collect buffer controller operatively connected to the physical collect buffer and configured to receive command data in a command from a host connected to the host channel adapter. The command includes an instruction, identification of packet data, and a length field. The collect buffer controller is further configured to extract the length of the command from the length field in the data, generate the scoreboard mask based on the length, store the command data in the physical collect buffer, set, with each portion of the command data received, a bit of the scoreboard to identify the portion of data received, and issue a kick on the host channel adapter when the scoreboard and the scoreboard mask indicate that all command data of the command is received.","In general, in one aspect, the invention relates to an integrated circuit that includes a physical collect buffer including a payload buffer and a header buffer. The integrated circuit further includes a collect buffer controller configured to receive data in a command from a host connected to the host channel adapter. The command includes an instruction, identification of packet data, and a length field. The collect buffer controller further includes functionality to extract a length of the command from the length field in the data, generate a scoreboard mask based on the length, wherein the scoreboard mask includes unused bits in the scoreboard preset, store the data in the physical collect buffer, and set, with each portion of the data received, a bit in a scoreboard to identify the portion of data received. The collect buffer controller further includes functionality to determine that the size of the data received for the command matches the length using the scoreboard by performing a bitwise \u201cor\u201d operation on the scoreboard and the scoreboard mask to obtain a result, and determining that all bits of the result are set. The collect buffer controller further includes functionality to issue a kick on the host channel adapter when a size of the data received for the command matches the length, where, in response to the kick, the instruction is executed and sent on the network.","Other aspects of the invention will be apparent from the following description and the appended claims.","Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.","In the following detailed description of embodiments of the invention, numerous specific details are set forth in order to provide a more thorough understanding of the invention. However, it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. In other instances, well-known features have not been described in detail to avoid unnecessarily complicating the description.","In general, embodiments of the invention provide a method and system for signaling to the host channel adapter when the entirety of a command is received. Specifically, embodiments of the invention use a length field in the command data that defines the length of the command. Thus, when command data is received from a host, the host channel adapter extracts the length, and generates a scoreboard mask based on the length. Subsequently, with each portion of the command data received, the host channel adapter sets a bit in a scoreboard that identifies the portion of the data received. The entire command is deemed received when performing a bitwise \u201cor\u201d operation on the scoreboard and the scoreboard mask to obtain a result having all bits set.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","100","100","101","102"]},"In one or more embodiments of the invention, the host () includes one or more guest virtual machines (e.g., virtual machine 1 (), virtual machine Y ()), a control virtual machine (), a hypervisor (), and a root complex (). Each of these components is discussed below.","Broadly speaking, the virtual machines (e.g., virtual machine 1 (), virtual machine Y (), control virtual machine ()) are distinct operating environments configured to inherit underlying functionality of the host operating system via an abstraction layer. In one or more embodiments of the invention, each virtual machine includes a separate instance of an operating system (e.g., OS 1 (), OS Y ()) (OS in ). The separate instances of the operating system may be the same type of operating system or different types of operating systems.","Specifically, the guest virtual machine operating system (e.g., OS 1 (), OS Y ()) operates as if the guest virtual machine operating system is the only operating system on the host () and the resources (e.g., processor cycles, memory, resources of the host channel adapter) allocated to the guest virtual machine are the only resources available on the host (). Thus, the guest virtual machine operating system (e.g., OS 1 (), OS Y ()) includes functionality to control the operating environment of applications executing in the guest virtual machine using resource allocated to the guest virtual machine Each virtual machine may be allocated disjoint or non-overlapping physical memory ().","Many different types of virtual machines exist. For example, the Xen\u00ae virtualization project allows for multiple guest operating systems executing in a host operating system. Xen\u00ae is a trademark overseen by the Xen Project Advisory Board. In one embodiment of the invention, the host operating system supports virtual execution environments (not shown). Another example is a Solaris\u2122 Container. In such cases, the Solaris\u2122 Container may execute in the host operating system, which may be a Solaris\u2122 operating system. Solaris\u2122 is a trademark of Oracle America, Inc. In one embodiment of the invention, the host operating system may include both virtual machines and virtual execution environments.","In one or more embodiments of the invention, the guest virtual machine includes a virtual host channel adapter device driver (e.g., vHCA driver 1 (), vHCA driver Y ()). The virtual host channel adapter device driver is software program that provides an interface to host channel adapter () for the guest virtual machine operating system. Specifically, when the guest virtual machine operating system wants to send commands to the host channel adapter (), the virtual machine operating system invokes a routine in the virtual host channel adapter device driver. In response, the virtual host channel adapter device driver issues commands to a virtualized device controller (not shown) presented by the hypervisor () (discussed below). In turn, the hypervisor () includes functionality to transmit the message to the host channel adapter ().","In addition to the guest virtual machine (e.g., virtual machine 1 (), virtual machine Y ()), the host () also includes a control virtual machine (). In one or more embodiments of the invention, the control virtual machine () has a separate address space and operating system environment than the guest virtual machine (e.g., virtual machine 1 (), virtual machine Y ()). The control virtual machine () includes a control virtual machine operating system (), a control virtual machine manager (), and a virtual machine host channel adapter device driver (). The virtual machine host channel adapter device driver () includes functionality similar to the guest virtual machine host channel adapter device drivers (e.g., vHCA driver 1 (), vHCA driver Y ()) discussed above. The host virtual machine operating system () includes functionality to provide an operating environment for software executing in the control virtual machine ().","In one or more embodiments of the invention, the software executing in the control virtual machine () includes a virtual machine manager () (discussed below). In one or more embodiments of the invention, the virtual machine manager () includes functionality to configure the hypervisor (), configure the host channel adapter (), create, remove, and configure guest virtual machines, and perform the management of the host (). With regards to configuring the host channel adapter, the virtual machine manager includes functionality to send commands to the host channel adapter to adjust the number of resources allocated to each virtual machine To receive parameter values for performing the above management tasks, the virtual machine manager () may include a user interface and\/or an application programming interface for communicating with a computer administrator or another program in one or more embodiments of the invention.","Continuing with , the hypervisor () includes functionality to control the sharing of hardware resources on the host (). Specifically, the hypervisor () includes functionality to virtualize the physical devices of the host () so that more than one operating system may share the same physical device transparently in accordance with one or more embodiments of the invention. Further, the hypervisor () controls when the guest virtual machine (e.g., virtual machine 1 (), virtual machine Y ()) and the control virtual machine () are allowed to execute. For example, the hypervisor () may be a thin-privileged layer of software that only manages which guest virtual machine or the host virtual machine () is executing.","Continuing with the host, the host () includes hardware (). The hardware () may include, for example, a central processing unit (), memory (), and a root complex (). In one or more embodiments of the invention, the CPU () is a hardware processor component for processing instructions of the host. The CPU () may include multiple hardware processors. Alternatively or additionally, each hardware processor may include multiple processing cores. In general, the CPU () is any device configured to execute instructions on the host ().","In one or more embodiments of the invention, the memory () is any type of hardware device for storage of data. In one or more embodiments of the invention, the memory () may be partitioned on a per-virtual machine basis, such that each virtual machine (e.g., control virtual machine (), virtual machine 1 (), virtual machine Y ()) is allocated separate and distinct memory. In one or more embodiments of the invention, the memory () includes functionality to store a send queue (not shown).","A separate send queue may be stored in memory for each virtual machine Alternatively or additionally, multiple virtual machines may share one or more send queues. In one or more embodiments of the invention, a send queue includes functionality to store an ordered list of command identifiers for commands for processing by the host channel adapter (). In one or more embodiments of the invention, the command identifiers may be the actual commands and\/or references to the commands.","In one or more embodiments of the invention, the root complex () includes functionality to connect the CPU and memory subsystem to a peripheral component interconnect (PCI) Express switch fabric. Specifically, in one or more embodiments of the invention, the root complex () connects the host () to the host channel adapter (). Although  shows the root complex () as separate from the CPU (), the root complex () may be integrated as part of the CPU.","The root complex () includes an input\/output memory management unit (IOMMU) () in one or more embodiments of the invention. The IOMMU () includes functionality to connect a direct memory access (DMA) input\/output (I\/O) bus to the memory. In one or more embodiments of the invention, the IOMMU () includes functionality to translate device virtual addresses to physical addresses of memory on the host ().","Continuing with , the host () is connected to the host channel adapter (). In one or more embodiments of the invention, the connection between the host () and the host channel adapter () may be a PCI express connection. Specifically, the host channel adapter may connect to a PCI express fabric connector on the host.","In one or more embodiments of the invention, the host channel adapter () is a hardware device configured to connect the host () to the Infiniband\u00ae network (). Specifically, the host channel adapter () includes functionality to receive commands from the host () and process the commands. Processing the commands may include performing DMA with host memory to obtain and store packet data and to obtain control information, performing any validation required on the packet data, generating packets from the packet data, and sending and receiving packets on the Infiniband\u00ae network ().  shows a schematic diagram of the host channel adapter () from the prospective of the host (). As shown in , the host channel adapter () includes at least one Infiniband\u00ae port (e.g., Infiniband\u00ae port 1 (), Infiniband\u00ae port 2 ()), a resource pool (), and an embedded processor subsystem (). Each of the components of the host channel adapter is discussed below.","In one or more embodiments of the invention, an Infiniband\u00ae port (e.g., Infiniband\u00ae port 1 (), Infiniband\u00ae port 2 ()) is a physical interface connector between the host channel adapter () and the Infiniband\u00ae network (). Although  shows two Infiniband\u00ae ports, more or fewer ports may exist without departing from the invention.","The resource pool () is a collection of resources that are required to send and receive packets on the Infiniband\u00ae network. Specifically, the resource pool () corresponds to the collection of hardware and stored data that is shared by the virtual machines (e.g., control virtual machine (), virtual machine 1 (), virtual machine Y ()). The resource pool () is discussed in  below.","In one or more embodiments of the invention, the sharing of the resource pool is performed using the concepts of physical function and virtual functions. A physical function () exposes the actual hardware of the host channel adapter () to an operating system. Specifically, by way of the physical function, the control virtual machine operating system () may control the host channel adapter. Thus, the physical function allows the control virtual machine () to control the host channel adapter (), such as to disable the host channel adapter ().","A virtual function (e.g., virtual function 1 (), virtual function Y ()) exposes a virtualized host channel adapter to a virtual machine Specifically, the virtual function (e.g., virtual function 1 (), virtual function Y ()) exposes to the virtual machine operating system only the partition of the resource pool allocated to the virtual machine To the guest virtual machine (e.g., virtual machine 1 (), virtual machine Y ()), the resources exposed by the virtual function (e.g., virtual function 1 (), virtual function Y ()) appear as if the resource are the only resources on the host channel adapter (). Thus, the virtual function (e.g., virtual function 1 (), virtual function Y ()) allows the virtual machine operating system (e.g., OS 1 (), OS Y ()) to control the portion of resources allocated to the virtual machine In other words, a virtual function (e.g., virtual function 1 (), virtual function Y ()) provides the virtual machine operating system (e.g., OS 1 (), OS Y ()) the appearance that the virtual machine operating system (e.g., OS 1 (), OS Y ()) is controlling the host channel adapter () as a whole even though the actions of the virtual machine operating system (e.g., OS 1 (), OS Y ()) does not affect any other virtual function (e.g., virtual function 1 (), virtual function Y ()).","In one or more embodiments of the invention, the term, underlying function (UF), is used to generically refer to either a physical function or a virtual function. Specifically, as used herein, an underlying function may be a physical function or a virtual function.","The embedded processor subsystem () corresponds to an embedded processor and logic for managing the host channel adapter (). The embedded processor subsystem includes a service processor resource manager () and a send queue scheduler (). The service processor resource manager () includes functionality to receive and process the management commands on the host channels adapter. For example, the management commands may be to change the allocation of host channel adapter resources, change the configuration of the host channel adapter, and perform other management of the host channel adapter. With regards to resource allocation, the service processor resource manager includes functionality to change the allocation of the host channel adapter resources to underlying functions and change the allocation of the host channel adapter resources to QoS levels within the underlying functions.","Continuing with , the send queue scheduler () includes functionality to schedule commands identified in the send queue on the host channel adapter. Specifically, the send queue scheduler includes functionality to iterate through the send queue and store commands identified in the send queue on the host channel adapter ().","As discussed above,  provides a general diagram of the host channel adapter () in one or more embodiments of the invention.  shows a schematic diagram of the resources and management components for the resources of the host channel adapter in one or more embodiments of the invention. Specifically,  shows components of the resource pool for transmission of messages on the Infiniband\u00ae network as shared between virtual machines and components to manage the resource pool in one or more embodiments of the invention.","In general, the resource pool is configured to receive and execute commands from a virtual machine A command corresponds to an instruction to the host channel adapter. For example, a command may be an instruction to send a message on the Infiniband\u00ae network (not shown). A command includes command data in one or more embodiments of the invention. Specifically, command data corresponds to individual portions of the command.","When the command is an instruction to send a message on the Infiniband\u00ae network, the command may include the message itself or one or more addresses in the host memory having the message. The host channel adapter is configured to obtain the command, obtain the message from the command or from host memory referenced in the command, partition the message into packets if required, and send the packets on the Infiniband\u00ae network in accordance with an Infiniband\u00ae protocol. In one or more embodiments of the invention, the message is packet data. Specifically, packet data is data sent in the packets on the Infiniband\u00ae network. Thus, the packet data may be in the command or in the one or more addresses in host memory.","As shown in , the resource pool and management components of the host channel adapter include a non-blocking pipeline (), a virtual kick arbitrator (), transmit virtual lane (TVL) virtual kick lists (e.g., virtual kick list(), virtual kick list()), a mapping table (), physical collect buffer (PCB) pool (), dedicated PCBs (), a PCB allocator (e.g., PCB Allocator(), PCB Allocator()), virtual collect buffers (VCBs) (e.g., VCB 0(), VCB N(), VCB 0(), VCB T()), and underlying function CSRs (e.g., underlying functionCSR(), underlying functionCSR()). Each of these components is discussed below.","The non-blocking pipeline () corresponds to a set of hardware and firmware that includes functionality to process commands on the host channel adapter. Specifically, the non-blocking pipeline () includes functionality to obtain a command from a PCB (described below), obtain packet data based on the command data, verify the queue pair for sending the packet data, generate one or more packets having the packet data, and sending the packets on the Infiniband\u00ae network in accordance with the Infiniband\u00ae protocol. In one or more embodiments of the invention, the non-blocking pipeline () is partitioned into modules (not shown). Each module corresponds to hardware and\/or firmware that includes functionality to perform a portion of the nonblocking pipeline. For example, one module may be configured to perform DMA with the host memory while another module may be configured to generate packets having the packet data.","In one or more embodiments of the invention, one of the modules includes a completion module. A completion module includes functionality to store messages in a completion linked list queue until an acknowledgement is received or transmission is deemed to have failed, such as by not receiving an acknowledgement within a predefined period of time. In one or more embodiments of the invention, the completion module is used when a queue pair is set in reliable transmission mode.","In one or more embodiments of the invention, the non-blocking pipeline is time shared amongst TVLs. In particular, a TVL is a time slice of the non-blocking pipeline. In other words, commands assigned to a TVL may be blocked by the execution through the pipeline of one or more other commands in the same TVL. In contrast to commands assigned to the same TVL, when a command is assigned to a different TVL, the command is not blocked by other commands in different TVLs.","In one or more embodiments of the invention, each TVL is associated with a virtual kick list (e.g., virtual kick list(), virtual kick list()). A virtual kick list (e.g., virtual kick list(), virtual kick list()) corresponds to a storage location for storing command identifiers of commands, assigned to the TVL, for which a kick has issued. A kick indicates that the command is ready for execution on the non-blocking pipeline (). Specifically, in one or more embodiments of the invention, the kick indicates that the entirety of the command is stored on the host channel adapter. In one or more embodiments of the invention, commands are processed from the virtual kick list in a first in first out (FIFO) order. In other words, the commands are processed in an order in which the commands are received.","In one or more embodiments of the invention, the command identifier of the command may be the command, an address of a memory location having the command, or any other data that identifies the command. For example, the command identifier may be an address or identifier of the PCB (discussed below) having the command.","In one or more embodiments of the invention, a virtual kick arbitrator () is operatively interposed between the virtual kick list (e.g., virtual kick list(), virtual kick list()) and the non-blocking pipeline (). In one or more embodiments of the invention, the virtual kick arbitrator includes functionality to arbitrate between TVLs having commands initiating execution on the pipeline. Specifically, the virtual kick arbitrator includes functionality to select a TVL and initiate execution of the command from the virtual kick list for the TVL.","Continuing with , the host channel adapter includes PCBs (e.g., dedicated PCBs (), PCB 0 (), PCB Z ()). A PCB is physical memory that is configured to store a single command. Further, each command requires a single PCB in one or more embodiments of the invention.","Dedicated PCBs correspond to PCBs that are dedicated for use by administrator and management components in one or more embodiments of the invention. For example, dedicated PCBs may be used by the service processor resource manager, the send queue scheduler, a host process for controlling the host channel adapter, and for other such components of the system.","In one or more embodiments of the invention, the host channel adapter includes a PCB pool (). A PCB pool () corresponds to a collection of PCBs (e.g., PCB 0 (), PCB Z ()) that are available for use by any underlying function. Specifically, each PCB (e.g., PCB 0 (), PCB Z ()) in the PCB pool () may used by any underlying function in one or more embodiments of the invention. When a PCB is in use by an underlying function (e.g., Underlying Function(), Underlying Function ()) to store a command, the PCB is considered bound to the underlying function and cannot be used by another underlying function. The PCB is discussed in further detail below and in .","Continuing with , a TVL mapping table is operatively interposed between the PCBs (e.g., dedicated PCBs (), PCB 0 (), PCB Z ()) and the virtual kick list (e.g., virtual kick list(), virtual kick list()) in one or more embodiments of the invention. The TVL mapping table () includes a mapping of the underlying function (e.g., Underlying Function(), Underlying Function()) to one or more TVLs. In particular, the mapping defines, for each underlying function, which TVLs correspond to the underlying function. Specifically, each underlying function may be allocated a set of TVLs. In one or more embodiments of the invention, the mapping of set of TVLs may be storage of an identifier of the underlying function with an identifier of the virtual kick lists corresponding to the TVLs in the set of TVLs.","Additionally, in one or more embodiments of the invention, a set of TVLs may be allocated to the dedicated PCBs (). Thus, the TVL mapping table () may further include a mapping of the dedicated PCBs to the set of TVLs allocated to the dedicated PCBs.","Continuing with , the PCB pool () is connected to one or more PCB allocators. A PCB allocator is logic, such as hardware or firmware, configured to select the PCB from the PCB pool () for storing a command. Although  shows multiple PCB allocators, a single PCB allocator may exist for all underlying functions. Alternatively or additionally, a separate PCB allocator may exist for each PCB. The PCB allocator is discussed in further detail below and in .","In one or more embodiments of the invention, the PCB allocator further includes functionality to bind the PCB to a VCB (VCB) (e.g., VCB 0(), VCB N(), VCB 0(), VCB T()). In one or more embodiments of the invention, a VCB is a virtual address space used by a process on the host to write to a PCB. Specifically, a single VCB is capable of being bound to only a single PCB at any single moment in time in one or more embodiments of the invention. Thus, the binding a PCB to a VCB creates an association between the VCB and the PCB. In other words, the binding prevents the PCB from being used by any other VCB and prevents the VCB from being associated with any other PCB.","In one or more embodiments of the invention, an underlying function CSR (e.g., CSR(), CSR()) stores status and control information about the VCBs allocated to the underlying function. Specifically, each underlying function is allocated a set of VCBs from a VCB pool (discussed below and in ). The number of VCBs allocated to an underlying function represents a guarantee of the number of commands that the HCA will process for the virtual machine corresponding to the underlying function. In one or more embodiments of the invention, the number of VCBs allocated to an underlying function may exceed the number of PCBs allocated to the underlying function. The flowcharts of , discussed below, provide a method for processing requests when the underlying function has a VCB available and no PCBs available.","Continuing with , in one or more embodiments of the invention, the underlying function CSR (e.g., CSR(), CSR()) may include a base address register (BAR). The BAR stores the lowest virtual address assigned to the underlying function in one or more embodiments of the invention. The underlying function CSR may further store information about which VCBs are in use in one or more embodiments of the invention.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["300","302","302","304","304"],"sub":["0 ","Y ","0 ","Y "],"i":["a","b","a","b"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["400","400","402"]},"As shown in , the PCB allocator () is connected to a PCB (e.g., PCB ()). In one or more embodiments of the invention, each PCB (e.g., PCB ()) includes a payload buffer (), a header buffer (), a scoreboard mask field (), and a scoreboard field (). Each of these components is described below.","In one or more embodiments of the invention, the payload buffer () corresponds to storage for storing the payload of the command. Specifically, the command may include packet data to send on the Infiniband\u00ae network or may include one or more addresses in memory on the host that include the packet data. In one or more embodiments of the invention, if the command includes packet data, the packet data is stored as payload in the payload buffer ().","In one or more embodiments of the invention, the header buffer () corresponds to storage for storing the header of the command. The header of the command includes data for processing by the host channel adapter. For example, the header may include the type of command, one or more addresses in memory on the host that includes packet data, a queue pair identifier, a length of the command, and\/or any other information for processing by the host channel adapter.","The scoreboard mask field () and the scoreboard field () each include functionality to store a scoreboard mask and a scoreboard, respectively. The scoreboard mask and the scoreboard may each be represented as a bit string (i.e., an ordered series of bits), where each bit in the bit string corresponds to a location of command data in relation to the VCB. Specifically, in one or more embodiments of the invention, the VCB is a virtual page. The virtual page is the same size as the PCB in one or more embodiments of the invention. Thus, each bit in the scoreboard mask () represents a specific segment of the virtual page, and, therefore, a specific segment of the PCB. In one or more embodiments of the invention, the segments of the PCB are non-overlapping and together form the entire PCB. In one or more embodiments of the invention, the size of the scoreboard mask field () and the scoreboard field () and, therefore, the number of bits in the bit string, is at least as many as the number of bits to represent each segment of the PCB.","In one or more embodiments of the invention, the scoreboard is used to track which segment of command data is received. Specifically, in one or more embodiments of the invention, each bit in the scoreboard may initially be reset (defined below). As command data is received, the bit in the position corresponding to the segment of the received command data is set.","In one or more embodiments of the invention, for a particular command, the scoreboard mask is configured to have bits that represent segments of the PCB that will not be used for a particular command set. The bits that represent segments of the PCB that will not be used for a particular command set may be referred to herein as unused bits. In other words, for a particular command, the unused bits are set based on the PCB being greater than the size of the particular command. In one or more embodiments of the invention, the unused bits may be set immediately after a length value is received and used to update the scoreboard before being reset for the next command data received. Alternatively, the unused bits may be continually set after the length value is received until kick is issued.","In one or more embodiments of the invention, a bit is set when the value of the bit is changed to indicate that command data is received for the corresponding segment. A bit is reset when the value of the bit changes from indicating command data is received for the corresponding segment to indicating command data is not received for the corresponding segment. A bit is not set when the value of the bit indicates that command data is not received for the corresponding segment. A bit is preset when the value of the bit is initialized to indicate command data is received for the corresponding segment.","For example, in binary terms, a value of \u201c1\u201d may indicate that command data is received for the corresponding segment. In the example, a bit is set when the value of the bit is changed to \u201c1\u201d, reset when the value of the bit changes from \u201c1\u201d to \u201c0\u201d, not set when the value of the bit is \u201c0\u201d, and preset when the value of the bit is initialized to \u201c1\u201d. As an alternative example in binary terms, the value of \u201c1\u201d may indicate that command data is not received for the corresponding segment. In the alternative example, a bit is set when the value of the bit is changed to \u201c0\u201d, reset when the value of the bit changes from \u201c0\u201d to \u201c1\u201d, not set when the value of the bit is \u201c1\u201d, and preset when the value of the bit is initialized to \u201c0\u201d.","Continuing with the PCB (), consider the following example. Consider the scenario in which the payload buffer is 256 bytes (B) and the header buffer is 64 B. In the example, the scoreboard field and scoreboard mask field may each be 40 bits. Each bit in the scoreboard represents a separate and distinct 8 B of the 320 B command. Similarly, each bit in the scoreboard mask field represents a separate and distinct 8 B of the 320 B command. Thus, the first 8 bits of each of the scoreboard and scoreboard mask may represent 8 B of the header. The remaining 32 bits of the scoreboard and the scoreboard may represent 8 B of the payload. In the example, consider the scenario in which a command has a 64 B header and only a 128 B payload. In the example, consider the scenario in which the length is the first command data received. In the example, the scoreboard mask is updated to have the first eight bits not set for the header, the next 16 bits not set for the payload, and the remaining bits set in one or more embodiments of the invention (e.g., scoreboard mask=\u201c0000 0000 0000 0000 0000 0000 1111 1111\u201d). Continuing with the example, the scoreboard may be updated using the scoreboard mask (e.g., scoreboard=\u201c0000 0000 0000 0000 0000 0000 1111 1111\u201d after the length is received). When the first 8 B of the header is received, the scoreboard has the first bit set (e.g., scoreboard=\u201c1000 0000 0000 0000 0000 0000 1111 1111\u201d). When the second 8 B of the header is received, the scoreboard has the first two bits set (e.g., scoreboard=\u201c1100 0000 0000 0000 0000 0000 1111 1111\u201d). As shown, with each portion of command data received regardless of order, the scoreboard is updated to reflect the portion of command data received. When the scoreboard completely set, then a virtual kick is issued.","Continuing with , the PCB allocator () is connected to a port data collector (). In one or more embodiments of the invention, the port data collector () is a hardware port configured to receive command data from a transmission medium that connects the host to the host channel adapter. In one or more embodiments of the invention, the transmission medium is a PCI express fabric bus (not shown). The port data collector includes functionality to transmit the command data to a collect buffer controller () (discussed below).","In one or more embodiments of the invention, the port data collector () is operatively connected to the PCB allocator (). The PCB allocator includes a collect buffer controller (), a doorbell checksum state (), a collect group table (), a free PCB list controller (), and an underlying function table (). In one or more embodiments of the invention, the collect buffer controller () corresponds to hardware and\/or firmware. The collect buffer controller () includes functionality to receive command data from the port data collector (), select a PCB (e.g., PCB ()) from the PCB pool to process the command, update the scoreboard field (), and trigger a virtual kick when the entirety of the command data is received.","In one or more embodiments of the invention, the collect buffer controller () includes a scoreboard mask generator logic () and kick logic (). The scoreboard mask generator logic () includes functionality to identify the length field in the command data, extract a length value from the length field, and generate the scoreboard mask based on the length value.","In one or more embodiments of the invention, kick logic () include functionality to determine whether the entire command is received, and issue a kick when the entire command is received. The kick logic () is operatively connected to the scoreboard field (), the scoreboard mask field (), and the virtual kick list () (discussed above and in ).","Continuing with the PCB allocator (), the doorbell checksum state () corresponds to a block that stores a checksum of the contents of the payload buffer and the header buffer. In one or more embodiments of the invention, the checksum is a one's complement of the sum of the header and the payload. However, other types of checksums may be used without departing from the scope of the invention.","In one or more embodiments of the invention, the collect group table () maintains a counter for each collect group. The counter denotes the number of PCBs available to each collect group. In one or more embodiments of the invention, a collect group corresponds to an underlying function, a quality of service level with the underlying function, or grouping of entities. In one or more embodiments of the invention, when writing to a PCB is initiated, the counter corresponding to the collect group may be decremented.","In one or more embodiments of the invention, the free PCB list controller () corresponds to logic and storage for storing a free PCB list identifying PCB(s) that are not currently in use. Different structures may be used for the free PCB list. For example, in one or more embodiments of the invention, the free PCB list is a bit string. Each bit in the free PCB list represents a particular PCB. When the bit corresponding to the PCB is set, then the PCB may be deemed available. Another structure may be for the free PCB list to store a unique identifier of each PCB that is available. When the unique identifier is removed from the free PCB list, then the PCB may be deemed to be no longer available.","In one or more embodiments of the invention, the underlying function table () corresponds to storage for storing information about the VCBs allocated to each underlying function. Specifically, the underlying function table identifies the virtual address space corresponding to each underlying function in one or more embodiments of the invention.","Although  show a certain configuration of components, other configurations may be used without departing from the invention. For example, rather than having a PCB pool from which any underlying function may use, individual PCB may be allocated to a particular underlying function to be used solely for the particular underlying function. Other variations of the system may be used without departing from the invention.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIGS. 5-10","FIG. 5"]},"In Step , a process executing in a virtual machine acquires a lock to the dedicated PCB. In one or more embodiments of the invention, the lock is located on the host channel adapter. In Step , the process executing in the virtual machine writes a command to the send queue on the host. In one or more embodiments of the invention, the writing of the command to the send queue may be performed by acquiring a separate lock corresponding to the memory location of physical memory having the send queue and storing the command in the memory location.","Continuing with , in Step , the virtual machine determines whether a dedicated PCB is available. In one or more embodiments of the invention, determining whether a dedicated PCB is available may be performed by checking a CSR that indicates whether the corresponding dedicated PCB is in use. In one or more embodiments of the invention, the CSR may be set and checked by both hosts processes and the embedded processor subsystem.","In Step , when the dedicated PCB is available, the host channel adapter receives command data (i.e., data in the command) and writes the command data to the PCB until the kick is received. Specifically, in one or more embodiments of the invention, the command data may be transmitted to the host channel adapter using the PCI express fabric. Each command may be of variable length. The kick indicates that the entirety of the command is stored in the PCB. Performing Step  is discussed below and in . Continuing with , in Step , the lock is released in one or more embodiments of the invention.","Although  shows a flowchart for a process on the host to use the dedicated PCB, in one or more embodiments of the invention, dedicated PCBs may be used by the virtual machine manager, the send queue scheduler, portions of the electronic processor subsystem, and other components to perform management functions.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 6","b":"601"},"In Step , a determination is made about whether a VCB is available. Management of the usage of the VCBs is performed by the virtual machine operating system in one or more embodiments of the invention. Specifically, the virtual machine operating system allocates the VCBs to the process in the virtual machine requesting the VCB. The process selects the VCB to allocate from the set of VCBs allocated to the process. If a VCB is not available, then the process waits.","When a VCB is available, the process in the virtual machine sends a command to the requested address of the VCB in Step . At this stage, once the command is sent to the VCB, to the process, the command is processed by the host channel adapter. However, the physical resources may not be available on the host channel adapter.","In Step  a determination is made about whether a PCB is available to the underlying function. Specifically, when command data corresponding to a new command is received, the PCB allocator determines, based on the VCB address, whether a PCB is available. For example, the PCB allocator may first check whether a PCB corresponding to the underlying function is available. If a PCB corresponding to the underlying function is not available, then the PCB allocator may check whether a PCB shared amongst the underlying functions is available. Checking whether a PCB is available may be performed by checking a CSR to determine whether the maximum allocated number of PCBs is in use.","In Step , if a PCB is available, then PCB is bound to the VCB and the command data is written to the PCB. In one or more embodiments of the invention, the binding means that any subsequent command data written to the VCB for the command is stored in the PCB bound to the VCB. Writing command data until the kick is received may be performed as discussed above with reference to Step  in .","Continuing with , if a PCB is not available, then the VCB is marked to be in send queue mode in Step . By marking the VCB in send queue mode, the command is set to be later obtained from the send queue.","In Step , the queue pair identifier and the send queue sequence number is extracted from the command data and the remaining command data is dropped until the kick is received. In one or more embodiments of the invention, the queue pair identifier corresponds to the queue pair to which the command is directed. The send queue sequence number provides an identifier of where the command was stored in the send queue in Step  (discussed above).","As discussed above, the non-existence of a PCB may be hidden from the process in the virtual machine Accordingly, the process of the virtual machine may send command data for the entire command to the host channel adapter. However, as discussed above, the remaining command data is dropped in one or more embodiments of the invention.","In Step , the queue pair identifier and the send queue sequence number is added to the queuing structure in host memory. By adding the queue pair identifier and the send queue sequence number to the queuing structure, the command may be obtained by the send queue scheduler and stored on the host channel adapter. In Step , once the kick is received, the VCB is freed. At this stage, the VCB may be used by other processes in the virtual machine.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 7","FIG. 5"]},"In Step , the send queue scheduler identifies the next entry in the queuing structure. In one or more embodiments of the invention, the queuing structure is a first in first out queue. In such embodiments, the next entry in the queuing structure is the oldest entry in the queuing structure.","In Step , the send queue scheduler determines whether a dedicated PCB is available. Determining whether a dedicated PCB is available may be performed as discussed above with reference to Step  of .","When a dedicated PCB is available, the send queue scheduler obtains the send queue sequence number and the queue pair identifier in the queuing structure. The scheduler requests the command from the send queue location corresponding to the send queue sequence number using the queue pair identifier. When the scheduler requests the command, the command data is transferred to the host channel adapter.","In Step , the host channel adapter receives the command data from the send queue and writes the data to the dedicated PCB until the kick is received. Step  may be performed in a similar manner as discussed above with reference to Step  in .","In Step , a determination is made about whether another entry in the queuing structure on the host exists. If another entry exists, then the send queue scheduler continues  to process the next entry in the queuing structure.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 8","b":"801"},"In Step , a determination is made about whether the received command data includes a length field. Determining whether the received command data includes the length field may be performed using the predefined protocol. In Step , if the received command data includes a length field, the length value is obtained from the length field. At this stage, the host channel adapter has information regarding the size of the command.","In Step , regardless of whether the command data includes a length field, a scoreboard mask is generated. If the scoreboard mask includes a length field, generating the scoreboard mask includes identifying, from the length value, the length of the header and the length of the payload. In one or more embodiments of the invention, from the length of the header, the used and unused segments of the header are identified. A used segment is one which will store command data for the command while and unused segment is one which will not store command data for the command. The bits of the scoreboard mask corresponding to the used segment(s) of the header are not set while the bits corresponding to the unused segment(s) of the header are set. Similarly, in one or more embodiments of the invention, from the length of the payload, the used and unused segments of the payload are identified. The bits of the scoreboard mask corresponding to the used segment(s) of the payload are not set while the bits corresponding to the unused segment(s) of the payload are set.","Continuing with Step , if the command data includes data for storage in the PCB, then bits corresponding to the segments are set in the scoreboard mask. Specifically, an address of the command data is identified. Based on the address of the command data, the segment of the header buffer or the payload buffer being populated is identified. In one or more embodiments of the invention, because a page of the VCB corresponds to a page of the PCB, only the offset in the address is used to identify the segment. The bit(s) in the scoreboard mask corresponding to the identified segment is set in one or more embodiments of the invention. In such embodiments, the scoreboard mask not only masks the unused bits, but also masks the bits corresponding to the received command data that is stored in the PCB.","In Step , the received command data is stored in the PCB. The received command data is stored in the PCB bound to the VCB to which the command data is addressed. In one or more embodiments of the invention, the received command data may be stored with or without the length field.","In Step , a determination is made about whether the scoreboard and the scoreboard mask indicate that the full length of the command is received. In one or more embodiments of the invention, a bitwise \u201cOR\u201d operation is on the scoreboard and the scoreboard mask to obtain a result. If the result has all of bits set, then the full length of the command is determined to be received. If the full length of the command is not received, then the method may repeat with Step  to receive command data for the command on the bus.","If the full length of the command is received, then a kick is issued in Step  in one or more embodiments of the invention. Issuing a kick may be performed by accessing the TVL mapping table to identify the TVL corresponding to the command. Specifically, from the TVL mapping table the TVL or set of TVLs corresponding to the underlying function is identified. If a set of TVLs are identified, then a TVL may be selected from the set of TVLs, such as by using a load balancing protocol. The virtual kick list corresponding to the selected TVL is identified and an identifier of the PCB having the command is stored in the virtual kick list. When the identifier of the PCB is in the virtual kick list, the command is deemed ready for processing by the non-blocking pipeline in one or more embodiments of the invention.","In Step , the scoreboard is updated. Updating the scoreboard may be performed by storing the result of the operation performed in  in the scoreboard. Specifically, in one or more embodiments of the invention, a bitwise \u201cOR\u201d operation is performed on the previous value of the scoreboard and the scoreboard mask to create a result. The result is written as a new value for the scoreboard in one or more embodiments of the invention. In one or more embodiments of the invention, after the length field is received and if a kick is not issued, the scoreboard has the unused bits set.",{"@attributes":{"id":"p-0106","num":"0105"},"figref":["FIG. 9","FIG. 9","FIG. 8"],"b":["901","903","905","909","913","915","801","803","805","809","811","813","901","903","905","907","909"]},"In Step , the scoreboard is updated based on the received data. In one or more embodiments of the invention, the scoreboard is directly updated by the collect buffer controller. Updating the scoreboard may be performed by identifying based on the address of the command data, the segment of the header buffer or the payload buffer being populated. The bit corresponding to the identified segment is set in the scoreboard in one or more embodiments of the invention.","In Step , a determination is made about whether the scoreboard and the scoreboard mask indicate that the full length of the command is received. If the full length of the command is not received, then the method may repeat with Step  to receive command data for the command on the bus. If the full length of the command is received, then a kick is issued in Step  in one or more embodiments of the invention.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 10","b":"1001"},"In Step , a determination is made about whether DMA is required. In one or more embodiments of the invention, the host channel adapter supports DMA between the host memory and the host channel adapter. For example, command data sent to the host channel adapter may include the packet data for packets to send on the Infiniband\u00ae network. In such a scenario, in Step , if DMA is not required, then the packet data is extracted from the command in the PCB.","Alternatively, the command data may specify a location in host memory, such as the location of packet data. If the command data specifies a location in host memory, then DMA is required to obtain the command data. In Step , a DMA module identifies one or more locations in host memory that are specified in the command data in the PCB. In Step , the DMA module obtains the packet data from the one or more locations in host memory and stores the packet data into buffers. In one or more embodiments of the invention, as part of obtaining the packet data, the DMA may perform validation to ensure that the host process sending the command has necessary permissions to obtain the packet data.","In Step , regardless of whether DMA is performed to obtain the packet data, the packets are issue to the Infiniband\u00ae port for sending on the Infiniband\u00ae network. In particular packets are generated from the packet data. The generating of the packets may include performing various levels of identification and validation, such as validating the send queue sending the packet(s) and the receive queue receiving the packet(s).",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIGS. 11A-11B","FIG. 11A"],"b":["1100","1102","1104","1102","1106","1108","1110"]},"Each virtual machine is associated with an underlying function. For example, the control virtual machine is associated with underlying function 0 (). The weatherModeler virtual machine is associated with underlying function 1 (). The OceanStreams virtual machine () is associated with underlying function 2 (). Each underlying function has a corresponding BAR (e.g., BAR 1 (()), BAR 1 (()), BAR 2 (())). In one or more embodiments of the invention, the BAR defines which underlying function is writing to a PCB in the PCB pool ().","In the example, consider the scenario in which a process in the weatherModeler virtual machine () wants to send a command on the Infiniband\u00ae network (). In the example, the process, through the weatherModeler virtual machine operating system (not shown) and virtual host channel adapter device driver (not shown), writes the command to a virtual address of a VCB. The command is sent over time as a series of command data. The command data may be sent in order or out of order.","When the collect buffer controller () receives the first command data directed to the VCB, the collect buffer controller () determines that the VCB is not yet bound to a PCB (e.g., PCB i (), PCB j ()). Based on PCB j () in the PCB pool () being available, the collect buffer controller () selects PCB j (). At this stage, with each command data received, the collect buffer controller () may start updating the scoreboard field (), the scoreboard mask field (), the payload buffer and the header buffer ().","Continuing with the example,  shows a chart showing the example updates to the scoreboard field and the scoreboard mask field in one or more embodiments of the invention. In the chart, column 1 () lists the sequence of command data. Specifically, each row represents a step in the sequence of command data. Column 2 () shows the scoreboard in the scoreboard field when the command data in the sequence is received. Column 3 () shows the scoreboard mask based on the receipt of the command data. Column 4 () shows the result of a check to determine whether to issue a kick. Column 5 () shows the value written to the scoreboard in one or more embodiments of the invention. In the chart, the scoreboard, scoreboard mask, result of the scoreboard check, and the write are all presented in hexadecimal format. Further, the use of 40'h in  means that the hexadecimal number represents a 40 bit number. The use of 12'h means that the hexadecimal number represents a 12 bit number.","In Step , an initialization is performed as shown in Step , column 1 (). Specifically, as shown in Step , column 5 (), the value of \u201c0000000000\u201d is written to the scoreboard. At this stage, all bits in the scoreboard are reset. Further, the scoreboard mask will be overwritten with each subsequent command data in one or more embodiments of the invention. In one or more embodiments of the invention, the scoreboard may be reset immediately upon issuing a kick for the previous command received in the PCB and\/or as part of initiating processing of a new command.","In Step , command data at page offset 12'h10 is received as shown in Step , column 1 (). When the command data at page offset 12'h10 is received, based on Step , the scoreboard is \u201c0000000000\u201d as shown in Step , column 2 (). Based on the page offset, the bit in the scoreboard mask corresponding to the segment received is set. Thus, the value of the scoreboard mask is \u201c0000000004\u201d as shown in Step , column 3 (). After updating the scoreboard mask, a determination is made about whether the scoreboard and the scoreboard mask indicate that the entire command is received. Performing bitwise \u201cOR\u201d operation on the scoreboard and the scoreboard mask yields a scoreboard check result of \u201c0000000004\u201d as shown in Step , column 4 (). \u201c0000000004\u201d means that not all bits are set (i.e., the value of the scoreboard check result is not \u201cff_ffff_ffff\u201d). Because not all bits are set, a kick is not issued. Further, the result (i.e., \u201c0000000004\u201d) is written to the scoreboard as shown in Step , column 5 ().","In Step , command data at page offset 12'h20-0x38 is received as shown in Step , column 1 (). When the command data at page offset 12'h20-0x38 is received, based on Step , the scoreboard is \u201c0000000004\u201d as shown in Step , column 2 (). Based on the page offset, the bit in the scoreboard mask corresponding to the segment received is set. Thus, the value \u201c00000000f0\u201d is written to the scoreboard mask as shown in Step , column 3 (). After updating the scoreboard mask, a determination is made about whether the scoreboard and the scoreboard mask indicate that the entire command is received. Performing bitwise \u201cOR\u201d operation on the scoreboard and the scoreboard mask yields a scoreboard check result of \u201c00000000f4\u201d as shown in Step , column 4 (). Because \u201c00000000f4\u201d means that not all bits are set, a kick is not issued. Further, the result (i.e., \u201c00000000f4\u201d) is written to the scoreboard as shown in Step , column 5 ().","In Step , command data at page offset 12'h0 is received as shown in Step , column 1 (). The command data further includes a length field indicating that the length is 16 B as shown in Step , column 1 (). When the command data at page offset 12'h0 is received, based on Step , the scoreboard is \u201c00000000f4\u201d as shown in Step , column 2 (). Based on the length field, the value \u201cff_ffff_fc01\u201d is written to the scoreboard mask as shown in Step , column 3 (). After updating the scoreboard mask, a determination is made about whether the scoreboard and the scoreboard mask indicate that the entire command is received. Performing bitwise \u201cOR\u201d operation on the scoreboard and the scoreboard mask yields a scoreboard check result of \u201cff_ffff_fcf5\u201d as shown in Step , column 4 (). Because \u201cff_ffff_fcf5\u201d means that not all bits are set, a kick is not issued. Further, the result (i.e., \u201cff_ffff_fcf5\u201d) is written to the scoreboard as shown in Step , column 5 ().","In Step , command data at page offset 12'h8 is received as shown in Step , column 1 (). When the command data at page offset 12'h8 is received, based on Step , the scoreboard is \u201cff_ffff_fcf5\u201d as shown in Step , column 2 (). Based on the page offset, the bit in the scoreboard mask corresponding to the segment received is set. Thus, the value \u201c0000000002\u201d is written to the scoreboard mask as shown in Step , column 3 (). After updating the scoreboard mask, a determination is made about whether the scoreboard and the scoreboard mask indicate that the entire command is received. Performing bitwise \u201cOR\u201d operation on the scoreboard and the scoreboard mask yields a scoreboard check result of \u201cff_ffff_fcf7\u201d as shown in Step , column 4 (). Because \u201cff_ffff_fcf7\u201d means that not all bits are set, a kick is not issued. Further, the result (i.e., \u201cff_ffff_fcf5\u201d) is written to the scoreboard as shown in Step , column 5 ().","In Step , command data at page offset 12'h18 is received as shown in Step , column 1 (). When the command data at page offset 12'h18 is received, based on Step , the scoreboard is \u201cff_ffff_fcf7\u201d as shown in Step , column 2 (). Based on the page offset, the bit in the scoreboard mask corresponding to the segment received is set. Thus, the value \u201c0000000008\u201d is written to the scoreboard mask as shown in Step , column 3 (). After updating the scoreboard mask, a determination is made about whether the scoreboard and the scoreboard mask indicate that the entire command is received. Performing bitwise \u201cOR\u201d operation on the scoreboard and the scoreboard mask yields a scoreboard check result of \u201cff_ffff_fcff\u201d as shown in Step , column 4 (). Because \u201cff_ffff_fcff\u201d means that not all bits are set, a kick is not issued. Further, the result (i.e., \u201cff_ffff_fcff\u201d) is written to the scoreboard as shown in Step , column 5 ().","In Step , command data at page offset 12'h40-12h'48 is received as shown in Step , column 1 (). When the command data at page offset 12'h40-12h'48 is received, based on Step , the scoreboard is \u201cff_ffff_fcff\u201d as shown in Step , column 2 (). Based on the page offset, the bit in the scoreboard mask corresponding to the segment received is set. Thus, the value \u201c0000000030\u201d is written to the scoreboard mask as shown in Step , column 3 (). After updating the scoreboard mask, a determination is made about whether the scoreboard and the scoreboard mask indicate that the entire command is received. Performing bitwise \u201cOR\u201d operation on the scoreboard and the scoreboard mask yields a scoreboard check result of \u201cff_ffff_ffff\u201d as shown in Step , column 4 (). The value of \u201cff_ffff_ffff\u201d means that all bits are set. Accordingly, a kick is issued. In one or more embodiments of the invention, issuing the kick means that the command is received on the host channel adapter and ready to process on the non-blocking pipeline.","Returning to , upon determining that all bits in PCB j () are set, the collect buffer controller () adds an identifier of PCB j () to the virtual kick list (). At this stage, the command is ready for processing on the non-blocking pipeline (). Specifically, when the command becomes the highest priority command in the virtual kick list(s) () (e.g., by being the oldest, etc.), the command is processed. Processing the command includes generating packets based on the received command data and transmitting the packets on the Infiniband\u00ae network () via the Infiniband\u00ae ports ().","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 1-4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 5-10"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 11A-11B"}]},"DETDESC":[{},{}]}
