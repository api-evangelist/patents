---
title: Pluggable component interface
abstract: A system, method, and computer program product are provided for initiating an application in communication with a database management system via a bridge. Application memory is allocated to the application from a shared memory space within the database management system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08490105&OS=08490105&RS=08490105
owner: Sybase, Inc.
number: 08490105
owner_city: Dublin
owner_country: US
publication_date: 20090817
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention relates generally to data services and, more specifically, coupling third-party software to a data services package.","2. Description of the Background Art","Sybase Adaptive Server Enterprise (\u201cASE\u201d) is a high-performance relational database management system (\u201cRDBMS\u201d) used by a diverse set of clients for an equally diverse set of applications. Database products in general are found in use in many settings, and therefore must adapt to each particular database administrator's needs.","Various competing database products have afforded end-users some level of customization of the product by implementing a number of software features which several prominent end-users may request. For example, Sybase has previously demonstrated the ability to integrate the Java Virtual Machine (\u201cJVM\u201d) into ASE in order to run high-level object oriented code from within ASE. Such a feature is desirable to a number of clients. However, further maintenance of ASE with integrated JVM would require maintenance not only of ASE, but also of the various integrated components.","The task of maintaining not only the primary database software, but also each of the tightly-integrated parts, would be daunting. It would likely require a dedicated team for the purpose of porting the component to be integrated, such as JVM, and to maintain that component. Such maintenance would involve not only ensuring future compatibility with the revisions to the ASE core components, but also applying bug fixes and other updates to the JVM itself.","Moreover, it is possible to abandon certain integrated components once they become obsolete. However, even such deprecated functionality often remains through several iterations of a software product in order to ensure that end-users have an opportunity to rewrite their applications accordingly, without forcing the end-users to remain on an unsupported version of the software. This causes the database software footprint to grow from both new features as well as the obsolete features.","Enabling third party integration with ASE presents several problems itself. If the third party software contains bugs or signals error messages to the ASE, the software's erratic behavior could affect the performance of the ASE software. Moreover, providing the typical hooks for integration with a software package like ASE may expose security breaches within the ASE software which third party application developers could exploit. Additionally, function calls made to the third party applications may require a long wait time for a response, blocking ASE and hanging or delaying critical processes.","Integrating third party software with ASE also presents legal issues. Licensing issues with the third party software might prevent integration with ASE, or may have terms for integration which cannot be met based on the functional character of ASE.","Accordingly, what is desired is a database system which provides component integration without requiring a high level of core integration support, while at the same time defending against issues that arise from integration with third party applications.","Embodiments of the invention include a system comprising a database management system and a bridge tightly-integrated with the database management system, wherein the bridge is configured to initiate an application in communication with the database management system via the bridge and allocate application memory to the application from a shared memory space within the database management system.","Further embodiments of the invention include a method comprising initiating an application in communication with a database management system via a bridge and allocating application memory to the application from a shared memory space within the database management system.","Further embodiments of the invention include a computer-readable medium having stored thereon computer-executable instructions that, if executed by a computing device, cause the computing device to perform a method comprising initiating an application in communication with a database management system via a bridge and allocating application memory to the application from a shared memory space within the database management system.","Further embodiments of the invention include a method comprising receiving a function call from a task, translating the function call to a function pointer, allocating a native thread, wherein the native thread is provided with the function pointer and wherein the native thread is configured to execute the function located at the function pointer, receiving the result from the function, and providing the result to the task as a return value to the function call.","Further embodiments of the invention include a computer-readable medium having stored thereon computer-executable instructions that, if executed by a computing device, cause the computing device to perform a method comprising receiving a function call from a task, translating the function call to a function pointer, allocating a native thread, wherein the native thread is provided with the function pointer and wherein the native thread is configured to execute the function located at the function pointer, receiving the result from the function, and providing the result to the task as a return value to the function call.","Further embodiments of the invention include a system comprising a memory storing a first module configured to receive a function call from a task, a second module configured to translate the function call to a function pointer, a third module configured to allocate a native thread, wherein the native thread is provided with the function pointer and wherein the native thread is configured to execute the function located at the function pointer, a fourth module configured to receive the result from the function, and a fifth module configured to provide the result to the task as a return value to the function call, and one or more processors configured to process the modules.","Further embodiments of the invention include a method comprising receiving a function call from a task, translating the function call to a function pointer, wherein the function pointer points to an application function within an application, and wherein the function call and the application are associated with a same slot identifier, requesting that the application be bootstrapped and configured in a manner which will enable the application to provide a result to the function call, allocating a native thread, the native thread configured to call the application function using the function pointer, receiving the result from the function, and providing the result to the task.","Further embodiments of the invention include a computer-readable medium having stored thereon computer-executable instructions that, if executed by a computing device, cause the computing device to perform a method comprising receiving a function call from a task, translating the function call to a function pointer, wherein the function pointer points to an application function within an application, and wherein the function call and the application are associated with a same slot identifier, requesting that the application be bootstrapped and configured in a manner which will enable the application to provide a result to the function call, allocating a native thread, the native thread configured to call the application function using the function pointer, receiving the result from the function, and providing the result to the task.","Further embodiments of the invention include a system comprising a memory storing a first module configured to receive a function call from a task, a second module configured to translate the function call to a function pointer, wherein the function pointer points to an application function within an application, and wherein the function call and the application are associated with a same slot identifier, a third module configured to request that the application be bootstrapped and configured in a manner which will enable the application to provide a result to the function call, a fourth module configured to allocate a native thread, the native thread configured to call the application function using the function pointer, a fifth module configured to receive the result from the function, and a sixth module configured to provide the result to the task, and one or more processors configured to process the modules.","Further features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein.","The present invention will now be described with reference to the accompanying drawings. In the drawings, generally, like reference numbers indicate identical or functionally similar elements. Additionally, generally, the left-most digit(s) of a reference number identifies the drawing in which the reference number first appears.","I. Introduction","The following detailed description of the present invention refers to the accompanying drawings that illustrate exemplary embodiments consistent with this invention. Other embodiments are possible, and modifications can be made to the embodiments within the spirit and scope of the invention. Therefore, the detailed description is not meant to limit the invention. Rather, the scope of the invention is defined by the appended claims.","It would be apparent to one of skill in the art that the present invention, as described below, can be implemented in many different embodiments of software, hardware, firmware, and\/or the entities illustrated in the figures. Any actual software code with the specialized control of hardware to implement the present invention is not limiting of the present invention. Thus, the operational behavior of the present invention will be described with the understanding that modifications and variations of the embodiments are possible, given the level of detail presented herein.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","b":["100","102","106","106","104","102"],"i":["a","c "]},"Rather than incorporating applications -(generally \u201capplications \u201d) into a monolithic executable for RDBMS , the applications  are able to plug in to the RDBMS  while remaining sandboxed from other applications , direct accesses to the operating system, and the RDBMS  itself, in accordance with an embodiment of the present invention. Moreover, the applications  can be treated as black boxes, enabling them to plug in to RDBMS  regardless of their particular program internals. In accordance with an embodiment of the present invention, the bridge  can remove an application  from the system in the event of an error or other threat to the integrity of the RDBMS .","The conceptual framework of architectural model  is termed a Pluggable Component Interface (\u201cPCI\u201d). The bridge  is therefore sometimes termed the PCI Bridge.","As an example of the types of applications  which can be integrated in the manner shown in , a simple HTTP server within the RDBMS  could be provided to enable configuration and monitoring services using a web browser as a front end. Traditionally, such functionality would have had to be built in to the monolithic RDBMS  executable. Using the architecture model , however, it is possible to incorporate many third-party applications, as well as first-party components, as an application  coupled over bridge  without requiring any modification to the monolithic RDBMS  code itself.","One skilled in the relevant arts will appreciate that the types of applications  which can be integrated as in  is varied and limitless. Another example would be to embed scripting support within the RDBMS  by providing a script interpreter as a plug-in application . Support for general programming language integration is possible as well. Even traditionally fixed assets within the RDBMS  can be migrated to PCI applications to improve development processes.","The PCI Bridge  provides a number of facilities for the integration of applications . One skilled in the relevant arts will appreciate that not all of the following mechanisms are necessary to implement architectural model , and are provided by way of example, and not limitation. PCI Bridge  is able to provide management of native operating system threads and processes in an embodiment. PCI Bridge  is further able to provide for memory management in a further embodiment. In additional embodiments, PCI Bridge  is able to provide synchronization management, data access service support, configuration management, function dispatching on demand with automatic plug-in loading, specific signal wrappers and exception handling, platform run-time support, dynamic instrumentation facility, and a dedicated error log channel towards the RDBMS log mechanism. These features are discussed in further detail below.","II. Integrating Applications with RDBMS",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2","b":["200","106","102","106","104","102","102","202","106","102","204"]},"By providing transparent API , an application  continues using default platform memory allocation functions, such as, for example, malloc( ), calloc( ), free( ), or realloc( ). It is not necessary to rewrite application , and the RDBMS  will then intercept these memory allocation functions (or, indeed, any functions) and service the function itself. Servicing the function within RDBMS  may ultimately involve a call to the actual operating system function, or other function, which the application  intended to call, but this is not strictly necessary. For example, application  may request to open a file using a standard operating system call, and may have actual permission to do so based on operating system permissions. However, RDBMS  can intercept this function, and perhaps deny the open file request based on its own requirements.","By way of example, and not limitation, memory allocation (e.g., malloc calls) normally made by an application  directly to operating system  are instead made to a memory allocation function provided by API , which serves to intercept the function call. RDBMS  then allocates memory for the application's use. In accordance with an embodiment of the present invention, RDBMS  allocates memory from a PCI memory pool used for that purpose.","In accordance with an embodiment of the present invention, the integration between PCI bridge  and RDBMS  is tight, and does not require a network stack for communications. In accordance with a further embodiment of the present invention, PCI Bridge  is part of the same monolithic executable as RDBMS , and is maintained concurrently therewith. In the embodiment depicted in , the RDBMS , PCI Bridge , and API  are part of the same monolithic executable.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":["300","106","200","302","304","306","106","102","106"]},"At step , a call is initiated from the RDBMS  to the application . By way of example, and not limitation, a call to the application  is embedded within a query being executed by RDBMS . For example, application  may be a script parsing engine, such that a script may be embedded within a query made to RDBMS . RDMBS  can parse the script by initiating a call to parse the script at step .","Once the application  has completed its processing, it stores the result in a shared memory space at step . One skilled in the relevant arts will appreciate that RDBMS  can request a result from application  and wait for the result to be returned to it. However, the best mode of operation is to allow the application  to compute the result asynchronously from the RDBMS , thereby preventing the application  from blocking the RDBMS . Accordingly, the application  computes the result and stores it in a shared memory space . At step , the application then notifies the RDBMS  that the result is ready.","At step , the RDBMS  receives the result from the shared memory space. In accordance with an embodiment of the present invention, the result is retrieved from the shared memory space by the PCI Bridge and provided to the RDBMS  as a return result to the call from step . The method ends at step .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 4","FIG. 3","FIG. 2"],"b":["400","300","200"]},"As previously noted, PCI Bridge  is tightly integrated with RDBMS , in accordance with an embodiment of the present invention. Accordingly, one skilled in the relevant arts will appreciate that communications to and from each of the PCI Bridge  or RDBMS  may be directed to or from a component other than the one it is shown to be associated with, depending on the particular implementation.","At step , PCI Bridge  requests the initialization of application . Application  then requests a memory allocation at step , and the allocated memory space is provided at step . At this point, application  is fully initialized and ready to accept calls.","At step , RDBMS  calls a function within application , as in step  of . At step , application  requires a resource from operating system , and initiates a call to an API function within RDBMS  to provide the resource. RDBMS  essentially provides an API which wraps the operating system resource requests, and then passes the function calls at step  to the operating system, to which the operating system  provides a reply at step . In accordance with an embodiment of the present invention, RDBMS  is able to handle the API function call  without requesting resources from the operating system . Regardless of the methodology by which RDBMS  allocates the requested resources, a reply to the original API function call is provided at step .","Once application  has completed its processing, it provides a result to the function call  in a shared memory location. Application  then notifies RDBMS  that the result is ready at step . RDBMS  is then able to receive the result from the shared memory via a function return value, for example, without being blocked while waiting for the result.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 5","b":["500","106","104","102","102","106"]},"First party applications or third party applications developed specifically for the purpose of integrating with RDBMS  in this manner are able to utilize function calls directly into PCI Bridge  and RDBMS  to substitute for resource control calls to the operating system. For example, a first party application or a specially-developed third party application can use a memory allocation function provided by RDBMS  for its memory allocation uses, and would be designed not to rely on the operating system's memory allocation calls.","However, many third-party applications can be integrated without modifying the underlying application  by wrapping the application  with an adaptor layer . The adaptor  translates calls made by the application  to the operating system into functions handled by RDBMS , and provides the calls thereto. This is useful in, for example, integrating a Java Virtual Machine without the need to modify the underlying source code. It is then possible to maintain included application  in an updated state by modifying only the wrapper  to conform to any code changes. This shortens the upgrade cycle for applications  integrated with RDBMS  when compared to coding the application  into the monolithic RDBMS  executable.","As previously noted in flowchart  of , applications  provide results to the RDBMS  in an asynchronous manner, in accordance with an embodiment of the present invention. Applications  store the requested result in a shared memory space, and then notify the RDBMS  that the data in the shared memory space is valid and is ready to be retrieved.","III. Asynchronous Function Execution",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 6","b":["600","102","604","605","102","102"]},"Tasks  can be developed, in accordance with an embodiment of the present invention, to make a function call to be serviced by an application . However, when the task  makes such a function call, the RDBMS  runs the risk of being stalled while the application  executes and provides an answer to the function call. The framework  enables tasks  to send this function request to an application  without stalling RBDMS .","Moreover, it is useful to fully isolate the execution context between the RDBMS  and the application  in order to prevent execution errors within application  from affecting the performance of RDBMS .","Fully isolated execution context between RDBMS  and application  is accomplished by providing cells , in accordance with an embodiment of the present invention. A cell  is assigned for a particular PCI slot ID, and is shared between the application  (and its native threads ) and the requesting task . It is this shared memory space where an application  is able to write any results for task  to retrieve asynchronously, in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 7","b":["700","702","704","604","706","104","606"]},"In accordance with an embodiment of the present invention, PCI bridge  maintains a set of spare native threads  which are ready to be assigned when a function call is received from a task . These native threads  may be placed by the PCI bridge  in a wait state, or they may return to a main loop while awaiting instructions. One skilled in the relevant arts will appreciate that other techniques exist for placing a native thread  in an idle condition when no function call is present.","At step , the PCI bridge  allocates a cell memory , in accordance with an embodiment of the present invention. This cell memory is a shared memory location that is accessible to the task  and the native thread , in accordance with a further embodiment of the present invention. One skilled in the relevant arts will appreciate that the precise location of the cell memory , whether within the PCI bridge or elsewhere may vary with implementation details, and the cell memory  is shown within the PCI bridge by way of example, and not limitation. By allocating the cell memory , the PCI bridge establishes a relationship between the task  making the function call, and one or more native threads .","Now that the task  has made a function call, which has been sent to the PCI bridge, the task  must wait for the result. In accordance with an embodiment of the present invention, PCI bridge  is able to notify scheduler  that task  is blocked and should not be scheduled. This enables scheduler  to pull the task  from the scheduling rotation. In doing so, other tasks , as well as the RDBMS , are free to continue execution while task  awaits a result to the function call. Rather than scheduling task  for several processing timeslices during which it would be blocked, scheduler  can devote the processing time to other processor consumers with greater need.","With the ASE task  blocked, the newly-allocated or awoken native thread  retrieves the function from cell memory . In accordance with an embodiment of the present invention, native thread  is a generic component configured to retrieve a function pointer from cell memory  upon being allocated or awoken. Native thread  then runs whatever function is pointed to by the function pointer at step , and is not required to know any specifics regarding the function. As PCI bridge  is responsible for managing the slot locations of various applications , it is the PCI bridge which knows how to properly configure the pointer location for any function call made by a task .","The function referred to in the above paragraph can be located in many different places within any number of memory spaces. By way of example, and not limitation, the function may be a direct call to a function provided by the underlying operating system. In a further example, the function may be a call directly to an application . In an additional example, the function may be a call to a PCA  wrapping an application . One skilled in the relevant arts will recognize that the pointer may point to any location containing one or more instructions for the native thread  to execute, and the aforementioned locations are presented by way of example, and not limitation.","After the native thread  has called the function and the function has produced a result, the result is stored in the shared memory location, i.e. cell , at step . With the result ready, it is now possible for task  to retrieve the result from cell . At step , PCI bridge  instructs scheduler  to schedule task  in its normal rotation to ensure that task  is eventually serviced. In accordance with an embodiment of the present invention, scheduler  schedules task  with a high priority to compensate for the time during which the task  was removed from the scheduling rotation.","When task  is unblocked, it proceeds to receive the result from cell  at step . In accordance with an embodiment of the present invention, task  receives the result as a return value to the function call of step . The method ends at step .","By removing the task  from the scheduling rotation while it is blocked and awaiting a reply to the function call, and only putting the task  back in the scheduling rotation when the reply to the function call is ready, a truly asynchronous function execution methodology is available.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 8","b":["800","800","700","800"]},"An ASE task , during the course of its operation, makes a function call which must be serviced by an application . This function call is sent at step  to PCI bridge , in accordance with an embodiment of the present invention.","PCI bridge then wakes up native thread  at step . As previously noted, native thread  may be among several idle native threads kept in reserve. In accordance with an embodiment of the invention, if no spare native threads are available, an additional native thread is spawned for this purpose.","Native thread  is configured to, upon being awoken, created, or otherwise allocated, request a pointer for the called function from the cell memory at step . In accordance with an embodiment of the present invention, the PCI bridge  translates the function call from ASE task  to a particular application  or PCA  function. This is handled by assigning the application  or PCA  to a slot number within PCI bridge .","At step , native thread  receives a pointer to the function, which it then proceeds to call at step . As noted above, this is commonly a call into application  or PCA , but may also point to any other set of instructions such as, by way of example and not limitation, native functions provided by the operating system.","Once the function has completed its execution, the result is sent back to the PCI bridge at step  for storage within cell . If a PCA wrapper  is used to wrap application , the PCA wrapper  is configured to understand where to locate the cell  within PCI bridge . One skilled in the relevant arts will appreciate that other methods for storing the result of the function call into the cell memory exist, and this particular method is presented by way of example, and not limitation.","With ASE task  unblocked, the task then requests the result  from the cell  within PCI bridge , and the result is provided to the ASE task  at step .",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 9","b":["900","604","902","604","104"]},"At step , the PCI bridge  notifies the ASE scheduler  that task  is being blocked by the function call. ASE scheduler then blocks task  at step , removing it from the scheduling order.","PCI bridge  then initiates the usual function call to the application  through the use of native thread , as shown at steps , , , , and  of , in accordance with an embodiment of the present invention.","With the result stored in the cell , PCI bridge  notifies the ASE scheduler  to re-schedule ASE task  at step . At step , ASE scheduler  adds ASE task  to the scheduling rotation at a high priority, in accordance with an embodiment of the present invention. As ASE task  is no longer blocked while waiting for the result of the function call, it can then immediately receive the result provided to it at step . In accordance with an embodiment of the present invention, ASE task  receives the result as a return value to the function call .","IV. On-Demand Function Execution","An additional disadvantage of integrating applications  into the monolithic RDBMS  executable is the memory footprint required for the additional code. End-users of the RDBMS  software may demand the integration of certain functionality, such as the Java Virtual Machine, in order to meet their needs. However, such integration runs the risk of alienating end-users who do not need such functionality and would prefer that the RDBMS  software remain lightweight and more focused in its purpose. Maintaining various development builds of the RDBMS , to include or not include the additional applications , presents its own difficulties in terms of development complexity.","By providing on-demand function execution, it is possible to package applications  with RDBMS  to meet the demands of end-users who request the applications , without increasing the memory footprint of RDBMS  for end-users who do not need the applications . This is accomplished by packaging the applications  for integration via the framework  of , in accordance with an embodiment of the present invention. Then, only when an end-user demands data from the applications  are the applications  loaded.","The method by which this is performed is shown in flowchart  of . The method begins at step  and proceeds to step  where the RDBMS task (e.g., ASE task ) issues a function call to an application . At step , a determination is made whether the application is presently initialized. If yes, the method proceeds to step , but if not, the method proceeds to step  where the application is initialized, and to step  where memory is allocated to the application, in accordance with an embodiment of the present invention.","At step , a PCI slot ID is assigned to the application, in accordance with an embodiment of the present invention. Every application is bound to its own PCI slot ID number for facilitating communications between the PCI Bridge  (designated as slot #, in accordance with an embodiment of the present invention) at the application .","Once the application has been fully initialized, the application is ready to process the function call from step . The application  provides a result at step  within a shared memory space (e.g., cell ). The RDBMS task receives the result at step . In accordance with an embodiment of the present invention, the PCI reads the result from the shared memory space and provides it to the RDBMS task as a return value for the function call of step . The method ends at step .","As is noted from steps - of , the initialization process is only typically necessary once per application . Therefore there is no additional cost to an end-user that will frequently utilize the application , as the application  is initialized upon first usage. However, there is a significant benefit to end-users who do not intend to use application , as the processing cycles and memory footprint usage associated with initializing the application  are never incurred in this case.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 11","b":["1102","604","104","104","1104","502","106","106"]},"PCA  launches the application  at step . In accordance with an embodiment of the present invention, PCA  is tailored to the particular application  in order to properly configure the application  to work with the PCI system. By way of example, and not limitation, PCA  is configured to instruct the application  of the location of the shared memory space (e.g., cell ) to which the result of its execution should be written. This configuration step is shown as occurring at step . One skilled in the relevant arts will recognize that such configuration may be performed at initialization, as well as at additional points in time, such as when a function call is received by PCA .","As before, PCI bridge  allocates a native thread  at step , either by waking up an existing spare native thread  or initializing a new native thread , in accordance with an embodiment of the present invention. Native thread  requests the function pointer at step , and receives it at step . The native thread  then calls the function based on the associated slot number at step .","In accordance with an embodiment of the present invention, application  returns the result at step  to the PCA , which then sends the result to the PCI bridge  at step  for storage at cell . As before, once ASE task  is reactivated and scheduled, the result from cell  is provided to it at step . In accordance with an embodiment of the present invention, the result is provided to ASE task by PCI bridge  by reading the result from cell  and providing the result as the return value for the function call of step .","V. Example Computer System Implementation","Various aspects of the present invention can be implemented by software, firmware, hardware, or a combination thereof.  illustrates an example computer system  in which the present invention, or portions thereof, can be implemented as computer-readable code. For example, the methods illustrated by flowcharts  of ,  of , and  of , as well as the methods illustrated by communication flow diagrams  of ,  of , and  of , can be implemented in system . Various embodiments of the invention are described in terms of this example computer system . After reading this description, it will become apparent to a person skilled in the relevant art how to implement the invention using other computer systems and\/or computer architectures.","Computer system  includes one or more processors, such as processor . Processor  can be a special purpose or a general purpose processor. Processor  is connected to a communication infrastructure  (for example, a bus or network).","Computer system  also includes a main memory , preferably random access memory (RAM), and may also include a secondary memory . Secondary memory  may include, for example, a hard disk drive , a removable storage drive , and\/or a memory stick. Removable storage drive  may comprise a floppy disk drive, a magnetic tape drive, an optical disk drive, a flash memory, or the like. The removable storage drive  reads from and\/or writes to a removable storage unit  in a well known manner. Removable storage unit  may comprise a floppy disk, magnetic tape, optical disk, etc. which is read by and written to by removable storage drive . As will be appreciated by persons skilled in the relevant art(s), removable storage unit  includes a computer usable storage medium having stored therein computer software and\/or data.","In alternative implementations, secondary memory  may include other similar means for allowing computer programs or other instructions to be loaded into computer system . Such means may include, for example, a removable storage unit  and an interface . Examples of such means may include a program cartridge and cartridge interface (such as that found in video game devices), a removable memory chip (such as an EPROM, or PROM) and associated socket, and other removable storage units  and interfaces  which allow software and data to be transferred from the removable storage unit  to computer system .","Computer system  may also include a communications interface . Communications interface  allows software and data to be transferred between computer system  and external devices. Communications interface  may include a modem, a network interface (such as an Ethernet card), a communications port, a PCMCIA slot and card, or the like. Software and data transferred via communications interface  are in the form of signals which may be electronic, electromagnetic, optical, or other signals capable of being received by communications interface . These signals are provided to communications interface  via a communications path . Communications path  carries signals and may be implemented using wire or cable, fiber optics, a phone line, a cellular phone link, an RF link or other communications channels.","In this document, the terms \u201ccomputer program medium\u201d and \u201ccomputer usable medium\u201d are used to generally refer to media such as removable storage unit , removable storage unit , and a hard disk installed in hard disk drive . Signals carried over communications path  can also embody the logic described herein. Computer program medium and computer usable medium can also refer to memories, such as main memory  and secondary memory , which can be memory semiconductors (e.g. DRAMs, etc.). These computer program products are means for providing software to computer system .","Computer programs (also called computer control logic) are stored in main memory  and\/or secondary memory . Computer programs may also be received via communications interface . Such computer programs, when executed, enable computer system  to implement the present invention as discussed herein. In particular, the computer programs, when executed, enable processor  to implement the processes of the present invention, such as the steps in the methods illustrated by flowcharts  of ,  of , and  of , as well as the methods illustrated by communication flow diagrams  of ,  of , and  of , discussed above. Accordingly, such computer programs represent controllers of the computer system . Where the invention is implemented using software, the software may be stored in a computer program product and loaded into computer system  using removable storage drive , interface , hard drive  or communications interface .","The invention is also directed to computer program products comprising software stored on any computer useable medium. Such software, when executed in one or more data processing device, causes a data processing device(s) to operate as described herein. Embodiments of the invention employ any computer useable or readable medium, known now or in the future. Examples of computer useable mediums include, but are not limited to, primary storage devices (e.g., any type of random access memory), secondary storage devices (e.g., hard drives, floppy disks, CD ROMS, ZIP disks, tapes, magnetic storage devices, optical storage devices, MEMS, nanotechnological storage device, etc.), and communication mediums (e.g., wired and wireless communications networks, local area networks, wide area networks, intranets, etc.).","VI. Conclusion","While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example only, and not limitation. It will be understood by those skilled in the relevant art(s) that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined in the appended claims. It should be understood that the invention is not limited to these examples. The invention is applicable to any elements operating as described herein. Accordingly, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated herein and form a part of the specification, illustrate embodiments of the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the relevant art to make and use the invention.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 4","FIG. 3","FIG. 2"],"b":["300","200"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7","b":"700"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
