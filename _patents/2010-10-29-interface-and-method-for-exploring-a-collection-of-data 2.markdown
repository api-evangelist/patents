---
title: Interface and method for exploring a collection of data
abstract: An interface is provided for permitting a user to explore a collection of data. The data collection provides nodes as structural elements, and references which are assigned to nodes and hold identifiers of other nodes. Multiple references can be assigned to each node, thus guiding a user of the system to multiple other nodes, and multiple references can hold the same address, so that multiple nodes can have references pointing to the same node. The interface allows visualizing the network created by the interconnection of the nodes on a display region. The interface also allows the user to intuitively navigate along the references in both directions of the references, so that the user can explore which nodes are referenced by a certain node, and also by which nodes a certain node is referenced. Electronic documents can be assigned to each node, and the interface allows these documents to be displayed either directly in a reserved display region of the interface, or by launching a matching application on the user's computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09600603&OS=09600603&RS=09600603
owner: Xbranch, LLC
number: 09600603
owner_city: Plano
owner_country: US
publication_date: 20101029
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","General Features of the Interface and Internal Data Structure","Full Text Search","Documents Assigned to a Node","SQL Queries Assigned to Nodes","Integrity of Information","Server Concept","Exploring HTML Documents","Further Data Collections","Performing a Search","Displaying the Results of a Search as Nodes","Extended Search Options","Alternate Views for Displaying Parent Nodes","Transparent Parent Nodes","Referencing Extended Information","Specialized Screens","Externally Prompting the Display of Nodes"],"p":["This application is a continuation of U.S. application Ser. No. 11\/474,259, filed Jun. 26, 2006, which is a continuation of U.S. application Ser. No. 10\/864,603, filed Jun. 10, 2004, which is a continuation-in-part of U.S. application Ser. No. 10\/408,195, filed Apr. 8, 2003, each of which is incorporated herein by reference in its entirety.","The present invention relates to an interface and a method allowing a user to intuitively explore and navigate within a collection of data. The invention is particularly suited for use with computer programs.","Over the last decades, the way information is stored and managed has dramatically changed. For centuries, information was stored in physical libraries. Librarians administered the inventory, and only few people had access. Nowadays, the increasing use of electronic storage systems makes it easy and cheap to store all kind of information. Huge databases hold millions of documents. Depending on the operating efficiency of the database server, any desired document can be made available within fractions of a second. Furthermore, the computer systems connected to the Internet provide a steadily growing number of documents. A new problem has arisen, and that is finding the desired information.","On computers, documents are typically stored in a file system. A file system can be organized in folders, each folder having further subfolders, if desired. Such a hierarchical organization can be visualized using tools like for instance the Windows\u00ae Explorer (produced and distributed as part of the operating system Windows by Microsoft Corp., Seattle, Wash., USA). This software has a graphical user interface (GUI) that is often referred to as a tree structure, allowing the user to expand or collapse branches and sub-branches, the branches reflecting the folder structure. Although the folder and sub-folder structure allows storing documents in a structured manner, it is often difficult to decide which would be the appropriate location for a document. As a consequence, a lot of time is often spent searching for documents stored on a hard disk of a computer.","Database systems often allow to tack additional information to the documents, like search terms. Also, assigning documents to predefined classes is common. However, there is always a compromise to be made. Limiting the number of classifications or search terms helps to maintain a certain degree of lucidity, but restricts the user in adding references. Providing greater freedom in entering search terms and classifications quickly ends up in a counterproductive tangle.","In the Internet, so called hyperlinks are widely used. A hyperlink contains the address of another document. If the user \u201cfollows\u201d the hyperlink, the document located at the respective address can be accessed, However, it can still be a tedious exercise to find what one is searching for. One major reason is that the hyperlinks are not managed. A link may point from one document to any given other document, but at the target document, there is no information available about all the links that are pointing to this document. Especially, when the document is close to what the user is actually looking for, it would be desirable to know about all the hyperlinks pointing to that document and follow them \u201cbackwards\u201d in order to find a document that either contains the desired information or has hyperlinks pointing to other matching documents.","But there is no such possibility. The only option to walk the way backwards that led to such a document is by using the capability of most Internet browsers of storing the addresses of the documents accessed within one session. So the \u201cBack\u201d button of the Internet browser can guide the user back to the document from where the link pointed to the recent document, not because such information is stored in the documents, but only because the browser remembers previous addresses.","Documents in a database are often administered in a hierarchical manner. Such hierarchical structures are typically visualized by using a tree structure. Such a tree structure shows a number of items, and each item may have an arbitrary number of sub-items. Several interrelated items will typically be grouped under a superordinate item. While the tree structure appropriately depicts the hierarchy of items, such a structure has other limitations: Each item has only one \u201cparent\u201d item, in other words only one link is pointing to each item. Due to this, only one path leads to a document. If the creator of the structure had a different understanding of a logical configuration than any given user, then that user may never find a desired piece of information.","A requirement managing tool named DOORS\u00ae (produced and distributed by Telelogic AB, Malmo, Sweden) allows organizing documents in a hierarchical manner. The hierarchy is visualized in a tree structure (similar to the Windows Explorer). Additionally, links can be generated pointing from an item to any other item. However, the link structure cannot be viewed in a lucid manner, and navigating along the links is a tedious exercise. Only one level of links can be viewed at a time. In other words, for each item only the links pointing directly to the item and pointing away from the item are displayed. Especially, when links have led to a fruitless location, reverting to a more promising junction is not supported. This type of navigation is very similar to exploring the content of a computer hard disk by using old DOS versions, where on each directory level, the DIR command would list the subdirectories, and one had to change to one of the subdirectories to be able to find out more about further subdirectories by again using the DIR command. This mode of navigation significantly lacks the efficiency and convenience provided for instance by a tree view display.","Relational databases allow creating a complex data structure, where tables or certain kind of data entries are referring to other tables or data entries in order to project a complex structure into a database. But such structure is predefined to contain information in a certain structure. The links are part of a predefined structure, not part of the information itself. Therefore it requires the skill-set of a database architect to build and maintain such complex database systems.","The exploding amount of information related to a certain subject tends to dilute the understanding of such subject. Even more, for a comprehensive understanding of a subject it is required to communicate the inherent structure between information items. It is not sufficient to list or summarize the information items itself. But such an inherent structure is often too complex to simply being projected to either one hierarchical tree or an anarchistic deployment of unilateral links. The thesis can be made that in a complex structure, a significant part of the information itself is contained in the structure or network of the information items.","A typical prior art visualization mode of items being interrelated by pointers is shown in . Although only 12 items are present and the number of pointers is only 16, the representation of the network is already confusing. If a data collection having thousands of items is presented to the user in this manner, it is a hard task to locate an item holding the information the user is looking for.","Accordingly, a need remains for an interface and a method allowing a user to intuitively explore a complex collection of data, and to navigate within the collection using references pointing from data items to other data items.","A primary objective of the present invention is to provide an interface and a method, preferably embodied by a program executed on a computer, said interface allowing the user to intuitively explore a collection of data. Such a collection must consist of data items and references, the data items being interrelated with each other by references. Data items are discrete pieces of information. The interface makes use of the references to allow the user to comfortably navigate from a given data item to other related items.","References are pointing from one data item to another data item. The invention is most useful when being utilized on a data collection where the references are forming a network of interrelations between the data items. In such an environment, the data items can be regarded as a network of nodes being interrelated by pointers or references. For this reason, the term \u201cnodes\u201d is used in this disclosure when referring to data items of a data collection. A node can for instance be a row in a database table, or a term in a list of terms, for instance being delimited by semicolons. An electronic data file like an HTML document is also regarded as a node within the scope of this invention. Such a node may primarily serve as a label, or it can contain further information. It can have further data like an electronic document assigned to it, or it may only hold references to other nodes.","In a preferred embodiment, each node has a descriptive name. This name can for instance be stored in a field of a database table, or it can be defined as part of the information contained in the node. With HTML documents, the title as defined in the title tag could serve as a name. The data or documents that may be assigned to a node will be electronic files in a preferred embodiment. Identification of those documents can be achieved by storing the names in a field of a database table, or it can be merged into the other information contained in a node. In HTML documents, link tags are referencing external documents.","Documents can be text documents, images, video clips or any other kind of electronically storable data. However, a node could also hold a description of the location of a physical document like a CD or a book. In a fully computerized data collection, the documents would be available in electronic format. Once the user has selected a node, the interface would allow him\/her to directly view the assigned document on the computer monitor, assuming respective access rights.","In a database system, information nodes would typically be numbered, each node carrying a unique identifier, The numbering does not have to be known or visible to the user. A reference in its simplest form consists only of two identifiers: The identifier of the node being the starting point of the reference, and the identifier of the node where the reference is pointing to.","References being assigned to a first node and pointing to a second node are referred to as \u201coutgoing\u201d references with respect to the first node and \u201cincoming\u201d references with respect to the second node. In a file system on a computer, an entry defining a subdirectory is regarded as an outgoing reference with respect to the parent directory and an incoming reference with respect to the subdirectory. In more general terms, an \u201cincoming\u201d reference with respect to a particular node is a reference that holds that node's identification. In case of a particular HTML document, an incoming reference is a link specifying the file name and, if applicable, the location of that particular document. If the document holding the link is also an HTML document, and both documents are located within one file system, the location may be defined as a relative location. If both documents are located in the same directory, only the filename is required.","The user interface according to the principles of this invention will present references pointing from any given node to other nodes in an intuitive graphical manner. Furthermore, the user interface allows the user to display not only the references pointing away from a given node to other nodes, but also all the references pointing to a given node from other nodes. Preferably, the user interface allows switching between both presentation modes in order to maintain good overview. For outgoing references, in a preferred embodiment the common tree view, as for instance used in the Windows Explorer, will be adequate, showing the nodes where the outgoing references of a certain node are pointing to as so called \u201cchild nodes\u201d of the respective node. Child nodes are typically displayed one level below the respective node and with a certain indentation to the right. To visualize a plurality of incoming references to a certain node, a modified tree view will be implemented, allowing to assign as many \u201cparent\u201d nodes to any given node as incoming references are present. In one possible implementation, the user could select a particular node and then switch to a \u201cShow Uplinks\u201d mode, \u201cShow Uplinks\u201d being synonymous to \u201cShow Incoming References\u201d. Then, the display would group all nodes having references pointing to the selected node above the selected node, with a certain indentation to the left, these nodes thus being displayed as \u201cparent\u201d nodes. In this view mode, each parent node can be expanded again, thus displaying all nodes that have references pointing to that parent node. In this way, the user can quickly obtain a comprehensive overview from which areas references are pointing to a particular node.","In another implementation, references can be filtered. It would be possible to assign references to pre-defined categories or user groups, and a subset of references could be visible for a special user group only. Furthermore, references may also be assigned to the creator. In this way, each user can set private references, not visible to other users.","In yet another implementation, the interface according to the principles of the present invention would be used to explore a collection of data where the data items (or nodes) are distributed over several data collections, each collection being identified with a unique identifier. Since each information node and each reference can carry its own unique identifier, there is no risk of confounding different items in different systems. In such a network, references could point to a node in another data collection by appending the data collection identifier to the node identifier. Navigation along such a reference structure being spread over several information management systems would best be supported by a centralized server, the server having knowledge of the location of each affiliated data collection. In this way, when following a reference to another data collection, the request would automatically be directed first to the server, and the server would forward the request to the appropriate data collection. This concept is similar to the domain name servers (DNS) in the Internet: When a user enters the name of a Web site, those servers forward the request to the physical address of the computer hosting the respective site.","In a preferred environment, the electronic documents assigned to nodes are stored in a file system on a computer that prevents direct access by the users and thus does not allow bypassing the interface as described in this disclosure.","A data collection to be explored using the interface according to the principles of this invention incorporates two basic components: Nodes and references. Additionally, supplementary documents can be handled. The term \u201cnode\u201d, as used in the claims, is interpreted to mean a discrete piece of information, distinguishable from other pieces of information. The nodes of the data collection are associated with each other by references and may serve two purposes. Firstly, they can be a structural element, which means that a node has at least one reference pointing to the node, and at least one reference pointing away to another node. Secondly, they can hold additional information other that the name of the node. Thirdly, they can have one or more documents assigned. The information itself may be partially stored in the node, and partially in the document, or it can completely reside in the node or completely reside in the assigned document(s).","References are helping the user seeking for information to find respective documents or respective nodes. Although the term \u201clink\u201d is commonly used and understood, the term \u201creference\u201d describes the nature of those pointers more precisely and is therefore generally used in this disclosure. A reference is a directional pointer between two nodes, since it can best be understood as pointing from a first node to a second node. The identification of the node where the reference is pointing to will typically be explicitly noted, while the identification of the node that the reference is assigned to can either be also explicitly noted, for instance in a field of a database table, or it can also be assigned to a node by being part of the information contained in the node. References can appear in a broad variety of representations and can be organized in many different manners. They could be stored in an electronic file like for instance so-called hyperlinks, as widely used in HTML documents. The address in this case is written in ASCII characters. A hyperlink contained in an HTML document is therefore assigned to the document where it is located, and the name and location of the document it is pointing at is explicitly noted as part of the link. The term \u201creference\u201d, as used in the claims, is interpreted to mean a piece of information which is assigned to a node and holds the identification of another node.","According to the meaning of the term \u201creference\u201d in this disclosure, the file system on a computer hard disk is also organized by references. While to the user a sub-folder or sub-directory in the file system appears to be simply arranged \u201cunder\u201d another folder, the file system internally provides a list for each folder, containing all files and sub-folders, and entries in the file allocation table (FAT) point to the actual location of the files and sub-folders on the hard disc. The way a file system is structured can therefore be regarded as a system of references. An entry defining a subdirectory is regarded as an outgoing reference with respect to the parent directory and an incoming reference with respect to the subdirectory. Another preferred method to manage references is storing them in a database table. A file card in a physical library, holding the shelf number of a book, could also be regarded as a reference. However, this invention is limited to a collection of electronic data and does not include physical references. A data collection to be explored by the interface described in this disclosure is therefore constituted by a plurality of nodes having interrelations defined by a plurality of references.","The interface provides one or more display regions to a user. At least one display region is used to visualize a structured view of the nodes and their interrelations. To allow for intuitive navigation from the user's perspective within the reference structure, each reference must have a direction. A reference that would simply state that it connects node A to node B would not be appropriate according to this invention. In one preferred embodiment, the interface is managing nodes stored in an electronic database system, more specifically on a SQL database. SQL is the abbreviation for \u201cStructured Query Language\u201d and describes a database where subsets of the data records that are stored within the database can be received by sending queries to the database, the query being assembled using the standardized terms and syntax of SQL. A SQL database holds record sets in tables. Each table may consist of several columns or fields. While the term \u201ccolumn\u201d may be more illustrative when looking at a graphical representation of a table, the term \u201cfield\u201d is typically used in SQL documentation and also in data structures reflecting results of SQL queries (\u201crecordsets\u201d), and is also used in this disclosure. In order to structure the data, certain fields of any given table may have relationships to fields of other tables.","To implement the basic functionality required for an interface according to the principles of this invention, two tables are required: One table holding the nodes, another one holding the references. A rudimentary implementation of a library system is used to demonstrate the capabilities of such a structure in conjunction with the interface. The entries in the exemplary data collection are reduced to a bare minimum for the sake of perspicuity.  show two tables. Table \u201cNodes\u201d in  holds twelve rows, each row reflecting a node. The first field  (\u201cID\u201d) holds the identifier of the node. In , the identifiers are normal numbers. In a preferred embodiment, unique numbers will be used for each item. Today's database systems like Microsoft\u00ae Access provide a special number format named GUID or Replication ID. GUID is the abbreviation for \u201cGlobally Unique Identifier\u201d. GUIDs may for instance be generated by using the current date and time, the ID of the network adapter of a computer and a random number, making sure that the same GUID will never be generated again at any time on any computer. If the database provides GUID as number format, the GUID of each record can be created automatically by the database system when the record is created. GUIDs are typically 128-bit numbers. If visualized in hexadecimal format, they still consist of 32 characters, and are not very easy to grasp for a human. For this reason, all figures representing database tables in this specification will show normal numbers instead of GUIDs, although GUIDs are a preferred implementation for identifiers in this invention. Furthermore, numbers below 100 have been chosen as identifiers for table \u201cNodes\u201d, and numbers above 100 and below 1000 have been chosen as identifiers for table \u201cReferences\u201d, in order to improve legibility.","The second field  (\u201cName\u201d) holds the text that is displayed to the user on a display region of the interface for each node. The third field  (\u201cDocument\u201d) holds the name of the electronic document assigned to the node. Depending on the specific implementation, the entries in the third field may additionally carry the file extension (like .doc, .jpeg), or a further field is reserved for the extension, in case the filename is a GUID.","Table \u201cReferences\u201d in  holds sixteen rows, each row reflecting a reference. The first field \u201cID\u201d  holds the identifier of the reference. The number format of this field would preferably also be GUID, but for the sake of comprehensibility, normal numbers are used in . This applies also to the two following fields. Field \u201cOriginNodeID\u201d  references the origin of the reference, while field \u201cTargetNodeID\u201d  references the node where the reference is pointing to.","The first row in table \u201cNodes\u201d holds the so-called root node with ID # (all identifiers are arbitrary). This node is a structural node and serves as origin for high level nodes, that typically will also serve as structural nodes and will have no documents assigned. The first two rows in table \u201cReferences\u201d are referencing this node (value I in field \u201cOriginNodeID\u201d). The first reference is pointing to the node with ID #, named \u201cAuthors\u201d, the second one points to node #, named \u201cCategories\u201d. From node #, two references are pointing to two further nodes: # named \u201cHemingway\u201d and # named \u201cGoldstein\u201d. From node #, three references are pointing to three further nodes: # named \u201cThe Old Man and the Sea\u201d, # named \u201cThe Sun Also Rises\u201d and # named \u201cCat in the Rain\u201d. In the same manner, all other references are pointing from one node to another.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 3"},"The topmost node  is named \u201cRoot\u201d and reflects the node with ID # in table \u201cNodes\u201d. Below that node, as child nodes having an indentation to the right, two nodes  and  are arranged: \u201cAuthors\u201d and \u201cCategories\u201d, according to the two entries with IDs # and # in table \u201cNodes\u201d, which are assigned to Node ID # by references # and # in table \u201cReferences\u201d. The collapse symbols  (\u201cminus\u201d sign) left of the nodes indicate that the branch is expanded, which means that all sub-items are displayed. If a branch is collapsed (not expanded), an expand symbol (\u201cplus\u201d sign) would appear, indicating that sub-items are present. A so-called \u201cleaf node\u201d, that has no outgoing references, would have no sign at the left. A common way to expand or collapse branches in tree views is to click at the plus respectively minus sign.","Below node \u201cAuthors\u201d, two child nodes  and  are located: \u201cHemingway\u201d and \u201cGoldstein\u201d, reflecting entries # and # in table \u201cNodes\u201d. Below node \u201cHemingway\u201d, three child nodes ,  and  are arranged, named \u201cThe Old Man and the Sea\u201d, \u201cThe Sun Also Rises\u201d and \u201cCat in the Rain\u201d, reflecting nodes #, # and #, structured by references #, # and #. All other nodes in the tree can be derived from the database tables in the same manner. In this way, the tree structure reflects the information nodes in table \u201cNodes\u201d and the references in table \u201cReferences\u201d.","An interesting aspect is shown by node  \u201cThe Old Man and the Sea\u201d as a child-node of node  \u201cNovels\u201d. Node  is stored in table \u201cNodes\u201d with ID #. The reference with ID # points from the node with ID # (which is \u201cNovels\u201d) to the node with ID # (which is \u201cThe Old Man and the Sea\u201d). So both nodes  and  in  are reflecting the same node in table \u201cNodes\u201d with ID #. This is also true for node , being a child-node of \u201cOutdoors & Nature\u201d, ID # in table \u201cNodes\u201d. Nodes ,  and  do not just have the same name (like two different files in a computer file system could have the same names as long as they are located in different folders), but instead they reference exactly the same node in the database. The document # attached to that node would typically hold the text or an abstract of \u201cThe Old Man and the Sea\u201d. In a similar manner, node  (\u201cThe sun also rises\u201d) is identical to node , node  (\u201cCat in the rain\u201d) is identical to node , and node  (\u201cOffshore Fishing\u201d) is identical to node .","There are several ways for a potential user to locate with the help of the interface for instance the document assigned to \u201cThe Old Man and the Sea\u201d. When the interface described in this disclosure is activated, only two child-nodes would typically be displayed as shown in : Node  \u201cAuthors\u201d and node  \u201cCategories\u201d. Note that instead of collapse symbols, expand symbols  are displayed, since both nodes allow for expansion, but are not yet expanded. If the user knows the author, he or she will expand node  and then expand node  \u201cHemingway\u201d, the tree then looking like . If the user does not know the author, he or she will expand node  \u201cCategories\u201d. There, according to , the main categories \u201cNovels\u201d and \u201cShort Stories\u201d are listed, but additionally the high-level classification \u201cOutdoors & Nature\u201d (node ) is present. Obviously, many more classifications would typically exist here. In this case, Hemingway's \u201cThe Old Man and the Sea\u201d is located under \u201cNovels\u201d as well as under \u201cOutdoors & Nature\u201d (see ). Many more useful sub categories having various references to the various books in the library could be set up.","Another great benefit is the possibility to follow the references in the other direction. Assuming, a user has located Hemingway's \u201cThe Old Man and the Sea\u201d as shown in , but he\/she is looking not exactly for this item, but something similar.\n\n","After node  is selected, the \u201cShow Uplink\u201d feature is activated. In a preferred embodiment, this is done by locating the mouse pointer over the selected item and clicking the right mouse button. A small window  will appear, holding several menu items (a so-called pop-up menu), see . One menu item states \u201cShow Uplinks\u201d. If the user clicks at this menu item, the window will disappear, and now all nodes that have references pointing to the selected node are displayed as parent nodes as shown in . This portion of the tree is named \u201cup-branch\u201d in this disclosure, while the originally selected node is called \u201ccenter-element\u201d and the portion of the tree below the center-element (if present) \u201cdown-branch\u201d. The main attribute of a typical center-element is that it has an up-branch structure above it and a down-branch structure below. Node  in  however is a leaf node and therefore has no down-branch below. As discussed later, a tree view can have multiple center-elements, each center-element joining an up-branch portion and a down-branch portion.","To point up that the up-branch is visualizing incoming references, a specific arrangement mode for the nodes different from the arrangement of a down-branch is used. In a preferred embodiment, the arrangement of the tree elements (expand\/collapse symbols, nodes) of the up-branch is mirrored. The elements are aligned to the right border of the tree view instead of the left border as usual, and also the expand\/collapse symbols are located at the right side of the nodes. In this way, it is apparent to the user that this portion of the tree above a particular node displays all the nodes that are pointing to that node (incoming references), which is substantially different to the common visualization mode of a tree view which can only show outgoing references (below a particular node all the nodes are displayed where that node is pointing to).  shows a center element having an up-branch above and a down-branch below and demonstrates that both arrangement modes can well be combined within one tree view.","After having executed the \u201cShow Uplinks\u201d function on node , the user has several options. One option is to find out which nodes are pointing to \u201cHemingway\u201d. A click on the plus sign next to node  would expand this node and additionally show node  \u201cAuthors\u201d (). If the user wants to look for other works by Hemingway instead, node  is to be selected. Then the \u201cShow Downlinks\u201d function can be activated (). \u201cShow Downlinks\u201d is synonymous to \u201cshow outgoing references\u201d. Now, basing on the references that point from node \u201cHemingway\u201d to other nodes, these nodes are displayed as child-nodes of node  as shown in .","Another option instead of looking for works by Hemingway would be to select node  \u201cOutdoors & Nature\u201d in the configuration shown in  and to activate the \u201cShow Downlinks\u201d functionality. This would lead to a display as shown in . In this situation, the user might find node  \u201cOffshore Fishing . . . \u201d worthwhile to evaluate. By selecting this node, activating \u201cShow Uplinks\u201d and expanding all parent nodes, a tree view as shown in  would be presented to the user. So it becomes obvious even from this limited example that basing on the concept of references and the associated display concept according to the invention, each node offers a variety references to other useful pieces of information.","In a preferred embodiment, the database would be implemented as SQL server. A computer executing a program would embody the interface, the program being able to access the database. Another preferred embodiment is to run a remote server handling a database and providing a Web interface. Such a Web interface can be implemented using HTML and\/or ASP technologies, and can be operated by a user with a standard Internet browser. It would also be possible to provide an ActiveX\u00ae (trademark of Microsoft Corporation) control embedded in a WEB page. Microsoft's .NET technology provides various options like ASP.NET to develop interactive Web based applications. The present invention is not pertaining to a specific underlying technology.","A preferred development tool to create an interface that would be embodied in a program running on a local computer is Visual Basic\u00ae (produced and distributed by Microsoft Corp., Seattle, Wash., USA). This programming environment comprises components for convenient database access as well as many other useful components for a graphic user interface. However, other embodiments can successfully be created in many other development environments.","To display the data in a tree view as described above, the respective data has to be received from the database by the interface. This is done by generating SQL queries. The examples noted in this disclosure are using the \u201cdialect\u201d of Microsoft Access. To obtain root node , its ID must be known. The options to achieve this include but are not limited to defining the ID as a constant in the database or storing it in a separate table. The ID being 1 in our example, an appropriate SQL query to obtain the root node would be:\n\n",{"@attributes":{"id":"p-0077","num":"0078"},"figref":"FIG. 15","b":["24","25","26","27","28","29","30","31"]},"Element  \u201cLevel\u201d stores the number of the respective hierarchical level. The root node receives 0 at the beginning. Each node being entered as a child-node under a certain node receives the level of the parent-node +1. Accordingly, in the up-branch portion of the tree, each new node being inserted as a parent node of a certain node receives the level of the child-node \u22121. The absolute number of the levels is not relevant, just the relative values.","Reading the root node into the data structure would create the first element of the array as displayed in : The values of elements ,  and  are taken directly from the recordset returned by the SQL query. Element  receives a \u22121, since the root entry has no parent node. The portion of the tree reflected in this node is the down-branch by default, since the root element does not have any node above itself; accordingly element  receives a \u201cD\u201d. Element  receives \u22121, since no reference is pointing to the root node. The value of element  is taken from a further SQL query as explained below. Element  \u201cLevel\u201d receives value 0.","When data of a certain node is obtained from the database, in a preferred embodiment the interface is automatically looking for references pointing away from that node respectively towards that node. This is done because the display of the node needs to be equipped with an expand symbol in case continuative references exist.","To obtain references pointing away from a node, the following SQL command can be used:\n\n","If the user now desires to expand that node, the child-nodes have to be obtained and entered. An appropriate SQL query to be used in a preferred embodiment is: (SQL3) \u201cSELECT Nodes_1.ID, Nodes_1.Name, Nodes_1.Document, References.ID FROM (Nodes INNER JOIN References ON Nodes.ID=References.OriginNodeID) INNER JOIN Nodes AS Nodes_1 ON Referenees.TargetNodeID=Nodes_1.ID WHERE OriginNodeID=<Node_ID>\u201d\n\n","Further expansion of Node  \u201cCategories\u201d (equivalent to element with index (2) in the internal data structure) would require to run (SQL3) again, with <Node_ID> being substituted by 8. Three records are returned:\n\n","and  shows how the data are entered into the internal data array.","If the \u201cShow Uplinks\u201d function is activated, new parent-nodes can for instance be obtained by the following SQL query:\n\n","An adequate query looking for references pointing to newly entered nodes in the up-branch would be:\n\n","The internal data structure reflecting the configuration of  is shown in . The main purpose of the internal data structure is that it easily allows \u201cpainting\u201d the tree view. If for instance Visual Basic is used as programming environment, a PictureBox can be placed on the GUI of the interface, and one by one each element of the internal data structure is written to the PictureBox. Text is written by using the \u201cPrint\u201d command (for instance \u201cpctTree.Print uTreeRep(0).Name\u201d), and lines are drawn using the \u201cLine\u201d command (for instance \u201cpctTree.Line (x1, y1)\u2212(x1, y2)\u201d). The vertical arrangement of the elements is preferably done on a line-by-line basis, while the horizontal arrangement is derived by using the \u201cLevel\u201d element of the data structure in order to calculate the appropriate indent. Connecting lines between the boxes framing the text can also be drawn, as shown in the respective figures, and the expand\/collapse symbols can either be drawn line by line, or they can be copied from an existing bitmap resource.","If the user clicks at the tree view respectively at the PictureBox, the mouse coordinates are made available to the program, and it can easily be calculated if the user has clicked at an expand\/collapse symbol or a node. So a mouse click can lead to expanding\/collapsing branches or to select a node. When expanding a branch, the new elements have to be obtained by sending an adequate SQL query (like SQL3 or SQL4) to the database. The new elements have to be inserted into the internal data structure below the node to be expanded, and the following respectively previous (in case of the up-branch portion) elements have to be shifted accordingly. Doing this, the values of element  \u201cRef_Ix\u201d have to be adjusted if applicable since they may refer to a portion of the data array that has been shifted. When collapsing a branch, the simplest solution is to delete the respective elements from the data array. This can be achieved easily by making use of the \u201cLevel\u201d element: All entries below (respectively above in case of the up-branch) the selected node are deleted until a \u201cLevel\u201d value is reached that is equal or smaller (respectively greater in ease of the up-branch) than the level assigned to the selected node. Again, the values in \u201cRef_Ix\u201d may have to be adjusted accordingly.","If a click with the right mouse button is performed, also this becomes known to the program, and a respective pop up menu can be displayed. All this is strongly supported by Visual Basic. For somebody skilled in the art of programming and with some basic knowledge of SQL databases, no problem will be presented in creating an interface representing this invention. Some diligence is required if the interface is used in a multi-user environment. The programmer has to be aware that elements displayed on the computer monitor of one user may be deleted by another user shortly afterwards. Accordingly, when sending SQL queries to the database, appropriate error handling is required. Additionally, it may be useful to run a verification routine triggered by a timer for instance every 30 seconds over the internal data structure and detect if the current tree view reflects the latest state of the database.","Also, other useful features may be implemented. Since nodes can show up multiple times within one tree view, it would be helpful to the user that each time he\/she selects a node, a program routine scans the internal data structure for duplicates of this node, and highlights these duplicates in the tree view.","Furthermore, it is desirable that the user can add new nodes, delete existing nodes, change the name of existing nodes, create new references and delete existing references in a convenient manner by operating the mouse within the tree view. This can be greatly supported by pop-up menus as already explained in the context of selecting the \u201cShow Uplink\u201d and \u201cShow Downlink\u201d functionality. Adding new nodes is performed by creating new entries in the database (in the \u201cNodes\u201d table as well as in the \u201cReferences\u201d table) basing on the currently selected node that serves as a parent node for the new element. Preferably, the entry in table \u201cNodes\u201d is performed first, since only the new ID number (respectively GUID) is known. Afterwards, the insertion into the internal data structure and the creation of an appropriate entry in table \u201cReferences\u201d can be executed. Deletion of existing nodes is performed by deleting the respective record from table \u201cReferences\u201d. SQL database allow defining joins between tables that allow for automatic deletion of all elements in a joined table that are referencing an element to be deleted (\u201ccascade delete\u201d). Using this functionality, all respective references in table \u201cReferences\u201d would be deleted automatically. The relation between the records in table \u201cNodes\u201d and the currently selected node is done by using element  \u201cNode_ID\u201d of the internal data structure, which holds the ID of the respective record. This is the case for all SQL queries.","It would certainly be helpful, if the look-and-feel of operating the tree view was similar to the tree views commonly used in many other programs. Changing the name of a node can be performed best using the so-called \u201cSlow Double-Click\u201d functionality known from other tree views: If the user selects a node and clicks at the same node again after for instance 2 seconds, the text becomes editable. The new name would then be entered into table \u201cNodes\u201d. Adding new references could be performed by \u201cdrag-and-drop\u201d. A drag-and-drop operation is performed by the user by clicking onto a symbol on the GUI (in this case a node being displayed in the tree view) with the help of a mouse or another pointing device (touch pads etc.) and dragging the symbol to another location on the GUI by operating the pointing device. During this drag operation, the mouse pointer typically changes its shape. When the symbol is dropped by releasing the pointing device, the drag-and-drop operation is completed, and depending on the context, the internal data being displayed on the GUI are changed accordingly. The term \u201cdrag-and-drop\u201d, as used in the claims, is interpreted to mean a user-driven operation on a GUI where a symbolic representation of data is selected, then moved across the GUI and placed at another location. Visual Basic strongly supports drag-and-drop operations by providing methods like \u201cOLEDrag\u201d and \u201cOLEStartDrag\u201d to start such an operation basing on mouse actions and by presenting events like \u201cOLEDragOver\u201d (for appropriately changing the style of the mouse pointer), and \u201cOLEDragDrop\u201d and \u201cOLECompleteDrag\u201d (for triggering the internal data changes).","A new entry in table \u201cReferences\u201d is created by using the mouse coordinates of the drag-and-drop operation. The ID of the node where the drag operation was started is temporarily stored in a variable. The node where the drop operation was performed serves as \u201cOriginNodeID\u201d. When the drag-and-drop operation is completed, the ID stored in the variable serves as \u201cTargetNodeID\u201d. An appropriate SQL command adds a new record to table \u201cReferences\u201d, using the IDs of the nodes where drag-start and drop were performed. Deleting existing references is performed preferably via pop-up menu. If the user decides to delete the reference from the selected node to the parent node, the value of element  \u201cRef_ID\u201d of the internal data array is used to achieve the ID of the reference in table \u201cReferences\u201d. Before performing a \u201cDelete Reference\u201d operation, the interface should seek for other references pointing to the selected node, and in case that no other references are found, the user should be warned that after deletion of the reference, the node itself will not be accessible any more since the reference to be deleted is the only one attaching the current node to all other nodes. After all operations changing the content of the internal data structure are processed, a redraw operation on the tree view has to be performed.","Many other useful features can be implemented. In a preferred embodiment, the order in which the child-nodes are arranged can be selected by the user. Assuming that in addition to the name of a node, the date when the node was created (or changed) and the name (or ID) of the creator is stored in table \u201cNodes\u201d, it is possible to order the elements accordingly as desired by the user. This SQL query would return child-nodes in the order of the creation date (it is assumed that this field is named \u201cDateCreated\u201d in the database table), the newest one being displayed at the top: (SQL6) \u201cSELECT Nodes_1.ID, Nodes_1.Name, Nodes_1.Document, References.ID FROM (Nodes INNER JOIN References ON Nodes.ID=References.TargetNodeID) INNER JOIN Nodes AS Nodes_1 ON References.OriginNodeID=Nodes 1.ID WHERE TargetNodeID=<NodeID> ORDER BY Nodes_1.DateCreated DESC\u201d.","Each time when the \u201cShow Uplinks\u201d respectively \u201cShow Downlinks\u201d functionality is performed, significant portions of the tree structure will disappear. If for instance node  \u201cCat in the Rain\u201d in  is selected and \u201cShow Uplinks\u201d is performed, all that remains is node  as center-element and two parent-nodes named \u201cShort Stories\u201d\n\n","Another aspect is how the nodes are to be arranged after a \u201cShow Uplinks\u201d or \u201cShow Downlinks\u201d action. In , node  \u201cCat in the Rain\u201d is for instance displayed in the 6th line. If either element is selected, and \u201cShow Uplinks\u201d is performed, only three lines remain. In a preferred embodiment, the center-element \u201cCat in the Rain\u201d would remain at its previous location, thus leaving a significant void area side at the left and the top (see ). However, this void space is well understandable to the user.","In order to reduce the size of the void area, another helpful feature is implemented in a preferred embodiment. Since the tree structure may become very large, the available display area on the GUI may not be large enough to show all elements of the tree. In this case, so-called slider controls are typically introduced.  shows an exemplary tree view having a vertical slider  and a horizontal slider .  shows the tree structure after having executed \u201cShow Uplinks\u201d for node  \u201cCat in the rain\u201d. Now, if the user drags the horizontal slider  to the right, this leads the tree view to be moved to the left. The visible void area to the left is thus decreased. Internally, the software also eliminates the invisible void area. Accordingly, the length of the slider increases, since the overall width of the tree area is reduced relatively to the visible area. Once the user has moved the tree completely to the left, there is no more void area on the left, neither visible nor invisible. Accordingly the length of the slider has been increased to the maximum, indicating that there exists no more hidden tree portion in horizontal direction. The same applies to the vertical arrangement. The result is shown in .","In yet another implementation, the number of center-elements is not limited. As shown in , nodes  (\u201cThe Sun also Rises\u201d) and  (\u201cCategories\u201d) are center-elements. Although serving as center-element, node  is not expandable to the bottom, since it is a leaf node (it has no references pointing to other nodes). Node  is not expanded to the top, but could be (it has node  \u201cRoot\u201d pointing to it).","From , it becomes obvious that the horizontal arrangement of the elements may become difficult when multiple center-elements are used, and the branches of the center-elements are expanded to a significant level or have long names. In yet another embodiment, two or more tree views are used. The left view, for instance, would represent the down-branch starting at the root node. The right view would show the up-branch of the node that is currently selected in the left view. In another implementation, the user would have to explicitly demand the right view to synchronize with the left view. It would also be possible to synchronize the left view with the right one: If the user selects any node on the right view, the left tree view could display the down-branch of that node. Accordingly, the display region of the interface displaying the structured view of the nodes and their interrelations can consist of more than one component. The arrangement of the components is not predetermined by this invention. Possible arrangements include but are not limited to horizontal arrangements, vertical arrangements and superposition.","If a new reference has to be created by a drag-and-drop action, and the tree structure is very large, so that the first node where the drag operation is to be started and the second node where the drop operation is to be performed are not both visible within the available display area at the same time, it is also helpful to have two tree structures. The drag-and-drop operation would be started at one tree view showing the first node, and be completed at the other tree view showing the second node.","In another preferred embodiment, a tree view can be temporarily separated into two views by using a splitter bar. This feature is well known from software like Microsoft Word and is very useful to independently orient two parts of the same tree in an appropriate manner to perform a drag-and-drop operation. Alternatively, two menu items could be added to the pop-up menu showing up when a node is right-clicked with the mouse. One menu item could for instance state \u201cStart link\u201d, the other one \u201cDrop link\u201d.","In another preferred embodiment of the present invention, a portion of the GUI would be reserved for temporarily placing a symbol being dragged. The drag-and-drop operation would be suspended by dragging the symbol onto the reserved space, the user can then scroll the tree view until the desired target area is displayed, and then would continue the drag-and-drop operation by clicking onto the symbol currently being placed at the holding area and dragging it over the target.  illustrates a holding area  below a tree view, and a symbol  currently being placed at this holding area by drag-and-drop. The big advantage of this functionality is that the user can always see which symbol is currently subject of a suspended drag-and-drop operation. Other solutions that are commonly used in tree views like selecting an item, copying the item into the clipboard and pasting it from the clipboard at the desired target have the great disadvantage that the user cannot, intuitively determine what is currently placed in the clipboard. If he\/she accidentally performs another copy-to-clipboard operation before pasting the originally desired item at the target, the last copied item will erroneously be pasted instead. Therefore, the functionality of a holding area as described above would be very useful for many other applications as well.","Within the scope of this disclosure, one possible implementation would work as follows: The user clicks at node and starts dragging the mouse. The MouseMove event is used to trigger the OLEStartDrag method, which stores the ID of the node being dragged in a variable. When the mouse cursor is dragged over the holding area and released, the OLEDragDrop event of the control representing the holding area (preferably another picture box) will be fired, and this event initiates a function that paints the node onto the holding area, preferably using the same mechanism as used for painting the nodes at the tree view. To illustrate that not an independent node is present, but rather a representation of a node belonging to the tree structure, an additional symbol may be added like the little curved arrow as shown in  at the lower left corner of the node. Now, the drag operation is suspended. The user can scroll the tree view, and expand or collapse branches. When the node representing the desired drop target is visible, the user clicks at the node representation located at the holding area and drags it onto the node representing the drop target. The beginning of the drag operation is handled in the same manner like described above for drag-and-drop operations within the tree, using the \u201cOLEStartDrag\u201d event of the picture box representing the holding area, and is completed by \u201cOLEDragDrop\u201d and \u201cOLECompleteDrag\u201d events of the tree view control. Since the ID of the node being subject of the operation was stored in a variable, the completion of the operation is done just as if the drag-and-drop operation had not been suspended.","More useful enhancements of the holding area can easily be created. It would for instance be possible to let the holding area serve as a container for multiple node representations. A user planning for instance to reference many nodes to a newly created node could locate the nodes one after another and drag them onto the holding area. After she\/he has collected all desired nodes, the newly created node has to be located, and a single drag-and-drop operation onto this node could assign all nodes being present in the holding area as sub-nodes of the new node. Instead of having a single variable for storing the ID of the node where the drag operation started, the program code requires to provide an array of GUID variables for multiple drag starts. When the drop operation has been performed, instead of creating one new record in table \u201cReferences\u201d, as many records as IDs are present in the array are created. It is obvious that this feature greatly improves the efficiency of operating the interface, and minimizes the risk of errors resulting from accidentally dropping a link onto an undesired target due to confusion from the user's side when maneuvering inside large tree structures.","In another preferred embodiment, another arrangement mode, being a derivative of a classical tree structure, is used. Assuming that a data collection holds information on movies, a possible implementation would be to have a node named after the respective movie, and for each movie have sub-nodes named \u201cActors\u201d, \u201cDirector\u201d, Story\u201d, \u201cBackground\u201d etc. Below the \u201cActors\u201d nodes, further sub-nodes would hold the names of the actors. If a user selects a node representing an actor, and executes the \u201cShow Uplinks\u201d functionality, many parent-nodes named \u201cActors\u201d will appear, depending on the number of movies where this actor had a role. The user will have to expand each \u201cActors\u201d node, in order to see the names of the movies. If a node has only one incoming reference (like each of the \u201cActors\u201d nodes), it would be helpful to display the parent-node of this node by default, and it could also be displayed in the same alignment as the child-node.  shows a possible implementation. This implementation makes obvious that a classical tree is only one option to display the interrelations of nodes. Other arrangement modes are also possible, and in order to enable the present invention, the only requirement for the GUI of the interface is that it can show references in both directions, and in more than one level of interrelations for each direction, providing appropriate arrangement modes for each direction. Preferably, the number of levels to be displayed is more than ten. The term \u201clevel of interrelations\u201d, as used in the claims, is interpreted to mean a step from one node to another node when following a reference. The possible arrangement modes in order to visualize these levels include but are not limited to a vertical arrangement with indentations like commonly used in tree structures or horizontal arrangements as demonstrated in . The term \u201clevel of interrelations\u201d as used in the claims emphasizes that the number of levels between two nodes, which is the number of steps taken when following references from one node to another node is not necessarily a fixed number. Since references can be created in an unrestricted manner, it would be possible to have a reference pointing from node A to node B, another reference pointing from node A to node C, and a third reference pointing from node B to node C. The number of levels between node A and C is therefore one, when following directly the reference from node A to node B, and is two when following the reference from node A to node B and from there to node C.","When the interface is launched, it is possible to have a default root node serving as a starting point as explained further above. This is, however, not necessary. Other mechanisms like search algorithms can be implemented allowing a user to define the starting point. Especially when exploring HTML documents, the arbitrary selection of a root node will be helpful. This will be discussed further below.","To anybody skilled in the art it will become obvious that the features of the GUI as discussed above are only exemplary. Many other useful implementations are possible.","Storing the nodes as records in a database allows for several useful functions in order to locate desired elements. Navigating along the references is one option. If the name or a part of the name of a node is known, then an SQL query can be run in order to receive all nodes that match the search term. If for instance the term \u201cold\u201d is to be part of the name, an appropriate query would be:\n\n","Another option is to search for nodes that have been created (or modified) within a certain time slot. This SQL query would return nodes that have been created between Aug. 7, 2002, and Sep. 1, 2002: (it is assumed that the respective field is named \u201cDateCreated\u201d in the database table):\n\n","A further option would be to look for nodes that have been created (or modified) by a certain person. This requires that the person that creates or modifies data is also noted in the recordset. Depending on the nature of data additionally present in the \u201cNodes\u201d table, many other search functions can be presented to the user. It is also possible to combine clauses. For instance it may be useful to look for nodes that have been modified by a certain person within a certain time slot.","One characteristic feature of an interface according to this invention is the possibility to view a document assigned to a node. Although the term \u201cdocument\u201d is widely used and understood for electronic data stored in files on a computer system, the more general term \u201cdata\u201d is used in the claims, since the interface does not require data to be present in a specific format, like a file on a computer system. Documents may include but are not limited to electronic files stored on a computer system, portions of such files, portions of a data stream and digital data received from a database.","There are several ways how the document may be defined internally. In a preferred environment, the electronic file has received a GUID as file name, and this GUID is stored in the record of the node as shown in . To avoid locating a huge number of documents in one folder on the file system of a hard disk, sub-folders can be used. The path of the sub-folder could then be stored in the \u201cNodes\u201d table. Sub-folders can also be created automatically by the interface if for instance a sub-folder for each month according to the day of creation of the respective node is created. The sub-folders could then be named like \u201c2003-05\u201d. Basing on the internal data of the creation date of the node, the interface could automatically assemble the path where the document is located. In a preferred embodiment, the normal users would have no direct access to the folders via the GUI of the operating system (for instance the Microsoft Windows Explorer), so they cannot unintentionally delete documents that are assigned to nodes.","The interface can offer several possibilities to the user to access the document that is assigned to a node. One solution would be to reserve a large portion of the interface's GUI for direct display of the document. If the interface is programmed in Visual Basic, a large textbox or a \u201cRichTextBox\u201d would be placed onto the main form as shown in . This control could display files holding text. To enable this, a variable would receive the document's name and path. Assuming that the documents are stored in sub-folders named according to the month of the node's creation date, and the creation date of each node is stored in a field named \u201cDateCreated\u201d, and the file extension is stored in a separate field named \u201cExt\u201d, an SQL query like this one could be run:\n\n","By running a further Visual Basic command like:\n\n","In a preferable embodiment, multiple controls being able to handle different file formats are part of the GUID. In order to not waste space, all controls are of the same size, and have the same location. Only the control that is able to load the assigned document is switched to \u201cvisible\u201d, all other controls are hidden. The appropriate selection can be made via a \u201cSelect Case\u201d switch in the interface software, making use of the \u201cExt\u201d field in table \u201cNodes\u201d.","If no appropriate control is available, it is also possible to open directly the application assigned to the respective file format by the operating system. In a Windows environment, the API function \u201cShellExecute\u201d can be used. In Visual","Basic, this can be implemented by declaring the API function in the following manner:\n\n","It depends on the specific implementation if the assigned document is automatically opened when the user clicks at a node, or if a specific action is requested from the user, which would be preferable if the files are located on a remote site with a low bandwidth connection.","Another kind of documents assigned to a node could be an SQL query. Since SQL queries are text strings, the document format is preferably be ASCII. A file extension like \u201cQRY\u201d could indicate that the file holds an SQL query. Depending on the specific implementation, the SQL query could be directed to the database of the current data collection, or it could also be directed to any other database, if the database is specified and accessible. One option would be to specify the database also in the document that holds the SQL query. To display the results of the query, a control like \u201cDBGrid\u201d can be used. This control is also delivered with the Visual Basic development environment. A DBGrid control can display recordsets in a flexible table format. It can be bound to a \u201cData\u201d control (also delivered with Visual Basic), and the data control can access databases by using only a few lines of code:\n\n","An interface being connected to an Information Management System as described in this disclosure may well be used as a requirement managing tool. System requirements can be entered, and when an implementation is designed, the elements of the function breakdown structure (FBS) are linked to the system requirements. Test cases are the linked to the FBS. A test case covering multiple PBS entries will have incoming references from each of these entries. In this way, documenting the verification and validation of a complex system can be performed with the help of the interface. In order to do so, it is essential that information items can only be changed by a well-defined group of users, depending on the state of development of the system. While during the design phase, all members of the design group may be allowed to add, modify and delete data in the FBS, this is not allowed any more when testing activities have started. This can be supported in many ways by the interface and the underlying data structure of a data collection. Assuming the data collection would be a database according to the previous descriptions, one option is to add fields to the \u201cNodes\u201d table and also to the \u201cReferences\u201d table that have joins to other tables holding user groups. Each user has to belong to at least one user group, and if a user attempts to modify data, the system runs a query to make sure that at least one group to which the user belongs has the rights to perform such changes. The same applies to adding new nodes as child-nodes or erasing nodes. Identification of users may be done by providing login screens as commonly used in many computer programs.","If the visibility of a document or a node is restricted to certain user groups, they would be hidden from other users. There are many possible implementations of access rights. A commonly used method is to embrace a number of users in a user's group. Each user receives an ID (numerical value, text string etc.), and each user group lists the IDs of its members. This kind of information can for instance also be stored in database tables. One table would list the names and IDs of the user groups; another table would list the IDs of the user groups in one field and the IDs of the members in another field. The creator or owner of a node or the assigned document can then select, one or more user groups that are allowed to view or edit his data. One possible implementation is to have a separate table in the database, holding the ID of the node in one field and the ID of a user group in another field. If more than one user group shall have the right to view or edit the node information, multiple records are added to the table. If the table would have an additional field defining the nature of access (read only, read-and-write etc.), then the owner could define certain groups that may only view a document, while other groups could also edit the document. If a node is to be expanded, an SQL query according to SQL3 would be directed to the database. Instead of displaying all nodes returned by the recordset, for each record of the recordset a new SQL query would be generated, returning all records in the table holding the IDs of the nodes and the IDs of user groups that would match the current Node ID. In yet another query, all members belonging to the respective user groups obtained by the previous query would be listed. In this way, a list of all users having permission to view and\/or edit the node is compiled. Then, the interface checks if the ID of the current user is part of this list. If not, the node will not be displayed or the assigned document will be hidden.","A useful option to track changes is to add two fields to each node and\/or reference, holding the date\/time (\u201ctimestamp\u201d) of the beginning and the end of the validity period of each record. If a new record is created, the beginning of the validity period is the date\/time of creation, and the end of the validity period could for instance be set to Dec. 31, 9999. If a user attempts to change data, a copy of the record is created. This copy receives the timestamp of the change as the end of validity, while the actual record receives the timestamp of the change as the beginning of validity. The end of the validity period remains unchanged. If the current view of the data collection is requested (which will typically be the case), the interface will equip all SQL queries with the WHEN clause: \u201c(AND) EndDate #9999-12-31#\u201d. If the status of the database on Jul. 1, 1999 at noon shall be displayed, all SQL queries have to be equipped with the WHEN clause: \u201c(AND) BeginDate <#1999-07-01 12:00:00# AND EndDate>#1999-07-01 12:00:00#\u201d.","Another important aspect is the integrity of the documents that are assigned to nodes. The database could store the ID of the creator (or the ID of a respective user group) in the Nodes table and also for instance fields holding flags stating if the document is ready to be published or still in work. The interface could be equipped with checkboxes indicating if a document is finished and\/or if it may already be viewed by users outside the person or group identified as owner. Changes of respective checkmarks would only be saved to the database if the creator of the node (or a member of the respective user group) has been identified as current user.","If a portion of a documentation system basing on this invention is to be baselined, all respective nodes and references would receive a flag that they cannot be altered or deleted any more by any user. The assigned documents could be converted into PDF documents (a file format provided by Adobe) and electronically signed.","The benefits of an interface being connected to a data collection as disclosed above can be greatly amplified by placing the database and also the assigned documents on servers that are accessible to many users. These servers could be connected to the Internet. Since a user would not necessarily know about the internet addresses of databases according to the invention, it would be possible to set up a central server that serves as a gateway. On this server, a database could be located that has no documents assigned to any of its nodes, but provides only a sophisticated structure of references where the leafs are pointing to nodes in other databases. Since all references are managed in databases, it can be assured that no \u201cdead references\u201d exist.","The central server could also be user for billing issues. Many internet services are restricted to subscribers. However, somebody looking for a certain article in a medical journal does not necessarily want to subscribe for a year. The publishing house of such a journal could assign each article in each issue to a node in the data collection. Parent node of each node could be a node that has the abstract assigned to it. Access to the \u201cabstract\u201d-nodes could be granted to everybody for free. If a user wants to have access to the full article, he would have to be a member of a specific user group. If the user is registered with his\/her credit card number at the central server, he\/she could be instantaneously placed onto such a user group after accepting a certain amount of money to be billed to their credit card. The great advantage of this concept is that the user needs to register only once at the central server. He\/she can define limits for monthly expenses, and would receive an invoice with all items listed. Depending on the frequency of using a certain provider, a user can still subscribe a service in order to get a better pricing. This concept has special benefits for non-commercial information providers. A doctor who wants to publish about a special subject could add his document to the database of a university he is cooperating with, and would let the central server know how much he wants to bill. The company running the central server would charge the credit card of the users looking at the document, and retain a certain percentage of the fee for its own benefit. Such a concept has great advantages over currently offered services like PubMed, where for normal users only the abstracts of articles are accessible, but there is often no convenient way to quickly get hold of the complete article.","While the interface as described in this disclosure is most useful when connected to a database, it can also handle a collection of HTML documents in the same efficient manner. In this case, the HTML files are serving as nodes. HTML files typically have a title defined as a title tag within the document. This title could for instance be displayed as caption of the respective node when a tree view is used. Since HTML documents have a well defined structure, a simple algorithm can parse the source text of such a document and look for sequences like \u201c<title>\u201d and \u201c<\/title>\u201d, which enclose the actual title of the document. In Visual Basic, the function InStr(StringToBeSearched, SearchTerm) returns the position of the first character of the search term within the string to be searched, which is the source text of the HTML file. If the length of the search term, for instance 7 in case of search term \u201c<title>\u201d, is added to this number, the first position of the title string is determined. The first position of the terminating string \u201c<\/title>\u201d tells the length of the title string. Using a Visual Basic command like\n\n","In HTML documents, the references are included within the document as so-called hyperlinks. A hyperlink pointing to the Patent's Main Page of the USPTO WEB site, would look like:\n\n","Hyperlinks can reference any kind of electronic file. In a preferred embodiment of this invention, hyperlinks to other HTML documents are serving as references according to the scope of this invention, while hyperlinks pointing to other file types are serving as links to assigned documents. The presence of hyperlinks is determined in the same manner as described above for the title string. In this case, the search term \u201c<a href=\u201d has to be used, the address of the link being enclosed in quotation marks. Parsing an HTML document in this manner, all references to other HTML documents (nodes) can be extracted.","If a tree structure is used as display element of the interface, and the user clicks at the \u201cExpand\u201d symbol of a node, the interface would extract the titles of all HTML documents referenced in that node, and display the titles as captions of the sub nodes. Generating a down-branch in this manner is simple. Generating an up-branch requires more efforts, since each HTML document contains only the outgoing references, but no incoming references. In order to generate up-branches, all documents within a collection of HTML files have to be parsed by the interface to extract references pointing to a certain HTML document. To avoid unsuitable delays, this parsing process will favorably not be performed each time an \u201cExpand\u201d symbol is clicked at the interface. In a preferred embodiment, this process will rather be performed frequently in the background, and the results will be stored in an appropriate data structure. This could be a temporary internal data structure of the interface program, or it could be an external database. In case many users are working on the same data collection, it would be preferable to have a stand-alone collection of references, for instance stored in a database, and an independent software process frequently scanning the collection of documents and updating the collection of references. The interface program would in this case not parse the HTML documents, but would connect to the reference collection. This process would be very similar to obtaining reference data from the \u201cReferences\u201d table as explained further above. Such a method could even be performed on HTML documents placed on computers connected to the Internet. The Internet search engine Google\u00ae (operated by Google\u00ae Inc., Mountain View, Calif., USA) for instance is continuously scanning HTML pages and other documents like PDF and DOC in the Internet and is analyzing the links in order to create a relevance value for each document visited by the search engine. Web pages that are referenced by many other pages are considered more relevant than pages that are scarcely referenced. A reference or a hyperlink on another Web page that is pointing to a specific document is an incoming link with respect to that document. If Google would store all detected references or hyperlinks in a database, the interface of the present invention could make use of this data collection and allow the user to navigate within HTML documents of interest. Since some Web pages have a high number of incoming links, the additional features of the interface like full text search will be of great value to the user.","As mentioned before, hyperlinks in HTML documents may also be pointing to documents like image files, video files, sound files etc. Also, PDF files are often used as a container for text and graphics. Additionally, an image file can be referenced in a manner that the image is to be displayed to the user embedded in the text. These files are defined by the inline image tag \u201c<IMG\u201d, followed by at least the \u201cSRC\u201d attribute stating the file name and location. In a preferred embodiment, the interface will provide a display region that shows the contents of an HTML document in a manner similar to typical browsers like Microsoft's Internet Explorer. In other words, the text elements and inline images will be displayed in a formatted manner. References to non-HTML files are regarded as references to assigned documents. If the interface is provided with controls that are able to handle the respective file format, the content of such a document can be displayed directly within a display region of the interface. Alternatively, the application registered for the respective file format by the operating system will be launched directly, or another application specified by the interface. This will also be the case if no control is present within the interface that can handle the respective file format.","It has been mentioned before that the interface requires having a node as a starting point in order to obtain incoming and outgoing references. This node can be a pre-defined node that is always used when the interface is launched. If a confined collection of HTML documents is to be explored, this will be adequate. When working on a very large collection, other methods of defining a starting point can be used. One option is the full-text-search explained further above. Another option would be to provide the interface with a classical file-open dialog. The user could then pick any desired file from the accessible file system. A further option is to pass the name of a file to the application when the interface is launched. Windows provides this possibility. If a user double-clicks at a file shown at the Windows Explorer, the operating system selects the application registered for the respective file type by analyzing the file extension, then launches that application and passes the name of the file to be opened to the application. In Visual Basic, the file name can be obtained by using the \u201cCommand\u201d function which returns the file name and path as provided by Windows. If for instance the program representing the interface would be registered by the operating system for extensions HTM and HTML, then the interface would launch automatically if a HTML file is double-clicked, and the respective file would be used as starting point for the structured view.","From the examples presented in this disclosure, it becomes obvious that the interface will be useful for exploring many different kinds of data collections. As an alternative or a supplement to a database, HTML documents are just one example of a data collection that is not organized in a database format. A file format named XML can be regarded as a hybrid. XML documents are ASCII text documents like HTML files, but they can be structured in a very stringent manner and are widely used to export, transfer and import data between databases. XML documents could also serve as a stand-alone data collection within the scope of this invention. It is also obvious, that the data collection being explored by the interface can be a combination of one or more databases and stand-alone documents like HTML files. Additionally, a plurality of nodes can be defined within one electronic document. For instance, a simple ASCII based format could be used where nodes and\/or references are listed in separate lines, the nature of each element being defined for instance by a tag at the beginning of the line. Many other implementations are also possible.","Another useful utilization of the present invention would be to display the relations between tables in a complex SQL database. While Microsoft Access for instance provides a graphical overview of the relations by displaying the tables with their fields and drawing lines connecting the fields having relations, this overview can quickly become confusing if a significant number of relations are present. It would be a simple task to interpret the fields of the tables as nodes, and the relations to other fields as references. A node representing a field that is referenced by another field would have an incoming link. For this and similar applications, it could be useful to introduce different types of references. Such references would not only have a direction, but would also belong to group of reference types. One type of references could for instance represent the assignment of a field to a table. Each table would then be present as a node, its child nodes representing the fields. Another type of references would represent the relations between fields. Since in SQL different types of relations are possible (1:1, 1:n, n:n) with different attributes (with or without referential integrity, cascade delete, cascade update), these characteristics could be represented by the reference type. This could be accomplished by adding another piece of information to the reference data. If the references are stored in a table in a database, like shown in , an additional field that could for instance be named \u201cType\u201d could be added. In the display region of the interface, the representation of the references could be displayed as different line types (dashed, dotted, varying thicknesses etc.), or the lines could receive permanent tags or labels, or little windows popping up when the mouse is hovering over a line (so-called \u201ctool tips\u201d) could show information about the type of a reference.","In section \u201cFull Text Search\u201d it has been explained how a search for specified characters in a node's name can be performed throughout all nodes or a subset of nodes in a collection of data. In section \u201cSQL Queries assigned to Nodes\u201d it has been explained how a pre-defined SQL query could be assigned to a node, and how the results of the query can be displayed in a table. Running an SQL query on a collection of data can also readily be understood as performing a search. In a more general understanding, a search means to identify objects that match a specified pattern.","The term \u201csearch\u201d, as used in the claims and in the specification, is therefore interpreted to mean obtaining a list of data elements and information related to those data elements, matching a specified pattern. Such a search pattern can be as simple as obtaining nodes where specific characters are contained in the node's name, or as complex as for instance obtaining nodes that are referenced by all nodes which have the characters \u201corder\u201d in their names and have been created between May 5, 2002 and May 4, 2003 by owner John Brown. Depending on the specific SQL query, additional fields in related tables may also be returned. Independently of the complexity of the search pattern, a list of nodes will be returned. This list can contain no entry in case no matching node was found at all, one node or many nodes. The term \u201csearch result\u201d, as used in the claims and in the specification, is therefore interpreted to mean a list of data elements matching a specified search pattern. There are various options of displaying the list to the user, for instance as a table where each row reflects one element of the search result and, if applicable, also related data from tables in a database.","If a search result comprises elements of a data collection that are at least partially referencing each other (\u201cnodes\u201d), and the matching elements are displayed in a table or another form of a list, only a portion of the information contained in the search result is disclosed to the user. He or she may see all the elements, but the relationship between the nodes is hidden, in other words the references pointing from one node within the search result to another node are not visible. It is therefore preferable if the search result is presented within a view that allows display of existing references between the nodes and navigating along these references.","Obviously, the same methods as describes in this application can be used for a search result. For instance, a tree view can be generated as described in section \u201cGeneral Features of the Interface and Internal Data Structure\u201d. Such a view can for instance be displayed in its own window or within the main window of the interface. Many different implementations of such a \u201cstructured search result view\u201d are possible. For instance, the node having the highest number of references pointing to or from other nodes within the search result could be placed prominently in the view, and the tree branches representing the references could already be expanded so that the other nodes that are also member of the search result are displayed. Nodes within the search result not having any references to other nodes within the search result would be placed as independent items in the view.","To further enhance the productivity of such a view, references leading to a node within the search result from other nodes that are not part of the search result could also be provided as well as references pointing from a node within the search result to other nodes \u201coutside\u201d of the search result. In this manner, a search result could be used as a powerful starting point for a thorough exploration of a collection of data.","It is also obvious that no root node (i.e. a node not being referenced by other nodes) is required if a search is used to identify one or more nodes as starting points for further exploration of a collection of data. Although a root node is shown in all the drawings of this specification, existence of a root node is not required.","The above described method for displaying a search result as a view visualizing data elements as well as the references pointing from one data element to another will also be beneficial to other applications that are not originally intended to display nodes and references of a data collection. The Internet search engine Google for instance displays search results in a list. Google currently weighs its search results anyway according to the number of references (or \u201clinks\u201d) pointing to a document. Therefore, if such a document would be displayed as a node with its references being visualized, navigating along the references would significantly enhance the capabilities of locating a desired piece of information in the Internet.","In yet another embodiment of the invention, the structured view of search results will not be displayed within an independent view designated for search results, but will be arranged within an existing view. If for instance a node within an existing view would have an SQL query assigned, as explained in section \u201cSQL Queries assigned to Nodes\u201d, the results of the query could be added as child nodes to the node. These nodes would therefore appear to be referenced by the node holding the query. Yet these relationships between those nodes would not be permanent, in other words these relationships would not be stored as references. Rather, they are generated \u201con the fly\u201d, which is during run-time of the interface. Accordingly, the nodes being displayed as child nodes would not permanently be the same nodes. If for instance an SQL query would be assigned to a node that obtains all orders that have been placed the day before, different nodes would be showing up under that node each day.","Generating temporary nodes in a tree view is easy. In a preferred embodiment, all nodes that are displayed have been obtained as result of an SQL query. The only difference would be that instead of running a query like (SQL2) which asks for references pointing from a certain node to other nodes, an arbitrary SQL query could be used. The records returned by that query would be entered as child nodes of that node in the same manner as nodes that are referenced by that node.","An interface designed to monitor orders and deliveries for instance would greatly benefit from such a display mode. If all orders to be delivered by the end of the day would be listed as child nodes of a node named \u201cToday's Deliveries\u201d, each delivery showing up under that node could have references to the items contained in that order as well as the recipient of the delivery and also to the shipper of the delivery. Instead of switching from one screen to another screen to yet another screen, all relevant information can be obtained by simply navigating through the tree. For the recipient, contact info could be displayed instantaneously by a VCF file assigned to the node. VCF is a file format holding personal information which is used for instance by Microsoft\u00ae Outlook\u00ae to maintain contacts. It is also possible to store e-mails in MSG files, a file format that is used by Outlook as well.","As described in the specification of the original application. (Ser. No. 10\/408,195), a search can be performed throughout all nodes or a subset of nodes in a collection of data. Section \u201cFull Text Search\u201d describes such a search in detail. As indicated, a search is not limited to text strings within the name of a node. Rather, searches for all other properties of nodes like creation date, owner etc. are possible.","However, it would also be a very useful option to search not within a node, but within documents assigned to nodes. This process is known for instance from the operating system Microsoft\u00ae Windows, where a search for a file can be performed basing on the filename or a portion thereof or for a word or a term to be found within the file itself. The second option may be rather time consuming depending on the number of files to be searched, but does not require any mammal attendance while the search is performed and is therefore in many cases a welcome feature.","Such a feature can be integrated into the user interface by presenting an entry field, where a text string can be input by the user. It could further be specified if the search is to be performed for all documents assigned to any node within the collection of data, or only documents that are assigned to the currently selected node, or subnodes of the currently selected node, which means nodes where a reference is pointing to from the currently selected node. It would also be possible to define over how many levels of sub nodes the search may be carried out.","When the search is started by the user, the plurality of documents would then automatically be opened one by one by a computer program. Many file formats like Microsoft\u00ae Word hold the text characters in a common binary format, where 1 byte (8 bit) encodes one character. The encoding is defined in the ASCII standard (ASCII standing for American Standard Code for Information Interchange\u201d). So any software can open a Word file and look for specified characters inside the file. If Visual Basic was used, the command line\n\n","If the nodes of the collection of data are represented by text documents like HTML files, in a preferred embodiment the user can also search for text strings within the document. The mechanisms used for the search can be the same as described above.","If a first node has a reference pointing to a second node, the first node is called \u201cparent node\u201d of the second node in this specification. The reference pointing from the first node to the second node is an \u201cincoming\u201d reference with respect to the second node and an \u201coutgoing\u201d reference with respect to the first node. Accordingly, the term \u201cincoming reference\u201d with respect to a given node, as used in this specification and the claims, is interpreted to mean a reference pointing to said given node from another node. The term \u201coutgoing reference\u201d with respect to a given node, as used in this specification and the claims, is interpreted to mean a reference pointing from said given node to another node.","In a preferred embodiment of this invention, a \u201cShow Uplinks\u201d mode is used in order to view nodes that have references pointing to a given node. In yet another preferred embodiment another display mode is provided. One implementation of such a view mode is shown in .",{"@attributes":{"id":"p-0152","num":"0189"},"figref":"FIG. 27","b":["50","55","56","51"]},"For displaying the collapsed status of the representation of incoming links, a different icon  is used in order to distinguish this icon from the icon  displaying the collapsed status of the child branch. The reason for this is that expanded branches are easily recognized as child or parent branches, while the icons for collapsed branches could be confused; therefore a certain degree of differentiation is desirable. However, the functionality of the implementation described herein is independent of the specific design of the icons. It is possible to use completely different icons for all four status representations, or to share icons for status representations. In yet another implementation, icons are not required at all. The tree structures of Windows XP explorer have the ability to present a node as a \u201chyperlink\u201d, and if the user clicks at the name of the node, the child branch expands. It would be possible to have an expanded child branch collapse when clicking again at the name of the node. Using the right mouse button instead of the left one could in a similar manner operate the parent branch, or mouse clicks in conjunction with keys pressed on the keyboard. In such an implementation, only an indication is required if a node has chills or outgoing references at all. Since the vast majority of nodes in a typical collection of data will have parent nodes, a specific indication for the existence of parent nodes may not be required. The preferred embodiment, however, uses icons to receive the same look and feel as classic tree structures in order to familiarize the user more easily with the interface.","In case only one icon should be present, this would either mean that no downlinks are present, or\u2014in case of a root node\u2014no uplinks are present. For the user, the distinction between these two conditions is apparent for instance by the icons.","In  nodes \u201cAuthors\u201d  and \u201cHemingway\u201d  are expanded downwards. Node \u201cThe Old Man and the Sea\u201d  for instance has just one icon  indicating that no child nodes are available.",{"@attributes":{"id":"p-0156","num":"0193"},"figref":["FIG. 28","FIG. 27","FIG. 27","FIG. 28","FIG. 9"],"b":["54","51","55","54"]},"If the user for instance would want to know which references to other nodes are held by node \u201cOutdoors.& Nature\u201d. (one of the parents of \u201cThe Old Man and the Sea\u201d), he or she simply needs to click at the \u201cplus\u201d icon next to node , and the expanded downlink shows that two nodes are referenced by this node, see .",{"@attributes":{"id":"p-0158","num":"0195"},"figref":"FIG. 29","b":["70","54","53","71"]},"Another advantage of the display mode as explained above is that the display of parent nodes and child nodes is not limited to one node, but can be performed for a plurality of nodes.  shows a configuration where parent nodes and child nodes are displayed in parallel for a plurality of nodes. For instance, both nodes \u201cHemingway\u201d  and \u201cOutdoors & Nature\u201d  have their child branch expanded, and both nodes \u201cThe Old Man and the Sea\u201d  and \u201cGoldstein\u201d  have their parent branch expanded.","An otherwise useful structure of references within a collection of data may cause the effect that several different parent nodes, all having the same name, will be displayed for certain nodes. For instance, a couple of nodes representing movies can be held in a collection of data, and each of said nodes has (amongst other sub nodes) a sub node named \u201cActors\u201d which is referencing the actors playing in the movie. If an actor has played a role in several movies, several parent nodes named \u201cActors\u201d would be displayed for this actor. It is obvious that the user would rather prefer to directly have the movies listed instead of seeing a couple of parent nodes named \u201cActors\u201d and having to expand each of those nodes in order to see the movies where the actor has played. It has been proposed as one option to automatically further expand the parent-nodes of such nodes. Another option is to suppress the display of certain nodes under certain conditions. It is obvious that each of the \u201cActor\u201d nodes for instance does not hold useful information in itself, but has the only purpose of holding references to other nodes, thus bundling these nodes in a specific context. Such a node could receive an attribute or a label specifying that the node will not be displayed at all in an up-branch, but be substituted directly by its parent. This \u201ctransparency\u201d would be allowed only for nodes having no more than one parent. Otherwise, the node would have to be displayed since an unambiguous substitution would not be possible. The attribute or label stating that the node should be substituted by its parent in a parent branch could for instance be defined in a specific field in a database table holding or referencing the nodes. The attribute could be presented to the user of the interface as a property of the node, for instance accessible via context menu. In child branches, however, each node must be displayed, no matter if such an attribute is set or not.","If more complex information is to be assigned to certain nodes within a collection of data, for instance the date when an order has been placed, the part number of an item that has been ordered, or the delivery date of such an item, one option would be to provide further fields in a table holding the nodes or referencing the nodes. However, a possible disadvantage of such an approach would be an increasing complexity of the table structure. If yet another set of nodes would for instance require additional information regarding technical drawings of certain items, the table holding the nodes or referencing the nodes would comprise a high number of additional fields, each field being utilized by only a relatively small number of nodes. Therefore, it would be desirable to provide several independent tables for different types of information. A table holding details of orders for instance would have only as many rows as nodes are present representing an order. Each row (or recordset) in this table would have one field referencing the ID of the respective node to which the information is assigned. If the user selects a node, the interface would search for the ID of that node throughout the tables holding extended information.","In order to avoid ambiguity, in another implementation of the invention the nodes could be limited to representing only one type of extended information. For instance, a node could receive an attribute defining it as an order. The interface would in this case search only the \u201corders\u201d table for the ID of that node, and would ignore all other tables holding extended information. Providing such an attribute for a node could be realized by having a designated field in the table holding or referencing the nodes, or by sharing another attribute field. Another alternative is to assign a document to a node that would define the type of information assigned to the node. Such a document could obviously also hold the extended information itself, thus eliminating the need of specialized tables. Depending on the specific implementation, it may be more desirable to store extended information in independent documents assigned to nodes, or in database tables where search and filter actions can be performed more efficiently.","If nodes carry extended information (like for instance order dates, part numbers and delivery dates), these additional pieces of information must be provided for display and editing. It has already been discussed that in a preferred embodiment of the invention a view would be provided displaying documents assigned to nodes. Depending on the nature of a document, this could be a word processor, a bitmap viewer, a video player or all other kinds of applications. Many document types can be displayed by applications already present on the user's computer. As discussed earlier, contact information from Microsoft Outlook can be stored in VCF files and readily displayed in a separate screen. In a similar manner, it is possible to provide specialized screens for displaying other types of extended information assigned to a node. Such a specialized screen can either be part of the interface or be programmed as a separate application. Programming an application that is able to read data from a file or from one or more database tables and to present that data to a user is a task that can readily be performed by a skilled software programmer. The selection of the appropriate screen for a specific type of data can for instance be done basing on the file extension of an assigned document or basing on an attribute assigned to the node.","A great number of file formats allow for insertion of hyperlinks. Word documents for instance as well as HTLM files can carry hyperlinks. Hyperlinks maybe presented to the user for instance as text, or they can be assigned to a graphic. It is even possible to assign a couple of hyperlinks to different areas of a graphic, for instance by using image maps or by virtually slicing a graphic and assigning a link to each slice. There are several useful implementations for embedding hyperlinks into a document assigned to a node, these hyperlinks pointing to another node.","One especially helpful implementation would maintain flowcharts. A flowchart can visualize work flows, decision points and loops. For complex applications like for instance the quality management system of a manufacturer for medical devices, the complete structure of processes is typically broken down into a great number of flowcharts, each visualizing a sub set of processes or even a portion of a process of quality management. Since many of the processes are interrelated with each other, most flowcharts have several entry points from external documents and also one or more exit points to external documents. It can be an arduous task to navigate through dozens or even hundreds of interrelated flowcharts. Managing such a complex system by assigning each flowchart to a node is beneficial especially if the nodes receive references reflecting the interrelations of the portions of the process visualized in flowcharts. A flowchart having five entry points would accordingly have up to five parent nodes, each parent node having a flowchart assigned holding the origin of one of the entry points. In this way, the high level process flow could be mapped within the references of the nodes, while the detailed process flow would be provided within flowcharts assigned to nodes.","Having several parent nodes representing the origins of external entry points is already very helpful, but still requires selecting the matching node for a certain entry point. It would be much more convenient if the user would simply have to click at the entry respectively exit point at the flowchart, and the interface would automatically select the appropriate node holding the adjunctive flowchart. Tasks like this can be achieved by using hyperlinks embedded in documents.","A very common program for generating flowcharts is Microsoft\u00ae Visio\u00ae. A flowchart in Visio is assembled from so called shapes like ovals, rectangles, diamonds etc., the shapes representing beginning or end of processes, process steps, decision points and the like. Visio allows assigning hyperlinks to each shape by selecting a shape and then clicking at the \u201cHyperlink\u201d menu item from the \u201cInsert\u201d menu. The desired target can be entered manually or selected by browsing. A hyperlink can point to another Visio diagram, a WEB address or a local file on a computer or server. A diagram with embedded hyperlinks can then be exported as HTML document by selecting \u201cSave As . . . \u201d from the \u201cFile\u201d menu and then selecting \u201cHTML Files\u201d from the dropdown list. A \u201cSave As HTML\u201d dialog box opens and allows for choosing the image format. Via the \u201cOptions\u201d button it can be ensured that option \u201cEnable Image Maps\u201d is checked. Visio then creates an HTML file that has the diagram embedded as a graphic file and also holds the image map defining the areas of the graphic that have hyperlinks assigned. The HTML file will typically contain a line like\n\n","Such an HTML file can then be viewed by a WEB browser or alternatively in a view integrated in an interface as described in this application. In order to assign portions of the flowchart to other nodes, in one embodiment auxiliary files having a specified file extension like for instance NLK are implemented. It is recommended to use an extension that is not widely used by other computer programs If a link to a node is to be inserted into a Visio flowchart, a preferred embodiment of the interface would provide two functions:","The ID of the node (preferably in hexadecimal format in case GUIDs are used as identifiers) would be exported to the Windows clipboard, completed by a dot and the extension. For instance, a string like\n\n","An auxiliary file is created having the same name as the string that has been copied to the Windows clipboard. This auxiliary file is either stored in the same directory as the HTML file generated by Visio, or at another location. If it is stored at another location, the link in the HTML file must also contain the path to that location. In a preferred embodiment, the auxiliary file can be empty.","A preferred embodiment of the process that leads to displaying a node within the interface when a user activates a hyperlink within any document currently open on the user's computer is illustrated in . Activating a hyperlink is typically performed by clicking at the hyperlink with the computer mouse. The left portion  of  displays method steps that are performed within the program implementing","the interface of this invention. The right portion  of  displays method steps that are performed by an arbitrary program which currently displays a document containing a hyperlink, and an auxiliary program which is launched directly by said program or indirectly by the operating system.","To ensure that the intended program is launched when a hyperlink is activated which points to a file having the specified extension, the auxiliary program must be registered at the operating system. When a software program is installed on a computer, the installation routine can for instance register the program to be associated to the respective file extension. Alternatively, the auxiliary program can also be selected manually by the user at the first time such a file having the specified extension is to be opened.","Generally, if the user activates at a hyperlink within a document (step ), the program currently displaying the document selects the appropriate program to open the file assigned to the hyperlink or lets the operating system select the program, and forwards the file name to the respective program (step ). The same mechanism is used when a user double-clicks at a filename in Windows Explorer. The operating system looks up which program to use, and launches that program. When launching the program, the filename of the document to be opened is also transmitted, and the program can retrieve the filename. In a Visual Basic application, a command line to retrieve such a filename would be:\n\n","Once the auxiliary program has been launched, and it has retrieved the filename and the node identifier, it will then transmit this identifier to the interface of this invention. There are several options to notify the interface. For instance, a notification file at a predetermined location can be used into which the auxiliary program enters the node identifier (step ). The interface would, triggered by an internal timer, frequently check the file date\/time of the same file (step. ). If the date\/time has changed, the interface would open the file and read the new node identifier (steps ). The timer could for instance be set to an interval of 0.5 seconds to make sure that the interface responds in a timely manner once the user prompts the display of the node by activating a hyperlink. When the interface has detected a new node identifier, it could, after reading the ID, delete this entry from the file to avoid ambiguity.","Another option would be to use Windows messages. The auxiliary program would send a message that notifies the interface about the node identifier. In yet another implementation an auxiliary program is not needed. The program implementing the interface is registered itself for being associated to the specified file extension. Once the user clicks at a hyperlink, another instance of the interface would be launched at the user's computer. This instance would detect that a previous instance is already running, would then forward the node identifier to the previous instance and shut itself down again. The advantage of this implementation is that the interface would be launched automatically by the user clicking a respective hyperlink if it wasn't already running.","After the interface has detected or been notified that a node has been selected externally, it would display that node to the user (step ). In a preferred embodiment the interface would scan the currently displayed view(s) to detect if the node is already present. If an internal array is used as shown in  to manage the currently displayed nodes, value Node_ID  would hold the identifier, and the computer program embodying the interface simply needs to comprise a loop running over all elements of the array and check for each row of the array if the value of Node_ID equals the identifier of the node that has been selected externally.","A node can also be present in a view without actually being displayed, for instance when it belongs to a branch that has previously been displayed, but is currently collapsed. If this is the case, the interface automatically expands the branch in order to display the node. If the node is not present in any view, the interface would scan the currently displayed view(s) to detect if a parent of the node or a child of the node is present. If that is the case, the interface would generate the respective branch and expand the generated branch. It is also possible to look for interrelations over several levels, in other words to look also for \u201cgrand-parents\u201d and \u201cgrand-grand-parents\u201d of the node to be displayed. In a preferred embodiment, the interface allows for configuration of the number of levels to be searched for interrelations between nodes that are present in the currently displayed view(s) and the node that has been selected externally.","If no sufficient interrelation between the currently present nodes and the externally selected node can be found, the interface could either create a new view where the node is displayed or add the node as an independent node to an existing view.","It becomes obvious that the functionality described above is not limited to an interface providing at least two arrangement modes for different directions of references. Rather, other interfaces being able to visualize only one direction of references for nodes, as for instance a standard tree view, will also greatly benefit from the disclosed method.","The words used in this specification to describe the invention and its various embodiment are to be understood not only in the sense of their commonly defined meanings, but to include by special definition in this specification structure, material or acts beyond the scope of the commonly defined meanings. Thus if an element can be understood in the context of this specification as including more than one meaning, then its use in a claim must be understood as being generic to all possible meanings supported by the specification and by the word itself.","Insubstantial changes from the claimed subject matter as viewed by a person with ordinary skill in the art, now known or later devised, are expressly contemplated as being equivalent within the scope of the claims. Therefore, obvious substitutions now or later known to one with ordinary skill in the art are defined to be within the scope of the defined elements.","This application is a continuation of U.S. application Ser. No. 11\/474,259, filed Jun. 26, 2006, which is a continuation of U.S. application Ser. No. 10\/864,603, filed Jun. 10, 2004, which is a continuation-in-part of U.S. application Ser. No. 10\/408,195, filed Apr. 8, 2003, each of which is incorporated herein by reference in its entirety.","It must be understood that the illustrated embodiment has been set forth only for the purposes of example and that it should not be taken as limiting the invention. It will be apparent to those skilled in the art that alterations, other embodiments, improvements, details and uses can be made consistent with the letter and spirit of the foregoing disclosure and within the scope of the invention's patent application, which is limited only by the following claims, construed in accordance with the patent law, including the doctrine of equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING","p":[{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 15","FIG. 14"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 18","FIG. 11"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 20","FIG. 19"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 21","FIG. 20"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 28","FIG. 27"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 29","FIG. 28"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 31","FIG. 29"]}]},"DETDESC":[{},{}]}
