---
title: Method to accelerate message signaled interrupt processing
abstract: Methods to accelerate a message signaled interrupt (MSI) are described herein. An embodiment of the invention includes an interrupt controller to receive a messaged signaled interrupt (MSI) request from a device over a bus, and an execution unit coupled to the interrupt controller to execute an interrupt service routine (ISR) associated with the device, the execution unit to retrieve interrupt data from a predetermined memory location specifically allocated to the device and to service the MSI using the interrupt data, without having to obtain the device interrupt data via an input output (IO) transaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09378163&OS=09378163&RS=09378163
owner: Intel Corporation
number: 09378163
owner_city: Santa Clara
owner_country: US
publication_date: 20111103
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND","DETAILED DESCRIPTION"],"p":["This patent application is a U.S. National Phase Application under 35 U.S.C. \u00a7371 of International Application No. PCT\/US2011\/059182, filed Nov. 3, 2011, entitled METHOD TO ACCELERATE MESSAGE SIGNALED INTERRUPT PROCESSING.","Embodiments of the present invention relate generally to data processing systems. More particularly, embodiments of the invention relate to acceleration of message signaled interrupt (MSI) processing.","Message signaled interrupts (MSI) are a feature that enables a device function to request service by writing a system-specified data value to a system-specified address using, for example, a memory write transaction. An MSI transaction enables a device function to request an interrupt service by sending the MSI transaction as an inbound memory write on its bus to the front-side bus (FSB). Because an MSI transaction is generated in the form of a memory write, MSI transactions support transaction conditions such as a retry, master-abort, target-abort or normal completion. As added benefits, MSI transactions simplify board design by removing out of band interrupt routing and represent another step towards a legacy-free environment.","Message signaled interrupts allow a device to write a small amount of data to a special address in memory space. The chipset will deliver the corresponding interrupt to a processor (also referred to as a central processing unit or CPU). A common misconception with message signaled interrupts is that they allow the device to send data to the CPU as part of the interrupt. The data that is sent as part of the write is used by the chipset to determine which interrupt to trigger on which CPU; it is not available for the device to communicate additional information to the interrupt handler.","A drawback of MSI transactions is the latency involved with servicing an interrupt. For example, when a device requests an interrupt service using MSI, the device generates a MSI transaction including a system-specified message and a system-specified address. Once a processor receives the MSI transaction, the processor has to communicate with the requesting device to retrieve data required to service the interrupt. The processor may then service the interrupt using interrupt data received from the device. However, the latency involved with communications with the device may be relatively long. As a result, each interrupt serviced via a MSI transaction involves a long latency and adds traffic to, for example, the FSB, the memory controller hub (MCH), and\/or, the input-output controller hub (ICH) coupling the device to the processor.","Various embodiments and aspects of the inventions will be described with reference to details discussed below, and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However, in certain instances, well-known or conventional details are not described in order to provide a concise discussion of embodiments of the present inventions.","Reference in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification do not necessarily all refer to the same embodiment.","According to some embodiments, a mechanism is provided to allow a device to bundle and send interrupt data or messages to processor directly when asserting an MSI interrupt to the processor for effective and accelerated interrupt handling. According to one embodiment, for each device that is capable of handling MSI interrupts, a specific block of memory is allocated for the device. Such a block of memory may be allocated from a processor cache (e.g., processor level-3 or L3 cache) or from a specific memory region of a system memory coupled to the processor. Each device is able to directly access its associated block of memory, for example, via a posted write transaction (e.g., using direct cache access techniques). The size of a memory block associated with a device may vary dependent upon the specific configuration or needs, which may be configurable during an initialization of the system or device.","According to one embodiment, when a device is about to assert an MSI, the device is configured to store all the necessary data (also referred to herein as interrupt data) to be utilized during the interrupt service to the associated memory block via a first posted write transaction. The device then is configured to request the MSI via a second posted write transaction to the system specifically defined address for the MSI to trigger the MSI interrupt. When the processor invokes an interrupt service routine (ISR) associated with the device, the processor can access the memory block specifically allocated to the device to retrieve the interrupt data and service the interrupt using the interrupt data without having to access the device for the same data via one or more IO transactions, which may take a relatively long period of time.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 1","FIG. 1"],"b":["100","101","102","106","102","103","104","107","101","101","110","101","103","104","105","101","108","103","104","111","109","101","108","111","102","106","107"]},"According to one embodiment, when a device such as device  or device  is about to assert an MSI, the device is configured to store interrupt data  to be utilized during the interrupt service to the associated block of cache  via a first posted write transaction. The device then requests the MSI via a second posted write transaction to the system specifically defined address for the MSI to trigger the MSI interrupt. When processor  invokes an interrupt service routine (ISR) associated with the device, processor  can access interrupt data  associated with the device and service the interrupt using the interrupt data without having to access the device for the same data via one or more IO transactions.","One of the reasons for specific cache lines to be allocated is to prevent interrupt data written to these allocated cache lines from being automatically replaced by the cache line replacement algorithm (e.g. least recently used (LRU) cache line replacement policy). For example, device  pushes interrupt data into cache line  followed by an MSI interrupt. Processor  branches to device 's ISR  and executes the ISR's callback function. When processor  services the interrupt (assuming that processor core  is servicing the interrupt). Meanwhile, a second process from another processing core (core ) accesses data from system memory  and encounters a cache miss, which causes the interrupt data contents of cache line  to be automatically replaced by data in system memory . This will cause ISR  to access the no longer valid interrupt data from cache line  and compromise the whole system. In one embodiment, the allocated cache line is allocated by marking it unavailable for automatic replacement and it is allocated to a device (e.g. device ) by writing its cache line or memory address into device 's interrupt data register , such that device  is the only device that can write to that cache line.","Note that the configuration as shown in  is described for the purpose of illustration only. The memory blocks allocated to store interrupt data  for devices - can also be allocated from other memories such as system memory  and accessible by processor  via MCH . Also note that MCH  may be integrated with chipset , where chipset  further includes input output controller hub (ICH)  to control IO devices such as devices -, as shown in .",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 3","FIG. 1","FIG. 2","FIG. 3"],"b":["300","100","200","300","105","101","301","302","303","103","104","301","301","103","104","302","303"]},"When a device (e.g., device ) wishes to request an MSI interrupt, the device is configured to issue a posted write transaction to a system defined address for MSI, including an interrupt vector representing an entry point of the associated ISR. The MSI request causes an interrupt controller to invoke processor  to call back the ISR (e.g., ISR ) to service the interrupt. Conventionally, when the ISR is invoked, the processor has to access the corresponding device to retrieve the necessary interrupt data such as data of one or more control and status register (CSR) of the device via one or more IO transactions, which may consume a relatively long period of time.","According to one embodiment, for each of devices -, a dedicated block of memory is allocated to store interrupt data to be utilized by the corresponding ISR when an MSI interrupt is serviced by processor . The memory block can be allocated from processor cache  or alternatively from a specific region of the system memory such as memory . Such memory blocks can be allocated during an initialization of system  (e.g., boot) or during initialization of device drivers -. Alternatively, a memory block may be dynamically allocated when a device is connected with the system (e.g., detected by a plug-and-play manager).","For example, according to one embodiment, during initial enumeration of devices, the system firmware such as a basic input output system (BIOS) or a low level OS initialization component can allocate and assign a block of memory to each device. For example, the system may directly configure or write a particular cache line address and\/or size, or memory address and\/or size associated with the corresponding memory block of each device in a predetermined register of the device (e.g., registers -). The system may allocate a fixed size memory block for each device such as memory blocks -. For example, during system initialization, the system may allocate and write a memory address and\/or size of the allocated block to a predetermined register such as interrupt data registers - of devices -, respectively.","Subsequently, when device drivers - are loaded and initialized by OS , each of devices - can retrieve the cache line address or memory address from its interrupt data register (e.g., registers -) and directly access the associated memory block (e.g., memory blocks -) for the purpose of storing the interrupt data, for example, via a direct cache access (DCA) or direct memory access (DMA) method when it wants to send an MSI interrupt to processor . Similarly, during system initialization, OS  may also write the same memory address and\/or size of the allocated memory block previously allocated to device - to a device driver - interrupt data parameter (e.g., interrupt data address\/size -) for the purpose of accessing device interrupt data from the same memory block during ISR interrupt service processing.","In a particular embodiment, during initialization, OS  allocates cache line  and writes the memory addresses to both the device driver interrupt data register  and also a device driver interrupt data parameter (e.g. interrupt data address\/size -). When device  wishes to interrupt processor . It proactively sends its interrupt data as a posted write transaction into cache line  via DCA using the memory address previously stored in its interrupt data register  followed by an MSI interrupt posted write. The MSI interrupt will trigger processor  to branch to device driver's ISR . Inside ISR . Processor  then obtains device 's interrupt data using the cache line address pointed to by device driver interrupt data parameter  and uses the interrupt data to process the interrupt. Storing the same cache line or memory address to both device data register  and an interrupt data parameter  inside device driver  during initialization enables device  and processor  executing device driver  (e.g., two separate entities) to know where to send and retrieve interrupt data without having to query each other.","Alternatively, according to another embodiment, when a device driver is loaded and initialized by OS , the device is configured to communicate with OS  or the BIOS to request a block of memory (from processor cache or system memory) with a particular size. For example, a device driver can call a specific an application programming interface (API) to BIOS or OS  to negotiate a block of memory either from processor cache  or system memory . In return, the system allocates and provides a starting memory address and\/or size to the device driver, which may be maintained (in memory ) by the device driver throughout the life of the device driver or alternatively, it can be written in a register of the device (e.g., interrupt data registers -). As a result, each device driver has the capability of negotiating various sizes of memory blocks for storing interrupt data, which is not limited to traditional MSI request messages.","For the purpose of illustration only, it is assumed that device driver  is configured to control and operate device  and memory block  has been allocated to device  for storing interrupt data. When an interrupt event of device  occurs, device  is configured to store the associated interrupt data to memory block . Note that an interrupt requester of a driver is invoked only once during device configuration to reserve (request for) an MSI interrupt, which may include setting up the interrupt vector and linking it to the interrupt service routine callback function of the device and reserving a memory block for storing interrupt data. The device is the one that contains additional logic, firmware or software to proactively push its interrupt data including its own CSR values, filled DMA buffer addresses, device messages, tags and other information to processor cache or memory when it wishes to send an MSI interrupt to processor. When this is done, device driver 's interrupt service routine no longer needs to poll the device for its interrupt data using multiple IO transactions. For example, when device  wishes to assert an MSI interrupt to processor , interrupt request logic , which may be implemented as a DCA\/DMA logic or firmware, proactively pushes interrupt data of device  (e.g. CSR , DMA filled buffer addresses, interrupt messages, tags . . . ) into memory block  as a first posted write transaction before sending an MSI interrupt as the second posted write transaction.","Once the interrupt data has been stored in memory block , logic  of device  will send an MSI interrupt, for example, by issuing a posted write transaction, to a system defined address specifically for MSI interrupt. In response to the MSI request, an interrupt controller such as interrupt controller  of  causes processor  to branch to its interrupt handler and calls ISR  of device driver . When ISR  is invoked, processor  is configured to access memory block  to retrieve the interrupt data stored therein based on the memory address associated with the allocated memory block and to service the MSI interrupt using the retrieved interrupt data without having to access device  via one or more IO transactions.","Note that the interrupt controller (e.g. processor APIC\u2014Advanced Programmable Interrupt Controller) processes the interrupt vector associated with the MSI interrupt and causes processor  to branch to its interrupt handler. The interrupt handler will invoke ISR . An MSI interrupt is sent by a device to a system defined address of processor and contains one interrupt vector. Each device's MSI interrupt contains a unique interrupt vector that is mapped to the device ISR. When processor  detects that a posted write transaction is to the system defined address, it passes the posted write transaction data (e.g., the interrupt vector) to the processor APIC. The processor APIC uses the interrupt vector to locate the interrupt handler which may reside in some specified memory address. The interrupt handler then invokes the device driver's ISR  callback function to service the interrupt. In this embodiment, ISR  obtains its interrupt data from memory  without having to poll device  using multiple IO transactions.","According to one embodiment, when device  wishes to request an MSI interrupt, logic  of device  is configured to issue a first posted write transaction to a preconfigured memory address corresponding to memory block  to a bus (e.g., IO bus and\/or FSB) with all the necessary interrupt data included therein. The memory address may be retrieved from interrupt data register  and also maintained by device driver . Once the interrupt data has been stored in memory block , device  is configured to issue a second posted write transaction to a system defined address for requesting an MSI interrupt, which will be received by an interrupt controller that may reside within processor  or within a chipset coupling device  and processor . In one embodiment, the first and second posted write transactions may be issued as back-to-back transactions. In one embodiment, prior to issuing the first posted write transaction, interrupt request logic  may acquire an exclusive bus access by locking down a bus coupling device  with processor  and to release the exclusive access after the second posted write transaction has been issued.","Since both transactions are treated as posted writes and the bus (e.g., backbone bus such as FSB and\/or IO bus) is locked, producer consumer rules guarantee that data write transaction and MSI interrupt transaction will be delivered to processor  in a correct order, without interference from other components. Upon receiving the MSI interrupt via the second posted write transaction, processor  branches to ISR . While executing ISR , processor  is configured to access memory block  to retrieve interrupt data such as CSR information corresponding to CSR register , device specific messages, and other information as needed. Based on the information, processor  can determine the type of interrupt services requested by device , the state of device , and\/or the statues of device ; and service the requested interrupt using the retrieved interrupt data accordingly. After servicing the interrupt, processor  may update certain registers of device  via one or more IO or memory mapped IO transactions, notifying device  that the interrupt has been serviced.","Dependent upon the size of an allocated memory block, according to one embodiment, interrupt data can include a variety of information that can be utilized by ISR  when servicing the MSI interrupt. For example, as shown in , interrupt data  may include, but is not limited to, service request symbol or tag , CSR register value , direct memory access (DMA) addresses , device specific messages , and other data . Service request symbol or tag  may be utilized by an ISR to determine the type of service or function should be performed during the interrupt service (e.g., a filled DMA buffer to be processed; an error condition occurred and error recovery is needed; data available to be processed; or device ready to receive data, etc). Service request symbol or tag  may be internally defined by a device logic developer and\/or device software developer specifically tailored to the device's needs. CSR register values  may be retrieved from one or more CSR register of the device and posted via the first posted write transaction. Note that information - is shown for the purpose of illustration only; more or less of information - may be included dependent upon the specific configuration.","For example, interrupt data  may further include any device register values, first-in-first-out (FIFO) entries, queue entries, or any other device information can may otherwise be obtained using one or more IO transactions to query device registers during an ISR callback (after MSI interrupt has been received and processor execution has entered the ISR). Device power state information  may allow the device to proactively interrupt processor in response to a change in its power state or in response to a power state transition event. Device thermal and thermal control information  may allow the device to proactively interrupt processor in response to a thermal event such as overheating or the need to turn on\/turn off a fan or a cooling system. Other data information  may include some relatively \u201csmall size\u201d interrupt data, such as keystrokes and\/or coordinates information from a user input device such as a mouse, touchpad or keyboard, etc.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 5","FIG. 5"],"b":["500","100","200","501","502","503","504","315","316","505"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 6","FIG. 3","FIG. 6","FIG. 4"],"b":["600","103","104","601","602","603","400","604","605"]},"It can be seen that embodiments of the invention enable a device to proactively push certain information such as its CSR register values and other data into processor's cache or certain regions of the system memory when interrupting the processor for service using a coalesced bus write transaction. The processor can have fast access to information it needs to service the interrupt and does not have to poll a register of the device via an IO transaction which can be inefficient and time consuming. It can also be seen that devices may selectively push only subsets of information needed by the processor to service the interrupt, for example, as shown in . It will be appreciated that a device designer may choose to use conventional methods of servicing an MSI interrupt, an improved MSI method as described above, or a combination of both methods. The choices of MSI processing methods may be selected dependent upon the complexity of the devices and\/or the bandwidth or processing power available at the point in time (e.g., whether it is more efficient to \u201cpush\u201d instead of \u201cpoll\u201d under the circumstances).",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 7","FIGS. 1 and 2","FIG. 7"],"b":["700","100","200","700"]},"Referring to , in one embodiment, system  includes processor  and chipset  to couple various components to processor  including memory  and devices - via a bus or an interconnect. Processor  may represent a single processor or multiple processors with a single processor core or multiple processor cores  included therein. Processor  may represent one or more general-purpose processors such as a microprocessor, a central processing unit (CPU), or the like. More particularly, processor  may be a complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, or processor implementing other instruction sets, or processors implementing a combination of instruction sets. Processor  may also be one or more special-purpose processors such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), a network processor, a graphics processor, or the like. For example, processor  may be a Pentium\u2122 4, Pentium\u2122 Dual-Core, Core\u2122 2 Duo and Quad, Xeon\u2122, Itanium\u2122, XScale\u2122 or StrongARM\u2122 microprocessor available from Intel Corporation of Santa Clara, Calif. Processor  is configured to execute instructions for performing the operations and steps discussed herein.","Chipset  may include memory control hub (MCH)  and input output control hub (ICH) . MCH  may include a memory controller (not shown) that communicates with a memory . MCH  may also include a graphics interface that communicates with graphics device . In one embodiment of the invention, the graphics interface may communicate with graphics device  via an accelerated graphics port (AGP), a peripheral component interconnect (PCI) express bus, or other types of interconnects. ICH  may provide an interface to I\/O devices such as devices -. Any of devices - may be a storage device (e.g., a hard drive, flash memory device), universal serial bus (USB) port(s), a keyboard, a mouse, parallel port(s), serial port(s), a printer, a network interface (wired or wireless), a wireless transceiver (e.g., WiFi, Bluetooth, or cellular transceiver), a media device (e.g., audio\/video codec or controller), a bus bridge (e.g., a PCI-PCI bridge), or other devices.","MCH  is sometimes referred to as a Northbridge and ICH  is sometimes referred to as a Southbridge, although some people make a technical distinction between them. As used herein, the terms MCH, ICH, Northbridge and Southbridge are intended to be interpreted broadly to cover various chips who functions include passing interrupt signals toward a processor. In some embodiments, MCH  may be integrated with processor . In such a configuration, chipset  operates as an interface chip performing some functions of MCH  and ICH , as shown in . Furthermore, graphics accelerator  may be integrated within MCH  or processor .","Memory  may store data including sequences of instructions that are executed by processor , or any other device. For example, executable code and\/or data of a variety of operating systems, device drivers, firmware (e.g., input output basic system or BIOS), and\/or applications can be loaded in memory  and executed by processor . An operating system can be any kind of operating systems, such as, for example, Windows\u00ae operating system from Microsoft\u00ae, Mac OS\u00ae\/iOS\u00ae from Apple, Android\u00ae from Google\u00ae, Linux\u00ae, Unix\u00ae, or other real-time operating systems. In one embodiment, memory  may include one or more volatile storage (or memory) devices such as random access memory (RAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), static RAM (SRAM), or other types of storage devices. Nonvolatile memory may also be utilized such as a hard disk or a flash storage device. Front side bus (FSB)  may be a multi-drop or point-to-point interconnect. The term FSB is intended to cover various types of interconnects to processor . Chipset  may communicate with other devices such as devices - via point-to-point interfaces.","Cache  may be any kind of processor cache, such as level-1 (L1) cache, L2 cache, L3 cache, L4 cache, last-level cache (LLC), or a combination thereof. Cache  may be shared with processor cores  of processor . Cache  may be embedded within processor  and\/or external to processor . Processor  may further include a direct cache access (DCA) logic to enable other devices such as devices - to directly access cache . Processor  and\/or chipset  may further include an interrupt controller to handle interrupts such as message signaled interrupts.","Processor  may further include one or more register files including, but are not limited to, integer registers, floating point registers, vector or extended registers, status registers, and an instruction pointer register, etc. The term \u201cregisters\u201d is used herein to refer to the on-board processor storage locations that are used as part of macro-instructions to identify operands. In other words, the registers referred to herein are those that are visible from the outside of the processor (from a programmer's perspective). However, the registers should not be limited in meaning to a particular type of circuit. Rather, a register need only be capable of storing and providing data, and performing the functions described herein. The registers described herein can be implemented by circuitry within a processor using any number of different techniques, such as dedicated physical registers, dynamically allocated physical registers using register renaming, combinations of dedicated and dynamically allocated physical registers, etc. In one embodiment, integer registers store 32-bit or 64-bit integer data. A register file may contain extended multimedia SIMD registers (e.g., XMM) for packed data. Such registers may include 128 bits wide XMM registers and 256 bits wide registers (which may incorporate the XMM registers in their low order bits) relating to SSE2, SSE3, SSE4, GSSE, and beyond (referred to generically as \u201cSSEx\u201d) technology to hold such packed data operands.","According to one embodiment, a portion of process cache  and\/or memory  is utilized to allocate a memory block for at least one of devices - to store interrupt data. When a device wishes to request an MSI interrupt, the device issues a first posted write transaction to the memory block to store its interrupt data as part of interrupt data . The device then issues a second posted write transaction to a system defined address to request an MSI interrupt according to the MSI specification. These transactions are back-to-back transaction while the bus or interconnect is locked by the device. However, in other embodiments, the bus does not have to be locked as long as bus transactions are sent and observed by the processor in a correct order. Thereafter, an ISR associated with the device is invoked to service the MSI interrupt using the interrupt data retrieved from the memory block, without having to communicate with the device via an IO transaction, as described above.","Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as those set forth in the claims below, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","Embodiments of the invention also relate to an apparatus for performing the operations herein. Such a computer program is stored in a non-transitory computer readable medium. A machine-readable medium includes any mechanism for storing information in a form readable by a machine (e.g., a computer). For example, a machine-readable (e.g., computer-readable) medium includes a machine (e.g., a computer) readable storage medium (e.g., read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media, optical storage media, flash memory devices).","The processes or methods depicted in the preceding figures may be performed by processing logic that comprises hardware (e.g. circuitry, dedicated logic, etc.), firmware or software (e.g., embodied on a non-transitory computer readable medium), or a combination of both. Although the processes or methods are described above in terms of some sequential operations, it should be appreciated that some of the operations described may be performed in a different order. Moreover, some operations may be performed in parallel rather than sequentially.","Embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.","In the foregoing specification, embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the invention are illustrated by way of example and not limitation in the figures of the accompanying drawings in which like references indicate similar elements.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
