---
title: Two-level operating system architecture
abstract: A computer system is provided comprising a core operating system and a system space having a number of memory locations. The core operating system creates a number of protection domains to partition the system space. Each of the partitions includes a partition operating system and a partition user application. Each partition operating system provides resource allocation services to the respective partition user application within the partition.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07103745&OS=07103745&RS=07103745
owner: Wind River Systems, Inc.
number: 07103745
owner_city: Alameda
owner_country: US
publication_date: 20021017
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND INFORMATION","SUMMARY","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is related to U.S. application Ser. No. 10\/273,288, entitled HEALTH MONITORING SYSTEM FOR A PARTITIONED ARCHITECTURE and U.S. application Ser. No. 10\/273,305, entitled INTERPARTITION COMMUNICATION, both filed on even date herewith, and the entire disclosures of which are hereby incorporated by reference in their entirety.","A computing environment comprising, for example, a CPU, memory and Input\/Output (I\/O) devices, typically includes an operating system to provide a way to control the allocation of the resources of the environment. Traditional multitasking operating systems (e.g., UNIX, Windows) have been implemented in computing environments to provide a way to allocate the resources of the computing environment among various user programs or applications that may be running simultaneously in the computing environment. The operating system itself comprises a number of functions (executable code) and data structures that may be used to implement the resource allocation services of the operating system.","Certain operating systems, called \u201creal-time operating systems,\u201d have been developed to provide a more controlled environment for the execution of application programs. Real-time operating systems are designed to be \u201cdeterministic\u201d in their behavior\u2014i.e., responses to events can be expected to occur within a known time of the occurrence of the event, without fail. Determinism is particularly necessary in \u201cmission-critical\u201d and \u201csafety-critical\u201d applications, where the outcome of event responses is essential to proper system function. Real-time operating systems are therefore implemented to execute as efficiently as possible with a minimum of overhead. As a result, prior real-time operating systems have typically employed relatively simplistic protection models for system and user processes\u2014typically all processes execute in the same space, thus allowing direct access to all system resources by all user tasks (system calls can be made directly). This real time operating system model provides the fastest execution speed, but is deficient in providing system protection.","In order to improve system protection, it has been proposed to provide an operating system that implements a \u201cprotection domain\u201d architecture. VxWorks\u00aeAE, marketed by Wind River Systems of Alameda, Calif., is an example of such a protection domain system. Basically, the protection domain system segregates the computing environment into a number of \u201cprotection domains.\u201d Each protection domain is a \u201ccontainer\u201d for system resources, executable code and data structures, as well as for executing tasks and system objects (such as semaphores and message queues). Each resource and object in the system is \u201cowned\u201d by exactly one protection domain. The protection domain itself is a self-contained entity, and may be isolated from other system resources and objects to prevent tasks executing in the protection domain from potentially interfering with resources and objects owned by other protection domains (and vice versa).","The protection domain system of VxWorks\u00aeAE also, however, provides mechanisms by which tasks executing in one protection domain may access resources and objects contained in a separate protection domain. Each protection domain includes a \u201cprotection view\u201d that defines the system resources and objects to which it has access (i.e., the resources and objects which it can \u201csee\u201d). By default, each protection domain has a protection view that includes only the system resources and objects contained within that protection domain. However, a protection domain may acquire access to the resources of other protection domains by \u201cattaching\u201d to these protection domains. When a first protection domain has obtained \u201cunprotected attachment\u201d to a second protection domain, the second protection domain is added to the protection view of the first protection domain. Executable code in the first protection domain may use \u201cunprotected links\u201d to functions selected in the second protection domain, allowing tasks executing in the first protection domain to use the resources and access the objects of the second protection domain with a minimum of execution overhead.","Unrestricted access by all tasks executing in one protection domain to all the resources and objects of another protection domain may not be desirable, however, for reasons of system protection and security. The VxWorks\u00aeAE protection domain system therefore provides a further mechanism whereby individual tasks executing in a first protection domain may access resources or objects contained in a second protection domain, but without adding the second protection domain to the protection view of the first protection domain. This access is achieved by \u201cprotected attachment\u201d of the first protection domain to the second protection domain via a \u201cprotected link\u201d between executable code in the first protection domain and selected functions in the second protection domain. Using the protected link, a task running in the first protection domain may, for example, make a direct function call to a function existing in the second protection domain, without the need to alter the protection view of the first protection domain. Tasks in the first protection domain are prevented from accessing the second protection domain except through this protected link, thus preventing unauthorized accesses of functions and data in the second protection domain. Protected linking can be achieved without the need to use different code instructions for protected and unprotected accesses (increasing implementation flexibility), and without the need to create separate tasks in the protected protection domain to perform the desired actions.","Such a protection domain system allows the operating system to dynamically allocate system resources among processes and flexibly implements and enforces a protection scheme. This protection scheme can be formulated to control the impact of poorly written applications, erroneous or disruptive application behavior, or other malfunctioning code, on the operating system and other applications running in the computer system. The protection domain approach accomplishes the protection results in a manner that is transparent to application developers, and incurs minimal execution overhead.","While the known protection domain system achieves a significant advance in system protection, additional capabilities would be desirable. For example, in safety-critical applications, it would be desirable to separate user applications into discrete partitions so that the impact of any erroneous or disruptive behavior of a particular user application can be contained to the malfunctioning application itself.","According to one exemplary embodiment of the present invention, a computer system is provided, comprising a core operating system and a system space having a number of memory locations. The core operating system partitions the system space into a plurality of partitions. Each of the partitions includes a partition operating system and a partition user application. Each partition operating system provides resource allocation services to the respective partition user application within the partition. Also according to another exemplary embodiment of the present invention, the core operating system is arranged to schedule the partitions such that the partition operating system, partition user application pairs are temporally partitioned from each other. According to another exemplary embodiment, the scheduling is a time multiplexed scheduling.","According to another exemplary embodiment of the present invention, a computer system is provided, comprising a core operating system and a system space having a number of memory locations. The core operating system creates a number of protection domains to partition the system space. Each of the partitions includes a partition operating system and a partition user application. Each partition operating system provides resource allocation services to the respective partition user application within the partition. Also according to another exemplary embodiment of the present invention, the core operating system is arranged to schedule the partitions such that the partition operating system, partition user application pairs are temporally partitioned from each other. According to another exemplary embodiment, the scheduling is a time multiplexed scheduling.","A first method according to an exemplary embodiment of the present invention is also provided. The method includes implementing a core operating system and providing a system space having a number of memory locations. Additional steps include operating the core operating system to partition the system space into a plurality of partitions; and implementing a partition operating system, partition user application pair in each partition whereby the partition operating system, partition user application pairs of the partitions are spatially partitioned from each other. The method provides the step of operating each partition operating system of each pair to provide resource allocation services to the respective partition user application within the partition.","A second method according to an exemplary embodiment of the present invention is also provided. The method includes implementing a core operating system and providing a system space having a number of memory locations. Additional steps include operating the core operating system to create a number of protection domains to partition the system space and implementing a partition operating system, partition user application pair in each partition whereby the partition operating system, partition user application pairs of the partitions are spatially partitioned from each other. The method provides the step of operating each partition operating system of each pair to provide resource allocation services to the respective partition user application within the partition.","Pursuant to a third method, an additional step is provided in the first and\/or second methods, wherein the additional steps includes operating the core operating system to schedule the partitions such that the partition operating system, partition user application pairs are temporally partitioned from each other.","In with accordance with further embodiments of the present invention, computer readable media are provided, having stored thereon, computer executable process steps operable to control a computer to implement the embodiments described above.","Referring now to the drawings, and initially to , there is illustrated in block diagram form, a computer system  comprising a CPU , which is coupled to a physical memory system  and a number of I\/O systems . Connection of the CPU  to the physical memory system  and the number of I\/O systems  may be according to any of the well known system architectures (e.g., PCI bus) and may include additional systems in order to achieve connectivity. I\/O systems  may comprise any of the well known input or output systems used in electronic devices (e.g., key pad, display, pointing device, modem, network connection). Physical memory system  may include RAM or other memory storage systems, and read only memory and\/or other non-volatile storage systems for storage of software (an operating system, other applications) to be executed in the computer system . Alternately, software may be stored externally of computer system  and accessed from one of the I\/O systems  (e.g., via a network connection). CPU  may also include a memory management unit (MMU, not shown) for implementing virtual memory mapping, caching, privilege checking and other memory management functions, as is also well known.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 2","FIG. 2"],"b":["110","100","110","100","110","102","100","110","110","110","110","110"]},"According to the present invention, the system space  stores a core operating system , such as, for example the VxWorksAE\u00ae operating system. The core operating system  includes executable code and data structures, as well as a number of executing tasks and system objects that perform system control functions, as will be described in more detail below. Pursuant to the present invention, the core operating system  implements a protection domain system in which all resources and objects are contained within protection domains. The core operating system itself can be contained in a protection domain . The exemplary protection domain system of the core operating system  is also object oriented, and each protection domain is a system object.","By way of background, operating systems implemented in an \u201cobject oriented\u201d manner are designed such that when a particular function and\/or data structure (defined by a \u201cclass\u201d definition) is requested, the operating system creates (\u201cinstantiates\u201d) an \u201cobject\u201d that uses executable code and\/or data structure definitions specified in the class definition. Such objects thus may contain executable code, data structures, or both. Objects that perform actions are typically referred to as \u201ctasks\u201d, \u201cthreads,\u201d or \u201cprocesses\u201d (which may include tasks or threads)\u2014they may all be referred to generally as executable entities, but will be referred to herein simply as tasks for purposes of clarity. Upon loading and execution of an operating system into the computing environment, system tasks will be created in order to support the resource allocation needs of the system. User applications likewise upon execution may cause the creation of tasks (\u201cuser tasks\u201d), and other objects in order to perform the actions desired from the application.","The structure of each protection domain is defined through a protection domain \u201cclass\u201d definition. A protection domain may be created, for example, by instantiating a protection domain object based on the protection domain class. Only the core operating system  can create or modify (or destroy) a protection domain, although user tasks can request such actions through a protection domain application programming interface (API) provided by the core operating system. A protection domain object is owned by the protection domain that requested its creation.","Referring now to , there is illustrated the system space  of  arranged into partitions according to an exemplary embodiment of the two-level operating system architecture according to the present invention. The core operating system  instantiates a number of protection domains  to provide partitions within the memory system space , as will be described in more detail below. Instantiated within each partition defined by a protection domain  is a partition operating system  and a partition user application . According to this exemplary embodiment of the present invention, each partition operating system  is dedicated to the respective partition user application  within the same protection domain , and the partition user application  interacts with the respective partition operating system . The partition operating system  allocates resources instantiated within the protection domain  to the respective partition user application  (or requests resources outside the protection domain  via the OS abstraction layer to core operating system , as described further below). As discussed, each of the partition operating system  and the respective partition user application  of a particular protection domain-defined partition comprises objects including executable code and\/or data structures. All of such objects are instantiated in the respective protection domain of the partition. The term \u201cuser application\u201d is used herein to denote one or more user applications instantiated within a particular protection domain.","In this manner, user applications can be spatially separated into discrete partitions of the system space  so that they are unable to interact with each other, except through explicit mechanisms, as for example, under tight control of the two-level operating system architecture implementing the protection domain scheme. Moreover, each user application  can be controlled through explicit allocation of resources owned by the protection domain, by the partition operating system , to prevent the applications from affecting the operation of the entire system.","Pursuant to the exemplary embodiment of the present invention, the core operating system  performs certain functions for the overall system and\/or on behalf of each partition operating system . As discussed, the core operating system  creates and enforces partition boundaries by instantiation of the protection domains . The core operating system  schedules partition processor usage among the several protection-domain-defined partitions, to determine which user application and respective partition operating system will be operating at any given time. In addition, the core operating system  can control system resource allocation, the passing of messages between the partitions, the handling of interrupts, the trapping of exceptions and the execution of system calls, on behalf of the partition operating systems , and the Input\/Output systems .","Each of the partition operating systems  can be implemented from object components of a real time operating system such as, for example, VxWorks\u00ae, marketed by Wind River Systems of Alameda, Calif. The components can include, for example, kernel, math, stdio, libc and I\/O functionality of the VxWorks\u00ae real time operating system to achieve resource allocation for user task management and inter-task communication for the respective partition user application . Each partition operating system  is also implemented to support user-application level context switches within a partition, and to indirectly interact with I\/O devices via calls to the core operating system . Each partition operating system  can also be configured to call the core operating system  for access to resources maintained at the system level, and for the handling of traps and exceptions by the core operating system . Accordingly, the partition operating system  appears to be the only operating system to user application , and thus user application  can be implemented in a standard manner, without consideration of the interface or operation of core operating system .","Referring now to , there is illustrated a logical block diagram of an exemplary protection domain , as may be created by the core operating system . The specific components capable of being \u201cowned\u201d by a protection domain  may be specified in the protection domain class definition. Exemplary protection domain  may be considered the owner of one or more of the following components:\n\n","Memory space  comprises a number of virtual memory locations from system space . These memory locations need not be contiguous, and may include memory mapped I\/O locations. The amount of memory allocated to the memory space  of a protection domain  by the core operating system  may be specified at the time protection domain  is created. Additional memory may be dynamically allocated to memory space  by the core operating system  as needed from any free memory in system space . The code modules are stored within the memory space .","Upon creation of the protection domain , the protection view  is established. The protection view  represents all of the protection domains  to which tasks executing in the protection domain  illustrated in  may have access. An exemplary protection view data structure  that may be used to represent the protection view  is illustrated in .","Protection view data structure  is a bit map for a particular protection domain , in which each protection domain  in the system space  is represented by a single bit. Where a bit is set, the respective protection domain  represented by the bit map has unprotected access to the memory space  of the corresponding protection domain in system space . Where a bit is not set, unprotected access is not permitted. The core operating system  may maintain information for mapping each bit to an existing protection domain . The size of the bit map defines the maximum number of protection domains supported in the system space ; in this example, sixty-four protection domains are possible. Note that other data structures or different sized bit maps could be used to represent the protection view  to increase or decrease the number of protection domains that can be in a protection view. The default condition for a specific protection domain  is a protection view  that includes only the resources and objects of the memory space  of that protection domain , and no other protection domains. In the exemplary bit map of protection view data structure , this default condition may be represented by setting the bit corresponding to the illustrated protection domain, while leaving the remaining bits cleared (value zero). A protection domain  may expand its protection view  by being \u201cattached\u201d to other protection domains during the linking process when code modules or other objects are loaded into protection domain , pursuant to features of the VxWorks\u00aeAE operating system.","Also upon creation of a protection domain  by the core operating system , a set of protection domain attributes  may be specified. These attributes may be used to control the actions allowed by tasks executing in the created protection domain , the linking permitted between the created protection domain  and other protection domains in the system space , and other characteristics of the protection domain . Among the protection domain attributes  supported by protection domains  of, for example, the VxWorks\u00aeAE operating system are:\n\n","In addition, during the protection domain creation process by the core operating system , the memory space  is loaded with code modules . Pursuant to the present invention, the code modules  include the partition operating system  of the respective partition , and the respective user application . The code modules  comprising the partition operating system  and the respective partition user application , are therefore spatially separated from other code modules of system space  by a protection domain-defined partition. Thus, according to the present invention, execution of user tasks, and resource allocation control functions of the partition operating system for the specific tasks can be accomplished from within a protected and separated portion of the system space . Such an arrangement minimizes the ability of a user application from affecting anything within the system space that is beyond its partition.","For maximum security, the protection view of a partition  can be set in the default mode wherein only objects within the specific protection domain memory space  can be accessed by executable code executing within the partition . Thus, each partition operating system and partition user application pair can be substantially spatially isolated from all other system space.","However, the executable code may include a number of instructions, which, for example, in the case of a code module of the respective partition user application , reference other executable code or data structures outside of code module  (e.g., via a \u201cjump\u201d or \u201cbranch\u201d instruction to execute a function). These references may be made using \u201csymbols\u201d that are intended to represent the memory location of the desired code or data structure. In order to determine (\u201cresolve\u201d) the memory address value of these symbols, the loading of code modules  may include a linking process of the type provided in the VxWorks\u00aeAE operating system, that attempts to resolve symbol references by searching for other occurrences of the symbol either in other code modules  already loaded into the respective protection domain , or in code modules loaded into other protection domains.","As illustrated in , a symbol table , with entry points , and a linking table , are provided. These tables are features of the VxWorks\u00aeAE operating system that can be used to achieve protected links between executable code in one protection domain  and resources of another protection domain, if desired.",{"@attributes":{"id":"p-0051","num":"0061"},"figref":"FIG. 9","b":["110","150","100","160","170","170","175","150","160","170","160","160","165","170","160","162","150","175","165","164","166"]},"Abstraction layer  provides a facility for partition OS's  to communicate with Core OS  (as will be further described below). Core OS  provides its own API, which is only accessible via abstraction layer .","Among the facilities provided by core OS  are a task data structure , a scheduler , a number of ready queues  and pending queues , and various service routines  (such as interrupt handling routines  and exception handling routines ). Task data structure  includes entries for each core OS task which exists in system . Each partition  also has an entry in the task data structure . A core OS task is created which executes the partition OSes. Within this core OS task, the partition OS provides a multithreading capability to support the various user tasks. This core OS task has an entry in the task data structure , as partitions are schedulable entities, and the task data structure  provides a convenient location for storing parameters associated with the partition .","Core OS  also includes certain pre-instantiated tasks \u2014referred to as \u201cworker tasks.\u201d Each partition  is preferably associated with at least one worker task . Worker tasks are tracked by a worker task data structure  (preferably maintained for each partition as a linked list). As described further below, worker tasks  may be used by partitions to perform core OS services that are blocking, thus allowing other ready tasks in the partition to execute.","Core OS  also includes a number of \u201cevent queues\u201d . Each partition has a corresponding event queue  located in core OS . As further described below, data related to events (e.g., system call complete, clock ticks) pertaining to a partition are stored in the event queue for delivery to the partition via the \u201cpseudo-interrupt\u201d facility.","Pursuant to a feature of the exemplary embodiment of the present invention, the core operating system  schedules partition operation to determine which partition operating system, partition user application pair is to execute at any particular time. The core operating system implements temporal partitions, preferably using a time-multiplexed schedule, between the partition operating system, partition user application pairs of the protection domain-defined spatial partitions .","A preferred time-multiplexed schedule is illustrated in . A timing sequence comprises a series of major time frames . The major time frames  are repetitive, and each major time frame  has a predetermined, fixed periodicity. In this manner, the major time frames  are deterministic. The basic scheduling unit of the major time frame  is a temporal partition , and there is no priority among the temporal partitions .","Alternative schemes for providing temporal partitions could also be used. For example, a priority based scheme could be used wherein the partition with the highest priority task (or other operation) is scheduled for a specified duration.","Returning to the time-multiplexed schedule of , at least one temporal partition  is allocated to each protection domain-defined spatial partition , and a protection domain-defined partition  is activated by allocation of at least one temporal partition  from within the major time frame  to the particular partition . Each temporal partition  has two attributes, an activation time within the major time frame  (in , indicated by t\u2013t) and an expected duration (in , indicated by \u201cduration1\u201d, \u201cduration 2\u201d). Each temporal partition is defined by an offset from the start of a major time frame  (the activation time) and its expected duration. The duration of each temporal partition is set in fixed increments. The value of the increments can be configurable.",{"@attributes":{"id":"p-0060","num":"0070"},"figref":"FIG. 10","b":["1205","112","1205","1210","1210","1215","1210","201","150","150","201","1205","200","1205","1205"]},{"@attributes":{"id":"p-0061","num":"0071"},"figref":"FIG. 11","b":["201","112","116","116","116","150","100","150","150","124","116","112","201"],"i":["a ","b ","b "]},"A data structure \u201cbudget\u201d is maintained to track the amount of time remaining in the current temporal partition . Core OS  includes a timer facility , which causes \u201cticks\u201d to be generated at regular intervals (which may be specified by implementation). Receipt of a tick by the scheduler  causes a decrement of the budget. Upon reaching zero, the temporal partition expires and a new partition must be scheduled.","According to the preferred embodiment, different scheduling \u201cmodes\u201d may be specified, for example, through the use of multiple linked lists in the schedule data structure . A data structure \u201cnext_schedule_index\u201d is maintained containing an index to the mode that should be used next from the schedule data structure . A data structure \u201ctransition\u201d is also maintained, containing an indicator of when the transition to the next schedule mode should occur. According to the preferred embodiment, this transition indicator can indicate a transition on the next tick, the end of the next temporal partition , or the end of the next major frame . Under normal operating conditions, the next schedule mode will be the current schedule mode, and the transition code indicator will cause a transition at the end of the next major frame  (thus causing the major frame  to repeat again).",{"@attributes":{"id":"p-0064","num":"0074"},"figref":["FIG. 12","FIG. 11"],"b":["1405","1410","1415","1420","1425","201","1205","1430","201","1435","1410","1425","1440"]},"Upon transition to a new temporal partition, the \u201cbudget\u201d data structure is loaded from the duration value in the entry for the temporal partition in the schedule data structure, and the \u201cready_Q_head\u201d pointer is adjusted to point to the top of the new combined ready queue (the kernel ready queue and the partition ready queue associated with the new spatial partition) (step ).","As shown in , not all the time available in a major time frame  may be scheduled to partitions. Such unscheduled time may be used by core operating system  for system operations or may simply be idle time.","Each partition operating system is preferably implemented as a user-level executable entity on top of the core operating system. In a preferred embodiment of the present invention, the partition operating system operation does not depend on the details of the core operating system. Rather, the partition operating system simply needs a specific set of services to be provided by the core operating system\u2014particularly services related to the underlying system hardware (e.g., I\/O operations, interrupts, exceptions). To provide this level of functionality, an abstraction layer  (see, e.g.,  discussed below) is preferably interposed between the partition operating systems and the core operating system.","Preferably, abstraction layer  is a thin layer of code that abstracts the specifics of the underlying core operating system, allowing the partition operating systems to run. In order to provide sufficient separation among the core operating system and the various partitions, it is advantageous to limit the number, and nature, of communication between the core operating system and each partition operating system. This architecture allows the core operating system to be used with multiple types of partitions operating systems (perhaps in the same overall system), and allows the partition operating system to run on more than one type of core operating system, with minimal changes. A particularly preferred embodiment of the abstraction layer will now be described, wherein the communication between the partition operating systems and the core operating system is limited to:","1. Core OS System Calls","2. Pseudo-Interrupts to the partition OS","In this embodiment, abstraction layer functionality resides in both the core operating system and each partition operating system. Each half of the abstraction layer understands the requirements and data format expected by the other half.","System calls are initiated by the partition operating system to request the core operating system to perform a desired service. In this example, there is only one system call API defined by the abstraction layer, which can multiplex all service requests. The partition operating system can request a core operating system service by issuing the system call with parameters indicating the requested service. This system call causes the abstraction layer to convert the call into an appropriate core operating system API call(s) which performs the desired service(s). Preferably, the set of system services (methods) that the partition operating system is allowed to request is limited and parameters validation is performed on all arguments passed via the system call.","In accordance with one preferred embodiment of the present invention, time management within a partition is accomplished through maintenance of a single timer queue. This queue is used for the management of watchdog timers, timeouts on various operations.","Elements on the queue are advanced when a system clock \u201ctick\u201d is announced to the partition operating system. Each tick denotes the passage of a single unit of time. Ticks are announced to the partition operating system from the core operating system through the \u201cpseudo-interrupt\u201d mechanism (specifically, through the system clock tick event). During initialization of the partition operating system, the current tick count maintained by the partition operating system will be set to equal the value of the core operating system tick count (as result, the tick count of each partition will be synchronized with each other and the core OS). Preferably, there are no limits on the clock tick rate that can be accommodated by the partition operating system, other than the available processor cycles that can be utilized by the system in servicing clock hardware interrupts and issuing pseudo-interrupts.","Preferably, clock ticks are only delivered to a partition during that partition's window of execution. When the core operating system schedules in a new partition, the clock ticks are then delivered to the newly scheduled partition via the system clock tick event. The issuance of clock ticks to the scheduled-out partition recommences at the start of the partition's next window. At this point, the core operating system announces, in batch mode (e.g., with a single pseudo interrupt), all the clock ticks that have transpired since the last tick announced to the partition in its previous window. In such a system, a timeout (or delay) can expire outside the partition's window, but the timeout is only acted upon at the beginning of the next partition window. It should be appreciated, however, that if a particular time out (or delay) is critical, the system integrator could simply increase the duration of temporal partition  for the corresponding spatial partition , or provide that a plurality of temporal partitions  be assigned to the spatial partition.","The batch delivery of clock ticks allows the core operating system to conserve processor cycles. Although the core operating system is still required to service the clock hardware interrupts, processor cycles are conserved by elimination of the overhead involved in issuing pseudo-interrupts, and the subsequent processing of the ticks within the various partition operating systems. This is particularly true for systems that require a timeout specification granularity of 0.25 milliseconds (which translates into 4000 ticks per second).","Further optimizations may be made to the tick delivery facilities in order to enhance the throughput of the exemplary system. One optimization permits a partition to specify that it does not need tick delivery for a certain number of ticks (e.g., no tasks require the updating of the tick count until \u201cX\u201d number of ticks have occurred). Once the threshold number of ticks have occurred, the core OS may deliver a single pseudo-interrupt representing all subsequent ticks that have occurred in the system. This optimization reduces the number of pseudo-interrupts generated (and handled), thus providing the system with additional productive cycles. Core OS  provides an API (which may be accessible to partition OS  via the system call facility of the abstraction layer ) allowing the partition OS to specify the number of ticks (relative to the current tick count) to wait until generating a System Clock Tick pseudo-interrupt. This value may be stored in a location in task control data structure  associated with the particular partition making the request.","Another optimization permits the core OS to reset the system tick counter prior to rollover. As ticks are accumulated on a periodic basis, at some point in time the quantity stored in the system tick counter will overflow, causing a reset. Although a system tick counter reset can be handled at the time of overflow, it may introduce unwanted, non-deterministic delays in overall system operation while the tick counter reset is performed and the associated variables are recalibrated. A facility is provided in core OS  which allows the core OS  to cause a system tick counter reset at a time which is most convenient for the overall system (i.e., the reset will have the smallest impact on system operation). Core OS  can detect such a condition based on scheduling workload information or other metrics. A similar facility may be provided in each partition OS, if desired.","Each partition may employ its own scheduler , having an independent scheduling algorithm. For example, tasks within a partition may be scheduled using a priority scheme. In a preferred embodiment of the present invention, the priority scheme is implemented in accordance with a pre-emptive priority-based algorithm. In such an embodiment, each task has an assigned priority, and in each partition, the partition operating system scheduler uses the priority assigned to each task to allocate the CPU to the highest-priority task within the partition that is ready to execute.","In a pre-emption based scheme, pre-emption occurs when a task of higher priority than the currently executing task becomes ready to run. In general, a higher-priority task may become ready to run as a result of the expiration of a timeout, or the new availability of a resource that the task had been pending on. Pre-emptive events are delivered from the core operating system to the partition operating system, through the pseudo-interrupt mechanism. These events, which may result in a higher priority task becoming available, include but are not limited to, the system clock tick and system call completed signals.","The scheduling of equal priority tasks can be implemented in a number of ways. For example, equal priority tasks can be scheduled on a first-come-first serve basis (e.g., using a queue of equal priority tasks). Alternatively, round-robin scheduling could be used. Preferably, the system allows the system integrator to select either round-robin scheduling or first-come-first-serve scheduling. Round-robin scheduling allows the processor to be shared by all tasks of the same priority. Without round-robin scheduling, when multiple tasks of equal priority must share the processor, a single non-blocking task can usurp the processor until pre-empted by a task of higher priority, thus never giving the other equal-priority tasks a chance to run. In accordance with round-robin scheduling, a \u201ctime slice\u201d (or interval) is defined which represents the maximum time that a task is allowed to run before relinquishing control to another task of equal priority. Preferably, the \u201ctime slice\u201d is a variable that can be set by calling an appropriate routine.","As described previously, when the partition operating system , or an application running in the partition operating system, needs to request a service from the core operating system, a system call is issued from the partition operating system to the core operating system via abstraction layer . If the system call is a blocking system call, then the core operating system assigns a worker task  to complete the request, and returns control to the partition operating system. The partition operating system then places the requesting task in the pend queue, and applies the scheduling algorithm to determine the next task that should be run. When the assigned core operating system task completes the system call, a system-call-complete pseudo interrupt is issued by the core operating system to the partition operating system. The pseudo-interrupt handler for the partition OS is executed, which retrieves the event data from the event queue. This event data, in the preferred embodiment, includes a cookie value, which allows the event to be matched to the task that is in the pending queue. The partition operating system can then determine if the pending task should regain the processor, in which case it pends the currently executing task and schedules the requesting task. Alternatively, the system could be designed such that, upon receiving the system call complete, the partition operating system places the task in the \u201cready\u201d queue (i.e., makes the task ready to run, but does not deschedule the current task).",{"@attributes":{"id":"p-0082","num":"0092"},"figref":"FIG. 7","b":["1070","160","112","1070","150","112","1070","150","1072","150"]},{"@attributes":{"id":"p-0083","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"OS_INVOKE_STATUS CoreOsInvoke ("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SYSCALL_METHOD","method,"]},{"entry":[{},"UINT32","*returnValue,"]},{"entry":[{},"UINT32","*methodErrno,"]},{"entry":[{},"UINT32","cookie,"]},{"entry":[{},"UINT32","argument1,"]},{"entry":[{},"\u2003..."]},{"entry":[{},"UINT32","argument n"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["method: An enumeration that specifies the core operating system service to be invoked.","returnValue: A pointer to an unsigned integer, which is de-referenced to store the return value from the system call.","methodErrno: A pointer to an unsigned integer, which is de-referenced to store the error number value (if any) set by the system call.","Cookie: A value that is unique to the requesting partition. Typically it is the ID of the partition operating system task that issued the request. This value has no significance to the core operating system. When the system call completes, the cookie is returned back to the requesting partition (e.g., via pseudo-interrupt), and assists the partition operating system in identifying the task whose request has been completed.","argument . . . argument n: The argument(s) that is passed to the core operating system function being invoked. There may be zero or more arguments to a system call, depending on the service requested.","OS_INVOKE_STATUS: enumerated result code of call. Can be one of OK, ERROR, PENDING, OSNOTREADY, or BADPARAMS."]}}}},"The core OS portion of the abstraction layer  provides a matching routine alOSInvoke( )  having similar parameters. Routine alOSInvoke( )  includes a facility  to perform parameter validation on parameters passed to it, and a Core OS API Dispatch facility  to map methodIDs to corresponding core OS  API system calls and execute the appropriate core OS API system call (if available).","As described above, the preferred abstraction layer  employs two internal layers via the coreOSInvoke( ) and alOSInvoke( ) routines. Any number of layers could be implemented (for example, only one layer), however the use of two layers within abstraction layer  facilitates the immediate pre-emption of blocked tasks currently executing in partition  (as will be further described below), which improves system performance.","The operation of the example of  is illustrated in flow chart form in . Assume task  executing in partition OS  has made a system call by calling coreOSInvoke( ) (step ). coreOSInvoke( ) makes a call to alOSInvoke( ) (step ). alOSInvoke( ) performs a parameter validation on the parameters provided by task  (step )\u2014for example, by checking to insure that the methodID specified is valid, that the returnValue and methodErrno pointers point to addresses within the partition's assigned memory space, and whether the arguments provided are valid for the method specified by the methodID (this may be done by mapping the methodID to a method-specific parameter validation routine). If the parameter validation fails, a BADPARAMS return result code is passed back to coreOSInvoke( ) (step ), which is then returned to task  for handling (step ).","If parameter validation is achieved, the Core OS API dispatcher is invoked (step ) to map the methodID to the appropriate core OS system call. As part of the Core OS API distributor, it is first determined whether the method being invoked is a blocking or non-blocking method (step ). If the method is non-blocking, it is executed in the partition's task context (step ), an OK return result code is returned to coreOSInvoke( ) (step ), which is then returned to task  (step ). If the method is blocking, it is then determined whether a worker task associated with the active partition is available (step ). This may be accomplished by examining the worker task data structure for the active partition and determining whether any worker tasks are not in use. If a worker task is available, the available worker task is assigned, made unavailable in the worker task data structure, and scheduled in the core OS (step ) and the return code PENDING is returned to coreOSInvoke( ) (step ). If a worker task is not available, return code OSNOTREADY is returned to coreOSInvoke( ) (step ).","As part of the coreOSInvoke( ) routine, a Partition Queue Adjustment function  is provided to check the return code for a code that will cause the currently executing task  to block (step ). For example, a return code of PENDING indicates that a worker task is blocked at the core OS, and therefore task  should also block pending the completion of the worker task. Thus, for a return code of PENDING or OSNOTREADY, the partition queue adjustment facility  places task  on the pending queue of partition OS  and causes the scheduling of the next ready task in the partition (step ). Task  will become ready upon receipt by partition OS  of a pseudo-interrupt indicating that the assigned worker task has completed (for the PENDING return code) or that any worker tasks have completed (for the OSNOTREADY return code).","Pseudo-interrupts are a way to provide asynchronous event notifications\/information from the core operating system to the appropriate partition operating system (as contrasted with a traditional hardware interrupt\/exception). A pseudo-interrupt system is illustrated in . In accordance with a preferred implementation, each partition  is provided with a corresponding event queue , located, for example, within core operating system . Each event queue  may be constructed as an array, with a number of locations to store event data elements (representing the occurrence of events). The format of an exemplary event data element may take the following form:",{"@attributes":{"id":"p-0090","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"VT_EVENT_TYPE\u2003\u2003evtType;\u2003\u2003\/* event type *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT32","data1;","\/* event data word 1 *\/"]},{"entry":[{},"UINT32","data2;","\/* event data word 2 *\/"]},{"entry":[{},"UINT32","data3;","\/* event data word 3 *\/"]},{"entry":[{},"UINT32","data4;","\/* event data word 4 *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} VT_EVENT;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As indicated, the exemplary event element includes a field indicating the event type (described below), and up to four 32-bit words of data. The amount and type of data passed depends on the event in question (for example, a \u201cSystem Call Complete\u201d event may put the cookie value passed by the calling partition as the event data, so that the partition can match the event to the task that made the system call). An exemplary set of events is as follows:","1. Power Interruption: reports power interruption","2. Synchronize: used by the core OS to detect whether the specified partion OS is executing a critical code section, such that access of OS data structures may produce inaccurate results. Useful for interactions with development tools.","3. System Clock Tick: reports the occurrence of a \u201ctick\u201d of the system clock, allowing each partition OS to receive synchronized time information.","4. Port Receive Notification: reports the receipt of a message in a destination buffer  (see , and accompanying discussion)","5. Port Send Notification: reports that of a message in a source buffer  has been sent (see , and accompanying discussion)","6. System Call Complete: reports the completion of a previously requested system call to the core OS that was dispatched to a worker task","It should be noted, however, that synchronous exceptions are not queued in this implementation. Rather, the core operating system re-vectors the program flow of the partition's code by directly changing the program counter (pc) to execute the partition's synchronous exception handler.","In the preferred embodiment, the size of each event queue  is pre-defined as the sum of all the possible events which may occupy the event queue for a particular partition. For example, since the number of worker tasks  is fixed for a particular partition OS, the number of slots in the event queue  reserved for System Call Complete events for that partition OS need only be the number of worker tasks  associated with that partition. One slot may be reserved for each of the Partition Restart, Synchronous Exception, System Clock Tick and Synchronize events. The utilization of such a fixed size event queue ensures that an event queue overflow will never occur.","Abstraction layer  includes a pseudo-interrupt facility . Pseudo-interrupt facility  performs two operations: posting an event to the event queue  of the specified partition OS , and raising a signal to that partition. Communication of the pseudo-interrupt is through the well-known signaling functionality (for example, as specified by the POSIX standard). An exemplary API for psuedo-interrupt facility  can be:",{"@attributes":{"id":"p-0101","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"STATUS alPseudoInt"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(",{},{}]},{"entry":[{},"PARTITION_ID","partId,","\/* Receiving partition ID *\/"]},{"entry":[{},"VT_EVENT_TYPE","evtType,","\/* Event being posted *\/"]},{"entry":[{},"UINT32","data1,","\/* Event data word 1 *\/"]},{"entry":[{},"UINT32","data2,","\/* Event data word 2 *\/"]},{"entry":[{},"UINT32","data3,","\/* Event data word 3 *\/"]},{"entry":[{},"UINT32","data4","\/* Event data word 4 *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["1","2","3","4","150","100","1078","125","112"]},"Each partition OS  implements one or more pseudo-interrupt handlers , which are executed upon receipt of the signal generated by pseudo-interrupt facility . One pseudo-interrupt handler  may be used, in which case a single signal may be used for all pseudo-interrupts. Alternatively, multiple pseudo-interrupt handlers  can be specified, for example, to handle different pseudo-interrupt events, in which case multiple signals may be used. In any case, pseudo-interrupt handler  will issue a system call to core OS  in order to dequeue the event that has been posted to the partition's event queue  (and retrieve any associated event data). The pseudo-interrupt handler  will then execute appropriate facilities to service the event.",{"@attributes":{"id":"p-0103","num":"0119"},"figref":["FIG. 15","FIG. 15"],"b":["100","122","112","1705","1710","1715","1720","1715"]},"If the exception identifier is listed, the exception handler then creates an \u201cexception stack frame\u201d on the stack of the executing task (step ). The exception stack frame may include various information about the state of the system at the time of the exception, including the contents of registers associated with the executing context. Execution is then transferred to an exception handler  of the appropriate partition OS (for example, by loading the program counter with the address of the exception handler ) (step ).","The exception stack frame data is then loaded (step ) and the appropriate partition OS exception handler is then executed (step ). The appropriate partition OS exception handler may be selected based on data stored in the exception stack frame, for example, through the use of a vector lookup table in the partition OS. The partition OS exception handler may perform any number of remedial operations, including suspending\/terminating the offending task. If the partition OS exception handler returns (e.g., the previously executing task was not the offending task), the previous context data is reloaded from the task stack (step ), and the previously executing task is permitted to continue execution.","Development of the system according to the present invention may require the use of development tools, such as provided as part of an integrated development environment (IDE). Such development tools are commonly used for development of software for systems implemented as so-called embedded computer systems, which may have reduced user interfacing capabilities (such as displays and data entry devices). The tools may be located on a separate computing system (a so-called \u201chost\u201d computing environment) with a link to the \u201ctarget\u201d embedded computing system (via a communication link such as an ethernet connection or serial link).",{"@attributes":{"id":"p-0107","num":"0123"},"figref":"FIG. 14","b":["1600","112","150","1600","1605","1610","1615","1620","100"]},"Core OS  includes a target agent . Target agent  provides services to communicate with target server  (for example, the WDB Protocol), such that requests\/commands from IDE  can be processed at target system . Target agent  operates as a task under core OS  (thus allowing it to be serviced as a scheduled task).","A single target agent  permits access by IDE  to core OS  and each partition . Correspondingly, only a single instance of each tool of IDE  may be needed to perform operations on core OS  and each partition . Since target agent  operates in core OS  as a core OS task, target agent  has a full system view and may access data structures throughout system , including kernel data structures for each partition OS .","A problem raised by the use of multiple independent partitions in the use of target agent  is insuring the data obtained from each partition is accurate. Due to the time and space partitioning, instances could arise where partition data could be left in an inaccurate\/inconsistent state at a point when a request is made to the target agent to retrieve such data. An example of such a situation is provided in .","In this example, partition # has started to delete a thread executing in partition #, but its temporal partition has expired prior to completion of the deletion process. The core OS schedules partition # upon expiration of the temporal partition, causing various ready threads existing in partition # to execute. Once the temporal partition associated with partition # expires (as well as any other intervening temporal partitions), core OS will schedule partition # again, and the thread deletion process may complete. The time from when the first temporal partition for partition # ends until the second temporal partition # begins may have an inaccurate task control block for partition #.","In order to prevent data inaccuracy, target agent  will cause the Synchronize pseudo-interrupt to be generated and sent to the partition from which system information is requested. The synchronize pseudo-interrupt will cause the partition pseudo-interrupt handler to execute, determine the identity of the pseudo-interrupt, and launch the appropriate service routine\u2014which in this case is a routine that performs a special system call to the core OS indicating that the partition OS is not executing a critical code section. If the partition OS is executing a critical code section (or if the partition is not active), the handling of pseudo-interrupts will be disabled, and thus no system call will be made (until pseudo-interrupt handling is enabled, causing the pseudo-interrupt handler to execute). Upon receipt of the system call, target agent  will be able to operate on the partition as needed.","Alternatively, communication between the target agent  and a partition OS  may be accomplished using semaphores. For example, each partition upon instantiation can be associated with two binary semaphores (e.g., \u201cSem\u201d and \u201cSem\u201d). Upon target agent  generating the Synchronize pseudo-interrupt, target agent  takes Sem for the partition for which data access is required, causing the target agent  to block. Upon handling the pseudo-interrupt, the pseudo-interrupt handler gives Sem (allowing the target agent  to unblock) and takes Sem, causing the partition to block. Target agent  can now operate on partition  as needed. Target agent gives Sem when its operations are completed, thereby unblocking the partition  and allowing the previously executing task to continue. The identifiers for Sem and Sem may be stored in a location in the task data structure  associated with their corresponding partition .","In order to implement the functionality of software logic analysis, each partition OS  includes instrumentation  which performs system calls to core OS  (for example, using the abstraction layer ) to log instrumented events. Core OS  includes a system event log , and a logging facility . Event buffer  may be implemented in a manner similar to that of other well known logic analysis systems, such as the WindView\u00ae software logic analyzer tool of Wind River Systems, Alameda, Calif. Event buffer  may include multiple buffers (allowing simultaneous upload and download), and the ability to store event data having timestamps (including sequential stamps), event codes and associated data. Logging facility  may implement an API that allows the passing of event information from a partition  to the event log , for example, as follows:",{"@attributes":{"id":"p-0115","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STATUS wvEventLogWrite"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(",{}]},{"entry":[{},"short","eventId,"]},{"entry":[{},"BOOL","timestamp,"]},{"entry":[{},"void * src,"]},{"entry":[{},"int","eventSize"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["169","160","170","169","150","132"]},"A complication of the simultaneous collection of event data from multiple partitions (and the core OS), is the proper interpretation of that data at the host tool, particularly where each partition may generate event data having disparate meanings. The embodiment according to the present invention includes a method to configure the host tool to properly interpret event data uploaded from event log , using event definition libraries.","The first events read from the event log upon initialization will be configuration data for the Core OS part of the log. In this configuration data will be an indicator that multiple partition data (also referred to as \u201cnamespaces\u201d) will be stored in the log. The core OS will provide a namespace identifier for itself, as well as a list of event definition libraries applicable to event data generated by the core OS. These event definition libraries may be included in the configuration data (and thus uploaded to the software logic analyzer  for reference during event log parsing), or may be already located on the host system (and then simply accessed directly by the software logic analyzer ). Following the core OS configuration data will be configuration data for each partition configured to generate event data. This partition configuration data will include a namespace identifier used to identify event data sourced from the particular partition, as well as a list of the event definition libraries to be used for the partition (and potentially event definition library lists\/data). Thereafter during event data collection, logging facility  may place \u201cnamespace selection\u201d events into the event log  prior to logging event data from a particular partition (e.g., a partition different from the most recently logged partition), the namespace selection event including the namespace identifier of the particular partition. Using the namespace selection events, source of the event data can be determined by the software logic analyzer, and the appropriate event definition library can be used to interpret the event data.","Pursuant to another feature of the present invention, a communication system is provided to permit the passing of messages between partitions . A message is sent from a single partition  to one or more other partitions . In the exemplary embodiment of the present invention, the communication system comprises ports, messages and a channel. Each partition that implements bidirectional interpartition communication includes a source port and a receiving port. A partition that does not require interpartition communication may include zero ports, and a partition that requires only one-way communication could potentially include only one port. The channel is a logical set of source and receiving ports for the transmission of messages.","Referring now to , there is illustrated an exemplary communication system for passing a message between two of the partitions . In this example, the sending partition includes a sender process , and the receiving partition includes a receiver process . Moreover, each of a source port  for the sending partition and a receiving port  for the receiving partition comprises a circular buffer implemented in the core operating system . Each circular buffer is defined by a set of attributes including, for example, an identification of the partition with which it is associated, and whether it is a source port or a receiving port.","A port driver  is implemented in the core operating system , and is operable to read messages stored in each source port  and to write the read messages into the receiving port(s)  of the partition(s) identified in the message as the receiving partition(s) When the sending partition needs to send a message to the receiving partition the sender process  formats a message, including, for example, a message descriptor to identify such information as source and destination of the message. The sender process  then writes the message into the corresponding source port  circular buffer in the core operating system . The sender process  then updates a write pointer. The port driver  reads each message in the source circular buffer and writes each read message into the receiving port  circular buffer of the receiving partition identified in the message descriptor of the message. According to the exemplary embodiment, of the present invention, each receiving partition periodically reads the messages stored in the corresponding circular buffer comprising the receiving port  of the partition A table of message descriptors can be maintained by the core operating system  to enable the core operating system  to track all messages.","In the preceding specification, the invention has been described with reference to specific exemplary embodiments and examples thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the claims that follow. The specification and drawings are accordingly to be regarded in an illustrative manner rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
