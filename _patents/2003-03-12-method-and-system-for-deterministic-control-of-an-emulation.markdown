---
title: Method and system for deterministic control of an emulation
abstract: An emulation-based event-wait simulator including an application module to configure and command verification processes on a design under test (DUT). An event dispatcher is in communication with the application module to deliver commands to the DUT. A plurality of transactors are in communication with the event dispatcher to forward the commands to the DUT. A channel controller is in communication with the transactors to process and forward the commands to the DUT, wherein the channel controller also receives messages from the DUT, processes the messages, and forwards the messages to the transactors for delivery to the event dispatcher and the application module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07472055&OS=07472055&RS=07472055
owner: Broadcom Corporation
number: 07472055
owner_city: Irvine
owner_country: US
publication_date: 20030312
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Transaction-Based Techniques of Embodiments of the Present Invention","Example SOC Embodiment","Example Implementation Embodiment"],"p":["This application claims priority to commonly assigned U.S. Provisional Patent Application No. 60\/384,390, filed Jun. 3, 2002, and to commonly assigned U.S. Provisional Patent Application No. 60\/430,048, filed Dec. 2, 2002, entitled METHOD AND SYSTEM FOR DETERMINISTIC CONTROL OF AN EMULATION, which are incorporated by reference herein in their entirety.","This invention relates generally to system and ASIC design verification, and more specifically, to deterministic verification techniques.","As system-on-chip (SOC) designs grow increasingly complex, the verification of those designs becomes more challenging. Recent trends in the electronics industry appear to show that verification has become the single most time-consuming part of a SOC design schedule. Thus, there is a need for broader, deeper system-level verification.","Conventional verification methods provide a means to test basic hardware functionality, but lack the throughput to handle system-level verification of complex SOC designs. This lack is apparent in designs that integrate multiple components on a signal chip. This lack exposes companies to substantial risks if design teams miss product delivery dates due to increased verification times, or worse, design errors that require expensive chip re-spins.","There are various approaches available to compensate for this challenge. For example, the need for higher verification speed can be addressed by creating specific C-test benches or using standard electronic design automation (EDA) tools interfacing directly with register transfer level (RTL)\/gates via standard programming language interface (PLI) calls. The increased productivity gained by this approach becomes insufficient, however, as the SOC design size increases.","This insufficiency in speed and efficiency reveals the verification bottleneck of simulating the register transfer level (RTL). Once this bottleneck is reached, system-level verification schedules often include a mixture of standard simulation to verify block, large block functionality, and partial chip-level functionality plus co-simulation, vector acceleration, prototyping, in-circuit emulation, or transaction-based verification. This second tier of verification was considered insurance in the past, but is now becoming a necessity to find the dreaded hidden corner-cases in large SOC designs.","Conventional solutions also include hardware-assisted techniques. These techniques use a co-simulation methodology that pairs a hardware design language (HDL) test bench with a high-speed hardware accelerator. In these approaches, the HDL test bench runs on the host workstation transferring data. The HDL test bench synchronizes with the hardware platform through an interface at each event exchange. This synchronization is a slow but necessary process for software simulation. Hardware accelerators can provide the advantage of dedicated parallel processors to distribute the evaluation of RTL\/gates events. For example, simulation speed increases up to a few thousand cycles per second for functional simulations, but slows down to a few hundred cycles per second for full-timing simulations. While this performance is excellent compared to software simulation solutions, it is still too slow for thorough system-level verification of SOCs.","Alternatively, data streaming is another technique. Data streaming can use a workstation, personal computer (PC), or other device, such as a vector-generation device to send bit-level vectors on a clock cycle or clock enable basis to a hardware accelerator or emulator. This approach works well in non-interactive systems that, once configured, perform a certain function repeatedly (e.g., formatting an MPEG block from incoming data). This technique can also be extended to interactive data streaming applications, but the increased number of vectors required make the techniques cumbersome. The overall verification speed slows down considerably because the vectors need to be generated, transmitted, received, decoded, tagged, compared, and stored by the data streaming device\/host processor.","Data streaming performance is usually limited by the streaming\/recording device to about 20-30 MHz for small width vectors in non-interactive applications. The speed of applications that use interactive data streaming is much slower, usually up to 10-100 kHz with a decline in speed as vector width increases. This is still much faster than conventional software simulation.","The trade-off between the various verification methods is often speed versus the productivity gained by having an automated netlist compiler, and the probing of the SOC design. Both these options offer the highest verification throughput (100 kHz to 20 MHz) and highest quality of verification, but usually require the development of a slowed-down target board to serve as a prototype that connects to a number of system interfaces. This prototyping to thoroughly verify system integrity (hardware, firmware, and software) is not always practical or possible in cases where the target system is not readily available or where the target system can not be slowed down. In many cases, slowing down a target system and other systems connected to it is the biggest impediment to the adoption of these verification methodologies.","An approach for verifying SOC designs accurately and with reproducible results is needed. Further, an approach for verifying SOC designs in a deterministic manner such that errors can be isolated quickly and completely is needed.","Accordingly, the present invention is directed to a deterministic emulator and associated hardware and software that substantially obviates one or more of the problems and disadvantages of the related art.","In one aspect of the invention there is provided an emulation-based event-wait simulator including an application module to configure and command verification processes on a design under test (DUT). An event dispatcher is in communication with the application module to deliver commands to the DUT. A plurality of transactors are in communication with the event dispatcher to forward the commands to the DUT. A channel controller is in communication with the transactors to process and forward the commands to the DUT, wherein the channel controller also receives messages from the DUT, processes the messages, and forwards the messages to the transactors for delivery to the event dispatcher and the application module.","In another aspect there is provided a system for evaluating performance of a device under test (DUT) including a deterministic emulator with a channel controller that receives data packets from an application module. A plurality of transactors forward the data packets to corresponding output channels to be transferred to the DUT.","In another aspect there is provided a system for evaluating performance of a device under test (DUT) including a deterministic emulator with a channel controller that receives data packets from an application module. A deterministically controlled clock within the deterministic emulator is responsive to commands from the application module. A plurality of transactors forward the data packets to corresponding output channels to be transferred to the DUT. The transactors gather the data packets while the clock is running, and forward the data packets to the corresponding output channels and hence, back to the software (application module), while the clock is stopped. While the clock is stopped, the output messages occur at the same \u201ctime\u201d, but they actually are transferred one at a time.","In another aspect there is provided a system that deterministically evaluates operations of a circuit design including an application module that determines a set of commands for execution by a DUT. A channel controller delivers the set of commands to the DUT. A source level debugger monitors the DUT during the execution of the set of commands. An event dispatcher receives a set of events from the DUT that includes results of the execution of the set of commands.","In another aspect there is provided a system that deterministically evaluates operations of a circuit design including an application module that communicates with an emulator that emulates the circuit design, and that awaits event notifications from the emulator. Transactor drivers receive responses from the emulator. The application module enters an event-wait state. Zero simulation time transpires for servicing the responses. These responses are translated into events that are handled by the event-wait simulator one level up, when all events are processed.","Further embodiments and features of the present inventions, as well as the structure and operation of the various embodiments of the present invention, are described in detail below with reference to the accompanying drawings.","The present invention will now be described with reference to the accompanying drawings. In the drawings, like reference numbers indicate identical or functionally similar elements. Additionally, the left-most digit(s) of a reference number identifies the drawing in which the reference number first appears.","The present invention is particularly applicable in situations where the actual design under test (DUT) is not practical to test in a pure emulation mode. For example, effectively testing all the corner cases on a cable modem head end may require arranging hundreds of cable modems to simultaneously send data to the head end being tested. This presents an obvious logistical and hardware challenge. Yet another situation that is difficult to test is the case of multiple I\/O channels all operating at different clock rates on the DUT. Another situation that may be difficult to test is slowing down a device that normally operates on a clock in the range. The task of slowing down the entire test fixture of hundreds of MHz to a low frequency in a KHz range may itself create difficult problems, or may not be possible.","The present invention provides methods and systems for an emulation-based event-wait emulator that provides for testing of complex designs. The emulator can operate with a design under test (DUT), and associated test hardware, or transactors, contained within it thus avoiding the need for a prototype or target hardware. The emulator provides deterministic behavior for interactive simulations through a combination of event queuing methods. In an embodiment, the DUT is stimulated with messages that include commands. These commands translate into one or more vectors for the DUT. DUT operations on these vectors are recorded and can be fed back to the emulator, which optionally provides additional input stimulus to the DUT.","In a further embodiment, an event-wait message protocol utilized in a transaction-based environment (operating in either or both emulation and\/or software simulation modes) operates over a communications application programming interface (API) to service multiple concurrent events. As the environment performs operations, events are generated between emulation and simulation modules. These events are encoded in a protocol in accordance with an embodiment of the present invention to optimize transmission and reception with the DUT. The ability to service multiple concurrent events provides the environment with a realistic evaluation of the DUT. In one embodiment, a protocol is employed within a bi-direction physical communication layer.","In accordance with additional embodiments of the present invention, a method and system for deterministically controlling an emulation environment is described. The method models actual signal information as events with a discrete time simulator that allows for the creation of stimulus in response to the events. In one embodiment, the emulator and simulator are logically coupled and controlled by a timer queue module and event-loop module. The timer queue module orders callback events so that it can return the emulation time for a given signal. The event-loop module arbitrates processing to the emulator that is waiting for event notifications, i.e., notification that events have been processed and\/or the results obtained by processing the events.","An embodiment of the present invention uses a transaction-based emulation system where the emulated design is implemented as a synchronous, cycle accurate equivalent representation of the original design such that the clock for the emulated design can be stopped and restarted without causing any malfunction of the emulated design.","In one embodiment, the present invention includes transactors that communicate via messages. The transactors can operate in parallel. They manage the platform\/driver(s) (PCI, Ethernet, etc.) and the flow of data to and from the DUT. Input messages can provide stimulus information to the DUT. The DUT forwards data to the transactors, which, in turn, generate output messages. The system includes a clock module that communicates with the transactors and can stop the system or one or more transactors. This eliminates the possibility of inherent non-deterministic simultaneous operation in the system, such as, e.g., asynchronous or reply acknowledge messages.","An embodiment of the present invention includes a channel controller capable of operating with both the emulation and simulation components of a transaction-based environment. The channel controller controls all of the message traffic between the transactors and the software simulator. Whenever one or more transactors require servicing, they each generate an output message to the channel controller. The channel controller processes each message and sends it to the application module.","Event- and Transaction-Based Methodologies","Transaction-based simulation combines the best qualities of homegrown C-test benches, standard EDA tools, and in-circuit emulation. This results in sophisticated software test benches that stimulate the SOC as if it were on a target system. Transaction-based simulation can link abstract models of the system running on a workstation with the detailed RTL\/gate level implementation running on an emulator. In some embodiments, the foundation is a transaction interface with a high bandwidth, and a low latency physical connection between the emulator and workstation (application module).","Transactions include high-level commands (Command\/Address\/Data) that can be sent from a software C driver to an RTL transactor that drives a particular interface of the DUT. These high-level transactions translate into one or more vectors for the DUT. Several orders of magnitude of improvement in performance may be achieved by reducing the amount of interfacing between the test bench and the emulator (which can include the DUT), and taking advantage of the inherent speed of the C-test bench and emulator. Transaction-based verification enables exhaustive tests of complex designs without the need for a prototype or target hardware. In addition, it can be operated in several modes to allow users to take full advantage of emulation speeds and verification methodologies. Thus, the transaction based verification of the present invention overcomes the limitations of software simulation performance and leverages the expressive power of high-level software development.","Emulation-Based Event-Wait Simulator","The Event-Wait Message Protocol is an algorithm built on top of a communication API to service multiple concurrent events. In this environment, the software is in total control of the simulation\/emulation being performed. It generates all of test stimulus and controls all hardware simulation clock cycles. Note that the application module (the \u201csoftware\u201d) and the device-under-test (the \u201chardware\u201d) never execute concurrently. This maintains determinism and repeatability throughout the run.","First, a software Event Manager collects a list of relevant events from the registered software components. Typically, these components will be mostly made up of stimulus generators, but may include data collectors or other DUT related pieces of support code.","Next to the Event Manager, the TimerQueue is the most important software component. It collects and sorts a list of timeout requests from the registered components. This timeout list is the primary mechanism for determining how long the hardware emulation should run before returning control to the software. The Event Manager asks the TimerQueue for the shortest registered timeout period, sets the timeout value, then enters the \u201cevent-wait\u201d loop. At this point, the software is dormant until a relevant event, including but not limited to the expiration of the timer, is detected.","In the event-wait loop, the middle, or transactor driver, layer of software sends a clock advance command to the hardware to start simulating for the programmable amount of time. The DUT now performs operations based on the stimulus or configuration provided by the application software. During this time, the DUT sends multiple service request messages back to the transactor layer. Every time a message is sent across the interface, hardware operation is stopped until serviced by all the software layers. Upon receipt of a service message callback, the software exits out of its event-wait loop to service the hardware. If appropriate, the transactor layer generates an event to indicate to the application module that a specific condition has occurred. The Event Manager then distributes the event to the registered recipient. In the case of a timeout event, the Event Manager passes control to the TimerQueue, which then distributes the event notification to the one or more objects waiting for that specific amount of time to expire.","Once the application software has serviced the event, the sequence starts over again.","The \u201cevent-wait\u201d algorithm enables communication with numerous tools\/models used in an ASIC verification environment (both software and hardware assisted). Without it, multiple parallel threads happening in the design under test would have difficulty being deterministically controlled in software. This capability, in essence, converts an emulation environment into a \u201cquasi-simulation\u201d environment.","A transaction-based verification system according to an embodiment of the present invention is shown in . In , system  includes an application module , an event dispatcher , and a thread control . Also included are transactor drivers , a transport layer module , a physical layer module , a channel controller , RTL transactors , and a communications integrated circuit (IC) that includes at least one DUT .","The application module  is described here and in further detail below with respect to . The application module  provides the commands that will be used to test the DUT . The application module  is in communication with the event dispatcher  as well as to the thread control .","The event dispatcher  is in communication with the transactor drivers , as well as to the thread control . The event dispatcher  controls the timing of stimulus (commands and events) and includes part of the wait-timing logic described herein with regard to the event-wait protocol. The event dispatcher  provides notifications to components so events happen in an order that is required by testing conditions set by the application module .","The thread control  provides control over the one or more threads of stimulus to the DUT . The thread control  communicates with the components of the application module  and the event dispatcher .","The transactor drivers  are variously configured interfaces for communicating with the RTL transactors . Logical communication path indicates the flow of stimulus to and from the drivers , through the channel controller , and to the RTL transactors . The transactor drivers  are in communication with the event dispatcher .","The transport layer module  provides the stimulus through interfaces to the communications layer module . This is the physical transport path for stimulus within the system . As shown in , one example of module  includes a multi-channel transport\/standard co-emulation (MCT\/SCE) application programming interface , Transaction Interface Portal API application program interface (TAPI) , and peripheral component interface (SPCI) card . Interfaces provide connectivity for the transactor drivers  to the emulation environment of modules -. The transport layer  is in communication with the transactor drivers .","Stimulus is provided by path to the physical layer . As shown for example purposes, co-model macros and I\/O controller are included in module . Modules  provide the stimulus, commands and\/or events, which in one embodiment are messages\/stimulus, to the channel controller .","The channel controller  is in communication with the physical layer . The channel controller  receives stimulus originating from the event dispatcher  and the RTL transactors . The channel controller  is also in communication with the RTL transactors .","The RTL transactors  are in communication with the communications IC . The RTL transactors provide the interface to the various ports being utilized to access the DUT . Thus, conceptually,  may be thought of as having hardware on the right-hand side and software on the left-hand side. In other words, the hardware on the left-hand side may be put into a hardware box, i.e., the RTL code can be synthesized. Everything on the right-hand side of  represents an emulator.","There are any number of ways of implementing the transport layer (boxes  and  of ). TAPI is one way, and the use of an SPCI board that resides on a PCI back plane communicating with a set of co-model macros , is also one particular way of implementing the invention, but the invention is not limited to this particular transport layer hardware.","In this particular implementation, the SPCI card and the co-model macros support reads and writes of either 512 bits or 1024 bits.","TAPI is the software layer on top of the SPCI card that interprets a read or write command from the application module  and converts them into stimuli. TAPI repackages the test vector (the 512 or 1024 bits) into a number of different transfers across the interface. A particular card used in one embodiment transfers data 86 bits at a time, so the test vector is packaged into a number of PCI transactions that take place via the SPCI card . The SPCI card packages them on the left-hand side of , and the I\/O controller on the right-hand side unpackages them. The I\/O controller receives the stimuli and reverses what the SPCI card did, reconstituting the vector into 512 or 1024 bits, and giving it to the co-model macros . The co-model macros are thus part of an asynchronous interface that syncs up with the DUT .","MCT is essentially a set of specifications for transmitting data across the interface, and provides a mechanism for how data should be used in transaction-based form, but does not itself specify any details on how to implement actual operations. The inputs and outputs to the MCT are a set of APIs for reading and writing.","The interaction between the transactor drivers  and the MCT includes a \u201cdata set\u201d and a \u201cdata get\u201d, which is analogous to data writes and data reads. The data, as noted above, is essentially a vector going across the interface. The channel controller  takes the data and routes it to the appropriate RTL transactors .","The transactor drivers  are essentially functions that perform particular tasks. For example, suppose that on the application module  side there is an internet packet that needs to be transmitted, (for example, an Ethernet) packet. Once the packet has been created, a function needs to be called that will transmit the packet from the application module  to the appropriate RTL transactor  to stimulate the DUT . The transactor drivers  do exactly that. A set of APIs is called that transfers data to the RTL transactors , or transfers data from the RTL transactors  through the channel controller , and the lower level transport layer back to the transactor driver . Thus, there is a set of commands for each interface, for example, Ethernet, 10baseT, 100baseT, GB, UART, PCI 32 bit, PCI 64 bit, MPEG, MPEG with DOCSIS, custom standards for cable modems, USB, memory interfaces, SDRAM, etc.","Each packet to be transmitted includes a header and a payload. The header is based on the interface standard. A packet is received, for example, from the DUT and captured by the RTL transactors . On the RTL transactor  side, the packets are received, including the preamble and the header and any other overhead. Once the packet is received, an event happens that physically stops the hardware side, and sends the entire packet to the transactor driver . The MCT layer recognizes that a message has been received and that it needs to generate a callback. Thus, the transactor driver  gets the callback, reads the entire packet, and puts it in a buffer. At this point, the packet is ready for processing, for example, where the application module  can compare the received packet with the expected packet.","Thus, the transactor drivers  are a mechanism of encoding and transmitting information to the emulator, or, if the information is already pre-encoded, then it only needs to be transmitted (without a need for encoding). Then, the transactor drivers  receive callbacks from the emulator, and decode it. Alternatively, instead of decoding, the transactor drivers  can move the data up to the event dispatcher , or the application module .","The role of the transactor drivers  is illustrated in . As shown in , the transactor drivers  include a transactor tool that is used to encode packets for the various interfaces, for example, the PCI interface, the GMI\/MII interface, the USB interface, the Ethernet interface, etc. The transactor drivers  communicate over the physical layer  and the transport layer  with the channel controller , which in turn uses transactors  to communicate with the DUT .",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 1B","b":["124","126","126","124","128"]},"In addition to regular data being sent back and forth between the hardware side and the software side, each of the transactors  also can monitor error conditions, such as parity errors, and status information being transmitted, which is specific to each particular interface.","Thus, the transactors  transmit and receive data to and from the DUT . When the transactors  receive data, if the transactor  receives a message from the application module  requesting more data, the transactor driver  will provide it with more data. When the transactor driver  finishes providing the additional data, then another event is generated at the transactor , indicating to the application module  that it is done with the transmission of the data, and requesting instructions from the application module  for what to do next. Whenever the transactor  completes the operation, it generates an event that is interpreted by a higher-level module.","On the emulation side, there are at least two clocks\u2014a high-speed clock (uncontrolled clock, or UCLK) that is free-running and is used by the control logic and the channel controller . There is also a controlled clock (CCLK), and clocks derived from CCLK, which are ultimately controlled by the application module  by means of a clock advancer. The channel controller , upon command from the application module , instructs the CCLK to run continuously, run for a preset number of cycles, or not run at all. Upon instruction from the application module , the CCLK in the emulator can advance by, for example, 100 nsec, or whatever time increment the application module  wants.","With the use of a controlled clock, the present invention allows for testing of a DUT  with multiple input\/output channels. It enables loading the transactors  with test vectors for multiple channels during \u201czero simulation time,\u201d and then, upon restarting of the clock CCLK, flooding the DUT  with data on multiple (or all) channels. This avoids the situation of having latency and mis-synchronization affect the outcome of the testing. This also allows all events that are meant to occur synchronously to actually be synchronous, without concern for the latency and other transmission effects of the simulation\/emulation setup. Phrased another way, it allows for a deterministic emulator, or an emulator with deterministic clock control.","The transactors  send data to the application module , and the operation of the hardware is stopped until the application module  responds with the message that it is in an event-wait loop. This is a form of an acknowledge message.","Each RTL transactor  is in charge of starting and stopping its transmission of data, and stopping the clock CCLK at the correct time. Generally, the clock CCLK is stopped whenever the transactor  runs out of data to transmit, and it is still in an operational mode (e.g., for one processing cycle, or for a number of processing cycles). Thus, if an Ethernet transactor  transmits data, it will stop the controlled clock CCLK inside the emulator and will send a message to the software side, indicating that it completed the task that it was commanded to do. In other words, it generates a callback (see  and discussion below). At the application level, the application module  receives the callback, indicating that the transactor  finished transmission. Thus, the time can be advanced forward, to simulate no activity. In other words, the transmission of data between the hardware side and the software side is not on a clock-by-clock basis but is on an event-by-event basis, forming the basis for a high-level event simulator.","A transactor , at the RTL level, is a state machine that takes the commands sent by the application module , and sequentially transmits it to the pins on the DUT interface, to stimulate the DUT .  illustrates the relationship between the channel controller  and the transactors A-N. As shown in , the transactors  have uncontrolled clock UCLK as input. The transactors also have a bus with message-in data, message-out receive ready, and message-in transmit ready. The channel controller  is essentially an interface between an asynchronous domain and a synchronous domain.  shows the interface between the channel controller  and RTL transactors A-N, which uses a tri-state multiplexed bus for data going between the channel controller  and the RTL transactors .","Note that the application module  can interact with the DUT  through high-level commands. The present invention therefore provides a bandwidth allocation mechanism, based on the event-wait algorithm. A number of transactors  can be queued up with data, regardless of the speed of the pipeline (interface) connecting the application module  with the DUT . The determinism of the emulator is maintained because the hardware stops until a message from the application module  is received, directing the emulator to restart (i.e., directing the CCLK to restart).","The event-wait algorithm is implemented in the event dispatcher , and uses time stamps to track when events occur. In one embodiment, pseudo-threads are used in the thread control module , to keep track of events.","The source-level debugger, in one embodiment, may be a special transactor that monitors each and every operation of the DUT  (for example, a MIPS microprocessor, or a Verilog implementation of a MIPS microprocessor). A tool called Trace Gate monitors every operation of the MIPS microprocessor, which has a gated clock, and sends a message back to the application module  every time an instruction is executed. These messages are then used to connect the MIPS processor instructions to generic debug tools.","Another tool is called Bus Device which provides additional encoding\/decoding functions based on the interface type in response to a callback. Another \u201cabstract class\u201d provides members of the Bus Device with mapping to various addresses internal to the DUT  (e.g., MIPS, MAC, peripheral, etc.) By switching the abstract class, it is possible to access the internal addresses through the various different interfaces, without having to modify the source code.","Thus, the channel controller  provides the application module  control of multiple, independent parallel transactions. The channel controller  functions as a transport layer in a software\/hardware communications protocol. It provides fine control of the emulation (control) clock CCLK so that message exchange occurs in a deterministic manner. In other words, the channel controller  effectively causes the emulator to work like a very fast, cycle-based simulator. The input and output halves of the channel controller  may be independent designs. The input half, which is shown in , includes an input macro , which is interfaced to a message input register , which in turn is interfaced to the transactors , as shown on . The input macro  provides the interface to the physical data cable leading back to the work station on which the application module  is running. The active message in Msg_In_Transmit_Ready [N:0] is decoded from the seven bits of the tipCommand defined as the input port ID.","The output portion of the channel controller  is illustrated in . As shown in , the channel controller  includes a priority encoder  for transactor output messages, with a handshake back to the transactor . A controlled cycle counter  is used to keep track of the CCLK clock status. Cycle count registers  are also used in conjunction with the cycle counter  and a cycle stamp multiplexer  to keep track of the CCLK clock time. This time is transmitted every time Msg_Out_Transmit_Ready [N:0] goes active.","Output macro interface latches and handshake logic  is used for multiplexing of selected output messages and cycle stamps to the output macro , which in turn acts as the portal across the physical cable to the work station on which application module  is running.","Determinism is achieved by forcing messages between the emulator and the application module  to be \u201czero time events\u201d. An output message stops the controlled clock CCLK. Control is then given to the application module , which processes beginning with the callback function bound to the output port that sent the message. Before the application module  returns control to the emulator, it sends a special, \u201cenable\u201d message to the channel controller \/clock advancer, which re-starts the controlled clock CCLK if:\n\n",{"@attributes":{"id":"p-0090","num":"0091"},"figref":["FIG. 1G","FIG. 1G","FIG. 1G","FIG. 1G"],"b":["104","110","104","128","104","104","110","104","110","104"]},"In , the various modules of the application module  are illustrated, according to one embodiment of the present invention. Module  can include a packet generator , an application control , an output queue , an input queue , a packet encoder , a packet decoder , a packet router , and a test scenarios module . The components of module  are described in additional detail in , discussed below.","The test scenarios  include the information that determines how the other components of the application module  are to be configured. In one embodiment, the test scenarios  are specialized based on the DUT . In an alternative embodiment, the test scenarios  are specialized based on the type of conditions that are being tested in the DUT . The queues  and , and coders  and  are instantiated based on the requirements of the test scenario  to forward and receive stimulus from the packet generator . The packet generator  generates the commands (i.e., stimulus for the DUT) based on the requirements of the test scenario . The application control  manages the modules of the application module , and ensures that the test scenario is properly executed. The packet router  tags and routes packets, both commands and returning events to the proper output and input queues -. In an embodiment of the present invention, more than one of modules - are instantiated in the module .","In , according to an embodiment of the present invention, various transactors are shown. Ethernet transmit , Ethernet receive , PCI master , PCT slave , Memory module , and other drivers  are illustrated. These drivers represent various interface types that can be implemented as transactor drivers in module . These drivers provide the various modes of communication, utilizing specific APIs. These drivers are often determined based on the type of testing required and\/or the type of design being tested, i.e., does the DUT include Ethernet, PCI and\/or other components that either require testing and\/or are required for testing. The memory module  provides an interface to external memory used by the DUT (such as a SDRAM).",{"@attributes":{"id":"p-0094","num":"0095"},"figref":["FIG. 4","FIG. 1A","FIG. 1A"],"b":["122","122","122"]},"Briefly, in , an application module  is in communication with an event dispatcher  as well as a thread control . The event dispatcher  is in communication with a transactor drivers module . The module  is in communication with a transport layer . The transport layer  is in communication with a physical layer . The physical layer  is in communication with a channel controller . The channel controller  is in communication with a bus . The bus  is in communication with one or more RTL transactors . The transactors  are in communication with the communications IC , which includes one or more DUT(s).","The software target system embodied by the application module  generates sequences of transaction stimuli, i.e., commands\/data, that are designed to match real-world operations to the DUT. During verification, these stimuli are queued and scheduled by the modules , , and  for transmission to the DUT at specific times. The commands simulate the behavior of an actual system. In turn, transaction responses, i.e., events, from the DUT are received by the module . The events can be recorded for later review or viewed in real-time, i.e., after each set of commands generates a response. The results can be compared with expected or predicted responses.","The creation and maintenance of transactors  in the user environment is important. Transactors  can be developed in parallel with the hardware design in a software simulation environment. For example, the transport layer  and physical layers  are provided with a standard programmable language interface (PLI) which mimics the behavior of its hardware components. These PLIs can be used with standard hardware description language (HDL) simulators to run slow speed simulations of the system at the register transfer level (RTL). Once they are tested at this level, they can be compiled directly into an emulation environment.","This provides the capability of having a unified, structured co-modeling environment that uses software simulation for initial functional and timing verification of basic operation and emulation for exhaustive functional testing.","A number of SOC designs can be verified using the transaction-based verification environment of the present invention. Complete regressions can be run in less clock time than a single process in a continuous software simulation.","By raising the level of abstraction, transaction-based simulation allows more complete verification of the SOC and expands the verification possibilities, such as, in one embodiment, applying directed Monte Carlo techniques. With a software target system in place, application software developers with system-level modeling skills can directly contribute in the hardware verification. This provides an additional perspective on hardware verification by enabling software developers to build sophisticated verification scenarios without needing to understand the detailed hardware implementation.","In , a block diagram illustrating the connectivity of the modules of the application module with other components of the system is displayed. Application module  is in communication with thread control  and event dispatcher . The application module  provides the test scenarios for the system. In one embodiment, the test scenarios are loaded onto their own module (module ). The test scenarios can include the commands for the other modules of the system, as well as timing information and notification rules so that events, such as callback events, can be handled by the system.","These commands are forwarded to the thread control  and the event dispatcher . The thread control  initializes and verifies components of the system. The event dispatcher  registers objects for the test scenarios so that timed events will yield the proper callback event. The callback events, as described in additional detail elsewhere herein, provide confirmation that a specific condition in the DUT has occurred, i.e., an error condition or a successful end of process condition. The event dispatcher  provides, according to an embodiment of the present invention, a timer queue that provides the global clock for the system. The timer queue allows for discrete control of event_wait loops, and thus, control over the advancement of time within the system.","The modules  and  provide commands and clock advancement control, respectively, to packet generators -, where n represents any number of packet generators. In one embodiment, threads are instantiated for testing in the system of the present invention by the creation of one or more of packet generators . The packet generators  are typically independent of each other and provide commands to the one or more packet queues -(e.g., either output queue  or input queue ). The packet queues -can be configured to handle packets based on category, destination, or similar feature. In one embodiment, the packet queues -can provide automatic verification of the commands.","The stimulus to the DUT is structured as commands and events, which are formed into packets and transmitted through the components of the present invention. While the present invention makes use of packets, it is not limited to forming and operating with stimulus only as packets. As one skilled in the relevant arts would recognize, based at least on the teachings herein, other forms of transport can be utilized.","The packet queues -can be in communication with one or more sets of interfaces. A first set of interfaces -can be in communication with the emulator and\/or application module  and forward commands to the application module . A second set of interfaces -can be in communication with the application module  and forward events from the application module  to the packet queues -","During the process of developing the transaction-based verification environment, we discovered that there are several natural modes of operation.","Data Streaming","Dividing a transaction model into its C driver and RTL transactor is a design consideration of efficiently creating a system that provides for a maximizing of speed, maintainability, and flexibility. In some cases, it is effective and simpler to generate vectors in software and stream them directly to the emulator. This is particularly advantageous for users that want to use vector-based regressions in both simulation and emulation. Vectors can be algorithmically generated in C and created via other tools such as Matlab or can be real-life data captured with a recording device. Conversely, data streaming can also record data in a regular, periodic manner from the pins of a chip interface and send it back to C as vectors. Often, this data is simply put into a file and post-processed. Thus, data streaming and transaction simulation are important features of a verification system.","Memory Interfacing","Memory transactors can be multi-ported memories with ports connected to a transaction interface and other ports connecting to the SOC as standard memories, such as SDRAM, SRAM, EEPROM, and so on. From a high level C test bench, memory transactors improve the programmability of software. Memory models with transaction interfaces can be loaded and unloaded at very high speeds (e.g., up to speeds of approximately 64 Mbps).","In addition, tests for memory locations of conditions can be done at any time during the simulation run. In one embodiment, when the memory requirements are beyond the capacity of an emulation main memory, external RAM boards can be attached to the emulator using traditional in-circuit I\/O connections. In this case, the memory transactor becomes a wrapper interface to these external memory boards. Various verification embodiments can be devised utilizing the access provided by memory transactors, i.e., memory that is external to the SOC as well as internal memories.","Loose Simulations","Front-end DUT verification has two main components: hardware design and software development. Usually both components can operate disjointedly throughout most of the project. This is because the hardware design can run bounded test cases on the DUT implementation, and the software development can provide applications and firmware by using abstract software models of the DUT.","Nevertheless, at some point the software side removes these abstract models and tests the application code and firmware against the DUT. In some cases, if prototyping or in-circuit emulation is not used, this usually occurs with the delivery of the first silicon. Transaction-based verification can bring both sides together sooner, so the actual firmware and software application or portions of the application (depending on the size and complexity) can be run with a system before the DUT is available in silicon form. This allows for hardware changes to fix overall system problems found in software integration.","Typically, during the software verification stage, testers are more concerned about running their applications on a real asynchronous system. Simulation determinism has not been as important as raw speed during this part of the verification cycle, since checking specific corner cases in the hardware is not the primary objective. Verifying the software is the primary objective, so loosely coupled behavior that can give a close approximation to the real system is the preferred mode of operation for transaction-based environments.","A transaction-based environment of an DUT design with a CPU core running a real-time operating system (RTOS) provides benefits to software verification. A virtual prototype of the SOC can be provided and a programming interface for it developed.","According to one embodiment of this transaction-based environment, a set of transactors can be developed. Memory transactors can be used to pre-load data and instruction sets prior to the start of simulation and also to peek and poke into memory during simulations. A UART transactor can be used that allows interaction with the RTOS through a terminal window. This allows testing the DUT and software code prior to either tape-out or other processing. Actual diagnostics can be debugged (e.g., at the source level, as described elsewhere herein) and can run prior to any real silicon availability. In essence, the environment provided by the present invention yields the software and hardware for an executable verification of a specification on system running actual code.","Deterministic Simulations","During hardware verification, simulation runs need to be completely deterministic for designers to isolate failures. Software simulators work this way because of their single thread of execution. If separate processes are used (such as a PLI), the inter-process communication takes place in zero simulation time, leaving the sequence of simulation events deterministic. Parallel processes are running, one in the emulator and one or more in the software of the simulator. Thus, indeterminate behavior is possible between separate runs of the same simulation due to the varying relative speeds and process execution in the multi-tasking operating system (e.g., Unix).","The present invention provides for multiple threads of execution, as described herein. In one embodiment, deterministic operation prevents the emulator from running at the same time as the simulator. The exception to this rule is, when running, the application module does not send an asynchronous command or input to the running emulator that causes a change of state to the DUT (e.g., loading a transactor memory buffer that is almost empty). When the software and emulator are running concurrently and the application module sends a transaction to the emulator, there is no way of knowing at what absolute time that transaction arrived at the DUT, and determinacy is lost. Therefore, the ability to accurately start and stop the emulation clock is an approach to implementing deterministic behavior. The event dispatcher  and channel controller  modules can provide this clock control when using a compliant API\/PLI.","While determinism enhances process control, there is a reduction in the overall system speed from stopping the emulator clock. Exemplary embodiments have shown that operating in fully deterministic mode can reduce speed to about half the maximum given by the emulation clock speed if the clock is left free running (i.e., the extreme loosely-coupled case).","The transaction-based verification environment does not require determinism, but as the following example shows, it can be implemented to identify errors. For example, in one embodiment, during the verification of a DUT design, a strange behavior may be recorded in one of the first-in first-out buffers (FIFOs) during real-time verification. Managing this behavior can be impossible, since the particular failure\/outcome may not be easy to repeat. In a deterministic system in accordance with an embodiment of the present invention, the failure can be quickly identified and fixed after at least two runs: one run to find out when in time the error occurred; and the second run to record the data for corrective purposes.","Hardware Assisted Transaction-Based Performance","Speed is an important factor in verification, but it often ranks behind determinism. Where one could achieve less than a second of real-time operation through software simulation, transaction-based simulation allows one to deterministically run several minutes of real-time operation. In general simulation, speeds can be bounded by the software running on the workstation and not by hardware speeds. This is a switch from traditional software simulation where test bench C software is much faster than the simulation software.","The availability of virtually unlimited verification cycles has a profoundly positive impact on verification strategy. With traditional verification methodologies, one can typically create test cases designed to optimize as much functional coverage as possible within a given number of available verification cycles. With this constraint removed, one can create and run tests that were not previously possible. Accordingly, this significantly increases the amount of verification that can be done as well as the functional coverage that can be obtained.","Transaction-based verification unites disparate design areas including system architecture, RTL design, system integration, and software engineering. It integrated these areas early in the development process. System architecture can receive implementation feedback of the overall system functionality during the RTL verification phase. RTL design can augment their targeted block\/SOC-level hardware tests with random or exhaustive testing techniques. System integration has a very powerful tool to verify silicon with real world tests, and then debug potential failures by running those real world tests in a transaction-based environment. Software engineering can work with the hardware design on software\/hardware integration before a prototype is available. All of this provides the tools to build quality systems on schedule.","By providing orders of magnitude of improvement in verification performance, transaction-based verification changes the nature of SOC verification. Transaction-based verification facilitates integration of software code and hardware design by allowing for system level verification and characterization of the complete system. Most importantly, by providing comprehensive visibility into system-level functionality before a tape-out, it offers an effective verification solution for uncovering the hidden corner case conditions in highly integrated SOC designs: eliminating expensive silicon re-spins and time-to-market delays.","The system-level verification challenges described herein prompted the development of the transaction-based methodology of the present invention. This methodology allows C models running in a workstation to communicate with the design under test (DUT) running in an emulator. This methodology can dramatically improve the verification capabilities for next-generation devices.","In simulation environments, packets of data are input through one or more interfaces, processed by the ASIC, and then output on other interfaces.  shows an example of such an ASIC with a few standard interfaces connected to the DUT. In , a DUT  includes ingress ports  and egress ports . Ports  and  allow for the transport of the packets of data through the system. Processor , general purpose I\/O (GPIO) , memory , and Ethernet  are optional components that provide the DUT with additional testing functionality.","Simulation scenarios, typified in , are built to test as many critical corner cases as possible. These check at the block and ASIC level. Once the data path and corner-cases are checked at the functional and timing level, the ASIC is considered verified. In one embodiment, this type of design increases in size, increased verification requirements can be met by sending the additional simulations to a simulation farm.","With today's highly integrated DUT designs, a difficult verification problem arises when complex control and state machines are present. The methods described herein for ASIC verification checks this complex data flow, as well as the corner-cases of DUT design.","The number of corner-cases at the DUT level is often too difficult to compute. As a result, the DUT can fail once an illegal state is reached. This can happen at any time and is extremely difficult to debug in silicon. The level of verification required finding this type of failure is usually not attainable with traditional simulation methods, because of the hundreds of millions of cycles required to provoke these types of errors.","To complicate matters, generating the stimulus (i.e., the commands) to find the hidden corner-cases is very difficult. At least three solutions are available to solve this problem. The first is to keep track of all state machines in the DUT, and make sure each state and state transition is hit during the verification process. Once all states and combination of states are verified, the design is comprehensively tested. Unfortunately, creating an environment to keep track of these states imposes severe restrictions on RTL designers.","The second solution is to use a prototype or in-circuit emulation of the DUT. This verification method almost always guarantees functional operation of the first silicon, but requires effort to build a target board, slow down the target system interfaces, and locate it in an asynchronous environment (non-deterministic checking). In some cases, like those where the DUT is part of a new system whose other parts are in development, it is not possible to build a target board.","A third solution is to use software to pseudo-randomly stimulate the DUT in a transaction-based emulation environment. The controlled stimulus and collection of data in and out of the system verifies the DUT design as if operating in the real system. As the stimulus arrival times are throttled and actual data varied, the hidden corner-cases fall out. This method requires creating an interactive C-level verification environment, specifically a transaction-based solution.","To implement the environment, application developers build software target systems directly coupled to emulation through a physical layer API using standard GNU C and C++ tools. The software target system provides control, configuration, and stimulus from a C-level test bench via high-level, standard transaction interfaces.","Transaction interfaces or transactors can have two parts: a C driver and an RTL transactor. By calling the C driver from the software target, pseudo randomly generated traffic scenarios are played and compared against the DUT implementation at a high level of abstraction. Utilizing a modular, object-oriented suite of data generators, queues, event handlers, and result checkers, the application software allows for the creation of verification scenarios that quickly uncover illegal states and hidden corner cases.","RTL transactors can be designed for standard platforms\/protocols such as Ethernet and PCI (as well as custom transactors). RTL transactors can be created for each distinct DUT interface, and compiled into the emulator with the DUT design. These RTL models convert transactions into the pin level accurate I\/O of the DUT. For example, a PCI burst read transaction would generate a complete, functionally accurate bus protocol performed by the RTL transactor. According to embodiments of the present invention, the transaction interfacing described herein has the benefit of reducing communication between the workstation and emulator, and allowing the emulator to run for multiple clock cycles at a time. Both of these factors can yield improved verification performance.",{"@attributes":{"id":"p-0134","num":"0135"},"figref":"FIG. 7","b":["128","128","704","706","704","708","708","708","708","704"],"i":["a","e","a","e "]},"Memory modules  and  are also in communication with the processor  and provide storage and\/or buffering capability to the processor . PCI module  and Ethernet module  are in communication with the processor . The modules  and  are also in communication with the downstream processor . The PCI module  provides a PCI interface between the upstream processor  and the downstream processor . The Ethernet module  provides an Ethernet interface between the upstream processor  and the downstream processor . A memory module , similar to the memory modules  and  is in communication with downstream processor , and provides storage and\/or buffering capabilities. The downstream processor  is in communication with at least one downstream channel .","In one embodiment, the operational flow of data involves the data being forwarded to the upstream processor  via the upstream channels -. The processor  then processes the data. During processing, the processor  is able to access the memory modules  and . Post-processed data is forwarded through either or both of modules  and  to the downstream processor . The downstream processor , with access to memory module , can further process the post-processed data before forwarding it to downstream channel .",{"@attributes":{"id":"p-0137","num":"0138"},"figref":["FIG. 8A","FIG. 7"],"b":"800"},"In system A, the application module  can include a number of modules, as described in other embodiments herein. Main.c module includes the operating logic for the application module . Packet generator  receives commands from both an application control  and DUT software application(s) (described below), and generates the appropriate packets. The packets are forwarded to the appropriate queues \/. The queues \/ forward the packets to the modules of the thread control and event API , described below. The application control module  instantiates and configures the components of the system A based on the requirements and\/or parameters of the test scenarios defined by the DUT software application(s) . The packet decoder  is an optional component that can decode, and in some embodiments, encode (as described above with respect to a packet encoder), the packet received from the packet queues \/.","The thread control and event API  can include a thread control module  and an event dispatcher . As described elsewhere herein, the thread control  handles the scheduling of events and forward commands to the packet generator . The event dispatcher  controls the event_wait loop state, object registration, and receives events, such as callback events from the other components of system A. The thread control and event API  are in communication with the driver API layer .","In one embodiment, the driver API layer  includes numerous drivers including, but not limited to, memory.cc , Ethernet Tx.cc , Ethernet Rx.cc , PCI master.cc , PCI slave.cc , and Custom I\/F.cc . The memory.cc is a shared memory area for the transactor drivers of the driver layer . The other drive modules provide the driver services for which they are named. For instance, drivers and provide transmit and receive Ethernet services, respectively. Similarly, drivers and provide PCI services. The custom I\/F.cc driver provides customized driver services based on the specifications of the DUT software application(s) . In an embodiment, the driver is not instantiated.","The driver layer  is in communication with a transport layer . The transport layer  is in communication with a physical layer . In one embodiment, stimulus is transported between the software centric components and the hardware centric components. The physical layer  is in communication with a channel controller .","The channel controller  allows for deterministic operations in the system by working in conjunction with the application module , and layer , to provide clock advancement and latency counter features at the hardware level. In an embodiment, the channel controller  includes the ability to control the clock cycles in the DUT . In another embodiment, the channel controller  operates with the DUT  as a primary transactor. The channel controller  is in communication with the channel controller bus .","The bus  is in communication with one or more transactors . In one embodiment, an Ethernet Tx transactor , Ethernet Rx transactor , PCI master transactor , PCI slave transactor , Custom I\/F transactor , and Memory transactor  are in communication with the bus . This configuration can be called a common memory transactor embodiment because the memory transactor  is in communication with a SDRAM memory module and DUT memory module . The memory transactor  providing memory transaction functionality for both these modules.","The transactor modules  are in communication with the DUT cores  within the DUT . In one embodiment, one or more of the DUT cores  can be located external to the DUT , such as, for example, when modules that relay data to one or more external cores are being tested in the DUT .","The Ethernet transactor Tx and Ethernet transactor Rx are in communication with an Ethernet core within the DUT . Test signals are delivered to the core by the transactor , processed by the core , and the post-processed data forwarded to transactor . In one embodiment, when an error condition is shown in the post-processed data, the transactor forwards a callback event to the channel controller  which in turns forwards it back to the application module .","The PCI transactor modules and are in communication with a PCI core . The PCI core operates in a similar fashion as the core , providing processing of data. In one embodiment, however, as the PCI architecture demonstrates, both the master and slave transactors transmit and receive data.","A custom I\/F transactor is in communication with a custom core ","The SDRAM memory is in communication with the SDRAM core of the DUT . The core provides for the testing of the DUT's memory design. As previously mentioned, the DUT memory can be included within the DUT  and provides memory access with the DUT .",{"@attributes":{"id":"p-0149","num":"0150"},"figref":["FIG. 8B","FIG. 7"],"b":"800"},"The individual memory transactor embodiment of system B is equivalent to the system A with the following modifications to the transactors and the DUT . The memory transactors are reconfigured such that the DUT memory and SDRAM memory are no longer in communication with the memory transactor . In the embodiment as shown, the transactor  is replaced with transactors  and  which directly interact with the respective modules. The SDRAM memory is in communication with the SDRAM transactor , which is in communication with the bus . The DUT memory is in communication with the DUT memory transactor , which is in communication with the bus .",{"@attributes":{"id":"p-0151","num":"0152"},"figref":"FIG. 9","b":"900"},"In step , the test scenarios are instantiated in the application module . The test scenarios can include configuration information for the application control to utilize in configuring the system of the present invention. The routine then proceeds to step .","In step , the test scenarios provide for the configuration of the components of the system of the present invention. These components can include the application control module , as well as the event dispatcher  and\/or thread control module . The routine then proceeds to step .","In step , the application control module  is initialized with the commands to be provided to the DUT . The application control module  can also include the other commands for components of the system of the present invention, e.g., one or more transactors , memory modules, or core modules located external to the DUT . The routine then proceeds to step .","In step , the application control module  initializes the other remaining modules. These modules can include the packet generator , queues , , decoders , and other components of the system that take their timing from the application control module . The routine then proceeds to step .","In step , the event dispatcher  receives registrations from the other components of the system so that it can properly forward commands to the packet generator(s) . The routine then proceeds to step .","In step , the test scenarios are used to configure the modules of the application module , such as the packet generator  and packet queues , , with the commands that they will be processing and forwarding to the interfaces of the present invention. The routine then proceeds to step .","In step , the event dispatcher  is provided with the events for which it is to monitor the system for. The routine terminates.",{"@attributes":{"id":"p-0159","num":"0160"},"figref":"FIG. 10","b":"1000"},"In step , the system enters a run state command from the application module . The modules and components of the system begin operations at this point. The routine then proceeds to step .","In step , the application control determines, based on the test scenario, the amount of programmable time to operate the system in a run state. The routine then proceeds to step .","In step , commands are forward by the application control. These commands are determined based on the programmable amount of time. In one embodiment, the test scenarios forward the selected commands to the thread control module  for delivery to the packet generators . The routine then proceeds to step .","In step , the processed commands are delivered as messages, e.g., one or more packets of data, to the DUT . The routine then proceeds to step .","In step , the event dispatcher  sends a clock advance command, which is paralleled in hardware by the channel controller  to the DUT . The routine then proceeds to step .","In step , the event dispatcher then holds the software systems with an event_wait loop. The routine then proceeds to step .","In step , the DUT , having received the message and being advanced in time, beings to perform operations.",{"@attributes":{"id":"p-0167","num":"0168"},"figref":"FIG. 11","b":"1100"},"In step , the reception of data messages from the DUT  causes the system to halt the DUT's operations so that the data messages, which can include one or more events, is processed. In one embodiment, the channel controller  halts the DUT  and forwards the messages to the thread control  and event dispatcher  modules. The routine then proceeds to step .","In step , the application module  receives the messages from the DUT . These messages include information about the services being performed by the DUT  and can include one or more events. The routine then proceeds to step .","In step , the messages are processed and any callback events are received. The callback event is, according to an embodiment of the present invention, a message informing the application module  that a specific condition exists or has occurred in the DUT . The routine then proceeds to step .","In step , the reception of the data messages causes the system to terminate the event_wait loop and begin processing the messages and any events. In one embodiment, the events can trigger the application module's delivery of further stimulus to the DUT . The routine then proceeds to step .","In step , the application module  can optionally retrieve additional data from the DUT . In one embodiment, the operations of the DUT  can produce data as the result of calculations or the interaction of the various components of the DUT . The data generated by these activities can also be useful in the verification process. The routine then proceeds to step .","In step , the system determines if the event(s) warrant further notification to other components of the system. If yes, the routine then proceeds to step . In no, the routine then proceeds optionally to step .","In step , the system generates a simple event to those components to indicate that a condition has occurred or is present in the DUT . The routine then proceeds to step .","In step , the system can optionally store the event(s), data and\/or stimulus so that further processing can occur offline and external of the system. Optionally, the routine then proceeds to step . Otherwise, the routine then proceeds to step .","In step , the application module  determines additional commands to be delivered to the DUT . The routine then proceeds to step .","In step , any additional commands are delivered to the DUT . The routine then proceeds to step .","In step , the DUT  resume operations. The routine then proceeds to step .","In step , the system enters the event_wait loop.",{"@attributes":{"id":"p-0180","num":"0181"},"figref":"FIG. 1H","b":["1601","1602","128","1603","1604","104","1605","1607","1608","1605","1607","1605","1606","1601"]},{"@attributes":{"id":"p-0181","num":"0182"},"figref":["FIG. 12","FIGS. 1A-8B"],"b":["1200","1200"]},"Data processing unit  may represent personal computer(s), hand held computers, workstation(s), and\/or any other type of data processing devices. Which type of data processing device used to implement entities shown in  is implementation specific.","Data processing unit  includes a communication medium  (such as a bus, for example) to which other modules are attached.","Data processing unit  includes one or more processor(s) , and a main memory . Main memory  may be RAM, ROM, or any other memory type, or combinations thereof.","Data processing unit  may include secondary storage devices , such as but not limited to hard drives  or computer program product interfaces . Computer program product interfaces  are devices that access objects (such as information and\/or software) stored in computer program products . Examples of computer program product interfaces  include, but are not limited to, floppy drives, ZIP\u2122 drives, JAZ\u2122 drives, optical storage devices, etc. Examples of computer program products  include, but are not limited to, floppy disks, ZIP\u2122 and JAZ\u2122 disks, memory sticks, memory cards, or any other medium on which objects may be stored.","The computer program products  include computer useable mediums in which objects may be stored, such as but not limited to optical mediums, magnetic mediums, etc.","Control logic or software may be stored in main memory , secondary storage device(s) , and\/or computer program products .","More generally, the term \u201ccomputer program product\u201d refers to any device in which control logic (software) is stored, so in this context a computer program product could be any memory device having control logic stored therein. The invention is directed to computer program products having stored therein software that enables a computer\/processor to perform functions of the invention as described herein.","The data processing unit  may also include an interface , which may receive objects (such as data, applications, software, images, etc.) from external entities  via any communication mediums including wired and wireless communication mediums. In such cases, the objects  are transported between external entities  and interface  via signals. In other words, such signals include or represent control logic for enabling a processor or computer to perform functions of the invention. According to embodiments of the invention, such signals are also considered to be computer program products, and the invention is directed to such computer program products.","While specific embodiments of the present invention have been described above, it should be understood that they have been presented by way of example only, and not limitation. It will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined in the appended claims. Thus, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS\/FIGURES","p":["The accompanying drawings, which are incorporated herein and form a part of the specification, illustrate the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the pertinent art to make and use the invention.","In the drawings:",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 1D-1E"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 1F-1G"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1H"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 8A","FIG. 7"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 8B","FIG. 7"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
