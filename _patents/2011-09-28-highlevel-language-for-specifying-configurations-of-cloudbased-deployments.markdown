---
title: High-level language for specifying configurations of cloud-based deployments
abstract: A high-level object-oriented specification language allows configurable components of a cloud-based deployment to be modeled by a class definition that includes a group of configurable class parameters. The object-oriented specification language supports extension of an existing base class definition to create new class definitions, and supports inheritance of class parameters from the existing base class definition by the new class definitions. A cloud-based deployment can be customized based on class definitions used in configuring one or more generic deployments, such as by modifying class parameter values of the class definitions, varying interrelationships between the classes, and supplementing existing class parameters with new class parameters. The high-level object-oriented specification language supports class definitions that model hardware and virtual resources as well as software roles and service roles served by software applications and services in a cloud-based deployment. Syntax for specifying dependency and connectivity between classes is also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08261295&OS=08261295&RS=08261295
owner: Google Inc.
number: 08261295
owner_city: Mountain View
owner_country: US
publication_date: 20110928
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims under 35 U.S.C. \u00a7119(e) the benefit of U.S. Provisional Application No. 61\/453,478, filed Mar. 16, 2011, which is hereby incorporated by reference in its entirety.","This specification relates generally to cloud computing. Cloud computing is a computing model developed to enable convenient, on-demand network access to a shared pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that can be provisioned and released quickly, dynamically, and with minimal manual management efforts and human interactions with the service providers.","A few common cloud-based service models include, Software (e.g., commercially-available software applications) as a Service (SaaS), Platform (e.g., hosting environment of software applications, such as virtual machines or application frameworks) as a Service (PaaS), and Infrastructure (e.g., compute power, storage, database, networking services, etc.) as a Service (IaaS). Before a cloud-based service is made available to a cloud-service customer, various aspects of the service are configured according to a configuration specification, such that when the service is deployed, it meets the customer's needs and usage demand.","This specification describes technologies relating to use and management of cloud computing environments.","In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of: receiving a configuration specification for configuring a cloud-based deployment, the configuration specification being written in an object-oriented specification language and requiring instantiation of respective class definitions of one or more classes, each class modeling a respective data or functional component of the cloud-based deployment using a group of configurable class parameters, and the respective class definition of each class representing a requested state of the data or functional component modeled by the class; deriving a plurality of API calls for configuring the cloud-based deployment based on the class definitions of the one or more classes; and causing the plurality of API calls to be executed to configure the cloud-based deployment.","In some implementations, the one or more classes include at least an existing base class and at least a customized class extended from the existing base class. The customized class inherits respective class parameters of the existing base class and the customized class modifies a value of at least one of the class parameters inherited from the existing base class or includes at least one new class parameter not present in the existing base class.","In some implementations, the data or functional component modeled by each class is one of a virtual device supporting a cloud-based environment, a service utilized in the cloud-based environment, a software role performed by an installed application in the cloud-based environment, a data package holding data to be used during deployment or operation of the cloud-based environment, or a combination of one or more thereof.","In some implementations, the object-oriented specification language supports dependency between class definitions, and a definition dependency between a first class and a second class represents a deployment dependency between respective components modeled by the first and the second class.","In some implementations, the definition dependency between the first class and the second class is expressed by a class parameter of the first class where the class parameter of the first class refers to an instance of the second class.","In some implementations, the object-oriented specification language supports connectivity between class definitions, and a value assignment linking an instance of a second class to a class parameter of a first class represents a connectivity between respective components modeled by the first class and the second class.","In some implementations, the methods further include the actions of: identifying, based on the respective class definitions of the one or more classes, a plurality of data and functional components modeled by the one or more classes, and one or more dependency and connectivity relationships existing among the plurality of data or functional components; and deriving a block diagram of a cloud-based environment based on the identified plurality of data and functional components and the identified dependency and connectivity relationships.","In some implementations, deriving the block diagram further includes representing trigger events for dynamic reconfiguration of the cloud-based environment in the block diagram.","In some implementations, the methods further include the actions of: for each of the one or more class definitions: identifying an aspect of the cloud-based deployments that are influenced by the class definition in terms the respective initial configuration state of the aspect; monitoring one or more performance metrics associated with the identified aspect; associating the one or more performance metrics with the class definition; and utilizing the one or more performance metrics in calculating a quality metric of the class definition.","In some implementations, the methods further include the actions of: identifying a plurality of cloud-based deployments each having been carried out according to a respective configuration specification written in the object-oriented specification language; identifying at least one base class whose class definition is used in multiple of the plurality of cloud-based deployments; monitoring respective performance of each of the multiple of the plurality of cloud-based deployments; and calculating a quality metric of the at least one base class based on aggregated performance of the multiple of the plurality of cloud-based deployments.","In some implementations, the respective performance of each of the multiple of the plurality of cloud-based environment is a performance associated with a data or function component modeled by the at least one class.","In some implementations, the methods further include the actions of: storing respective class definitions of a plurality of core classes of the object-oriented specification language, each core class corresponding to a modular component of a cloud-based environment, each core class being extendable with additional class parameters to configure the respective modular component; storing a mapping between each of the core classes and a respective group of API calls, the respective group of API calls for configuring the modular component associated with the core class according to the class parameters of the core class; and storing a plurality of protocols for modifying the respective groups of API calls associated with each core class to obtain a new group of API calls for a new class definition derived from the core class.","In some implementations, deriving the plurality of API calls for configuring the cloud-based deployment further includes deriving the plurality of API calls based on the respective groups of API calls associated with one or more of the plurality of core classes from which the one or more classes of the configuration specification are derived, and based on the plurality of protocols for modifying the respective groups of API calls.","In some implementations, the plurality of protocols further includes rules for imposing an ordering of the groups of API calls according to dependency and connectivity relationships specified in class definitions written according to the object-oriented specification language.","In general, another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of: receiving a respective definition submission from each of a plurality of definition suppliers, wherein the respective definition submission includes one or more class definitions written in an object-oriented specification language, and each class definition models a data or functional component of a cloud-based deployment using a group of configurable class parameters and is extendable to create at least one new class definition by a modification to one or more of the group of configurable class parameters or an addition of one or more new class parameters; and providing a user interface that presents the class definitions received from the plurality of definition suppliers, for review and selection by a plurality of definition users.","In some implementations, the methods further include the actions of: receiving a plurality of distinct configuration specifications written in the object-oriented specification language, the plurality of distinct configuration specifications each for configuring a distinct cloud-based deployment and including a distinct class definition that extends from a same one of the class definitions received from the plurality of definition suppliers; and configuring each of the distinct cloud-based deployments based at least on the same one of the received class definitions and the distinct class definition that extends therefrom in the distinct configuration specification of the distinct cloud-based deployment.","In some implementations, the methods further include the actions of: for each of the received class definitions: monitoring usage of the class definition in a plurality of configuration specifications that have been used to configure a plurality of cloud-based deployments; and recording, for each use of the class definition in the plurality of configuration specifications, a credit to a definition supplier of the class definition and a charge to a definition user associated with the use.","In some implementations, the usage of the class definition includes an instantiation of the class definition in a respective configuration specification that has been used to carry out a respective cloud-based deployment.","In some implementations, the usage of the class definition includes an extension of the class definition to create a new class definition that is instantiated in a respective configuration specification used to carry out a respective cloud-based deployment.","In some implementations, the methods further include the actions of: receiving a software submission from a software supplier, the software submission including a software application to be deployed in a cloud-based environment and a plurality of distinct configuration specifications each for deploying the software application in the cloud-based environment in a distinct manner; and providing the plurality of distinct configuration specifications for review and selection by a software user.","In some implementations, the methods further include the actions of: receiving selection of one of the plurality of distinct configuration specification by the software user; deploying the software application in the cloud-based environment according to the selected distinct configuration specification; and recording a charge to the software user and a credit to the software supplier based on a respective price associated the selected distinct configuration specification.","In general, another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of: providing a plurality of class definitions for selection, each class definition modeling a respective data or functional component of a cloud-based environment using a group of configurable class parameters, each class definition supporting instantiation and inheritance of the class definition in a configuration specification for a cloud-based deployment; deriving respective performance metrics associated with each of the plurality of class definitions based on aggregated performance of multiple cloud-based deployments, wherein the multiple cloud-based deployments had been carried out according to respective configuration specifications that require instantiation of the class definition or a new class definition derived from the class definition; and utilizing the respective performance metrics associated with each of the plurality of class definitions in ranking the plurality of class definitions.","In some implementations, the methods further include the actions of: categorizing the plurality of class definitions based on the respective data or functional components of the cloud-based environment modeled by the plurality of class definitions; and ranking the plurality of class definitions within the class definitions' respective categories.","In some implementations, providing the plurality of class definitions for selection further includes providing the respective performance metrics with each of the plurality of class definitions for user review in a selection user interface.","In some implementations, the methods further include the actions of: for each of the plurality of class definitions: identifying a plurality of cloud-based deployments that had been carried out according to respective configuration specifications that required instantiation of the class definition or at least one new class definition derived from the class definition; monitoring respective performances of the plurality of cloud-based deployments; and associating the respective performances of the plurality of deployments with the class definition.","In some implementations, deriving respective performance metrics associated with each of the plurality of class definitions based on aggregated performance of multiple cloud-based deployments further includes: for each of the plurality of class definitions: identifying one or more data or functional components in the plurality of cloud-based deployments that were configured according to the class definition or a new class definition derived from the class definition; identifying one or more performance metrics associated with the identified one or more data or functional components; and deriving the respective performance metrics associated with the class definition by aggregating the identified one or more performance metrics.","In some implementations, the performance metrics include one or more measures of latency, reliability, scalability, availability, or security.","In some implementations, the methods further include the actions of: for each of the plurality of class definitions: tracking a respective count of cloud-based deployments that have been configured at least in part according to the class definition; and utilizing the respective counts associated with the plurality of class definitions in the ranking of the plurality of class definitions.","In some implementations, the methods further include the actions of: for each of the plurality of class definitions: tracking a respective count of problems encountered in cloud-based deployments that have been configured at least in part according to the class definition; tracking a number of required changes to resolve the problems encountered in the cloud-based deployments that have been configured at least in part according to the class definition; and utilizing the respective counts of the problems and the respective numbers of required changes associated with the plurality of class definitions in the ranking of the plurality of class definitions.","In some implementations, the respective numbers of required changes associated with the plurality of class definitions are used to calculate respective weights given to the respective performance metrics associated with the plurality of class definitions in ranking the plurality of class definitions.","Other embodiments of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods. A system of one or more computers can be so configured by virtue of software, firmware, hardware, or a combination of them installed on the system that in operation cause the system to perform the actions. One or more computer programs can be so configured by virtue having instructions that, when executed by data processing apparatus, cause the apparatus to perform the actions.","Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages.","A high-level object-oriented specification language allows configurable components of a cloud-based deployment to be modeled by a class definition that includes a group of configurable class parameters. The object-oriented specification language supports extension of an existing base class definition to create new class definitions, and supports inheritance of class parameters from the existing base class definition by the new class definitions. An administrative user of a cloud-based service can customized a cloud-based deployment based on class definitions used in configuring one or more generic deployments, such as by modifying class parameter values of the class definitions, varying interrelationships between the classes, and supplementing existing class parameters with new class parameters.","The object-oriented specification language allows multiple layers of abstraction to be made on the different types of cloud-service components that are configurable. For example, the high-level object-oriented specification language not only supports class definitions that model hardware and virtual resources, but also software roles and service roles served by software applications and services in a cloud-based deployment. In addition, the object-oriented specification language provides syntax for specifying dependency and connectivity between classes. Cloud components that involve multiple sub-components and complex structures can be modeled by class definitions that refer to multiple types of base classes and specify respective interrelationships between the base classes.","A configuration specification can rely on existing class definitions to configure some aspects of a cloud-deployment at a high level of abstraction, while customizing other aspects at a more detailed level using newly derived class definitions. An administrative user of a cloud-based service is able to control the level of customization for a cloud-based deployment by choosing an appropriate set of class definitions to include and instantiate in the configuration specification for the cloud-based deployment.","In addition, the object-oriented specification language allows many class definitions that model common or special purpose cloud-service components to be created and stored. These stored class definitions can be extended or reused as is in configuration specifications of future deployments by different cloud-service customers. This reuse of class definitions in specification configurations can improve the speed and efficiency of the deployment process.","Because class definitions can be reused and shared among many cloud-service customers, the efforts for developing suitable configuration specifications for the same or similar purposes do not have to be duplicated by the cloud-service customers. A marketplace for sharing reusable class definitions can be developed, such that a cloud-service customer can choose to purchase or license the use of existing class definitions developed and provided by other cloud-service customers for a fee. In addition, software applications can be provided with different types of configuration specifications (i.e., as \u201cconfig-wrapped\u201d software solutions) that are suitable for different usage demands and organizational infrastructures of the cloud-customers.","When a configuration specification of a cloud-based deployment is written in the object-oriented specification language, the cloud-service provider is able to parse the configuration specification to identify the class definitions that are involved in configuring each data or functional component of the cloud-based deployment. Further, when the deployment is carried out according to the configuration specification, the cloud-service provider is also able to identify the underlying software or virtual resources associated with each of the data or functional components of the deployment. Therefore, the object-oriented specification language enables the cloud service provider to monitor the performance of the data and functional components of the cloud-based deployment, and associate the performance with the class definitions that are used to configure each of the data and function components. Thus, the cloud-service provider can provide guidance to the cloud-service customers on which parts of the configuration specification needs to be modified to improve the performance of the deployment.","In some implementations, the cloud-service provider can generate a block diagram for the cloud-based deployment based on the configuration specification. The performance of the different components of the deployment can be visually represented on the block diagram. Various reconfiguration triggers specified in the configuration specification can also be represented in the block diagram. This visual representation allows an administrator of the cloud-based deployment to adjust the configuration parameters of the deployment timely and appropriately.","The object-oriented specification language allows class definitions to be reused in multiple configuration specifications, and potentially by multiple cloud-service customers. The cloud-service provider can track the performances of multiple cloud-based deployments that have been configured using configuration specifications involving reused class definitions. For each reused class definition, the cloud-service provider can evaluate the quality of the class definition based on the aggregated performance of the multiple deployments that have been configured using the class definition. In a marketplace for sharing reusable class definitions, a ranking or quality scores of the class definitions based on the quality of the class definitions can be provided. This ranking or quality scores help cloud-service customers to better select the class definitions to reuse in their own cloud-based deployments. The ranking or quality scores may also help providers of reusable class definitions to improve their class definitions.","The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.","Like reference numbers and designations in the various drawings indicate like elements.","In a cloud computing environment, cloud-service customers (e.g., end users or enterprises) obtain access to software, platform, and\/or infrastructure services through one or more networks (e.g., the Internet). The cloud-service customers are able to scale the service level (e.g., in terms of service type, quality, and amount) up and down as needed, for example, through configuration user interfaces provided by the cloud-service providers, and\/or through programmably-established configuration specifications stored at the cloud-service providers. Correspondingly, a cloud-service provider pools resources and serves its customers via a multi-tenant model, where physical and virtual resources are assigned and reassigned, configured and reconfigured according to customer demands. The locations of the physical resources underlying the cloud infrastructure are not exposed to the cloud-service customers and can change dynamically.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 1","b":["100","100","102","104","106","102","104","102","104","104","108","102","104","102","104"]},"In one example, the cloud-service provider  is conceptually structured in multiple layers. The lowest layer is the firmware and hardware layer  on which other layers of the cloud-service provider  are built. The firmware and hardware layer  includes generic contributing nodes (e.g., data centers, computers, and storage devices) geographically distributed across the Internet and provide the physical resources for implementing the upper layers of the cloud service provider .","Above the firmware and hardware layer  is the software kernel layer . The software kernel layer  includes the operating system  and\/or virtual machine manager  that host the cloud infrastructure services provided by the cloud-service provider . The software kernel layer  controls and communicates with the underlying firmware and hardware layer  through one or more hardware\/firmware-level application programming interfaces (APIs). The hardware\/firmware-level APIs can be provider-specific and implemented to support Hypertext Transfer Protocol (HTTP) and HTTP Secure (HTTPS) based communications protocols. Examples of provider-specific APIs include Amazon Web Services APIs, Google App Engine APIs, and Microsoft SQL Azure APIs.","The infrastructure services provided by the cloud-service provider  include virtualized resources, such as virtual machines, virtual storage (e.g., virtual disks), virtual network appliances (e.g., firewalls), and so on. The infrastructure servicers also include virtualized services, such as database services, networking services, file system services, web hosting services, load balancing services, MapReduce services, message queue services, map services, e-mail services, and so on. Each of these infrastructure services can be employed by a cloud-service customer  and deployed in an infrastructure service layer  above the software kernel layer .","The scale and various aspects (e.g., data, connectivity, and dependency relationships within and between service components) of an infrastructure service deployment are configurable by an administrator user of the cloud-service customer . In one example, the administrator user submits a configuration specification to the cloud-service provider  via a frontend interface  of the cloud-service provider . The cloud-service provider  translates the configuration specification into instructions (e.g., API calls) to the infrastructure service layer  and the kernel layer  according to the APIs of the involved infrastructure services and the APIs of the underlying software kernel layer . These instructions are executed to provision and configure the infrastructure services requested in the configuration specification of the deployment. For example, a configuration specification can be translated into infrastructure and kernel level APIs calls that create, re-create, move, or delete components (e.g., virtual machines and services) and assign or change attributes (e.g., memory and CPU allocations, network settings, disk sizes and volumes) of the components.","In addition to the infrastructure services, the example cloud-service provider  also provide platform services, such as an environment (e.g., Linux, Solaris, Microsoft Windows, etc.) for running virtual machines or a framework (e.g., .NET, Java, Oracle Database, etc.) for developing and launching a particular type of software applications. The platform services are implemented in a platform service layer  over the infrastructure service layer , and can employ one or more infrastructure services configured in a particular manner. Configuration of platform services can be accomplished by program code written according to the APIs of the platform services and, optionally, the APIs of the infrastructure services that are employed in enabling the platform services.","In this example, the cloud-service provider  also provides software application services in an application service layer . A software application (e.g., a commercially-available software application) can be installed on one or more virtual machines or deployed in an application framework in the platform service layer . The software application can also communicate with one or more infrastructure service components (e.g., firewalls, databases, web servers, etc.) in the infrastructure layer . The installation and configuration of the software application in the application service layer  can be accomplished through APIs of the software itself and the APIs of the underlying platform and infrastructure service components.","To manage the deployment and operation of the cloud-based services provided to the cloud-service customers , the example cloud-service provider  includes a cloud-service manager . The example cloud-service manager  communicates with the frontend interface  to receive service requests from the cloud-service customers . The example cloud-service manager  is further responsible for the managing of the cloud resources and services, including service enrollment, provisioning, coordination, monitoring, scheduling, etc. As described in this specification, the example cloud-service manager  also includes tools and libraries for translating the user requirements (e.g., as expressed in one or more configuration specifications and service level agreements (SLAs)) in the different service layers (e.g., the layers , , and ) into physical resources demands (e.g., as expressed in one or more kernel and hardware\/firmware-level API calls).","Although the example cloud-service provider  provides all three types of cloud-based services, in some implementations, fewer or more types of services may be provided. In some implementations, the cloud-service provider  may outsource some of the cloud services or portions of a service to other cloud-service providers. The cloud-service manager  may implement API calls to these other cloud-service providers for supporting some of its services to the cloud-service customers . In addition, the conceptual layers of the cloud-service provider  shown in  are merely illustrative. Other conceptual structure of a cloud-service provider may be provided, for example, depending on the types of services actually offered by the cloud-service provider.","In this example, the cloud-service customers  can employ cloud-based services offered in each of the services layers , , and . Depending on the type of services that a cloud-service customer  has employed, the cloud-service customer  is granted different levels of control in configuring the services. For example, if a software application service is employed, an administrator user of the cloud-service customer  is given control over how the software application is configured, but controls over the underlying platform and infrastructure services supporting the software application remains with the cloud-service provider . If a platform service is employed, an administrative user of the cloud-service customer  is given control over how the platform and\/or application frameworks are configured, but the control over the infrastructure services that support the platform and\/or application frameworks remains with the cloud-service provider . Similarly, if infrastructure services are employed, an administrative user of the cloud-service customer is given control over the particular infrastructure services employed, but not the underlying kernel layer  and firmware and hardware layer .","In the cloud-computing environment , the cloud-service customers  access the cloud-based services using data processing apparatus such as personal computers, smart phones, and tablet computers. Depending on the type of service being employed, different user interfaces or programming interfaces may be used to communicate with the cloud-service provider .","For example, if a software application service is being employed, an end user can access and use the software application through a web browser. If platform or infrastructure services are being employed, a user of the service (e.g., an administrator user of a cloud-service customer ) can access a configuration user interface that includes administrative functions to control and configure the services. The administrative functions include, for example, starting or stopping virtual machines, managing cloud storage, installing and deploying software on virtual machines, or setting up web servers, etc. In addition, a cloud-service provider  can optionally allow an administrator user of a cloud-service customer  to write program code according to various provider-, platform-, framework-, and\/or service-dependent application program interfaces (APIs) to control and configure various aspects of the services that the cloud-service customer  receives. In some implementations, if an open standard is used for a cloud-computing environment, provider-, platform-, framework-, and service-independent APIs can be used to control and configure the services as well.","When configuring a cloud-based service for deployment, a service user or service developer provides one or more configuration files to the cloud-service provider . The configuration files set forth the desired initial state of the service expressed in terms of various configuration parameters. Typically, the configuration file is written in a structured way according to the rules and syntax provided or recognized by the cloud-service provider , such that the configuration file will be parsed and interpreted correctly by the cloud-service provider .",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 2A","b":["200","200","200"]},{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 2B","b":["208","200","202","210","212","210","212","214","214","216","216","204","202","218","218","214","214","206","220","222","224","216","216","216","216"],"i":["a ","b ","a ","b","a ","b","a ","b","a ","b","a ","b. "]},"As illustrated in , the example conventional configuration specification  relies on nested markup constructs (e.g., code blocks , , and ) to describe the components of a deployment and relationships among the components. The user writing the configuration specification  needs to be familiar with the details within each markup construct that goes into the configuration specification  and the markup construct's meaning to the API translator of the cloud-service provider. For a large and complex deployment, the configuration file can become very long and complex with many layers of markups and duplicate statements. Furthermore, the possibility of code reuse decreases as a configuration specification becomes long and complex, because customization of the configuration specification for another deployment would require many changes and debugging the customized configuration file would also become more difficult.","As disclosed in this specification, instead of providing a configuration specification written in a markup language or through a graphical user interface, a cloud-service customer or service developer can provide a configuration specification written in a high-level object-oriented specification language. The high-level object-oriented specification language allows components (e.g., infrastructures, storage devices, services, software package to be installed, and \u201csoftware roles\u201d played by installed software applications) of a cloud-based deployment to be specified as instances of one or more reusable and modifiable classes, where each class models a component of the deployment using a group of configurable class parameters. The value of each class parameter can be specified, reused, or modified for particular deployments using the syntax and functions provided by the object-oriented specification language. The instance of each reusable and modifiable class declares the desired state of the component that is modeled by the class.","As described in this specification, inheritance of class definitions is supported by the high-level object-oriented specification language. New class definitions can be provided based on statements relating or modifying one or more existing class definitions using the high-level specification language. Statements relating different classes capture the relationships between multiple aspects (e.g., data or functional components) of a deployment. Examples of such relationships include the dependencies between software installations and service activations in a deployment, the connectivity between multiple software roles in a deployment, and the connectivity between a software role and a service or virtual device in a deployment. New class definitions can also be created by extending an existing class definition with the addition of new class parameters and\/or methods. A user can customize a deployment by specifying a new class derived from one or more existing base classes and instantiate the new class.","According to this specification, a cloud-service provider is able to compile a configuration specification written in the high-level object-oriented specification language into a set of API calls, based on the requirements specified by the class definitions included in the configuration specification. The inclusion of a class definition in a configuration specification refers to a request in the configuration specification to instantiate the class definition or to instantiate a new class definition derived from the class definition.","In some implementations, different service layers of the cloud-service provider and different services within the same layer have different APIs. To compile the configuration specification written in the object-oriented specification language, the cloud-service provider stores a set of rules and protocols for translating each of a set of most basic class definitions (or core class definitions) of the specification language to a respective group of API calls. The group of API calls for each core class definition conforms to the API of the type of components modeled by the core class definition. The compiler is then able to use the set of rules and protocols to translate all class definitions derived from the core class definitions into an appropriate combination of API calls to configure all of the components of a particular deployment. In some implementations, the API calls are sent to and executed on one or more servers of the cloud-service provider. Alternatively, some of the API calls may be passed to an intermediary component of the cloud-service provider or a third-party service provider, where the API calls are further processed into lower-level API calls and carried out by the sub-components of the intermediary component or third-party service provider.","In some implementations, the high-level object-oriented specification language also includes syntax for specifying triggers for scaling or dynamically reconfiguring various aspects of the deployment. For example, a class definition that models a virtual machine can include one or more class parameters for a scaling policy, such that the compiler can derive API calls to dynamically adjust the number of virtual machines deployed based on various performance metrics monitored by the cloud-service manager (e.g., the cloud-service manager  shown in ).","The following examples (shown in ) illustrate the syntax and various properties of an example object-oriented specification language, and how a cloud-based deployment can be specified according to the example object-oriented specification language, and based on existing and newly derived class definitions.","In the first example, an example configuration specification  written in an example object-oriented specification language is shown in . The deployment made according to this configuration specification  is for launching a virtual machine with a web server (e.g., an Apache web server) installed and serving the files present in a data package.","This example assumes the existence of a number of base class definitions that the compiler is able to parse and translate to API calls. The existing base class definitions include a set of core class definitions provided by the compiler and possibly other class definitions that extend from one or more of the core class definitions either directly or via one or more intermediate class definitions.","In some implementations, the existing base class definitions are grouped into modules (e.g., modules \u201cutils,\u201d \u201cstd\u201d shown in ), and classes included in each module are referenced in a configuration specification by a module name followed by a class name (e.g., \u201cstd.Parameters,\u201d \u201cutils.ConfiguratorLAMP,\u201d \u201cstd.DataPackage,\u201d \u201cstd.Role,\u201d \u201cutils.PublicTCPFirewall,\u201d \u201cutils.BaseDeployment\u201d as shown in the specification ). Each of the base class definitions specifies an initial configuration state of a corresponding component of a cloud-based deployment, subject to the modifications and component relationships set forth in the configuration specification .","As shown in , the configuration specification  includes new class definitions that extend from the existing base class definitions. For example, a new class \u201cParams\u201d extends from the base class \u201cstd.Parameters,\u201d a new class \u201cSimpleHostingPackage\u201d extends from the base class \u201cstd.DataPackage,\u201d a new class \u201cSimpleHostingVM\u201d extends from the base class \u201cutils.Configurator.LAMP,\u201d a new class \u201cSimpleHostingRole\u201d extends from the base class \u201cstd.Role,\u201d a class \u201cSimpleHostingFirewall\u201d extends from the base class \u201cutils.PublicTCPFirewell,\u201d and a class \u201cSimpleHostingDeployment\u201d extends from the base class \u201cutils.BaseDeployment,\u201d as shown by the new class definitions , , , , , and , respectively. The configuration specification  triggers the deployment of a simple hosting application by creating an instance of the \u201cSimpleHostingDeployment\u201d class (e.g., as shown by statement ), which in turn creates instances of other classes from which the \u201cSimpleHostingDeployment\u201d class is derived.","In this example, the \u201cSimpleHostingDeployment\u201d class definition  customizes the definition of the base class \u201cutils.BaseDeployment\u201d by modifying two class parameters, a \u201croles\u201d parameter and a \u201cfirewall\u201d parameter. The \u201croles\u201d parameter specifies the respective software roles that one or more installed software packages are supposed to play in the deployment. The \u201cfirewall\u201d parameter specifies that a firewall service is to be included as part of the deployment. In this case, the class definition  specifies that a single software role is to be included, which is represented by an instance of the \u201cSimpleHostingRole\u201d class. The class definition  further specifies that the firewall service to be included in this deployment is represented by an instance of the \u201cSimpleHostingFirewall\u201d class. According to the properties of the object-oriented specification language, the \u201cSimpleHostingDeployment\u201d class inherits other class parameters defined in the base class \u201cutils.BaseDeployment\u201d without further modification. These other class parameters describe other aspects of the deployment that need not be further customized for this simple hosting deployment.","According to the class definition , instantiation of the \u201cSimpleHostingDeployment\u201d class requires instantiation of the \u201cSimpleHostingRole\u201d and the \u201cSimpleHostingFirewall\u201d classes as well. As shown in , the \u201cSimpleHostingRole\u201d class definition  extends from the base class \u201cstd.Role.\u201d Both classes are based on a \u201csoftware role\u201d model that categorizes a software installation according to the role that the software installation plays in a cloud-based deployment. For example, a software package may be installed to play a role of a webhost, a frontend, a backend, a communication interface, and so on. Depending on the particular role that a software installation plays, different parameters may be used to configure the software installation. Each configurable parameter for the software role can have a corresponding class parameter or function in the class definition created based on the \u201csoftware role\u201d model.","In one example, in addition to an identifier or name of the role that the software installation plays in a deployment, a \u201csoftware role\u201d model can include model parameters for configuring various aspects of the software installation, including the virtual machines on which the software is to be installed, the location of the software binary, instructions on which installer program should be used to install the software, and so on. If the software installation requires other services or software installations to be performed first, this dependency is optionally included in the \u201csoftware role\u201d model as well. Example of dependency relationships are \u201cstart after\u201d or \u201cstop before.\u201d Other dependency types (e.g., install on the same virtual machine, etc.) can be supported as well.","In this example in , the class definition  for the \u201cSimpleHostingRole\u201d class specifies that the role of the software installation in the deployment is to serve as a \u201cwebhost.\u201d How the \u201cwebhost\u201d software is to be deployed is made known to the compiler through the class definition of the \u201csimplehosting.webhost\u201d class. In this example, the \u201csimplehosting.webhost\u201d class definition includes the configurations of a simple apache web server, which is already written and made known to the compiler. When the \u201cSimpleHostingRole\u201d class is instantiated, the \u201csimplehosting.webhost\u201d class is instantiated as well.","The class definition  for the \u201cSimpleHostingRole\u201d class further declares that the data package that is needed to run this webhost is represented by an instance of the \u201cSimpleHostingPackage\u201d class, and that the webhost is to be installed on virtual machines that are represented by instances of a \u201cSimpleHostingVM\u201d class.","In this example, each of the \u201croleName,\u201d \u201cmoduleName,\u201d \u201cdataPackages,\u201d and \u201cvms\u201d are parameters of the \u201cstd.Role\u201d class, and are customized in the \u201cSimpleHostingRole\u201d class definition . Other class parameters of the \u201cstd.Role\u201d class are inherited by the \u201cSimpleHostingRole\u201d class without modification.","The class definition  of the \u201cSimpleHostingRole\u201d class also defines a few new parameters, such as the \u201cserving_domain\u201d and \u201cdocument_root\u201d parameters whose values are assigned either indirectly through another parameter name (e.g., \u201cserving_domain\u201d of the \u201cParams\u201d class ) or by a direct value entry (e.g., \u201c\/var\/www\/static\u201d). In this example, only one software role is defined, so no dependency between software roles is specified for the software role (e.g., the \u201cSimpleHostingRole\u201d) in terms of installation or execution.","With respect to the firewall component of the deployment, the class definition  of the \u201cSimpleHostingFirewall\u201d class is based on the existing \u201cutils.PublicTCPFirewall\u201d class definition. In this example, the \u201cutilis.PublicTCPFirewall\u201d class defines a public firewall with Transmission Control Protocol (TCP) set as the protocol. The only parameters of the \u201cPublicTCPFirewall\u201d class that are modified for this deployment are the \u201ctarget\u201d and \u201cports\u201d parameters. In the class definition , the target of the firewall is represented by an instance of the \u201cSimpleHostingRole\u201d class, while the port of the firewall is set to port \u201c80.\u201d Other parameters (e.g., the \u201csource\u201d and the \u201cprotocol\u201d parameters) that are needed to configure the firewall are specified in the base class definition of \u201cPublicTCPFirewall\u201d and are inherited by the \u201cSimpleHostingFirewall\u201d class without modification. In this example, a connectivity between the firewall component and the simple hosting software role (e.g., represented by an instance of the \u201cSimpleHostingRole\u201d class) is specified by the value assignment to the \u201ctarget\u201d parameter.","In this example, the class definitions of the \u201cSimpleHostingFirewall\u201d and the \u201cutils.PublicTCPFirewall\u201d classes are both based on a firewall service model. Unlike a \u201csoftware role\u201d model, a service model does not need to include parameters for the underlying virtual machines, disks, or software packages. Instead, these aspects are controlled by the cloud-service provider and not subject to the configuration by the users of the service. Like in a \u201csoftware role\u201d model, a service model also optionally includes parameters that specify dependences between services and between services and software roles. In this example, the firewall component is connected to the web server component, but no dependencies of the firewall service are specified for this simple hosting deployment.","As set forth earlier and shown in , the class definition  of the \u201cSimpleHostingRole\u201d class requires instantiation of the \u201cSimpleHostingPackage\u201d class and the \u201cSimpleHostingVM\u201d class. The class definition  of the \u201cSimpleHostingPackage\u201d class specifies the source of the data (e.g., \u201cdata\u201d in the current directory\u201d) that is to be copied to the virtual machine hosting the \u201cSimpleHostingRole.\u201d The class definition  further specifies a destination directory (e.g., \u201c\/var\/www\/static\u201d) of the copied data on the virtual machine. When the deployment is carried out according to the configuration specification , the data package \u201cdata\u201d is copied from the directory in which the configuration file resides, to the destination directory \u201c\/var\/www\/static\u201d on the virtual machine that has been deployed according to the \u201cSimpleHostingVM\u201d class definition .","As shown in , the \u201cSimpleHostingVM\u201d class definition  extends from the \u201cutils.ConfiguratorLAMP\u201d class definition. Both classes are based on a virtual machine model and specify how a virtual machine can be configured. In this example, the \u201cutils.ConfiguratorLAMP\u201d class configures a customized virtual machine that already has an Apache web server installed. Therefore, by extending from the \u201cutils.ConfiguratorLAMP\u201d class rather than a standard virtual machine class, a user can simplify and speed up the configuration process. The \u201cSimpleHostingVM\u201d class definition  also specifies the number of virtual machines to be deployed in this deployment and the external IP addresses to be bound to the virtual machines, through the newly added \u201creplicas\u201d and \u201cstaticlP\u201d class parameters. Other parameters that are commonly used to configure a virtual machine or virtual machines for supporting a software role include, for example, configuration parameters for the CPU and memory requirements of the virtual machine(s), storage disks to be attached to the virtual machine(s), read-only storage sources attached to the virtual machine(s), IP addresses, network interfaces of the virtual machine(s), the data center location of the virtual machine(s), and so on. Each of these virtual machine model parameters is optionally included as a class parameter in a virtual machine class definition or another class that extends from a virtual machine base class definition.","Optionally, a special \u201cParams\u201d class is included in the configuration specification of a deployment, such as that shown in the example configuration specification . Parameter values can be provided in this class definition and used to assign values to parameters in other class definitions that are included in the same configuration file. For example, the values of parameters \u201creplica_count,\u201d \u201cserving_domain,\u201d and \u201cip_array\u201d are injected into the class definitions  and  through references made to the respective names of parameters.","As illustrated in the example configuration specification , it is possible to create class definitions for different components of a cloud-based deployment based on different component models. A high-level object-oriented specification language can be developed based on models of various types of infrastructures, storage, services, and software roles that commonly occur in a cloud-based computing environment. Each model describes a corresponding infrastructure component, storage, service, or software role using a number of model parameters. Core class definitions that represent generic initial configuration states of some most common and basic components of the cloud-based environment can be created based on these component models. As more complex components can be built from combinations of multiple basic components, class definitions that represent the initial configuration states of more complex components can be created from multiple core class definitions and\/or other class definitions that are derived from the core class definitions.","A compiler of the high-level object-oriented specification language is created to parse the class definitions created based on these component models, extract the configuration requirements expressed by the values of the class parameters, and translates the requirements into a proper set of API calls for configuring the types of components represented by these component models. In some implementations, a compiler is implemented as a software program or script that reads a configuration file and outputs a set of API calls. In some implementations, the compiler also direct the API calls to appropriate components of the cloud-service provider or third-party providers for execution.","The example in  has illustrated class definitions developed based on an example software data package model, an example virtual machine model, an example \u201csoftware role\u201d model, an example firewall service model, and an example deployment model, respectively. As an additional example, an example storage model includes model parameters for configuring aspects of a storage option of a deployment, such as the size of the storage, mounting points of the storage, and so on. In some implementations, a storage model optionally includes a scaling policy for dynamically adjust the size of the storage based on monitored usage of the storage. Furthermore, in addition to a firewall service, a cloud-based environment can include many platform and infrastructure services, such as a database service, a message queue service, a load balancing service, a map service, a MapReduce service, and so on. Different service models can be developed for each of these cloud-based services, and class definitions for configuring the different services can be created based on the different service models.","As illustrated by the example of , an object-oriented specification language enables the creation of class hierarchies that represent different levels of customization for components in various layers of the cloud-computing environment. A configuration specification written in the object-oriented specification language can reuse existing class definitions, either by extending from an existing class definition or referring to an instance of an existing class definition when assigning a value to a class parameter. Reusing existing class definitions simplifies the configuration specification for a new deployment. Furthermore, when reusing an existing class definition, a user only needs to know the configuration state that can be accomplished by the existing class definition, but not all the literal details set forth within the class definition to accomplish that configuration state.","In addition, class definitions of highly complex components (e.g., components involving multiple services, multiple data sources, and multiple levels of deployments) can be developed based on multiple existing class definitions, with or without modification to the class parameters of the existing class definitions. These highly complex class definitions can be reused by a user in a new deployment, without in depth understanding of these complex class definitions on all levels.","By choosing the appropriate base classes to customize and modify in a new configuration specification, the user also gains more refined control over particular aspects of the deployment while leaving other aspects of the deployment generic to definitions of the base classes.",{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 3B","b":"320"},{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 3C","b":["340","320","320","340"]},"The following describes how the based class definitions in the \u201clamp\u201d module  are used to establish a basic LAMP deployment structure. In the \u201clamp\u201d module , the special \u201cParams\u201d class  includes some parameters that are used in multiple class definitions, such as a flag \u201csingle_node\u201d indicating whether the Apache software and the MySQL software should be installed on the same virtual machine, a \u201cfrontend_ip\u201d parameter for specifying the IP addresses to be bound to the LAMP frontend component, a \u201cserving domain\u201d parameter for specifying the domain name of the Apache website, a \u201cdoc_root\u201d parameter for setting the document root of the Apache server, a \u201cmysqldatafolder\u201d parameter for setting the database folder relative to the persistent disk mount point, a \u201cmysql_pdname\u201d parameter for specifying the name of the persistent disk, a \u201cmysql_pd mount_point\u201d parameter for specifying the mount point of the persistent disk, a \u201cpd_size_gb\u201d parameter for specifying the size of the persistent disk in GB. Optionally, the parameter values in the special \u201cParams\u201d class can be changed through a command line tool provided by the cloud-service provider to make it more convenient for users to adjust deployments based on the \u201clamp\u201d module.","A LAMP-based application deployment typically includes the following components: a frontend (i.e., the software role of a frontend software application), virtual machines on which the frontend software application (e.g., an Apache web server application) is installed, a database (i.e., the software role of a database software application), virtual machines on which the database software application (e.g., a MySQL software application) is installed, a permanent disk for storing the database, and a firewall. Each of the above components is modeled by a respective set of class parameters that are configurable for a particular LAMP-based application deployment.","As shown in , the class definition \u201cFrontendVM\u201d  extends from an existing class definition \u201cutils.ConfiguratorLAMP\u201d which configures a virtual machine image that already has an Apache web server software pre-installed. In this case, the MySQL database software is to be installed on the same virtual machine as the Apache software, as indicated by the \u201csingle node\u201d flag in the \u201cParams\u201d class definition . Therefore, the \u201cDatabaseVM\u201d class definition  also extends from the class definition \u201cutils. ConfiguratorLAMP.\u201d","In the \u201clamp\u201d module , the \u201cMysqlPD\u201d class definition  models the permanent disk on which the database is to be stored. The MysqlPD class definition  includes class parameters that specify the name of the persistent disk, the size of the persistent disk, and the mount point of the persistent disk, for example. Other parameters that specify how the persistent disk should be configured are inherited from an existing \u201cstd.PersistentDiskSpec\u201d class definition without modification.","The \u201cFrontendRole\u201d class definition  models the frontend component of the LAMP-based environment. The \u201cFrontendRole\u201d class definition  extends from a standard software role modeled by an existing base class definition \u201cstd.Role.\u201d The \u201cFrontendRole\u201d also refers to a \u201clampfront\u201d placeholder class and a \u201clamp\u201d placeholder module as the temporary values assigned to the \u201croleName\u201d and the \u201cmoduleName\u201d class parameters. These temporary values will be replaced by the names of the actual module and class that configure the LAMP frontend software application to be deployed. As will be shown in , the class definition that configures the front end software (e.g., the Mantis debugging software) is the \u201cmantis frontend\u201d class in the \u201cmantis\u201d module. The class definition  also sets forth that the virtual machine on which the LAMP frontend role is to be installed is represented by an instance of the \u201cFrontVM\u201d class .","The \u201cDatabaseRole\u201d class definition  models the database component of the LAMP-based environment. The \u201cDatabaseRole\u201d class also refers to a placeholder class in a placeholder module (e.g., \u201clamp\u201d and \u201clamp backend\u201d) for the backend software configuration. The names of the placeholder class and the placeholder module will be replaced by the actual names of the class and module that configure the backend database software. The \u201cDatabaseRole\u201d class definition  also specifies that the persistent disk storing the database is represented by an instance of the \u201cMysqlPD\u201d class definition . In addition, a \u201cvms\u201d parameter is defined to indicate that the virtual machine for installing the backend database software of the LAMP environment is to be represented by an instance of the \u201cFrontendVM\u201d class if the \u201csingle_node\u201d flag is set to TRUE, otherwise, the virtual machine is to be represented by an instance of the \u201cDatabaseVM\u201d class.","Lastly, in the \u201clamp\u201d module , the firewall component of the LAMP-based environment is modeled by the \u201cHttpFirewall\u201d class definition . The \u201cHttpFirewall\u201d class definition extends from the existing \u201cutils.PublicTCPFirewall\u201d class definition, such as the protocol, source, and target parameters of the \u201cutil.PublicTCPFirewall\u201d class are inherited by the \u201cHttpFirewall\u201d class. The \u201cHTTPFirewall\u201d class definition modifies the \u201cport\u201d parameter of the \u201cutils.PublicTCPFirewall\u201d from \u201cany\u201d to \u201c80.\u201d","Each class definition set forth in the \u201clamp\u201d module  shown in  is extendable, modifiable, and\/or usable as is for an application-specific deployment and\/or for creating new class definitions in other modules. The configuration specification  shown in  includes and builds upon the class definitions in the \u201clamp\u201d module  shown in . A statement  at the beginning of the configuration specification  points to a file containing the class definitions of the \u201clamp\u201d module , to indicate to the compiler where to locate the base class definitions that are used in the configuration specification .","The configuration specification  is for configuring an application deployment that launches virtual machines in a LAMP structure and installs the Mantis debugging software on the virtual machines. Mantis is a web-based bug-tracking system written in the PHP scripting language and works with a MySQL database and a webserver.","As specified in the in the \u201cMantisDeployment\u201d class definition , the deployment calls for two software roles and a firewall to be installed. In this case, the two software roles are created according to the \u201cMantisFrontend\u201d class definition  and the \u201cMantisDatabaseRole\u201d class definition , while the firewall is created according to the \u201cMantisFirewall\u201d class definition . When the configuration specification  is compiled, the statement  makes an instance of the \u201cMantisDeployment\u201d class and causes the other classes on which the \u201cMantisDeployment\u201d class depends to be instantiated as well.","In this example, the \u201cMantisFrontend\u201d class definition  extends from the \u201clamp.FrontendRole\u201d class definition  shown in . The class parameters that are modified for the Mantis software installation include the \u201croleName,\u201d \u201cmoduleName\u201d of the software configuration specification, the \u201cdataPackages\u201d from which the Mantis software binaries can be copied, and the database host to be associated with the Mantis application deployment. The configuration parameters for the virtual machine aspect of the Mantis frontend are inherited from the \u201clamp.FrontendRole\u201d class definition  without modifications. In other words, the user writing the configuration specification  accepts the default virtual machine configuration specified in the \u201clamp\u201d module , and needs not customize the Mantis application deployment with that level of details.","Similarly, the \u201cMantisDatabaseRole\u201d class definition  extends from the \u201clamp.DatabaseRole\u201d class definition  shown in . The class parameters that are modified for the Mantis software installation includes the \u201croleName\u201d and \u201cmoduleName\u201d of the configuration specification for the backend database role. In addition, the frontend host of the database role is set to be an instance of the \u201cMantisFrontendRole\u201d class. The configurations for the virtual machine aspect and the persistent disk aspect of the database backend role are inherited from the \u201clamp.DatabaseRole\u201d class definition  without modification.","In addition, the \u201cMantisFirewall\u201d class definition  inherits the parameters from the \u201clamp.HTTpFirewall\u201d and modifies only the value for the \u201ctarget\u201d parameter to an instance of the \u201cMantisFrontendRole\u201d class. Other parameters, such as the \u201cport\u201d and \u201cprotocol\u201d parameters of the \u201cMantisFirewall\u201d class are inherited from the base class \u201clamp.HTTpFirewall\u201d defined in the \u201clamp\u201d module .","Other parameters and values specific to the Mantis deployment are set forth in the special \u201cParams\u201d class definition  and the data package from which the Mantis software is copied is specified in the \u201cMantisPackage\u201d class definition .","In the above example, the configuration specification for the Mantis software deployment is derived from the base class definitions (e.g., class definitions in the \u201clamp\u201d module ) created for a generic LAMP-based application deployment. Configurations of many aspects of the LAMP-based deployment do not have to be redefined for the Mantis application deployment. The configuration specification for the Mantis application deployment only needs to specify new parameters or new parameter values that are particular to the Mantis application deployment or in need of customization. Parameters that are already defined for other more generic aspects of the deployment do not need to be re-specified or modified in the configuration specification . The details of these other aspects of the deployment can remain opaque to the user.","The examples shown in  are merely illustrative of the properties of an object-oriented specification language for writing configuration specifications of cloud-based deployments. In various implementations, the exact syntax of the object-oriented specification language can depart from what is shown in the examples. Furthermore, many types of base classes can be created to model the components that may exist in a cloud environment. Syntax for specifying relationships between components modeled by the classes can also vary from one object-oriented specification language to another object-oriented specification language. For a given object-oriented specification language, a compiler can be created to parse the class definitions included in a configuration specification written in the object-oriented specification language according to a predetermined set of syntax rules to extract the parameters that are used to configure the various types of components in the cloud environment.",{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 4","b":["222","104","222","104","102","222","102","120","104","222","102"]},"After the frontend  receives the configuration specifications  from an administrative user of the cloud-service customers , the frontend  passes the received configuration specifications  to an API translator  of the cloud-service manager . The API translator  have access to a library of core class definitions (e.g., stored in a definition database ) and translation protocols (e.g., stored in a rule database ) on how to translate the core class definitions into respective sets of API calls for configuring various components of a cloud-based environment of the cloud-service provider .","For example, the API translator  can include a compiler (e.g., a parsing script or program) that parses the class definitions received in a configuration specification , identify all the base classes from which the classes in the configuration specification are derived, and extract the base class parameters that are left unmodified as well as the class parameters that are modified or new. In addition, the compiler also identifies all the relationships (e.g., connectivity and dependencies) among the components of the cloud-based deployment from the statements in the class definitions. Based on the values of the class parameters and the stored translation protocols, the API translator  generates an appropriate set of API calls  to configure various aspects of the cloud-based deployment.","For example, the translation protocols can include a mapping between a core class definition modeling a respective modular aspect of the cloud-based environment to a group of API calls that are used to configure that aspect of the cloud-based environment. The translation protocols can further include protocols for modifying the set of API calls (e.g., changing default parameters used in the API calls) with parameter values specified for that modular aspect of the cloud-based environment in classes derived from the core class definition.","As a more specific example, suppose a standard virtual machine class definition (e.g., a \u201cstd.VM\u201d class) is a core class definition known to the compiler. The compiler would have access to a translation rule mapping the core class definition to a set of provisioning API calls made to the VM manager in the kernel layer of the cloud-service provider  for deploying a standard virtual machine image. A default set of parameters (e.g., duplicate count, IP address, memory requirement, etc.) can be used in the provisioning API calls. The protocol for modifying the API calls can include protocols for changing the default parameter values according to the parameter values specified in the specification configuration and in intermediate class definitions that are derived from the standard virtual machine class definition. For example, if a class parameter of a new class definition derived from the standard virtual machine image specifies the software package to be installed on the virtual machine image, the translation protocols would specify how the additional API calls for installing software packages on a designated virtual machine should be added to the group of API calls associated with configuring the standard virtual machine image.","In some implementations, the protocols for translating class definitions to API calls are written as program scripts. As new core class definitions are added to the class definition database , the protocol for translating the new class definition can be created and added to the translation rules database . The translation protocols can be created, for example, by the cloud-service provider . In some implementations, when encountering a particular class definition in parsing a received configuration specification, the API translator  locates and runs a corresponding script to parse the class definition into a set of API calls. The API calls, when executed, cause the configuration specified by the class definition to be achieved in the cloud-based environment.","In some implementations, the API calls  generated by the API translator  are sent to a service launcher component  of the cloud-service manager . The service launcher component  is responsible for channeling the API calls  to various layers of the cloud-service environment or components of the cloud-service provider  where the API calls can be executed. In some implementations, where the deployment are to be carried out in several stages due to the dependencies between various aspects of the deployment, the service launcher component  is also responsible in checking the order by which the API calls are sent out to the layers and\/or components for execution, and verify that the API calls have been completed in a proper sequence.","Since class definitions written in an object-oriented specification language as disclosed in this specification can be reused in multiple configuration specifications, an administrator user of a cloud service may wish to employ class definitions provided by a third party (e.g., another user, a service developer of the cloud-service provider, or third-party developers) in their own configuration specifications, rather than developing those class definitions by themselves. In some implementations, a marketplace for sharing\/sale and selection of existing configuration specifications and reusable class definitions can be provided, for example, by the cloud-service provider or a third-party provider.","In this example, the cloud-service provider  provides such a platform for the sharing of reusable configuration specification and class definitions. In some implementations, the frontend  of the cloud-service provider provides a definition submission user interface and a definition selection interface to facilitate the sharing of reusable configuration specifications and class definitions. The parties that provide the configuration specifications and class definitions for reuse by others serve as definition suppliers  for the cloud-service provider . The potential definition users include administrative users of cloud-based services. The potential definition users also, optionally, include definition suppliers who will create new reusable class definitions or class definitions for submission based on the existing class definitions provided by other definition suppliers.","As shown in , the cloud-service manager  of the cloud-service provider , or a component of the cloud-service manager , can serve to manage the platform for sharing reusable class definitions. The definition suppliers  submit reusable class definitions to the cloud-service manager  through the definition submission user interface provided by the frontend . Each class definition submission can include multiple reusable class definitions, such as in a class module. Each class definition in the submission is accompanied by descriptions of the initial configuration state that the class definition can accomplish if subsequently used in a configuration specification. In some implementations, the description also includes instructions on how the class parameters in the class definition can be subsequently modified in configuration specifications to suit the needs of particular deployments.","When a definition supplier submits a reusable class definition or a module of reusable class definitions, the cloud-service manager  can store the received class definitions in a class definition database (e.g., the definition database ). In some implementations, the frontend  provides registration and authentication services for the definition suppliers . Each class definition or class module received from a registered definition supplier  is stored in association with the identifier of the definition supplier, such that the definition supplier  can be properly credited when the class definition is subsequently used or purchased by a definition user.","In some implementations, the definition suppliers  can provide reusable class definitions for free or for a cost. The cloud-service manager  can facilitate the sale or license of the reusable class definitions to the potential definition users (e.g., administrative users of the cloud-service customers ) through the definition sharing platform. In some implementations, the definition supplier  provides and the cloud-service manager stores respective prices associated with the sale or licenses for different usage levels for the reusable class definitions provided by the definition suppliers .","In some implementations, the cloud-service manager  provides a definition selection user interface over the frontend . The definition selection user interface presents the class definitions that are available for reuse, such as in defining new class definitions. The new class definitions include those included in the configuration specification of a new deployment and, optionally, those that are submitted to the cloud-service provider for reuse by others. The potential definition users (e.g., administrative users of the cloud-service customers and definition suppliers) can view the class definitions that are available for selection through the definition selection interface, along with their prices and descriptions, and optionally, reviews and quality scores, and decides on whether to reuse one or more of the class definitions in a configuration specification or for deriving a new class definition.","In some implementations, definition selection user interface allows the user of the class definitions to download or copy a reusable class definition available for selection. In some implementations, the user does not have to copy or download the class definition, and can use the class definitions by simply identifying the module and class name in a configuration specification submitted to the cloud-service provider for deployment. The cloud-service manager  will identify and locate the class definitions that are referenced in the specification file, and keep track of the usage of the class definition.","In some implementations, the reuse involves an entire module (e.g., the \u201clamp\u201d module shown in ), where the module includes a collection of multiple interrelated class definitions for configuring a cloud component that includes multiple sub-components.","In some implementations, the class definitions or class modules are categorized based on the type of components they model. In some implementations, the definition selection interface allows the potential users of the class definitions to search or review available class definitions by categories, functions, definition suppliers, and other attributes associated with the class definitions and modules.","In some implementations, the cloud-service provider  or a third party provider also provides a platform for software suppliers  to provide software solutions accompanied by multiple alternative configuration specifications or alternative collections of class definitions for configuring the software solutions. For example, a personnel management program can be accompanied by configuration specifications that are tailored for cloud-service customers  that have different scale, needs, and internal infrastructures. When a cloud-service customer  purchases or licenses the software solution for deployment in the cloud environment of the cloud-service provider , the cloud-service customer  can choose the configuration specification that best suits its needs.","In some implementations, the service manager  can receive submissions of software solutions with accompanying configuration specifications (e.g., either as configuration specifications or modules of reusable class definitions) through a software submission user interface provided through the frontend . In some implementations, the software submission user interface includes registration and authentication capabilities, such that each submission of a configuration-wrapped software solution  is stored in association with the software provider that submitted the configuration-wrapped software solution .","The cloud-service provider  can provide the configuration-wrapped software solutions in a software selection interface to the cloud-service customers  through the frontend . The software selection interface can also provide the descriptions of the different configuration specifications accompanying each software solution. When a user (e.g., an administrative user of an cloud-based application service) select a software solution and one of the accompanying configuration specifications from the software selection interface, the cloud service provider  can launch the software solution in the cloud-based environment according to the selected configuration specification, with or without additional customizations.","In some implementations, the cloud-service provider  facilitates the accounting (e.g., by an accounting component ) for the sale and purchase of the reusable configuration specifications, reusable class definitions, and configuration-wrapped software solutions that are accomplished through the platforms provided by the cloud-service provider . In some implementations, the cloud-service provider does not need to directly provide these platforms, but provide accounting services (e.g., by the accounting component ) to the user and provider of the reusable configuration specifications, reusable class definitions, and configuration-wrapped software solutions based on actual usage that has occurred in the cloud environment of the cloud-service provider .","In some implementations, the cloud-service manager  includes a service monitor . The service monitor  monitors the statuses of the cloud-services that have been deployed in the cloud environment of the cloud-service provider . The statuses monitored by the service monitor  include, for example, the virtual resources that are employed for each component of a cloud-based deployment, the usage level of the virtual resources, the cloud-services that are employed by each component of the cloud-based deployment, the usage level of the cloud-services. The service monitor  can compute performance metrics associated with each cloud-based deployment based on the statuses of the virtual resources and the cloud-based services that are associated with the deployment. The performance metrics include, for example, the number of user requests received, the latency associated with the responses, the availability of the virtual resources and services, the failure rate of each virtual resource or service, the fault tolerance level of the virtual resources and services, and so on. In some implementations, the performance metrics is stored in a performance data store  of the cloud-service manager .","As disclosed in this specification, cloud-based deployments can be carried out according to configuration specifications written in an object-oriented specification language, where the configuration specifications include class definitions that model different aspects of the cloud-based deployments at different levels of abstraction. When the cloud-service manager  processes a configuration specification into a set of class definitions, the cloud-service manager  is able to track the hierarchy of class definitions that have influenced the configuration of each of those different aspects of the deployment. Further, the cloud-service provider is able to associate the virtual resources and services that are dedicated to the different aspects of the cloud-based deployment to the different class hierarchies that have influenced the configuration of those aspects of the cloud-based deployment.","Therefore, the object-oriented specification language allows performance metrics to be derived for each of these different aspects based on the status and performance of the virtual resources and services that contribute to the performance of the aspect of the cloud-based deployment. In particular, the performance associated with each aspect of the cloud-based deployment is associated with the class definitions that are involved in configuring that aspect of the cloud-based deployment. Then, the performance associated with a class definition can be used as a factor in determining a quality measure for the class definition. If a class definition is used in configuring multiple cloud-based deployments, the aggregated performance associated with the class definition can be used to assess the quality of the class definition.","Using the reusable class definitions and configuration specification shown in  as an example, when the service-cloud manager  deploys the Mantis and MySQL software applications and the firewall service in the Mantis application deployment according the \u201cMantisDeployment\u201d class definition  and all the base classes on which the \u201cMantisDeployment\u201d class definition  depends, the service manager  can monitor the respective performances of the software roles, the firewall service, and the underlying virtual machines supporting the software roles. The cloud-service manager  can associate the respective performances of the frontend role with the classes that influenced the configuration of the frontend component of the Mantis deployment, associate the respective performance of the firewall component with the classes that influenced the configuration of the firewall component, associate the respective performance of the virtual machines underlying the frontend role with the classes that influenced the configuration of the frontend virtual machines, and so on, for example.","In some implementations, the cloud-service manager  can generate a system block diagram of the cloud-based deployment according to the configuration specification writing in the object-oriented specification language. For example, the nature of the infrastructural components, storage, services, software roles, as well as their interrelationships (e.g., dependencies and connectivity) and reconfiguration triggers, can be identified from the class definitions in the configuration specification and represented as corresponding elements in the system block diagram of the deployment. The basic system block diagram can be created when the configuration specification is parsed by the API translator , for example.",{"@attributes":{"id":"p-0159","num":"0158"},"figref":["FIG. 5","FIG. 3C"],"b":["500","340","340","222","354","222","504","506","508","502"]},"Next, according to the class definition of the \u201cMantisFrontendRole\u201d class, the cloud-service manager  determines that the software application serving the frontend role is to be deployed according to the class definition of the \u201cmantis frontend\u201d class. The cloud-service manager  therefore adds a block  within the block , to represent the frontend software that is serving the frontend role. Similarly, from the class definition of the \u201cMantisDatabaseRole\u201d class, the service manager  determines that the software application serving the database role is to be deployed according to the class definition of the \u201cmantis backend\u201d class. Therefore, the service manager adds a block  within the block , to represent the backend database software that is serving the database role.","Furthermore, according to the class definitions  and  of the \u201cMantisFrontendRole\u201d and the \u201cMantisDatabaseRole,\u201d the frontend role and the database role are connected to each other. Based on the class definition  of the \u201cMantisFirewall,\u201d the firewall is connected to the frontend role. Therefore, the cloud-service manager  can insert a connection  between the block  and the block , to represent the connectivity relationship between the frontend role and the database role. In addition, the cloud-service manager  also inserts a connection  between the block  and the block , to represent the connectivity relationship between the frontend role and the firewall.","In addition, since the \u201cMantisFrontRole\u201d class definition  extends from the \u201cFrontendRole\u201d class definition , the cloud-service manager  determines from the class definition  of the \u201cFrontendRole\u201d class that, the frontend software (e.g., the Mantis software) is to be installed on a virtual machine modeled by the \u201cFrontendVM\u201d class definition . Similarly, the \u201cMantisDatabaseRole\u201d class definition  extends from the \u201cDatabaseRole\u201d class definition , and the cloud-service manager  determines from the class definition  of the \u201cDataBaseRole\u201d class that, the backend database software (e.g., the MySQL database software) is to be installed on the same virtual machine as the frontend role software. Based on the above information, the service manager  adds a block  under the blocks  and , to represent the underlying virtual machine for the frontend role and the database role.","Furthermore, according to the \u201cDatabaseRole\u201d class definition , the cloud-service manager  determines that a persistent disk is connected to the database role by a mount point on the underlying virtual machine. The persistent disk is deployed according to the specification specified in the \u201cMysqlPD\u201d class definition . Therefore, the service manager  adds a block  to the block  representing the mantis deployment, and adds a connection  to represent the connectivity relationship between the database software, its underlying virtual machine, and the permanent disk.","In some implementations, when the components of the deployment is deployed, the service manager  can also record identifiers associated with the underlying infrastructure components (e.g., process IDs or identifiers of the virtual machines and other virtual resources) for each block or connection represented in the block diagram . When the cloud-service manager  monitors the statuses of the underlying virtual resources and services for the deployment, the cloud-service manager  optionally determines the performance or usage metrics for each component (e.g., blocks and connections) represented in the block diagram . The cloud-service manager  can also optionally represent the performances and usage of the different component in the system block diagram .","In some implementations, visualization of the performances and usage of these different components of the deployment and their changes over time can be shown on the block diagram . In some implementations, the cloud-service manager  can present the performance and usage statistics in a visual form on the block diagram in a management interface of the cloud services for each cloud-service user. For example, the performance and usage statistics can be represented as a histogram or pie chart that dynamically changes according to the actual conditions of the components in the cloud environment. In some implementations, the cloud-service provider bills the cloud-service customers according to the performance and usage statistics.","In some implementations, the configuration specification optionally includes programmatically triggered reconfiguration requests. For example, the configuration specification for a component can specified that when a particular monitored parameter reaches a specified threshold value, the cloud-service manager  is to scale the provisioned virtual machine or services by a specified amount. For a more specific example, the class definition of the persistent disk class (e.g., the \u201cMysqlPD\u201d class definition) can include a statement that requests an increase in the size of the persistent disk when the disk capacity is 80% utilized; the class definition of the \u201cfrontendVM\u201d class can request that when the latency of the frontend role is more than one second, the \u201creplica-count\u201d parameter of the FrontendVM is to be increased by one; and so on.","As set forth in this specification, the object-oriented specification language allows the configuration of each component in a cloud-based deployment to be specified by a respective set of class definitions. When parsing a configuration specification, the service manager is able to identify the components of the deployment, and identify all of the base classes whose class parameters contributed to or influenced the configuration state of the component. In some implementations, the performance of each component is associated with the class definitions that contributed to the configuration of that component. If a class definition contributed to the configuration of multiple components in multiple deployments, the performance of these multiple components in the multiple deployments can all be associated with that class definition. The quality of the class definition can be assessed based at least in part on the aggregated performance of all of the multiple components in the multiple deployments.","In some implementations, the cloud-service manager keeps track of the usage of each class definition in the cloud-based environment and charges the cloud-service users that have used the class definition in their deployments. Optionally, the amount of charge billed to the users is based on the amount of usage the user has accrued for the class definition in all of the deployments the user has requested. In some implementations, where the class definitions are provided by third-party definition providers, the cloud-service manager  can record a credit to the third-party definition provider for each use of the class definition provided by the third-party definition provider.","For example, when parsing the configuration specification for the Mantis application deployment shown in , the cloud-service manager  records that the Mantis frontend component  is deployed according to the \u201cMantisFrontendRole\u201d class definition , which extends the \u201clamp.FrontendRole\u201d class definition , uses the \u201cmantis_frontend\u201d class definition for software configuration, and the \u201cMantisPackage\u201d class definition  to identify the location of the software package, and is connected to the \u201cMantisDatabaseRole\u201d class . Further, the service manager  determines that the \u201clamp.FrontendRole\u201d class definition  further extends from the \u201cstd.Role\u201d class definition, uses the \u201cFrontendVM\u201d class definition , and that the \u201cFrontendVM\u201d class definition  extends from the \u201cutils.ConfiguratorLAMP\u201d class definition.","The cloud-service manager  can continue to identify the class definitions that are involved in the configuration of the frontend role component of the deployment by tracing the class hierarchies connected to the \u201cMantisFrontendRole\u201d class definition , until the most fundamental sets of class definitions are identified. All of the class definitions that contributed to the configuration of the frontend role component are associated with the frontend role component for the deployment. A similar process can be carried out for each component of the deployment.","When the deployment is carried out, the cloud-service manager  can record the usage of each class definition in configuring the deployment according to the number of times that the class definition is used in the deployment. In some implementations, multiple uses of a class definition is counted only once in each deployment or for each user, depending on the payment structure (e.g., fees per use license or per sale) established by the definition supplier of the class definition.","In some implementations, in a marketplace of reusable class definitions, each reused class definition can be ranked against other reused class definitions according to the aggregate performance of the class definition in all the deployments that used the class definition. In some implementations, the performance of a deployment can be associated with each class definition that contributed to the configuration of the deployment, and used in evaluating the quality of the class definition. In some implementations, only performances of those components whose configurations are influenced by a class definition are associated with the class definition and used in evaluating the quality of the class definition.","For example, when the cloud-service manager identified multiple components in multiple deployments that are influenced by a virtual machine class definition, the aggregated performance of the multiple components are used in evaluating the quality of the virtual machine class definition. In addition, when the cloud-service manager identifies all of the class definitions that contributed to the configuration of a frontend role component of a deployment, the performance associated with the frontend role component in the deployment will be associated with each of these identified class definitions.","In some implementations, a quality score is calculated for each class definition based on the aggregated performance associated with all or multiple components or deployments that are configured based at least in part on the class definition. The quality score can be presented with the class definition in the definition selection interface provided by the cloud-service provider. In some implementations, multiple quality metrics can be calculated for each class definition based on, for example, the scales of the deployments that utilized the class definition, the weight or influence of the class definition in each deployment that utilized the class definition, the availability, fault tolerance, scalability, and failure rate of the components configured according to the class definition, the types of problems encountered, the modifications required to solve the encountered problems, explicit user feedback, and so on. Based on the various quality metrics, one or more types of quality scores can be provided for each shared class definition and a potential definition user can browse the list of available shared class definitions based on the quality scores.","Although the above example describes the quality scores with respect to reusable class definitions, similar quality scores can be calculated for reusable class modules, reusable configuration specifications, or configuration-wrapped software solutions.",{"@attributes":{"id":"p-0176","num":"0175"},"figref":["FIG. 6","FIGS. 3A-3C","FIG. 1","FIG. 4"],"b":["600","600","104","222","600","404"]},"In the example process , a configuration specification for configuring a cloud-based deployment is received (e.g., by the API translator of a cloud-service provider) (). The configuration specification is written in an object-oriented specification language and requires instantiation of class definitions of one or more classes. Each class models a respective data or functional component of the cloud-based deployment using a group of configurable class parameters. The respective class definition of each class represents a requested state of the data or functional component modeled by the class. A plurality of API calls for configuring the cloud-based deployment are derived based on the class definitions of the one or more classes (). Then, the API translator of the cloud-service provider causes the plurality of API calls to be executed to configure the cloud-based deployment ().","In some implementations, the one or more classes include at least an existing base class and at least a customized class extended from the existing base class. In some implementations, the customized class inherits respective class parameters of the existing base class and modifies a value of at least one of the class parameters inherited from the existing base class. In addition, or alternatively, the customized class inherits respective class parameters of the existing base class and includes at least one new class parameter not present in the existing base class.","In some implementations, the data or functional component modeled by each class is one of a virtual device supporting a cloud-based environment, a service utilized in the cloud-based environment, a software role performed by an installed application in the cloud-based environment, a data package holding data to be used during deployment or operation of the cloud-based environment, or a combination of one or more thereof.","In some implementations, the object-oriented specification language supports dependency between class definitions, and a definition dependency between a first class and a second class represents a deployment dependency between respective components modeled by the first and the second class. In some implementations, the definition dependency between the first class and the second class is expressed by a class parameter of the first class where the class parameter of the first class refers to an instance of the second class.","In some implementations, the object-oriented specification language supports connectivity between class definitions, and a value assignment linking an instance of a second class to a class parameter of a first class represents a connectivity between respective components modeled by the first class and the second class.",{"@attributes":{"id":"p-0182","num":"0181"},"figref":["FIG. 7","FIGS. 1 and 4"],"b":["700","700","104"]},"In the example process , the cloud-service provider identifies, based on the respective class definitions of the one or more classes in a configuration specification, a plurality of data and functional components modeled by the one or more classes and one or more dependency and connectivity relationships existing among the plurality of data or functional components (). Then, the cloud-service provider derives a block diagram of a cloud-based environment based on the identified plurality of data and functional components and the identified dependency and connectivity relationships (). In some implementations, when deriving the block diagram, the cloud-service provider also represents trigger events for dynamic reconfiguration of the cloud-based environment in the block diagram.",{"@attributes":{"id":"p-0184","num":"0183"},"figref":"FIG. 8","b":"800"},"In the example process , for each class definition, the cloud-service provider identifies an aspect of the cloud-based deployments that are influenced by the class definition in terms the respective initial configuration state of the aspect (). The cloud-service provider monitors one or more performance metrics associated with the identified aspect (). The cloud-service provider associates the one or more performance metrics with the class definition (). Then, the cloud-service provider utilizes the one or more performance metrics in calculating a quality metric of the class definition ().",{"@attributes":{"id":"p-0186","num":"0185"},"figref":"FIG. 9","b":"900"},"In the example process , the cloud-service provider identifies a plurality of cloud-based deployments each having been carried out according to a respective configuration specification written in the object-oriented specification language (). The cloud-service provider then identifies at least one base class whose class definition is used in multiple of the plurality of cloud-based deployments (). The cloud-service provider monitors respective performance of each of the multiple of the plurality of cloud-based deployments (). The cloud-service provider then calculates a quality metric of the at least one base class based on aggregated performance of the multiple of the plurality of cloud-based deployments (). In some implementations, the respective performance of each of the multiple of the plurality of cloud-based environment is a performance associated with a data or function component modeled by the at least one class.",{"@attributes":{"id":"p-0188","num":"0187"},"figref":"FIG. 10","b":"1000"},"In the example process , the cloud-service provider stores respective class definitions of a plurality of core classes of the object-oriented specification language (). Each core class corresponds to a modular component of a cloud-based environment and each core class is extendable with additional class parameters to configure the respective modular component. The cloud-service provider also stores a mapping between each of the core classes and a respective group of API calls (). The respective group of API calls is for configuring the modular component associated with the core class according to the class parameters of the core class. The cloud-service provider also stores a plurality of protocols for modifying the respective groups of API calls associated with each core class to obtain a new group of API calls for a new class definition derived from the core class ().","In some implementations, to derive the plurality of API calls for configuring the cloud-based deployment, the cloud-service provider derives the plurality of API calls based on the respective groups of API calls associated with one or more of the plurality of core classes from which the one or more classes of the configuration specification are derived, and based on the plurality of protocols for modifying the respective groups of API calls.","In some implementations, the plurality of protocols further includes rules for imposing an ordering of the groups of API calls according to dependency and connectivity relationships specified in class definitions written according to the object-oriented specification language.",{"@attributes":{"id":"p-0192","num":"0191"},"figref":"FIG. 11","b":["1100","1100"]},"In the example process , the cloud-service provider or platform provider receives a respective definition submission from each of a plurality of definition suppliers (). The respective definition submission includes one or more class definitions written in an object-oriented specification language. Each class definition models a data or functional component of a cloud-based deployment using a group of configurable class parameters and is extendable to create at least one new class definition by a modification to one or more of the group of configurable class parameters or an addition of one or more new class parameters. The cloud-service provider or platform provider then provides a user interface that presents the class definitions received from the plurality of definition suppliers, for review and selection by a plurality of definition users ().",{"@attributes":{"id":"p-0194","num":"0193"},"figref":["FIG. 12","FIG. 4"],"b":["1200","1200","104"]},"In the example process , the cloud-service provider receives a plurality of distinct configuration specifications written in the object-oriented specification language (). The plurality of distinct configuration specifications are each for configuring a distinct cloud-based deployment and including a distinct class definition that extends from the same one of the class definitions received from the plurality of definition suppliers. Then, the cloud-service provider configures each of the distinct cloud-based deployments based at least on the same one of the received class definitions and the distinct class definition that extends therefrom in the distinct configuration specification of the distinct cloud-based deployment ().",{"@attributes":{"id":"p-0196","num":"0195"},"figref":"FIG. 13","b":"1300"},"In the example process , for each of the received class definitions, the cloud-service provider monitors usage of the class definition in a plurality of configuration specifications that have been used to configure a plurality of cloud-based deployments (). The cloud-service provider records, for each use of the class definition in the plurality of configuration specifications, a credit to a definition supplier of the class definition and a charge to a definition user associated with the use ().","In some implementations, the usage of the class definition includes an instantiation of the class definition in a respective configuration specification that has been used to carry out a respective cloud-based deployment. In some implementations, the usage of the class definition includes an extension of the class definition to create a new class definition that is instantiated in a respective configuration specification used to carry out a respective cloud-based deployment.",{"@attributes":{"id":"p-0199","num":"0198"},"figref":"FIG. 14","b":["1400","1400"]},"In the example process , the cloud-service provider or platform provider receives a software submission from a software supplier (). The software submission includes a software application to be deployed in a cloud-based environment and a plurality of distinct configuration specifications each for deploying the software application in the cloud-based environment in a distinct manner. Then, the cloud-service provider or platform provider provides the plurality of distinct configuration specifications for review and selection by a software user ().",{"@attributes":{"id":"p-0201","num":"0200"},"figref":["FIG. 15","FIG. 4"],"b":["1500","1500","104"]},"In the example process , the cloud-service provider receives selection of one of the plurality of distinct configuration specification by the software user (). The cloud-service provider deploys the software application in the cloud-based environment according to the selected distinct configuration specification (). Then, the cloud-service provider records a charge to the software user and a credit to the software supplier based on a respective price associated the selected distinct configuration specification (). In some implementations, to provide the plurality of class definitions for selection, the cloud-service provider provides the respective performance metrics with each of the plurality of class definitions for user review in a selection user interface.",{"@attributes":{"id":"p-0203","num":"0202"},"figref":["FIG. 16","FIG. 4"],"b":["1600","1600","104"]},"In the example process , the cloud-service provider provides a plurality of class definitions for selection (). Each class definition models a respective data or functional component of a cloud-based environment using a group of configurable class parameters. Each class definition supports instantiation and inheritance of the class definition in a configuration specification for a cloud-based deployment. The cloud-service provider also derives respective performance metrics associated with each of the plurality of class definitions based on aggregated performance of multiple cloud-based deployments, where the multiple cloud-based deployments had been carried out according to respective configuration specifications that require instantiation of the class definition or a new class definition derived from the class definition (). Then, the cloud-service provider utilizes the respective performance metrics associated with each of the plurality of class definitions in ranking the plurality of class definitions ().",{"@attributes":{"id":"p-0205","num":"0204"},"figref":"FIG. 17","b":"1700"},"In the example process , the cloud-service provider categorizing the plurality of class definitions based on the respective data or functional components of the cloud-based environment modeled by the plurality of class definitions (). Then, the cloud-service provider ranks the plurality of class definitions within the class definitions' respective categories ().",{"@attributes":{"id":"p-0207","num":"0206"},"figref":"FIG. 18","b":"1800"},"In the example process , for each of a plurality of class definitions, the cloud-service provider identifies a plurality of cloud-based deployments that had been carried out according to respective configuration specifications that required instantiation of the class definition or at least one new class definition derived from the class definition (). The cloud-service provider monitors respective performances of the plurality of cloud-based deployments (). The cloud-service provider then associates the respective performances of the plurality of deployments with the class definition ().",{"@attributes":{"id":"p-0209","num":"0208"},"figref":"FIG. 19","b":"1900"},"When deriving respective performance metrics associated with each of a plurality of class definitions based on aggregated performance of multiple cloud-based deployments, the cloud-service provider performs the example process . In the example process , the cloud-service provider, for each of the plurality of class definitions, identifies one or more data or functional components in the plurality of cloud-based deployments that were configured according to the class definition or a new class definition derived from the class definition (). The cloud-service provider identifies one or more performance metrics associated with the identified one or more data or functional components (). Then, the cloud-service provider derives the respective performance metrics associated with the class definition by aggregating the identified one or more performance metrics (). In some implementations, the performance metrics include one or more measures of latency, reliability, scalability, availability, or security.",{"@attributes":{"id":"p-0211","num":"0210"},"figref":"FIG. 20","b":"2000"},"In the example process , for each class definition, the cloud-service provider tracks a respective count of cloud-based deployments that have been configured at least in part according to the class definition (). Optionally, the cloud-service provider tracks a respective count of problems encountered in cloud-based deployments that have been configured at least in part according to the class definition. Optionally, the cloud-service provider also tracks a number of required changes to resolve the problems encountered in the cloud-based deployments that have been configured at least in part according to the class definition. Then, the cloud-service provider utilizes the respective counts associated with the plurality of class definitions in the ranking of the plurality of class definitions (). Optionally, the cloud-service provider also utilizes the respective counts of the problems and the respective numbers of required changes associated with the plurality of class definitions in the ranking of the plurality of class definitions.","In some implementations, the respective numbers of required changes associated with the plurality of class definitions are used to calculate respective weights given to the respective performance metrics associated with the plurality of class definitions in ranking the plurality of class definitions.","Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a computer storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on a propagated signal that is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.","The term \u201cdata processing apparatus\u201d encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.","A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.","The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing or executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few.","Computer readable media suitable for storing computer program instructions and data include all forms of nonvolatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.","To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's user device in response to requests received from the web browser.","Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), e.g., the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.","Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.","Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 2B","FIG. 2A"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 3C","FIG. 3B"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 5","FIG. 3C"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
