---
title: Populating resource-constrained devices with content verified using API definitions
abstract: Remote incremental program verification may be achieved by receiving content verified by at least one content provider, installing the content on a resource-constrained device, disabling subsequent installation of content on the resource-constrained device, and issuing the resource-constrained device to an end user. The at least one content provider includes an applet provider, a device manufacturer, and a device issuer. The content includes at least one program unit, where each program unit comprises an Application Programming Interface (API) definition file and an implementation. Each API definition file defines items in its associated program unit that are made accessible to one or more other program units, and each implementation includes executable code corresponding to the API definition file. The executable code includes type specific instructions and data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06883163&OS=06883163&RS=06883163
owner: Sun Microsystems, Inc.
number: 06883163
owner_city: Santa Clara
owner_country: US
publication_date: 20000914
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application claims the benefit of provisional patent application Ser. No. 60\/200,480 filed Apr. 28, 2000 in the name of Judith E. Schwabe, entitled \u201cSystem and Method for Remote Incremental Program Verification Using API Definitions\u201d.","This application is related to the following:\n\n","1. Field of the Invention","The present invention relates to computer systems. More particularly, the present invention relates to a system and method for remote distributed program verification using API definitions.","2. Background","In general, computer programs are written as source code statements in a high level language that is easy for a human being to understand. As the computer programs are actually executed, a computer responds to machine code, which consists of instructions comprised of binary signals that directly control the operation of a central processing unit (CPU). A special program called a compiler is typically used to read the source code and to convert its statements into the machine code instructions of the specific CPU. The machine code instructions thus produced are platform dependent, that is, different computer devices have different CPUs with different instruction sets indicated by different machine codes.","More powerful programs are typically constructed by combining several simpler programs. This combination can be made by copying segments of source code together before compiling and then compiling the combined source. When a segment of source code statements is frequently used without changes, it is often preferable to compile it once, by itself, to produce a module, and to combine the module with other modules only when that functionality is actually needed. This combining of modules after compilation is called linking. When the decision on which modules to combine depends upon run time conditions and the combination of the modules happens at run time, just before execution, the linking is called dynamic linking.","Object Oriented Principles","Object oriented programming techniques such as those used by the Java\u2122 platform are widely used. The basic unit of object oriented programs is an \u201cobject\u201d. An object has methods (procedures) and fields (data). The term \u201cmembers\u201d is used herein to refer to methods and fields. A method declares executable code that can be invoked and that passes a fixed number of values as arguments. A class defines the shared members of the objects. Each object then is a particular instance of the class to which it belongs. In practice, a class is a template to create multiple objects (multiple instances) with similar features.","One property of classes is encapsulation. Encapsulation is used to describe a system wherein access to an object is provided through an interface, while keeping the details private. In other words, the actual implementation of the members within the class is hidden from an outside user and from other classes, except as exposed by an interface. This makes classes suitable for distributed development, for example by different developers at different sites on a network. A complete program can be formed by assembling the classes that are needed, linking them together, and executing the resulting program.","Classes enjoy the property of inheritance. Inheritance is a mechanism that enables one class to inherit all of the members of another class. The class that inherits from another class is called a subclass; the class that provides the attributes is the superclass. Symbolically, this can be written as subclass <=superclass, or superclass =>subclass. The subclass can extend the capabilities of the superclass by adding additional members. The subclass can override a virtual method of the superclass by providing a substitute method with the same name and type.","The members of a class type are fields and methods; these include members inherited from the superclass. The class file also names the superclass. A member can be public, which means that it can be accessed by members of the class that contains its declaration. A member can also be private. A private field of a class is visible only in methods defined within that class. Similarly, a private method may only be invoked by methods within the class. Private members are not visible within subclasses, and are not inherited by subclasses as other members are. A member can also be protected.","An interface type is a type whose members are constants and abstract methods. This type has no implementation, but otherwise unrelated classes can implement it by providing implementations for its abstract methods. Interfaces may have sub-interfaces, just as classes may have subclasses. A sub-interface inherits from its super-interface, and may define new methods and constants as well. Additionally, an interface can extend more than one interface at a time. An interface that extends more than one interface inherits all the abstract methods and constants from each of those interfaces, and may define its own additional methods and constants.","Java\u2122 Programming Language","In the Java\u2122 programming language, classes can be grouped and the group can be named; the named group of classes is a package. If a class member is not declared with any of the public, private or protected keywords, then it is visible only within the class that defines it and within classes that are part of the same package. A protected member may be accessed by members of declaring class or from anywhere in the package in which it is declared. The Java\u2122 programming language is described in detail in Gosling, et al., \u201cThe Java\u2122 Language Specification\u201d, August 1996, Addison-Wesley Longman, Inc.","Java\u2122 Virtual Machine","Programs written in the Java\u2122 language execute on a Java\u2122 virtual machine (JVM), which is an abstract computer architecture that can be implemented in hardware or software. Either implementation is intended to be included in the following description of a VM. For the purposes of this disclosure, the term \u201cprocessor\u201d may be used to refer to a physical computer or a virtual machine.","A virtual machine is an abstract computing machine generated by a software application or sequence of instructions that is executed by a processor. The term \u201carchitecture-neutral\u201d refers to programs, such as those written in the Java\u2122 programming language, which can be executed by a virtual machine on a variety of computer platforms having a variety of different computer architectures. Thus, for example, a virtual machine implemented on a Windows\u2122 based personal computer system will execute an application using the same set of instructions as a virtual machine implemented on a UNIX\u2122-based computer system. The result of the platform-independent coding of a virtual machine's sequence of instructions is a stream of one or more bytecodes, each of which is, for example, a one-byte-long numerical code.","The Java\u2122 Virtual Machine (JVM) is one example of a virtual machine. Compiled code to be executed by the Java\u2122 Virtual Machine is represented using a hardware- and operating system-independent binary format, typically stored in a file, known as the class file format. The class file is designed to handle object oriented structures that can represent programs written in the Java\u2122 programming language, but may also support several other programming languages. These other languages may include, by way of example, Smalltalk. The class file format precisely defines the representation of a class or interface, including details such as byte ordering that might be taken for granted in a platform-specific object file format. For the sake of security, the Java\u2122 Virtual Machine imposes strong format and structural constraints on the instructions in a class file. In particular example, JVM instructions are type specific, intended to operate on operands that are of a given type as explained below. Any language with functionality that can be expressed in terms of a valid class file can be hosted by the Java\u2122 Virtual Machine. The class file is designed to handle object oriented structures that can represent programs written in the Java\u2122 programming language, but may also support several other programming languages. The Java\u2122 Virtual Machine is described in detail in Lindholm, et al., \u201cThe Java\u2122 Virtual Machine Specification\u201d, April 1999, Addison-Wesley Longman, Inc., Second Edition.","The process of programming using such a VM then has two time periods associated with it; \u201ccompile time\u201d refers to the steps which convert the high level language into VM instructions, and \u201crun time\u201d refers to the steps which, in a Java\u2122 VM environment, interpret instructions to execute the module. Between compile time and run time, the modules of instructions compiled from statements can reside dormant for extended, arbitrary periods of time, or can be transferred from one storage device to another, including being transferred across a network.","Loading refers to the process of finding the binary form of a class or module with a particular name, typically by retrieving a binary representation previously compiled from source code. In the JVM, the loading step retrieves the class file representing the desired class. The loading process is implemented by the bootstrap loader or a user defined class loader. A user-defined class loader is itself defined by a class. A class loader may indicate a particular sequence of locations to search in order to find the class file representing a named class.","Linking in the JVM is the process of taking a binary form of a class in memory and combining it into the run time state of a VM, so that it can be executed. A class is loaded before it is linked.","Verification","For many reasons, particularly regarding the integrity of downloaded computer programs, the Internet and other insecure communication mediums are potentially \u201chostile\u201d environments. A downloaded program may contain errors involving the data types of operands not matching the data type restrictions of the instructions using those operands, which may cause the program to fail during execution. Even worse, a program might attempt to create object references (e.g. by loading a computed number into the operand stack and then attempting to use the computed number as an object handle) and to thereby breach the security and\/or integrity of the user's computer. Alternatively, one or more of the modules may have been updated since the others were prepared. It is therefore prudent, when assembling several modules that may have been written independently, to check both that (1) each module properly adheres to the language semantics and that (2) the set of modules properly adheres to the language semantics. These checks are typically performed on program modules containing instructions produced from compiled source code. By analogy with the terminology used by the designers of the Java\u2122 programming language, this post-compilation module checking can be called verification. A verifier, therefore, performs an essential role in ensuring a secure runtime environment.","The binary classes of the JVM are examples of general program modules that contain instructions produced from compiled source statements. Context sensitivity of validity checks performed during verification means that those checks depend on information spread across more than one module, i.e., those checks are called inter-module checks herein. Validity checks that do not require information from another module are called intra-module checks herein. Intra-module checks include, for example, determining whether the downloaded program will underflow or overflow its stack, whether any instruction will process data of the wrong type and whether the downloaded program will violate files and other resources on the user's computer. See, for example, U.S. Pat. No. 5,668,999 to Gosling, U.S. Pat. No. 5,748,964 to Gosling and U.S. Pat. No. 5,740,441 to Yellin et al.","During normal execution of programs using languages that do not feature pre-execution verification, the operand stack must be continuously monitored for overflows (i.e., adding more data to the stack than the stack can store) and underflows (i.e., attempting to pop data off the stack when the stack is empty). Such stack monitoring must normally be performed for all instructions that change the stack's status (which includes most all instructions). For many programs, stack monitoring instructions executed by the interpreter account for approximately 80% of the execution time of an interpreted computer program.","Turning now to , a high level flow diagram that illustrates verification is presented. At , intra-module checks are performed to determine whether a module is internally consistent. At , inter-module checks are performed to determine whether the module is consistent within the context of externally referenced modules. Verification is successful if both checks pass. Execution of a module is prevented if either checks fail.","Verification typically follows an execution path. Verification starts at a program's main entry point and proceeds in a \u201ctop down\u201d fashion, one instruction at a time. During this process, the verifier may encounter a reference to an external library that includes at least one program unit. At this point, the verifier obtains the binary file for the external library and continues verification along an execution path.","Turning now to , a high level flow diagram that illustrates verification of an application to be executed on a resource-rich device  is presented. Verification is typically performed on a relatively resource-rich device  such as a desktop computer. A compiler  compiles a source file . During compilation, the compiler  verifies the correct use of data and instructions. These checks include intra-module checks and inter-module checks. The output of the source code compiler  is a binary file  containing the executable instructions corresponding to the source file . When the binary file  is referenced by an application executing on a virtual machine , a loader  loads the binary file . A verifier  verifies the binary file  at some point prior to execution by an interpreter . If the binary file  references any items that are external to the binary file , the verifier  verifies the binary file  against the referenced binary file(s)  containing the externally referenced item(s).","Turning now to , a block diagram that illustrates the need for verification is presented.  is the same as , except that binary file  and\/or referenced binary file  are potentially modified at some point after source file  is compiled. The modification may be the result of an update of a binary file  or referenced binary file . Alternatively, modification of the binary file  or referenced binary file  may be the result of file corruption. As mentioned previously, such program modifications could potentially cause the program to violate Java\u2122 semantics and thus breach the security and\/or integrity of the host computer .","Note that some updates in  are allowed. Some changes made when revising a binary file result in the new version being backward compatible with the previous version. When a newer version is backward compatible with an older version, the versions are said to be binary compatible. Binary compatibility is discussed in greater detail below. A verification error should be indicated when versions are not binary compatible. Thus, some updates may pass verification, but corrupted binary files must not pass verification.","Verification coupled with execution time has some disadvantages. For example, in an object oriented programming language system like the Java\u2122 platforms (but not Java Card\u2122 platforms), it leads to a verifier initiating class loading when the verifier needs to check subtype relations among classes not already loaded. Such loading can occur even if the code referencing other classes is never executed. Because of this, loading can consume memory and slow execution at run time as compared to a process that does not load the classes unless they are referenced by the instructions that are actually executed.","Methods for verification coupled with execution time typically do not verify one class or module at a time before run time. This is a disadvantage because classes cannot be verified ahead of time, e.g. before run time, so verification must incur a run time cost. Thus, there is a need for module-by module, also called module-at-a-time, verification before run time. Such verification is also called pre-verification because technically it is distinct from the verification which occurs during run time linking by the Java Card\u2122 Virtual Machine (JCVM).","Also, since verification is typically performed at run time, a class that has been run once, and passed verification, is subjected to verification again each time the class is loaded\u2014even when reverification is not required. Reverification may not be required, for example, when the class is being used in the same application on the same processor, or in an environment that prevents changes that would affect verification. This can lead to redundant verification, thereby requiring more memory and executing more slowly during run time than ought to be necessary. Thus, there is a need for an option to use verified modules without further, or with minimum verification at run time.","Resource-Constrained Devices","Resource-constrained devices are generally considered to be those that are relatively restricted in memory and\/or computing power or speed, as compared to typical desktop computers and the like. Other resource-constrained devices include, by way of example, smart cards, cellular telephones, boundary scan devices, field programmable devices, personal digital assistants (PDAs) and pagers and other miniature or small footprint devices.","Smart cards, also known as intelligent portable data-carrying cards, are a type of resource-constrained device. Smart cards are typically made of plastic or metal and have an electronic chip that includes an embedded microprocessor or microcontroller to execute programs and memory to store programs and data. Such devices, which can be about the size of a credit card, typically have computer chips with 8-or 16 bit architectures. Additionally, these devices typically have limited memory capacity. For example, some smart cards have less than one kilobyte (1K) of random access memory (RAM) as well as limited read only memory (ROM), and\/or non-volatile memory such as electrically erasable programmable read only memory (EEPROM).","A Java\u2122 virtual machine executes programs written in the Java\u2122 programming language and is designed for use on desktop computers, which are relatively rich in memory. It would be desirable to write programs that use the full implementation of the Java\u2122 virtual machine for execution on resource-constrained devices such as smart cards. However, due to the limited architecture and memory of resource-constrained devices such as smart cards, the full Java\u2122 virtual machine platform cannot be implemented on such devices. Accordingly, a separate Java Card\u2122 (the smart card that supports the Java\u2122 programming language) technology supports a subset of the Java\u2122 programming language for resource-constrained devices.","Referring to , development of an applet for a resource-constrained device, such as a smart card , begins in a manner similar to development of a Java\u2122 program. In other words, a developer writes one or more Java\u2122 classes and compiles the source code with a Java\u2122 compiler to produce one or more class files . The applet can be run, tested and debugged, for example, on a workstation using simulation tools to emulate the environment on the card . When the applet is ready to be downloaded to the card , the class files  are converted to a converted applet (CAP) file  by a converter . The converter  can be a Java\u2122 application being executed by a desktop computer. The converter  can accept as its input one or more export files  in addition to the class files  to be converted. An export file  contains naming or linking information for the contents of other packages that are imported by the classes being converted.","Referring to , the CAP format is parallel to the class file information. Each CAP  contains all of the classes and interfaces defined in one Java\u2122 package. A CAP file  has a compact and optimized format, so that a Java\u2122 package can be efficiently stored and executed on resource-constrained devices. Among other things, the CAP file  includes a constant pool component (or \u201cconstant pool\u201d)  that is packaged separately from a methods component . The constant pool  can include various types of constants including method and field references which are resolved either when the program is linked or downloaded to the smart card or at the time of execution by the smart card. The methods component  specifies the application instructions to be downloaded to the smart card and subsequently executed by the smart card. Also included in a CAP file , among other things, are class definitions , field definitions , and descriptive type definitions .","Referring again to , after conversion, the CAP file  can be stored on a computer-readable medium  such as a hard drive, a floppy disk, an optical storage medium, a flash device or some other suitable medium. Or the computer-readable medium can be in the form of a carrier wave, e.g., a network data transmission or a radio frequency (RF) data link.","The CAP file  then can be copied or transferred to a terminal  such as a desktop computer with a peripheral card acceptance device (CAD) . The CAD  allows information to be written to and retrieved from the smart card . The CAD  includes a card port (not shown) into which the smart card  can be inserted. Once inserted, contacts from a connector press against the surface connection area on the smart card  to provide power and to permit communications with the smart card , although, in other implementations, contactless communications can be used. The terminal  also includes an installation tool  that loads the CAP file  for transmission to the card .","The smart card  has an input\/output (I\/O) port  which can include a set of contacts through which programs, data and other communications are provided. The card  also includes a loader  for receiving the contents of the CAP file  and preparing the applet for execution on the card . The installation tool  can be implemented, for example, as a Java\u2122 program and can be executed on the card . The card  also has memory, including volatile memory such as RAM . The card  also has ROM  and non-volatile memory, such as EEPROM . The applet prepared by the loader  can be stored in the EEPROM .","As mentioned regarding , verification is typically performed on a resource-rich device. Verification programs are typically large programs that require a relatively large amount of runtime memory when executing. Also, verifier programs typically require large amounts of detailed descriptive information in the verification process. This descriptive information includes information regarding field types, signature types and access flags (private, protected, etc). This type information is typically maintained in secondary storage. Such memory requirements are typically not an issue on relatively resource rich devices such as a desktop computer. However, these same characteristics make verification ill-suited for resource-constrained devices such as smart cards. Providing verification of program modules to execute on a resource-constrained device is critical to ensure the integrity of program modules executed such a device. Accordingly, a need exists in the prior art for a system and method for remote verification of programs to be executed by a resource-constrained device.","As mentioned previously, a Java\u2122 verifier proceeds along an applet's execution path, verifying all external references in the process. This means that the verifier must have access to the full binary file of not only the module to be verified, but also all modules in the execution path of the module to be verified. However, some of the libraries may contain proprietary implementations that must not be revealed to consumers. For example, a vendor may install a library that contains proprietary implementation algorithms (such as an encryption algorithm) that must not be revealed to another vendor. Since typical verification methods require revealing the binary files of the modules to be verified, such methods could reveal proprietary information. Accordingly, there is a need in the prior art for a system and method for program verification that does not reveal proprietary details.","Moreover, a library may have multiple implementations. Verification with a particular implementation does not guarantee verification with another implementation. Accordingly, there is a need in the prior art for a system and method for specifying when verification with a first implementation guarantees verification with a second implementation.","Program Module Hierarchical Dependencies",{"@attributes":{"id":"p-0043","num":"0047"},"figref":"FIG. 6","b":["285","280","290","290","295","300","305"]},"Each of the boxes shown in  represents a Java\u2122 package. A package is called a library package if it exports items and is therefore referenced by other packages. A package is called an applet package if it contains a program entry point. Some packages are both library and applet packages.","As shown in , a package may depend on other packages at the same API level or from those packages in lower API levels. The Java Card\u2122 framework  may have dependencies from the Java\u2122 language framework . Moreover, the custom framework  at the custom API level and the applets  and  may have references that depend from the Java Card\u2122 framework . In turn, the applet  may have references that depend on the custom framework . The applet  and the custom framework  may also depend on the Java\u2122 language framework . Applets may also depend on one another as shown by the line from Applet  to Applet . In this case, Applet  is both an applet and library package.","Although the example of  shows linear dependencies, non-linear dependencies such as circular dependencies may be supported using a suitable converter and installation tool.","Post-Issuance Install","The Java Card\u2122 CAP file format provides for the post issuance installation of applications. In other words, the CAP file allows the content of a resource-constrained device to be updated after the device has been issued to an end user. The capability to install applications after the card has been issued provides card issuers with the ability to respond dynamically to their customer's changing needs. For example, if a customer decides to enroll in the frequent flyer program associated with the card, the card issuer can add this functionality, without having to issue a new card.","The Java Card\u2122 CAP file format thus provides more flexibility for application issuers. Application issuers may implement transactional services as applets, and then host these applets, either in their own cards or in the cards of other issuers with whom they do business. For example, an issuer may provide a core service to clients in the form of Java\u2122 applets for the issuer's cards. The clients will then combine these applets with other applets designed to provide a variety of value added services. These applet combinations can be updated through the dynamic applet loading process to meet the changing needs of individual customers.","Turning now to , a block diagram that illustrates preparation of a resource-constrained device without post-issuance installation is presented. A manufacturer typically prepares the resource-constrained device by loading it with some initial content (). This initial content typically includes the native OS, Java Card\u2122 VM and some or all of the Java Card\u2122API packages (). Some initial applets and\/or libraries may be provided by an applet or library provider (). The initial content is burned into ROM. This process of writing the permanent components into the non-mutable memory of a chip for carrying out incoming commands is called masking. The manufacturer may also load general data onto the card's non-volatile memory. This data is identical across a large number of cards and is not specific to an individual. An example of this general data is the name of a card manufacturer.","Typically, the manufacturer also personalizes the content of a card by assigning the card to a person. This may occur through physical personalization or through electronic personalization. Physical personalization refers to permanently marking by, for example, embossing or laser engraving the person's name and card number on the physical surface of a card. Electronic personalization refers to loading personal data into a card's non-volatile memory. Examples of personal data include a person's name, personal ID or PIN number, and personal key.","Next, an issuer  obtains an initialized device from the manufacturer. The issuer may obtain additional applets or libraries from a provider and load the additional content onto the device. This further customization of the cards is performed by installing the applets or libraries in the form of CAP files. The issuer may also load general data, such as the issuer name, into the card's non-volatile memory.","After preparing the cards (), the issuer disables subsequent installation of libraries or applets on the device and distributes the device to an end user . At this point, the card is ready for use having its complete content. Since installation has been disabled, no further content will be added after the card has been issued. The card may be obtained from an issuer, or it can be bought from a retailer. Cards sold by a retailer can be general-purpose, in which case personalization is often omitted.","Turning now to , a block diagram that illustrates preparation of a resource-constrained device with post-issuance installation is presented. The diagram illustrates the case where a \u201ctrusted\u201d installer  installs additional content on the device after the device has been issued to the end user . The post-issuance installer  is \u201ctrusted\u201d because of a preexisting agreement between the post-issuance installer  and the issuer . In this case, the issuer  distributes the device to the end user  without disabling subsequent installations. The end user may update the content of the resource-constrained device by presenting it to a \u201ctrusted\u201d post-issuance installer . The \u201ctrusted\u201d post-issuance installer  installs additional content on the resource-constrained device and returns it to the end user . The installation is performed by transmitting a CAP file to the device.","In the scenario illustrated in , the roles of the manufacturer, issuer, services provider and applet provider are described. These roles can be filled by one or more entities.","Typically, each of the roles described in  entail testing the applets and packages before they are installed on the device. Testing checks the functional behavior of these modules, confirming that given a particular input a required output is produced. Testing examines a different domain than verification, described above.","A Java Card\u2122 system may be constructed incrementally and at each stage, it is desirable to ensure program integrity. For example, the manufacturer may populate a resource-constrained device with one or more libraries. Before shipping, it would be desirable for the manufacturer to guarantee the content integrity. At this stage, there are only libraries on the device, and no applets. Without an applet, there is no applet entry point and therefore no execution path for a verifier to follow. If an issuer then adds an applet, it would be desirable continue to ensure the content integrity. Accordingly, a need exists in the prior art for a system and method for remote program verification that accounts for iterative installation. There is a further need for a system and method for resource-constrained device program verification that protects against untrusted post-issuance installers.","Binary Compatibility","In Java Card\u2122 technology, a change to a type in a Java\u2122 package results in a new CAP file. A new CAP file is binary compatible with a preexisting CAP file if another CAP file converted using the export file of the preexisting CAP file can link with the new CAP file without errors.","The Java\u2122 Language Specification includes several examples of binary compatible changes for the Java\u2122 language. These examples include adding a class and adding a field to a class. Examples of binary incompatible changes include deleting a class and changing the parameters to a method.","The Java Card\u2122 Virtual Machine specification defines binary compatible changes to be a strict subset of those defined for the Java\u2122 programming language. An example of a binary compatible change in the Java\u2122 programming language that is not binary compatible in the Java Card\u2122 platform is adding a public virtual method to a class that can be extended by a referencing binary file.","Turning now to , a block diagram that illustrates binary compatibility is presented.  shows an example of binary compatible CAP files, P1 () and P1\u2032 (). The preconditions for the example are: The package P1 is converted to create the P1 CAP file () and P1 export file (), and package P1 is modified and converted to create the P1 CAP file (). Package P2 imports package P1, and therefore when the P2 CAP file () is created, the export file of P1 () is used. In the example, P2 is converted using the original P1 export file (). Because P1\u2032 is binary compatible with P, P2 may be linked with either the P1 CAP file () or the P1 CAP file ().","The Java Card\u2122 Virtual Machine further specifies that major and minor version numbers be assigned to each revision of a binary file. These version numbers are record in both CAP and export files. When the major version numbers of two revisions are not equal, the two revisions are not binary compatible. When the major version numbers of the two revisions are equal, the revision with the larger minor version number is binary (backward) compatible with the revision with the smaller minor version number.","The major and minor versions of a package are assigned by the package provider. A major version is changed when a new implementation of a package is not binary compatible with the previous implementation. The value of the new major version is greater than the version of the previous implementation. When a major version is changed, the associated minor version is assigned the value of 0.","When a new implementation of a package is binary compatible with the previous implementation, it is assigned a major version equal to the major version of the previous implementation. The minor version assigned to the new implementation is greater than the minor version of the previous implementation.","Both an export file and a CAP file contain the major and minor version numbers of the package described. When a CAP file is installed on a Java Card\u2122 enabled device, a resident image of the package is created, and the major and minor version numbers are recorded as a part of that image. When an export file is used during preparation of a CAP file, the version numbers indicated in the export file are recorded in the CAP file.","During installation, references from the package of the CAP file being installed to an imported package can be resolved only when the version numbers indicated in the export file used during preparation of the CAP file are compatible with the version numbers of the resident image. They are compatible when the major version numbers are equal and the minor version of the export file is less than or equal to the minor version of the resident image.","Any modification that causes binary incompatibility in Java Card\u2122 systems may cause an error at run time. Accordingly, an additional need exists in the prior art for a system and method for program verification that ensures binary compatibility.","A method for remote incremental program verification includes receiving content verified by at least one content provider, installing the content on a resource-constrained device and issuing the resource-constrained device to an end user. The content includes at least one program unit and each program unit includes an Application Programming Interface (API) definition file and an implementation. Each API definition file defines items in its associated program unit that are made accessible to one or more other program units and each implementation includes executable code corresponding to the API definition file. The executable code includes type specific instructions and data. According to one aspect, subsequent installation of content on the resource-constrained device is disabled. A resource-constrained device includes a memory for providing content verified by at least one content provider and a virtual machine that is capable of executing instructions included within the content. The content includes at least one program unit and each program unit includes an Application Programming Interface (API) definition file and an implementation. Each API definition file defines items in its associated program unit that are made accessible to one or more other program units, each implementation includes executable code corresponding to the API definition file, and executable code includes type specific instructions and data.","Those of ordinary skill in the art will realize that the following description of the present invention is illustrative only. Other embodiments of the invention will readily suggest themselves to such skilled persons having the benefit of this disclosure.","This invention relates to computer systems. More particularly, the present invention relates to a system and method for remote distributed program verification using API definition files. The invention further relates to machine-readable media on which are stored (1) the layout parameters of the present invention and\/or (2) program instructions for using the present invention in performing operations on a computer. Such media includes by way of example magnetic tape, magnetic disks, optically readable media such as CD ROMs and semiconductor memory such as PCMCIA cards. The medium may also take the form of a portable item such as a small disk, diskette or cassette. The medium may also take the form of a larger or immobile item such as a hard disk drive or a computer RAM.","According to embodiments of the present invention, a verifier uses API definition files of program modules to perform inter-module consistency checks. Each program has an associated verification status value that is True if the program's integrity is verified by the verifier, and it is otherwise set to False. Use of the verifier in accordance with the present invention enables verification of a program's integrity and allows the use of an interpreter that does not execute the usual stack monitoring instructions during program execution, thereby greatly accelerating the program interpretation process.","According to embodiments of the present invention, verification does not continue beyond an API definition file. This differs from typical verification methods that continue the verification process into an implementation of the API definition file. An API definition file defines the context of a binary file in relationship to other referenced binary files. Once it is shown that binary files are implemented in accordance with their API definition files, binary files that reference items in other binary files need only look to the API definition files of whatever binary files implement those items to determine whether two binary files are compatible. Verifying that a binary file is implemented in accordance with its API thus obviates the need for other binary files that reference the verified binary file to continue the verification process into the verified binary file because it has already been verified. Using API definition files in accordance with the present invention therefore provides a mechanism for making conclusions regarding whether a referencing program passes verification, without the disadvantages of typical known verification methods.",{"@attributes":{"id":"p-0106","num":"0110"},"figref":["FIGS. 10A","FIGS. 10A and 10B","FIGS. 10C and 10D"],"b":"10"},"The examples in  illustrate analysis which is typically performed during verification using a virtual stack. The virtual stack is validated and updated during verification based on the operations defined for instructions in a method. (For examples of virtual stack usage during verification, See U.S. Pat. No. 5,668,999 to Gosling, U.S. Pat. No. 5,748,964 to Gosling and U.S. Pat. No. 5,740,441 to Yellin et al.)","Turning now to , a flow diagram that illustrates verification that follows an execution path is presented. At , a bytecode program is loaded into a verifier and the verifier is initialized. At , the instruction pointer is set to the first instruction in the program. At , a determination is made regarding whether the instruction is a method invocation instruction. If the instruction is not a method invocation instruction, the instruction is verified at . If the instruction is a method invocation instruction, at , a determination is made regarding whether the current virtual stack matches the list of expected parameter and result types, also referred to as the method signature, found in the binary file that contains the referenced method. If there is no match, a verification error is indicated at . If there is a match, at , the invoked method is verified. At  a determination is made regarding whether the invoked method was successfully verified. If the invoked method was not successfully verified, a verification error is indicated at . At , a determination is made regarding whether the current instruction is the last instruction. If the current instruction is not the last instruction, verification continues with the next instruction at . Verification terminates at  when the last instruction has been examined.","With respect to reference numerals 415-425 of , when a method invocation instruction is encountered during verification that is coupled with execution, a typical verifier performs the following operations pertaining to the content of the referencing binary file.\n\n","Typically, either before step 1 or between steps 2 and 3, the referenced binary file is verified. Regardless of the exact timing, when verification is coupled with execution, a referenced binary file is verified before it is executed.","The example shown in FIG A does illustrate verification of references to non-methods such as classes, interfaces and fields. Typically, verification of such non-method preferences also entails examining the referenced items. Furthermore, when examining such referenced items, the referenced binary file that contains the referenced item is also typically verified.","Turning now to , a code sample that illustrates verification that follows an execution path is presented.  includes code samples for a library package L0  and applet A1 . Applet A1  includes references to items in package L0 .  also illustrates a virtual stack before () and after (515) verification of method invocation instructions in L0  and A1 . Method A10  references method A11  at reference numeral . Method A11  references method L01  at reference numeral . Method L01  references method L02  at reference numeral .","Verification of applet A1  begins with method A10 . At , method A10  invokes method A11  with the short integer parameter S  and assigns the result to byte array ba . In preparation for the method A11  invocation, the method A11  parameter types are put on the stack. In Java\u2122 technology, values of type byte, short and integer are represented as integer types on the stack. Thus, before invoking method A11 , the virtual stack  contains type int, the type for S . This matches the declaration of method A11  found in the A1 binary file .","At , method A11  invokes method L01  and assigns the result to byte array type ba . Before invoking method L01 , the virtual stack  contains a reference to class A1. The expected type is type Object . A1  is assignment-compatible with Object  because A1  extends Object (). This matches the declaration of method L01  found in the L0 binary file .","At , method L01  invokes method L02  and assigns the result to float value f . Before invoking method L02 , the virtual stack  contains a reference to class Object. The virtual stack  also contains an integer type corresponding to integer I . This matches the declaration of method L02  found in the L0 binary file .","Next, the virtual stack is updated by removing the arguments to the invoked method and adding the return type, if any, of the invoked method. The return type is defined in the referenced binary file. In the above example, method L02  returns float type f , which matches the method L02 return type of float f . Method L01  returns an integer type. At , the returned integer type is explicitly cast to type byte, which matches the type of ba[0] . Method A11  returns a byte array, which corresponds to the type of byte array ba .","Thus, method A10  has been verified by examining the content of method A10  and the binaries of all compilation units referenced by method A10 .","Verification using an API definition file according to embodiments of the present invention follows the same four steps shown above with reference to , except that information about the invoked method is obtained from an API definition file instead of a binary file. The conclusions drawn regarding verification of the referencing binary file are the same in both cases. In addition, at some point during verification, the API definition file is verified for internal consistency. This step is parallel to verifying a referenced binary file. Furthermore, during verification using an API definition file according to embodiments of the present invention, the assumption is made that an implementation of the API definition file has been verified in a previous operation and that the implementation is complainant with the API definition file. This is described in more detail with reference to .","Turning now to , a flow diagram that illustrates verification that follows an execution path to an API definition file in accordance with one embodiment of the present invention is presented. At , a verifier receives a bytecode program and the verifier is initialized. At , the instruction pointer is set to the first instruction in the program. At , a determination is made regarding whether the current instruction is a method invocation to an external method. If the current instruction is not a method invocation to an external method, the instruction is verified at . If the instruction is a method invocation instruction, at , a determination is made regarding whether the virtual stack matches the method signature found in an API definition file that corresponds to the binary file of the invoked method. If the virtual stack does not match the method signature, a verification error is indicated at . If the virtual stack matches the method signature, the virtual stack is updated at . At , a determination is made regarding whether the current instruction is the last instruction. If there is another instruction, the next instruction is pointed to at  and verification continues at . Verification ends at  when the last instruction has been examined. A detailed example that illustrates this process is described with reference to FIG. D.","Turning now to , a code sample that illustrates verification that follows an execution path to an API in accordance with one embodiment of the present invention is presented.  includes code samples for a library package L0  and applet A1 . Applet A1  includes references to items in package L0 .  also illustrates a virtual stack before () and after () execution of source code statements in L0  and A1 . Method A10  references method A11  at reference numeral . Method A11  references method L01  at reference numeral .","Verification of applet A1  begins with method A10 . At , method A10  invokes method A11  with the short integer parameter S  and assigns the result to byte array ba . In preparation for the method A11 invocation (), the method A11  parameter types are put on the stack . As mentioned above, in Java\u2122 technology, values of type byte, short and integer are represented as integer types on the stack. Thus, before invoking method A11 , the virtual stack  contains type int, the type for S . This matches the declaration of method A11  found in the A1 binary file .","At , method A11  invokes method L01  and assigns the result to byte array type ba . Before invoking method L01 , the virtual stack  contains a reference to class A1. The expected type is type Object . A1  is assignment-compaitable with Object  because A1  extends Object (). This matches the declaration of method L01  found in the L0 API definition file .","Next, the virtual stack is updated by removing the arguments to the invoked method and adding the return type, if any, of the invoked method. The return type is defined in the referenced API definition file. In the above example, method L01  returns an integer type. At , the returned integer type is explicitly cast to type byte, which matches the type of ba[0] . Method A11  returns a byte array, which corresponds to the type of byte array ba .","Thus, method A10  has been verified without reference to the binary files containing compilation units referenced by method A10 . Instead, method A10  has been verified by examining the content of method A10  and the API definition files of all compilation units referenced by method A10 .","The description regarding verification in  illustrated verification with respect to a method. This example is intended for illustrative purposes only. Those of ordinary skill in the art will recognize that verification of other references may be performed in a similar manner using an API definition file. These references include by way of example, references to fields, classes and interfaces.","Referring now to , there is shown a distributed computer system having multiple client computers ,  and multiple server computers . In one embodiment, each client computer ,  is connected to the servers  via the Internet , although other types of communication connections could be used. While most client computers are desktop computers, such as Sun workstations, IBM compatible computers and Macintosh computers, virtually any type of computer can be a client computer. In one embodiment, each client computer includes a CPU , a user interface , a memory , Internet access processor  and a communications interface . Client memory  stores:\n\n","The converter  converts a binary file into an optimized binary file and an API definition file of the optimized binary file. If the binary file includes external reference, the converter  uses the API definition file stored in  of the module including the external reference to verify the external reference.","According to one embodiment of the present invention, the resource-constrained device is a Java Card\u2122 enabled device. In this embodiment, the API definition file is Java Card\u2122 export file, the binary file is a class file and the optimized binary file is a CAP file. Also, the methods in a class to be loaded are bytecode programs, which when interpreted will result in a series of executable instructions. According to this embodiment, the bytecode program verifier  verifies the integrity of the bytecode programs in a CAP file with reference to the CAP file, the export file corresponding to the CAP file, and the export file containing externally referenced items. If all the methods are successfully verified, the CAP file is sent to the resource-constrained device  via a terminal device .","As shown in , a terminal  is equipped with a card acceptance device (CAD)  for receiving a card. The terminal  may be connected to a network  that communicates with a plurality of other computing devices, such as a server . It is possible to load data and software onto a smart card over the network  using card equipped devices. Downloads of this nature include applets or libraries to be loaded onto a smart card as well as digital cash and other information used in accordance with a variety of electronic commerce and other applications. The verified instructions and data used to control processing elements of the card acceptance device and of the smart card may be stored in volatile or non-volatile memory or may be received directly over a communications link e.g., as a carrier wave containing the instructions and\/or data. Further, for example, the network  can be a LAN or WAN such as the Internet or other network.","The third computer node , assumed here to be configured as smart card or other resource-constrained device, includes a microprocessor , a memory , and an I\/O port  that connects the second computer node to the terminal device . Resource-constrained device memory  stores programs for execution by the processor .","Resource-constrained device memory  stores:","an operating system ;",{"@attributes":{"id":"p-0131","num":"0000"},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["a loader  for loading a verified optimized binary file via  port ;","an interpreter  for executing a module within an optimized binary file;","at least one program  for execution by microprocessor ."]}}}},"The first, second and third computer nodes ,  and  may utilize different computer platforms and operating systems ,  such that object code program executed on either one of the two computer nodes cannot be executed on the other. For instance, the server node  might be a Sun Microsystems computer using a nix operating system while the user workstation node  may be an IBM compatible computer system using a Pentium III microprocessor and a Windows 98 operating system. Furthermore, other user workstations coupled to the same network and utilizing the same server  might use a variety of operating systems.","According to embodiments of the present invention, verification is performed before the module is loaded on a resource-constrained device, herein referred as remote verification. According to one embodiment of the present invention, verification is performed on a resource-rich device such as a desktop PC, as illustrated in FIG. A. According to another embodiment of the present invention, remote verification is performed on a terminal device, as illustrated in FIG. B.","Turning now to , a block diagram that illustrates verification on a resource-rich device before installation in accordance with one embodiment of the present invention is presented. A verifier  resident on the resource-rich device  verifies the optimized binary file . The optimized binary file  is transferred to a terminal device  having an installer . The installer  communicates with a loader  on a resource-constrained device  to load the verified optimized binary file.","According to one embodiment of the present invention the loader confirms that the context in which the binary file will be linked and executed is compatible with the context of the API definition files used during verification. Additionally, the context of a verified and loaded binary file must not be allowed to change in to an incompatible state. In a Java Card\u2122 compliant system, this requirement is fulfilled by ensuring that a referenced binary file is never deleted or updated.","Turning now to , a block diagram that illustrates verification on a terminal device before installation in accordance with one embodiment of the present invention is presented. The optimized binary file  is transferred to a terminal device  having an off-device installer . A verifier  resident on the terminal device  verifies the optimized binary file . The installer  communicates with a loader  on a resource-constrained device  to load the verified optimized binary file.","Turning now to , a flow diagram that illustrates verification in accordance with one embodiment of the present invention is presented. At , a library or applet is received. At , the library or applet is verified using the applet binary file, the API definition file of the library or applet if it exports items, and the API definition file of any binary files containing items referenced by the applet binary file. At , the library or applet is stored in a secure state to protect against unauthorized modification. At , the library or applet is loaded for subsequent linking and execution on a resource-constrained device.","Turning now to , a block diagram that illustrates verification relationships using Application Programming Interface (API) definitions in accordance with one embodiment of the present invention is presented.  illustrates the process of verifying applet A1. In this example, A1 is an applet that references the library L1. Library L1 includes a reference to Library L0. Verification proceeds as follows: First, the L0 API definition file  is verified with the L0 binary file . Next, the L1 binary file  is verified with the L0 API definition file . Next, the L1 API definition file  is verified with the L1 binary file . Verification of the L1 binary file  with the L0 API definition file  thus indicates the L1 binary file  is verified with the L0 binary file . Next, the A1 binary file  is verified with the L1 API definition file . Verification of the A1 binary file  with the L1 API definition file  thus indicates the A1 binary file  is verified with the L1 binary file . Thus, a fully verified collection of binary files (A1 , L1  and L0 ) has been constructed.","As mentioned previously, an API specifies how one program module may interact with another. Different vendors may implement an API in different ways, as long as they adhere to the API definition file. For example, one vendor may choose to implement a method that sorts a set of values using an algorithm optimized for speed, while another vendor may choose to implement an algorithm optimized for low memory usage. In both cases, the implementations would be compliant with an API definition file containing a method that performs a sort, and vary in implementation details.","According to embodiments of the present invention, verification does not depend upon a particular implementation. More specifically, if a referencing binary file references an API and there is more than one implementation for that API, the referencing binary file is said to be verified with each implementation if the referencing binary file verifies with the referenced API and if each implementation of the API verifies with the referenced API definition file. This example is illustrated in FIG. B.","Turning now to , a block diagram that illustrates implementation-independent verification using an API definition file with multiple implementations in accordance with one embodiment of the present invention is presented. In the example, L1 is a library that references library L0. Library L0 has two implementations from two different vendors, vendor  implemented  and vendor  implemented . Both the L0 binary file from vendor  () and the L0 binary file from vendor  () are verified with the L0 API definition file . Next, the L1 binary file  is verified with the L0 API definition file . Since both L0 binary files  and  are verified against the L0 API definition file  and since the L1 binary file  is verified against the L0 API definition file , the L1 binary file  is verified against both particular implementations of L0, that is binary files  and . Thus, two fully verified collections of binary files have been constructed: 1) L1 binary file  and L0 binary file provided by vendor  (); and 2) L1 binary file and L0 binary file provided by vendor  ().","As shown in , verification applies to all permutations of linking. Thus, when binary file L1 () is installed on one resource-constrained device, it may be linked with the L0 binary file from vendor  (). It may also be installed on another resource-constrained device and linked with the L0 binary file from vendor  ().","The number of implementations illustrated in  is not intended to be limiting in any way. Those of ordinary skill in the art will recognize that the invention is applicable when more that two implementations are provided.","According to one embodiment of the present invention, program verification is performed iteratively, one program module at a time. This is also called distributed verification. Referring to , a flow diagram that illustrates incrementally constructing a verified system in accordance with one embodiment of the present invention is presented. An initial library is verified (), stored in a secure state () and loaded (). At , the API definition file of the initial verified library is provided for use by client libraries or applets that reference library. Each client library or applet is verified (), stored in a secure state () and loaded (). At , a check is made to determine whether the client exports any items. If the client exports any items, the API definition file of the client library is provided for use by other libraries or applets that reference the client library ().","According to another embodiment of the present invention, the loading of verified libraries and applets is delayed until all the libraries and applets required for an update have been verified. In both this case and the embodiment described immediately above, the process of performing verification using API definition files is the same.","Turning now to , a block diagram that illustrates verification and installation of an initial library in accordance with one embodiment of the present invention is presented. In this example, the resource-constrained device  contains a loader , an interpreter and I\/O services . No libraries or applets have been installed at this point. This initial content provides the foundation for installing and executing libraries and applets. First, a verifier  on a resource-rich device  verifies the L0 binary file , the library to be added. The resource-rich device may be by way of example, a desktop PC or a terminal device. Verification of the L0 binary file  includes verifying the L0 binary file  and verifying the L0 API definition file  with the L0 binary file . Next, the verified L0 binary file  is installed on a resource-constrained device . After installation, the content of the resource-constrained device  is said to be verified.","Turning now to , a block diagram that illustrates verification and installation of an applet that references a library in accordance with one embodiment of the present invention is presented. In this example, resource-constrained device  has been initialized with library L0 (see ) and applet A1 is to be added to the resource-constrained device . Applet A1 binary file  references library L0. Since the L0 binary file  has already been verified with its corresponding L0 API definition file  and installed, the verified API definition file for L0  is resident on the resource-rich device . The A1 binary file  is verified using the API definition file of the referenced library, L0 . After verification, the A1 binary file  is installed on the resource-constrained device. After installation, the content of the resource-constrained device (A1 binary file  and L0 binary file ) is said to be verified.","Those of ordinary skill in the art will recognize that the scenarios illustrated in  can be combined to verify and install a module that both references a library and exports an API. The module's exported API definition file will be available to be referenced by succeeding binary files. Turning now to , a flow diagram that illustrates verifying a library or applet in accordance with one embodiment of the present invention is presented. At , a library or applet package is received. At , intra-module checks are performed to determine whether the package is internally consistent. At , inter-module checks are performed to determine whether the external references of the package are consistent within the context of the API definition file of each external reference. At , a check is made to determine whether the package exports any items. If the package exports items, the current package is verified against its API definition file ().","The order of the intra-module checks and the inter-module checks shown in  is not intended to indicate a required order of operations. During program verification that follows an execution path, those of ordinary skill in the art will recognize that when intra-module checks or inter-module checks are performed can depend on the context of the element being verified. When performing intra-module checks, if an element is encountered that references an external item, an inter-module check can be performed immediately. Alternatively, all inter-module checks can be postponed and performed in one step as shown in FIG. .","The intra-module checks may include by way of example, verifying binary file format and verifying that:\n\n","See, for example, U.S. Pat. No. 5,668,999 to Gosling, U. S. Pat. No. 5,748,964 to Gosling and U.S. Pat. No. 5,740,441 to Yellin et al.","Turning now to , a flow diagram that illustrates verifying external references using an API definition file in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  in FIG. . At , a program unit such as a library or applet package is received. If the API definition file of the referenced package is not found, a verification error is indicated. At , the API definition file of the referenced package is loaded. At , the package attributes are compared. The package attributes may include by way of example, the package name and version. If the package attributes are not compatible, a verification error is indicated.","At , for each referenced class and interface, the usage of the class or interface in the binary file is compared to the corresponding usage in the API definition file. If the class or interface is not found in the API definition file, a verification error is indicated. If usage of the class or interface is not compatible, a verification error is indicated. An example of an incompatibility is an attempt to create an instance of an abstract class or interface.","At , for each referenced field, the field is located in the API definition file, and the usage of the field in the binary file is compared to the corresponding definition in the API. If the field is not found in the API definition file, a verification error is indicated. If the usage of the field is not compatible, a verification error is indicated. An example of an incompatibility is an attempt to store a floating-point value into a field that is declared as an integer (int)-type in the API definition file.","At , for each referenced method, the method is located in the API definition file, and the usage of the method in the binary file is compared to the definition in the API. If the method is not found in the API definition file, a verification error is indicated. If the usage of the method is not compatible, a verification error is indicated. An example of an incompatibility is an attempt to invoke a method without passing in any parameters when the method is declared in the API definition file to require one parameter of the specified type (int).","Those of ordinary skill in the art will recognize that locating and verifying usage against definitions in an API definition file can be performed sequentially in one step as shown in FIG. . Alternatively, locating and verifying usage against definition can be performed as the usage is encountered.","Turning now to , a flow diagram that illustrates verifying a package with its corresponding API definition file in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  in FIG. .  is not intended to indicate the order in which the various checks are performed. A library or applet package (herein referred to as a binary file) is received () and the API definition file of the package is received (). If the API definition file of the package is not found, and the binary file exports elements, a verification error is indicated.","At , the package attributes are compared. The attributes may include by way of example, the package name, version and number of classes and interfaces. Continuing this example, this step detects whether an extra class or interface is defined in the API definition file that is not present in the binary file. If the attributes are incompatible, a verification error is indicated.","Several checks are performed to verify each exported class and interface in the binary file. At , the class or interface is located in the API definition file and the attributes of the class or interface as defined in the API definition file are compared to the definition of the class or interface in the binary file. If the class or interface is not found in the API definition file, a verification error is indicated. The attributes may include by way of example, the class name, flags, number of fields and number of methods. Continuing this example, this step detects whether an extra field or method is defined in the API definition file that is not present in the binary file. Additionally, this step will detect whether an extra field or method is present in the binary file but not defined in the API definition file. If the attributes are incompatible, an error is indicated.","At , the superclasses and superinterfaces are compared. See, for example, U.S. Provisional Patent Application filed Nov. 12, 1999 in the name of inventor Judith E. Schwabe, entitled \u201cAPI Representation Enabling Submerged Hierarchy\u201d, Ser. No. 60\/165,298 and U.S. Provisional Patent Application filed Nov. 15, 1999 in the name of inventor Judith E. Schwabe, entitled \u201cAPI Representation Enabling Submerged Hierarchy\u201d, Ser. No. 60\/165,533. If the set of public superclasses or superinterfaces of a class or interfaces, respectively, defined in the binary file do not correspond to the set in the API definition file, a verification error is indicated.","At , the set of public implemented interfaces of a class in the binary file is compared to the set in the API definition file. If the sets of implemented interfaces do not correspond, a verification error is indicated.","At , for each exported field in the binary file, the field is located in the API definition file and the attributes of the field in the API definition file are compared to the definition in the binary file. If the field is not located, a verification error is indicated. The attributes may include by way of example, the name, flags and type. If the attributes are incompatible, a verification error is indicated.","At , for each exported method in the binary file, the method is located in the API definition file and the attributes of the method in the API definition file are compared to the definition in the binary file. If the method is not found in the API definition file, a verification error is indicated. The attributes may include by way of example, the name, flags and signature. If the attributes are incompatible, a verification error is indicated.","Turning now to , a flow diagram that illustrates loading a library or applet onto a resource-constrained device in accordance with one embodiment of the present invention is presented. At , a program unit such as a library or applet package is received. At , the program unit is authenticated. At , a determination is made regarding whether the program unit references one or more other program units. If the program unit references one or more other program units, at , the version of the API definition file used during verification is checked to determine whether it is compatible with the version of the referenced binary file resident on the resource-constrained device. If the versions are not compatible, an error is indicated. At , the program unit is loaded or otherwise prepared for execution when the version of the API definition file used during verification is compatible with the version of the referenced binary resident on the resource-constrained device.","The invention as described thus far has pertained to scenarios where the version of a referenced binary file is the same version as its corresponding API definition file. As to discussed previously, both the Java\u2122 specification and the Java Card\u2122 specification define behavior where the version of a referenced binary file is a newer version than the one used during preparation of the referencing binary file. Furthermore, these specifications define changes that can be made when revising a binary file that result in the new version being backward compatible with the previous version. When a newer version is backward compatible with an older version it is said to be binary compatible.","Binary compatible changes to a referenced binary file are undetectable to a referencing binary file. The updated referenced binary file is required to contain all of the elements of the API definition file of the original binary file. Accordingly, a referencing binary file is provided with a superset of the element in original API of the referenced binary file, and therefore all of the elements it references are guaranteed to be present. A referencing binary file may be successfully linked with, verified with and executed with any binary compatible revision of the original target referenced binary file. Thus, it is valid in both Java\u2122 and Java Card\u2122 technology to prepare a binary file using an old version of a referenced binary file and then later link, verify and execute with a new, binary compatible version of the referenced binary file.","According to one embodiment of the present invention, an additional verification step is performed on a resource-rich device to confirm whether or not a revision of a binary file is binary (backward) compatible with an earlier version. This additional step provides the functionality required to assert that a referencing binary file and a binary compatible revision of a referenced binary file constitute a verified set. The details of this verification step are described in .","Those of ordinary skill in the art will recognize that other versioning schemes can also be used to provide binary compatibility information as well.","Turning now to , a block diagram that illustrates verification using API definition files of backward compatible revisions in accordance with one embodiment of the present invention is presented. The example illustrated in  includes an applet A1 that references library L0. Library L0 has two versions, 1.0 and 1.1. Each version of library L0 has been previously converted to a binary file and an API definition file. The A1 binary file  was initially verified against L0 version 1.0. The precondition for this verification is verifying the L0 API definition file version 1.0 () with the L0binary file version 1.0 (). As described in , these verification steps indicate that A1 binary file () is verified with L0 binary file version 1.0 ().","Library L0 version 1.0 was subsequently changed to create L0 version 1.1. According to one embodiment of the present invention verification of the A1 binary file () with the L0 version 1.1 binary file () is established by verifying that L0 API definition file version 1.1 () is backward compatible with L0 API definition file version 1.0 () and by verifying that L0 API definition file version 1.1 () verifies with L0 binary file version 1.1 (). Hence, a modified referenced library does not require verification of a referencing applet with the API definition file of the modified referenced library when it can be shown that the API definition file of the modified referenced library is backward compatible with the original referenced library and when the API definition file of the modified referenced library verifies with the binary file of the modified referenced library.","The verification steps shown in  indicate that A1 binary file () is verified with L0 binary file version 1.1 ().","Turning now to , a block diagram that illustrates verification using API definition files of backward compatible revisions in accordance with one embodiment of the present invention is presented.  illustrates the case where a binary compatible version of a library has been previously installed on a resource-constrained device. The referencing binary file, A1 (), is prepared and verified using an earlier version of the referenced API definition file. The L0 binary file version 1.1 () was previously verified with the L0 API definition file version 1.1 (). Next, the previously verified API (L0 API definition file version 1.1 ()) is verified to be backward compatible with the earlier version (L0 API definition file version 1.0 ())). Next, the A1 binary file () is verified using the API definition files of the referenced library (L0 API definition file version 1.0 ()) and the A1 binary file () is installed on the resource-constrained device . A loader  on the resource-constrained device  verifies that the API definition file used during verification is compatible with the referenced binary file. The resulting content of the resource-constrained device  is a verified set of binary files: A1 binary file () and L0 binary file version 1.1 ().","Turning now to , a flow diagram that illustrates verifying versions using API definition files in accordance with one embodiment of the present invention is presented. At , the old version of the package API definition file is received. At , the new version of the package API definition file is received. At , a determination is made regarding whether the version of the new package indicates backward compatibility with the version of the old package. In Java Card\u2122 technology, for example, this determination is made by comparing major and minor version numbers. If the new version is backward compatible, at , the content of the new API definition file is verified for backward compatibility with the content of the old API definition file.","Turning now to , a flow diagram that illustrates verifying that the content of a new API definition file is backward compatible with the content of an old API definition file in accordance with one embodiment of the present invention is presented. At  and , the old package API definition file and the new API package definition are received.","At , the package attributes are compared. The attributes may include the package name and the number of classes and interfaces. If the set of classes and interfaces defined in the old API definition file is not found in the new API definition file, a verification error is indicated.","Several checks are performed for each class and interface in the old package. At the class and interface attributes are compared to the attributes of the same class or interface in the new package. The attributes may include the name, flags, number of fields and number of methods. If the sets of fields and methods defined in a class or interface in the old API definition file are not found in the corresponding class or interface in the new API definition file, a verification error is indicated. If any other the attributes of a class or interface are not binary compatible, a verification error is indicated.","At , the superclasses and superinterfaces of the class or interface are compared to the same in the new package. If the sets of superclasses or superinterfaces of a class or interface, respectively, are not binary compatible, a verification error is indicated.","At , the implemented interfaces of a class are compared to the same in the new package. If the sets of implemented interfaces of a class are not binary compatible, a verification error is indicated.","At , for each field in the old package, the attributes are compared to the same field in the new package. The attributes may include the name, flags and type. If the attributes of a field are not binary compatible, a verification error is indicated.","At , for each method in the old package, the attributes are compared to the same method in the new package. The attributes may include the name, flags and signature. If the attributes of a method are not binary compatible, a verification error is indicated.","The list of binary compatibility checks performed is not intended to be an exhaustive list. Further details regarding binary compatibility may be found in the Java\u2122 Language Specification and the Java Card\u2122 Virtual Machine Specification.","According to embodiments of the present invention, program modules are verified on a resource-rich device prior to an installation on a resource-constrained device such as a smart card.  to D illustrate different embodiments in which verification is performed.","According to one embodiment of the present invention, program modules are optionally verified by a card manufacturer, a card issuer and an applet or library provider. Verification may performed by any combination of the above parties. Referring to , a manufacturer ensures that the initial content is verified and prepares a device with that initial content () before shipping the device to an issuer. The initial modules may be verified either by the manufacturer, the applet or library provider (), or both. The issuer receives the device from the manufacturer, optionally installs additional modules, disables further installations and distributes the device () to an end user . If additional modules are installed, the issuer ensures that they are verified before installation. The issuer, applet or library provider, or both may perform verification.","Turning now to , according to another embodiment of the present invention, program modules are optionally verified by a card manufacturer (), a card issuer (), an applet provider () and a trusted post-issuance installer (). Verification may be performed by any combination of the above parties, but must result in each module being verified before it is installed on a device. Referring to , post-issuance installations by a trusted installer () are allowed. Verification is optionally performed by the applet or library provider () before shipping. Verification is also optionally performed by the manufacturer (), the issuer () and the post-issuance installer () before the additional content is installed on the device.","In , the post-issuance installer is a trusted installer (). A trusted installer () is an installer that has an agreement with the issuer, governing the post-issuance updates of cards. In contrast, an untrusted installer has no such agreement with the installer. When an issuer issues cards without disabling subsequent installations, an untrusted and possibly malevolent post-issuance installer could potentially add program modules to a card. Such unauthorized additions may corrupt the existing program modules or compromise them in other ways, causing the program to either execute erroneously or not execute at all.","According to another embodiment of the present invention, verification of program modules is performed in a system that allows post-issuance installations by an untrusted installer. Referring to , note that  is the same as , except that the post-issuance installer () is untrusted. Preferably, the verifier in this case resides on a terminal device or another device not under the control of the untrusted installer ().","According to another embodiment of the present invention, verification of program modules is performed in a system that allows post-issuance installations by an untrusted installer. Furthermore, this embodiment performs binary compatibility checks as part of the verification. Referring to , note that  is the same as , except that each party that performs verification includes binary compatibility checks in the verification process. Those of ordinary skill in the art will recognize that verification that entails binary compatibility checks can also be applied to the scenarios shown in .","The above embodiments differ in the entities that are involved in the preparation of a card for an individual user. The above embodiments also differ regarding whether post-issuance installation is enabled. However, the details of verification process are equivalent, regardless of the entity performing the verification.","According to one embodiment of the present invention, the manufacturer, issuer and trusted post-issuance installer consider the applet or library to have been received from a potentially hostile environment. The verifier is run with the applet or library before installation. The manufacturer, issuer and trusted post-issuance installer make a determination regarding whether their environments are secure. If the environments are secure, the scenario depicted in either  (verifier on resource-rich device) or  (verifier on terminal) is used. If the environments are not secure, the scenario depicted in  (verifier on terminal) is used.","Preferably, the untrusted post-issuance installation operates in the scenario depicted in  (verifier on terminal).","In the scenario depicted by  (verifier on resource-rich device), the content provider preferably runs the verifier before shipping (using FIG. A), thus confirming that the binary file was not corrupted when it was prepared or stored in the applet\/package provider's environment, and ensuring that the applet package provider is not shipping a hostile binary file to the manufacture, issuer, trusted post-issuance installer, or untrusted post-issuance installer.","According to one embodiment of the present invention, verification includes binary compatibility checks. Preferably, the manufacturer and issuer confirm that the updated resource-constrained device is binary compatible with the previous version(s). This prevents an older program unit from being placed into an invalid context when installed.","According to a preferred embodiment, programmatic content is installed in a secure environment. Once a verified binary file has been installed, the smart card's programmatic content is not altered by an unauthorized entity. Therefore, once a verified binary file is installed in this secure environment, the binary file's verification status is unchanged between subsequent executions. In other words, the binary file need not be re-verified before each execution.","Although the present invention has been illustrated with respect to a smart card implementation, the invention applies to other devices with a small footprint such as devices that are relatively restricted or limited in memory or in computing power or speed. Such resource-constrained devices may include boundary scan devices, field programmable devices, pagers and cellular phones among many others.","The present invention also relates to apparatus for performing these operations. This apparatus may be specially constructed for the required purpose or it may comprise a general-purpose computer as selectively activated or reconfigured by a computer program stored in the computer. The procedures presented herein are not inherently related to a particular computer or other apparatus. Various general-purpose machines may be used with programs written in accordance with the teachings herein, or it may prove more convenient to construct more specialized apparatus to perform the required process. The required structure for a variety of these machines will appear from the description given.","While the Java\u2122 programming language and platform are suitable for the invention, any language or platform having certain characteristics would be well suited for implementing the invention. These characteristics include type safety, pointer safety, object-oriented, dynamically linked, and virtual machine based. Not all of these characteristics need to be present in a particular implementation. In some embodiments, languages or platforms lacking one or more of these characteristics may be utilized. Also, although the invention has been illustrated showing object-by-object security, other approaches, such as class-by-class security, could be utilized.","Additionally, while embodiments of the present invention have been illustrated using applets, those of ordinary skill in the art will recognize that the invention may be applied to stand-alone application programs.","The system of the present invention may be implemented in hardware or in a computer program. Each such computer program can be stored on a storage medium or device (e.g., CD-ROM, hard disk or magnetic diskette) that is readable by a general or special purpose programmable computer for configuring and operating the computer when the storage medium device is read by the computer to perform the procedures described. The system may also be implemented as a computer-readable storage medium, configured with a computer program, where the storage medium so configured causes a computer to operate in a specific and predefined manner.","The program is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. These steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared and otherwise manipulated. It proves convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like. It should be noted, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities.","Thus, a novel system and method for program verification using API definition files has been described. While embodiments and applications of this invention have been shown and described, it would be apparent to those skilled in the art having the benefit of this disclosure that many more modifications than mentioned above are possible without departing from the inventive concepts herein. The invention, therefore, is not to be restricted except in the spirit of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0068","num":"0072"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0069","num":"0073"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0070","num":"0074"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0071","num":"0075"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0072","num":"0076"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0073","num":"0077"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0074","num":"0078"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0075","num":"0079"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0076","num":"0080"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0077","num":"0081"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0078","num":"0082"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0079","num":"0083"},"figref":"FIG. 10C"},{"@attributes":{"id":"p-0080","num":"0084"},"figref":"FIG. 10D"},{"@attributes":{"id":"p-0081","num":"0085"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0082","num":"0086"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0083","num":"0087"},"figref":"FIG. 11C"},{"@attributes":{"id":"p-0084","num":"0088"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0085","num":"0089"},"figref":"FIG. 13A"},{"@attributes":{"id":"p-0086","num":"0090"},"figref":"FIG. 13B"},{"@attributes":{"id":"p-0087","num":"0091"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0088","num":"0092"},"figref":"FIG. 15A"},{"@attributes":{"id":"p-0089","num":"0093"},"figref":"FIG. 15B"},{"@attributes":{"id":"p-0090","num":"0094"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0091","num":"0095"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0092","num":"0096"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0093","num":"0097"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0094","num":"0098"},"figref":"FIG. 20A"},{"@attributes":{"id":"p-0095","num":"0099"},"figref":"FIG. 20B"},{"@attributes":{"id":"p-0096","num":"0100"},"figref":"FIG. 20C"},{"@attributes":{"id":"p-0097","num":"0101"},"figref":"FIG. 20D"},{"@attributes":{"id":"p-0098","num":"0102"},"figref":"FIG. 21A"},{"@attributes":{"id":"p-0099","num":"0103"},"figref":"FIG. 21B"},{"@attributes":{"id":"p-0100","num":"0104"},"figref":"FIG. 21C"},{"@attributes":{"id":"p-0101","num":"0105"},"figref":"FIG. 21D"}]},"DETDESC":[{},{}]}
