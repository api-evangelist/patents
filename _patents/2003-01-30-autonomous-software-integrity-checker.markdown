---
title: Autonomous software integrity checker
abstract: A semiconductor integrated circuit includes a processor for executing application code from a memory and a verifier processor arranged to receive the application code via the same internal bus as the processor. The verifier processor performs a verification function to check that the application code is authentic. The verifier processor runs autonomously and cannot be spoofed as it receives the application code via the same internal bus as the main processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07707638&OS=07707638&RS=07707638
owner: STMicroelectronics (Research & Development) Limited
number: 07707638
owner_city: Marlow-Buckinghamshire
owner_country: GB
publication_date: 20030130
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates to a memory security device, and in particular to the security of flash memory used in conditional access devices.","In conditional access devices for pay television, or any other device using memory and requiring security, there is a need to provide flash memory but to avoid hacking. Hacking is the unauthorized placing of software in memory to override security features. A known way of attempting to prevent hacking is to use some form of checking instructed by ROM memory to ensure that an application code stored in flash memory is correct. Such a device is shown in .","A flash memory  has a boot sector  and an application sector . A CPU  is arranged to run application code from the flash memory  retrieved over an interface  via bus  EMI  and bus . The security is provided by the CPU  booting from a boot ROM  which contains code to check the boot sector  of the flash memory. This is done once by the CPU producing a function of the code in the boot sector and comparing with a stored signature on startup. The CPU then jumps to the code in the boot sector  if it passes the check. However, it is now known that there is a relatively simple way of hacking such a security arrangement. When the CPU  boots up using code from the ROM , the CPU checks that the code in the boot sector  is correct. The weakness is that the process of power on, CPU boot and checking the flash takes a predictable number of clock cycles of the CPU clock. Thus, to hack the system, a hacker places code in an unchecked part of the flash memory  and forces the CPU to read from that part of the memory after a predetermined number of clock cycles by fixing an external address line.","The CPU  thereafter runs from unchecked code and no further checks are conducted, because the verification of code is only conducted on boot up from the ROM .","It is an object of the present invention to overcome the problem of storing application code within devices that can be insecure and prone to hacking by storing unauthorized code.","An embodiment of the invention comprises an additional processor termed a verifier processor and code arranged to read data from a memory to be checked, to produce a function of that data, and to verify that function of the data against a stored code. The verifier processor is on the same device and has the same external interfaces as a CPU which runs application code from the memory. The advantage of using an additional processor on the same device as a CPU is that the system cannot be hacked by changing code stored in memory as the additional processor would then also receive changed application code which would not be verified.","The verifier processor is arranged to continually check the flash memory while the CPU executes from the flash memory. If the address lines of the device were redirected so that the CPU runs from unauthorized code, then the verifier processor would also be redirected to that unauthorized code which would not pass the check.","The additional processor preferably produces a hash of the application code stored in memory and uses signature techniques to verify the application code. The embodiment thus comprises an additional processor function which runs independently of a CPU but is within the same integrated circuit as that CPU and shares the same bus. The processor function analyzes the application code applied to the CPU and, if not authentic, issues a reset signal to reset the integrated circuit.","The Autonomous Flash Checker (AFC) comprises a processor whose purpose is to check or verify that application code stored in a flash memory  for execution by a CPU  is authentic and has not been changed or \u201chacked\u201d. Flash memory is used in many devices, but the preferred embodiment is a conditional access system for television broadcast.","In such systems it is important that application software stored in flash memory is authentic and has not been changed in any way by a hacker. Such changes could be to run code whereby the system decrypts received broadcast signals without requiring payment by the user. The AFC processor  thus analyzes the application code stored in flash memory to ensure the code is authentic.","An integrated circuit embodying the invention is shown in , labelled device B. A processor (CPU)  is connected via an internal bus  and an external interface  via external connections on an interface  and bus  to a flash memory . The flash memory  contains application code in a boot sector  for execution by the CPU , signature portion  and an application sector . The signature portion  contains a signature that is a function of the application code in the boot sector  itself and is used for verification.","On power up of integrated circuit B, the CPU  is directed to the boot vector  of the flash memory  on a first integrated circuit, labelled circuit A. The application code is then retrieved over bus  and external memory interface  via internal bus  by the CPU  which executes the code. The application code is stored in a signed code portion  of the flash memory. It is noted that the AFC  is connected to the same internal bus  and external connections as the CPU, and so retrieves exactly the same code as the CPU without possibility of external interference. This is because the CPU, AFC processor and interconnect bus are all part of the same integrated circuit, labelled device B.","The CPU  and flash memory  operate in a known fashion, unless the AFC processor determines that the application code in flash memory  is not authentic. In this case, the AFC impairs operation of the device B by using a reset causing the device to reset and the boot sequence is restarted. Thus, if the application code has been tampered with, the set top box will repeatedly reboot and will not function to decrypt received TV signals. Other forms of impairing the operation of device B could be used such as disabling or stopping the device clock or otherwise limiting the functionality of the device.","The operation of the AFC processor itself is achieved by producing a hash function and a signature of the application code using a public key from a public key storage  selected by antifuse  () as will now be described with reference to . The AFC  comprises a verifier processor such as a Risc processor  which executes code stored in code ROM  and uses RAM  for temporary storage. The code in code ROM  is only accessible by the verifier processor and instructs the Risc processor  to undertake the following steps:\n\n","The verifier processor is not externally accessible other than in specific ways described later, and so cannot be hacked and only runs from the code in ROM which cannot be changed. If the signature is correct then the application code in flash memory is deemed authentic.","The steps set out above are undertaken continually; each set of steps comprising a cycle of the verifier processor. During each cycle the CPU  continues to operate as normal in retrieving and executing the application code over the same internal bus  as used by the verifier processor  over line . Accordingly, to avoid reducing the performance of the CPU , the verifier processor requests application code from the memory less frequently than the CPU, for example the verifier requests code once every 1,000 to 10,000 CPU requests. Also, the verifier requests are at pseudo random locations and at pseudo random times. This helps obscure the verifier requests among the CPU requests. The requests made at external connections at interface  for data from the flash thus comprise CPU requests and pseudo random requests at pseudo random times comparatively infrequently mixed together. It is thus all but impossible for a hacker to determine how to spoof the external address lines to direct the CPU to hacked code but the verifier to genuine code. The use of pseudo random locations and times makes spoofing harder. The requests to the flash memory themselves are indistinguishable, whether made by the CPU or verifier processor.","The first step of producing a hash of the application code uses a flash read circuit which is instructed by RISC processor  to retrieve the code over bus . The application code can be read sequentially, in circular or pseudo random fashion as specified by the code in ROM, and is provided to the RISC processor  over line . The hash function can be any one-way hash function which has the advantage that any small change in the application code will result in a large change in the hashed code, but is mathematically all but impossible to derive multiple changes that could be made to the application code such that the hashed code is unchanged. Preferably, the RISC processor  continually receives the application code from the flash in a pseudo-random read pattern, and uses a know hash function such as MD5.","On completion of the hash function, the second step is to produce a signature function of the hashed code. To do this, the RISC processor produces a function F (hashed code, public key) where the public key is selected from the public key storage  by antifuse  and provided at . The signature of the application code is retrieved from signature location  () in the flash (having been created and prestored using the corresponding private key). A second function G (public key, signature) is then produced. The antifuses are arranged to select only one of a plurality of keys in the key storage . This allows a generic device B to be created but to be tailored by selecting just one of possible keys. The antifuses are known and are irreversible fuses.","The third step is then to verify the hashed code against the signature by the standard digital signature technique of comparing F (hashed code, public key) and G (public key, signature). The preferred algorithm is DSA. Provided that the signature is verified, then no action is taken. If the application code does not verify the signature, however, an impair function results at  a chip reset is issued over line , preventing the chip from operating further.","We have also appreciated that there may be a need to download new (authentic) code to the flash memory and that this should be provided for so that the AFC does not erroneously reject this new code. To allow this, the verifier processor must be stopped for M minutes, but again this could leave the possibility of a hack in which the AFC is permanently stopped. To prevent this, the code in ROM  causes the verifier processor to automatically issue a chip reset after M minutes, and starts the verification at the beginning of the new code in flash memory.","The only commands available to the CPU  to control the verifier processor  are: STOP, RESTART, PAUSE. Thereafter, the operation of the AFC processor is autonomous and largely in hardware, with the only software being in ROM  or RAM  which are only accessible by the RISC processor . We have appreciated, however, that these commands need to be available to the CPU to avoid contention and allow flash memory updates, but could open the possibility of hacks which permanently pause or stop the AFC or continually reset. For that reason, further preferred features are included.","A first preferred feature is to allow the CPU  to pause the verifier processor to avoid contention. However, we have appreciated that this could allow a hack in which the AFC is permanently paused. So the code in ROM  is configured only to allow N pauses in one cycle of checking the flash memory. Each pause can be around 1 second. If the count N is exceeded, a chip reset signal is sent. A further possible hack would be to block requests made by the verifier processor for code from the flash such that the verification process never completes. To prevent this, a watchdog function is incorporated in the code in ROM  such that a reset is issued if a cycle does not complete in a given time. The given time is predictable as it is known how long should be taken for a cycle and so this is programmed in ROM.","It could also be possible to hack the flash memory code such that the CPU continually instructs the verifier processor to stop and restart. To avoid this, the code in ROM does not allow the verifier processor to stop after a restart request so that a whole cycle of verification is conducted.","It is noted that the verifier processor has access to the RAM . This RAM is also on the same device as the CPU, ROM  and verifier processor so as to avoid the possibility of hacking this RAM, which is used to store temporary values during execution of the verification code in the ROM . The verifier processor only has two external connections to retrieve data and to issue resets. The reset is issued to the device B itself, so it cannot be hacked. The retrieval of code uses the same bus as the CPU, and so if hacked, it would not be verified as previously described."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["An embodiment of the invention will now be described by way of example only and with reference to the figures in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 3","FIG. 2"]}]},"DETDESC":[{},{}]}
