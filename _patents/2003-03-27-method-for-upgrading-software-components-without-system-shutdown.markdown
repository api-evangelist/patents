---
title: Method for upgrading software components without system shutdown
abstract: In an operating software system that provides one or more software components for use by a plurality of software programs, a method of providing an upgraded version of a software component for use by one or more of the software programs while at the same time allowing other programs of the plurality of programs to continue to operate with the older version. The method is particularly suitable for upgrading omponent bject odels (COM's) as used in the WindowsÂ® operating system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07146610&OS=07146610&RS=07146610
owner: Taiwan Semiconductor Manufacturing Company, Ltd.
number: 07146610
owner_city: Hsin-Chu
owner_country: TW
publication_date: 20030327
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["The present invention relates generally to a method of upgrading software components or modules used by a multiplicity of software programs without having to shut down all of the software programs that require the software component. More specifically, this invention relates to a software arrangement using a Component Object Model (COM) used by a multiplicity of different Client Applications (software) and subsequently providing an upgraded version of the COM for use by at least one of the multiplicity of Client Applications without having to shut down the remaining Client Applications of said multiplicity that do not require the updated version.","The Microsoft\u00ae Corporation has developed a platform-independent, distributed, object-oriented system for creating binary software components that can interact. This system is commonly referred to as Component Object Model or COM, and is the foundation technology for Microsoft's OLE (compound documents), ActiveX\u00ae (Internet-enabled components), as well as others.","To understand the COM concept, it is note that COM is not an object-oriented language but a standard. Further, COM does not specify how an application should be structured. Language, structure, and implementation details are left to the application programmer. COM on the other hand does specify an object model and programming requirements that enable COM objects (also called COM components, or simply objects) to interact with other objects. The \u201cobjects\u201d can be within a single process, in a variety of processes, and can even be on remote machines. They can even be written in different languages, and may be structurally quite dissimilar. Thus, COM is referred to as a binary standard and applies after a program has been translated to binary machine code.","The only language requirement for COM is that the code defining the COM be generated in a language that can create structures of pointers and either explicitly or implicitly, call functions through pointers. For example, object-oriented languages such as Microsoft\u00ae Visual C++\u00ae and Smalltalk provide programming mechanisms that simplify the implementation of COM objects, but languages such as C, Pascal, Ada, Java, and even BASIC programming environments can also create and use COM objects.","In general, a software object is made up of a set of data and the functions that manipulate the data. A COM object on the other hand is one in which access to an object's data is achieved exclusively through one or more sets of related functions. These function sets are called interfaces, and the only way to gain access to an interface is through a pointer to the interface. Besides specifying the basic binary object standard, COM defines certain basic interfaces that provide functions common to all COM-based technologies, and it provides a small number of API functions.","The concept of using COM objects and interfaces allows objects to interact across process and machine boundaries as easily as within a single process. The use of such common modules enables the manipulation of data associated with an object through an interface on the object. COM uses the word interface in a sense different from that typically used in Visual C++ programming. A C++ interface refers to all of the functions that a class supports and that clients of an object can call to interact with it. A COM interface refers to a predefined group of related functions that a COM class implements, but a specific interface does not necessarily represent all the functions that the class supports. Referring to an object implementing an interface means that the object uses code that implements each method of the interface and provides COM binary-compliant pointers to those functions to the COM library. COM then makes those functions available to any client who asks for a pointer to the interface, whether the client is inside or outside of the process that implements those functions.","The COM concept makes a fundamental distinction between interface definitions and their implementations. An interface is actually a contract that consists of a group of related function prototypes whose usage is defined but whose implementation is not. These function prototypes are equivalent to pure virtual base classes in C++ programming. An interface definition specifies the interface's member functions and what they must do. There is no actual implementation associated with an interface. An interface implementation on the other hand is the code supplied to carry out the actions specified in an interface definition.","Simple objects support only a single interface. More complicated objects, such as embeddable objects, typically support several interfaces. Client applications have access to a COM object only through a pointer to one of its interfaces, which, in turn, allows the client application to call any of the methods that make up that interface. These methods determine how a client can use the object's data.","An important aspect of the COM concept is how client applications and servers interact. A COM client application is whatever code or object gets a pointer to a COM server and uses its services by calling the methods of its interfaces. A COM server is any object that provides services to clients; these services are in the form of COM interface implementations that can be called by any client that is able to get a pointer to one of the interfaces on the server object. There are two main types of servers, and can be classified as in-process and out-of-process servers. In-process servers are implemented in a dynamic linked library (.DLL), and out-of-process servers are implemented in an executable file (.EXE). .DLL and .EXE files will be recognized by anyone familiar with Microsoft\u00ae Windows\u00ae software. Out-of-process servers can reside either on the local machine or on a remote machine. In addition, the COM concept provides a mechanism that allows an in-process server (a .DLL) to run in a surrogate .EXE process to gain the advantage of being able to run the process on a remote machine.","A well-known example of the COM concept with respect to an .EXE program is \u201cspell checker\u201d in MS Office. Spell Checker is a single software component that can be called on by the word processing program or any other of the programs in MS Office.","A dynamic-link library (.DLL) on the other hand, is a module that contains functions and data that can be used by another module (application or .DLL).","For example, a .DLL can define two kinds of functions: exported and internal. The exported functions may be called by other modules, as well as from within the .DLL where they are defined. Internal functions are typically called only from within the .DLL where they are defined. Although a .DLL can export data, its data is generally used only by its functions. However, there is nothing to prevent another module from reading or writing that address.",".DLLs provide a way to modularize applications so that functionality can be updated and reused more easily. They also help reduce memory overhead when several applications use the same functionality at the same time, because although each application gets its own copy of the data, they can share the code.","The Windows\u00ae application programming interface (API) is implemented as a set of dynamic-link libraries, so any process that uses the Windows\u00ae API uses dynamic linking.","Dynamic linking allows a module to include only the information needed to locate an exported.DLL function at load time or run time. Dynamic linking differs from the more familiar static linking, in which the linker copes a library function's code into each module that calls it.","A .DLL can be called during loading or running a program. In load-time dynamic linking, a module makes explicit calls to exported .DLL functions as if they were local functions. This requires linking the module with the import library for the .DLL that contains the functions. An import library supplies the system with the information needed to load the .DLL and locate the exported .DLL functions when the application is loaded. The threads of the process that called the .DLL can use handles operated by a .DLL function. Similarly, handles opened by any thread of the calling process can be used in the .DLL function. The .DLL uses the stack of the calling thread and the virtual address space of the calling process. The .DLL allocates memory from the virtual address space of the calling process.","Programming models and constructs using COM allow COM clients and servers to work together across the network, not just within a given machine. This enables existing applications to interact with new applications and with each other across networks with proper administration, and new applications can be written to take advantage of networking features. It is not necessary for COM client applications to be aware of how server objects are packaged. For example, they may be packaged as in-process objects (in .DLLs) or as local or remote objects (in .EXEs). The COM concept is designed for location transparency that extends across a network. This allows applications written for single machines to run across a network and provides features that extend these capabilities and adds the security necessary in a network. More specifically, there are nearly 200 Microsoft\u00ae Windows\u00ae defined COM interfaces and tens of thousands COM components overall. In most cases, these generic interfaces can be re-used. However, some applications have specific requirements that make it desirable or necessary to define specific object interfaces.","The Microsoft\u00ae Windows\u00ae registry is the system database for Windows\u00ae operating systems. It contains information about the configuration of system hardware and software as well as about users of the system. Any Windows\u00ae-based program can add information to the registry and read information back from the registry. While writing a new program, programmers often search the registry for interesting components to use.","Thus, the registry maintains information about all the COM objects installed in the system. Whenever an application creates a COM component, the registry is consulted to resolve either the CLSID (Class's ID) or ProgID of the component into the pathname of the server .DLL or .EXE that contains it. A CLSID is a generated 128 bit unique identifier or UUID as defined by the DCE organization. A UUID is a randomly-generated unique ID, and an interface ID or IID as well as a CLSID. The ProgID is a string identifier that the client program can use to resolve possible CLSID's. The COM system may use any of these three ID's (CLSID, IID and ProgID). After determining the component's server, Windows\u00ae either loads the server into the process space of the client application (in-process components) or starts the server in its own process space (local and remote servers). The server creates an instance of the component and returns to the client a reference to one of the component's interfaces.","Additional information concerning Mircosoft\u00ae COM system may be found on the internet at http:\/\/msdn.microsoft.com\/library\/default.asp?url=\/library\/en-us\/com\/comportal3qn9. asp, and http:\/\/msdn.microsoft.com\/library\/default.asp?url=\/library\/en-us\/dllproc\/base\/dynamic_link_libraries.asp.","A method for upgrading a software component such as a COM (Component Object Model) as used by Microsoft\u00ae Windows\u00ae operating system and having a first file name. The software component is used by a multiplicity of software programs or client applications without shutting down the computer software operating system. The operating system will include a database such as the system registry file as used by Windows\u00ae.","The method comprises assigning a second file name to the new software component or module (COM) that is to be used as the upgraded version. This upgraded module or component with the second file name is then stored in a directory in the computer storage. The upgraded component with the second file name is also registered in the system's database. After storing the new component and registering the second file name, the software program or client application that is to use the upgraded software component is shut down and reconfigured so as to require the upgraded software component or COM under the second file name. The client application or software program is then run according to normal procedure and is linked to the software component (COM) having the second file name.","The foregoing has outlined rather broadly the features and technical advantages of the present invention in order that the detailed description of the invention that follows may be better understood. Additional features and advantages of the invention will be described hereinafter which form the subject of the claims of the invention. It should be appreciated by those skilled in the art that the conception and specific embodiment disclosed may be readily utilized as a basis for modifying or designing other structures or processes for carrying out the same purposes of the present invention. It should also be realized by those skilled in the art that such equivalent constructions do not depart from the spirit and scope of the invention as set forth in the appended claims.","The making and using of the presently preferred embodiments are discussed in detail below. It should be appreciated, however, that the present invention provides many applicable inventive concepts that can be embodied in a wide variety of specific contexts. The specific embodiments discussed are merely illustrative of specific ways to make and use the invention, and do not limit the scope of the invention.","The present invention will be described with respect to preferred embodiments in a specific context, namely a component used in a Windows\u00ae operating system or provided by the Microsoft\u00ae Corporation. The invention may also be applied, however, to other software arrangements.","Referring now to , B and C, there is illustrated the prior art processes of upgrading a software component, such as for example a COM module used by a plurality of programs or \u201cclient applications.\u201d As shown in , four software programs or client applications , ,  and  are functionally linked to a single COM module or software component  having a selected file name such as, for example only, RMS Parser  as indicated by solid line links A, B, C and D through interface node . The COM module is stored in computer memory . If an upgrade version of the COM module (RMS parser ) A is necessary for software program (or client application)  to improve performance, or if client application  itself is to be upgraded so as to require an upgraded version of the COM module (RMS Parser ), such a change was accomplished in the past by shutting down all of the software client applications , ,  and  that required the COM module named RMS Parser .","The old version of RMS Parser  () was then deleted from memory  and the new version of Parser  (A) was then stored in computer memory  under the same name and address as indicated in . The four programs that were shut down for this replacement were then restarted. This process was the same whether or not the new version of software component (COM) A (still named RMS parser ) provided any benefit to programs ,  and , which do not require the upgraded versions (i.e., operated quite satisfactory with the old version). In addition to the obvious disadvantage of the unnecessary cost of shutting down all of the client applications that worked well with the old version COM RMS Parser  () to avoid problems, the operating system would lock the file when the client applications were running whether or not they were actually being used at that time by the specific COM to be upgraded. Thus, such upgrades typically were required to take place during scheduled down-time.","A shut down of all programs or client applications , ,  and  was also necessary even when the new software component or COM required by program  was so different it required a new name (for example RMS parser ) and could not be used by the other programs ,  and , which remained linked to COM RMS Parser  ().  illustrates the resulting arrangement of programs ,  and  still linked to old version COM RMS Parser   stored in memory  while program  is linked to the new COM RMS Parser  (A) also stored in the computer memory .","Referring now to , B and C there are illustrated the process of the present invention. (Those elements that are the same as used in , B and C retain the same reference numbers.) As shown in , the upgraded software component or COM version A may be stored in computer memory  under an appropriate directory with a different name (i.e., RMS Parser  rather than RMS parser ) and registered in the software database as a registry file. It is also noted that the upgraded COM has its own interface node(s) A. In the example of , the system may then be shut down and client applications  and  reconfigured so as to now require RMS Parser  rather than RMS parser . The system is then started back up with client applications  and  using RMS Parser  while client applications  and  continue to operate using RMS parser . When the system is restored, the software component or COM  and A will now be unlocked as shown even though still in use.","This inventive process may be more clearly illustrated by now referring to , wherein client applications or software programs  and  are linked to software component or COM named \u201cRMS parser \u201d having reference number  and stored in computer memory  whereas client applications  and  are linked to software component or COM A named \u201cRMS parser \u201d also stored in computer memory  as shown in . Further, the components are no longer \u201clocked\u201d since an upgrade does not require removing the COM module from the system when it is to be replaced with a new module.","Therefore, if as an example, it also becomes desirable to upgrade client application  to RMS Parser  while client application  continues to operate with RMS Parser  (), it is only necessary to shut down client-application  and reconfigure it to require RMS Parser  (A) rather than RMS Parser  () and then restart the program so that it now links to RMS Parser  (A). Thus, client application  may continue to operate through the complete upgrade process for client application . If in the future client application  is also to be upgraded, a process similar to that used for upgrading client application  is simply repeated. Now if all of the client applications have been switched over or upgraded; that is, there are no other client applications that require the COM version named RMS Parser  (), the RMS Parser  () file may be deleted.","As mentioned, the above-described invention is especially applicable for use with a Windows\u00ae operating system, wherein the software components as referred to as Component Object Models, COM's and the software programs are referred to as client applications. Further, the Windows\u00ae operating system identifies file types by their \u201cextensions\u201d and two of the file types are identified with .DLL and .EXE extensions.","More specifically, in the COM architecture developed by Microsoft\u00ae Windows\u00ae a 16 byte number is used to represent the unique-identifier of a component and its interface node. This 16 byte number is the GUID (Globally Unique Identifier) and text string represents the \u201cProgram ID of the GUID. Windows\u00ae may use the Program ID to determine the GUID, which in turn identifies the specific COM component that the client application or software program requires (i.e., will call and link to). The Program ID has the following format:\n\n\u201c<Component Name>.<Interface Name>.<Version Number>\u201d\n\nAs an example only, \u201cRMSParser.Parser.1\u201d where \u201cRMSParser\u201d is the component name, \u201cParser\u201d is the interface name and \u201c1\u201d is the version number.\n","If the deployment is to be \u201cseamless,\u201d the developer of the upgrade COM component should adhere to the following guidelines: First, with respect to the COM component itself, the developer assigns a totally different GUID (Globally Unique Identifier) to the upgraded version of the COM component and all interface nodes, and includes the \u201cversion number\u201d of the upgrade. The COM component file is also renamed such that its name is different than the previous version(s). That is, in the example above, the file name was \u201cRMSParser.Parser.1\u201d for version 1. Therefore, the file name of the new version 2 will be \u201cRMSParser.Parser.2.\u201d","The component definition used by the calling or requesting software program includes a GUID portion and a Program ID portion, and for the original component definition of version 1",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HKCR"},{"entry":"{"},{"entry":"\u2003RMSParser.Parser.1 = s \u2018Parser Class\u2019"},{"entry":"\u2003{"},{"entry":"\u2003\u2003CLSID = s \u2018{ABC}\u2019"},{"entry":"\u2003\u2003\u2003Note: to aid in understanding, the term \u201cABC\u201d represents"},{"entry":"\u2003\u2003\u2003the GUID of the original COM and replaces the much more"},{"entry":"\u2003\u2003\u2003complex actual GUID portion of an actual COM which as"},{"entry":"\u2003\u2003\u2003made up of a series of approximately 36 alphanumeric"},{"entry":"\u2003\u2003\u2003characters (e.g., ABC=Ed52C3D5-69F7-11D5-9110-"},{"entry":"\u2003\u2003\u20030002B332CB84)"},{"entry":"\u2003}"},{"entry":"\u2003RMSParser.Parser = s \u2018Parser Class\u2019"},{"entry":"\u2003{"},{"entry":"\u2003\u2003CLSID = s \u2018{ABC}\u2019"},{"entry":"\u2003\u2003CurVer = s \u2018RMSParser.Parser.1\u2019"},{"entry":"\u2003}"},{"entry":"\u2003NoRemove CLSID"},{"entry":"\u2003{"},{"entry":"\u2003\u2003ForceRemove {ABC} = s \u2018Parser Class\u2019"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ProgID = s \u2018RMSParser.Parser.1\u2019"},{"entry":"\u2003\u2003\u2003\u2003Note: \u201cRMSParser.Parser.1\u201d is the Program ID of"},{"entry":"\u2003\u2003\u2003\u2003the original version of the COM."},{"entry":"\u2003\u2003\u2003VersionIndependentProgID = s \u2018RMSParser.Parser\u2019"},{"entry":"\u2003\u2003\u2003ForceRemove \u2018Programmable\u2019"},{"entry":"\u2003\u2003\u2003InprocServer32 = s \u2018%MODULE%\u2019"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2018TypeLib\u2019 = s \u2018{ABC}\u2019"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In a similar manner, the component definition of the upgraded COM version is as follows:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HKCR"]},{"entry":[{},"{"]},{"entry":[{},"\u2003RMSParser.Parser.2 = s \u2018Parser Class\u2019"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003CLSID = s \u2018{XYZ}\u2019"]},{"entry":[{},"\u2003\u2003\u2003Note: \u201cXYZ\u201d replaces the 36 alphanumeric GUID of the"]},{"entry":[{},"\u2003\u2003\u2003updated COM version (e.g., XYZ=a2b205af-7881-4c7d-"]},{"entry":[{},"\u2003\u2003\u2003ad8d-bf2acefb906b)"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003RMSParser.Parser = s \u2018Parser Class\u2019"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003CLSID \u2212 s \u2018{XYZ}\u2019"]},{"entry":[{},"\u2003\u2003CurVer = s \u2018RMSParser.Parser.2\u2019"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003NoRemove CLSID"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003ForceRemove {XYZ} = s \u2018Parser Class\u2019"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003ProgID = s \u2018RMSParser.Parser.2\u2019"]},{"entry":[{},"\u2003\u2003\u2003\u2003Note: This is the Program ID of the updated"]},{"entry":[{},"\u2003\u2003\u2003\u2003version of the COM."]},{"entry":[{},"\u2003\u2003\u2003VersionIndependentProgID \u2212 s \u2018RMSParser.Parser\u2019"]},{"entry":[{},"\u2003\u2003\u2003ForceRemove \u2018Programmable\u201d"]},{"entry":[{},"\u2003\u2003\u2003InprocServer32  \u2212 s \u2018%MODULE%\u2019"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2018TypeLib\u2019 \u2212 s \u2018{XYZ}\u2019"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The client application or software program is configured to identify which COM version it calls or with which it links. However, if the client application is to use the newest or upgraded version, it is not necessary to identify the version. For example, in the client application or software program: Set Parser=CreateObject(\u201cRMSParser.parser.\u201d+command) where \u201cCommand\u201d is a parameter of the client application to indicate which version of COM component is to be used. For example, if command=\u201c2\u201d, the client application links to the newer or upgraded version of the COM component.","Referring now to , there is illustrated a simplified flow diagram of the method steps of the present invention. As shown, a new version or upgraded version of a software component or COM having a new name is provided and then stored in the computer system database (for example registered in the registry file) as indicated by steps , ,  and . A software program or client application requiring an upgraded COM is then shut down and reconfigured to operate with the upgraded COM as indicated at steps  and . The reconfigured program is then stated up or run as indicated at step  and linked with the upgraded COM as indicated at step .","Although the present invention and its advantages have been described in detail, it should be understood that various changes, substitutions and alterations can be made herein without departing from the spirit and scope of the invention as defined by the appended claims.","Moreover, the scope of the present application is not intended to be limited to the particular embodiments of the process, methods and steps described in the specification. As one of ordinary skill in the art will readily appreciate from the disclosure of the present invention, processes, methods, or steps, presently existing or later to be developed, that perform substantially the same function or achieve substantially the same result as the corresponding embodiments described herein may be utilized according to the present invention. Accordingly, the appended claims are intended to include within their scope such processes, methods, or steps."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawing, in which:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 1A","b":["1","1"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 2A","b":["2","2"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 3","FIGS. 2A"],"b":["2","2"]}]},"DETDESC":[{},{}]}
