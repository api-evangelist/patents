---
title: System for integrating diverse database and maintaining their consistency
abstract: An arrangement maintains consistency among satellite databases and an integrated database that is the union of the satellite databases with a controller that fetches update requests from a queue and applies each fetched request to all of the databases, in sequence, ending with the integrated database. In applying a modification request to a target database, a filter is used that comprises two components. The first component processes the modification request submitted by the queue to a modification request that is appropriate for the schema of the target database and that is based on the data that is already present in the target database. When appropriate, the first component also creates an update request that is sent to the queue, to achieve transitive closure. The second component communicates with the target database, using the API and protocols of the target database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07660830&OS=07660830&RS=07660830
owner: Avaya Inc.
number: 07660830
owner_city: Basking Ridge
owner_country: US
publication_date: 20010410
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION","Example 1","Example 2","Example 3","Example 4"],"p":["This invention claims priority from provisional application No. 60\/197,878, which was filed on Apr. 17, 2000.","This invention relates to databases, and more particularly to a plurality of databases that are logically combined to form a meta-database, such as a meta-directory.","A great deal of corporate data is buried in network devices, such as PBXs, messaging platforms, email platforms, etc. Typically, each of these devices possesses only the information that is needed for its specialized need, maintains it in a database, and possesses means for administering this information. The means for administering typically must deal either with a proprietary interface, or a standard protocol against a proprietary schema; but typically that presents no problems, as long as one does not want to employ the data in an inter-platform manner. Efforts to use, modify, and update such data in an inter-platform manner, however, leads to many problems, including the need for data replication and difficult interoperation problems with diverse devices and applications.","Nevertheless, the emerging need to provide organization-wide access to data is creating a demand to interconnect previously isolated systems. As a result, integrating information from multiple heterogeneous data sources has become a central issue in modern information systems. A data integration system provides uniform and transparent access to multiple data sources, making information more readily accessible and allowing users to pose queries without having to interact with a specific source, using the proper interface.","Even though an integrated system produces many advantages, as indicated above, difficult problems arise when integrating information from multiple sources; most notably autonomy and heterogeneity. Autonomy relates to the fact that some systems operate under separate and independent control, using their own data model and Application Programming Interface (API). Heterogeneity can arise at different levels. For instance, different systems may use different APIs, different vocabularies, (e.g., use the same term for different concepts or different terms for the same concept) different schemas, etc.","Building custom applications that assemble data from appropriate locations is not always a practical solution. It can be prohibitively expensive, inflexible, and hard to maintain.","Several research projects have developed mediator systems to address these problems. See, for example, G. Wiederhold, \u201cMediators in the Architecture of Future Information Systems,\u201d , pp. 38-49, March 1992. A mediator system provides an intermediate layer between the user and the data sources. Each data source is wrapped by software that translates local terms, values and concepts into global concepts shared by some or all sources, thereby smoothing the semantic heterogeneity among the various integrated sources. The mediator then obtains information from one or more wrapped components, and exports the information to other components. Queries to the mediator are in a uniform language, independent of the distribution of data over sources and the APIs of the source. Another thing that can be said about mediators is that they concentrate on read-only queries. With mediators, queries that are posed against the unified system are dynamically executed at the various data sources, rather than materializing subsets of the data from the various sources in an integrated directory.","In an effort to employ the data that is available on different platforms, a widely deployed directory access protocol has been developed, known as Lightweight Directory Access Protocol, or LDAP. See, for example, S. Cluet et al, \u201cUsing LDAP Directory Caches.\u201d 1999, and R. Arlein et al \u201cMaking LDAP Active With the LTAP Gateway: Case Study in Providing Telecom Integration and Enhanced Services,\u201d , September 1999. To supply all the functionality that users expect, middleware to integrate the LDAP directories with network and telecommunication devices is needed. This integration makes data that has traditionally been buried in network\/telecommunication devices like routers, PBXs, and messaging platforms available to new applications that can add value to the data. In addition, since much of this data is replicated in multiple devices, corporate directories, and provisioning systems, integration reduces the need to manually re-enter such data, and consequently, it reduces data inconsistencies across repositories.","From a database perspective, LDAP can be thought of as a very simple query and update protocol. Directory entries are stored hierarchically in a tree fashion, which makes the arrangement easily scalable. Each entry in the tree is identified by a Distinguished Name (DN), which is a path from the root of the tree to the entry itself. The DN is produced by concatenating the Relative Distinguished Name (RDN) of each entry in the path. The RDN for an entry is set at creation time and consists of an attribute name\/value pair\u2014or in more complicated cases, a collection of these pairs. The RDN of an entry must be unique among the children (i.e., lower branches) of a particular parent entry in the tree.","One limitation with LDAP is that its update services can only create or delete a single leaf node, or modify a single node; that is, LDAP has the Modify command, and the ModifyRDN command. The Modify command modifies any field of an entry except the RDN field, and ModifyRDN modifies the RDN field. Another limitation is that while individual update commands are atomic, one cannot group several update commands into a transaction. For example, one cannot atomically change a person's name and telephone number if the name is part of the person's RDN but the telephone number is not.","An improvement in the art is realized with an arrangement that maintains consistency among satellite databases and a materialized database that maintains data that corresponds to the union of data stored in the satellite databases, and is accessible to all users. Consistency is maintained by all modifications (to any and all of the databases that are coupled to the system) being sent to a queue following a conversion to a global database schema; for example the schema of the materialized, integrated, database. Modification requests are fetched from the queue on a first come\u2014first serve basis are applied, seriatim, to each of the different (target) databases that are coupled to the system. In the embodiment illustrated, the integrated database is modified last.","In applying a modification request to a target database, a filter is used that comprises two components. The first component processes the modification request submitted by the queue to a modification request that is appropriate for the schema of the target database and that is based on the data that is already present in the target database. When appropriate, the first component also creates an update request that is sent to the queue, to achieve transitive closure. The processing in the first component is assisted by a specification module that comprises simple declarative statements that define the schema translations, alternative attribute mappings, and pattern matching. The second component communicates with the target database, using the API and protocols of the target database.","In accordance with the principles disclosed herein, diverse database sources (satellite systems having satellite databases) are maintained consistent with each other by means of a system that integrates the information of the diverse database sources into a single database, applies appropriate updates to each of the diverse databases to maintain consistency, and allows remote users to access the integrated database.","The databases that are updated by the system disclosed herein provide write-write consistency; that is, the system insures that values for an object attribute that is present in multiple objects (perhaps after an appropriate transformation) eventually converge to the same value after an update. Discussions on write-write consistency are found in an article by A. Deniers et al, titled \u201cEpidemic algorithms for replicated database maintenance,\u201d , p. 1-12 (1987), and an article by L. Seligman et al \u201cA mediator for approximate consistency: Supporting \u2018good enough\u2019 materialized views,\u201d 8:203-225 (1997). The system disclosed herein includes techniques to extend this write-write consistency functionality to collections of integrated databases. When applications require the more strict read-write consistency, for example the consistency required when one updates a bank balance with a deposit or withdrawal, the collection of databases will need to use additional distributed transaction techniques. A discussion of read-write consistency can be found in and article by Y. Breitbart et al, \u201cTransaction management in multidatabase systems,\u201d in Won Kim, editor, , pp. 573-591, ACM Press and Addison-Wesley.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["10","11","12","20","21","22","100","121","122"]},"PBX ","PBX  is a conventional PBX with an administrative port  and an operating system (OS) . Database  can be independently updated through port , via OS  and database manager (DBM) . For purposes of this invention, the program in DBM  that finally commits updates to database  is augmented with a call to a conventional two-way communication module in OS . Such augmentation is very simple, and is clearly within the scope of skilled artisans. The communication module is adapted to interact with a preselected port of PBX ; i.e., the port through which PBX  connects to system . In the communication direction from system  to PBX , the communication module is triggered by an interrupt from system  and is thereby enabled to receive information from system  and to provide responsive information to system . This is a conventional communication module and is not explicitly shown in . It acknowledges the receipt of the information and treats the received information as input to its operating system. This includes accepting input from system  that is directed to DBM . The input may comprise a query of database , or an update of database  (which includes adding to, deleting from the database). In the communication direction from PBX  to system ; that is, when an update is introduced into database  from path , the communication module is adapted to trigger execution of a program module within system  and to interact with that program module, for example, passing information from DBM . That program module is represented in  by filter .","Platform ","Platform  is a conventional messaging platform that includes an operating system (OS) , and port  through which an administrator can update database . In the  embodiment, OS  includes a communication module that is identical to the one described in connection with PBX  and, also like in connection with PBX , database manager (DBM)  is augmented to request its communication module to trigger filter  in system  whenever an update to database  is being committed.","System ","In addition to database  and associated database manager , system  includes an update manager (UM) , a queue , and an operating system  that allows communication between UM , DBM , and queue , as well as communication with filters -. The function of UM  is to update database  as well as all of the external databases (e.g., database  and database ) in response to each request that is stored in queue . The update from system  to database  in PBX  is via filter , and the update from system  to database  in platform  is via filter . System  typically includes its own administration path; for example, administrator  that is connected to OS  through Internet . Update requests arriving from administrator  are placed in queue  just like update requests from database  of PBX  (via filter ) and from database  of platform  (via filter ). As an aside, system  is typically realized in a stored-program controlled computer that includes a processor and memory that includes the operating system, the update manager, the queue the database manager and the database itself.","Database Modifications","Database modification requests are handled by queue  on a First-In-First-Out (FIFO) basis, and can be structured in various ways. Illustratively, each request is a string (e.g., terminated by the \u201clie feed\u201d character <LF>) that specifies the source of the request and information about the data modification that is sought to be effected. The specification of the source is not a requirement of this invention, but typically one would want to have the source specified (if the source of the update request is other than administrator ) so that updating of the source can be skipped during the updating process.","To illustrate the principles disclosed herein, the discussion that follows employs a database  that comprises two database tables, and a database  that comprises one table. The illustrative database base arrangement are relational, but it should be noted that the principles disclosed herein are not dependent on the database being relational and that, for example, the databases can be hierarchical. In particular, LDAP provides a hierarchical database that can be modeled as relational by treating each LDAP object class as a separate relation that also includes the distinguished name of the object. Specifically, the illustrative database  tables are",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["db 11 table \u201cpeople\u201d",{},"db 11 table \u201ccommunication\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00001","he":"2.12mm","wi":"2.46mm","file":"US07660830-20100209-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Social Security #",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00002","he":"2.12mm","wi":"2.46mm","file":"US07660830-20100209-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Record ID"]},{"entry":[{},"cn","common name","SSN","Social Security #"]},{"entry":[{},"mn","Middle name","ph","Phone number"]},{"entry":[{},"sn","Surname","typ","type"]},{"entry":[{},"org","Organization #"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"21"},{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"db 21 table \u201csubscribers\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00003","he":"2.12mm","wi":"2.46mm","file":"US07660830-20100209-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Record ID"]},{"entry":[{},"SOC","Social Security #"]},{"entry":[{},"lgn","Login name"]},{"entry":[{},"sn","Subscriber name"]},{"entry":[{},"al","Alert options"]},{"entry":[{},"msg","# stored messages"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00004","he":"2.79mm","wi":"2.46mm","file":"US07660830-20100209-P00002.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},"b":["11","21","11"]},"Before proceeding with the discussion of database modifications, a few observations about the tables of databases  and  are in order. The \u201cpeople\u201d table records identify people in an organization. The \u201ccommunication\u201d table records identify phone numbers that can be used to reach people. Each record in the \u201ccommunication\u201d table is related to one record in the \u201cpeople\u201d table, and each record in the \u201cpeople\u201d table is related to zero, one, or more records in the \u201ccommunication\u201d tables. The fields that establish this relationship are the (SS) and (SSN) fields in the \u201cpeople\u201d and \u201ccommunication\u201d tables, respectively. To illustrate, Mary Jones with Social Security Number 123-45-6789 may have one record in the \u201cpeople\u201d table and two records in the \u201ccommunication\u201d table: one with ph=(908) 420-1234 and typ=voice, and another record with ph=(908) 420-5609 and typ=fax.","The records in table \u201csubscribers\u201d contain information about stored messages that are destined to a particular login name and that are associated with a particular person. A person is associated with each login name, and the persons identified in the subscriber table of database  may be the same persons that are specified in the \u201cpeople\u201d table of database , i.e., persons who have the same social security number, in a field named \u201cSOC.\u201d Also, a person can have a number of logins.","In addition to semantic difference between the tables, in that the same data are present in differently named fields in the different tables, and different data is present in similarly named fields, for example the (sn) field in the \u201cpeople\u201d and \u201csubscribers\u201d tables, there is also a structural difference between the tables. For example, the information contained in field (sn) of the \u201csubscribers\u201d table in database  corresponds to a subscriber's full name, such as \u201cHarry Samuel Jones, Jr.,\u201d whereas a record in the \u201cpeople\u201d table of database  that corresponds to the same person contains the same information\u2014namely, the person's full name\u2014but only through the concatenation of three separate fields; to wit, the (fn), (mn), and (sn) fields.","Thus, there is a need to maintain consistency between databases  and , and as indicated above, the ultimate aim of system  is to maintain this consistency, and to have the union of all data available to users. In the course of this undertaking, system  materializes and maintains database . With reference to the above-presented illustrative databases  and , database  may be structured to have the following tables and relationships:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"46.57mm","wi":"66.46mm","file":"US07660830-20100209-C00001.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["121","11","121","21","11","21","100","121","11","21"]},"Returning to the subject of database modifications, an update in database  (e.g., by operation of its administrator at port ) might be a string such as",{"@attributes":{"id":"p-0036","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["Update;","Updatekey subscribers.SOC=296-32-0735;","subscribers.lgn=smiller, subscribers.sn=Susan Miller;<LE>.\n\nWhat this string specifies is that\n"]}}}},"(a) an update of a record has taken place,","(b) a \u201csubscribers\u201d table includes a field labeled \u201cSOC\u201d,","(c) the record with the (SOC) field value of 296-32-0735 was updated,","(d) the value of an (lgn) field of that record was updated to smiller, and","(e) the value of an (sn) field in that record was updated to Susan Miller.","By the time this request passes through filter  and is stored in queue  it is of the form:",{"@attributes":{"id":"p-0042","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["Update;","source=DB_;","Updatekey messages.SOC=296-32-0735;","messages.lgn=smiller; messages.sn=Susan Miller;<LF>.\n\nWhat this string specifies is that the source is database , and that a record in the \u201cmessages\u201d table where the (SOC) field is equal to 296-32-0735 is to be updated so that the value of the (lgn) field is changed to smiller and the value of the (sn) field is changed to Susan Miller. The transformation used to create this update (example 2) from the update to database  (example 1) is a very simple one, based on attribute equivalence. A more complicated transformation from database  to database  might set name.cn, name.mn and name.sn appropriately from messages.sn. A merit of the system disclosed herein is that even though this relationship is only described implicitly through other attribute mappings, notable the ones between database  to database , described below, the transitive closure techniques eventually cause the attributes in database  to change appropriately.\n"]}}}},"An update request that is triggered by an add in database  might be a string such as:",{"@attributes":{"id":"p-0044","num":"0000"},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["Add;","Source=DB_;","messages.SOC=296-32-0735, messages.lgn=smiller, messages.sn=Susan A. Miller, messages.al=cal:2035823451, messages.msg=0,<LF>.\n\nLastly, an update request that is triggered by delete in database  might be a string such as:\n"]}}}},{"@attributes":{"id":"p-0045","num":"0000"},"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["Delete;","Source=DB_;","Updatekey messages.SOC-296-32-0735;<LF>."]}}}},"As indicated above, UM  carries out the updates specified by entries in queue  that arrive from filter , filter , administrator , and\/or possibly from DBM . The latter might occur when OS \/DBM  self-triggers an update in database  (for example, through action of the cron in a UNIX\u2122-based system).  presents a flow chart of the update sequencing process carried out in UM .","Step  determines whether queue  is empty. If it is not, step  fetches the next request in queue  and erases the request from the queue, sets index j to J, and passes control to step . The value of J corresponds to the number of external databases with which system  concerns itself, and in the illustrative example of , J=2, (with, for example, database  corresponding to j=1 and database  corresponding to j=2). The database within system  (i.e., database ) always corresponds to j=0.","Step  performs the appropriate modification to database j and passes control to step  where the index j is decremented, and the latter passes control to step . Pursuant to step , as long as j is not less than 0, control returns to step  to update the next database. When j=0 database  is updated. When j is less than 0, control passes to step  to initiate a database modification in response to a next update request in queue .","The Filters","The updating carried out in step  comprises a call to the filter that is appropriate for the database that is being updated. Specifically, filter  is called when updating database , and filter  is called when updating database . Each filter is simply a call to a TranslateUpdate Function followed by a call to CommunicateUpdate Function. The TranslateUpdate Functions of different filters vary in the details, but structurally they are the same. Similarly the CommunicatetUpdate Functions of different filters vary in the details, but structurally they are the same. Filter , for example, is simply:","OutboundFilter (111, portID, InUpdate, OutUpdate)","{","TranslateUpdate (111, InUpdate, effUpdate, OutUpdate, RC)","CommunicateUpdate (111, PortID, effUpdate, RC)","}","The PortID parameter identifies the port that is used to communicate with the target system, the InUpdate parameter is the update request structure\/string that is fetched from queue , and the OutUpdate parameter is an update request string that is sent to queue  in consequence of information gained from the process of updating the databases based on the update request of the InUpdate parameter (i.e., complying with transitive closure requirements). Internal to the filter, the effUpdate parameter of TranslateUpdate_ is the output structure\/string of the TranslateUpdate_ Function. It is the update information, developed in response to the InUpdate string and translated to the schema of database , which system  wishes to impart to database . The TranslateUpdate Function is thus the module that overcomes the structural and semantic differences between the source and the target of the filter. The RC parameter is a Return Code, indicating whether an update message should, in fact, be sent to PBX , or whether an error indicates that an update of database  should not take place. The CommunicateUpdate Function communicates the effUpdate information to the PBX via the PortID, using the API and protocols specific to PBX. The CommunicateUpdate Function is thus the module that overcomes the communication protocol differences between the filter's source and the target systems, and interacts with the target system to actually implement the requested database modification. It may be noted that the same CommunicationUpdate module may be used in more than one filter, for example if system  were interacting with another DEFINITY PBX satellite system. That is, the CommunicationUpdate module is target-centric. For example, satellite systems that employ different communication APIs require a CommunicationUpdate module that is different in its particulars.","As indicated above, the task of each TranslateUpdate Function is to overcome the structural and semantic differences between a specific source and a specific target. It accepts a structure\/string that specifies the action to be done (InUpdate), and outputs a translated structure\/string (effUpdate) that is aimed at the target database, and a return code (RC). In addition, it outputs an OutUpdate string that is returned, illustratively to queue , to update the databases in conformance with transitive closure. In accordance with the principles disclosed herein, the TranslateUpdate Function comprises three sections of simple declarative specification sections, and a processing section. The following illustrates the three specification sections for the TranslateUpdate_ Function of the database  that is illustrated above.",{"@attributes":{"id":"p-0058","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Section I"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Source","name=DB_121;","# Specifies that database 121 is the source"]},{"entry":["SourceObjects","names.SS,","# Potentially relevant fields of the \u201cnames\u201d"]},{"entry":[{},"names.cn,","table;"]},{"entry":[{},"names.mn,"]},{"entry":[{},"names.sn,"]},{"entry":[{},"names.org,"]},{"entry":[{},"comm.SSN,","# Potentially relevant fields of the \u201ccomm\u201d"]},{"entry":[{},"comm.ID,","table;"]},{"entry":[{},"comm.ph,"]},{"entry":[{},"comm.typ,"]},{"entry":[{},"messages.SOC,","# Potentially relevant fields of the"]},{"entry":[{},"messages.sn,","\u201cmessages\u201d table;"]},{"entry":["Target","name=DB_11;"]},{"entry":["TargetObjects","people.SS,"]},{"entry":[{},"people.cn,"]},{"entry":[{},"people.mn,"]},{"entry":[{},"people.sn,"]},{"entry":[{},"people.org,"]},{"entry":[{},"communication.SSN,"]},{"entry":[{},"conununication.ID"]},{"entry":[{},"communication.ph,"]},{"entry":[{},"communication.typ;"]},{"entry":["TargetJoin","people.SS,","# Reference fields-used in \u201cadd\u201ds;"]},{"entry":[{},"communication.SSN;"]},{"entry":["TargetUpdate","people.SS,","# Reference fields-used in \u201cupdate\u201ds;"]},{"entry":[{},"communication.ID;"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"This section identifies database  as the source, specifies the fields (objects) found in the tables of database , identifies database  as the target database, and specifies the fields (objects) found in the tables of database . It is noted that in specifying the source objects, objects that cannot contribute information to the target database are not included; for example, the (messages.al) object. Correspondingly, target fields that cannot be generated from information from the source are also not included.","The TargetJoin subsection is used in \u201cadd\u201d-type modifications to insure that update requests that are structured in the form of an \u201cadd,\u201d add a record to database  only if necessary. For example, the earlier illustrated add request (Example 3), it would not make good sense to add a record to the tables of database  if appropriate records already exist in the tables of database  for an individual with a social security number of 296-32-0735. Indeed, the database manager of database  would not allow it. However, it makes good sense to make sure that the attributes of the individual in database  whose social security number is 296-32-0735 are consistent with the attributes found in the add request. For example, if the record in the \u201cnames\u201d table with SS=296-32-0735 contains the information cn=Susan, mn=Ann and sn=Jones, it would make sense to convert the add request to an update request to change the (sn) field from Jones to Miller, and it would even make sense to send back to system  a update request modify Susan Miller to Susan Ann Miller.","To refrain from doing the inadvisable, and to do the advisable instead, the TargetJoin subsection specifies the fields that uniquely identify the record that is sought to be inserted. That is, fields specified in the TargetJoin subsection identify the key fields in the target database that are used when an add request is attempted to insure that it should not be converted to an update request. In the illustrated TranslateUpdate_ Function, those fields are the people.SS field for updates to the \u201cpeople\u201d table, and comnmunication.SSN field for updates to the \u201ccornmunication\u201d table.","Thus specifically, in response to an add specification in the InUpdate string, the TranslateUpdate Function ought to perform a query on database , such as",{"@attributes":{"id":"p-0063","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT","names.*, communication.*"]},{"entry":[{},"FROM","names, communication"]},{"entry":[{},"WHERE","names.SS=messages.SOC and communication.SSN="]},{"entry":[{},{},"messages.SOC,"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"11"},"Alternatively, the query can be performed on corresponding tables and fields in database , as described in more detail below.","The TargetUpdate subsection specifies the target fields that uniquely identify records in the target database that are used for updates to the target tables. That is, as with add requests, update requests ought be performed intelligently, which means that a field should not be updated if the update would result in no change. Accordingly, a query is performed by the TranslateUpdate Function, effectively as described above, the query results are analyzed, and an update request is constructed accordingly. Thus, the TargetUpdate subsection specifies the key fields for update requests and, in the illustrated example, those fields are the people.SS field for updates to the \u201cpeople\u201d table, and communication.ID field for updates to the \u201ccommunication\u201d table.","Similarly, there may be a TargetDelete subsection in some embodiments of the invention. The TargetDelete subsection specifies the target fields that uniquely identify records in the target database that are to be deleted. In this embodiment, the TargetDelete fields are always the same as the TargetUpdate fields, so only the TargeUpdate fields are specified.","The second section of the TranslateUpdate_ Function of the above-illustrated database  may be of the form:",{"@attributes":{"id":"p-0068","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Section II"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Constraint","sn \u201c{circumflex over (\u2009)}[A-Z][a-z]*\u201d,","# imposed constraints;"]},{"entry":[{},{},"org \u201c[0-9][0-9][0-9]\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The third section of the TranslateUpdate_ Function of the above-illustrated database  may be of the form:",{"@attributes":{"id":"p-0070","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Section III"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["people.SS=names.SS,","# single, or alternative,"]},{"entry":["people.SS=comm.SSN;","definitions for objects in the"]},{"entry":["people.SS=messages.SOC","names table of database 11;"]},{"entry":"people.cn=names.cn,"},{"entry":"people.cn=stripoff_cn(messages.sn);"},{"entry":"people.mn=names.mn,"},{"entry":"people.mn=stripoff_mn(messages.sn);"},{"entry":"people.sn=names.sn,"},{"entry":"people.sn=stripoff_sn(messages.sn);"},{"entry":"people.org=names.org;"},{"entry":["communication.SS=names.SS,","# single, or alternative,"]},{"entry":["communication.SS=comm.SSN;","definitions for objects in the"]},{"entry":["commumcation.SS=messages.SOC","communication table of database"]},{"entry":["communication.ph =comm.ph;","11;"]},{"entry":"communication.typ=comm.typ;"},{"entry":"communication.ID=comm.ID;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"This section specifies the correspondences that are enforced in placing data in the target database; i.e., this section produces the information that forms the effUpdate structure\/string. In addition to forming the effUpdate structure\/string, it provides for multiple mappings as a sequence of alternate mappings. The first mapping in the sequence is executed if the required source attribute is present. Otherwise, the next mapping in the sequence is executed, etc. Of course, if the source attribute is not present for any of the alternative mappings, no mapping is effected at all. In the case of the first entry, for example, it states that if names.SS attribute is present in the InputString, then the people.SS field for database  is made equal to the provided names.SS attribute. If the names.SS attribute in database  is not present but the comm.SSN attribute is present, then the people.SS field for database  is made equal to the comm.SSN attribute. Lastly, if neither the names.SS attribute nor the comm.SS attribute are present but the messages.SOC field is present, then the people.SS field of database  is made equal to the messages.SOC attribute. It is noted that pattern the stripoff_cn function, as well as other functions, can include various conventional constructs, such as pattern matching. With the aid of pattern matching, for example, the components of a person's name can be properly parsed out regardless of whether \u201cJohn Adams Quincy, Jr.,\u201d or \u201cQuicy Jr., John Adams\u201d is presented. For example, the following pattern properly locates a person's first name:",{"@attributes":{"id":"p-0072","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pattern fname(strg)="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\u201c,\u201d, part(part(strg,2,2,\u201d,\u201d),1,1,\u201d\\t\\t\u201d),"]},{"entry":[{},"\u201c{circumflex over (\u2009)}.\u201d, part(strg,1,1,\u201d\\t\\n\u201d)"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The pattern, called fname, accepts the full name, strg, as an argument. The pattern includes two columns and two rows. It matches strgagainst the regular expression in the first column in sequence. The first matching regular expression causes the mapping in the second column to be executed. In this example, the mappings use the function \u201cpart\u201d: part(strg,a,b,c).","The function \u201cpart\u201d breaks the input string strg into parts separated by one or more of the delimiter characters in c. In the above examples, the delimiters are either a signal comma or from the set including a blank, a tab, and a new line. Counting from 1, \u201cpart\u201d returns parts a through b (with enclosed delimited characters present).","In the pattern fname, the first row matches names that include a comma, and the associated mapping returns the first word after the comma as the first name. If the regular expression in the first row does not match, the regular expression in the second row matches any non-null string. The associated mapping returns the first word of strg as the fist name. If neither regular expression matches, the original string (in this case, null) is returned.","Also, with pattern matching, bulk updates are possible; for example, change the people.org field to \u201cAvaya 12\u201d in all records where the people.org field is \u201cLucent 45*\u201d (where the * is a \u201cwildcard\u201d that stands for any one or more characters). Lastly, string operations are permissible in the specification section m. For example, the third section of the TranslateUpdate_ Function (where the database  is the target database) includes the entry\n\n","In the declarative specification, the first section describes the source and target attributes that may be involved in the modification of the target. The source attributes are used in the correspondences in Section III to generate target attributes that are added, modified, deleted, used as keys, or used in constraints. Since some attributes that can be generated by the correspondences may not be permitted in add or modify requests, at the target, or must not be deleted from the target database, it is useful to note this in the TargetObjects section. Such attributes are preceded by a \u201cnoadd,\u201d \u201cnoupdate,\u201d and\/or \u201cnodelete\u201d qualifier. If the communication.ID for database  is generated by the target as a unique key and cannot be changes but can be deleted with the record, it would be represented in the following way in TargetObjects:\n\n","When some attributes in a target are listed as \u201cnodelete,\u201d a delete request for the target replaces all attributes that can be deleted with nulls and leaves the \u201cnodelete\u201d attributes unchanged. In the global, materialized, database (database ) this has the effect of allowing information specific to one of the integrated database to be deleted while still maintaining information required by the other integrated databases When all the attributes in the global database record become null, the global database can remove the record.","The processor section creates the effUpdate structure\/string, and the Return Code. Employing queries that address database  rather than the target databases themselves, the processing section of the TranslateUpate Function may have the form:\n\n",{"@attributes":{"id":"p-0080","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"changed field","first correspondence"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"people.SS","names.SS"]},{"entry":[{},"people.cn","names.cn"]},{"entry":[{},"people.mn","names.mn"]},{"entry":[{},"people.sn","names.sn"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":{"@attributes":{"id":"ul0016-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":["# Identify involved DB_ tables.\n        \n        ","# Construct and execute Query on involved tables for target information.\n        \n        ","# Compare what is in target to what the update calls for. Through the \u201cstripoff\u201d it is determined that the target fields need to be updated as follow:\n        \n        ","That may be modified, however, to take the approach that an update to a null really corresponds to a no update at all, in which case the comparison to be made is whether the results of the query yield names.cn=Susan, and people.sn=Miller. a null value. Carrying out the comparisons in the illustrative example, this step identifies that the update should change the surname of the individual with people.SS=296-32-0735 from \u201cJones\u201d to \u201cMiller.\u201d Additionally, the comparison step reveals that the update to the \u201cmessages\u201d table suggests that the people.mn should be empty, but the query shows that people.mn is set to \u201cAnn.\u201d This suggests that the messages.sn field should be updated from Susan Miller to Susan Ann Miller and the name.sn field should be updated to Miller. The changes to these fields are identified by using the declarative specification for filter ; that is, the specification for translating the data in reveres, from an update on database  to an update on database  (see the later discussion on inbound filters).","# Construct add\/update request on the target tables\n        \n        ","# Construct the OutUpdate\n        \n        "]}}}},"In the above illustration of TranslateUpate for filter  the constraints of the second specification section are met. When a constraint is not met, the processing section of the TranslateUpdate Function chooses one of a number of options, based on the specific encountered situations. For example, if the update request illustrated above wished to set messages.sn-Susan Miller3, the constraints of the second specification section would not be met, the RC parameter would be set to its \u201cerror\u201d value, for example, binary 1, the effUpdate string would not be created, the OutUpdate string would not be created, and the CommunicateUpdate Function would not be executed.","The above illustrative example demonstrates a situation where an add request is converted to an update request. Other database modification changes can also occur, for example, where an update request changes to a delete request vis-\u00e0-vis one database, and to an add request vis-\u00e0-vis another database. Consider, for example, the situation where a first database contains records for individuals with assigned telephone numbers from exchange (908)-582, e.g., all individuals working company A in state X, a second database contains records for individuals with assigned telephone numbers from exchange (973)-386, e.g., all individuals working for company B in state X, and a third database contains records of all individuals with telephones in state X. Consider further that an individual with telephone number (973)-386-1234 changes jobs and is given the telephone number (908)582-1234, and that this modification in the telephone number of the individual is effected in the third database. Such a modification would be in the form of an update in the third database, which triggers an update request that is sent to queue . In executing the update request on the first database attempting to update from (973)-386-1234 to (908)-582-1234, the record (973)-386-1234 is not found, but it is known from the second specification section that this database only entertains phone numbers in the format (908)-582. Since the update matches this constraint, but a record to be modified in not found, the update request is converted to an add request. In executing the update request on the second database, on the other hand, a record is found, but the constraint of the second specification section disallows changes other than to numbers that begin with (973)-386. Since the individual's number does not begin with (973)-386, the record of that individual must be removed from the second database and, therefore, the update request is converted to a delete request.","In our examples, records in the target database are read and compared to incoming request before being updated. Reading target records that match the TargetJoin key fields on an add is necessary to permit combining existing data with additional data from new sources. The filter may optionally raise an error to indicate that the databases are out of synchronization if an add request attempts to change preexisting data (rather than modify it). If the source field in the add request is identical to the target, then raising an error is not appropriate because the add is being re-executed to ensure consistency across all of the databases (as explained further below). In such a case, the add request is always converted to an update request.","When an update request is made, the constraints can often be used to avoid the cost of the read at the target. This is useful, because the targets integrated into the global database may need to avoid unnecessary operations due to performance limitations or requirements. The previously described algorithms for creating target attributes from the source attributes are used to create values for constrain attributes that may already exist in the target (ore old attributes) as well as their values at the target after any modification (the new attributes). The following rules for changing an update request to some other modification request can be used:",{"@attributes":{"id":"p-0085","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Old Attributes","New Attributes","Resulting Operation"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["violate constraints","satisfy constraints","add request"]},{"entry":["satisfy constraints","satisfy constraints","remains a modify request"]},{"entry":["satisfy constraints","violate constraints","delete request"]},{"entry":["violate constraints","violate constraints","no operation at the target."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"As indicated above, the OutUpdate string provides a mechanism for sending back to queue  modification requests that, in conformance with transitive closure, are found to be needed though the process of preparing a modification request for the target database. At times, the same mechanism must take place, but after a modification is effected in the target database. Consider, for example, that an individual's surname is modified in the \u201cnames\u201d table of database , and that an update request is sent to queue , which later is converted to an update request for the \u201csubscribers\u201d table of database . Consider further that database  develops the Login name of individuals algorithmically, and that, consequently, an individual name Susan Ann Jones would have the Login name sajones. When the names of Susan Ann Jones is updated to Susan Ann Miller (e.g., following a marriage), database  automatically changes the Login name from sajones to samiller (assuming that samiller is unique). To satisfy transitive closure, database  needs to create and send an update request to queue  to reflect the change from sajones to samiller. A similar situation occurs when an update request that is applied to a particular target database is converted to an add request, and the table where the record is added creates its own Record ID (or some other object). An update request must be created and sent to queue  to impart to system  the created Record ID (or some other object) information.","To generalize the above, a simple algorithm for achieving transitive closure between a source-target pair with mappings in both directions effectively follows the following:\n\n","An optimization of these algorithms is possible for data generated by a target database other than the global database. If the generated target attributes do not affect any attributes except those in the global database, the newly generated attributes can be mapped to the affected attributes in the global database and added to the current update request. Since the global database is always updated last, information about the generated attributes can be recorded in the global database without sending a new update request to queue . Typically when unique keys are generated by target database, only the global database needs the record them for use in future update operations. Likewise, if the global database generates data that is not used elsewhere, it does not need to send a new update request to queue .","It may be noted that the update request that is communicated to queue  and that is propagated identifies the source database. Yet, the sequencing described above, and depicted in  does not treat the source database any differently than any other database. The need for the sequencing to treat the source database in the same manner as non-source databases is made clear by considering a situation where a first database sends an update request to queue  to modify attribute A to B, and a short time later a second database sends an update request to queue  to modify the same attribute from A to C. By not ignoring the information as to which database is the source of the modification requests, the first update request results in both databases assigning the value B to the attribute, and the second update request results in both databases assigning the value C to the attribute. If update requests skipped the source database, the first update request would result in the second database assigning the value B to the attribute, and the second update request result would result in the first database assigning the value C to the attribute. That would make the databases inconsistent.","Theoretically, there is a possibility of an endless modification loop. An update to table a parameter X in A may cause an update to a parameter Y in table B, which may cause an update to the same parameter X in table A, ad infinitum. While this is highly unlikely, one can protect against the endless loop by adding a repetition flag to each update that is sent to queue . Updates that originate in a database and are sent to queue  carry the value 0 for the repetition flag. An update that results from a modification triggered from system  is sent back with a repetition flag that is incremented by 1. Setting a threshold at some selected arbitrary value (for example, in the second specification section\u2014such as RepetitionFlag<4) permits breaking the endless loop.","The above description coveres the outbound filters, such as filter , and the inbound filters are quite similar. For example, a satellite database triggers execution of an inbound filter (such as database  triggering execution of filter ), and that filter comprises a call to a source-centric communicateUpdate module, followed by a TranslateInUpdate function. For example,\n\n","The above disclosed the principles of this invention, but it should be understood that various modifications and additions can be implemented without departing from the spirit and scope of the invention, which is defined in the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1","b":["100","100"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"],"b":"120"}]},"DETDESC":[{},{}]}
