---
title: Adaptive resource management using survival minimum resources for low priority consumers
abstract: Allocation of resources across multiple consumers allows efficient utilization of shared resources. Observed usages of resources by consumers over time intervals are used to determine a total throughput of resources by the consumers. The total throughput of resources is used to determine allocation of resources for a subsequent time interval. The consumers are associated with priorities used to determine their allocations. Minimum and maximum resource guarantees may be associated with consumers. The resource allocation aims to allocate resources based on the priorities of the consumers while aiming to avoid starvation by any consumer. The resource allocation allows efficient usage of network resources in a database storage system storing multiple virtual databases.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09106591&OS=09106591&RS=09106591
owner: Delphix Corporation
number: 09106591
owner_city: Menlo Park
owner_country: US
publication_date: 20091224
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This invention relates generally to resource management for storage systems, and in particular to adaptive management of resources shared by multiple consumers.","Virtualization technologies allow hardware resources to be used and shared by multiple consumers. A consumer can be a process running on a computer system that accesses resources to perform certain tasks. An example of consumer is a task related to database operations on a system hosting databases, for example, query processing, data manipulations, reporting, replication, backup, restore, or export. These tasks can require significant amount of system resources. An example of a shared hardware resource is network resource that allows consumers to communicate with external systems. Another example is a bandwidth of storage subsystem. Shared resources are allocated between various consumers. The allocation of resources to individual consumers determines the overall utilization of the hardware resources in a system.","Consumers of resources may be associated with priorities based on the consumer's importance to an end user. For example, certain consumers perform tasks that have higher priority than other consumers or have tighter service level agreements (SLA) requirements. Allocation of hardware resources between consumers need to consider their priorities. Allocations aim to ensure that higher priority tasks get a larger share of resources than lower priority tasks. However, even a low priority task should be able to make progress over time, although its progress may be slow compared to high priority tasks. Improper allocation of resources to consumers may result in starvation of some consumers and hoarding of resources by other consumers. Starvation of a consumer results when the consumer is perpetually denied resources that it needs.","Various strategies are utilized to share resources between consumers. A fixed resource allocation strategy can allocate fixed amount of resources to different consumers based on their priorities. In many cases these fixed amounts are determined upfront or are results of explicit operator input. Fixed resource allocation strategies may not be able to automatically adjust to dynamic changes in consumer needs. A proportional fairness based resource allocation strategy allocates an amount of resources for each consumer proportionate to its anticipated resource consumption. Another resource allocation strategy is a round robin strategy that iterates through consumers in a round robin fashion to allocate resources. Other types of allocation strategies include first come first served type of allocation, fair queuing (max-min fairness) and weighted queuing.","Virtualization of databases allows consolidation of multiple virtual databases on the same database storage system. Multiple tasks associated with the virtual databases may execute on the storage system including, loading of the databases, provisioning of the virtual databases, and serving of requests and tasks related to the virtual databases. These tasks are consumers of system and hardware resources, for example, network resources and storage bandwidth. The goal is the allocation of resources for the consumers optimizes that optimizes the overall utilization of the resources for the system across multiple virtual databases with respect to their SLAs and priorities. Resources are distributed among various consumers depending on their dynamic needs and required SLAs.","Embodiments of the invention enable allocation of network resources to consumers of different priorities in a computer system. A metric representing the aggregate needs of a low priority set of consumers of the network resources is determined based on observed usage of the network resources by the consumers. The metric representing the needs of the low priority set of consumers is compared to a threshold value. If the needs of the low priority consumers are above a threshold value, allocations of the network resource are first determined for a high priority set of consumers. After allocating the resources to the high priority set of consumers, a remaining amount of left over allocations is determined and allocated to the low priority set of consumers. In an embodiment, resources can be allocated to the high-priority customers up to the total amount of resources minus the amounts guaranteed to the lower priority consumers.","In an embodiment, if the metric representing the needs of the consumers is below a threshold value, the allocations of the low priority consumers are determined first and the remaining leftover resources are allocated to the high-priority consumers. Any resources still remaining are distributed over all the consumers.","Embodiments of the invention enable computation of total throughput of network resources used by consumers. Multiple usage values of the network resource that are cumulative over time are determined. Each cumulative usage value is associated with a time interval and is based on observed usages of network resource by consumers over the time interval. The total throughput of the network resource is determined based on an aggregate value based on the multiple cumulative usage values. The total throughput value is increased by a predetermined factor. Allocations of the network resource for each consumers of the network resource are determined based on the increased total throughput value.","Each allocation for a consumer determines the availability of the network resource to the consumer for a subsequent time interval. The system assumes certain guarantees for individual users and for priority groups. If these guaranteed amounts are unlikely to be consumed based on the forecasting of the described method, the surplus part of the resource will be allocated to other consumers.","The features and advantages described in this summary and the following detailed description are not all-inclusive. Many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings, specification, and claims.","The figures depict various embodiments of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.","Virtual Databases as Consumers of Resources","Creation of virtual databases allows storage of multiple virtual databases in a database storage system. Storage of multiple virtual databases on a database storage system requires execution of multiple tasks related to the virtual databases on the database storage system. These tasks include creation of virtual databases, tasks related to use of virtual databases including query processing, data manipulations, replication, backup, restore, export of virtual databases and the like. These tasks share hardware resources available on the database storage systems and act as consumers of the shared resources. Different tasks can be associated with different priority levels which may be determined by a system administrator. The resources shared by different consumers need to be allocated between the consumers appropriately, for example, higher priority consumers may be given larger share of resources compared to lower priority consumers. In an embodiment, the allocation of resources ensures that lower priority tasks are not starved of resources. In another embodiment, some lower priority tasks may be starved but are allowed to continue to exist in the system. The system aims at optimizing the overall usage of the shared resources across various consumers with respect to their priorities.","In an embodiment, usage of shared resources is optimized across multiple modules of virtual database systems stored on a database storage system. Virtual databases can be created based on the state of a production database at a particular point in time, and the virtual databases can then be individually accessed and modified as desired. A database comprises data stored in a computer or storage subsystem for use by computer implemented applications. A database server is a computer program that can interact with the database and provides database services, for example, access to the data stored in the database. Database servers include commercially available programs, for example, database servers included with database management systems provided by ORACLE, SYBASE, MICROSOFT SQL SERVER, IBM's DB2, MYSQL, and the like. The term \u201cproduction database\u201d is used in particular examples to illustrate a useful application of the technology; however, it can be appreciated that the techniques disclosed can be used for any database, regardless of whether the database is used as a production database. The virtual databases are \u201cvirtual\u201d in the sense that the physical implementation of the database files is decoupled from the logical use of the database files by a database server. Systems and methods for creating virtual databases and using them in workflows are disclosed in U.S. application Ser. No. 12\/603,545 filed on Oct. 21, 2009, which is incorporated by reference in its entirety.","In one embodiment, information from the production database is copied to a storage system at various times, such as periodically. This enables reconstruction of the database files associated with the production database for these different points in time. The information may be managed in the storage system in an efficient manner so that copies of information are made only if necessary. For example, if a portion of the database is unchanged from a version that was previously copied, that unchanged portion need not be copied. A virtual database created for a point in time is stored as a set of files that contain the information of the database as available at that point in time. Each file includes a set of database blocks and the data structures for referring to the database blocks stored for earlier copies. A virtual database may be created on a database server by creating the database files for the production database corresponding to the state of the production database at a previous point in time, as required for the database server. The files corresponding to the virtual database are made available to the database server using a file sharing mechanism, which links the virtual database to the appropriate database blocks stored on the storage system. The process of making the virtual database available to a database server is called \u201cprovisioning\u201d the virtual database. In some embodiments, provisioning the virtual database includes managing the process of creating a running database server based on virtual database. Multiple VDBs can be provisioned based on the state of the production database at the same point in time. On the other hand, different VDBs can be based on different point in time state of the same production database or different production databases. The database server on which a virtual database has been provisioned can then read from and write to the files stored on the storage system. A database block may be shared between different files each file associated with a different VDB.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["110","100","110","140","100"]},"In response to a request from the administrator system , or based on a predefined schedule, the database storage system  may send a request  for data to a production database system . The production database system  responds by sending information stored in the production database as a stream of data . The request  is sent periodically and the production database system  responds by sending information representing changes of data stored in the production database since the last response  sent by the production database system . The database storage system  receives the data  sent by the production database system  and stores the data. The database storage system  may analyze the data  received to determine whether to store the information or skip the information if the information is not useful for reconstructing the database at previous time points. The database storage system  stores the information efficiently, for example, by keeping versions of database blocks that have changed and reusing database blocks that have not changed.","To create a virtual database, the database storage system  creates files that represent the information corresponding to the production database system  at a given point in time. The database storage system  exposes  the corresponding files to a virtual database system  using a file sharing system . The virtual database system  runs a database server that can operate with the files exposed  by the database storage system . Hence, a virtual copy of the production database is created for the virtual database system  for a given point in time in a storage efficient manner.","Modules in the database storage system  require resources to perform tasks. The resources can be network resources for communicating with external systems, computing resources or other resources. For example, the virtual database manager  may need resources for provisioning a VDB, the point-in-time copy manager  may need network resources for retrieving a point-in-time copy of a database from the production database system , the transaction log manager  may need network resources for retrieving log updates from a production database system , the virtual database manager  may need resources for exporting the data in a VDB to an external system. A task performed by a module utilizing a resource is a consumer of the resource.","System Architecture",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 2"],"b":["100","100","110","100","140","130"]},"A production database system  is typically used by an organization for maintaining its daily transactions. For example, an online bookstore may save all the ongoing transactions related to book purchases, book returns, or inventory control in a production system . The production system  includes a database server  and a production DB data store . The production DB data store  stores data associated with a database that may represent for example, information representing daily transactions of an enterprise. The database server  processes requests that access data stored in the production DB data store . In alternative configurations, different and\/or additional modules can be included in a production database system .","The database storage system  retrieves information available in the production database systems  and stores it. The information retrieved includes database blocks comprising data stored in the database, transaction log information, metadata information related to the database, information related to users of the database and the like. The information retrieved may also include configuration files associated with the databases. For example, databases may use vendor specific configuration files to specify various configuration parameters including initialization parameters associated with the databases.","The data stored in the storage system data store  can be exposed to a virtual database system  allowing the virtual database system  to treat the data as a copy of the production database stored in the production database system . The database storage system  includes a point-in-time copy manager , a transaction log manager , a interface manager , a file sharing manager , a virtual database manager , a storage system data store , and an adaptive resource manager . The adaptive resource manager  comprises various modules including an allocation manager , a scheduler , a consumer store , a metrics manager  and a resource usage store . In alternative configurations, different and\/or additional modules can be included in the database storage system .","The point-in-time copy manager  interacts with the production database system  by sending a request to retrieve information representing a point-in-time copy (also referred to as a \u201cPIT copy\u201d) of a database stored in the production DB data store . The point-in-time copy manager  stores the data obtained from the production database system  in the storage system data store . The data retrieved by the point-in-time copy manager  corresponds to database blocks (or pages) of the database being copied from the production DB data store . After a first PIT copy request to retrieve information production DB data store , a subsequent PIT copy request may need to retrieve only the data that changed in the database since the previous request. The data collected in the first request can be combined with the data collected in a second request to reconstruct a copy of the database corresponding to a point in time at which the data was retrieved from the production DB data store  for the second request.","The transaction log manager  sends request to the production database system  for retrieving portions of the transaction logs stored in the production database system . The data obtained by the transaction log manager  is stored in the storage system data store . In one embodiment, a request for transaction logs retrieves only the changes in the transaction logs in the production database system  since a previous request for the transaction logs was processed. The database blocks retrieved by a point in time copy manager  combined with the transaction logs retrieved by the transaction log manager  can be used to reconstruct a copy of a database in the production system  corresponding to times in the past in between the times as which point-in-time copies are made.","The file sharing manager  allows files stored in the storage system data store  to be shared across computers that may be connected with the database storage system  over the network. The file sharing manager  uses the file sharing system  for sharing files. An example of a system for sharing files is a network file system (NFS). A system for sharing files may utilize fibre channel Storage area networks (FC-SAN) or network attached storage (NAS) or combinations and variations thereof. The system for sharing files may be based on small computer system interface (SCSI) protocol, internet small computer system interface (iSCSI) protocol, fibre channel protocols or other similar and related protocols.","The virtual database manager  receives requests for creation of a virtual database for a virtual database system . The request for creation of a virtual database may be sent by a database administrator using the administration system  and identifies a production database system , a virtual database system , and includes a past point-in-time corresponding to which a virtual database needs to be created. The virtual database manager  creates the necessary files corresponding to the virtual database being created and shares the files with the virtual database system  using the file sharing manager .","The interface manager  renders for display information necessary for display using the administration system . A database administrator user can see information available in the storage system data store  as well as take actions executed by the database storage system. For example, the database administrator can request the database storage system  to make a PIT copy of a database stored on a production database system  at a particular point-in-time. In an embodiment, the interface manager allows a system administrator to set various priorities associated with different tasks. The system administrator can also set minimum and maximum guarantees of allocation associated with various tasks.","The adaptive resource manager  contains various modules necessary to allocate shared resources between tasks representing consumers of the shared resources. The consumer store  maintains data structures representing consumers in the database storage system . The consumer store  stores the priority and sub-priority associated with each consumer. Consumers may be added to or deleted from the consumer store . A consumer may have a status, for example, pending or active. The resource usage store  stores information related to various resources available to the consumers in the database storage system  and information representing the usage of the resources.","The allocation manager  determines the allocations of various consumers for a given time interval. The allocation manager performs an allocation run comprising analysis of usage of resources based on information available in the resource usage store  and of consumer information available in consumer store  to determine allocations of resources across different consumers. In an embodiment, the allocation manager determines allocations of resources periodically, where results of each allocation run are used for a subsequent time interval.","The scheduler  periodically invokes the allocation manager  to execute a run of the allocation including collection and analysis of usages of resources by various consumers and to determine allocation of the resources for the next time interval. In an embodiment, the allocation manager  invokes the scheduler to schedule the next run of the allocation manager . The scheduler may get scheduling requests from other modules, for example, from the interface manager  that forwards requests made by a system administrator using the administration system . The scheduler  may be implicitly invoked by execution of specific tasks, for example, when a consumer is created or deleted.","The metrics manager  gathers statistics for use by other modules or for reporting via the user interface . Examples of data reported include observed usage per consumer, \u2018unhappiness\u2019 index associated with consumers described herein, overall resource usage and the like. In an embodiment, the metrics manager maintains a cache that stores frequently accessed information for fast access. The metrics manager  may receive and process requests for information from the user interface  for display via the user interface .","A virtual database system  includes a database server . The database server  is similar in functionality to the database server  and is a computer program that provides database services and application programming interfaces (APIs) for managing data stored on a data store . The data managed by the database server  may be stored on the storage system data store  that is shared by the database storage system  using a file sharing system . In alternative configurations, different and\/or additional modules can be included in a virtual database system . Some data can be stored on local storage.","Consumer Priority Hierarchy","A consumer is assigned to a priority group that determines the preference in allocation of resources for the consumer. There can be multiple priority groups that each consumer can be assigned to. Each consumer is assigned to only one priority group at a time. The consumer can be dynamically reassigned to a different priority group if necessary. The assignment of priority groups can be performed based on a default priority group when the consumer is added to the system or by a database administrator using the user interface . Alternatively consumers can be automatically mapped to priority groups based on attributes of the consumer. Automatic assignments can be subject to change by a database administrator.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3","b":["1","310","2","315","2","2","1"]},"As illustrated in , each priority is divided into sub-groups, for example, high sub-group , medium sub-group , and low subgroup . The high sub-group  includes consumers with priority higher than the consumers in medium sub-group  which in turn have priority higher than consumers in low subgroup . Similar to a default priority group being assigned to a consumer, a default sub-group within the priority group can be assigned to each consumer. A database administrator can reassign the sub-group of a consumer if necessary.  shows a root group  that includes all priority groups underneath. In some embodiments, the root group  can be used as the default priority group for the resources. Note that other embodiments can have a hierarchy of priority groups and sub-groups of arbitrary depth and width.","In one embodiment a consumer () is assigned to the lowest level of priority group in the hierarchy of priority-groups as shown in . In other embodiments, the consumer  can be assigned to any priority group in the hierarchy. For example, a consumer can be assigned to the P group , and may be assigned to a sub-group assigned by default. The parent of a consumer  is the group that the consumer belongs to in the priority group hierarchy.","Resources used by Consumers",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 4","b":["100","100","430","110","130","100","410","410","420","430","410","420","420","100","410"]},"Each network link  has a stated linkcapacity that specifies the bandwidth supported by the network link . The stated link capacity of the network link  may be specified by the vendor of the network link . However the actual bandwidth that is obtained when the network link  is used in a system can be different from the stated bandwidth since the actual bandwidth may depend on several factors, including network configurations, configuration and capacity of storage of the database storage system , nature of the workload, and the caching properties of the consumer tasks.","The portion of the resource associated with a network link  that is assigned to a consumer is called a flow . Hence, each external consumer  is assigned a flow  as shown in . A flow  is associated with attributes including, a network link  used by the flow, a priority value associated with the flow, and a network port on the database storage system  used by the flow. Typically, there is bidirectional network traffic associated with the flow  between the external consumer  associated with the flow and the database storage system . The database storage system  can enforce limits on the bandwidth available to a flow . The priority associated with a flow  typically depends on the priority of the associated consumer. The database storage system  throttles the network traffic through each flow to guarantee specific bandwidth to each consumer.","In an embodiment, corresponding to each external consumer  task, there is a consumer task executing on the database storage system . The information related to the consumer in the database storage system  is stored in the consumer store . Information related to the resources including network links is stored in the resource usage store .","Total Throughput Discovery","A link's total throughput is the aggregated network bandwidth available to all consumers using this particular link. Portions of the network bandwidth available on a link are allocated to the consumers associated with the link. The appropriate portion allocated to a consumer is calculated based on the total throughput. However, as described above, the total throughput depends on the actual bandwidth available using the link that depends on several factors and needs to be estimated. Also, the total throughput can change over time based on the changes in the factors that affect the overall bandwidth of the link.","The metrics manager  of the adaptive resource manager  stores the previously estimated resource usages of the network links  in the resource usage store . The previously estimated resource usage data is used to estimate the total throughput for network links . The significance and influence of the values of the past observations of resource usage are diminished over time to accommodate for changes in workloads, and storage or network configurations that affect the total throughput.","In an embodiment, a predetermined parameter lookback determines the length of historic time interval used to estimate the total throughput. All observed resource usages between the present time t and the previous time point (t-lookback) are used to determine the total throughput. However resource usage data prior to the time (t-lookback) is not considered. In another embodiment, a decay parameter is considered that reduces the contribution due to older values of resource usage. The decay parameter may reduce the importance of previous values by a factor depending on the age of the age of the data. For example, the older the data is, the smaller the contribution of the data.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5","b":["225","505","235","225","510"]},"The observed usage of a link is determined by estimating the usage of the link by each consumer served by the link. The usage may be estimated based on the consumer's inbound as well as outbound usage of the link. For example, the usage may be based on the total amount of data sent using the link in either direction during a time interval. The time interval for measuring the usage of a link by a consumer can be the predetermined time interval that the allocation manager  waits  before re-computing the TotalThroughput value for the link. For example, the time interval for measuring the usage of a link by a consumer can be 30 seconds and the data transferred measures using kilobytes. The observed usage for a link during a time interval is the total of the current usage of all consumers of the link during the time interval. In case of resources that are network links, the usage is measured in both directions, sending and receiving.","Based on the observed usage ObservedUsage of the link in the current time interval as well as previous time intervals, the allocation manager  re-computes  the total throughput value using the following equation:",{"@attributes":{"id":"p-0056","num":"0055"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"TotalThroughput","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"link"}},{"mi":"MAX","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mrow":[{"mi":"LowEstimateBW","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"link"}},{"munder":{"mi":"MAX","mrow":{"mn":"0","mo":["<=","<="],"mi":["s","lookback"]}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"DiscountValue","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"ObservedUsage","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"s"}},"mo":",","mi":"t"}}}}}],"mo":","}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}}},"The variable lookback is a parameter to determine the length of historic time interval over which the observed usages are considered for evaluating the total throughput for a link for the current time. The variable t is the present time and variable s represents any time point between t and lookback for which observed usage was determined. The example of Discounted Value function is","DiscountValue(ObservedUsage(s),t)=ObservedUsage(s)*e. The value e is a constant. Historical values determined earlier than t-lookback time are not considered in the above equation (1) for evaluation of TotalThroughput. Specifically, equation (1) computes the TotalThroughput of a link based on all observed usage values Observed Usage over the previous time interval of size lookback.","The Observed Usage values of previous time points are weighted to reduce the influence of old values on the computation of TotalThroughput. The factor eexponentially reduces the weight of the older values. The above equation keeps the computation of TotalThroughput dynamic so that although the value of TotalThroughput is based on historical values, recent values have more significant impact on the value of TotalThroughput than older values. Accordingly, a temporary increase in observed usage will increase the TotalThroughput value but unless the increase is sustained over significant period of time or observed again, its influence on the computation of TotalThroughput is exponentially reduced over time until it is completely eliminated from the computation after lookback time interval.","Alternative embodiments may utilize other functions to reduce the weight of older observed usages, for example a linear function or non-linear functions can be used. In some embodiments, the weight of all previous observed usages considered is the same and the older observed usages get eliminated after lookback time. The equation (1) ensures that even if observed usage values reduce significantly, the value of TotalThroughput is not reduced below LowEstimateBW. In some embodiments, the value of the lookback parameter can be dynamically adjusted. The value of the lookback parameter can be manually changed by a system administrator or determined based by the allocation manager . For example, if the observed usages in the system are changing very slowly, the value of lookback can be increased, whereas if the observed usages in the system are changing more frequently, the value of lookback parameter can be reduced. In an embodiment, changes to lookback parameter can be driven by various lookback policies,' for example absolute time (e.g. lookback for a month\/quarter\/year worth of data), or\/and by the amount of data processed, e.g. lookback goes as far as needed to account for 100TB of data). These lookback policies can be either manual or automatic.","An alternative embodiment uses the following recursive equation for computing the TotalThroughput for the current time indicated by time t and the computation of TotalThroughput for a previous time s.\n\nTotalThroughput(link, )=MAX{LowEstimate(link),ObservedUsage(),TotalThroughput(link,)\u00d7)}\u2003\u2003(2)\n","For the initial time t, there is no time s before time t for which TotalThroughput value is available. The computation of TotalThroughput for time t is based on the value of LowEstimateBW for the link as follows.\n\nTotalThroughput(link,0)=LowEstimate(link) \u2003\u2003(3)\n","The equation (2) computes the TotalThroughput value for time t based on the TotalThroughput value for a previous time point weighted by an exponential factor depending on the time difference between t and s. Alternative embodiments can use a different function to determine weight applied to the previous TotalThroughput value. For example, the weight applied to the previous TotalThroughput value can be a linear function of the time difference between present time and the previous time, a non-liner function or even a constant value. Typical functions used for computing the weights applied to the TotalThroughput value of previous time points attempt at reducing the significance of previous TotalThroughput values in computation of TotalThroughput for current time point.","In another embodiment, an estimate of the true total throughput for the link, True TotalThroughput(link) is computed based on the following equation:",{"@attributes":{"id":"p-0065","num":"0064"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"TrueTotalThroughput","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"link"}},{"munder":{"mi":"MAX","mrow":{"mn":"0","mo":["<=","<="],"mi":["s","lookback"]}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"ObservedUsage","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"s"}},"mo":"\u00d7","msup":{"mi":"\u2147","mrow":{"mrow":[{"mo":"-","mi":"a"},{"mo":["(",")"],"mrow":{"mi":["t","s"],"mo":"-"}}],"mo":"\u00d7"}}}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"4"}}]}}}}},"The true total throughput value assumes the LowEstimateBW (link)=0, i.e., it ignores the effect of LowEstimateBW(link) in equation (1). Since equation (1) uses LowEstimateBW (link), if the maximum of the weighted past observed usage values is too low, the TotalThroughput(link) value obtained from equation (1) can be higher than the value computed using equation (4). The TrueTotalThroughput(link) value can be used for reporting purposes.","Periodically, the value of all allocations is increased  by a factor (called fudge factor), for example, by 10%. The increase of the allocations is intended to cause the allocations to increase and reach a true maximum value of the allocations. The additional amount of resource allocated by the fudge factor may cause the ObservedUsage for the next iteration to increase compared to the previous iteration if the increase in allocation can be consumed. If each iteration increases the allocations by the fudge factor, the TotalThroughput increases in each iteration until the aggregate needs of all consumers of the resources are satisfied or the actual maximum throughput value based on the constraints of the resources is reached. When the needs of all consumers of the resources are satisfied or the actual maximum throughput value based on the constraints of the resources is reached, the additional resources introduced by the fudge factor are not consumed. As a result the observed TotalThroughput is not increased at time t.","If the TotalThroughput value determined by increasing  the TotalThroughput by the fudge factor is determined  to be higher than an upper estimate of the stated link capacity, the TotalThroughput value is assigned  to the upper estimate of the stated link capacity. The upper estimate of the stated link capacity may be determined from the stated link capacity, for example, 90% of the stated link capacity for each link. Typical inefficiencies of any practical system disallow the system to reach stated link capacities for the available links. Therefore, the TotalThroughput value for a link is limited to a maximum value based on the upper estimate of the stated link capacity. Whether the TotalThroughput is limited to the upper estimate of the stated link capacity or determined by applying the fudge factor to the re-computed  TotalThroughput value, the allocation manager  allocates  resources to consumers based on the total throughput. Since the total throughput is increased by a predetermined factor, the consumers may receive additional resources compared to their observed usage. The allocation manager  waits  for the predetermined interval and determines  the observed usages for the link and also determines  the TotalThroughput value. Some consumers may be able to utilize the additional allocated resources whereas other consumers may not need the additional allocated resources.","It is possible that the value of TotalThroughput for an iteration is over estimated. For example, the value of TotalThroughput can be overestimated if the system is reconfigured to change the network or storage resources available or there is a significant change in the load distribution. A change in load distribution may occur, for example, if the load is switched from sequential input\/output (IO) used for analytical applications to transactional load dominated by smaller IO operations that are randomly occurring. Since TotalThroughput is determined based on historical observations, the estimated TotalThroughput value may be larger than the changed throughput value available to the resources on a link. The overestimate of the available resources may lead to additional resources being allocated to the consumers, based on phantom portion of resource that does not actually exist. However the decay of historical TotalThroughput values over time accounted for in equations (1,2) and the elimination of historical values prior to the lookback time interval causes the extra allocation of resources to reduce and get eliminated over time causing the TotalThroughput value to reach a realistic estimate. In an embodiment, a system administrator is allowed to reset the TotalThroughput value to initial default value, causing the allocation manager  to re-compute the TotalThroughput value from scratch. An embodiment allows the allocation manager  to automatically reset the TotalThroughput value to initial default value either periodically or based on detection of particular events, for example, changes in network configurations or events that indicate significant load changes, for example, addition or deletion of a production database system  from the database storage system  configuration.","Resource Guarantees","Typical consumers of resources in a system similar to the system illustrated in  may require a minimum amount of resources to operate. For example, a module acting as a consumer may be required to send a periodic message stating its status. The status signal may be required to detect system failures, for example, modules may send a signal that indicates \u201cI am alive\u201d to another module in-charge of monitoring the health of various sub-systems or modules. If no signal is received from a module or sub-system, the system  may activate procedures to detect hardware or software failures in order to take appropriate action.","There may be other reasons for guaranteeing minimum availability of resources to specific systems. For example, a virtual database manager  interacting with a virtual database system  may need minimum amount of resources to continue a meaningful mode of processing for a particular task. Although the allocation manager  allocates minimum amount of resources to specific consumers, the usage of these consumers may need to be minimized to favor higher priority consumers. In an embodiment, a survival level resource allocation may be guaranteed to each consumer process created in the system and the consumer process needs to be suspended or deleted to reclaim the survival minimum resources allocated to the consumer. Note that suspension of a consumer process only stops real time activity of this consumer (data access, network traffic, etc) and frees all resources associated\/guaranteed to this consumer but does not destroy storage of data associated with this consumer. For example, deleting a consumer process associated with a virtual database does not require deletion of the storage associated with the VDB.","In an embodiment, the survival minimum resource allocation guaranteed to a consumer is configurable by a system administrator. In another embodiment, certain default values may be assigned to different categories of consumers based on their priorities in the system.","The minimal resource guarantee for a consumer in the system  is the minimal amount of resource that is made available by the allocation manager  to the consumer. If the consumer does not need its allocated minimal resources, the leftover portions of the resources are allocated by the allocation manager to other consumers based on their priority. On the other hand, if the allocation manager  determines after allocating higher priority consumers that there are leftover resources for lower priority consumers, the allocation manager  can provide additional allocations to the lower priority consumers, over and above the guaranteed minimum allocation. In an embodiment, a system administrator is allowed also to set maximum allocation values for individual consumers. A default value for minimum allocation of consumer resources can be zero, and a default value for the maximum allocation of consumer resources can be infinity.","In an embodiment, in addition to individual guarantees, the system can be configured to have a minimum guarantee for an entire set of consumers as a group, for example, the P group  shown in . The overall minimum guarantee for the P group corresponds to an amount of resources to be distributed among P consumers, if the P consumers are able to consume the resources. If the P consumers are unable to consume all the resources allocated by group minimum guarantee, the unused resources may be allocated to other consumers. The benefit of being able to configure a minimum guarantee for a group of consumers is to prevent the group of consumers (for example, P group) from getting starved of resources by another group of consumers that has higher priority (for example, P). The value of the minimum guarantee for a group of consumers can be specified by a system administrator or predetermined to a default value, for example, zero. An embodiment automatically derives the minimum guarantee automatically based on historical data. For example, group guarantee can be set as a fixed percentage of the historically observed total group usage. Alternatively, the resource needs of the group are observed in the time periods when the workload is not dominated by the high priority consumers (unconstrained periods). Based on that resource needs of the group, the group guarantee is determined so as to always provide the group with at least 65% of its estimated total need.","The overall minimum guarantee for a group may be either set individually for each link or set globally and then distributed across links. In the later case, the embodiment does this in proportion to the group traffic on the link.",{"@attributes":{"id":"p-0076","num":"0075"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":"GroupGuarantee","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"link"}},"mo":"=","mfrac":{"mrow":[{"mi":"GroupGuarantee","mo":"\u00d7","mrow":{"mi":"GroupThroughput","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"link"}}},{"munder":{"mo":"\u2211","mrow":{"mi":["link","LINKS"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mi":"GroupThroughput","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"link"}}}]}}},{"mrow":{"mo":["(",")"],"mn":"5"}}]}}}}},"In the above equation (4), the Group Guarantee(link) is the minimum guarantee for a group, for a specific link. The GroupGuarantee is the overall minimum guarantee for the group. The GroupThroughput(link) is the total throughput of the traffic generated by the group for a specific link. The value",{"@attributes":{"id":"p-0078","num":"0077"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["link","LINKS"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mi":"GroupThroughput","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"link"}}}}},"br":{}},"GroupThroughput(link) values for all links, where LINKS is the entire set of links.","When a new guarantee value is set for a consumer, the allocation manager  may check various constraints including the following: (1) The sum of individual guarantees and survival guarantees for all the consumers in a group (for example P), does not exceed the overall guarantee for the group. (2) The sum of the individual guarantees and survival guarantees for all the consumers in a group is below the low estimate for bandwidth for the link LowEstimateBW (link) which is determined as a predetermined fraction of the stated capacity of the link. (2) The overall guarantee specified for the group is below the LowEstimateBW (link) value. If any of the above checks fails, a warning may be generated, for example, to inform the system administrator of a constraint violation related to guarantees. These checks ensure that the resources guaranteed are definitely available, for example if the overall capacity estimate is reduced. In an embodiment, the guarantees are in absolute terms, not as percentage of the estimate.","Resource Allocation",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 6","FIG. 6","FIG. 6"],"b":["1","2","1","2","1","2","2","1","2","2","1"]},"Initially, the survival guarantees of the consumers in set P are allocated . The group guarantees of the consumers of P priority group represent the amount of resources available to the consumers collectively if they can use the resources made available. The unused amount is returned to a common allocation pool. The guarantees of the consumers of P priority group are designed to protect the consumers of the lower priority P group from being starved by the consumers of the higher priority P group.","The needs of the P consumers are determined  to check  if the needs of the P consumers are below the P guarantees. The needs of a consumer are determined based on the observed usage of the consumer. In an embodiment, a consumer is given an additional margin over and above the observed usage. The addition of the margin allows identification of consumers whose needs are growing. In an embodiment, the value of the margin by which the observed usage is increased for a consumer depends on the priority and sub-priority of the consumer as shown in . The following table shows an example of margins determined based on the priority and sub-priority of a consumer.",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Priority (P)","Sub-priority (S)","Margin (%)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["P1","High","25"]},{"entry":["P1","Medium","23"]},{"entry":["P1","Low","20"]},{"entry":["P2","High","18"]},{"entry":["P2","Medium","15"]},{"entry":["P2","Low","10"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Each row of the above table shows the margin value (third column) as a percentage of increase for a consumer with priority P (first column) and sub-priority S (second column). The values shown in the above table are example values. Each system may determine different set of values by tuning the parameters appropriately. In other embodiments the margin can be a function depending on observed usage. The new usage NewUsage(C) of a consumer C is determined by increasing the observed usage ObservedUsage(C) by the margin percentage. In an embodiment, the computation of NewUsage(C) value for a particular consumer can enforce a maximum value MAX(C). The calculation is shown in the equatios (6,6a) below. The components of the formula are: the minimum individual guarantee for the consumer, the survival minimum value assigned to the consumer and projected need of the consumer with the margin. The needs of the P consumers is the total of NewUsage(C) values for all consumers of the priority group P. The margin for priority P and sub-priority S is indicated by MARGIN(P,S).\n\nNewUsage()=MAX{MinGuarantee(),MinSurvival(),ObservedUsage()\u00d7(1+MARGIN()) \u2003\u2003(6)\n\nNewUsage()=MIN{NewUsage(),Max()) \u2003\u2003(6a)\n","If P consumers needs are determined to be below the guarantees of the P consumers, first the allocations for P consumers are determined  based on their needs, followed by allocations of P consumers determined  based to their needs. Since the needs of the P consumers are known to be below their guarantees, their allocations can be determined before the allocations of P consumers. Since the P consumers are expected to consume less resources then the amount they are guaranteed they are not causing any risk to P consumers of being allocated less resources. In an embodiment, a greedy algorithm described herein is used for determining  the allocations for P consumers. The greedy algorithm sequentially allocates the resources to the different consumers, going thorough the list of the consumers in order of decreasing priority. Since the needs of the P consumers were determined  to be less than the guarantees for the P consumers, it is likely that after allocating all resources for the P and P consumers, there are leftover resources. The remaining (leftover) resources are allocated  to all the consumers. In an embodiment, the remaining resources may be allocated  proportional to the needs of the consumers. In another embodiment, the allocation  of the remaining resources may be weighted by the priority\/sub-priority of the consumer.","If the P needs are above the P guarantees, first the amount of resources equal to (TotalThroughput-PGuarantees-AllSurvivalMinimumAllocations) is allocated to P consumers  based on their needs. Since the needs of the P consumers are higher than their guarantees, it is possible that if the P consumers are allocated resources before the P consumers, there may not be sufficient resources left for P consumers. After the resources required for P consumers are determined . the remaining resources are checked  to determine if there are sufficient resources left for P consumers. If there are sufficient resources left for the P consumers, the allocations for the P consumers are determined  based on their needs, for example, based on a greedy algorithm. After allocations for P consumers are also determined , the remaining leftover resources can be allocated . If after determining  allocations for the P consumers, it is determined that the remaining resources are not sufficient for the P consumers, the resources are allocated to P consumers based on a fair share strategy described below. In this situation, it is highly likely that there are no more leftover resources. However, if any leftover resources are found, they are allocated . After the leftover resources are allocated, a fudge factor may be introduced to find the maximum capacity as described above for step  in .","Allocation Strategies",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 7","FIG. 7","FIG. 3"],"b":["2","2","2","2","710"]},"The allocation for the consumer selected  is determined . The strategy used for determining  the allocation for consumer C is different for the greedy allocation compared to the fair share allocation. For greedy allocation, the allocation for consumer C is determined to be the NewUsage(C) see formula (6). Therefore, in the greedy allocation strategy, the consumer is allocated as much as the consumer needs based on its NewUsage value which already takes into account the guarantees","In the fair share allocation strategy, the allocation for the consumer may be less than the NewUsage value determined for the consumer. First a FairShare(C) value is determined for the consumer using the equation (7) below:",{"@attributes":{"id":"p-0091","num":"0090"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"FairShare","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"C"}},{"mi":"R","mo":"\u00d7","mfrac":{"mrow":[{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"C"}},{"munder":{"mo":"\u2211","mrow":{"mi":["ci","Consumers"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"ci"}}}]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"7"}}]}}}}},"The fair share value for a consumer FairShare(C) is determined based on the fraction of resources R allocated to the consumer C compared to the total resource allocated for all consumers ci in the set Consumers of the priority group. W(c) is a weight assigned to consumer C. Weights are designed to reflect the priority and subpriority of the consumers. The allocation for consumer C is determined to be min(NewUsage(C),FairShare(C)). Therefore, the allocation of a consumer C may be limited by the FairShare(C) value computed for the consumer, even if the consumer C needs NewUsage(C) resources.","The leftover allocation  divides remaining allocations after resource allocations for all consumers have been determined based on greedy or fair share allocation strategies. Leftover allocations may not be provided to consumers that have reached their maximum allocations. In an embodiment, if the resources are determined to be lightly loaded, the leftover resources are divided equally among all consumers. The previously determined allocations of all consumers are incremented by the amount obtained by equally dividing the leftover resources among all consumers. In one embodiment the system may be determined to be lightly loaded for a link if the number of consumers using the link is low and the observed usages of consumers using the link is also determined to be low. For example, the system may be considered lightly loaded for a link if there are fewer than 50 consumers using the link and the overall observed usage of the link is less than a quarter of the stated link capacity.","If the lightly loaded conditions are not met, the resources are divided between consumers in proportion of usage and weight of the consumers. The weight associated with a consumer is based on priority preferences, for example, the weight may be determined based on the priority and sub-priority associated with the consumer. The following equation shows how the share Share(C) of a consumer C is determined for leftover resources R.",{"@attributes":{"id":"p-0095","num":"0094"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"Share","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"C"}},{"mi":"R","mo":"\u00d7","mfrac":{"mrow":[{"mi":"W","mo":["\u2062","\u00d7"],"mrow":[{"mo":["(",")"],"mi":"C"},{"mi":"NewUsage","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"C"}}]},{"munder":{"mo":"\u2211","mrow":{"mi":["ci","Consumers"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"ci"}},{"mi":"NewUsage","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"ci"}}],"mo":"\u00d7"}}]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"8"}}]}}}}},"The share of a consumer Share (C) of the remaining resource R is determined based on the weighted fraction of the usage of consumer C compared to the weighted usage for all consumers ci in the set Consumers of the priority group. Based on the equation (8) above, the total of all Share(C) for all consumers adds up to the remaining total resource. Shares of consumers with the same usage are proportional to weights determined by their priorities and sub-priorities. Furthermore, shares of consumers within the same priority\/sub-priority groups are proportional to their usage. The allocations of resources for consumers determined previously are updated by adding the corresponding Share(C) value to each allocation. If the resulting value exceeds the maximum limit configured for the consumer, the allocation is limited to the maximum limit. Based on the above updates to allocations, the value of remaining resources is computed again. If for any reason there are still remaining resources, the above allocation can be repeated.","Metrics for Reporting","In an embodiment, an unhappiness index is determined by the metrics manager  as a measure of potential of starvation for a particular consumer. The metric is based on the fraction of a time interval during which the usage of the consumer exceeds a predetermined percentage of allocation, for example, 85% of allocation. In an embodiment, the unhappiness index is measures over a fixed time window, for example, 24 hours. During the fixed time window, there can be several allocation runs during which the allocation manager  re-computes the allocations for the next time interval. The time interval between two allocation runs is called an allocation interval and corresponds to the time during which the previous allocation was enforced.","The unhappiness index is determined as the sum of all allocation intervals ti within the time window TWINDOW when the usage of consumer C usage (C,ti) was greater than N % divided by the size of the TWINDOW. In an embodiment, N=85%. Equation (9) below shows the computation of the unhappiness index for a consumer C during the time window Unhappiness(C,TWINDOW).",{"@attributes":{"id":"p-0099","num":"0098"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":"Unhappiness","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["C","TWINDOW"],"mo":","}}},"mo":"=","mfrac":{"mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["ti","TWINDOW"],"mo":"\u2208"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"if","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"usage","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["C","ti"],"mo":","}}},{"mi":["N","%"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}],"mo":">"}}},{"mi":"THEN","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"ti"}},{"mi":"ELSE","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"0"}}],"mo":["\u2062","\u2062"]}},"mi":"TWINDOW"}}},{"mrow":{"mo":["(",")"],"mn":"9"}}]}}}}},"The summation in the numerator of (9) adds the time interval ti when the usage of consumer C during ti, usage(C,ti) is greater than N %. The denominator of equation (9) adds all the time intervals ti within the window TWINDOW thereby providing the time of the entire time window TWINDOW. In an embodiment, the consumers are ordered in decreasing order of their unhappiness index to obtain their unhappiness rank. The unhappiness tank and unhappiness index of the consumers may be reported by the metrics manager  to a system administrator, for example, via a user interface . The system administrator may decide to change the priority or sub-priority of the consumer based on the unhappiness index combined with other criteria for example, the type of the task. In an embodiment, the metrics manager  may provide the information regarding unhappiness of consumers to allow the allocation manager to make automatic adjustments to the priority or sub-priority of the consumers. In an embodiment, the unhappiness measure of a consumer is used for automatic adjustment of priority\/sub-priority of the consumer. For example, if a consumer is unhappy most of the time, the consumer may be automatically promoted to a higher priority.","Computing Machine Architecture",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 8","FIG. 8"],"b":["800","824"]},"The machine may be a server computer, a client computer, a personal computer (PC), a tablet PC, a set-top box (STB), a personal digital assistant (PDA), a cellular telephone, a smartphone, a web appliance, a network router, switch or bridge, or any machine capable of executing instructions  (sequential or otherwise) that specify actions to be taken by that machine. Further, while only a single machine is illustrated, the term \u201cmachine\u201d shall also be taken to include any collection of machines that individually or jointly execute instructions  to perform any one or more of the methodologies discussed herein.","The example computer system  includes a processor  (e.g., a central processing unit (CPU), a graphics processing unit (GPU), a digital signal processor (DSP), one or more application specific integrated circuits (ASICs), one or more radio-frequency integrated circuits (RFICs), or any combination of these), a main memory , and a static memory , which are configured to communicate with each other via a bus . The computer system  may further include graphics display unit  (e.g., a plasma display panel (PDP), a liquid crystal display (LCD), a projector, or a cathode ray tube (CRT)). The computer system  may also include alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse, a trackball, a joystick, a motion sensor, or other pointing instrument), a storage unit , a signal generation device  (e.g., a speaker), and a network interface device , which also are configured to communicate via the bus .","The storage unit  includes a machine-readable medium  on which is stored instructions  (e.g., software) embodying any one or more of the methodologies or functions described herein. The instructions  (e.g., software) may also reside, completely or at least partially, within the main memory  or within the processor  (e.g., within a processor's cache memory) during execution thereof by the computer system , the main memory  and the processor  also constituting machine-readable media. The instructions  (e.g., software) may be transmitted or received over a network  via the network interface device .","While machine-readable medium  is shown in an example embodiment to be a single medium, the term \u201cmachine-readable medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, or associated caches and servers) able to store instructions (e.g., instructions ). The term \u201cmachine-readable medium\u201d shall also be taken to include any medium that is capable of storing instructions (e.g., instructions ) for execution by the machine and that cause the machine to perform any one or more of the methodologies disclosed herein. The term \u201cmachine-readable medium\u201d includes, but not be limited to, data repositories in the form of solid-state memories, optical media, and magnetic media.","Additional Configuration Considerations","Throughout this specification, plural instances may implement components, operations, or structures described as a single instance. Although individual operations of one or more methods are illustrated and described as separate operations, one or more of the individual operations may be performed concurrently, and nothing requires that the operations be performed in the order illustrated. Structures and functionality presented as separate components in example configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements fall within the scope of the subject matter herein.","Certain embodiments are described herein as including logic or a number of components, modules, or mechanisms. Modules may constitute either software modules (e.g., code embodied on a machine-readable medium or in a transmission signal) or hardware modules. A hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments, one or more computer systems (e.g., a standalone, client or server computer system) or one or more hardware modules of a computer system (e.g., a processor or a group of processors) may be configured by software (e.g., an application or application portion) as a hardware module that operates to perform certain operations as described herein.","In various embodiments, a hardware module may be implemented mechanically or electronically. For example, a hardware module may comprise dedicated circuitry or logic that is permanently configured (e.g., as a special-purpose processor, such as a field programmable gate array (FPGA) or an application-specific integrated circuit (ASIC)) to perform certain operations. A hardware module may also comprise programmable logic or circuitry (e.g., as encompassed within a general-purpose processor or other programmable processor) that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically, in dedicated and permanently configured circuitry, or in temporarily configured circuitry (e.g., configured by software) may be driven by cost and time considerations.","Accordingly, the term \u201chardware module\u201d should be understood to encompass a tangible entity, be that an entity that is physically constructed, permanently configured (e.g., hardwired), or temporarily configured (e.g., programmed) to operate in a certain manner or to perform certain operations described herein. As used herein, \u201chardware-implemented module\u201d refers to a hardware module. Considering embodiments in which hardware modules are temporarily configured (e.g., programmed), each of the hardware modules need not be configured or instantiated at any one instance in time. For example, where the hardware modules comprise a general-purpose processor configured using software, the general-purpose processor may be configured as respective different hardware modules at different times. Software may accordingly configure a processor, for example, to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.","Hardware modules can provide information to, and receive information from, other hardware modules. Accordingly, the described hardware modules may be regarded as being communicatively coupled. Where multiple of such hardware modules exist contemporaneously, communications may be achieved through signal transmission (e.g., over appropriate circuits and buses) that connect the hardware modules. In embodiments in which multiple hardware modules are configured or instantiated at different times, communications between such hardware modules may be achieved, for example, through the storage and retrieval of information in memory structures to which the multiple hardware modules have access. For example, one hardware module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware module may then, at a later time, access the memory device to retrieve and process the stored output. Hardware modules may also initiate communications with input or output devices, and can operate on a resource (e.g., a collection of information).","The various operations of example methods described herein may be performed, at least partially, by one or more processors that are temporarily configured (e.g., by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors may constitute processor-implemented modules that operate to perform one or more operations or functions. The modules referred to herein may, in some example embodiments, comprise processor-implemented modules.","Similarly, the methods described herein may be at least partially processor-implemented. For example, at least some of the operations of a method may be performed by one or processors or processor-implemented hardware modules. The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the processor or processors may be located in a single location (e.g., within a home environment, an office environment or as a server farm), while in other embodiments the processors may be distributed across a number of locations.","The one or more processors may also operate to support performance of the relevant operations in a \u201ccloud computing\u201d environment or as a \u201csoftware as a service\u201d (SaaS). For example, at least some of the operations may be performed by a group of computers (as examples of machines including processors), these operations being accessible via a network (e.g., the Internet) and via one or more appropriate interfaces (e.g., application program interfaces (APIs).)","The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the one or more processors or processor-implemented modules may be located in a single geographic location (e.g., within a home environment, an office environment, or a server farm). In other example embodiments, the one or more processors or processor-implemented modules may be distributed across a number of geographic locations.","Some portions of this specification are presented in terms of algorithms or symbolic representations of operations on data stored as bits or binary digital signals within a machine memory (e.g., a computer memory). These algorithms or symbolic representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. As used herein, an \u201calgorithm\u201d is a self-consistent sequence of operations or similar processing leading to a desired result. In this context, algorithms and operations involve physical manipulation of physical quantities. Typically, but not necessarily, such quantities may take the form of electrical, magnetic, or optical signals capable of being stored, accessed, transferred, combined, compared, or otherwise manipulated by a machine. It is convenient at times, principally for reasons of common usage, to refer to these signals using words such as \u201cdata,\u201d \u201ccontent,\u201d \u201cbits,\u201d \u201cvalues,\u201d \u201celements,\u201d \u201csymbols,\u201d \u201ccharacters,\u201d \u201cterms,\u201d \u201cnumbers,\u201d \u201cnumerals,\u201d or the like. These words, however, are merely convenient labels and are to be associated with appropriate physical quantities.","Unless specifically stated otherwise, discussions herein using words such as \u201cprocessing,\u201d \u201ccomputing,\u201d \u201ccalculating,\u201d \u201cdetermining,\u201d \u201cpresenting,\u201d \u201cdisplaying,\u201d or the like may refer to actions or processes of a machine (e.g., a computer) that manipulates or transforms data represented as physical (e.g., electronic, magnetic, or optical) quantities within one or more memories (e.g., volatile memory, non-volatile memory, or a combination thereof), registers, or other machine components that receive, store, transmit, or display information.","As used herein any reference to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular element, feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment.","Some embodiments may be described using the expression \u201ccoupled\u201d and \u201cconnected\u201d along with their derivatives. It should be understood that these terms are not intended as synonyms for each other. For example, some embodiments may be described using the term \u201cconnected\u201d to indicate that two or more elements are in direct physical or electrical contact with each other. In another example, some embodiments may be described using the term \u201ccoupled\u201d to indicate that two or more elements are in direct physical or electrical contact. The term \u201ccoupled,\u201d however, may also mean that two or more elements are not in direct contact with each other, but yet still cooperate or interact with each other. The embodiments are not limited in this context.","As used herein, the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes,\u201d \u201cincluding,\u201d \u201chas,\u201d \u201chaving\u201d or any other variation thereof, are intended to cover a non-exclusive inclusion. For example, a process, method, article, or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process, method, article, or apparatus. Further, unless expressly stated to the contrary, \u201cor\u201d refers to an inclusive or and not to an exclusive or. For example, a condition A or B is satisfied by any one of the following: A is true (or present) and B is false (or not present), A is false (or not present) and B is true (or present), and both A and B are true (or present).","In addition, use of the \u201ca\u201d or \u201can\u201d are employed to describe elements and components of the embodiments herein. This is done merely for convenience and to give a general sense of the invention. This description should be read to include one or at least one and the singular also includes the plural unless it is obvious that it is meant otherwise.","Upon reading this disclosure, those of skill in the art will appreciate still additional alternative structural and functional designs for a system and a process for creating virtual databases from point-in-time copies of production databases stored in a storage manager. Thus, while particular embodiments and applications have been illustrated and described, it is to be understood that the disclosed embodiments are not limited to the precise construction and components disclosed herein. Various modifications, changes and variations, which will be apparent to those skilled in the art, may be made in the arrangement, operation and details of the method and apparatus disclosed herein without departing from the spirit and scope defined in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
