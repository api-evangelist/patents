---
title: Framework for generating programs to process beacons
abstract: In one embodiment, a method receives an object model determined from a specification for processing beacons. The method determines first information for a beacon object referenced in a basefact object to determine which beacon objects are applicable for the basefact object. Second information is determined for the structured data fields referenced in the basefact object to determine which output fields map to which structured data fields and third information is determined for a set of transformations for a set of input fields in the set of composite objects for the beacon to determine how to perform transformations to transform the set of input fields to the set of output fields. The method then generates instructions for a target program to process the beacons to transform the set of input fields to the set of output fields and map the set of output fields to the structured data fields.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09305032&OS=09305032&RS=09305032
owner: HULU, LLC
number: 09305032
owner_city: Santa Monica
owner_country: US
publication_date: 20140327
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation of U.S. patent application Ser. No. 13\/660,788 filed Oct. 25, 2012 and entitled \u201cFramework for Generating Programs to Process Beacons\u201d, which is incorporated by reference in its entirety for all purposes.","Companies provide services that users access using client devices. For example, a user may view a video in a media player. The companies often seek to improve their service by analyzing events that occur while the users are using their client devices. For example, while viewing the video, the user performs different actions, such as seeking to different times in the video, stopping the video, hovering over icons, etc. Web requests are generated to document the actions taken at the client devices (also referred to as \u201cbeacons\u201d). For example, when a user's browser requests information from a website, a server may aggregate information, such as the IP address of the computer being used; the time the material was viewed; the type of browser that was used, the type of action taken by the user, etc. The beacons are logged and aggregated for the company.","The beacons include information that is in an unstructured format. The unstructured format is not in a pre-defined data model that a company can easily store in a structured database. For example, many analysis applications are keyed to retrieve data in fields in a structured database. The beacons do not include data that can easily be stored in the correct fields. Thus, if a company is going to analyze the information in the beacons, the company needs to transform the unstructured data into structured data. The structured data organizes the data in a format desired by the company where the company can then analyze the structured data.","Programs need to be written to perform the transformation of the unstructured data of the beacons into structured data. However, each type of beacon has different types of information. Thus, for each type of beacon that the company wants to analyze, a programmer needs to write a program to transform the unstructured data for the beacon to the desired type of structured data. Writing the programs to perform these transformations may be a tedious process. Also, having to write code for the programs limits the number of users that can write the programs because most users are not programmers.","In one embodiment, a method receives an object model including objects determined from a specification for processing beacons where a beacon is associated with an event occurring at a client while a user is interacting with an application and includes unstructured data. The method determines first information for a beacon object referenced in a basefact object to determine which beacon objects are applicable for the basefact object. The beacon object includes a set of field objects that identify a set of composite objects for the beacon object, and the basefact object includes a set of structured data objects that identify the set of output fields in a composite object to map to a set of structured data fields. Second information is determined for the set of structured data fields referenced in the basefact object to determine which output fields map to which structured data fields and third information is determined for a set of transformations for a set of input fields in the set of composite objects for the beacon to determine how to perform transformations to transform the set of input fields to the set of output fields. The method then generates instructions for a target program to process the beacons using the first information, the second information, and the third information to transform the set of input fields to the set of output fields and map the set of output fields to the set of structured data fields.","In one embodiment, an apparatus includes: one or more computer processors; and a computer-readable storage medium comprising instructions, that when executed, control the one or more computer processors to be configured for: receiving an object model including objects determined from a specification for processing beacons, a beacon being associated with an event occurring at a client while a user is interacting with an application and including unstructured data; determining first information for a beacon object referenced in a basefact object to determine which beacon objects are applicable for the basefact object, wherein the beacon object includes a set of field objects that identify a set of composite objects for the beacon object, and the basefact object includes a set of structured data objects that identify the set of output fields in a composite object to map to a set of structured data fields; determining second information for the set of structured data fields referenced in the basefact object to determine which output fields map to which structured data fields; determining third information for a set of transformations for a set of input fields in the set of composite objects for the beacon to determine how to perform transformations to transform the set of input fields to the set of output fields; and generating instructions for a target program to process the beacons using the first information, the second information, and the third information to transform the set of input fields to the set of output fields and map the set of output fields to the set of structured data fields.","In one embodiment, a non-transitory computer-readable storage medium contains instructions, that when executed, control a computer system to be configured for: receiving an object model including objects determined from a specification for processing beacons, a beacon being associated with an event occurring at a client while a user is interacting with an application and including unstructured data; determining first information for a beacon object referenced in a basefact object to determine which beacon objects are applicable for the basefact object, wherein the beacon object includes a set of field objects that identify a set of composite objects for the beacon object, and the basefact object includes a set of structured data objects that identify the set of output fields in a composite object to map to a set of structured data fields; determining second information for the set of structured data fields referenced in the basefact object to determine which output fields map to which structured data fields; determining third information for a set of transformations for a set of input fields in the set of composite objects for the beacon to determine how to perform transformations to transform the set of input fields to the set of output fields; and generating instructions for a target program to process the beacons using the first information, the second information, and the third information to transform the set of input fields to the set of output fields and map the set of output fields to the set of structured data fields.","The following detailed description and accompanying drawings provide a better understanding of the nature and advantages of particular embodiments.","Described herein are techniques for a framework for processing beacons. In the following description, for purposes of explanation, numerous examples and specific details are set forth in order to provide a thorough understanding of particular embodiments. Particular embodiments as defined by the claims may include some or all of the features in these examples alone or in combination with other features described below, and may further include modifications and equivalents of the features and concepts described herein.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","100","102","104","106","108","102"]},"Users interact with clients  to produce events. For example, users may interact with websites on the worldwide web (WWW), such as through mouse clicks, hovering over objects, and other user interactions with web pages. Beacons are created based on the events and include information for the actions taken by the users and may also include other metadata about the event. For example, the metadata may include user identification information, what platform (e.g., device type or operating system) is being used, what application is being used, etc. The beacons may be unstructured data. Also, different clients  and different web sites may generate beacons in different formats.","A server  receives and stores the beacons for later processing. In one example, server  may aggregate beacons from multiple network devices. Also, server  may be a distributed system of servers that are storing the beacons. In this example, server  stores the beacons, but other storage devices may store the beacons.","In one example, target programs  may be executed to process the beacons. When executed, target programs  may determine beacons that are of interest and then transform the unstructured data of the beacons into structured data that can be used by a company. For example, different target programs  may be interested in different types of beacons. Each target program  would identify the applicable beacons. Then, target programs  transform the unstructured data into structured data. The structured data may be stored in a database for later querying, such as to generate reports.","Conventionally, users would have to write target programs  for each type of beacon that a company wanted to process. However, particular embodiments automatically generate target programs . For example, as will be described in more detail below, compiler  receives a specification and uses the specification to automatically generate a target program . Using the specification allows users to declaratively specify what beacons are of interest and what structured data is desired. Compiler  then generates target programs  that can process the beacons and perform the desired transformations from unstructured data to structured data. By using the specification to declare what is wanted, users do not have to write a program that is used to process the beacons. This may allow more users to specify how to process beacons.","The process of generating a target program  from a specification will now be described in more detail.  shows a more detailed example of compiler  according to one embodiment. Specifications  may be written using a specific grammar that declares what beacons are of interest and what structured data is desired. Users may write different specifications  to generate different structured data from different beacons.","In one embodiment, an abstract syntax tree generator  first converts specifications  into abstract syntax trees . The abstract syntax tree is an abstract way of representing the syntax of different specifications . In one embodiment, an abstract syntax tree is a tree representation of the syntactic structure of the input program. The syntax tree is built through the use of a parser, which produces a tree representation of the input program based on a grammar specification.","An object model generator  uses the abstract syntax trees to generate object models . Object models  convert nodes of the abstract syntax tree into objects that are in the object model. The object model is used such that generators  can be written to read a specific format defined in the object model. This allows generators  to be reused to process different specifications . Because beacons may have similar formats of data, specifications  may be written and parsed into object models . Thus, to process different types of beacons, object models  with different objects may be generated, but the same generators  may be used. Also, even though the information that is being transformed from unstructured data to structured data may be different, the same generator  may be used because each generator  is configured to parse the same format of an object model . In one embodiment, the object model is a simplified and generalized view of the input specification based on the abstract syntax tree. The object model is generated by passing over the abstract syntax tree multiple times. Specification correctness checks may be performed (semantic analysis), symbols may be resolved (e.g., various references that must be resolved and disambiguated), and a simplified structure is created (called the object model) so that generators  can be written more concisely.","Object models  are in a format that can be read by different generators ---N. Each generator ---N may generate target programs #1-N, respectively. For example, some generators  may generate MapReduce source code, structured query language (SQL) queries, representational state transfer (REST) requests, HTML documentation, and other target programs. Each generator  may be written to process the formats of object models  and thus multiple generators  do not need to be written for different specifications . That is, if MapReduce code is desired, the same MapReduce generator  is used for multiple specifications . The objects in object model  may change, but the same generator  may be used.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3","b":["106","302","108","202","202","202","108","108","108"]},"At , compiler  parses specification  into an abstract syntax tree . The abstract syntax tree organizes the elements of specification  into a tree structure.","At , compiler  converts abstract syntax tree  into an object model . For example compiler  parses nodes of abstract syntax tree  to generate object model . Object model  organizes specification  into objects.","At , compiler  determines a generator  for a target program . For example, compiler  may receive a user selection of a generator . The selected generator  is configured to produce a specific type of target program .","At , compiler  generates target program  for generator  based on object model . To illustrate the above process of generating target program  from specification , an example specification  will be described.  shows a specification  according to one embodiment. Specification  produces a target program  to convert a video ID to a video name, transform a browser name for the browser used to play a video to a browser name, and count the number of times the video was played. It should be noted that specification  may not be a complete specification and has parts redacted, such as when a \u201c . . . \u201d is shown.","Specification  includes three sections of \u201ccomposite\u201d, \u201cbeacon\u201d, and \u201cbasefact\u201d. A composite defines what is in the beacon, such as the raw data that is in the beacon, and how to transform the raw data in the beacon. At , three composite objects of \u201cVideo\u201d, \u201cBrowser\u201d, and \u201cCount\u201d are shown. Composites may have any number of input fields and one or more output fields. At , the Video composite object has an input parameter object named \u201cvideo_id\u201d. This is what the beacon parameter name is in a raw log line. For example, the unstructured data may include the term \u201cvideo_id\u201d. At , the Video composite object includes an output field object called \u201cvideo_name\u201d. This is the field name after video_id is transformed. At , a mapper object for \u201cMapReduceJob\u201d includes transformational logic for the output field object video_name. The mapper object includes details for performing the transformation that is specified in the mapper definition located at conversionMethod. Additional mappers may also be included in a composite object that may perform other transformations. At , other composite objects of \u201cBrowser\u201d and \u201cCount\u201d are included. Details have not been provided, but would be similar to those found in the Video composite object. It will be understood that specification  may include any number of composite objects . For example, specification  may include additional composite objects (not shown) that may be used by other beacon objects.","At , a beacon object is identified as \u201cplayback_start\u201d and uniquely identifies the beacon within specification . Because specification  may include multiple composite objects, the beacon object identifies which composite objects are part of this beacon object. At , the beacon includes three field objects: \u201cselected_video\u201d, which references the Video composite object; \u201cuser_browser\u201d, which references the Browser composite object; and \u201ccount\u201d, which references the Count composite object. The field objects are used to refer back to composite objects.","At , specification  defines a basefact object of \u201cstart_by_video_and_browser\u201d. The basefact object is used to define what structured data is desired and what unstructured data should be used to populate the structured data. The basefact object may use multiple basefacts objects. For example, this basefact object uses the \u201cplayback_start\u201d beacon object to determine applicable data. That is, this basefact ignores all other beacon objects that are not named \u201cplayback_start\u201d in specification . At , the basefact object includes three structured data field objects for the \u201cplayback_start\u201d beacon. The structured data fields may be different types, such as dimension or fact fields. A dimension maps a field in the beacon to a structured data field. A fact may perform a function (e.g., an aggregation function) on a field in the beacon to determine a result that is mapped to a structured data field.","A first structured data field of \u201cvideoName\u201d is defined as a dimension of the video_name field object in the composite object referenced by the selected_video field object in the beacon object and a second structured data field of \u201cbrowserName\u201d is defined as a dimension from the name field object in the composite object referenced by the user_browser field object in the beacon object. A third structured data field of \u201ctotalCount\u201d is defined as a fact that is the aggregation of the count field object in the composite object referenced by the count field object in the beacon object.","Once receiving specification , compiler  selects a generator  that is used to generate a target program . As discussed above, compiler  converts specification  into object model . Generator  takes object model  and generates code in a software language that is used to process beacons. In one embodiment, compiler  generates MapReduce job code as a target program . Target program  is configured to receive unstructured data, such as raw web event log lines, and generate structured data specified by the starts_by_video_and_browser basefact definition. That is, transformed data from the beacons is stored in structured data fields of videoName, browserName, and totalCount.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 5","b":["208","106","502","208","202","208","106"]},"The structured data field objects in the basefact object point to field objects in the beacon object at . For example, selected_video, user_browser, and count are referenced in both the basefact and the beacon objects. To determine which composite objects these structured data field objects are associated with, at , the field objects in the beacon object are associated with composite objects.","Generator  then uses the referenced composite objects from the beacon object to generate instructions on how to map unstructured data to structured data. For example, generator  generates instructions on how to tokenize (breaking the text of the beacon into words or phrases) and transform raw web log data to structured data. For example, at , the basefact object defines the structured data by the terms videoName, browserName, and totalCount, which are structured data fields that can be defined in a database. The transformations for the field objects in the basefact object are specified in the composite object that each beacon field object references as was discussed with respect to . Also, for the fact field object, generator  generates instructions to aggregate rows based on the count composite object.","Generator  then outputs the final software code that is compiled into target program . Target program  can then be used to process beacons and produce the transformed data as specified in the basefact definition.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 6","b":["106","208","106","202","206","602","604","202","606","202"]},"At , the term \u201cplayback_start\u201d is based on which beacons were defined by specification . In this case, only events defined by playback_start beacons are reviewed. At , the conversion found in the composite Video is found, and at , the conversion found in the composite Browser is found. Further, at , the functions \u201cIdentity<Long>( )\u201d and \u201cStaticInputAction<Long>(1L)\u201d are determined based on the fact \u201csum\u201d in the basefact in specification . The above information is determined by reviewing object model  to generate the target program .","Accordingly, compiler  generates target program , which can map unstructured data to structured data. A user can declare the structured data that was desired and the transformations needed to transform unstructured data to structured data. Compiler  then generates the software code to perform the desired transformations. A user thus does not need to write software code for target program .","Further, particular embodiments leverage object model  that allows different generators  to operate on the object model. Thus, different specifications  may be parsed into an object model  that can be operated on by the same generators .","Particular embodiments may be implemented in a non-transitory computer-readable storage medium for use by or in connection with the instruction execution system, apparatus, system, or machine. The computer-readable storage medium contains instructions for controlling a computer system to perform a method described by particular embodiments. The instructions, when executed by one or more computer processors, may be operable to perform that which is described in particular embodiments.","As used in the description herein and throughout the claims that follow, \u201ca\u201d, \u201can\u201d, and \u201cthe\u201d includes plural references unless the context clearly dictates otherwise. Also, as used in the description herein and throughout the claims that follow, the meaning of \u201cin\u201d includes \u201cin\u201d and \u201con\u201d unless the context clearly dictates otherwise.","The above description illustrates various embodiments along with examples of how aspects of particular embodiments may be implemented. The above examples and embodiments should not be deemed to be the only embodiments, and are presented to illustrate the flexibility and advantages of particular embodiments as defined by the following claims. Based on the above disclosure and the following claims, other arrangements, embodiments, implementations and equivalents may be employed without departing from the scope hereof as defined by the claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
