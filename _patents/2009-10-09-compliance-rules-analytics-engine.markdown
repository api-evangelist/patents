---
title: Compliance rules analytics engine
abstract: The present invention relates to compliance rules analytics systems and methods for facilitating compliance, such as the compliance of an investment portfolio or a set of investment portfolios, with a rule or a set of rules.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08108422&OS=08108422&RS=08108422
owner: Taiwan Semiconductor Manufacturing Company, Ltd.
number: 08108422
owner_city: Hsin-Chu
owner_country: TW
publication_date: 20091009
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","REFERENCE TO A COMPUTER PROGRAM LISTING APPENDIX SUBMITTED ON A COMPACT DISC","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","EXAMPLE","EXAMPLE"],"p":["This application is a continuation of now-pending application Ser. No. 11\/253,273, filed Oct. 18, 2005, which claims the benefit of Provisional Application Ser. No. 60\/654,667, filed Feb. 18, 2005, both of which are hereby incorporated by reference in their entirety.","Applicants hereby submit computer program listings on a compact disc, 2 copies (Copy 1 and Copy 2) of which are submitted herewith. Each copy of the CD contains a master folder entitled \u201cMacgregor_Tabet_CD_Contents\u201d having a size of 33 MB and having been created on Oct. 10, 2005. The master folder contains a folder entitled XIPWS, having a size of 33 MB and having been created on Oct. 10, 2005. The XIPWS folder contains the following folders: a \u201c3party\u201d folder having a size of 1.33 KB, an \u201cApp\u201d folder having a size of 403 KB, and a \u201cCommon\u201d folder having a size of 32.6 MB, each of the folders having been created on Oct. 10, 2005 and each of the folders and all of the files contained in those folders, and on the CD, being incorporated herein by reference in their entirety. A complete listing of all files contained on each copy of the CD, their date of creation, and the size of each of those files is attached as Appendix I.","The present invention relates to rule-based systems, e.g., portfolio compliance rule-based systems. Portfolio compliance is a unique challenge because it requires maintenance of potentially millions of aggregations with fast impact analysis of any proposed transaction set. An aggregation is a combination of positions, e.g., positions owned or controlled by a single trader or group of traders, that one can use to ensure compliance with rules such as regulations. A position is the amount of a security either owned (which constitutes a long position) or borrowed (which constitutes a short position).","Because the mapping between proposed transaction sets and a set of affected aggregations is not explicit, a compliance architecture must support an efficient matching, calculation and identification of affected aggregations to provide fast impact analysis and explicit reporting. The mapping is not explicit because the aggregations and the proposed transaction sets are both dynamic, e.g., changing over time. Many of these aggregations are comprised of hundreds or thousands of data values across a variety of data structures and sources.","Investment activity in large firms involves tens of thousands of daily transactions affecting a variety of aggregations. The requirement for effective pre-trade compliance is to quickly identify the impact of each set of transactions without adding delays to the investment process.","Conventional systems have not achieved comprehensive real-time scalable portfolio compliance. Only a small percentage of the portfolio compliance rules (typically less than about 10%) are evaluated in real-time. The large majority of compliance rules are checked only in a post-trade (post-mortem) basis. Such post-mortem checking means that violations are only detected after the fact and millions of dollars are put at risk or wasted in preventable errors. The primary impediment to implementing preventive measures is that current solutions do not provide the performance level and scalability needed to evaluate the status of portfolio compliance as part of real-time investment processes. Moreover, the business challenge is getting worse since most organizations have to deal with increasing volumes. Industry trends towards separately managed accounts and increased market regulation will continue to raise the performance thresholds that compliance solutions need to clear before they can be practically integrated into real-time investment processes.","From a technology perspective, existing devices are based on non-scalable and mostly stateful designs. In addition, prior methods typically restrict their choice of technologies to a small set of programming models. Typically portfolio compliance systems are built on procedural language frameworks (like C++) combined with relational database management systems. These systems do not achieve, and thus a need remains for, practical real-time scalable portfolio compliance.","The present invention relates to rule-based systems and methods, e.g., rule-based systems and methods for achieving portfolio compliance. One embodiment of the invention provides a compliance rules analytics system including: a rule editor operative to receive rule-related data and to convert the rule-related data into intermediate format data; a rule translator in communication with the rule editor and operative to receive the intermediate format data and operative to translate the intermediate format data into executable format data; and a compliance analytics engine (CAE) in communication with the rule translator and operative to receive the executable format data and to perform a compliance evaluation based at least in part on the executable format data, the evaluation being performed using, at least in part, a RETE-based process.","In one embodiment, the CAE includes: compliance services operative to receive a check compliance message from a request queue; a rules engine in communication with the compliance services and operative to receive a do-inference message from the compliance services and to execute executable format rule-related data; and business objects in communication with the rules engine. The business objects include: a data sensor in communication with the rules engine and operative to receive a get static data request from the rules engine and to return static data to the rules.net engine; and an aggregate sensor in communication with the rules engine and operative to receive a get aggregation data request from the rules engine and to return aggregation data to the rules engine.","Another embodiment of the invention provides a method for performing a compliance evaluation. The method includes: receiving rule-related data for portfolio compliance rules; obtaining aggregation data from an online analytic processing component; and performing a portfolio compliance evaluation based at least in part on the rule-related data and the aggregation data, the evaluation being performed using, at least in part, a RETE-based process.","Yet another embodiment of the invention provides a compliance rules analytics system including: rule editor means for receiving rule-related data and converting the rule-related-data into intermediate format data; rule translator (RT) means in communication with the rule editor means, the RT means for receiving the intermediate format data and for translating the intermediate format data into executable format data; and compliance analytics engine (CAE) means in communication with the RT means, the CAE means for receiving the executable format data and for performing a compliance evaluation based at least in part on the executable format data, the evaluation being performed using, at least in part, a RETE-based process.","The present invention relates to rule-based systems, e.g., such as rule-based systems for ensuring portfolio compliance.  is a deployment diagram for one embodiment of a system  according to the invention. With reference to , the illustrated embodiment includes a web server application server  coupled to a database server  having data sources . The application server  has a business logic layer  that includes business services components  and business package components . The business services components include rules management services , compliance services , rules engine services , application service , and exception management services . Similarly, the business package components include a rules management package , a compliance package , a rules engine package , an application package , and an exception management package .","The application server  also has data access components  including business objects (BO) data access interface  and data access components (DAC) . The Data Access Components (DAC) are a set of components implementing data access functions in a data access layer (DAL). The DAL exposes the data stored in databases to the business logic layer (shown as element  in ). The Business Objects abstract domain objects (domain data) from specific database technologies (platforms). In addition, the application server  has a session management component , a repository component , and a messaging services component .","The application server  also has presentation layer server side components  including a Push to Browser (PTB) server  and a page manager . The application server  interfaces with a client PC . The client PC  has presentation layer client side components  including view components , controller components  and a fa\u00e7ade . The fa\u00e7ade  interfaces with the business logic layer  and the controller components  interface with the presentation layer server side components .","In other words, with reference to , The Web Application Server  interacts with the database server  and its data sources . It also communicates with the client  and presentation layer components . The Web Application Server components include session management , a repository , messaging services , the presentation layer server side components , the business logic layer  and finally the data access components . The business logic layer has two sets of components: Business Services Components  and Business Package Components . The Business Logic Layer communicates directly with the client layer and interfaces with the Data Access Components. While the Business Services Components provide a web services interface to the business logic, Business Package components are the components that implement the actual business logic. The Business Package components have a one to one relationship to the business services provided by the system. Each package may access functionality implemented in other packages and reuse those implementations.","In operation, the presentation layer client side  components implement the user interface functionality such as viewing account data, rules, and compliance results. These components interface with presentation layer server-side  and allow the PTB Server  to push data from the server to the web client page and allow the page manager  to manage of page layouts. Session Management  and Messaging Services  are conventional application server infrastructure components. The Business logic layer  interfaces with the client side presentation layer. Its main function is to provide components implementing the application business logic. In one embodiment, the system aggregates Business Services  and Business Packages  in order to provide business logic for portfolio compliance clients. A business service is a standard web service and is coupled to a single business package. A business package implements specific functionality (application business logic such as check compliance, generate reports, and persist exception violations). In one embodiment, a business package is based on conventional .NET enterprise service technology available from Microsoft Corporation of Redmond Wash. Business logic layer interfaces with data access components  which encapsulate all data access logic. The Data Server component  is a conventional database server (MS SQL Server for example)","With reference to , one embodiment of the component structure for the system of  includes business logic (BL) compliance components  in communication with data access components  (also shown in ). The data access components  are, in turn, in communication with data server  (also shown in ). The BL compliance components  include compliance services  in communication with compliance rule engine services , which are in communication with business objects . The component  (Data Access) provides an interface for accessing data storage and retrieving data to the compliance components  via BO data access interface  ().","The compliance services  include validation services (rules and transactions)  and check compliance services . Validation services  checks a rule to confirm that the rule conforms to a particular grammar and check compliance services  confirms that a proposed trade or set of trades complies with a rule or set of rules. The compliance check generates a \u2018pass\/fail\u2019 status where fail means that a rule is violated. Whether the compliance check generates a pass or a fail status, the system returns calculated values, if any, to show how proposed transaction violates a rule. In one embodiment the compliance rule engine services  include a rules.net engine  and a rules.net application programming interface (API) . .NET is a Microsoft operating system platform that incorporates applications.","The business objects  include aggregate objects , aggregate sensor , domain objects  and a data sensor . Compliance services  are in communication with the data sensor . The two components communicate internally using an interface (API), and exchange data from the domain model (e.g., securities, positions, account information) represented as C# objects.","The BL compliance components further include rule repository services . The repository services  include deployment services  and a repository service application programming interface (API) .","In one embodiment the data access components  include an online analytical processing (OLAP).service.net service  (primarily responsible for OLAP refresh) and one implementation of OLAP.service.net is based on the Microsoft Decision Support Object (DSO) package. OLAP is computer processing that enables a user to easily and selectively extract and view data from different points-of-view. For example, a user can request that data be analyzed to display a spreadsheet showing all of a company's suntan lotion products sold in Massachusetts in the month of August, compare revenue figures with those for the same products in October, and then see a comparison of other product sales in Massachusetts in the same time period. To facilitate this kind of analysis, OLAP data is stored in a multidimensional database.","MOLAP (multidimensional online analytical processing) is OLAP that indexes directly into a multidimensional database. In general, as noted above, an OLAP application treats data multidimensionally; the user is able to view different aspects or facets of data aggregates such as sales by time, geography, and product model. If the data is stored in a relational database, it can be viewed multidimensionally, but typically only by successively accessing and processing a table for each dimension or aspect of a data aggregate. MOLAP processes data that is already stored in a multidimensional array in which all possible combinations of data are reflected, each in a cell that can be accessed directly. For this reason, MOLAP is, for most uses, faster and more user-responsive than relational online analytical processing (ROLAP), the main alternative to MOLAP.","The data access components  further include an OLAP.client.net service . This service accesses aggregate data from within the left-hand side (LHS) of a rule (i.e., the condition part of a rule). In other words, this service accesses data based on the expression contained in the LHS side of a rule. The following is an example of a rule using 2 aggregates in its LHS. This rule implements a money Markey fund compliance rule:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(defrule R2A7MDWAM90"},{"entry":"(Macgregor_XAT_Compliance_Component_EngineConnector"},{"entry":"\u2003\u2003\u2003\u2003(OBJECT ?connector)"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003(Macgregor_XAT_PersistenceLayer_MxwsModifiedAccount"},{"entry":"(processStageID ?processStage)"},{"entry":"\u2003\u2003\u2003\u2003(userID ?userID)"},{"entry":"\u2003\u2003\u2003\u2003(accountID ?accountID)"},{"entry":"\u2003\u2003\u2003\u2003(OBJECT ?modAcc)"},{"entry":"\u2003)"},{"entry":"(Macgregor_XAT_PersistenceLayer_TypedViewClasses_V_MxwsAccountRow"},{"entry":"\u2003\u2003\u2003(accountID ?accountID)"},{"entry":"\u2003\u2003\u2003(accountClassCode \u201c040101\u201d)"},{"entry":"\u2003\u2003\u2003(OBJECT ?ac)"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003(Macgregor_XAT_PersistenceLayer_MxwsDataListAccount"},{"entry":"\u2003\u2003\u2003\u2003(ruleCode \u201cR2A7MDWAM90\u201d)"},{"entry":"\u2003\u2003\u2003\u2003(exclude FALSE)"},{"entry":"\u2003\u2003\u2003\u2003(listBasis 0)"},{"entry":"\u2003\u2003\u2003\u2003(OBJECT ?aclist)"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003;; call isMember to test"},{"entry":"\u2003\u2003(test (call ?aclist isMember ?accountID) )"},{"entry":"\u2003\u2003(Macgregor_XAT_PersistenceLayer_Aggregation"},{"entry":"(processStageID ?processStage)"},{"entry":"\u2003\u2003\u2003\u2003(sliceValue ?accountID)"},{"entry":"\u2003\u2003\u2003\u2003(measure ?accTotal)"},{"entry":"\u2003\u2003\u2003\u2003(key \u201c10.3.0\u201d)"},{"entry":"\u2003\u2003\u2003\u2003(OBJECT ?accAggrTV)"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003(Macgregor_XAT_PersistenceLayer_Aggregation"},{"entry":"(processStageID ?processStage)"},{"entry":"\u2003\u2003\u2003\u2003(sliceValue ?accountID)"},{"entry":"\u2003\u2003\u2003\u2003(measure ?accTotalm)"},{"entry":"\u2003\u2003\u2003\u2003(key \u201c10.4.0\u201d)"},{"entry":"\u2003\u2003\u2003\u2003(OBJECT ?accAggrTVM)"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003(test (<\u20030.0 ?accTotal ) )"},{"entry":"\u2003\u2003(test"},{"entry":"\u2003\u2003\u2003\u2003(<"},{"entry":"\u2003\u2003\u2003\u2003\u200390.0"},{"entry":"\u2003\u2003\u2003\u2003\u2003(\/ ?accTotalm ?accTotal )"},{"entry":"\u2003\u2003\u2003\u2003)"},{"entry":"\u2003\u2003)"},{"entry":"\u2002=>"},{"entry":"\u2003(create-exception2 \u2002?connector \u201cR2A7MDWAM90\u201d \u201c1.0\u201d ?modAcc"},{"entry":"?aclist \u201c\u201d \u201c\u201d \u201cC\u201d\u2002\u201cMacgregor_XAT_PersistenceLayer_Aggregation\u201d"},{"entry":"?accAggrTVM)"},{"entry":")"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In addition, the data access components  include a DB.client.net service . This component is a database client and provides data source connectivity and access.","The data server  includes a MOLAP\/ROLAP component  and a database  that includes an application database and rule repository .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 8","FIGS. 1A and 1B"]},"The OLAP.client.net service  generates objects that the system matches against specified properties for the left hand side of a rule. One example of an aggregate object includes the following information: measure (holds the value of the aggregate as returned by OLAP), key (represents the kinds of aggregate value, here 10.3.0 means account total market value), and slicevalue (here the system sliced the data based on the account ID, this is just an input to OLAP). The OBJECT variable holds a pointer to the aggregate so the system can use it in the rule where it is declared:",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Company_XAT_PersistenceLayer_Aggregation"]},{"entry":[{},"\u2003\u2003(sliceValue ?accountID)"]},{"entry":[{},"\u2003\u2003(measure ?accTotal)"]},{"entry":[{},"\u2003\u2003(key \u201c10.3.0\u201d)"]},{"entry":[{},"\u2003\u2003(OBJECT ?accAggrTV)"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The Business Objects layer deals with aggregate objects and with domain objects, A domain object is an object containing data of interest to the system\u2014a domain object is an object from a domain model. A conventional domain object encapsulates business rules and logic. A Domain Model creates a web of interconnected objects, where each object represents some individual entity, the individual entity having meaning to the system. The individual entity can be as large as a corporation or as small as a single line on an order form. In the present invention, the rules are separate from the domain objects.","Using service rules, the Compliance Engine generates aggregate objects dynamically based on the rules needs. The conditions of each rule match on specific objects. Furthermore, one who creates a rule can assign compliance rules to specific accounts. The combination of this information allows a compliance engine according to the invention to create instantiations of aggregate objects at runtime as the rules fire for a given account (or accounts) Similarly, the system creates domain objects using the data sensor layer. Domain objects are created similarly to aggregate objects, based on rules conditions (referring to specific classes of data for given accounts). The engine uses the data sensor to issue a conventional query to the database and fetch that data. The object instances are then created from the returned data. This is not a standard command in C# Jess (C# is a programming language and Jess is a general purpose rule engine). The aggregate object and domain object messages contain object instance, data values according to the attributes of those objects and their types. Examples of such domain objects include securities, position data, and account details. An asset object has attributes such as an asset ID, a short name, an asset type code, an issuer ID, a primary exchange code, price currency code and votes per share. At runtime, given one or more accounts and their specific properties or constraints (for example a money market account), we only create object instances related to such a context. This allows the system to load only necessary data objects and optimize memory usage, One could imagine generating SQL code to query the data sources before running rules, but such an approach is not efficient.","Thus, one embodiment of the BL compliance components include:\n\n","A core element of the compliance engine is Rules.NET, its rule engine. Rules.NET is a forward chaining rule engine using, in one embodiment, a pattern matching data driven algorithm called RETE. This algorithm defines a network of logical patterns (rule conditions) and allows for the reuse of common patterns between rules, enabling fast evaluation of conditions and activation of rules.","System Interfaces","The Rules.NET library  is an API allowing various levels of access to the Rules.NET engine execution environment and object model. The library (a DLL) allows a Rules.NET user to observe\/manipulate the operation of the rules engine. As an example, a user can see the rules being selected for execution, new facts that have been created, data that has been updated, and the number of rules that have been fired. The Library (a dynamic link library or DLL) can be used by various components to build services. A dynamic link library is a library which is linked to application programs when they are loaded or run rather than as the final phase of compilation.","The Compliance Engine Gateway (Compliance Services)  interface is a bridge allowing the integration and interaction between the compliance engine  (component  can be referred to as a compliance engine or as compliance rules engine services\u2014one uses the term services in the context of APIs and interfaces and one uses the term engine in the context of components) and external components and services, such as an order management system (OMS). It is the entry point for compliance checking on a proposed set of orders or a list of transactions. The gateway provides low-level validation such as data type checking, integrity check, and other validation tests such as checking if the input transaction set exists already. The gateway is also used to retrieve the results from the underlying engine and stores them in the database using the data access layer interface.","DB.CLIENT.NET  is an API used for data access by components of the system. The engine's data sensor uses this interface to retrieve security data for example, and other domain model objects, as needed.","OLAP.CLIENT.NET  defines the interface to access aggregate data in the OLAP server using the engine's aggregate factory. The retrieved aggregate data is also transformed into objects using this interface and asserted as facts into the engine's working memory.","OLAP.SERVICE.NET  is primarily responsible for OLAP refresh. This component defines an API facilitating its configuration and the management of multiple OLAP cubes installations. It also provides a method to set a refresh interval as a default or per declared cube. A cube update service can be turned off, for example in the case of overnight cycles. The overnight cycle is a process that takes place at a scheduled time after the end of day (after the market closes). It includes any processing on carry over orders, changes to data, generation of reports on all activity that happened that day, and in some cases, tests all rules against the data and generates reports on compliance checks at that point as well.","Rules.NET Engine ","Rules.NET is a J# port of the Java-based Jess rule engine. J# is a Microsoft-supported language for .NET. J# is Microsoft's implementation of the Java programming language. As noted above, .NET is a Microsoft operating system platform that incorporates applications. Rules.NET adds an extended API to allow for an easy integration with the platform. one can practice this invention using any \u201cProduction Rules Engine\u201d that supports .NET platform or Java platform.","The following table describes the component information:",{"@attributes":{"id":"p-0054","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Rules.NET Service Component Information"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Namespace","Platform.BL.Engine"]},{"entry":[{},"Type","IEngine"]},{"entry":[{},"Responsibilities","Wrap Jess 6.0"]},{"entry":[{},{},"Provide a rule engine API in C#"]},{"entry":[{},{},"Reasoning"]},{"entry":[{},{},"Port Java Jess to .NET J#"]},{"entry":[{},{},"Unit and regression tests"]},{"entry":[{},"Collaborators","Sandia Jess 6.0"]},{"entry":[{},"Notes"]},{"entry":[{},"Issues"]},{"entry":[{},"Assembly name","Rules.NET"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"68"},"In one embodiment, the CE gateway service  is the primary check compliance interface for all other components of the platform. Given a set of orders, the compliance service, via its interface with the rule engine, captures a set of violations generated by rule firings in the engine (if there are any), and returns them to the requester (for example an order management system) In one embodiment the order management system interfaces with the system via the fa\u00e7ade  shown in .","The CE gateway uses Rules.NET engine deployment descriptors (XML files) combined with a configuration model to load rulebases as well as any required data and metadata. A rulebase is a set or a group of rules. For example, one can create a rulebase made of rules specifically dealing with money market funds.  illustrates one embodiment of a deployment process flow. A deployment descriptor is an XML file describing the rulebase location and name (the rulebase to be deployed).","With reference to . a deployment process begins with an administration tools component (also referred to as the rule management component) sending a deploy rules message to the rule repository component (RRC). If the RRC determines that the rules have not changed, the RRC sends the administration tools component (ATC) a message indicating that the rules have not changed and deployment is not necessary. If deployment is necessary the RRC records deployment and forwards deployment results to the ATC. The RRC then locks active rule changes. The ATC in turn notifies the engine to prepare for deployment and passes repository and rule information to the engine. The engine completes the latest request from the ATC and sends a request to the RRC for a deployable ruleset. The RRC sends a ruleset for deployment. The engine deploys the rules and notifies the ATC that the engine is ready for requests. The ATC then notifies the RRC to unlock the rules.","The following table describes the CE Gateway Service component information:",{"@attributes":{"id":"p-0059","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"MLC Service Component Information"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Namespace","Platform.Compliance"]},{"entry":["Type","Compliance"]},{"entry":["Responsibilities","Initialize other components, such as the DataSensor"]},{"entry":[{},"Load deployment descriptor information"]},{"entry":[{},"Load rules (including service rules) and initial"]},{"entry":[{},"facts"]},{"entry":[{},"Request data using service rules"]},{"entry":[{},"Reasoning"]},{"entry":[{},"Return results declaratively by embedding them in"]},{"entry":[{},"the VBOS object, the root object in one embodiment"]},{"entry":[{},"of a domain object model for use with the invention."]},{"entry":[{},"Provide an interface for external world"]},{"entry":["Collaborators","Rules.NET, DB.CLIENT.NET, OLAP.CLIENT.NET"]},{"entry":"Notes"},{"entry":"Issues"},{"entry":["Assembly name","Compliance"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"This component is a database client, using an object linking and embedding database (OLEDB) provider. In other words, one embodiment of the invention uses a database management system, such as Microsoft SQL server available from Microsoft Corporation of Redmond Wash., that supports standard query language (SQL). The database client provides concrete support for data source connectivity and access. Its API is generic and facilitates data access for certain components.","The following table describes the component information:",{"@attributes":{"id":"p-0062","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DB Client.NET Component details"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Namespace","Platform.BO.DB.Client"]},{"entry":["Type","DB.Client"]},{"entry":["Responsibilities","Define API to get primitives and connect to a specific"]},{"entry":[{},"data store"]},{"entry":[{},"Provide concrete support for API"]},{"entry":[{},"Load deployment descriptor"]},{"entry":["Collaborators","OLEDB provider"]},{"entry":"Notes"},{"entry":"Issues"},{"entry":["Assembly name","DB.Client"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"134"},"The system uses OLAP.CLIENT.NET to access aggregate data from within the left-hand side of a rule (the condition part of a rule). A typical example of an aggregate object is one that stores the total market value for a given account. Here is an example of this aggregate object used in the condition of a compliance rule:",{"@attributes":{"id":"p-0064","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Macgregor_XAT_PersistenceLayer_Aggregation"]},{"entry":[{},"\u2003\u2003(sliceValue \u2002?accountID)"]},{"entry":[{},"\u2003\u2003(measure \u2002?accTotal)"]},{"entry":[{},"\u2003\u2003(key \u2002\u201c10.3.0\u201d)"]},{"entry":[{},"\u2003\u2003(OBJECT \u2002?accAggrTV)"]},{"entry":[{},"\u2003)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The variable ?accTotal hold the MarketValue for a given account with the account ID matching the value stored in the variable ?accountID. The key \u201c10.3.0\u201d represents a market value by account.","Here is an example of rule leading to the aggregate mentioned:",{"@attributes":{"id":"p-0067","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(defrule R1940ACT5b1DMax5TAV_qry_accmv"},{"entry":"\u2003\u2003(Macgregor_XAT_Compliance_Component_EngineConnector"},{"entry":"\u2003\u2003\u2003\u2003(OBJECT ?connector)"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003(Macgregor_XAT_PersistenceLayer_MxwsModifiedAccount"},{"entry":"(processStageID ?processStage)"},{"entry":"\u2003\u2003\u2003\u2003(userID ?userID)"},{"entry":"\u2003\u2003\u2003\u2003(accountID ?accountID)"},{"entry":"\u2003\u2003\u2003\u2003(OBJECT ?modAcc)"},{"entry":"\u2003)"},{"entry":"(Macgregor_XAT_PersistenceLayer_TypedViewClasses_V_MxwsAccountRow"},{"entry":"\u2003\u2003\u2003(accountID ?accountID)"},{"entry":"\u2003\u2003\u2003(accountClasscode \u201c040101\u201d | \u201c0401\u201d)"},{"entry":"\u2003\u2003\u2003(OBJECT ?ac)"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003;; get the DataList for the account rule association"},{"entry":"\u2003\u2002(Macgregor_XAT_PersistenceLayer_MxwsDataListAccount"},{"entry":"\u2003\u2003\u2003\u2003\u2002(ruleCode \u201cR1940ACT5b1DMax5TAV\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2002(exclude FALSE)"},{"entry":"\u2003\u2003\u2003\u2003\u2002(listBasis 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2002(OBJECT ?aclist)"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003;; call isMember to test"},{"entry":"\u2003\u2003(test (call ?aclist isMember ?accountID) )"},{"entry":"\u2003\u2003(not"},{"entry":"\u2003\u2003\u2003\u2003\u2002(Macgregor_XAT_PersistenceLayer_Aggregation"},{"entry":"(processStageID ?processStage)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(key \u201c10.3.0\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(sliceValue ?accountID)"},{"entry":"\u2003\u2003\u2003\u2003\u2002)"},{"entry":"\u2003\u2003)"},{"entry":"=>"},{"entry":"\u2003\u2003(create-aggregate2 \u201cregular\u201d \u201c\u201d ?modAcc \u201c10.3.0\u201d false"},{"entry":"0)"},{"entry":"\u2003\u2003(printout t \u201ccreate-aggregate2\u201d\u2003crlf)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The aggregate is created only if it is not already available to the engine (see the not statement in the LHS of the rule).","This OLAP.CLIENT.NET service component  is an OLAP client, used to execute OLAP queries. The component is auto generated from the domain object model using XSL transformations. The OLAP.CLIENT.NET service provides an API allowing the auto-generation of methods for aggregates based on templates. As described more fully below, one can use an OLAP multi-dimensional expression (MDX) query markup to query OLAP databases. Furthermore, one can base the MDX queries on templates.","The following table describes the component information:",{"@attributes":{"id":"p-0071","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"OLAP Client.NET Component details"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Namespace","Platform.BO.OLAP.Client"]},{"entry":["Type","OLAP.Client"]},{"entry":["Responsibilities","Define API to get aggregates from OLAP service"]},{"entry":[{},"Used by AggregateFactory"]},{"entry":[{},"Define API to auto-generate methods for new"]},{"entry":[{},"aggregates"]},{"entry":["Collaborators","Microsoft\u2009\u00ae ADOMD or different"]},{"entry":[{},"multidimensional data provider"]},{"entry":"Notes"},{"entry":"Issues"},{"entry":["Assembly name","OLAP.Client"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"With reference to , The OLAP client  sends multi-dimensional expression queries to OLAP cubes and receives datasets in response. Similarly, data sensor  performs read\/write operations on the database .","With reference to , major software components of one embodiment of a system  according to the invention include a business rules definition component, e.g., a natural language grammar  and a Rule Editor . In operation, organizations can define complex business rules using application specific languages and tools (e.g., a natural language compliance grammar  and a Rule Editor ) best suited to the task. Appendix II provides one embodiment of a rule grammar specification for a structured standard grammar language close to Backus Naur form (BNF) standard syntax. Using this specification, a person of ordinary skill in the art can create a rule editor and a natural language grammar that support the rule expressions provided in the compliance engine of the present invention.",{"@attributes":{"id":"p-0074","num":"0078"},"figref":["FIG. 4","FIG. 2"],"b":["98","98"]},"Returning to , the rule editor converts the business rules into a machine-readable application and technology independent format (e.g., Rule Object Model format ). The intermediate representation\/format allows other applications to share and reuse a defined business rule, and for system developers to deploy the rules on alternative execution environments. A Rule Translator (RT)  receives the intermediate representation\/format of the business rules and translates the business rules from the application and technology neutral format into an equivalent format suitable for high-performance execution in a specific runtime environment (i.e., in the Compliance Analytics Engine proper ). In other words, one of the RT's outputs is an equivalent format (e.g., a C Language Integrated Production System, or CLIPS, rules format) of the compliance rules. The Compliance Analytics Engine (CA engine)  receives the CLIPS Rules as an input. CLIPS is a language for developing expert systems, with support for forward chaining rule-based, object-oriented and procedural programming.","In addition, in the illustrated embodiment the RT  extracts and persists the Rule Attributes properties  of the rule so that the rest of the system can directly access that information. In other words, the RT outputs Rule Attributes (RA) . The RA interface exposes a set of static basic properties of each rule that user interface (UI) applications require for display purposes. These properties can include a complete list of domain attributes referenced by the rule in question and information on how to navigate the attributes. The Security Asset Code from the security business object or the safe harbor date on the Account business object represent two examples of domain attributes referenced in regulatory rules (U.S. regulations as an example). There are other attributes regarding account properties (e.g., taxable or not-taxable and national or state).","The RT also generates a Relevance Filter (RF) function  for each translated rule. The RF  is an executable function unique for each rule. In one embodiment, in the portfolio compliance context, the RF receives as input a set of identifiers for securities and determines which of the securities, if any, contribute to the possible failure of that rule. A relevance filter is a function tightly coupled to the rule and in one embodiment is written as C# standard query language (SQL) code. One adds these filters to support post-compliance functionality. Here is an example of such code:","The properties to filter on are country and effective duration:",{"@attributes":{"id":"p-0079","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003SELECT ids.SecurityID"]},{"entry":[{},"FROM dbo.fn_SplitSecurityIDs(@spSecurityListID) ids"]},{"entry":[{},"WHERE ids.SecurityID IN"]},{"entry":[{},"("]},{"entry":[{},"\u2003SELECT sec.AssetID"]},{"entry":[{},"\u2003FROM v_MxwsSecurity sec"]},{"entry":[{},"\u2003WHERE (((((CountryCode=\u2018CAN\u2019) or (EffectiveDuration<2))"]},{"entry":[{},"\u2002and (CountryCode=\u2018US\u2019))"]},{"entry":[{},")"]},{"entry":[{},"\u2002or ((Sector<>\u2018Tech\u2019))"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Once the CA engine  receives the CLIPS rules, the CA engine evaluates and records the status of portfolio compliance with respect to the assigned rules in near-real time. In other words, an output of the CA engine  is compliance status . A compliance workstation  accesses the rule attributes  and the compliance status information  to perform in-depth analysis and reporting.","With reference to , a high-level diagram of one embodiment of the compliance analytics engine execution (runtime) environment shows a client  posting a request to a request queue . A listener component  picks up the next request in the queue. The specific request is associated with a compliance analytics engine thread . A thread includes placeholder information associated with a single use of a program that can handle multiple concurrent users. From a program interface perspective, a thread is the information needed to serve one individual user or a particular service request. If multiple users are using the program or concurrent requests from other programs occur, a thread is created and maintained for each of them, e.g., a plurality of threads , are created.","With reference to , A and A, one embodiment of a compliance service  receives, e.g., from an inventory management service (IMS) , via the request queue  and listener , a check compliance request associated with thread . The compliance service passes a do-inference request to a rules.net component . The rules.net component  sends a get-static-data request to the data sensor . In response, the data sensor  returns static data to the rules.net component . The rules.net component  also sends a get-aggregation-data request to the aggregate sensor . In response, the aggregate sensor  returns aggregation data to the rules.net component .","The DoInference( ) call in is a call for the engine to fire rules. The rules.net component  creates exception data, e.g., data regarding aspects of a portfolio and\/or a set of trades that do not comply with deployed rules. The rules.net component  passes the exception data back to the compliance service , which in turn passes a persist-evaluation-data request to a post compliance component . The post compliance component  passes an update-compliance-state request to the data sensor  and the compliance service  passes a post-result request to the response queue .","With reference to , another embodiment of the operation of the system of  includes the compliance services  receiving a transaction set from an order management system (OMS) . The compliance services  perform a check-transaction-list function and a validate-transaction-list function. The compliance services  then send a load-Business-Objects request to the compliance engine (CE) , e.g., the rules.net engine. The CE performs an assert-facts function, sends a get-security-data request to the data sensor , and a get-aggregates request to the aggregate sensor . In response, the aggregate sensor passes a get-OLAP-data request to the OLAP client , which sends a return-OLAP-data message in response. The aggregate sensor  in turn sends a return-aggregates message to the CE .","When the CE  receives a do-inference request from the compliance services , the CE executes a fire function and returns results to the compliance services . The compliance services  send a save-results request to the data sensor  and send a return-results message to the OMS ","With reference to , one embodiment of a system  according to the invention includes Service Rules and a Knowledge Management Framework. The Rule Translator (element  of ) generates the Service Rules. Service Rules provide a fast and flexible mechanism for accessing data elements needed for rule evaluation. The Knowledge Maintenance Framework (KMF) combines traditional object oriented and relational programming models with declarative rules and online analytical processing (OLAP) programming models into a common development platform.","Service Rules","A rule is a kind of instruction or command that applies in certain situations. For the purposes of this document, one embodiment of a rule has a left-hand side (LHS), i.e., a predicate or premise, and a right-hand side (RHS), i.e., an action or conclusion. One can imagine a rule without a LHS (no conditions), which one could interpret to be a fact, or without a RHS (no action), which one could interpret to be a query. The Service Rules provide a meta-evaluation level to efficiently optimize the calls to OLAP from the left-hand-side (condition part) of each compliance rule that is a candidate to be evaluated. In conventional OLAP usage, a procedural integration component would be built and used to access data in OLAP. Such an approach would require many calls and overhead. According to one embodiment of the invention, a user of the system can declare that a rule needs certain types of aggregates. When the rule matches on specific account information for a given rule, it will then generate an instance of the aggregate object, and use the parameters of the instantiation to call OLAP. OLAP will then return the results, for example a measure of the total market value for a given account. The system reuses such result in compliance rules to then check compliance status (for example a rule checking that a mutual fund market value for a given industry must be under 5% of the total of the account). The use of service rules (evaluated first before the compliance rules) filters unneeded data and information.","Metadata objects are objects used to define other objects. By creating metadata objects to represent aggregate instances and using them declaratively from within the left-hand-side of the rules, Service Rules provide a bridge between the analytics system (e.g., an OLAP system) and the rules-inferencing mechanism. An aggregate object, which is a metadata object, is used in the condition (LHS part) of a rule. The statement is declarative and not procedural where one would have to call a routine to communicate with OLAP.","One embodiment of the Service Rules bridge integrates the results of the analytics (OLAP processing) directly into the inferencing mechanism (i.e., the Rules Engine  in ). The engine not only processes domain data, but it also matches on the declaratively defined aggregations (specified in services rules, not executed in procedural methods). This matching allows for a seamless integration of OLAP and the inference engine. Typical methods would only focus on procedural execution (sequential execution) of OLAP queries, and then follow that procedural execution with rule engine processing.","Aggregations are declaratively defined since they are described as conditional patterns in service rules (in one embodiment service rules are the rules the system fires before the compliance rules). Consider the following compliance business rule: A money market account cannot own more than 5% of its total market value in technology. The aggregate objects (two in this case) return the total market value for the account and the total for the account for tech assets only. This information is then used by the compliance rules to check the 5% condition. The matching (of patterns against available data) is part of the engine's function, and the architecture of one embodiment of the present invention makes sure the system matches first on service rules and then compliance rules (which means in this cases, aggregates are created first and populated with the results from OLAP and then compliance rules are tested).","Another aspect of the invention is the fact that the rules are operating independently from the OLAP implementation. Declarative programs, such as certain rule-based programs, describe what the computer should do, but omit much of the instructions on how to do it, leaving the runtime system to fill in the blanks.","Service rules reuse the same RETE-based forward chaining rule execution mechanism as the business rules. The Rete algorithm is an efficient pattern-matching algorithm for implementing rule-based (\u201cexpert\u201d systems). In other words, a RETE-based forward chaining rule execution mechanism is used to determine whether to execute a particular business rule for a given set of facts. Service rules use the same RETE-based forward chaining rule execution mechanism to determine an efficient way to access the data that is to be tested to determine if a particular business rule should be executed. The RETE algorithm provides a two-phase optimization of its network. The Rete algorithm is described in a paper by Charles Forgy entitled \u201cRete: A Fast Algorithm for the Many Pattern\/Many Object Pattern Match Problem\u201d published in Artificial Intelligence, 19, pp 17-37, 1982, and incorporated herein by reference in its entirety. Service rules contain conditions that are satisfied at runtime allowing the selection of which data to load, and filtering any unneeded data and objects.","The architecture appears as if there was a rule engine inside the rule engine. The present invention allows the engine running compliance rules to be driven by the inference process applied to metadata on accounts\/portfolios, securities, and other business objects. When such meta-rules fire (one can refer to these meta-rules as service rules), they generate data objects in an efficient way (only the data needed is generated) allowing the compliance rules to be fired and the compliance-check to be executed. As noted above,  is a high-level diagram of the compliance analytics engine execution (runtime) environment. The path from Services Rules to the OLAP calculation implementation is supported by the Aggregate Sensor (shown as element  in ). The Aggregate Sensor acts as an object factory, used to create aggregate objects, integrated to the compliance domain object model.","Each aggregate class is generated using an OLAP multi-dimensional expression (MDX) query markup. MDX was created to query OLAP databases, and has become widely adopted within the realm of analytical applications. MDX is a standard for issuing queries to, and exchanging data with, multidimensional data sources. At runtime, the instantiation of each instance in the engine is what enables the implementation of the bridging between the rules and the OLAP queries, empowered by the choreography of Service Rules. In other words, once a rule is evaluated against the facts at a particular point in time, the service rules can efficiently access the necessary data based on the present state of the rule and the present state of the data by using the Rete algorithm. The instantiation and the evaluation of the rules enable the system to focus on specific OLAP cells at any point in time (an OLAP cell represents a single aggregate value in any dimension). The Service rules are efficient because they use the Rete algorithm to take advantage of the context data.","The Rete algorithm is a network linking all the conditions of the rules that are deployed in the compliance engine. Rete is a fundamental algorithm for production rule systems. The way Rete is structured, it remembers the instantiation of the conditions using the current facts, and therefore can decide which rules are ready, or are close to being ready, to fire. As an example, consider a rule that needs to check compliance for an account against a rule restricting trading in technology in certain countries. These conditions are used in service rules to only load specific data from the database for this account. Compliance rules are then applied only against the returned data as opposed to loading all the data related to that account, as is done by many other systems.","Service Rules help to satisfy the demanding performance and scalability requirements of portfolio compliance. Most data intensive applications make extensive use of data caching schemes in order to satisfy performance requirements. However, the open ended nature of user defined business rules combined with real-time changes to portfolio information and the need for scalability renders conventional data schemes inefficient and even counterproductive.","To amplify on this last point, user defined business rules can apply to arbitrary data sets and aggregations, and therefore data access patterns are typically unknown at design time (e.g., one organization may want to limit client portfolio investment in any security with more than 10% sales exposure in any one country except for those countries with GDP growth greater than 3%). In one embodiment, the compliance rules analytics engine design begins to get around the classic performance limitations of ad-hoc data analysis by leveraging the power of commercial OLAP engine technology to enable fast on-the-fly generation of arbitrary aggregations. An aggregation in the OLAP context is a composition technique for building a new object from one or more existing objects that support some or all of the new object's required interfaces.","One embodiment of the invention uses a Microsoft Analytic Services engine, e.g., one could purchase a Microsoft\u00ae SQL Server\u2122 2000 Analysis Services platform from Microsoft Corporation of Redmond, Wash. and load it onto a server as part of performing the methods of the present invention. Alternatively, other OLAP engines could be used to practice the present invention.","In addition, for every business rule defined the rule translator module generates a set of \u2018service\u2019 rules that define the data access rules associated with executing that business rule. The RT generates both service and business rules starting from the natural language. For each template rule mapped to the natural language expression, there is a corresponding service rule defining the data objects needed for such a template. The instantiation of the templates to real rules happens at translation time, and the instantiation and creation of data access objects happens at runtime as a result of the engine executing the service rules. In essence, the compliance engine \u2018caches\u2019 the data access strategy. Moreover, because the rules engine is RETE-based it naturally optimizes the data access strategy defined declarative in the service rules. A data access strategy in this context refers to the algorithm used to query and retrieve specific data from the database at a given point in time during the compliance check process. As an example, assume the system is checking compliance for a money market account. Since one embodiment of the system uses service rules (therefore declaratively stating the conditions for data access), the system can target specific data to load for this account only and not others. Further, this embodiment of the system will only load the data needed by the rules used by this account.","The RETE algorithm does not distinguish between \u2018business\u2019 logic rules and \u2018data access\u2019 logic rules and it optimizes them just the same. The optimization is a property of the algorithm itself. As noted above, the Rete algorithm is described in a paper by Charles Forgy entitled \u201cRete: A Fast Algorithm for the Many Pattern\/Many Object Pattern Match Problem\u201d published in Artificial Intelligence, 19, pp 17-37, 1982, and incorporated herein by reference in its entirety. The algorithm builds a network of nodes where each node represents the patterns or the conditions of each rule (this is the case for both the service rules and the compliance business rules of the present invention).","As noted above, the arbitrary nature of user defined business rules would make it difficult, if not a practical impossibility, to generate optimal data access schemes at design time.","The RT  translates service rules into CLIPS rules (shown in ). More precisely, in one embodiment the RT  ultimately translates or compiles all rules as CLIPS rules. Thus, the RT  translates service rules to CLIPS format before the Rules.NET Engine executes the rules.","The following paragraphs describe the process of translating a rule from a UI RuleGist format to executable rules. One part of translation involves resolving the intent of a rule against the rule created by the editor.","Because of the natural language presentation of a rule, rules are open to interpretation, from simple rules with several conditions to complex rules with parenthetical.","The following steps explain in detail the process for creating rules using the UI RuleGist. In some cases, we refer to the implemented application classes. Details on each one of the classes are given in the next section. Some of these steps can be viewed as a recommendation on best practices:\n\n","For a detailed description of how to parse RuleGist structure, please refer to the methods in GrammarTranslator. The GrammarTranslator is a class part of the overall RulGist UI Application (Rule editor). The file name is GrammarTranslator.cs and it is part of the computer program listings residing on each of the copies of the compact disc submitted with this document. One can find the GrammarTranslator.cs file on each copy of the compact disc at the following location:",{"@attributes":{"id":"p-0108","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"xipws\\Common\\BLL\\BusinessLogicPackages\\RuleTranslator\\"]},{"entry":[{},"GrammarTranslator.cs (a C# source file)."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"All of the methods have detailed comments, which explain how parsing works.","Required Assemblies","The following assemblies are required by the RuleTranslator.\n\n","This section provides an explanation of the core classes in RuleTranslator. It is meant to provide a high-to-medium level view of the responsibilities of each class.",{"@attributes":{"id":"p-0112","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"GrammarTranslator"},{"entry":"Responsible for parsing RuleGist structure for all rules and creating an array of Param"},{"entry":"Objects. For restriction rules, it parses the nested conditions first, producing a bottom up"},{"entry":"approach to parsing."},{"entry":"ClipsTransformer"},{"entry":"Responsible for calling the methods in JessClips. Contains the logic for generating the"},{"entry":"basic structure for all rules."},{"entry":"JessClips"},{"entry":"JessClips contains all the methods for generating jess specific clips statements for all"},{"entry":"rules. The class contains constants for most of the jess commands."},{"entry":"BaseTemplate"},{"entry":"BaseTemplate is the container for Param objects and translating Param objects to the"},{"entry":"equivalent Triplet object. This was done to decouple the UI and runtime format. In some"},{"entry":"cases, the Param's have to be massaged, so they fit the required format."},{"entry":"AbstractTemplate"},{"entry":"AbstractTemplate provides common implementation, so that one or more subclasses can"},{"entry":"extend it. One requirement is CompAlert rules will eventually have to be translated to the"},{"entry":"new format. Developers can easily extend the abstract class to read ComplAlert ResDef"},{"entry":"table and produce the correct Triplet objects."},{"entry":"ILogical"},{"entry":"Ilogical is the generic interface defining the methods for Logical operators. The types of"},{"entry":"logical operators are \u201cand\u201d conjunction and \u201cor\u201d disjunction."},{"entry":"RootLogical"},{"entry":"RootLogical is the base class which other logical classes extend. LeftHand extends"},{"entry":"RootLogical, since the rule object model must be able to express nested statements."},{"entry":"GrammarTranslator is the primary class creating new instances of this class."},{"entry":"ParamAnd"},{"entry":"ParamAnd represents a parameter object that contains one or more atomic conditions or"},{"entry":"nested statements."},{"entry":"ParamOr"},{"entry":"ParamOr represents a parameter that contains one or more atomic conditions or nested"},{"entry":"statements that are logical disjunctions. GrammarTranslator is the primary class creating"},{"entry":"new instances of this class."},{"entry":"Triplet"},{"entry":"Triplet represents an atomic comparison between values. It is specifically a comparison"},{"entry":"of an object attribute, which is a single attribute with a data value of the same type."},{"entry":"TripletAnd"},{"entry":"TripletAnd represents a conjunction of one or more atomic conditions or nested"},{"entry":"statements. Template classes are the ones responsible for creating instances of triplet"},{"entry":"objects."},{"entry":"TripletOr"},{"entry":"TripletOr represents a disjunction of one or more atomic conditions or nested statements."},{"entry":"Template classes are the ones responsible for creating instances of triplet objects."},{"entry":"IParam"},{"entry":"IParam is the generic interface describing Parameters."},{"entry":"ITransform"},{"entry":"ITransform is a simple interface that describes what a translator does. It transforms rules"},{"entry":"from one format to another format."},{"entry":"ServiceRuleService"},{"entry":"ServiceRuleService is responsible for using ListManagement and the repository manager"},{"entry":"to save implicit lists and service rules. This is necessary because the UI doesn't convert"},{"entry":"implicit lists to explicit lists. The service rules are required to query against the database"},{"entry":"and OLAP."},{"entry":"ServiceRuleTranslator"},{"entry":"ServiceRuleTranslator is responsible for taking the translated Triplets and generating the"},{"entry":"correct service rule for the given calculated rule. In some cases, there may be more than"},{"entry":"one service rule."},{"entry":"ITriplet"},{"entry":"ITriplet defines an atomic condition."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Knowledge Maintenance Framework (KMF)","With reference to , a Knowledge Maintenance Framework (KMF) integrates the OLAP cube models, MDX queries, Service Rules, Business Rules, the Object Oriented domain representation, and the Relational Domain Model into a common semantic platform.  represent one embodiment of a design of the system's knowledge structure. This design defines the data store of elements of the KMF as well as the operation of the system. In connecting A and B to , the knowledge structure relates to the data access\/server and BL components () and to the editor ().  illustrates one embodiment of a compliance check process including the editing (starting with the user entering rules using the editor) to the translation to the internal representation of rules to the runtime where a compliance status is generated. The overall structure of the system is shown in .","With the KMF, the present invention provides a semantic integration of all the elements in use. The present invention does not have separate concepts, used in completely different ways and concepts \u2018meaning\u2019 different things in each model. To clarify, one embodiment of the system uses a single XML schema (tree structure) to include all the elements making the \u2018knowledge base\u2019 of the present compliance system. For example, one embodiment of the KMF includes rules, sql queries, OLAP MDX queries, all in the same uniform representation.","In one embodiment, the Rules Analytics Engine integrates a variety of best-of-breed information processing technologies, e.g., MDX queries, OLAP and Rules.Net, the .Net implementation of Jess (In addition to those technologies already mentioned above, one can obtain SQL Server, Net development tools, and C# programming language from Microsoft Corporation of Redmond, Wash.). Each of the information processing technologies performs a certain kind of function, and each supports a different model of operation with proprietary semantics. Many of these technologies have not been adopted widely enough to be subject to robust industry standardization. The semantic integration challenge implied by the combination of these technologies is likely a major reason why other organizations have not successfully pursued the approach implemented by the present invention. Integration is always a difficult task requiring advanced technology. In this invention, multidimensional data and multiple sources add to the challenge. Semantic integration challenges include the translation of meaning from one model to another (for example the queries described in OLAP, the way the system uses the queries in rules, and how the user understands the queries). Another example of a semantic challenge in compliance systems is translating from one data source's interpretation to another. The integration of the meaning from one source to another is a challenge. Declarative systems as supported in this invention help alleviate such issues because logical expressions, conditions, and other types of information, are described declaratively and not encoded in procedures.","The framework of  includes an MDX markup language capable of supporting a platform, programming language, and platform-neutral OLAP statements. Platform in this context means software platform\/software environment. One example of a platform for use with the invention is Microsoft SQL Server 2000 Analysis Services. The expressiveness of the rule language is empowered by an extension to MDX query support (the extension is achieved using an extensible markup language (XML) schema) The XML schema can be used to write extended MDX queries. An MDX knowledge base defines and implements a set of generic templates used to generate OLAP queries in a platform independent manner. The queries can be represented in an OLAP language and in the C# programming language. An MDX utility facilitates not only the editing and navigation of queries, but also the testing and tuning of the performance of each query template. The MDX utility is a conventional application written in C#. It allows the testing of MDX queries using conventional calls to OLAP systems. One can take the same MDX queries and run them directly in the OLAP system of their choice.  illustrate the structure of the Knowledge Management Framework and the schema used to support OLAP integration.","One embodiment of the invention provides a flexible mechanism allowing the definition, representation and deployment of MDX statements as part of the MLC knowledge base, which includes business rules for compliance and domain data and metadata.","One embodiment of the invention provides an XML markup for MDX queries with an object-centered approach. An XML document according to the invention integrates MDX statements, Rules and other SQL statements together in the same environment (An MLC XML document contains rules, metadata, mdx and sql)","An XSL transformer implements the translation layer from XML to MDX statements for execution. The MDX template navigator, used to view and edit the list of available templates and their contents, is similar to the explorer interface in windows. In one embodiment, a feature is added to test and monitor the performance of each query and compare any changes that have been made and their performance with the previous version. The XSL transformer is written in standard XSL. Given the MDX XML schema, one can write an XSL translator. The template navigator is a conventional C# application.","The MDX markup language is a subset of the overall knowledge base markup, shown in . MlcKnowledgeStore  is one embodiment of a root element of an information set according to the invention, the information set including data, metadata, queries and rules. More specifically, MlcKnowledgeStore  is a sequence of rulebase elements , olapquerybase elements , sqlquerybase elements , domaindata elements , and domainmetadata elements  (which is in turn a sequence of metadata elements ).","The MDX subset starts with \u2018<olapquerybase>\u2019  as its main root element. It is a sequence, possibly empty, of mdxquery elements. Each \u2018<mdxquery>\u2019 element  represents a single mdx statement. With reference to , element  is a made of a header , a body , and a list of query parameters . Optionally, it may also include a query test element \u2018<qtest>\u2019 , used for testing purposes.","The MDX markup goes beyond any published markup related to OLAP.","One embodiment of the detailed MDX tree hierarchy is shown in more detail in .","MDX XML Schema","The XML schema is defined in an object-centered fashion.","<olapquerybase> ","The \u2018<olapquerybase>\u2019 element is the root element. It is a container for the sequence of MDX queries. It can also be empty since MLC knowledge bases may have no defined OLAP queries initially.","<mdxquery> ","The \u2018<mdxquery>\u2019 element is defined as an optional and unbounded sequence of mdx queries. Each \u2018<mdxquery>\u2019 element is itself a sequence of three elements: \u2018<header>\u2019, \u2018<body>\u2019, and \u2018<qparams>. An optional fourth element \u2018<qtest>\u2019 is available for testing purposes.","<header> ","The header element represents the header information for a given mdx query. It is used for C# code generation. Each header includes a parameter (optional), a description (header summary), and return values (<hreturn> element).","<hparam> ","The \u2018<hparam>\u2019 element is an optional element, describing declared header parameters. This element has two attributes: name and type. The name is used for the parameter name and the type is used for the corresponding data type. In the following example, one declares the parameter \u2018MeasureID\u2019 of type Integer:","<hparam name=\u201cMeasureID\u201d type=\u201cint\u201d>","<hsummary> ","The \u2018<hsumarry>\u2019 element contains the description and comment for the defined query, as shown in this example:","<hsummary> Select a measure by crossjoin of members<\/hsummary>","<hreturn> ","The \u2018<hreturn>\u2019 element contains a sequence of \u2018<hcolumn>\u2019 elements, where each one of them represents a value returned by the execution of the mdx query. Here is an example with two columns: \u2018Members\u2019 and \u2018MeasureID\u2019:",{"@attributes":{"id":"p-0132","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<hreturn>"]},{"entry":[{},"\u2003\u2003<hcolumn name=\u201cMembers\u201d \/>"]},{"entry":[{},"\u2003\u2003<hcolumn name=\u201cMeasureID\u201d>"]},{"entry":[{},"<\/hreturn>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"162"},"The \u2018<hcolumn>\u2019 element is a single element with and the name attribute representing the name of the return declared column.","<hcolumn name=\u201cCount\u201d\/>","<body> ","The \u2018<body>\u2019 element is the main mdx query element. It contains the query statement itself. This is similar to the body of a rule in the sense that it defines the conditions for the query.","This element contains a non-empty sequence of query items (\u2018<qitem>\u2019 element in the MLC MDX schema). Example of markup:",{"@attributes":{"id":"p-0136","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<body>"]},{"entry":[{},"\u2003\u2003<qitem code=\u201cmdx\u201d> WHERE <\/qitem>"]},{"entry":[{},"\u2003\u2003<qitem code=\u201cattr\u201d name=\u201cPositionCube\u201d><\/qitem>"]},{"entry":[{},"\u2003\u2003<qitem code=\u201cattr\u201d name=\u201cSlice\u201d><\/qitem>"]},{"entry":[{},"<\/body>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"166"},"Each \u2018<qitem>\u2019 element defines a query item, part of the mdx statement. A \u2018<qitem>\u2019 element contains two attribute: The attribute code and the attribute name. The code can be either a mdx keyword such as \u2018WHERE\u2019 or an attribute name. Here is an example:",{"@attributes":{"id":"p-0138","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<qitem code=\u201cmdx\u201d> WHERE <\/qitem>"]},{"entry":[{},"<qitem code=\u201cattr\u201d name=\u201cPositionCube\u201d><\/qitem>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"168"},"The \u2018<qparams>\u2019 element is a container for the sequence of declared parameters for the mdx query. These parameters are referenced and used in the body of the mdx query.","<qparam> ","The \u2018<qparam>\u2019 element has two attributes: type and name to represent the type and the name of each declared query parameter, respectively. A third attribute, \u2018members\u2019, is optional. The example below illustrates that some query parameters include an optional \u2018<tuple>\u2019 element.",{"@attributes":{"id":"p-0141","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<qparams>"]},{"entry":[{},"\u2003\u2003<qparam type=\u201ccube\u201d name=\u201cPositionCube\u201d \/>"]},{"entry":[{},"\u2003\u2003<qparam type=\u201cmeasure\u201d name=\u201cMeasureID\u201d \/>"]},{"entry":[{},"\u2003\u2003<qparam type=\u201cdimension\u201d name=\u201cSliceDim\u201d \/>"]},{"entry":[{},"\u2003\u2003<qparam type=\u201ccrossjoin\u201d name=\u201cSetCrossjoin\u201d><\/qparam>"]},{"entry":[{},"\u2003\u2003<qparam type=\u201ccrossjoin\u201d name=\u201cSetCrossjoinSun\u201d><\/qparam>"]},{"entry":[{},"\u2003\u2003<qparam type=\u201cset\u201d name=\u201cSlice\u201d members=\u201cone\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<tuple>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<dimension name=\u201cSliceDim\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/tuple>"]},{"entry":[{},"\u2003\u2003<\/qparam>"]},{"entry":[{},"<\/qparams>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"172"},"The \u2018<tuple>\u2019 element is defined by the \u2018<qparam>\u2019 element with the attribute \u2018members\u2019. It allows the declaration of a dimension. Here is an example of the markup:",{"@attributes":{"id":"p-0143","num":"0188"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<tuple>"]},{"entry":[{},"\u2003\u2003<dimension name=\u201cSliceDim\u201d \/>"]},{"entry":[{},"<\/tuple>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"174"},"The \u2018<dimension>\u2019 element is defined as part of a \u2018<tuple>\u2019 element, itself defined within a \u2018<qparam>\u2019 element. It has one attribute, name. Markup example:","<dimension name=\u201cSliceDim\u201d\/>","<qtest> ","The \u2018<qtest>\u2019 element is defined for testing purposes only. As such, it is not a required element for the mdx query to be valid with regards to the MLC MDX schema. The \u2018<qtest>\u2019 element contains a sequence of test parameters.","<tparams> ","The \u2018<tparams>\u2019 element is the container of all \u2018<tparam>\u2019 elements.","<tparam>","The \u2018<tparam>\u2019 element is a declaration of a single test parameter for the test query element. Some test parameters are fairly simple and define the parameter name and its corresponding value, as shown in the following example:",{"@attributes":{"id":"p-0148","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<tparam name=\u201cCount\u201d>"]},{"entry":[{},"\u2003\u2003<tparamval>10<\/tparamval>"]},{"entry":[{},"<\/tparam>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Others may include an inclusion or exclusion property when lists are involved (for example, when the parameter is country excluding certain countries), as illustrated in this example:",{"@attributes":{"id":"p-0150","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<tparam name=\u201cCountry\u201d>"]},{"entry":[{},"\u2003\u2003<tparamval>[Country].[Country Code]<\/tparamval>"]},{"entry":[{},"\u2003\u2003<tparammember type=\u2018exclude\u2019>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<item>[FR]<\/item>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<item>[DE]<\/item>"]},{"entry":[{},"\u2003\u2003<\/tparammember>"]},{"entry":[{},"<\/tparam>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"184"},"The \u2018<tparamval>\u2019 element contains the value corresponding to the parent element (test parameter name).","<tparamval>[Industry].[Industry]<\/tparamval>","<tparammember> ","The \u2018<tparammember>\u2019 element is used once exclusion or inclusion lists are involved in the definition of the values corresponding to the test parameter (parent element). Here is an example:",{"@attributes":{"id":"p-0153","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<tparammember type=\u2018include\u2019>"]},{"entry":[{},"\u2003\u2003<item>[FUN]<\/item>"]},{"entry":[{},"\u2003\u2003<item>[CNS]<\/item>"]},{"entry":[{},"<\/tparammember>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"182"},"The \u2018<item>\u2019 element is used to list a collection of values as part of an exclusion or an inclusion list, as shown in the example in section 3.1.18.","The knowledge elements defined in  are the basis of the design and implementation of the repository. They are stored in the database  shown in .","With reference to , a user can enter a rule via a Rule Editor User Interface (UI). In the illustrated example, the user has specified via a set of inputs, e.g., drop-down menus and input fields, the following rule: \u201cThe weight based on Net Assets of investments where SecurityAssetCode is equal to CS must be less than 70%.\u201d","One of the available representations for each rule is its \u201ctext representation\u201d, accessible from the Rule Editor. This is intended to be as close to the natural language expression of that rule as possible. Once the above rule is entered, its text representation is:","\u201cThe weight based on Net Assets of investments where SecurityAssetCode is equal to CS must be less than 70%\u201d","Rule Gist (a Rule Object Model)","The Rule Gist is the internal extensible markup language (XML) representation that the Editor and the Translator use to communicate with each other. As noted above, Appendix II provides one embodiment of a rule grammar specification for a structured standard grammar language close to Backus Naur form (BNF) standard syntax. Using this specification, a person of ordinary skill in the art can create a rule editor and a natural language grammar that support the rule expressions provided in the compliance engine of the present invention.","The Rule Gist XML representation is a hierarchical form that captures the structure of the rule along with all referenced values used by the editor. In our example the generated Rule Gist file is:",{"@attributes":{"id":"p-0162","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<RuleGist ruleTypeID=\u201cMinMaxRange\u201d>"]},{"entry":[{},"\u2003<RuleData>"]},{"entry":[{},"\u2003\u2003<Factor factor=\u201cweight\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<denominator name=\u201cnet assets\u201d \/>"]},{"entry":[{},"\u2003\u2003<\/Factor>"]},{"entry":[{},"\u2003\u2003<Scope code=\u201cInvestments\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<RExpr>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<FirstExpr>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<LExprElements>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<LExprElement openingParentheses=\u201c0\u201d"]},{"entry":[{},"closingParentheses=\u201c0\u201d negated=\u201cfalse\u201d jointType=\u201cNone\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Predicate useQClause=\u201cfalse\u201d"]},{"entry":[{},"attribute=\u201cSecurityAssetCode\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Clause>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Comparison firstValue=\u201cCS\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<Comparator chosen=\u201c1\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/Comparison>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/Clause>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/Predicate>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<\/LExprElement>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<\/LExprElements>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/FirstExpr>"]},{"entry":[{},"\u2003\u2003\u2003<\/RExpr>"]},{"entry":[{},"\u2003\u2003<\/Scope>"]},{"entry":[{},"\u2003\u2003<Comparison firstValue=\u201c70\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<Comparator chosen=\u201c4\u201d \/>"]},{"entry":[{},"\u2003\u2003<\/Comparison>"]},{"entry":[{},"\u2003<\/RuleData>"]},{"entry":[{},"<\/RuleGist>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"CLIPS Rule Set","As noted above, one of the Rule Translator's outputs is a set of CLIPS rules representing the translated Compliance Rule. The generated set in our example is attached here:","Simple Service rule that creates an internal list of all the referenced Security Asset Codes (in this case it's just the one-element list {CS}; additional AND\/OR clauses in the original rule would cause this list to grow",{"@attributes":{"id":"p-0165","num":"0210"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"; List Creation Service Rule"]},{"entry":[{},"(defrule list_C1_0"]},{"entry":[{},"\u2003\u2003(MLCDomain_XipBusinessObjectSet"]},{"entry":[{},"\u2003\u2003\u2003\u2003(OBJECT ?xbos)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"=>"]},{"entry":[{},"\u2003\u2003(create-lists ?xbos \u201cC1\u201d SecurityAssetCode:1:CS)"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0166","num":"0211"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},";; Aggregate Fetching Service Rule"]},{"entry":[{},"(defrule qry_C1"]},{"entry":[{},"\u2003\u2003(MLCDomain_XipBusinessObjectSet"]},{"entry":[{},"\u2003\u2003\u2003\u2003(OBJECT ?xbos)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"\u2003\u2003(MLCDomain_AggregationFactory"]},{"entry":[{},"\u2003\u2003\u2003\u2003(OBJECT ?aggrfac)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"\u2003\u2003(MLCDomain_MxwsModifiedAccount"]},{"entry":[{},"\u2003\u2003\u2003\u2003(userCode ?userCode)"]},{"entry":[{},"\u2003\u2003\u2003\u2003(accountCode ?accountCode)"]},{"entry":[{},"\u2003\u2003\u2003\u2003(OBJECT ?modAcc)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"\u2003\u2003;; Fetch the account list for rule \u201cC1\u201d to see if it's"]},{"entry":[{},"applicable"]},{"entry":[{},"\u2003\u2003(MLCDomain_MxwsDataList"]},{"entry":[{},"\u2003\u2003\u2003\u2003(ruleCode \u201cC1\u201d)"]},{"entry":[{},"\u2003\u2003\u2003\u2003(exclude FALSE)"]},{"entry":[{},"\u2003\u2003\u2003\u2003(listBasis 0)"]},{"entry":[{},"\u2003\u2003\u2003\u2003(OBJECT ?aclist)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"\u2003\u2003;; call isMember to test, only continue if this rule"]},{"entry":[{},"applies"]},{"entry":[{},"\u2003\u2002;; to ?accountCode (coming from the IMS message)"]},{"entry":[{},"\u2003\u2003(test (call ?aclist isMember ?accountCode) )"]},{"entry":[{},"\u2003\u2003(MLCDomain_MxwsSecurity"]},{"entry":[{},"\u2003\u2003\u2003\u2003(securityCode ?tick)"]},{"entry":[{},"\u2003\u2003\u2003\u2003(securityAssetCode ?securityAssetCode)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"\u2003\u2003(MLCDomain_MxwsDataList"]},{"entry":[{},"\u2003\u2003\u2003\u2003(ruleCode \u201cC1\u201d)"]},{"entry":[{},"\u2003\u2003\u2003\u2003(listBasis 7)"]},{"entry":[{},"\u2003\u2003\u2003\u2003(OBJECT ?list0)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"\u2003\u2003(test (call ?list0 isMember ?securityAssetCode) )"]},{"entry":[{},"\u2003\u2003(not"]},{"entry":[{},"\u2003\u2003\u2003\u2003(MLCDomain_Aggregation"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003(key \u201c11.3.0.7.F\u201d)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003(sliceValue ?accountCode)"]},{"entry":[{},"\u2003\u2003\u2003\u2003)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"=>"]},{"entry":[{},"\u2003\u2003(create-aggregate2 ?aggrfac ?modAcc \u201c11.3.0.7.F\u201d \u201c3\u201d"]},{"entry":[{},"\u201caccountCode\u201d ?acco"]},{"entry":[{},"untCode ?list0)"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0167","num":"0212"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},";; Condition creation service rule"]},{"entry":[{},"(defrule compare_C1"]},{"entry":[{},"\u2003\u2003(MLCDomain_XipBusinessObjectSet"]},{"entry":[{},"\u2003\u2003\u2003\u2003(OBJECT ?xbos)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"\u2003\u2003;; we will match on compare object"]},{"entry":[{},"\u2003\u2003(not"]},{"entry":[{},"\u2003\u2003\u2003\u2003(MLCDomain_Compare"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003(ruleCode \u201cC1\u201d)"]},{"entry":[{},"\u2003\u2003\u2003\u2003)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"=>"]},{"entry":[{},"\u2003\u2003;; create compare object"]},{"entry":[{},"\u2003\u2003(bind ?compare (new MLCDomain.Compare) )"]},{"entry":[{},"\u2003\u2003(call ?compare setRuleCode \u201cC1\u201d)"]},{"entry":[{},"\u2003\u2003(call ?compare setRuleType \u201cMin\/Max\/Range\u201d)"]},{"entry":[{},"\u2003\u2003(call ?compare setExceptionOperator \u201cless than\u201d \u201c70\u201d)"]},{"entry":[{},"\u2003\u2003(definstance MLCDomain_Compare ?compare)"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0168","num":"0213"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},";; Terminal Rule"]},{"entry":[{},"(defrule C1"]},{"entry":[{},"\u2003\u2003(MLCDomain_XipBusinessObjectSet"]},{"entry":[{},"\u2003\u2003\u2003\u2003(OBJECT ?xbos)"]},{"entry":[{},"\u2003\u2003)"]},{"entry":[{},"\u2003\u2003(MLCDomain_MxwsModifiedAccount"]},{"entry":[{},"\u2003\u2003(userCode ?userCode)"]},{"entry":[{},"\u2003\u2003(accountCode ?accountCode)"]},{"entry":[{},"\u2003\u2003(OBJECT ?modAcc)"]},{"entry":[{},")"]},{"entry":[{},";; we use DataList to test if the account applies"]},{"entry":[{},"(MLCDomain_MxwsDataList"]},{"entry":[{},"\u2003\u2003(ruleCode \u201cC1\u201d)"]},{"entry":[{},"\u2003\u2003(exclude FALSE)"]},{"entry":[{},"\u2003\u2003(listBasis 0)"]},{"entry":[{},"\u2003\u2003(OBJECT ?aclist)"]},{"entry":[{},")"]},{"entry":[{},";; call isMember to test"]},{"entry":[{},"(test (call ?aclist isMember ?accountCode) )"]},{"entry":[{},"(MLCDomain_Compare"]},{"entry":[{},"\u2003\u2003(ruleCode \u201cC1\u201d)"]},{"entry":[{},"\u2003\u2003(OBJECT ?compare)"]},{"entry":[{},")"]},{"entry":[{},"(MLCDomain_Aggregation"]},{"entry":[{},"\u2003\u2003(sliceValue ?accountCode)"]},{"entry":[{},"\u2003\u2003(measure ?accTotal)"]},{"entry":[{},"\u2003\u2003(newMeasure ?aggNTV)"]},{"entry":[{},"\u2003\u2003(key \u201c10.3.0\u201d)"]},{"entry":[{},"\u2003\u2003(OBJECT ?accAggrTV)"]},{"entry":[{},")"]},{"entry":[{},"(MLCDomain_Aggregation"]},{"entry":[{},"\u2003\u2003(sliceValue ?accountCode)"]},{"entry":[{},"\u2003\u2003(measure ?aggTV0)"]},{"entry":[{},"\u2003\u2003(newMeasure ?newTV0)"]},{"entry":[{},"\u2003\u2003(key \u201c11.3.0.7.F\u201d)"]},{"entry":[{},"\u2003\u2003(OBJECT ?accAggr0)"]},{"entry":[{},")"]},{"entry":[{},"(test (call ?compare check ?accAggr0 ?accAggrTV) )"]},{"entry":[{},"=>"]},{"entry":[{},"\u2003\u2003;; create the exception event object"]},{"entry":[{},"\u2003\u2003(create-exception2 ?xbos \u201cC1\u201d \u201c0.1\u201d ?modAcc ?aclist \u201c\u201d"]},{"entry":[{},"70 \u201cC\u201d \u201cMLCDomain_Compare\u201d"]},{"entry":[{},"?compare \u201cMLCDomain_Aggregation\u201d ?accAggr0"]},{"entry":[{},"\u201cMLCDomain_Aggregation\u201d ?ac"]},{"entry":[{},"cAggrTV)"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"From a technology perspective, the present invention overcomes current problems associated with developing real-time flexible and scalable portfolio compliance systems. The invention overcomes these problems through the successful integration of declarative rules and OLAP technologies. Service Rules and the Knowledge Maintenance Framework facilitate this success. The present invention integrates OLAP and Rules technologies to achieve scalable real-time execution performance while maintaining a semantic range that is flexible enough to support user defined business rules. In other words, one embodiment of the present invention integrates RETE-base rules systems, OLAP systems. RDBMS systems, Web Services, Object Oriented Systems and procedural 3GLs (e.g. C#).","Having thus described at least one illustrative embodiment of the invention, various alterations, modifications and improvements are contemplated by the invention. Such alterations, modifications and improvements are intended to be within the scope and spirit of the invention. Accordingly, the foregoing description is by way of example only and is not intended as limiting. The invention's limit is defined only in the following claims and the equivalents thereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE ILLUSTRATED EMBODIMENTS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 1A"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3A","FIG. 2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3B","FIGS. 1-3A"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 5A","FIGS. 1-3B"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 5B","FIGS. 1-3B"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIGS. 6A and 6B","FIG. 2","FIGS. 6A and 6B","FIGS. 1 and 2"],"b":"36"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 7","FIGS. 1A and 1B"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 8","FIGS. 1A and 1B"]}]},"DETDESC":[{},{}]}
