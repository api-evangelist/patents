---
title: Tracking queries and retrieved results
abstract: Various embodiments of systems and methods for tracking queries and retrieved results are described herein. In one aspect, a first query is associated with a first result set in a first tuple and a second query is associated with a second result set in a second tuple. The first result set is retrieved based on the execution of the first query and the second result set is retrieved based on the execution of the second query. The first and the second tuples are retained in a data structure in the order of execution of the respective queries. The retrieved result sets may be accessed forwards or backwards along the data structure without re-execution of the queries.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09020969&OS=09020969&RS=09020969
owner: SAP SE
number: 09020969
owner_city: Walldorf
owner_country: DE
publication_date: 20110713
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The field relates generally to data processing and digital processing systems. More specifically, the field is related to tracking query execution and retrieved results within a distributed computer systems environment.","There are various ways for storing, organizing, or otherwise manipulating large amounts of data. Typically, representations of information are implemented as sets of entities that are related via associations, where entities of a given set share common attributes. Common example of representations of information is relational databases, where a table is a set of entities that have same attributes. Table rows represent entities, table columns represent attributes and tables are related to each other via foreign key associations. Another example is business objects, where a business object represents an entity with certain properties, i.e. attributes, and relates to other business objects.","Usually, subsets of data are retrieved and\/or manipulated at a time, as working with an entire data collection at the same time may be unfeasible or inefficient, e.g., for performance reasons, technical limitations and the like. A common approach is using queries based on specific criteria to retrieve subsets of data to be further processed. An alternative approach is using iterators to access one entity at a time, such as a row cursor or an eXtensible Markup Language (XML) node iterator. Usually, the executed queries and the respective result sets retrieved based on the queries are not retained. The relation between a query and a corresponding result set, the execution order of the queries, e.g., the steps of queries execution determining how and in what order result sets are obtained, are not stored. In many cases, there is a need for analyzing result sets by inspecting the execution order of the respective queries.","Various embodiments of systems and methods for keeping record of queries execution order and retrieved results are described herein. In one aspect, a first query is associated with a first result set in a first tuple and a second query is associated with a second result set in a second tuple. The first result set is retrieved based on the execution of the first query and the second result set is retrieved based on the execution of the second query. The first and the second tuple are retained in a data structure. In another aspect, the first and the second tuple are arranged in the data structure according to the order of execution of the first query and the second query.","These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof, presented in connection with the following drawings.","Embodiments of techniques for keeping record of queries execution order and retrieved results are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","In computer systems, information result sets are retrieved following the execution of queries, e.g., database queries, an XML queries, etc. Often, a result set is manipulated and, as a consequence, it may change. The link between a query and the modified result set may be broken. From the modified data it cannot be inferred based on what query that data was retrieved. Often, there is a need to retain relations between queries and their corresponding result sets, even after the result sets have been altered.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","110"]},"In one embodiment, queries may be described using Abstract Syntax Tree path (ASPath) commands to retrieve data from an Abstract Syntax Tree (AST) or a Symbol Table (ST) of a program code. ASPath refers to SAP\u00ae AG proprietary internal query language for XPath like navigation in ASTs. A ST is a data structure, where identifiers of a program code are mapped or are associated with relevant metadata such as type, scope, size, address in the memory, etc. A ST is a data structure used by a compiler to keep track of semantics of identifiers used in a program. An AST is a tree representation of the abstract syntactic structure of a source code written in a programming language, where AST nodes represent constructs of the source code. Both the AST and the ST are internal data structures used by a compiler or an interpreter to organize and manipulate program code. Entries of a ST include identifiers and metadata of those identifiers. ST entries are associated with relevant AST nodes. The AST nodes represent constructs of the program code where the identifiers occur.","Referring back to , at , a first result set of entities is retrieved based on the execution of the first query. In one embodiment, a result set of entities may be organized in a database table, where table rows represent entities and table columns represent attributes that these entities share. Next, at , the first query is associated with the first result set in a first tuple. In this document, the term \u201ctuple\u201d means data structure combining a query and respective result set of entities as a discrete unit. Next, at , the first tuple is retained in a storage. In one embodiment, the storage keeps a number of queries and corresponding result sets as tuples, preserving the execution order of the queries.","At , a second query is executed. Based on the execution of the second query, a second result set of entities is retrieved at . Next, at , the second query is associated with the second result set of entities in a second tuple. At , the second tuple is retained in the storage. In one embodiment, the process ends at  with arranging the first and the second tuple in a data structure according to the query execution order. In one embodiment, the data structure may be, including but not limited to, a list of tuples, a graph structure, etc.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2","b":["200","200","280","290","285","200"]},"Client system  executes one or more computer applications, including but not limited to, user interfaces such as query interface . Client system  may include a browser or other client applications to interact with server system  via network . Query interface  may include one or more graphical user interface (GUI) elements used to receive queries, trigger queries execution and display query result sets.","Server system  includes, among other components, query engine . In one embodiment, query interface  is configured to interact with query engine . Query engine  may process queries received from query interface  to retrieve result sets of entities. The result sets may be returned to client system , e.g. to query interface  and displayed by the GUI elements. In one embodiment, processed queries and corresponding result sets of entities may be organized in data structure . For example, the processed queries ,  and , and the result sets of entities ,  and , retrieved based on the execution of the queries, may be retained in storage  and arranged in the data structure . In one embodiment, data structure  may be a linked list of tuples. For example, query  and result set of entities  are associated in tuple , query  and result set of entities  are associated in tuple , and query  and result set of entities  are associated in tuple , where tuples ,  and  are organized in linked list data structure . Alternative embodiments may utilize other kinds of data structures.","The server system  further includes compiler  that translates program source code , i.e. a sequence of characters, into abstract syntax tree (AST) . Program source code  may be written in any programming language such as JAVA, C\/C++\/C#, ABAP, etc. Compiler  also creates symbol table (ST)  of identifiers used in the program source code . In one embodiment, ST  may be a hash table. Queries ,  and  may include ASPath commands to query AST  and ST .","In one embodiment, queries ,  and  and result set of entities ,  and , may be organized in data structure  in their order of execution and retrieval. For example, if query  is processed first by query engine , tuple  is arranged as the first tuple of data structure . Accordingly, if query  is executed next, tuple  is arranged as second in data structure , and so on. Finally, if query  is executed last, then tuple  is ordered as last in data structure .","In , tuples in data structure  may be accessed via query interface . In one embodiment, a current query and a corresponding result set of entities may be displayed and accessed via query interface . An entity of a given result set of entities may be accessed via query interface , e.g. as a row iterator. Tuples ,  and  may be displayed and accessed in parallel. Furthermore, result sets ,  and  in data structure  are accessible without re-executing corresponding queries ,  and .","In , system  is an exemplary system for tracking queries and result sets, according to one embodiment. Computing systems with structure different from the one illustrated with system  may be used as well for tracking queries and retrieved result sets of entities. For example, some of the components illustrated in server system  may be distributed across other systems communicating with each other via network . The program source code , compiler , AST , ST , query engine  and storage  may operate independently from each other and need not be necessarily integrated into a single system node. For example, storage  may be a back-end node such as database server. Compiler , query engine  and program source code  may be modules of a separate server node, or distributed across multiple systems. AST  and ST  may be persisted in storage  and\/or in volatile memory of server system  (not illustrated). A specialist in the field would recognize that there are other possible variants for the architecture of system  corresponding to different embodiment.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","b":["300","310","320","330","340","271"]},"The first result set of entities may be used as source data over which the second query is executed. At , a second query is executed over at least one entity of the first result set of entities. At , a second result set of entities is retrieved based on the execution of the second query over the at least one entity of the first result set. For example, in , query  may retrieve data for the variables used in a given method of program source code . Then, query  may retrieve variable types associated with the variables used in the method. Thus, result sets of preceding queries provide source data over which successive queries to be executed.","At , the second query is associated with the second result set of entities in a second tuple. At , the second tuple is included in the data structure. In one embodiment, the process ends at  with arranging the first and the second tuple in the data structure according to the query execution order.","In one embodiment, the data over which the second query is executed, i.e. the at least one entity of the first result set, may be used as source data for other subsequent queries as well. Thus, one result set of entities may be used as data over which one or more subsequent queries may be executed. For example, in case the second query is executed over the first result set of entities, a third query may be executed over the first result set as well. Accordingly, tuples may be arranged not in a linear sequence such as a linked list of tuples, but in a tree structure. For example, the first tuple may be the parent node in the formed tree data structure, while the second and the third tuples are parallel child nodes, e.g., child nodes at same sublevel of the data structure.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["400","410","420","430","440","271","450"]},"At , the second query is executed. A second result set of entities is retrieved at  based on the execution of the second query, where the second query is built using one or more entities of the first result set. At , the second query is associated with the second result set of entities in a second tuple. At , the second tuple is retained in the data structure. In one embodiment, the process ends at  with arranging the first and the second tuple in the data structure according to the query execution order.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 5","b":["500","510","515","520","525"]},"At , corresponding entities of the first and the second result sets are related. At , a check is performed whether all entities of the second result set are related to entities of the first result set. If there are unrelated entities of the second result set, at , for every entity of the second result set that is not related to entity of the first result set, a default entity is added to the first result set. In one embodiment, a default entity may be a \u201cnull\u201d entity. At , every unrelated entity of the second result set is related to a default entity. Otherwise, if all entities of the second result set are related to entities of the first result set in , a check is performed whether all entities of the first result set are related to entities of the second result set at . Similarly, if there are unrelated entities of the first result set, at , for every entity of the first result set that is not related to entity of the second result set, a default entity is added to the second result set. At , every unrelated entity of the first result set is related to a corresponding default entity of the second result set.","The process  continues at  with associating the first query with the first result set in a first tuple. At , the second query is associated with the second result set in a second tuple. At , the first and the second tuples are retained in a data structure. In the data structure tuples are arranged according to order of execution of the respective queries, e.g. as illustrated with data structure  in .","In one embodiment, the first and the second result sets may be related in one-to-one relationship. That is, for every entity of the second result set, there is one corresponding entity of the first result set. In case the first and the second result sets are related in one-to-one relationship, in one embodiment, the entities of the first and the second result sets are ordered in the respective tuples to correspond to the established relations between the entities. The order of the entities in the first and the second tuple match to the relations between the entities. Thus, relations between entities may be retained by ordering related entities in the tuples to correspond to each other. An example is given further below with reference to  and .","In other embodiments, however, entities may be sorted or duplicate entities removed, e.g. retrieving only distinct entities. In such cases, the order of the entities in the first and the second tuple may not correspond to established relations between the entities.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 6","b":["600","610"]},"At , a request for accessing preceding or successive tuple to the currently accessed tuple is received. The preceding or successive tuple are respectively ordered in the data structure. In one embodiment, the access request may be received via query interface  as illustrated in . At , a check is performed whether request for accessing a preceding tuple is received. If request to access a preceding tuple is received, at , a check is performed whether there is a preceding tuple retained in the data structure. If there is no preceding tuple, the process ends. Otherwise, at , the preceding tuple is accessed. At , the preceding tuple becomes the currently accessed tuple and the process ends. Thus, backwards access to tuples is enabled without the need of new execution of the preceding queries.","If request to access a preceding tuple is not received, at , then request for accessing successive tuple is received. At , a check is performed whether there is a successive tuple retained in the data structure. If there is no successive tuple, the process ends. Otherwise, at , the successive tuple is accessed. At , the successive tuple becomes the currently accessed tuple and the process ends. Thus, forward access to tuples is enabled without the need of new execution of the successive queries.","By moving forwards or backwards or otherwise navigating along the sequence of tuples retained in the data structure, the executed queries, the retrieved results and the existing relationships and dependencies may be analyzed without re-executing the respective queries. Furthermore, the order in which queries are executed and result sets retrieved may be analyzed as well.","In one embodiment, while navigating along the sequence of tuples retained in the data structure, only result sets of the respective tuples may be accessed and analyzed. In yet another embodiment, only queries may be accessed.","Back to , if tuple  is currently displayed or otherwise accessed, access to the preceding tuple in data structure , e.g., tuple  may be requested via query interface . In one embodiment, if the currently accessed tuple switches from tuple  to tuple , in response to a backward access request, tuple  may be kept in the data structure  on storage  or it may be no longer retained. In case tuple  is retained, it could be accessed from tuple  without re-execution of query  according to process , e.g. forward access. Thus, no re-execution of queries - is required when moving forwards or backwards along the sequence of tuples retained in data structure .","In one embodiment, as opposite to tracking and accessing tuples one by one, simultaneous access to a number of tuples retained in the data structure may be enabled. Accordingly, in other embodiments, simultaneous access to a number of queries or a number of result sets may be enabled.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 7","b":["700","710","720"]},"At , a change of an entity of the first result set of entities is received. In one embodiment, a request for changing one or more entities of the first result set of entities may be received. For example, a user may change one or more attributes of one or more entities of a retrieved result set. Referring back to , all variables of a given method in ST  may be retrieved based on query , and one of the variables may be an array of type integer and length . The attributes type and length of the array may be changed via query interface . At , in response to the change at , the entity of the first result set is alerted. Furthermore, in response to the change at , the process  ends at  with altering an entity of the second result set of entities. In one embodiment, there is a relationship between the altered entity of the first result set and the consequently altered entity of the second result set. For example, the altered entities may share a common attribute that is changed. Thus, the change of the first result set is propagated in the second result set by changing the corresponding one or more related entities of the second result set.","For example, referring again to , all types of variables of a given method previously retrieved from ST  may be obtained based on an execution of a subsequent query, e.g., query  when the variables are retrieved based on the execution of query . Thus, in case the type of the retrieved array variable is changed, e.g., from integer to floating, the change may be reflected in result set  as well. In one embodiment, the change of a result set may be reflected not only by changing a related result sets, e.g, in the data structure , but also by changing the underlying data over which queries are executed, e.g. the data in ST  and AST  may be changed corresponding to a change in one or more of the result sets -.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 8","FIG. 2"],"b":["800","810","810","810","810","210","220","810","240","230"]},"In one embodiment, program  may displayed in a graphical user interface (GUI), and parts of the program  may be selected for querying the generated ST and AST. For example, in , variable , i.e. data \u201ca\u201d, is selected. Additionally, definition  of class , e.g., class \u201ca\u201d, the corresponding declaration of method  (e.g. method \u201ca\u201d of class ); and the respective implementation of method \u201ca\u201d, i.e. method  are selected for querying the relevant ST and AST of the code. In one embodiment, queries for ST and AST may be written or generated as ASPath commands.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 9A","FIG. 8","FIG. 2"],"b":["900","900","287"]},"In one embodiment, a query  may be entered in field , where the queried data are the ST and the AST of sample program  (). In one embodiment, query  is written as a ASPath command:\n\n","SELECT*FROM Phenotypes WHERE name=\u2018A\u2019","In these example queries \u201cstp\u201d and \u201cPhenotypes\u201d may correspond to symbol table (ST), abstract syntax tree (AST), or to both, and \u201cname\u201d may address identifier of a program, according to one embodiment.","There are different categories that group identifiers of a ST into different namespaces. Examples of namespaces include symbol table phenotypes (\u201cstp\u201d) and symbol table entries (\u201cste\u201d). Symbol table entries include identifiers and environment information for each identifier in a symbol table, where an environment groups a collection of identifiers. The relation between environments defines the relative visibility of the identifiers. \u201cPhenotypes\u201d provide additional semantic information about symbol table entries based on their category such as type information","The execution of query  may be triggered via button \u201cexecute\u201d , and result set of entities  is retrieved and displayed in result table . In the illustrated example result set  includes four entities represented as table rows of result table . The columns of table  represent attributes of the entities of the result set of entities . For example, CATEGORY, ID, TYPE, NAME, etc. are attributes or properties that the entities of the result set  share and these attributes are respectively represented by column , ,  and . In one embodiment, the values of the attributes ID and TYPE are hardcoded.","Referring back to , query  selects one field with name \u201cA\u201d, i.e. variable , one class with name \u201cA\u201d, e.g., class  and two entities for method \u2018A\u2019, i.e. declaration of method \u201cA\u201d  and implementation of method \u201cA\u201d . In one embodiment, the first row is automatically selected as the current row, i.e. the first entity from the retrieved result set of entities. In other embodiments, a random entity, a subset of entities of the result set or the whole result set of entities may be selected as current rows.","Referring back to , the first query may be query  and the first result set of entities may be result set , where result set  is retrieved based on the execution of query . Furthermore, according to process , query  and result set  may be retained in a data structure, such as data structure  in , as a first tuple. The first tuple, e.g., tuple  in , associates query  and result set .",{"@attributes":{"id":"p-0065","num":"0065"},"figref":["FIG. 9B","FIG. 8"],"b":["905","810","920","914","810","920"],"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":"@ stp:entry"}}}},"In one embodiment, \u201cstp\u201d, e.g., symbol table phenotypes, and the ST entries are associated in a one-to-one relationships. That is, for every symbol table phenotype there is a corresponding symbol table entry.","Referring back to , the execution of query  may be triggered via button \u201cexecute\u201d , and result set of entities  is retrieved and displayed in result table . Query  selects for each phenotype a corresponding associated entry. Result set  includes four entities, where the entities are represented as table rows of result table .","In one embodiment, referring back to , the second query may be query  and the second result set of entities may be result set , where result set  is retrieved based on the execution of query . According to process , query  and result set  may be retained in the data structure as a second tuple, such as tuple  in , associating query  and result set . Furthermore, the data structure arranges the first and the second tuple according to the query execution order. For example, since query  in  is executed first and query  in  is executed second, the tuple associating query  with result set  is arranged to precede the tuple associating query  with result set  in the data structure.","In one embodiment, referring back to , according to process , relations between the entities of result set  in  and the entities of result set  in  may be retained. For example, the entity in the first row of result table  may be related to the entity in the first row of result table , the entity in the second row of result table  may be related to the entity in the second row of result table , and so on.",{"@attributes":{"id":"p-0070","num":"0071"},"figref":["FIG. 10A","FIG. 10B","FIG. 9B","FIG. 10A","FIG. 8"],"b":["1000","1005","940","1010","1012","810","1010"],"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":"@stp: phenotype"}}}},"In the illustrated example, the first row in result table  is highlighted to mark it as selected, e.g., the first entity from the retrieved result set  is the current entity. Result set  is retrieved based on the execution of query  in . A user may check checkbox , e.g., \u201con selected line\u201d. Given that check box  is ticked, a subsequent query would be executed over the selected entities, e.g. the entity in the first row of result table . Thus, based on the execution of query , e.g., triggered via button \u201cexecute\u201d , result set of entities  is retrieved and displayed in result table  in . Based on the execution of query  over the selected entity of result set , the corresponding phenotype for the selected symbol table entry is retrieved.","Referring back to , according to process , the first query may be query  in  and the first result set of entities may be result set , where result set  is retrieved based on the execution of query . Query  is associated with result set  in a first tuple. Second query may be query  in , where query  is executed over the selected entity in the first row of result table . Result set  in  is retrieved based on the execution of query  over the selected entity of result set . Query  is associated with result set  in a second tuple. According to process , the first and the second tuples are retained in a data structure such as data structure  and arranged according to the execution order of query  and query .","In one embodiment, via clicking on button  labeled \u201cprevious result\u201d, the previous query and the corresponding result set may be displayed, i.e. query  and result set . Thus, moving along, navigating or otherwise accessing retained queries and result sets may be accomplished without re-execution of the queries, according to one embodiment.","Some embodiments of the invention may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. Examples of computer readable storage media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (\u201cASICs\u201d), programmable logic devices (\u201cPLDs\u201d) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment of the invention may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment of the invention may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0076","num":"0078"},"figref":"FIG. 11","b":["1100","1100","1105","1155","1100","1140","1155","1110","1115","1110","1115","1105","1115","1100","1125","1130","1100","1125","1130","1100","1135","1100","1150","1150","1100","1145","1100","1120","1160","1160","1160","1150","1160"]},"A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a markup language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as, Open DataBase Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however that the invention can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.","Although the processes illustrated and described herein include series of steps, it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps, as some steps may occur in different orders, some concurrently with other steps apart from that shown and described herein. In addition, not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover, it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.","The above descriptions and illustrations of embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather, the scope of the invention is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments of the invention with particularity. The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
