---
title: Method and apparatus for providing print job status
abstract: An apparatus and methods facilitate collection of print job status information. A first method configures a computer to obtain status information for subsequent print jobs to a printer. The first method supplies a proxy printer driver in place of an actual printer driver associated with the printer. The first method may hook a function in the actual printer driver. The first method may also configure the computer to spool RAW datatype to the printer. The first method may also store a unique identifier of the computer in the registry. The first method may also set a flag within the registry so as to indicate that the computer is able to provide status for print jobs on the printer. A second method gathers print status for a print job from a computer to a printer. The second method executes a proxy printer driver while producing the print job, wherein the proxy printer driver is a proxy for an actual printer driver. The second method inserts into the print job a unique identifier of the print job. The second method also queries at least one of a spooler and the printer regarding status of the print job. Optionally, the second method may detect inception of the print job and produce a notification of the status of the print job. In executing the proxy printer driver, the second method preferably receives a call to a function and calls a corresponding function in the actual printer driver. In some embodiments, the proxy printer driver produces RAW data. The apparatus is a computer readable medium on which is embedded a computer program. The program comprises a proxy printer driver translation part, the proxy printer driver translation part being a proxy for an actual printer driver translation part. Optionally, the program comprises one or more of a status configuration utility, a status monitor, a spooler comprising a port monitor, a graphic device interface, a registry, the actual printer driver translation part and an application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07106465&OS=07106465&RS=07106465
owner: Hewlett-Packard Development Company, L.P.
number: 07106465
owner_city: Houston
owner_country: US
publication_date: 20001101
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT","V. CONCLUSION"],"p":["This invention relates generally to computer controlled printing of documents, and more particularly to the collection of status information regarding print jobs.","End-users of computer systems often desire status information regarding print jobs. Existing system and application software provide end-users with mechanisms for obtaining print job status on current WINDOWS\u2122 operating systems, but these mechanisms often fall short of meeting the expectations of users. These mechanisms include the \u201cPrinters\u201d folder provided by MICROSOFT WINDOWS\u2122 and the DOCWISE\u2122 package provided by Hewlett-Packard Company, Palo Alto, Calif.","A WINDOWS\u2122 user can click on a printer icon in the \u201cPrinters\u201d folder or double-click on the printer icon in the task bar to view a window , as illustrated in , containing status information related to her print jobs. Unfortunately, this status might be more accurately called \u201cprint queue status.\u201d The window  shows a list of jobs waiting to be sent to the printer. As each job is sent to the printer, it is removed from the list regardless of whether or not it has completed printing. The state of the printer is displayed provided that a job is currently printing. Most printers have a buffer of memory for accepting incoming jobs. Often, this buffer provides more than enough storage to accommodate the job. This causes all of the print job data to flow into the printer buffer, which removes the print job from the printer status window . The print job might suffer from any number of problems while being processed by the printer; however, WINDOWS\u2122 has no provision for informing the user of these problems. Once the print job data has been transmitted outside of the operating system, WINDOWS\u2122 considers the job completed successfully, despite the fact that end-users do not share this optimism and this behavior does not meet end-users' expectations.","Recognizing these problems, Hewlett-Packard has developed software that independently provides print job status. This software is called DOCWISE\u2122. In use, DOCWISE\u2122 displays a print job status window , as shown in , when an end-user has requested notification. If the end-user requests notification when his print job has completed, the window  is displayed at that time. If the end-user requests notification when a problem is encountered while processing his print job, the window  is displayed at that time. The notification behavior is configurable.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3","b":["300","300","310","315","310","300","320","330","340","350","320","330","360","320","315","370","320","375","315","310","315","360","360","330","360","375","360","330","330","360","330","380"]},"The registry  is a collection of settings in the WINDOWS\u2122 operating system. These settings are used by the modified port monitor  and the status monitor . The status monitor  is responsible for monitoring print job status. The status monitor  detects the initiation of a print job and tracks the job as it is processed by the source computer system and the target printer. More specifically, DOCWISE\u2122 detects when a print job is initiated, determines the WINDOWS\u2122 ID (identification) of the job in order to track it within the spooler , and uniquely marks the job so that it can be identified within the printer. These steps will now be explained in greater detail.","The WINDOWS\u2122 NT 4.0 operating system provides convenient APIs (application programming interfaces) that provide notification of when a job is initiated. The APIs FindFirstPrinterChangeNotification and FindNextPrinterChangeNotification can be used with the flag PRINTER_CHANGE_JOB to monitor for the initiation of a new print job. Once notified of the existence of a new job, the spooler  can quickly be queried for the most recently added job using the EnumJobs API. Once the job in the spooler  has been identified, its job ID can be obtained.","The task of marking the print stream with a unique identifier can be divided into three subtasks: (1) determining a unique identifier; (2) insuring that the unique identifier is known to the status monitor ; and (3) inserting commands that are required to mark the print stream. DOCWISE\u2122 constructs a unique identifier by forming a combination of the network identifier of the source computer and the local print job ID. The unique identifier is then unique everywhere on the network, not just on the local machine. The network identifier of the local machine can be stored in the registry  and retrieved as required. Because the registry is easily accessible to programs, the network identifier can be reliably obtained anywhere it might be required (i.e. for inserting the commands required to mark the print stream). The local print job ID is also available throughout much of the operating system. As described above, the status monitor  can obtain the local print job ID by immediately querying the spooler . The local print job ID is also made available to kernel programs (which are not able to call normal API functions), such as the modified printer driver translation part .","DOCWISE\u2122 inserts the commands that are required to mark the print stream in two steps. First, the modified printer driver configuration part  gathers the information that is required to mark the print stream and places this information into the DEVMODE (\u201cdevice mode\u201d) data structure , where such print job settings as number of copies, duplex, color, etc. are stored. Next, the modified port monitor  uses this information to make the actual modification to the print stream.","Unfortunately, DOCWISE\u2122 suffers from a number of problems having to do with reliability and availability. First, DOCWISE\u2122 uses a specially modified printer driver. It can be extremely difficult to modify some printer drivers and to make the modified printer drivers available to end-users. Because many different business entities supply printer drivers to end-users, the necessary cooperation and coordination among these entities is challenging to achieve at best and impossible at worst. Second, DOCWISE\u2122 uses a specially modified port monitor to modify the job stream. Because DOCWISE\u2122 is linked to a particular port monitor technology, end-users wishing to use a different port monitor are unable to take advantage of the print job tracking capabilities supplied by DOCWISE\u2122. Third, printing must occur to a local port\u2014not a shared network queue as is often used in a network environment where print job status is most important\u2014for DOCWISE\u2122 to operate properly. If a remote spooler is utilized, DOCWISE\u2122 cannot provide print status information. The first two problems, by depending on special modifications to software that may vary, result in a brittle solution that is difficult to maintain. The third problem severely limits the availability of the desired print status feature. In summary, DOCWISE\u2122 only works under the following three conditions: (1) a printer driver must be modified; (2) a port monitor must be modified; and (3) printing must occur to a local port. Unfortunately, if these conditions are not met, the user simply does not receive print job status. As a result, the user can get the impression that DOCWISE\u2122 behaves inconsistently.","In one respect, the invention is a method for configuring a computer to obtain status information for subsequent print jobs to a printer. The method supplies a proxy printer driver in place of an actual printer driver associated with the printer. The method may hook functions in the actual printer driver. The method may also configure the computer to spool RAW datatype to the printer. The method may also store a unique identifier of the computer in the registry. The method may also set a flag within the registry so as to indicate that the computer is able to provide status for print jobs on the printer.","In another respect, the invention is a method for gathering print status for a print job from a computer to a printer. The method executes a proxy printer driver while producing the print job, wherein the proxy printer driver is a proxy for an actual printer driver. The method inserts into the print job a unique identifier of the print job. The method also queries at least one of a spooler and the printer regarding status of the print job. Optionally, the method may detect inception of the print job and produce a notification of the status of the print job. In executing the proxy printer driver, the method preferably receives a call to a function and calls a corresponding function in the actual printer driver. In some embodiments, RAW print data is produced.","In yet another respect, the invention is a computer readable medium on which is embedded a computer program. The program comprises a proxy printer driver translation part, the proxy printer driver translation part being a proxy for an actual printer driver translation part. Optionally, the program comprises one or more of a status configuration utility, a status monitor, a spooler comprising a port monitor, a graphic device interface, a registry, the actual printer driver translation part and an application.","In comparison to known prior art, certain embodiments of the invention are capable of achieving certain advantages, including some or all of the following: (1) an end-user can obtain print job status without modification to a printer driver; (2) an end-user can obtain print job status without modification to a port monitor; (3) an end-user can obtain print job status consistently, regardless of the printing method\u2014in particular, regardless of whether a local port or remote port on a network is utilized; and (4) the solution is much more resilient and easier to maintain than prior art solutions. Those skilled in the art will appreciate these and other advantages and benefits of various embodiments of the invention upon reading the following detailed description of a preferred embodiment with reference to the below-listed drawings.","I. System Architecture",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4","b":["400","400","300","410","415","410","420","430","440","445","450","430","480","410","415","460","410","415","470","420","475","415","400","300","490","415","475","490","475","490","400"]},"The application , spooler , registry , SAS configuration utility , SAS monitor , GDI , actual driver , proxy driver  and port monitor  are preferably software modules. Although software is preferred, some or all of the preceding could be hardware or firmware modules. Software modules can exist in a variety of forms both active and inactive, including data structures, source code, object code, executable code or other formats. Hardware modules can take the form of physical devices or hardware description language (HDL) files. Software files or HDL files can be embodied on a computer readable medium, which include storage devices and signals, in compressed or uncompressed form. Exemplary computer readable storage devices include conventional computer system RAM, ROM (read only memory), EPROM (erasable programmable ROM), EEPROM (electrically erasable programmable ROM), and magnetic or optical disks or tapes. Exemplary computer readable signals, whether modulated using a carrier or not, are signals that a computer system can be configured to access, including signals downloaded through the Internet or other networks. In a sense, the Internet itself, as an abstract entity, is a computer readable medium. The same is true of computer networks in general. As a final point on this matter, the various method described below, apart from any particular architecture such as the shown in , can be implemented by program modules, whether software, firmware, hardware or some combination.","II. Configuration",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5","b":["500","445","500","510","440","520","440","440","475","490","500","530","475","490","490","440","475","490","475","490","500","540","490","500","550","440","440","500"]},"III. Printing","A print job in WINDOWS\u2122 NT 4.0 is processed according to one of five methods. The five methods are (1) RAW spooling to a local port; (2) RAW spooling to a remote port; (3) EMF (enhanced metafile) spooling with local conversion of EMF to RAW, sent to a local port; (4) EMF spooling with local conversion of EMF to RAW, sent to a remote port; and (5) EMF spooling with remote conversion of EMF to RAW, sent to a local port. These methods are illustrated in , respectively.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 6","FIG. 6","FIG. 6","FIG. 6"],"b":["605","610","420","460","490","475","490","490","610","610","460","430","480","610","605","610"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 7","FIG. 7","FIG. 6"],"b":["605","620","640","610","430","630","640","605","620","610"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 8","FIG. 8"],"b":["420","460","460","460","460","430","420","460","420","420","430","460","490"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 9","FIG. 9","FIG. 7"],"b":"630"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10","b":["605","620","610","620","660","690","620","605","500","620","490"]},"To generalize, according to the printing techniques in each of , when an end-user submits a print job, the application  seemingly makes API calls to the GDI  (or the GDI , if on the print server ), as it would conventionally. However, the GDI  translates these API calls into printer ready data using the proxy driver , instead of using the actual driver .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 11","b":["1100","490","1100","1104","460","460","460","460","490","1108","475","1100","1112","1112","1112","1100","1116","475","490","1120","1124","490","460","460"]},"The replacing step  is a form of hooking. The replacing step  hooks certain functions from the actual driver , while the hooking step  hooks certain functions from the GDI . The proxy driver  is a program interfacing between the GDI  and the actual driver . Without the proxy driver , the GDI  would call Drv* entry points (i.e., entry points whose names begin with \u201cDrv\u201d by convention) in the actual driver , and the actual driver  would call Eng* functions in the GDI . The proxy driver  interposes between the GDI  and the actual driver  by hooking some or all of these Drv* and Eng* calls.","The hooking step  preferably utilizes dynamic linking mechanisms to hook EngGetDriverName, EngWritePrinter, EngLoadImage and EngUnloadImage. These functions are implemented by the GDI  as part of the kernel mode DLL (dynamic linked library) win32k.sys. The mechanisms used in dynamic linking can be exploited to replace these functions for just the actual driver  without impacting any other modules. The code that implements these functions need not be changed. Instead, the function pointers to these functions within the actual driver  are changed to point to the proxy driver's () implementation of these function (called ProxyGetDriverName, ProxyWritePrinter, ProxyLoadImage and ProxyUnloadImage).","On modern WINDOW\u2122 operating systems (i.e. systems that support WIN32), dynamic linking is performed by an operating system component called the loader. When an executable module (either an executable or a DLL) is loaded, the loader is responsible for inserting function pointers into a portion of the executable module known as the import table. The import table consists of a list of entries, with each entry specifying a module (e.g., DLLs), a function name (or ordinal), and a function address. When a module is initially loaded into memory, the function address portion of each entry is invalid (i.e. NULL). The loader is responsible for using each entry's module name and function name to determine the address portion of the entry. If the entry's module is already loaded, the loader will simply obtain the address of the desired function. If the entry's module is not loaded, the loader will load it and then obtain the address of the desired function.","The structure of WIN32 modules is governed by the Portable Executable (PE) file format. This file format is documented in detail within the MICROSOFT\u2122 Software Developers Network (MSDN) Library. Using the PE file format, it is possible to determine the in-memory location of the import table and selectively replace the function addresses supplied by the loader with alternative function addresses. This is how the proxy driver  \u201chooks\u201d the EngGetDriverName function, for example, of the actual driver . To continue the same example, the proxy driver  replaces the actual driver's () function pointer to EngGetDriverName with a pointer to its own version of this function, i.e., ProxyGetDriverName, in the import table.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 12","FIG. 12"],"b":["1200","490","1200","475","490"]},"The function ProxyEnablePDEV is the proxy driver's () surrogate for DrvEnablePDEV, which is used to establish a new printing session. When the proxy driver  receives () a call by the GDI  to the function ProxyEnablePDEV, the method  responds by calling () the actual DrvEnablePDEV and checking () whether the target printer is flagged for job status. The checking step  can be performed by reading the \u201cSystem Printer Settings\u201d flag in the registry ; this flag is set by the setting step  of the configuration method  (). If this flag is not set, then the method  terminates. If, on the other hand, the flag is set, then the method  tests () whether a new job has been created. If a new job has been created and the new job is associated with the parameters passed in on the function call (e.g., \u201cdhPDEV,\u201d \u201chDevice\u201d and \u201chPrinter\u201d), then the method  verifies and\/or sets () an association between the job and the parameters, in case ProxyStartDoc has been called before ProxyEnablePDEV. If a new job has not been created and associated with the input parameters, then the method  stores () the parameters, in case ProxyStartDoc is called later.","When the function ProxyDisablePDEV is called (), the method  calls () the actual DrvDisablePDEV and tests () whether there is a job associated with the parameter \u201cdhPDEV\u201d passed in. If there is one, then the method  removes () the associated job from the job list. Next, the method  tests () whether the current passed \u201cdhPDEV\u201d equals the last value of that variable set by ProxyEnablePDEV in the step . If so, the method  resets to null the variables stored by the step  to prevent their usage in the next ProxyStartDoc call.","The function DrvStartDoc is called to start a document printing. Not all print sessions result in printer output. Some print sessions simply obtain information, such as font metrics, about the target printer, in which case DrvStartDoc is not called. When the proxy driver  receives () a GDI  call to the function ProxyStartDoc, the proxy's implementation of DrvStartDoc, the method  responds by verifying () the document name passed in as a parameter and testing () whether the proxy driver  is to monitor jobs for the associated printer. If so, the method  creates () a new job structure and tests () whether the input parameter \u201cpso->hdev\u201d equals that stored in the \u201chDevice\u201d member variable during the step  of the ProxyEnablePDEV implementation. If the same, then the method  associates () the new job with the stored member variables, associates () the last printer name used to this job and resets () the member variables to null. As part of these steps, the method  writes the job ID into a table record for the printer associated with the parameter \u201chPrinter.\u201d This job ID is later utilized by EngWritePrinter to mark a print stream, as explained below. Lastly, the method  calls the actual DrvStartDoc before it returns from ProxyStartDoc.","When a call from GDI is received () to invoke ProxyEndDoc, the method  calls () the actual DrvEndDoc. The method  then tests () whether a job associated with the input parameters \u201cpso->hdev\u201d and \u201cpso->dhPDEV\u201d exists. If such a job can be found, then the method  removes (1298) the job from the internal list.","As already mentioned, the proxy driver  supplies its own implementations of several functions within the GDI \u2014namely EngGetDriverName, EngWritePrinter, EngLoadImage and EngUnloadImage. The proxy version of these functions are called ProxyGetDriverName, ProxyWritePrinter, ProxyLoadImage and ProxyUnloadImage, respectively. The operation of these four proxy functions will next be described.","When the actual driver  calls EngGetDriverName, the actual driver expects to have returned the name of the actual driver file. This name is often used to obtain resources stored within the driver file. This function should return the file name of the actual driver  rather than the proxy driver , even though the actual driver  file is replaced with the proxy driver  file. The proxy driver  file does not contain the resources required by the actual driver . The actual driver  expects to get the actual driver  file name when it calls EngGetDriverName. Accordingly, ProxyGetDriverName returns the file name of the actual driver .","The function EngLoadImage is hooked to ensure that if the actual driver  uses helper DLLs to accomplish printing tasks, these helper DLLs will also call into the proxy driver's () implementation of the Eng* functions. Thus, if the actual driver  relies on a helper DLL to print, the proxy driver's () implementation of EngLoadImage (ProxyLoadImage) would hook the same three functions in the helper DLLs if they call these methods. This process of hooking EngLoadImage guarantees that all helper DLLs call into the proxy driver's () implementation of these methods, to prevent potential printing errors. Similarly, the function EngUnloadImage is hooked (as ProxyUnloadImage) so that unloading of a helper DLL can be detected and state member variables reset.","The function ProxyWritePrinter is used to insert the network-unique job ID into the output stream. Kernel mode printer drivers call the function EngWritePrinter to pass RAW printer ready data (e.g. PCL or Postscript) to the GDI . By \u201chooking\u201d the actual driver's () EngWritePrinter function, the proxy driver  can filter all of the output from the actual driver . The proxy driver  replaces the actual driver's () function pointer to EngWritePrinter with a pointer to its own version of this function, i.e., ProxyWriteEnable. ProxyWriteEnable calls the real EngWritePrinter, carefully inserting the network-unique job ID into the output stream. The proxy driver's () implementation of EngWritePrinter also takes into account whether or not a WINDOWS\u2122 system printer for which an output stream is intended has been flagged for print job status tracking, as described above.","One of the parameters to the function EngWritePrinter is a handle to the printer, hPrinter. The proxy driver  uses the hPrinter handle supplied to ProxyWritePrinter to lookup the associated job structure (if one exists) to determine if and when the proxy driver  should insert the network-unique ID into the printer output stream. Recall that when the job was created, it was associated to a hPrinter (as well as other handles), so that a job structure can be retrieved based on any one of these handles. Accordingly, ProxyWritePrinter can retrieve an associated job structure using solely this printer handle. The association between the hPrinter, hDevice and\/or dhPDEV and a job structure is accomplished in either DrvEnablePDEV or DrvStartDoc, depending on the order in which these methods are called. These three handles are used in conjunction with each other, such that if one is known, the others can be determined. Thus, using the printer handle, it is possible to determine which WINDOWS\u2122 system printer the EngWritePrinter call is intended for. With this information available, the proxy driver  can later determine whether or not a particular EngWritePrinter call is intended for a WINDOWS\u2122 system printer that has been flagged for print job status tracking.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 13","b":["1300","440","1300","1310","1320","1330","1340","1330","1340","440","520","500","460"]},"As a final note, the issue of transparency is now addressed. The proxy driver  should be transparent to both the GDI  and the actual driver . In one respect, the proxy driver  is designed to appear to the GDI  like the actual driver  for all intents and purposes. In another respect, the actual driver  should behave exactly as it would if the proxy driver  were out of the picture. Although a preferred embodiment of the proxy driver  achieves transparency in a particular way detailed above, alternative approaches can result in the same level of transparency.","The proxy driver  can accomplish GDI  perspective transparency by using the actual driver . When the GDI  invokes a method on the proxy driver , three things can happen: (1) the GDI  could actually be invoking a method on the actual driver ; (2) the GDI  could be invoking a method on the proxy driver  and the proxy driver  could, in turn, invoke a method on the actual driver ; and (3) GDI could be invoking a method on the proxy driver , and the proxy driver  could be providing the entire implementation of the method without relying on any methods supplied by the actual driver . The first case is possible because the proxy driver  supplies the addresses of actual driver  functions; specifically, the DrvEnableDriver function does this, as explained above, in regards to the steps \u2013 of the method . In the second case, when the proxy driver  invokes a method on the actual driver , the proxy driver  might do bookkeeping or other actions before and\/or after invoking a method on the actual driver .","In order to achieve actual driver  perspective transparency, the proxy driver  is also designed to create the illusion from the perspective of the actual driver  that it is in direct contact with the GDI , with no indication that the proxy driver  is acting as an intermediary. This requires that two conditions be met: (1) the actual driver  should have exactly the same methods invoked with exactly the same parameters in exactly the same order as would have happened had the proxy driver  not been present; and (2) any function called by the actual driver  should return exactly the same result it would have in the absence of the proxy driver . To meet the first condition, the proxy driver  preferably passes all function invocations to the actual driver .","IV. Status Gathering","While the proxy driver  is busy ensuring that the output stream is marked with information that uniquely identifies the job, the SAS monitor  performs the method , which is illustrated in . The method  detects () the inception of the job, determines () the job's ID, which can be read from the job itself, and independently synthesizes () the job's network-unique ID from the machine's unique identifier and the job's ID. The method  uses the job's ID to monitor the job by querying () the spooler  regarding the job. Additionally, the method  uses the jobs network-unique ID to monitor the job by querying () the printer  regarding the print job. The method  can then notify () the end-user with information regarding the processing of the print job. Typically, only inconspicuous notifications, such as changing an icon in the system tray, are made\u2014unless something occurs that impedes the completion of the job. If something occurs that hampers job completion, a status message can be displayed that provides the user with the relevant information.","What has been described and illustrated herein is a preferred embodiment of the invention along with some of its variations. The terms, descriptions and figures used herein are set forth by way of illustration only and are not meant as limitations. Those skilled in the art will recognize that many variations are possible within the spirit and scope of the invention, which is intended to be defined by the following claims\u2014and their equivalents\u2014in which all terms are meant in their broadest reasonable sense unless otherwise indicated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 6\u201310"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
