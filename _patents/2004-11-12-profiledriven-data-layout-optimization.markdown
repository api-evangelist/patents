---
title: Profile-driven data layout optimization
abstract: Data layout optimization arranges data members within memory to enhance software performance. Profiling data is consulted to determine how to group data members for an object class into groups. One technique groups the data members based on how frequently the data members are referenced in memory. Another technique groups the data members based on their affinities for one another in time as determined by observing when references to the data members take place. A variety of options when collecting the profiling data and grouping the data members is supported. The data member grouping is recorded in metadata associated with a definition of the object class. At runtime, a class loader places the data members of an object in memory according to the metadata. Data members of different groups can be placed in separately-loadable units of memory in the memory system. Subsequently, when the data members are referenced in memory, more frequently referenced data members, including those that tend to be referenced at times close to each other, reside at neighboring locations in the memory system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07013459&OS=07013459&RS=07013459
owner: Microsoft Corporation
number: 07013459
owner_city: Redmond
owner_country: US
publication_date: 20041112
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO PRIOR APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Illustrated Embodiments","Greedy Data Layout Optimization Technique"],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/542,525, filed Apr. 4, 2000, now U.S. Pat. No. 6,862,729 entitled \u201cPROFILE-DRIVEN DATA LAYOUT OPTIMIZATION,\u201d by inventors Gerald Dwayne Kuch et al., which application is hereby incorporated herein by reference.","The field relates to optimization of computer software, and more particularly relates to determining data layout based on data obtained by profiling the software.","Various techniques have evolved for improving the performance of computer software. A category of techniques commonly called \u201coptimization\u201d evaluates a piece of software and modifies its operation to improve performance while preserving the software's functionality.","For example, the architecture of many computer systems organizes memory into pages. Such systems may include a mechanism by which a limited number of pages can be loaded into primary memory for access by a processor. Additional pages can be stored in secondary memory; however, when the system accesses secondary memory, processing is suspended while moving the pages from secondary memory to primary memory.","For purposes of illustration, consider a piece of software having instructions for four procedures A, B, C, and D executing in sequence in a system having only one page of primary memory. If procedures A and C are on a first page, and procedures B and D are on a second page, the following eight actions take place when the piece of software is executed:","1. Move first page to primary memory","2. Execute procedure A","3. Move second page to primary memory","4. Execute procedure B","5. Move first page to primary memory","6. Execute procedure C","7. Move second page to primary memory","8. Execute procedure D.","One optimization technique places code portions which execute within a certain period of time in close proximity to each other. Thus, A and B are placed close to each other (e.g., on the same page) and C and D are place close to each other. Applying such optimization to the above piece of software, the following six actions take place when the piece of software is executed:","1. Move first page to primary memory","2. Execute procedure A","3. Execute procedure B","4. Move first page to primary memory","5. Execute procedure C","6. Execute procedure D.","Thus, optimization of the software has saved two actions. Since moving pages into primary memory typically requires a large amount of time in terms of processing cycles, the savings is significant. This optimization technique can be applied to large software projects to provide dramatic savings in processing resources.","Although manual optimization is possible, software developers employ a technique called profiling to automate the process. Profiling observes software's behavior during execution to assist in optimization. For example, information about which procedures are executed within a certain period of time can be collected for the above-described optimization technique.","While the above-described techniques can lead to significant improvements in software performance, they focus on the code-related portions of software and fail to recognize inefficiencies related to the data-related portions of software. These techniques further fail to take into account various peculiarities of object-oriented software.","The invention includes a method and system for data layout optimization based on profiling. Various features provided by the system lead to better use of resources and improved performance. For example, data members of a software object can be divided into separate groups. Further, the system can provide feedback to assist in re-designing software object classes.","In one feature, data members of an object can be split into plural separate groups. For example, some data members of an object class can be designated as residing in a hot group, while others reside in a cold group. At runtime, the groups can be placed in separately-loadable units of a memory system. Data members from the same group can be placed at neighboring locations in the memory system. From the perspective of functions within the software, the division of the data members is inconsequential, but software performance can be improved.","In another feature, metadata describing the groups can be associated with an object class for consideration when the data members of an object are arranged in a memory system when the object is loaded into memory. In this way, the fields of an object can be stored in appropriate locations in the memory system, according to previously observed behavior of the software. For example, more frequently referenced data members can be placed at neighboring locations, and less frequently referenced data members can be placed at other locations separately loadable into the memory system.","In yet another feature, calculations for determining layout of data include the time domain to determine affinity of data members of one another with respect to time. Thus, \u201caffinity\u201d in such an arrangement means affinity in time. Analysis of the observation of software's behavior can determine that certain data members tend to be referenced at times close to each other. As a result of making such a determination, the data members can be placed close to each other in the memory system. Affinity-based layout can produce better results under certain circumstances.","In still another feature, a software developer can declaratively control optimization by including certain statements in source code or specifying options at a command line. For example, a programmer may wish to explicitly specify a particular layout scheme.","Another feature provides affinity information visually for consideration by developers. The information may lead to a re-design of the object classes to build a high-performance software object set.","Various aspects of the invention thus improve upon the above-described optimization technique, which focuses on optimizing the arrangement of data members of an object. The problem referred to as \u201cdragging around dead data\u201d is avoided. Performance is increased dramatically under certain circumstances, such as when some data members are quite frequently referenced, while others are referenced only a few times, once, or not at all.","Additional features and advantages of the invention will be made apparent from the following detailed description of illustrated embodiments, which proceeds with reference to the accompanying drawings.","The invention is directed toward a method and system for laying out data members of software objects. In one embodiment illustrated herein, the invention is incorporated into a runtime environment associated with the \u201cCOM+\u201d component of an operating system entitled \u201cMICROSOFT WINDOWS 2000,\u201d both marketed by Microsoft Corporation of Redmond, Wash. Briefly described, this software is a scaleable, high-performance network and computer operating system providing an object execution environment for object programs conforming to COM and other specifications. COM+ also supports distributed client\/server computing. The COM+ component incorporates new technology as well as object services from prior object systems, including the MICROSOFT Component Object Model (COM), the MICROSOFT Distributed Component Object Model (DCOM), and the MICROSOFT Transaction Server (MTS).","Exemplary Operating Environment",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 1"},"With reference to , an exemplary system for implementing the invention includes a conventional computer , including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit may be any of various commercially available processors, including Intel x86, Pentium and compatible microprocessors from Intel and others, including Cyrix, AMD and Nexgen; Alpha from Digital; MIPS from MIPS Technology, NEC, IDT, Siemens, and others; and the PowerPC from IBM and Motorola. Dual microprocessors and other multi-processor architectures also can be used as the processing unit .","The system bus may be any of several types of bus structure including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as PCI, VESA, Microchannel, ISA and EISA, to name a few. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM .","The computer  further includes a hard disk drive , a magnetic disk drive , e.g., to read from or write to a removable disk , and an optical disk drive , e.g., for reading a CD-ROM disk  or to read from or write to other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the computer . Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, and the like, may also be used in the exemplary operating environment.","A number of programs may be stored in the drives and RAM , including an operating system , one or more application programs , other programs , and program data . The operating system  in the illustrated computer may be the MICROSOFT WINDOWS NT Server operating system, together with the before mentioned MICROSOFT Transaction Server.","A user may enter commands and information into the computer  through a keyboard  and pointing device, such as a mouse . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, computers typically include other peripheral output devices (not shown), such as speakers and printers.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote client computer . The remote computer  may be a workstation, a terminal computer, another server computer, a router, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, extranets, and the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem , or is connected to a communications server on the LAN, or has other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","In accordance with the practices of persons skilled in the art of computer programming, the present invention is described below with reference to acts and symbolic representations of operations that are performed by the computer , unless indicated otherwise. Such acts and operations are sometimes referred to as being computer-executed. It will be appreciated that the acts and symbolically represented operations include the manipulation by the processing unit  of electrical signals representing data bits which causes a resulting transformation or reduction of the electrical signal representation, and the maintenance of data bits at memory locations in the memory system (including the system memory , hard drive , floppy disks , and CD-ROM ) to thereby reconfigure or otherwise alter the computer system's operation, as well as other processing of signals. The memory locations where data bits are maintained are physical locations that have particular electrical, magnetic, or optical properties corresponding to the data bits.","Object Overview",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 2","b":"76","i":"Inside OLE, Second Edition"},"In accordance with COM, the COM object  is represented in the computer system  () by an instance data structure , a virtual function table , and member methods (also called member functions) \u2013. The instance data structure  contains a pointer  to the virtual function table  and data  (also referred to as data members, or properties of the object). A pointer is a data value that holds a reference to an item. As will be explained in greater detail below, the conventional instance data structure  is modified to accommodate grouping the data members into separate groups. The virtual function table  contains entries \u2013 for the member methods \u2013. Each of the entries \u2013 contains a reference to the code \u2013 that implements the corresponding member methods.","The pointer , the virtual function table , and the member methods \u2013 implement an interface of the COM object . By convention, the interfaces of a COM object are illustrated graphically as a plug-in jack as shown for the software object  in . Also, interfaces conventionally are given names beginning with a capital \u201cI.\u201d In accordance with COM, the COM object  can include multiple interfaces, which are implemented with one or more virtual function tables. The member function of an interface is denoted as \u201cIInterfaceName::MethodName.\u201d","The virtual function table  and member methods \u2013 of the COM object  are provided by an object server program  (hereafter \u201cobject server DLL\u201d) which is stored in the computer  () as a dynamic link library file (denoted with a \u201c.dll\u201d file name extension). In accordance with COM, the object server DLL  includes code for the virtual function table  and member methods \u2013 of the classes that it supports, and also includes a class factory  that generates the instance data structure  for an object of the class.","Other objects and programs (referred to as a \u201cclient\u201d of the COM object ) access the functionality of the COM object by invoking the member methods through the COM object's interfaces. Typically however, the COM object is first instantiated (i.e., by causing the class factory to create the instance data structure  of the object); and the client obtains an interface pointer to the COM object.","Before the COM object  can be instantiated, the object is first installed on the computer . Typically, installation involves installing a group of related objects called a package. The COM object  is installed by storing the object server DLL file(s)  that provides the object in data storage accessible by the computer  (typically the hard drive , shown in ), and registering COM attributes (e.g., class identifier, path and name of the object server DLL file , etc.) of the COM object in one or more data stores storing configuration information. Configuration data stores for the object include the registry and the catalog.","A client requests instantiation of the COM object using system-provided services and a set of standard, system-defined component interfaces based on class and interface identifiers assigned to the COM Object's class and interfaces. More specifically, the services are available to client programs as application programming interface (API) functions provided in the COM+ library, which is a component of the MICROSOFT WINDOWS 2000 operating system in a file named \u201cOLE32.DLL.\u201d Other versions of COM+ or other object services may use another file or another mechanism. Also in COM+, classes of COM objects are uniquely associated with class identifiers (\u201cCLSIDs\u201d), and registered by their CLSID in the registry (or the catalog, or both). The registry entry for a COM object class associates the CLSID of the class with information identifying an executable file that provides the class (e.g., a DLL file having a class factory to produce an instance of the class). Class identifiers are 128-bit globally unique identifiers (\u201cGUIDs\u201d) that the programmer creates with a COM+ service named \u201cCoCreateGUID\u201d (or any of several other APIs and utilities that are used to create universally unique identifiers) and assigns to the respective classes. The interfaces of a component additionally are associated with interface identifiers (\u201cIDs\u201d).","In particular, the COM+ library provides an API function, \u201cCoCreateInstance( ),\u201d that the client program can call to request creation of a component using its assigned CLSID and an IID of a desired interface. In response, the \u201cCoCreateInstance( )\u201d API looks up the registry entry of the requested CLSID in the registry to identify the executable file for the class. The \u201cCoCreateInstance( )\u201d API function then loads the class' executable file, and uses the class factory in the executable file to create an instance of the COM object . Finally, the \u201cCoCreateInstance( )\u201d API function returns a pointer of the requested interface to the client program. The \u201cCoCreateInstance( )\u201d API function can load the executable file either in the client program's process, or into a server process which can be either local or remote (i.e., on the same computer or a remote computer in a distributed computer network) depending on the attributes registered for the COM object  in the system registry.","Once the client of the COM object  has obtained this first interface pointer of the COM object, the client can obtain pointers of other desired interfaces of the component using the interface identifier associated with the desired interface. COM+ defines several standard interfaces generally supported by COM objects including the \u201cIUnknown\u201d interface. This interface includes a member function named \u201cQueryInterface( ).\u201d The \u201cQueryInterface( )\u201d function can be called with an interface identifier as an argument, and returns a pointer to the interface associated with that interface identifier. The \u201cIUnknown\u201d interface of each COM object also includes member functions, \u201cAddRef( )\u201d and \u201cRelease( )\u201d, for maintaining a count of client programs holding a reference (e.g., an interface pointer) to the COM object. By convention, the \u201cIUnknown\u201d interface's member functions are included as part of each interface on a COM object. Thus, any interface pointer that the client obtains to an interface of the COM object  can be used to call the QueryInterface function.","Execution Engine Overview","For purposes of illustration, data layout optimization is shown implemented in an execution engine. An exemplary computer system  with an exemplary execution engine  is shown in . In the computer system , software  is provided by any of a number of means, such as by online or physical distribution. The software  includes one or more object class definitions . In some systems, information relating to the object class definitions  is stored in a central configuration store called a registry or catalog.","When the functionality provided by the software  is desired, the software is executed via the execution engine . The execution engine  is sometimes called a \u201cvirtual machine\u201d because it provides processing services as if it were a computer system. The execution engine  typically offers more flexibility than an actual computer centered around a particular central processing unit. For instance, the execution engine  might process software in varying degrees of compilation (e.g., fully compiled, partially compiled, or uncompiled) in a variety of formats (e.g., in various languages or according to various native machine formats).","The execution engine  includes various components to perform its work. Typically, a class loader  and garbage collector  are included, although many other arrangements are possible. In the example, the class loader  performs the work of laying out objects of the class specified in the object class definition  in the memory system . For example, when a new object is created, the class loader  places an instance data structure (e.g., the instance data structure  shown in ) at a particular location within the memory system . Further, the data members of an object (e.g., an integer field and an array) can be referenced in memory by referencing a particular address within the memory system . Preferably, the software  is written without regard to where in the memory system  the data members will be located. The execution engine  handles the details of determining where the data members will be located and how to access them within the memory system .","Although the memory system  is shown outside the execution engine , in some scenarios, it may be more accurate to portray the memory system  as part of the execution engine . In either case, the data members of an object are arranged within the memory system  in such a way that they can be referenced in memory for reading and writing by the software .","Memory System Overview","The principles of the invention can be applied to a wide variety of memory systems having architectures with at least two hierarchically-related portions of memory. These two portions of memory are sometimes referred to as a primary memory and a secondary memory.","For example, a virtual memory system  with an exemplary hierarchical memory architecture is illustrated in . In the example, a processing unit  has an associated cache , and the system  includes the main RAM  and the hard disk . For example, the main RAM  might take the form of 512 megabytes of RAM, and the hard disk  might be in the form of an 8 gigabyte hard disk. Many other arrangements and forms of storage are possible.","In accordance with accepted memory terminology the main RAM  is said to be \u201ccloser\u201d to the processing unit and exhibits a lower latency (i.e., is faster) than the hard disk . Typically, elements of the memory system  closer to the processing unit  exhibit a lower latency but have less capacity than elements further away. Further, in a system having virtual memory, the processing unit  typically does not work directly on items on the hard disk , but instead first loads them into the main RAM .","In such a scenario, the main RAM  can be called the \u201cprimary\u201d (or \u201cmain\u201d) memory, and the memory pages stored on the hard disk  can be called the \u201csecondary\u201d memory. Other arrangements are possible; the primary memory generally exhibits a lower latency than the secondary memory. In some systems, the cache  in combination with the main RAM  are considered to be part of the primary memory; in others, the cache  is not considered part of the virtual memory system , but is rather complementary to it. Further, there are often additional levels of cache within or in addition to the cache . Further details of virtual memory systems are discussed at length in Denning, \u201cVirtual Memory,\u201d (Tucker, Ed.), Chapter 80, pp. 1747\u20131760, 1997.","In a virtual memory system, the memory system can, for example, use the hard disk  to supplement the main RAM . Thus, the virtual address space available to a program is much larger than the RAM available to the program. In this way, a computer system with a virtual memory system can run programs that will not fit in the main RAM  alone. Ideally, the virtual memory system  is transparent to the program, which simply provides a virtual memory address that refers to memory anywhere in the virtual memory system , whether it happens to reside in the main RAM  or on the hard disk .","The virtual memory is typically divided into units called \u201cpages\u201d (sometimes called \u201cblocks\u201d). The pages of a memory system can be either of a fixed or variable size. The contents of a program can be spread out over multiple pages. Typically, pages representing the program instructions and program data initially reside on the hard disk . As the program executes, the processing unit references data on these pages, so they are loaded into the main RAM . The set of pages in the main RAM  is sometimes called the \u201cresident set\u201d. The virtual memory system  tracks which pages are available in the resident set. If an executing program specifies a virtual memory address referring to a page not in the resident set (i.e., not in main RAM ), the virtual memory system responds by loading the page into the main RAM  for access by the processing unit.","As a program executes, a memory reference to a portion of memory present at a particular level in the hierarchy is called a \u201chit\u201d; otherwise, it is a \u201cmiss.\u201d In the context of a cache, a cache hit means the item was present in cache when it was needed. If a memory reference is made to a virtual memory page not in primary memory, the miss is often referred to as a \u201cpage fault.\u201d Excessive page faults can particularly degrade performance because the processing unit typically suspends execution of the program until the page is fetched from a high-latency device (e.g., a mechanical device such as a hard disk).","Typically, the resident set for a program is limited to a certain number of pages, which may be less than the total pages required by the program. In other words, the entire program might not fit into the main RAM . Consequently, there will come a time when the processing unit requires access to a page, but the resident set has reached its limit. In such a situation, the virtual memory system  replaces a page in the resident set (i.e., in RAM ) with a new page. Various approaches sometimes called \u201creplacement policies\u201d have been formulated to determine which page should be replaced. For example, one approach replaces the least recently used page under the assumption that the least recently used page is least likely to be needed again soon. It would be inefficient, for example, to replace a page that is immediately reloaded back into the resident set.","Although a superior replacement policy can improve performance, performance improvement is bounded by how items are arranged within the pages (i.e., the layout of the items). The illustrated embodiments employ various techniques and features for determining an arrangement that results in better performance and further employ various techniques and features for achieving such an arrangement. The result is increased performance when a program is executed in an environment having primary and secondary memory such as the illustrated virtual memory system .","Profiling Overview","In various illustrated embodiments, profiling operates to monitor memory references to the data members of an object. Profiling can be achieved by a variety of methods. For example, the code of a program can be provided to an instrumentor, which writes instrumented code. When executed, the instrumented code produces memory-reference trace data for memory references to data members, which can be stored, for example, in a database. The memory-reference trace data can then be used to determine how the class loader arranges the data members of an object.","An exemplary database of memory-reference trace data might have a record for each memory reference to a data member to indicate the data member being referenced and when it was referenced in memory. Since profiling is typically applied to software having multiple objects with multiple data members referenced multiple times in memory, the database may become quite large. So, various techniques can be used to reduce its size. In some illustrated embodiments, the arrangement can be determined solely based on how many times each data member was referenced alone (without information about when it was referenced), so the memory-reference trace data need only keep a count of how many memory references were made to each data member being monitored. In other embodiments (e.g., an affinity-based technique), information about when the memory references were made is recorded.","Alternatively, a technique called \u201cstatic profiling\u201d might be used. Static profiling analyzes code without running it to determine profiling data. For example, it might be apparent from the code that a memory reference to one data member is performed responsive to a memory reference to another data member in a conditional statement.","Data Member Grouping Overview","When a developer specifies a software object, the specification includes a set of data members. At some point after the program is developed, these data members are translated from a high level definition (e.g., a set of data structures defined in C++ or a definition according to a scripting language) to an actual layout in the memory system (e.g., a virtual memory system). Many translation scenarios are possible. For example, the translation can be partially handled by a compiler, partially handled by an interpreter, or otherwise handled in a partially-compiled language.","For example, in the illustrated embodiments, a class loader loads an object into the virtual memory system when a program references an object. The class loader assigns an arrangement for the data members of the object by specifying which data members will reside where in the virtual memory system. Generally, the loader places more frequently accessed data members into a set of groups (called \u201chot groups\u201d) and less frequently accessed data members into another set of groups (called \u201ccold groups\u201d); however a group may fall anywhere in the spectrum between \u201chot\u201d and \u201ccold.\u201d The loader can place data members in the same group in neighboring locations in the virtual memory system. Further, the memory system typically has a set units (e.g., pages or blocks) that are separately loadable into primary memory.","Neighboring members in the same group tend to fall in the same pages of the virtual memory system. Members of different groups tend to reside in different pages of the virtual memory system. Consequently, when a program references a data member in one group, the virtual memory system tends to move the pages associated with the group having the referenced data member into primary memory, but the pages associated with the other group tend to be left behind in secondary memory.","A class loader could be constructed to interface with the virtual memory system to specifically assign the data members to particular pages of the virtual memory system. Further analysis of the arrangement could be done based on the size of a page in the virtual memory system.","Overview of Some Advantages","Arranging the data members with the class loader as described above results in several advantages. For purposes of comparison, consider a scenario in which the data members are not explicitly arranged by the class loader. For example, consider software in which thousands of references are made to various data members of an object over the lifetime of the object. Further, the resident set for the software is of such a size that it cannot accommodate all the data members, so page faults cause pages to be constantly swapped in and out of primary memory.","Some of the data members are particularly active; 98 percent of the references to data members are made to them. Some of the other data members are accessed only once over the lifetime of the object.","A class loader might unfortunately happen to place one of the active data members and one of the once-only data members alone on a page of virtual memory. Since the active member is referenced often, there could be many page faults for the page. For each page fault, the once-only member is copied into primary memory, even though it is accessed only once over the lifetime of the object. This phenomenon can be called \u201cdragging around dead data\u201d because the once-only data member is being repetitively copied into primary memory, even when it is not needed.","Instead, a more advantageous arrangement is for the class loader to place the data members into groups as described above. If the active data members are placed in one group, they will likely reside in the same pages of virtual memory. Likewise, if the once-only data members are placed in a different group, they will likely reside in the same pages of virtual memory. Accordingly, the \u201cdead data\u201d is less likely to be \u201cdragged around\u201d as references are made to the data members. In this way, the space of the resident set is used more effectively, resulting in fewer page faults.","Similarly, data members in the same groups will tend to co-reside in any cache that may be in the memory system (including processing unit-resident cache). Thus, properly grouping the data will also lead to fewer cache misses, making more effective use of the cache.","A shorthand name for techniques that group data members of objects within memory to enhance performance is \u201cdata layout optimization.\u201d \u201cOptimization\u201d or \u201coptimize\u201d means improvement in the direction of optimal; an optimal layout may or may not be produced by a data layout optimization technique.","An overview of an exemplary data layout optimization method is shown in . At , profile data for the object is collected. Examples of profile data are shown in the illustrated embodiments below. At , the data members of an object are grouped based on the profile data. Techniques for achieving such grouping are shown below. Then, at , at runtime, data members from the same groups are arranged at neighboring locations in the memory system; members from different groups are placed at locations separately loadable from each other (e.g., members from Group A are placed at locations in one page of memory, and members from Group B are placed at locations in another page of memory).","An overview of an exemplary architecture of a data layout optimization system is shown in , , and .  shows an exemplary arrangement for collecting profiling data. The software  to be profiled includes an object class definition . For example, the object class definition  could specify a set of data members of varying sizes and types.","The instrumentor  takes the software  as input and produces the instrumented software  (which includes an object class definition  identical to or based on the object class definition ) for generating the profiling data . Further, various options  can be specified to the instrumentor  to tailor the instrumented software  to generate various types of profiling data . In this way, profiling data for an object can be collected.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 7","FIG. 6"],"b":["712","702","632","722","712","732","722","714","712"]},"An exemplary decorated object class definition  is represented on a basic level as shown in inset . Data members mand mhave been grouped into group G, and data members m, m, and mhave been grouped into group G. A variety of other information can be included in the decorated object class definition  to further specify layout as described in more detail below.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 8","FIG. 7"],"b":["802","804","732","810","812","822","822"]},"As the program is run, the memory system  may appear as generally shown in inset . Two data members mand mof group Greside in one page  in primary memory of the memory system  and have also been placed in cache. Two other data members m, m, and mof group Greside in another page  in secondary memory of the memory system . The data members of group Gare separately loadable into primary memory, and are not currently loaded into primary memory.","An advantage to the arrangement shown in  is that if the data member grouper has placed, for example, more frequently used data members in group Gand less frequently used data members in group G, fewer page faults and cache misses will result. This is partly because each page fault for the page  brings in the group Gof the more referenced data members, while leaving the less referenced data members behind in page . Thus, in effect, a page of primary memory is conserved for use by another page (e.g., one which would have been replaced to load in the data members in group G).","The overview shown in  is a basic representation of possible implementations of a data layout optimization technique. In practice, the data layout may involve many more objects, data members, and pages (or other units of memory) in a memory system.","Instrumentation","A wide variety of instrumentation techniques can be used to generate profile data for use during data layout optimization. Some tools capture complete traces of software by generating a record in a database for each memory reference to any data. Such a trace can prove to be quite large, so various techniques can be used to reduce the size of the profile data. On a general level, the instrumentation attempts to measure the number of memory references to data members of an object (e.g., fields of an object).","An exemplary format for data captured during instrumentation appears in Table 1.",{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Logical Data Captured for Data References"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Field","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"ObjClass","Class of the Object having data being"]},{"entry":[{},{},"referenced"]},{"entry":[{},"FieldID","Identifier of the data member (e.g., field)"]},{"entry":[{},{},"of the object being referenced"]},{"entry":[{},"StaticOrNot","Boolean field to indicate whether the data"]},{"entry":[{},{},"member is a static field"]},{"entry":[{},"Width","Width of data member (e.g., byte, dword,"]},{"entry":[{},{},"etc.)"]},{"entry":[{},"RefType","Either \u201cread\u201d or \u201cwrite\u201d"]},{"entry":[{},"Time","Indicates a time at which the data was"]},{"entry":[{},{},"referenced (e.g., microsecond resolution"]},{"entry":[{},{},"or better)"]},{"entry":[{},"ObjectID","Identifier of the object instance"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"One way of reducing the size of the profile data is to track the number of memory references in counters (e.g., a read counter and a write counter) for each data member and then write one record to the database for each method call. Preferably, the counters are 64-bit integers. In such a system, repetitive entries of the format shown in Table 2 can be used.",{"@attributes":{"id":"p-0108","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Profiling Data Captured for References During a Method Call"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ObjClass","Class of the Object having data being referenced"]},{"entry":["FieldID","Identifier of the data member (e.g., field) of the"]},{"entry":[{},"object being referenced"]},{"entry":["StaticOrNot","Boolean field to indicate whether the data member"]},{"entry":[{},"is a static field"]},{"entry":["Hits","Number of memory references to the data member"]},{"entry":["Width","Width of data member (e.g., byte, dword, etc.)"]},{"entry":["ReadHitCount","Number of memory references reading the data"]},{"entry":[{},"member"]},{"entry":["WriteHitCount","Number of memory references writing to the data"]},{"entry":[{},"member"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Another instrumentation technique involves setting a timer and then tracking the number of memory references to each data member in counters (e.g., read and write counters). Upon expiration of the timer, a record with a column for each data member is written to the database and the counters are reset to zero. For data members having zero references, space can be saved by omitting the number. The format of such records resembles those shown in Table 2.","Still another technique involves using an overflow interrupt. On machines supporting an overflow interrupt, a record is generated when such an overflow interrupt is generated due to a counter overflow. Upon overflow, a record is written to the database.","Still another technique possibly used in conjunction with the method-based or timer-based technique (or similar techniques) is one that generates a record for the database whenever an overflow of the counter is likely. The likelihood of overflow can be represented by saving the time trend of the counts and extrapolating. Example code for forecasting an overflow is shown in . The counter L tracks the number of memory references (i.e., \u201chits\u201d) to a data member of a certain object class during, for example, a method call. The code shown in  is executed upon exit from an object's method. The counter H is an overall counter tracking sums of L. Steps are taken to avoid an overflow of H.","Derivation of the forecaster formula \u201c(H\u2212H)+H\u201d is illustrated in the graph  of . Assume  represents a point at which the value of the overall counter was observed to be H (the previous value of the overall counter) at time T\u2212D. Further,  represents a point at which the overall counter was observed to be H at time T. Point  represents a point at which the overall counter will be observed to be the forecast value F at time T+D (e.g., after the next method call). Point  can be extrapolated as shown in Table 3.",{"@attributes":{"id":"p-0113","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Extrapolation of Overflow Value"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"F","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["Forecast","value"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},{"mstyle":{"mtext":"H"},"mo":"+","mrow":{"mfrac":{"mrow":[{"mrow":{"mo":["(",")"],"mrow":{"mi":["T","D2"],"mo":"+"}},"mo":"-","mi":"T"},{"mi":"T","mo":"-","mrow":{"mo":["(",")"],"mrow":{"mi":["T","D1"],"mo":"-"}}}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":["H","H1"],"mo":"-"}}}}],"mo":"="}}}}]},{"entry":[{},{}]},{"entry":[{},"Assuming D1 and D2 are both D, we have"]},{"entry":[{},{}]},{"entry":[{},{"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"F","mo":"=","mrow":{"mi":"H","mo":"+","mrow":{"mfrac":{"mrow":[{"mrow":{"mo":["(",")"],"mrow":{"mi":["T","D"],"mo":"+"}},"mo":"-","mi":"T"},{"mi":"T","mo":"-","mrow":{"mo":["(",")"],"mrow":{"mi":["T","D"],"mo":"-"}}}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":["H","H1"],"mo":"-"}}}}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mi":"H","mo":"+","mrow":{"mfrac":{"mrow":[{"mi":["T","D","T"],"mo":["+","-"]},{"mi":["T","T","D"],"mo":["-","+"]}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":["H","H1"],"mo":"-"}}}}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mi":"H","mo":"+","mrow":{"mfrac":{"mi":["D","D"]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":["H","H1"],"mo":"-"}}}}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mi":"H","mo":"+","mrow":{"mo":["(",")"],"mrow":{"mi":["H","H1"],"mo":"-"}}}}}}]},"mo":"\u2003"}}}}]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"One data layout optimization technique, sometimes called \u201cgreedy,\u201d groups the data members based on a simple ordering by the number of memory references as indicated by the profile data. The technique is greedy in the sense that data members having more references (as indicated by the profile data) are placed in a more favored group. The following illustrates various possible greedy data layout optimization techniques.","Using an instrumentation technique, such as one of the instrumentation techniques described above, profiling data such as that shown in Table 4 can be collected for an object class Foo during execution of a piece of software.",{"@attributes":{"id":"p-0116","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Profile Data for Class Foo"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Data Member","References"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"m","47"]},{"entry":[{},"m","0"]},{"entry":[{},"m","5"]},{"entry":[{},"m","34"]},{"entry":[{},"m","1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"In a greedy grouping technique, arrangement of data members is determined by sorting the fields from most referenced in memory to least referenced in memory. Various criteria can then be used to place the data members into \u201chot\u201d (more referenced) and \u201ccold\u201d (lesser referenced) groups. Assuming the lesser referenced data members are less likely to be accessed at any given time, the greedy technique increases performance by facilitating loading the hotter groups into more readily accessible memory without having to move the data members in the colder groups along with them.","Data Layout Optimization Assistance Tools","Various techniques can be used to determine how to split a class (i.e., group the data members into groups). The examples listed here show splitting the data members into two groups, but a similar technique is used to split data members into three or more groups.","A simple splitting technique simply specifies a threshold (e.g., percentage of references) and splits the data members of a class into two groups: a hot group and a cold group. If the profiling data indicates a particular data member has at least the threshold (e.g., percentage of the references), it is placed in the hot group; data members having less than the threshold (e.g., percentage of references) are placed in the cold group.","In practice, however, the splitting technique can be more complex. A variety of techniques or mixture of techniques may result in superior performance. In some cases, it may not be advantageous to split the data members. For example, in an implementation in which splitting the data members introduces overhead, it is not advantageous to split a class into a hot group and a cold group if the size of the overhead in the hot group is not smaller than the size of the cold group.","An analysis of the profile data can be used to provide tools for assistance in deciding whether to split a class. These tools can be used, for example, by a developer to specify parameters during the data layout optimization process. Such tools include a threshold framework and a policy framework. The frameworks use formulas for hit-count statistics shown in Table 5 and global hit-count statistics shown in Table 6. The term \u201chit\u201d is used to mean a memory reference to a data member (e.g., a object field).",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Hit-Count Statistics for Class C"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"C\u00b7 NF = number of fields in class C"},{"entry":"C\u00b7 HC= number of hits on field j of class C."},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HC"},{"mo":["(",")"],"mrow":{"mstyle":{"mtext":"total hit count in class "},"mo":"\u2062","msub":{"mi":["C","i"]}}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}},{"munderover":{"mo":"\u2211","mrow":[{"mi":"j","mo":"=","mn":"1"},{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"NF"}]},"mo":"\u2062","mrow":{"msub":[{"mi":["C","i"]},{"mi":["HC","j"]}],"mo":"\u00b7"}}],"mo":"="}}}}},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mstyle":[{"mtext":"Then,"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"(the average hit count in class "},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"per field)"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HA"},"msub":{"mi":["C","i"]}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HC"},{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"NF"}]}}}}}},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HC2"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"(sum of squares of hit count in class "},{"mtext":")"}],"msub":{"mi":["C","i"]}},{"munderover":{"mo":"\u2211","mrow":[{"mi":"j","mo":"=","mn":"1"},{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"NF"}]},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["C","i"]},{"mi":["HC","j"]}],"mo":"\u00b7"}},"mn":"2"}}],"mo":"="}}}}},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"Then","mo":","}}},{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"SD"},{"mo":"(","mrow":{"mi":["standard","deviation","of"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}},{"mtd":{"mrow":{"mrow":{"mi":["hit","counts","in","class"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msub":{"mi":["C","i"]}},"mo":")"}}}]},"mo":"=","msqrt":{"mrow":{"mfrac":{"mn":"1","mrow":{"mi":["Ci","NF"],"mo":"\u00b7"}},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"j","mo":"=","mn":"1"},{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"NF"}]},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"msub":[{"mi":["C","i"]},{"mi":["HC","j"]}],"mo":"\u00b7"},{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HA"}],"mo":"-"}},"mn":"2"}}}}}}},{"mtd":{"mrow":{"mo":"=","msqrt":{"mrow":{"mrow":{"mfrac":{"mn":"1","mrow":{"mi":["Ci","NF"],"mo":"\u00b7"}},"mo":"\u2062","mrow":{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HC2"}},"mo":"-","msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HA"}},"mn":"2"}}}}}}]}}}]},"mo":"\u2003"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Global Hit-Count Statistics"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"NC = number of classes in profiling data for a program"},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"GNF","mo":["\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"(global number of fields in all classes) "}]},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"NC"},"mo":"\u2062","mrow":{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"NF"}}],"mo":"="}}}}},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"GHC","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["global","hit","count"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"NC"},"mo":"\u2062","mrow":{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HC"}}],"mo":"="}}}}},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"GHA","mo":["\u2062","(",")"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mi":["global","average","hit","count","per","field"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},"mo":"=","mfrac":{"mi":["GHC","GNF"]}}}}}},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"GHC2","mo":["\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"(sum of squares of hit counts in all classes) "}]},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"NC"},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HC"}},"mn":"2"}}],"mo":"="}}}}},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mtable":{"mtr":[{"mtd":{"mrow":{"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"GSD","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":"(","mrow":{"mi":["standard","deviation","of"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}}},{"mtd":{"mrow":{"mrow":{"mi":["hit","counts","in","all","classes"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":")"}}}]},"mo":"=","msqrt":{"mrow":{"mfrac":{"mn":"1","mi":"GNF"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"NC"},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"mrow":{"msub":{"mi":["C","i"]},"mo":"\u00b7","mi":"HC"},"mo":"-","mi":"GHA"}},"mn":"2"}}}}}}},{"mtd":{"mrow":{"mo":"=","msqrt":{"mrow":{"mrow":{"mfrac":{"mn":"1","mi":"GNF"},"mo":"\u2062","mi":"GHC2"},"mo":"-","msup":{"mrow":{"mo":["(",")"],"mi":"GHA"},"mn":"2"}}}}}}]},"mo":"\u2003"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Absolute thresholds have the advantages of precision and convenience. Although absolute thresholds depend on the total number of hits in a profiling run, they can be normalized by dividing all hit count measurements by GHC.","Gaussian thresholds have the advantage of being in a manageable range (e.g., 1\u20133). However Gaussian thresholds assume the hit counts have a normal distribution, which is not the case if the distribution is bimodal (e.g., there are a large number of fields with many hits and a large number of fields with zero hits).","Linear thresholds are often larger numbers than the Gaussian thresholds, but do not assume a normal distribution. A number of other techniques (e.g., rank-order or non-parametric statistics) could also be used.","For example, consider the profiling data in Table 7 and the corresponding analysis of Table 8. For purposes of example, assume the global average hit count per field (GHA) is 34.",{"@attributes":{"id":"p-0128","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Profile Data for Class Foo"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Field","Hits"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f","47"]},{"entry":[{},"f","0"]},{"entry":[{},"f","5"]},{"entry":[{},"f","34"]},{"entry":[{},"f","1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0129","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Analysis of Profile Data for Class Foo"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Foo.NF number of fields in class Foo = 5"},{"entry":"Foo.HCnumber of hits on field 1 of class Foo = 47."},{"entry":"Foo.HC= 0, Foo.HC= 5, Foo.HC= 34, Foo.HC= 1."},{"entry":"Foo.HC (total hit count in class Foo) = 87"},{"entry":"Foo.HA (the average hit count in class Foo per field) = 17.4"},{"entry":"Foo.HC2 (sum of squares of hit count in class Foo) = 3391"},{"entry":"Then, Foo.SD (standard deviation of hit counts in class Foo) = 19.4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Using the above formulas, a policy framework can be constructed to help specify when a class should be split into groups of data members. Given a proposed (or \u201ccandidate\u201d) cold group, a policy within the framework specifies whether or not the class should be split. Typically, the proposed cold group is specified via a threshold from the threshold framework.","The policy framework is useful, for example, to provide a way for a developer to provide guidance to the splitting process. In the policy framework, a default policy can be specified to apply to all classes. Further, the default policy can be overridden by specifying a policy for a particular class. Essentially, the policy specifies a Boolean result, which determines whether or not to split the class based on the proposed cold group. The policy framework provides the options shown in Table 9.",{"@attributes":{"id":"p-0132","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Global Policy Defaults"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Split if the cold group",{}]},{"entry":["Policy","is bigger than . . .","Split if . . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["H( )","Hot group overhead only","size of cold group >"]},{"entry":[{},"(this policy is the default","size of hot group"]},{"entry":[{},"if no policy specified)","overhead"]},{"entry":["HC( )","Hot group overhead and","size of cold group >"]},{"entry":[{},"cold group overhead","(cold group overhead +"]},{"entry":[{},{},"hot group overhead)"]},{"entry":["HFC(f)","Hot group overhead and a","size of cold group >"]},{"entry":[{},"fraction, f, of cold group","(f * cold group overhead +"]},{"entry":[{},"overhead","hot group overhead)"]},{"entry":["HFA(f)","Hot group overhead and cold","(((hit count for cold"]},{"entry":[{},"group overhead if cold is","group\/number of fields in"]},{"entry":[{},"warmer than fraction f of GHA","cold group) > (f * GHA))"]},{"entry":[{},{},"&& HC( )) \u2225 H( ))"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"For example, if the cold group is very cold, the space overhead created in the cold group may be tolerable since the cold group will not be referenced much. However, if the cold group is merely \u201ccool,\u201d the cool group will be referenced more frequently, and it is more a matter of judgment on how to proceed. The above-described policy framework provides a way to specify how to proceed in light of such scenarios.","The threshold and policy frameworks can provide a way for the developer to guide the data layout optimization process. For example, a software developer may have identified a particular class as large and critical to performance. The software developer can contribute this knowledge to the automatic optimization process by specifying these classes (e.g., in a command line or in a file) in conjunction with instructions on what threshold and policy to use.","Thus, the developer can specify a threshold and policy for each class. Other tools provided to the developer include options for specifying that all or only a subset of the classes should be considered for splitting. An exemplary command line interface for specifying the options is shown in a later section.","Splitting a Class According to a Greedy Method","For each class specified as a candidate for splitting, the threshold and policy are applied to determine whether and how to split the class. For example, returning now to Table 7, assume a linear threshold was specified to indicate that fields with a hit count greater than or equal to the global average hit count (GHA=34) are to be placed in a hot group for the class; other fields are to be placed in a cold group. Thus, fields fand fare grouped in the hot group, and fields f, f, and fare grouped in the cold group.","Metadata Associated with the Execution Engine","The above-described grouping of data members can be used when the program is executed to arrange the data members from the same group into neighboring locations in a memory system and place data members from different groups into separately-loadable units of memory. One way of accomplishing such arrangement is to generate metadata for use by an execution engine at run time. The term \u201cmetadata\u201d generally means, \u201cdata about the data.\u201d In other words, the metadata provides information about the data members of an object, namely into what groups the data members have been placed and thus, how they should be arranged at runtime.","For example, a format such as that shown in Table 10 can be used to specify various options to be used by a class loader of an execution engine.",{"@attributes":{"id":"p-0139","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Metadata Format for Specifying Groups"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Class C"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LayoutType = (AutoLayout, ExplicitLayout, or SequentialLayout)"]},{"entry":[{},"Data Member m:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Position]"]},{"entry":[{},"Offset\/Delta (offset if ExplicitLayout, shift if SequentialLayout)"]},{"entry":[{},"SplitGroupID (zero means no grouping)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data Member m:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Position]"]},{"entry":[{},"Offset\/Delta"]},{"entry":[{},"SplitGroupID"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Following the LayoutType is a specification for data members of the class. Position may be specified, or it can be implied by the order in which the data members appear (i.e., the first data member is assigned a position of 1).","Offset\/Delta can take on different meanings. If the option ExplicitLayout has been specified, Offset\/Delta specifies an actual offset (from the top of the object or group) at which the data member is located. Overlapping layout (e.g., for unions) can be permitted. If the option SequentialLayout has been specified, Offset\/Delta specifies a shift indicating how far after the present data member the next data member starts (essentially, the data member's size). Another optional field, not shown, specifies the field preceding the present field (the PredecessorField).","Exemplary metadata for a class Foo that has been split into two groups of fields (fand f) and (f, f, and f) is shown in Table 11.",{"@attributes":{"id":"p-0143","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Metadata for Foo"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Class Foo"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LayoutType = ExplicitLayout"]},{"entry":[{},"Data Member f:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Offset\/Delta: 0"]},{"entry":[{},"SplitGroupID: 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data Member f:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Offset\/Delta: 3072"]},{"entry":[{},"SplitGroupID: 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data Member f:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Offset\/Delta: 0"]},{"entry":[{},"SplitGroupID: 2"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data Member f:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Offset\/Delta: 1024"]},{"entry":[{},"SplitGroupID: 2"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data Member f:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Offset\/Delta: 1056"]},{"entry":[{},"SplitGroupID: 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"At runtime, the metadata can be consulted to determine how to actually arrange the data members in the memory system. From the perspective of software accessing an object, the data member arrangement is inconsequential. For example, an instance  of an object of a class called \u201cFoo\u201d might appear to software as shown in . A class loader placing an instance of the class Foo in memory might layout the fields in separately-loadable groups  if the class definition is decorated with metadata as described above. Fields fand fare placed at neighboring locations in a hot group , which has a pointer to the cold group , containing fields f, f, and fat neighboring locations separate from the hot group . The number of references for each of the fields is shown in ; however, this data need not reside with the field in memory.","The layout in  is meant as a general guide. A more detailed approximation of how the object would actually appear is shown in , which again shows how an instance  of the class Foo might appear in memory. A hot group  contains the fields fand fand a cold group  contains the fields fields f, f, and f. The hot group  further includes a pointer to the object information set , and the cold group  further includes a pointer to the object information set . The object information sets  and  provide, for example, information for garbage collection functions and VTableSlots that point to function members of the object. In some cases, there may be gaps between the fields, and an implementation could be constructed that uses an alternative VTable arrangement or an arrangement not using a VTable. The principle of data layout optimization can be implemented without various of the fields shown, including the fields related to garbage collection.","As a result of the arrangement described above, fields in the same group tend to reside in the same unit(s) (e.g., page or pages) of virtual memory in the memory system, and fields in different groups tend to reside in different units, separately loadable into primary memory from units for other groups. During execution, then, the fields in the hot group are more likely to occupy primary memory than fields in the cold group. Further, the software tends not to fill up its available primary memory (e.g., the resident set) with fields in the cold group, which are relatively seldom referenced.","Exemplary Operation","Data layout optimization of an object class increases performance during execution of a piece of software that makes use of the object class. For example, for purposes of comparison, the following two examples demonstrate how data layout optimization better utilizes primary memory and reduces page faults and cache misses. For purposes of the examples, when data is referenced, the cache copies the referenced data and a portion of the data following the referenced data.","In the first example, shown in , assume the exemplary class Foo were laid out (e.g., the fields f, f, f, f, and f) without regard to the profile data and thus were arranged in sequential order by the class loader. Accordingly, fields f, f, and f, have been placed in one memory page Pand fields f, and fhave been placed in another memory page P. Fields fand fare of another class called \u201cbaz\u201d and reside in another memory page P.","Each of the memory pages pictured is separately loadable into the primary memory . And, in fact, during execution, two pages Pand Phave been loaded into the primary memory  since the software has been referencing fields fand fof the object Foo (as the profile data indicated was likely). Assume the most recent reference to a data member was to f; accordingly, fand f(data following f) have found their way into the cache . The software then references f(a likely memory reference, based on the profile data). At this point, a cache miss results. Further, when the second page Pwas loaded into memory, it replaced another page Phaving a field fthat is about to be referenced shortly for the baz object. Accordingly, a page fault results when fis referenced, and Pis copied from secondary memory . We thus have a cache miss and a page fault.","By contrast, consider the same software that has been optimized with data layout optimization as described above (e.g., the fields fand freside in a hot group and f, f, and freside in a cold group). During execution, the software has been referencing fields fand fof the object Foo, as the profile data indicated was likely. Such references resulted in the arrangement shown in , where one page Pfrom the virtual memory system containing fields fand fhas been loaded into the primary memory  for the Foo object. Assume the most recent reference to a data member was to f; accordingly, fand fhave found their way into the cache . The software then references f(as in the example of ). At this point, there is no cache miss. Further, since Phas yet to be loaded into primary memory, the page Pwas permitted to stay in primary memory. Accordingly, there is no page fault when fis referenced, and Pneed not be copied from secondary memory . Thus there were no cache misses and no page faults.","As demonstrated by the above example, data layout optimization can result in loading fewer pages into primary memory (e.g., resulting in fewer page faults) and fewer cache misses. The above example is simplistic, but a more complex system exhibits similar benefits. Another way of describing the improvement in performance is to note that primary memory is not wasted by filling it with fields from the cold group every time there is a reference to the hot group. In this way, if the principles of data layout optimization are applied to a set of objects, primary memory tends to fill with fields that are frequently accessed (e.g., from the set of objects), and better use is made of the primary memory available to the software.","Using the Time Domain in an Affinity-Based Technique","Although the greedy technique described above may lead to dramatic improvements in performance in some instances, an affinity-based technique may be even better because it takes the time domain into account. Generally, the affinity-based technique strives to place data members referenced close in time close in location within the memory system. One embodiment described below performs a dot product calculation to determine affinity.","Again, various techniques can be used to determine how to split the data members into groups. For example, an embodiment described below finds the minimum-cost spanning tree of a graph defined in terms of affinity between the data members.","Instrumenting for an Affinity-Based Technique","Since the affinity-based technique takes the time domain into account, instrumentation of the software somehow represents the time domain in the profile data generated. Various techniques described in the section on a greedy technique can be used as long as they somehow incorporate the time domain. For example, the timer-based technique would work with an affinity-based data layout optimization technique.","Profile Data for an Affinity-Based Technique","Exemplary profile data for use in an affinity-based technique represents references to an object class called \u201cBar\u201d and is shown in Table 12.",{"@attributes":{"id":"p-0156","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 12"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Profile Data for Class Bar"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Field","Hit Counts"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f","5","6","7",{},{},{},{}]},{"entry":[{},"f",{},"2",{},"5","5","5"]},{"entry":[{},"f",{},{},{},{},"6","6","5"]},{"entry":[{},"f","3","4","5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"8","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"sub":["1 ","4 ","1 ","2"]},"In order to determine how to group the data members of a class based on profile data such as that shown in Table 12, the profile data can be transformed into a minimum-cost spanning tree problem, the solution to which is established and well-known. Such transformation is accomplished by constructing an affinity matrix for the profile data, then transforming the affinity matrix into a cost matrix, which represents a graph for which a minimum-cost spanning tree can be found and traversed to determine an appropriate data member order.","Constructing the Affinity Matrix","An affinity matrix indicates which fields are referenced near each other in time. For example, treating the entries for the fields shown in Table 12 as time vectors, an affinity matrix can be constructed by calculating the dot product of the vectors. Thus, the affinity of data member A to data member B can be calculated as shown in Formula 1, where T is the number of time samples. \n\n\nSelf-affinities (e.g., A\u2022A and B\u2022B) allow the affinity-based approach to degrade to a simply greedy technique when there is no affinity between the data members.\n","One way of describing the profile data is to call it a matrix V, of size N\u00d7T, where N is the number of data members, and T is the number of time samples. Then the affinity matrix is the matrix V matrix multiplied by V transpose. The affinity matrix is thus square (N\u00d7N). Typically, N is smaller than T, so the affinity matrix will be smaller than V (the profile data) and more easily stored. In the example, calculation of the affinity matrix is of complexity N*N*T. To reduce time complexity or reduce the amount of storage needed for the profile data, T (the number of time samples) can be reduced. Preferably, the affinities are computed using 128-bit integers (e.g., a pair of native 64-bit integers).","If there are N fields in an object class definition, then there are N(N+1)\/2 meaningful entries in the affinity matrix (the matrix is symmetric). A numerically larger entry in the affinity matrix indicates greater mutual locality of the two fields corresponding to the indexes of the entry, and therefore, generally, a greater desirability to lay them out nearby in space (e.g., at neighboring locations or on the same page in memory).","When the above-described calculations are performed on Table 12, the result is as that shown in Table 13.",{"@attributes":{"id":"p-0162","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Affinity Matrix for Class Bar"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"20.24mm","wi":"49.95mm","file":"US07013459-20060314-C00001.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"sub":["1","2 ","1","4"]},"One way of describing the affinity matrix is to call the vectors represented in Table 12 geometrical vectors in a Euclidean space. This space has a number of dimensions equal to the number of time samples, T. Each dimension, then, is a time-slice in which objects may be active. The magnitude of a vector in Euclidean space is the root sum of squares of the components. Thus, self-affinities in Table 13 are squared magnitudes of the time vector for objects of a particular class. The off-diagonal affinities are dot products in the geometrical sense under this approach.","Thus, the off-diagonal affinities can be related to the magnitudes of two vectors and an angle between them as shown in formula 2.\n\n\u2225cos(\u03b8)\u2003\u2003(2)\n\nThis angle can be described as a measure of the nearness of two time vectors in Euclidean space, independent of their magnitudes. The nearness can be generally called \u201cco-locality.\u201d\n\nConversion of the Affinity Matrix to a Cost Matrix\n","Typically, techniques for finding a solution to a cost matrix are posed in terms of minimizing cost; however, the aim of a data layout optimization technique is to maximize affinity. Therefore, the following illustrated example calculates a cost matrix by subtracting each affinity from the maximum affinity plus one (this approach is known as additive reflection). Thus, the lowest cost in the matrix will be one. The cost matrix for class Bar calculated using additive reflection is shown in Table 14. An alternative would be to calculate reciprocals (e.g., 1\/affinity) or rationalization about the least common multiple of the affinities.",{"@attributes":{"id":"p-0166","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Cost Matrix for Class Bar"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00002","num":"00002"},"img":{"@attributes":{"id":"EMI-C00002","he":"20.32mm","wi":"49.95mm","file":"US07013459-20060314-C00002.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Accordingly, a graph representing the cost matrix of Table 14 is shown in , the minimum-cost spanning tree is shown in , and a method for ordering the data members is shown in .","The method of  uses a minimum-cost, depth-first approach (which degrades to a greedy approach under certain circumstances), although other approaches (e.g., minimum-cost, breadth first) may yield better performance in some instances. At , a minimum-cost spanning tree is constructed from the graph representing the cost matrix (e.g., the graph shown in ). Techniques for constructing a minimum-cost spanning tree include Kruskal's and Prim's algorithms. These algorithms have running times of O(E 1g V) and O(E+V 1g V), respectively (where E is the number of edges, and V is the number of vertices). The minimum-cost spanning tree of the graph shown in  is shown in .","The vertices are then traversed and the order of visitation recorded. At , traversal begins with the vertex of lowest cost (e.g. fin the tree shown in ). The method then repetitively applies the technique , which involves traversing the subtree connected by the lowest cost edge at  (e.g., initially the edge connecting fto f) according to the technique  (e.g., recursively), then traversing the subtree connected by the other edge at  according to the technique . Such a traversal results in the ordering shown in Table 15. For purposes of example, an edge cost is also shown as a mechanism for deciding how to split the data members into groups.",{"@attributes":{"id":"p-0170","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 15"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Member Ordering for Class Bar"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Data Member","Edge Cost"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"f",{}]},{"entry":[{},"f","37"]},{"entry":[{},"f","99"]},{"entry":[{},"f","51"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"sub":["1 ","4","2 ","3"]},"In some cases, there will be disconnected components of the graph. The data members can be grouped according to the disconnected components (e.g., data members in the same disconnected component are placed into the same group; data members in different disconnected components are placed into different groups). Additionally, more than one group can be used for a particular disconnected component if appropriate.","The affinity-based approach can be used in combination with various of the features described for the greedy approach, such as calculating averages (e.g., average edge cost), specifying an absolute value, or calculating standard deviations.","Declarative Layout Directives","To provide a software developer with further control over the data layout optimization process, declarative layout directives can be provided. For example, a developer can place a directive in source code to indicate that a particular class should not be optimized. In this way, the developer can explicitly opt out of the data layout optimization process for data members that, for example, may not function properly if rearranged or separated.","Display of Affinity Information","To provide a software developer with further information about affinities between data members, the affinity data can be displayed. For example, a graded color scheme shows the various data members as vertices in a graph, with colored lines according to the scheme (e.g., red represents a high affinity) connecting the vertices of the graph. Also, a graph (e.g., a pie chart) shows which data members are being referenced how often. Activating a part of the graph relating to a data member displays the data member's affinity with the other data members also in the form of a graph (e.g., another pie chart).","In this way, the developer is provided with information about the behavior of an object and can better craft a high-performance object set.","Inheritance","Supporting inheritance while grouping the data members poses some special problems. Generally, one way of solving these problems is to combine data concerning a parent class (including children of the parent class) and choose a single layout.","Static Fields","Static fields typically present a special case because there is only one value per class for a set of instances of the class. One alternative is to group static fields together or use different splitting thresholds for static fields.","Exemplary Command Line Options for Instrumentation and Grouping","As explained in the section on instrumentation, various options can be chosen when instrumenting code. Table 16 shows a possible command line scheme for specifying such options. Table 17 shows a possible command line scheme for a data member grouper for specifying options during the grouping process.",{"@attributes":{"id":"p-0179","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 16"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command line options for the instrumentor"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Example","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Instrument\/TimeDriven: sampleRate","Use a timer-based profile"]},{"entry":["Program.exe","data collection technique; set"]},{"entry":[{},"the time to expire every"]},{"entry":[{},"sampleRate milliseconds"]},{"entry":["Instrument\/MethodDriven","Use a method-based profile"]},{"entry":["Program.exe","data collection technique"]},{"entry":["Instrument\/OverflowDriven","Use an overflow-driven"]},{"entry":["Program.exe","profile data collection"]},{"entry":[{},"technique (if supported)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0180","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 17"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command line options for the Data Member Grouper"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Example","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["DataOptimizer\/greedy Program.exe","Use a simple greedy"]},{"entry":[{},"technique to order the data"]},{"entry":[{},"members"]},{"entry":["DataOptimizer\/greedy\/","Use a greedy technique to"]},{"entry":["GlobalLinearThreshold:","order the data members,"]},{"entry":["multiplesOfMean Program.exe","and split at the specified"]},{"entry":[{},"multiplesOfMean"]},{"entry":["DataOptimizer\/greedy\/","Use a greedy technique to"]},{"entry":["GlobalAbsoluteThreshold: hitCounts","order the data members,"]},{"entry":["Program.exe","and split at the specified"]},{"entry":[{},"hitCounts"]},{"entry":["DataOptimizer\/greedy\/","Use a greedy technique to"]},{"entry":["GlobalGaussianThreshold:","order the data members,"]},{"entry":["standardDeviations Program.exe","and split at the specified"]},{"entry":[{},"standardDeviations"]},{"entry":["DataOptimizer\/affinity Program.exe","Use an affinity-based"]},{"entry":[{},"technique to order the data"]},{"entry":[{},"members"]},{"entry":["DataOptimizer\/affinity\/","Use an affinity-based"]},{"entry":["GlobalLinearThreshold:","technique to order the data"]},{"entry":["multiplesOfMean Program.exe","members, and split at the"]},{"entry":[{},"specified multiplesOfMean"]},{"entry":["DataOptimizer\/affinity\/","Use an affinity-based"]},{"entry":["GlobalAbsoluteThreshold: hitCounts","technique to order the data"]},{"entry":["Program.exe","members, and split at the"]},{"entry":[{},"specified hitCounts"]},{"entry":["DataOptimizer\/affinity\/","Use an affinity-based"]},{"entry":["GlobalGaussianThreshold:","technique to order the data"]},{"entry":["standardDeviations Program.exe","members, and split at the"]},{"entry":[{},"specified"]},{"entry":[{},"standardDeviations"]},{"entry":["\/ClassLinearThreshold: className,","A per-class threshold"]},{"entry":["multiplesOfMean","overriding the globally-"]},{"entry":[{},"specified option"]},{"entry":["\/ClassAbsoluteThreshold: className,","A per-class threshold"]},{"entry":["hitcounts","overriding the globally-"]},{"entry":[{},"specified option"]},{"entry":["\/ClassGaussianThreshold: className,","A per-class threshold"]},{"entry":["standardDeviations","overriding the globally-"]},{"entry":[{},"specified option"]},{"entry":["\/splitOnly: className","splits only the class"]},{"entry":[{},"specified (may be specified"]},{"entry":[{},"zero or more times in the"]},{"entry":[{},"command line)"]},{"entry":["\/splitOnly: *","split all classes"]},{"entry":["\/globalQualification: x","Where x is H; HC;"]},{"entry":[{},"HCF, realNumber; or"]},{"entry":[{},"HCA, realNumber"]},{"entry":["\/classQualification: x","Where x is H; HC;"]},{"entry":[{},"HCF, realNumber; or"]},{"entry":[{},"HCA, realNumber"]},{"entry":["\/responseFile: filename","take options from fileName"]},{"entry":[{},"instead of the command"]},{"entry":[{},"line"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"Another way of achieving data layout optimization is to include profiling functionality in an execution engine. In this way, data member grouping is based on behavior of the object as observed in its actual environment, rather than a test environment. Data member grouping might therefore change over time, leading to dynamic data layout optimization.","Having described and illustrated the principles of our invention with reference to illustrated embodiments, it will be recognized that the illustrated embodiments can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computer apparatus, unless indicated otherwise. Various types of general purpose or specialized computer apparatus may be used with or perform operations in accordance with the teachings described herein. Elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa. Although reference is sometimes made to \u201can\u201d object class or \u201ca\u201d data member, multiple object classes with a plurality of fields can be used. In view of the many possible embodiments to which the principles of our invention may be applied, it should be recognized that the detailed embodiments are illustrative only and should not be taken as limiting the scope of our invention. Rather, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 16","FIG. 15"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 17","FIG. 15"]}]},"DETDESC":[{},{}]}
