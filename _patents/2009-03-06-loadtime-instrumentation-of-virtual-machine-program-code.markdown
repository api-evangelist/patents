---
title: Load-time instrumentation of virtual machine program code
abstract: A method to instrument program code for a virtual machine that comprises, in the course of loading a class to a virtual machine, adding code to the class to declare a field that corresponds to a field declared in a first bootstrap class.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08863093&OS=08863093&RS=08863093
owner: Coverity, Inc.
number: 08863093
owner_city: San Francisco
owner_country: US
publication_date: 20090306
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The invention relates to in general to dynamic analysis of computer software targeted to a virtual machine, and more particularly, to instrumenting program code executed using a virtual machine.","2. Description of the Related Art","A typical computing system comprises a hardware layer, an operating system layer and an application layer that runs on top of the operating system. Virtualization software abstracts a virtual machine (VM) by interposing an additional layer within the system. A virtual machine itself is a target for a programmer or compilation system. A VM runs programs written and compiled for its abstract machine definition.","An application layer VM, for example, sits as an application program on top of an operating system. A typical application level VM runs as a normal application inside an operating system. The VM can be created when a process is started and can be destroyed when the process exits. A VM abstracts away details of the underlying hardware and operating system to allow a program targeted to the VM to execute in the same way on different computer system platforms. Java, Smalltalk and the .NET Framework are examples of application layer VM environments. A Java virtual machine (JVM) is a virtual machine that executes object oriented code known as bytecode that is compiled specifically to it. The Java programming language does not rely on platform-specific instructions sets, such as APIs specific to any one operating system to access or display resources such as files. Rather, in a Java runtime environment, Java-specific commands are interpreted.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIGS. 1A-1B","FIG. 1A","FIG. 1B","FIGS. 1A-1B","FIG. 1A","FIG. 1B"],"b":["102","104","106","108","106","106","110"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2","b":["108","112","114","116","112","114","114"]},"A JVM class loader subsystem  typically includes two kinds of class loaders: a bootstrap class loader and user-defined class loaders. The bootstrap class loader is a part of the virtual machine implementation. User-defined class loaders are part of the user-program written in the Java language that runs on the JVM. Classes loaded by different class loaders are placed into separate name spaces inside the Java virtual machine. The JVM class loader subsystem  handles more than just locating and importing the binary data for classes. It also verifies the correctness of imported classes, allocates and initializes memory for class variables, and assists in the resolution of symbolic references, for example. The JVM implementation employs a bootstrap class loader, which knows how to load trusted classes, including the classes of the Java API, so called \u2018bootstrap classes\u2019. Java employs a linking model to enable a designer to develop user-defined class loaders that extend a Java application in custom ways at run-time. Through user-defined class loaders, a Java application can load and dynamically link to classes and interfaces that were unknown or did not even exist when the application was compiled.","An instrumentation routine may be used to identify, locate, and modify specific computer program components to enable monitoring, analysis or debugging, for example. Such an instrumentation process is sometimes characterized as \u201cinstrumenting the code.\u201d In a Java environment, instrumentation typically involves the addition of instrumentation code (i.e. bytecode) to program code of methods defined in classes for the purpose of gathering data to be utilized by dynamic analysis tools, used for optimizing, characterizing, benchmarking, debugging or otherwise improving the robustness of a software program as it executes, for example. The additional instrumentation code generally does not fundamentally change the state or behavior of the application modified through the addition of such instrumentation code. Examples of such analysis tools include monitoring agents, profilers, coverage analyzers, event loggers and debuggers, for example.","One approach to instrumentation in a Java environment involves use of a Java \u2018Instrumentation\u2019 class and special Java libraries called Java agents. A Java agent typically utilizes a pluggable library that runs embedded in a JVM and that intercepts the classloading process. This allows a software agent to monitor the classloading process and to instrument the bytecode of the classes to provide informational callbacks into the agent's libraries, for example. Thus, one approach to the instrumentation of an object-oriented application targeted to a VM is to modify classes through the addition of instrumentation code (e.g., bytecode) as the classes are loaded.","However, in a JVM environment, these agents typically are loaded only after the JVM has embarked upon bootstrapping of bootstrap classes. At that stage of execution, several hundred bootstrap classes already may have been loaded but not yet have been processed by any instrumentation agent. Thus, these bootstrap classes will not have been instrumented by the instrumentor. One proposed solution to the problem is to statically instrument the bootstrap classes, which involves instrumenting them ahead of time and causing the JVM to use the instrumented classes when it starts up. However, this solution can be problematic since it involves modifying where the JVM loads bootstrap classes, which can lead to ease of use issues. See, Walter Binder, Jade Hulaas and Philippe Moret, Reengineering Standard Java Runtime Systems through Dynamic Bytecode Instrumentation, Seventh IEEE Working Conference on Source Code Analysis and Manipulation, SCAM 2007, Volume, Issue, Sep. 30-Oct. 1, 2007, pages, 91-100. Moreover, classes of the computer software based instrumentation process itself, i.e. its instrumentation classes, may not be instrumented either.","Thus, there is a need for improvement of techniques to instrument of computer program applications targeted to VMs that employ bootstrap classes. The present invention meets this need.","In one aspect, a method is provided to instrument program code for execution in a virtual machine. In some embodiments, an analysis field is declared in a selected class in the course of loading the class to a virtual machine. The analysis field corresponds to a field declared in a bootstrap class that extends the selected class.","The analysis field declared in the selected class can be used to gather and store data for use in dynamic analysis. A field declared in a bootstrap class can be monitored through an analysis field declared in the selected class that extends such bootstrap class. Thus, rather than modify the bootstrap classes, other classes are instrumented that extends such bootstrap classes.","These and other features and advantages of the invention will become apparent from the following description of embodiments thereof in conjunction with the appended drawings.","The following description is presented to enable any person skilled in the art to make and use a computer implemented system and method and apparatus to instrument program code for use in a virtual machine in accordance with embodiments of the invention, and is provided in the context of particular applications and their requirements. Various modifications to the preferred embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the invention. Moreover, in the following description, numerous details are set forth for the purpose of explanation. However, one of ordinary skill in the art will realize that the invention might be practiced without the use of these specific details. In other instances, well-known structures and processes are shown in block diagram form in order not to obscure the description of the invention with unnecessary detail. Thus, the present invention is not intended to be limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.","For some kinds of analysis it may be beneficial to instrument a program by adding field definitions to classes, herein referred to as \u2018analysis fields\u2019. In some embodiment, analysis fields may be created for each of certain declared fields in the original program. Classes may inherit behavior and\/or data from other classes referred to as superclasses. A subclass may override behavior that it inherits from its superclass, but if it does not, the behavior of the subclass may default to the behavior defined by a superclass of that subclass. A given reference to a field or method of a class may thus relate to something declared within the class itself or to something declared in a superclass of that class. Depending on the type of analysis being performed, an instrumentor may determine that an analysis field should be declared in a superclass of a class to be instrumented. That superclass may or may not have been loaded prior to the instrumentation of the class by the instrumentor.","As used herein the term \u2018field\u2019 refers to a region of a class that is allocated for a particular item of information. A field typically has attributes associated with it. In a class definition, fields may represent data values that are specific to each instance of the class, or common to all instances of the class. Fields may represent numerical quantities such as counters, sizes, or distances. Fields may also string data entities such as names, addresses, and so forth. Field types may be simple data types built into the programming language, or complex data types that are defined by the user, and which often consist of combinations of simpler data types. Some fields may represent low-level resources such as files, sockets, database connections. These fields are associated with additional data that is owned by the virtual machine, operating system, or other low-level component of the system.","As used herein, the declaration of a field implies specifying its type, name, and sometimes additional attributes. In some programming languages the type may be omitted and automatically inferred by the compiler, or determined at runtime. The declaration of a field can imply the reservation of memory when an object or class is created, when the program is initialized, or no memory at all (in the case of constants in some implementations). The meaning of a field declaration varies widely between programming languages, but usually it implies the creation of a named value within a class or structure, with a type and a certain scope of visibility.","Classes may inherit behavior and\/or data from other classes. A subclass may override inherited behavior, but if it does not, then the behavior of the subclass may default to that defined by the superclass. A given reference to a field or method of a class may thus relate to something declared within the class itself or to something declared in a superclass.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3","b":["300","302","304","300","306","308","300","310","306","312","312","316","312","308","316","316","302","316","318","306","318","310","304"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4","b":["400","420","421","423"]},"Decision block  monitors the loading of classes, which can be loaded for either the user application program or the instrumentor program which run in parallel to determine whether program execution requires loading of an additional class. If decision block ) determines that no additional class is to be loaded at that moment, then decision block  determines whether execution of the application program is complete. If decision block  determines that execution of the user application program is complete, then the application and instrumentation are done as indicated by block . On the other hand, if decision block  determines that execution of the user application program is not complete, then the process returns to application execution block , and the user application and the instrumentor continue to run in parallel. If on the other hand, decision block  determines that an additional class is to load, then Class loader block  loads the additional class for execution. This class may have been loaded due to a requirement of either the instrumentor or the user application. It will be understood that since the instrumentor is the intercepting program, its own classes are not to be intercepted. Decision block  determines whether the additional class is required for the instrumentor or for the user application. If decision block  determines that the additional class is loaded for the user application, then instrumentor block  instruments the additional class as it loads. If decision block  determines that the additional class is loaded for the instrumentor, then the process returns to application execution block , and the user application and the instrumentor continue to execute in parallel. If on the other hand, decision block determines that the additional class is loaded for the user application, then instrumentation block  instruments the class. Once the class has been loaded and instrumented, the process returns to the application execution block .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIGS. 5A-5B","FIG. 5A","FIG. 5B"]},"For the purposes of this description, a shadow field associated with a field named \u2018x\u2019 will be named \u2018shadow$x\u2019.  shows an illustrative class  that declares \u2018types\u2019 for two fields a and b. In some embodiments, a \u2018type\u2019 is declared for each field. Fields a and b may have the same or different types. In the course of an instrumentation process such as that of , the class of  is modified through the addition of declarations of shadow fields, shadow$a and shadow$b, that correspond to fields a and b, respectively. In some embodiments, these shadow fields may have a specific type defined by the instrumentation methodology, referred to as \u2018inst_type\u2019 in the drawing of . The inst_type can be any type that is useful for the specific analysis to be being performed through the instrumentation of the class. If the analysis requires that the shadow field type vary based on some aspect of the field itself, then shadow$a and shadow$b could have different types. More than one shadow field may be declared for each original field.","As explained above, the class represented by  also may be modified through the instrumentation process, which may provide instructions used to effect an analysis process. For example, an instrumentation process may provide instrumentation instructions (not shown) within methods of the same class \u2032 as modified in . Shadow fields may be used by such instrumentation instructions to track the states of fields referenced in such instrumentation instructions.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 6"},"Referring to , Interface A  declares two fields, a and b. Class B  implements Interface A, and therefore, inherits fields a and b. Class B also declares two new fields, c and d. Class C  extends Class B, and therefore, inherits from Class B and Interface A. However, Class C declares two fields c and e. Even though Class B also declares a field c that Class C could inherit, the definition within Class C takes priority and overrides the inherited definition of field c. Therefore Class C only inherits fields a, b, and d from Class B (a and b coming from Interface A originally).",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIGS. 7A-7D","FIG. 6","FIG. 6"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 7A","b":["750","751","752"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 7B","b":["753","754","755","756","757"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 7C","b":["758","759","7510","7511","7512","7513","7514"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 7D","b":["7515","7516","7517"]},"Unfortunately, a problem may arise due to load-time instrumentation that involves a class that inherits a field from a bootstrap class. For example, assume that a given class inherits a definition of a field x from a bootstrap class. Since the bootstrap class itself is not instrumented, no analysis field corresponding to field x is declared in the bootstrap class. Thus, the given class may inherit a field x for which an analysis field has not been defined. The absence of such analysis field may result in erroneous instrumentation or analysis.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 8","b":["800","802","804","804","806"]},"If on the other hand, decision block  determines that the selected class does extend a super class, then block  obtains information concerning the superclasses that the selected class extends. Decision block  determines whether the superclass extended by the selected class is a bootstrap class. If decision block  determines that the extended superclass is not a bootstrap class, then the process  proceeds to block , which declares respective analysis fields (e.g., \u2018shadow fields\u2019) that correspond to respective fields within the selected class.","If on the other hand, decision block  determines that the superclass that extends the selected class is a bootstrap class, then block  declares within the selected class, respective analysis fields (e.g., \u2018shadow fields\u2019) (if any) that correspond to respective fields declared within the bootstrap class.","It will be noted that decision block  determines whether a class is a bootstrap class. In some embodiments, in order to make this determination, bootstrap class names are added to a bootstrap class list that is created in computer readable storage media in the course of the loading of bootstrap classes by the VM. Block  refers to this list to determine whether or not class a superclass that extends a class that is being loaded and instrumented is a bootstrap class.","It will also be noted that decision block  causes the process  to proceed to block  only if the selected class is a direct descendant of the bootstrap class. That is, if the selected class extends a class that is not a bootstrap class, then the process  proceeds to block  instead.","Decision block  determines whether the bootstrap class extends a superclass. Note that a superclass that extends a bootstrap class is itself a bootstrap class. If decision block  determines that the bootstrap class does not extend a superclass, then the process  proceeds to block , which declares within the selected class, respective analysis fields (e.g., \u2018shadow fields\u2019) that correspond to respective fields declared within that selected class.","If on the other hand, the decision block  determines that the bootstrap class does extend a superclass, then block  obtains information concerning the superclass. Next, block  declares within the selected class, respective analysis fields (e.g., \u2018shadow fields\u2019) (if any) that correspond to respective fields declared within the bootstrap superclass. The loop that includes blocks - continues until the last extended superclasses is identified.","Depending upon the computer programming language, the superclass check of decision block  may not terminate at the point at which no more superclasses are identified, but alternatively, may end when the identified superclass is some language-defined class from which all classes are derived. The \u2018Object\u2019 class is an example of such a class in the Java language.","Thus, analysis field are declared within a selected class for fields declared within that class and also for fields declared in bootstrap classes extended by the selected class. Even though a bootstrap class itself is not modified through addition of an analysis field, a class that inherits a field from such bootstrap class can be modified through addition of an analysis field corresponding to such bootstrap class field. Thus, fields declared in a bootstrap class can be monitored through addition of analysis fields added to a class that extend such bootstrap classes. In particular, for example, instrumentation code (not shown) added to a class can refer to analysis fields to obtain dynamic (i.e., run-time) information concerning fields of the class.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIGS. 9A-9B","FIG. 9A","FIG. 9B","FIG. 8","FIG. 8","FIG. 9A"],"b":["902","902","904","904","906","906","908","908"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 9B","FIG. 8","FIG. 9A","FIGS. 8 and 9A"],"b":["902","804","902","808","902","904","904","810","904","904","800","806"]},"Now, assume that the second class  is in the process of being loaded. Referring to , block  determines that the second class  extends a superclass. Block  obtains information concerning the superclass extended by the second class , i.e., the third class . Decision block  determines that the extended superclass  is a bootstrap class. Block  creates an analysis field shadow$b within the modified second non-bootstrap class \u2032 that corresponds to the field b declared in the third (bootstrap) class that is extended by the second class \/\u2032. Decision block  determines that the third (bootstrap) class  extends another class, i.e. fourth class . Block  obtains information concerning the fourth (bootstrap) class  that is extended by the third class . Block  creates an analysis field shadow$a within the modified second class \u2032 that corresponds to the field a declared in the fourth bootstrap class  that is extended by the third bootstrap class . Decision block  determines that the fourth class  does not extend another class. Accordingly, process  proceeds to block , which declares analysis fields shadow$c and shadow$d within the modified second non-bootstrap class \u2032 that correspond to fields c and d that are declared within the second class .","The modified first and second classes \u2032 and \u2032 each includes a declaration of an analysis class for field d (i.e., shadow$d). As explained with reference to , a local definition of a field within a class supersedes a definition of the same field in a superclass extended by that class. Both the first non-bootstrap class \/\u2032 and the second non-bootstrap class \/\u2032, which is a superclass of the modified first class \u2032, define field d. Accordingly, although the declaration of field d in the first class \/\u2032 supersedes the declaration of field d in the second class \/\u2032, analysis fields are declared that correspond to each declaration of field in each such class.","The second non-bootstrap class \/\u2032 is a direct descendent of the third and fourth bootstrap classes  and . Whereas, the first non-bootstrap class \/\u2032 is not a direct descendant of the third and fourth bootstrap classes  and  since the second non-bootstrap class \/\u2032 is disposed in the inheritance hierarchy between the first non-bootstrap class \/\u2032 on the one hand and the third and fourth bootstrap classes  and  on the other hand.","Moreover, analysis fields for fields declared in bootstrap classes  and  are declared in the second non-bootstrap class. In this example, the first and second classes  and  may be user application classes, for example. The process  is operative to define analysis classes within user application program classes that correspond to fields declared in bootstrap classes, regardless of the order in which such user application classes are loaded. That is, for example, the process  is operative whether the first class is loaded before or after the second class is loaded. Thus, even though the bootstrap classes typically loaded before the loading of the user program classes, fields in such bootstrap classes that are inherited by such application classes can be monitored for analysis through addition of analysis fields, for example.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIGS. 10A-10B","FIG. 10A","FIG. 10B","FIG. 8","FIG. 10A"],"b":["1002","1004","1004","1006","1006","1008","1008"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 10B","FIG. 8","FIG. 10B"],"b":["1004","1006","1008","1002","1004"]},"In some embodiments, reflection techniques are employed by blocks  and  to obtain information about extended classes and by block  to use information obtained about an extended bootstrap class to modify a (non-bootstrap) class through the addition of an analysis field corresponding to a field of the bootstrap class. In the above-described example in , the second class \/\u2032 is modified through the addition of analysis fields shadow$a and shadow$b that correspond to fields a and b that are declared in extended (bootstrap) classes  and , respectively.","In a computer programming context, refection refers to the ability of a program to examine and control its own implementation. Introspective reflection includes the ability to inspect data structures, for example, inspecting a class definition. Structural reflection allows a program to change the definition of class at load time, for example. See, for example, Core Java 2, volume 1, chapter 5 starting at page 228, for a discussion of reflection in an object oriented programming environment.","The foregoing description and drawings of preferred embodiments in accordance with the present invention are merely illustrative of the principles of the invention. Therefore, it will be understood that various modifications can be made to the embodiments by those skilled in the art without departing from the spirit and scope of the invention, which is defined in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The aforementioned features and advantages of the invention, as well as additional features and advantages thereof, will be more clearly understandable after reading the detailed description of embodiments of the invention in conjunction with the following drawings.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIGS. 1A-1B","FIG. 1A","FIG. 1B"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIGS. 5A-5B","FIG. 5A","FIG. 5B"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIGS. 7A-7D","FIG. 6"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIGS. 9A-9B","FIG. 9A","FIG. 9B","FIG. 8"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIGS. 10A-10B","FIG. 10A","FIG. 10B","FIG. 8"]}]},"DETDESC":[{},{}]}
