---
title: Method and apparatus for rendering a computer-generated image
abstract: A method and apparatus for rendering a computer generated image using a stencil buffer is described. The method divides an arbitrary closed polygonal contour into first and higher level primitives, where first level primitives correspond to contiguous vertices in the arbitrary closed polygonal contour and higher level primitives correspond to the end vertices of consecutive primitives of the immediately preceding primitive level. The method reduces the level of overdraw when rendering the arbitrary polygonal contour using a stencil buffer compared to other image space methods. A method of producing the primitives in an interleaved order, with second and higher level primitives being produced before the final first level primitives of the contour, is described which improves cache hit rate by reusing more vertices between primitives as they are produced.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08654146&OS=08654146&RS=08654146
owner: Imagination Technologies, Ltd.
number: 08654146
owner_city: Kings Langley, Hertfordshire
owner_country: GB
publication_date: 20100517
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT"],"p":["The invention relates to a method and apparatus for rendering computer generated images, in which the images include at least one closed polygonal contour. Particularly, the invention relates to rendering of images using image space calculations and standard graphics hardware and in which the polygons in the images include \u2018arbitrary\u2019 shaped polygons, where \u2018arbitrary\u2019 permits the existence concavities, self-intersections, and even multiple \u2018contours\u2019.","In a computer-generated image, there are typically a large number of individual polygons. Graphics rendering hardware, in particular 3D graphics hardware, often only has capability for the rendering of triangle primitives or, occasionally, other convex polygons, that is to say, polygons in which all the internal angles of the polygon are less than 180\u00b0. Such polygons are relatively straightforward to render. Such specifications include \u2018fill rules\u2019 which determine which parts of an arbitrary polygon are to be deemed interior and which are exterior. SVG defines two such rules\u2014\u2018even-odd\u2019 and \u201cnon-zero\u201d. For brevity in this document, we will usually assume use of the \u2018even-odd\u2019 rule but it will be clear to one skilled in the art that the techniques presented apply to other well-defined fill rules.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":["FIGS. 1","FIGS. 1","FIG. 1","FIG. 1","FIG. 1"],"i":["a ","e ","a ","e ","b ","c ","d "],"b":["1","1"]},"The ability to render such arbitrary polygons, whilst also supporting convex polygons, is useful for a number of reasons, for example, to support vector graphics standards such as SVG (Scalable Vector Graphics) and OpenVG (Open Vector Graphics). SVG is a language for describing two-dimensional graphics and graphical applications in XML (Extensible Markup Language). OpenVG is a royalty-free, application programming interface (API) designed for hardware-accelerated 2-dimensional vector graphics. Naturally, any method able to render the arbitrary polygons, must also be able to handle convex polygons.","There are two families of methods with the capability of rendering arbitrary polygons on such hardware. The first family performs calculations in model space and are generally referred to as triangulation algorithms. These take a polygon outline and produce a set of non-overlapping triangles that exactly cover the filled area of the original polygon. To avoid confusion with other uses of \u201ctriangulation\u201d in this document, we will refer to such algorithms as \u201ctrue triangulation\u201d. An example of the possible results of such a process, as applied to the polygon of is shown in . The original shape can thus be constructed from the triangles: {[v,v,v], [v,v,v], [v,v,v], [v,v,v], [v,v,v]}. Assuming a simple polygon with N-sides and that no extra vertices are added (note some algorithms do introduce additional vertices), we will obtain N\u22122 triangles. Once these triangles are generated, they can easily be rendered on any commodity graphics hardware.","Numerous algorithms for the \u201ctrue triangulation\u201d process have been published. Lamot and Zalik provide a survey of methods in \u201c\u201d (Information Visualization, 1999, pp 153-158). These documented methods are nearly always restricted to simple polygons such as ) and (), i.e., they may contain neither self-intersections (including repeated vertices) nor multiple contours. Nevertheless, Meister's \u201cear cutting\u201d (or ear clipping) algorithm and Seidel's method are of interest to this discussion.","Meister's method removes one vertex at a time from a (simple) polygon in such a way that the reduced polygon remains simple. It repeatedly \u2018clips an ear\u2019, formed by a triple of consecutive vertices, from the polygon. This algorithm runs in O(n) time and, although it has been subsequently improved to be O(n), it is not particularly attractive except for polygons with relatively few vertices.","Seidel's method, on the other hand, runs in O(n log*n) time for simple polygons where log*(n) is defined as . . .",{"@attributes":{"id":"p-0010","num":"0009"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msup":{"mi":"log","mo":"*"},"mo":"\u2062","mi":"n"},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mrow":{"mi":["if","n"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"\u2264","mn":"1"}}]},{"mtd":[{"mrow":{"mn":"1","mo":"+","mrow":{"msup":{"mi":"log","mo":"*"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["log","n"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}}},{"mrow":{"mrow":{"mi":["if","n"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":">","mn":"1"}}]}]}}],"mo":"="}}}},"We can thus consider O(n log*n) to be practically O(n) for any reasonable values of n. As stated above, very few \u2018true triangulation\u2019 algorithms have been published that handle arbitrary polygons. Held's method (\u201cFIST: Fast Industrial-Strength Triangulation of Polygons\u201d Algorithmica 30, 4, 563-596) is one of the few exceptions. Although based on ear clipping, additional structures are used to achieve a much better time complexity for simple polygons, but it is not clear to the inventor how it behaves in the presence of self-intersections etc.","The application's inventor has implemented a version of Seidel's algorithm that has been enhanced to support completely arbitrary polygons. This still achieves virtually linear performance (assuming the implicit vertices created by self-intersections are included in \u2018n\u2019). However, on a \u02dc2 GHz CPU, the process still takes an average of 1\u02dc2 \u03bcs per polygon vertex. For polygons that will be drawn multiple times over numerous frames, the triangulation results can be cached, and so the pre-processing cost is amortised by the rendering process. For situations, however, where a polygon is only drawn a few times or is being dynamically altered on a frame-by-frame basis\u2014which forces re-triangulation\u2014the true triangulation process can be a very significant penalty. (Note that applying linear transformations to the model does not require re-triangulation.)","The second family of methods with the capability of rendering arbitrary polygons uses image space calculations. Here the rendering\/sampling process itself is adapted to determine which pixels fall inside the arbitrary polygon and which are outside. Although this can be done with scan line rendering algorithms, we are primarily interested in those that break the arbitrary polygon into smaller polygons (usually triangles) for which the hardware has direct rendering support, render those smaller polygons and make use of the hardware stencil buffer to determine which of the rendered pixels are inside the original arbitrary polygon. It is well known in the art (\u201c1.4\u201d, Shreiner et al, ISBN 0321173481) that arbitrary polygons can drawn by using the stencil buffer. For example, one may implement the odd-even rule by applying XOR operations to the stencil. Similarly, provided triangle winding orders are taken into account, increments and decrements of the stencil can be used to implement the non-zero rule.","With either fill rule, one must first produce a set of triangles from the source polygon. The obvious approach is described in the \u201c\u201d section of chapter 13 of Shreiner et al (available at either http:\/\/fly.cc.fer.hr\/\u02dcunreal\/theredbook\/chapter13.html or http:\/\/www.scribd.com\/doc\/7605395\/Redbook). Here a triangle fan (refer Chapter 2 of Shreiner et al or http:\/\/en.wikipedia.org\/wiki\/Triangle_fan) is created by simply submitting the vertices in order, i.e. [v, v, v, . . . v] which implicitly creates the set of N\u22122 triangles with vertices {[v,v,v], [v,v,v], [v,v,v] . . . [v,v,v]}.","Borrowing the example ( ()) from Shreiner et al, part of this process is shown in . The seven sided figure is rendered as a fan of five triangles. Assuming the odd-even fill rule, the pixels of the screen which are covered by an odd number of triangles will be deemed interior while those covered by an even number will be exterior. For example, the area bounded by v, v, and location , is covered by triangles [v,v,v] and [v,v,v]. Assuming that the stencil buffer is initialised to zero and an XOR operation employed, drawing triangle [v,v,v] will first set all the pixels' stencil values for region [v,v,\u201c\u201d] but these will subsequently be cleared again by triangle [v,v,v]. The region will thus be correctly deemed exterior to the polygon. The simplicity of this process is extremely appealing and, since it uses a triangle fan, it only requires the transmission of N vertices to the graphics hardware.","Once the stencil has been set to indicate which pixels are inside the polygon, it must be filled with the appropriate colours or textures. Methods to do this include computing the 2D bounding rectangle of all the vertices of the polygon and then drawing just a single rectangle (with stencil test), or to simply resend the generated triangles. The former, as applied to ) and illustrated in ), has the advantage of sending a near minimal amount of geometric data to the hardware but requires pre-computation of min and max bounds. It also can be expensive, in terms of wasted pixel processing, if the rectangle does not tightly bound the polygon to be filled, as shown by the region .","Another method, as shown in ),\u2014in this example using a set of triangles generated using the invention's method (refer FIG. )\u2014sends more geometry than the bounding box method but generally results in less redundant pixel filling. In this example, much of the shape is filled with a single \u2018layer\/pass\u2019 of pixels, , but there are regions where pixels are filled multiple times, . This typically becomes worse with polygons with greater numbers of regions of, or total area of, concavity.","The method also works unaltered for self-intersecting and multiple contour polygons\u2014Shreiner et al also provide an example of the latter. In effect they just concatenate all the vertices of all the contours and treat the result as larger triangle fan.","Despite the pleasing simplicity of this fan method, as described in the art, the inventor has appreciated that it has two fundamental problems. The first is related to the shape of the generated triangles. Producing a fan of triangles from the original polygon tends to lead to the production of long, thin triangles. Such a triangle is generally slower to render with graphics hardware than another that has an equal screen area but is \u2018more equilateral\u2019 in shape. One publication, \u201cSilhouette clipping\u201d, (Sander et al, SIGGRAPH 2000, pages 327-334) discusses this problem and gives a partial solution. Sander et al also need to fill sets of contour edges. These are, in effect, polygons and are likely to have concavities. They state:\n\n","This typically does improve the shape of the triangles but unfortunately introduces an extra point, which thus requires the data to be read twice. It also creates an additional triangle in the fan. An example of the results of their process, as applied to  (), is shown in . (Please note that the \u2018centroid\u2019 location, Vcentroid, is only an approximation in this illustration).","Sander et al suggest a further improvement:\n\n","This is, unfortunately, quite vague. Firstly, they don't say how \u201cwe pick two vertices\u201d. Secondly, in the context of the paper, \u201cproceed as before on the smaller loops\u201d would appear to imply the process of computing the \u2018centroid\u2019 of each loop and turning each into a fan. That does not seem correct as it would only produce two child loops.","A more likely interpretation is that they have a target, M, for the number of vertices per child \u2018loop\u2019 and divide the source polygon into sufficient equal pieces to meet that target number. An N-vertex source polygon would thus require P child polygons where P=\u2514N\/(M\u22121)\u2518. With their scheme, if the source polygon is thus divided into P sections, then P additional vertices (each located at the centroid of its respective \u2018loop\u2019) are introduced. It should be noted that, since each child loop is drawn with a fan, there are practical reasons\u2014described in the following paragraph\u2014for not choosing too small a value for M.","Also of relevance to the invention are the methods by which contemporary rendering hardware reduces the triangle data and bus bandwidth when models are supplied to the rendering hardware. The simplest method is to supply each triangle as three, V-byte vertices so that, for a model with T triangles, 3*T*V bytes of data would be transmitted to the hardware, but more efficient options exist. We have already seen that 3D hardware typically supports the concept of triangle fans, whereby a T triangle fan only needs to supply (T+2)*V bytes of data. For 3D models, a related concept called triangle strips (again see Shreiner or http:\/\/en.wikipedia.org\/wiki\/Triangle_strip), is typically more useful. Like triangle fans, these also require only (T+2)*V bytes of data for a strip of T triangles. In both cases, the ratio of triangles to vertices climbs asymptotically towards 1:1 as the length of the strip or fan increases. Longer strips and fans are thus more efficient.","Over the past decade, an indexed triangle format has been seeing increased popularity as a means of further decreasing the bandwidth and storage costs. Here each triangle is defined as three integer indices, each say of 16 or 32 bits, which select vertices from a vertex array. With 3D models, this format offers the opportunity to exceed the 1:1 barrier of strips and fans, though this is unlikely for 2D shapes. To efficiently support such a format, graphics hardware now frequently employs a vertex caching technique such as that described by Hoppe (\u201c(SIGGRAPH '99 Proceedings) pp 269-276). In brief, the hardware maintains a cache of the last K vertices used in past triangles. A FIFO replacement policy is generally employed rather than, say, a Least Recently Used (LRU) scheme as the former is not only simpler but, more importantly, generally results in a higher cache hit rate for 3D models.","We now return to the second, and probably far more significant problem with the prior art fan algorithm, which is that it can require a disproportionate amount of \u201cpixel filling\u201d. For example, one can see from  that there is a relatively large area which is covered by multiple triangles compared to the ideal situation of  as generated by a \u2018real triangulation\u2019 method. We will refer to the areas covered by multiple triangles as \u2018overdraw\u2019. This overdraw is an undesirable burden in the rendering phase and it is advantageous to reduce it if possible.","On average, simply using the less-obvious triangle strip order i.e. outputting the vertices in the order v, v, v, v, v, v. . . and thus producing the triangles {[v,v,v], [v,v,v], [v,v,v] . . . } often results in both better shaped triangles and lower overdraw compared to fan order (although, ironically, not in the particular case  ()), but the improvement is unfortunately not that great. From , Sander et al's method would also appear to reduce overdraw at the expense of introducing an additional vertex and triangle, but it certainly does not work in all cases. Applying their method to  (), where the centroid would be located in the centre of the \u201cU\u201d, would result in significant regions of overdraw, as shown in .","The inventor has appreciated that there is a need for a method of producing a set of simpler polygons (usually, but not always, triangles) from an arbitrary polygon for rendering with a stencil buffer method which:\n\n","It is an object of the present invention to provide a method and system that goes some way towards achieving the above goals.","In addition, for any method and system, the following features, though not necessarily essential, are desired:\n\n","The invention is defined in the appended claims to which reference should now be made. Advantageous features are defined in the dependent claims.","In order to address the issues identified with known methods, the inventor has appreciated the following:\n\n","In the \u201cear clipping algorithms\u201d (e.g. Meister or Held) for true triangulation, a \u2018safe\u2019 vertex is identified and then removed to reduce an N sided shape to an N\u22121 shape. The clipped vertex then forms a triangle with its two original neighbours. Unfortunately, the identification of a \u2018safe\u2019 vertex, i.e. where the produced triangle is entirely inside the original polygon is expensive.","We have appreciated that if one is using an image space method and rendering using a stencil buffer, then it not absolutely critical if the vertex selected is \u2018safe\u2019. Taking the example from , one can consider that the fan method, in effect, progressively clips the ears formed by vertices V, V, . . . Vuntil the polygon is reduced to the triangle {V,V,V}.","For triangle primitives, the inventor has appreciated that if a simple ear clipping algorithm is applied to every second vertex of an original (single) contour of an N-sided polygon, the \u2514N\/2\u2518 triangles thus formed will typically be more equilateral in shape than those produced by the fan or strip method. Furthermore, these triangles are less likely to have large regions that either lie outside of the final filled shape or overlap other triangles, than those typically generated by the fan or strip methods. After this process, one will be left with a \u2018residual\u2019 polygon with \u250cN\/2\u2510 (i.e. ceiling(N\/2)) vertices. The same process may then be reapplied to produce another set of triangles and another residual polygon with even fewer vertices. This process is thus repeated until the residual polygon is \u2018empty\u2019 i.e. when the residual polygon is a primitive of the size desired for output or the residual polygon has trivially zero area. The results of such a process as applied to  () are shown in . In this example, the desired result of lower overdraw has been achieved.","The preceding paragraph assumes that the rendering system supports triangle primitives. Some rendering systems also support the rendering of quads (either convex or arbitrary) or even M-sided \u2018arbitrary\u2019 polygons with say, M\u226616. Although the preferred embodiments detailed below demonstrate the invention for triangle primitives, the invention is not restricted to the output of triangle primitives and may output M-sided primitive units, or output primitive units of more than one type, eg triangles and quads, if used with more flexible rendering systems. In the presently preferred embodiments, one type of primitive, e.g. triangles, will be outputted to cover the majority of the contour.","It is also highly desirable to make the colour or texture filling process that occurs once the stencil has been set up, be as efficient as reasonably possible. To this end, the inventor has also appreciated that a single contour arbitrary polygon, without self-intersections, will have an overall winding order and, furthermore, it is usually advantageous for this winding order to be consistent for all objects drawn by an application. (This is due to the \u2018triangle fill\u2019 or \u2018tie-breaking rules\u2019 of graphics hardware as, say, summarised by the OpenGL, DirectX, or OpenVG standards, to avoid artefacts such as \u2018gaps\u2019 appearing between abutting objects). For practical systems, a multiple contour arbitrary polygon will thus also use a consistent overall winding order for the other pieces. (By consistent, it should be noted that contours representing \u2018holes\u2019 will have the opposite winding order and that each contour will not, in itself, be self-intersecting.)","The inventor has noted that, once the stencil buffer has been set up, for such an arbitrary polygon that has an overall winding order, W, only those triangles that were used to create the stencil that also have winding order W will be needed when filling the object. This can be demonstrated by considering the behaviour of the non-zero fill rule as the pixels drawn are a superset of those produced by the odd-even rule.","Assuming the overall winding order W corresponds to an increment of a pixel's stencil value, we thus will only need to fill those pixels whose stencil has a positive value. Triangles with the opposite winding order only subtract from the stencil's value and, since we are assuming a consistent winding order, can be eliminated. Since rendering pipelines typically provide free support for eliminating polygons with a user selectable winding order, the original triangulation can be re-used. (Note that polygons such as a self-intersecting \u2018bow-tie\u2019. i.e. \u201c[0,0], [1,0], [0,1], [1,1]\u201d do not have an overall winding order and so cannot use this additional optimisation).","This process, as applied to the triangulation of  () as illustrated in , is shown in , and can be compared with the results shown in ). One can see that the triangle, , can be eliminated from the fill process, leaving, in this case, just regions with a single layer of fill, . There is still some redundant filling, but this is greatly reduced compared to .","A first preferred embodiment is essentially that described earlier which is represented by the steps:\n\n","The conversion of a contour, C=(v,v,v, . . . v), where N\u22673, to a set of primitives, consists of dividing the closed polygonal contour into smaller polygonal units of maximum size P, P\u22673, vertices by repeatedly removing (up to) a first set of P\u22122 vertices from the contour, to produce a polygon with P vertices, (v,v,v), and a reduced source contour with N\u2212(P\u22122) vertices, removing (if possible) a second set of (up to) P\u22122 vertices starting with the last vertex of previous set and continuing thus until the end of the source contour. More precisely, this produces an initial set of smaller polygons,\n\n",{"@attributes":{"id":"p-0060","num":"0080"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":"C","mn":"1"},"mo":"=","mrow":{"mrow":[{"mrow":{"mo":["(",")"],"mrow":{"msubsup":[{"mi":"v","mn":["0","1"]},{"mi":"v","mn":["1","1"]}],"mo":[",",","],"mrow":{"mi":"\u2026","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msubsup":{"mi":"v","mrow":{"msup":{"mi":"N","mn":"1"},"mo":"-","mn":"1"},"mn":"1"}}}},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"where","msup":{"mi":"N","mrow":{"mi":"i","mo":"+","mn":"1"}}},{"mo":["\u230a","\u230b"],"mfrac":{"msup":{"mi":["N","i"]},"mi":"P"}}],"mo":"="}}}}},"This process is repeated with each subsequently reduced contour, C, until it has either P or fewer vertices, or been reduced to a line segment (and thus trivially zero area). The generated primitives are then rendered using a stencil buffer to produce a computer-generated image.","For example, the process of step 2 applied to a single contour, to generate triangles (i.e. for P=3), in accordance with a first embodiment of the invention will now be described. It is assumed that the contour has N-sides with vertices numbered from Base to Base+N\u22121:",{"@attributes":{"id":"p-0063","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"StepSize := 1;"]},{"entry":[{},"WHILE( StepSize < N )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ generate all the triangles with this step size"]},{"entry":[{},"J := 0;"]},{"entry":[{},"WHILE (J < (N \u2212 StepSize))"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Get the other two points that will make"]},{"entry":[{},"\/\/ up this triangle"]},{"entry":[{},"PtB := MIN(J+ StepSize, N\u22121);"]},{"entry":[{},"PtC := MIN(J + 2*StepSize, N\u22121);"]},{"entry":[{},"\/\/if this is a non degenerate triangle..."]},{"entry":[{},"IF(PtB != PtC)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/output triangle {J, PtB, PtC} relative"]},{"entry":[{},"\/\/to \u201cbase\u201d"]},{"entry":[{},"OutputTriangle(J + Base,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PtB + Base,"]},{"entry":[{},"PtC + Base);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Move to the next triangle in this set"]},{"entry":[{},"J := J + 2*StepSize;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Double the step size"]},{"entry":[{},"StepSize := StepSize * 2;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"It should be appreciated that this simple algorithm can be realised in hardware by one skilled in the art using a language such as VHDL or Verilog and would require only a small number of components including adders, registers, and comparators.",{"@attributes":{"id":"p-0065","num":"0085"},"figref":["FIG. 6","FIG. 6","FIG. 6","FIG. 6","FIG. 6","FIG. 6","FIG. 9","FIG. 6","FIG. 10","FIG. 9","FIG. 10"],"i":["a ","b ","c ","d","e","a"],"sup":"th "},"Of more importance is the amount of overdraw produced by the invention.  (A) shows the pixels that are covered by more than one triangle. For simplicity, this figure does not distinguish between areas covered by two triangles and those covered by three or more triangles even though the latter clearly is increasingly costly. Nevertheless, if we just count the number of pixels touched by the overdraw region relative to the pixels of the final intended result, we find that overdraw has an area that is approximately 15% of the area of the intended final result.","By contrast,  (B) shows the overdraw area using the modified fan algorithm. In this situation, the overdrawn pixels represent a region that, surprisingly, has an area that is approximately 39% of the final result. Note that the unmodified Shreiner fan algorithm would be significantly worse.","This first embodiment of the invention described above does, on average, address the two most important issues, i.e. that of improved triangle shape and reduced overdraw. Though of less importance, the first embodiment does not achieve the triangle data efficiency of fans and strips, whereby an N-sided contour, requiring N\u22122 triangles, can be transmitted with just N vertices. Another potential drawback of the method of the first embodiment is that, with the possible exception of the final larger values of StepSize, generated triangles that are \u2018chronologically\u2019 local, are often only spatially local in the vicinity of a single shared vertex.","If one examines the order of vertices created by the previously described embodiment, (and assuming the vertices start from \u201c1\u201d) one can see that the triangles are created in the order {[v,v,v], [v,v,v], [v,v,v] . . . [v,v,v], [v,v,v] . . . }. If we assume this data is provided in an indexed format to hardware with a K-vertex cache (where K is typically much smaller than N), it will only achieve a cache hit rate of around 33% since only one vertex is usually reused between adjacent triangles. A fan or strip, on the other hand, achieves nearly 66% as two vertices are shared.","A second preferred embodiment will now be presented that addresses these additional issues. This second embodiment incorporates the additional feature of a very small stack. Assuming the maximum number of vertices in a contour that will ever be encountered is N, then this stack needs at most \u250clog(N)\u2510+1 (ie ceiling(log(N))+1) entries. For example, if in a given system a contour could have at most 2vertices, then the stack would have no more than 17 entries.","This embodiment provides interleaving of primitive levels to maximise vertex temporal locality and produces at least one second level primitive before all the first level primitives are produced. Primitive polygon level is reflected in the separation of the vertices of the primitive polygon relative to the vertices of the original arbitrary closed polygonal contour. A first level primitive has vertices which are contiguous vertices in the original closed polygonal contour. Higher level primitives have vertices which are offset from each other in the original closed polygonal contour. The amount of offset is related to the primitive level and the number of vertices in the primitive. An (i+1)level (i\u22671) primitive is formed of end points of consecutive ilevel primitives. Considering the set of ilevel primitives, and associated vertices, each vertex will belong to exactly one member of the set except for the special case of end points, an end point being shared with at most one other ilevel primitive.","When a contour is divided into a single size of primitive over all primitive levels, for primitive level i and polygon primitive size Q, the vertices in the ilevel primitive correspond to vertices offset from each other by (Q\u22121)^(i\u22121) in the original arbitrary closed polygonal contour. For example, when dividing a contour using only triangle primitives, assuming first level primitives have vertices [v, v, v], [v, v, v] . . . , the second level primitives will have vertices [v, v, v], [v,v,v] . . . with an offset of (3\u22121)^(2\u22121)=2 relative to the vertices of the original closed polygonal contour, and the third level primitives will have vertices [v,v,v], [v,v,v] . . . with an offset of 4 relative to the vertices of the original closed polygonal contour etc.","The second embodiment uses the same steps 1 and 3 as the first variant, but replaces step 2, i.e. the triangulation of a single contour, with the following method, as expressed in pseudo code. We will assume, as before, that the contour starts at vertex number \u2018base\u2019 and has N vertices.",{"@attributes":{"id":"p-0074","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int Vstack[MAX_VERTEX_STACK_SIZE]; \/\/vertex stack"]},{"entry":[{},"int StackDepth;"]},{"entry":[{},"int CurrentVertexID;"]},{"entry":[{},"\/\/ put the first vertex, 0, on the stack."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"StackDepth",":= 1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Vstack[0] := 0;"]},{"entry":[{},"CurrentVertexID := 1; \/\/next vertex to process*\/"]},{"entry":[{},"\/\/ while we have at least 2 more vertices"]},{"entry":[{},"WHILE(CurrentVertexID <= N\u22122)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ put the next two vertices on the stack"]},{"entry":[{},"Vstack[StackDepth] := CurrentVertexID;"]},{"entry":[{},"Vstack[StackDepth+1] := CurrentVertexID+1;"]},{"entry":[{},"CurrentVertexID+=2;"]},{"entry":[{},"StackDepth +=2;"]},{"entry":[{},"\/\/ form a triangle from the top 3 vertices"]},{"entry":[{},"OutputTriangle(Vstack[StackDepth\u22123] + Base,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Vstack[StackDepth\u22122] + Base,"]},{"entry":[{},"Vstack[StackDepth\u22121] + Base);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ remove the \u2018second from top\u2019 stack element"]},{"entry":[{},"Vstack[StackDepth\u22122] := Vstack[StackDepth\u22121];"]},{"entry":[{},"StackDepth--;"]},{"entry":[{},"\/\/ do all the higher triangle levels we can.."]},{"entry":[{},"WHILE((StackDepth >= 3) &&"]},{"entry":[{},"\u2002((Vstack[StackDepth\u22121] \u2212 Vstack[StackDepth\u22122]) =="]},{"entry":[{},"\u2003(Vstack[StackDepth\u22122] \u2212 Vstack[StackDepth\u22123])) )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ form a triangle from the top 3 vertices"]},{"entry":[{},"OutputTriangle(Vstack[StackDepth\u22123] + Base,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Vstack[StackDepth\u22122] + Base,"]},{"entry":[{},"Vstack[StackDepth\u22121] + Base);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ remove the second from top stack element"]},{"entry":[{},"Vstack[StackDepth\u22122] := Vstack[StackDepth\u22121];"]},{"entry":[{},"StackDepth--;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}\/\/end while doing upper levels"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}\/\/end while at least 2 vertices left"]},{"entry":[{},"\/\/ process remaining whole triangles on the stack"]},{"entry":[{},"WHILE(StackDepth >= 3)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ form a triangle from the top 3 vertices"]},{"entry":[{},"OutputTriangle(Vstack[StackDepth\u22123] + Base,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Vstack[StackDepth\u22122] + Base,"]},{"entry":[{},"Vstack[StackDepth\u22121] + Base);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ remove the second from top stack element"]},{"entry":[{},"Vstack[StackDepth\u22122] := Vstack[StackDepth\u22121];"]},{"entry":[{},"StackDepth--;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}\/\/end while"]},{"entry":[{},"\/\/ if there is just one vertex left to do,"]},{"entry":[{},"\/\/ add it to the stack and form the final triangle"]},{"entry":[{},"IF(CurrentVertexID <= N\u22121)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Vstack[StackDepth] := CurrentVertexID;"]},{"entry":[{},"StackDepth++;"]},{"entry":[{},"\/\/ form a triangle from the top 3 vertices"]},{"entry":[{},"OutputTriangle(Vstack[StackDepth\u22123] + Base,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Vstack[StackDepth\u22122] + Base,"]},{"entry":[{},"Vstack[StackDepth\u22121] + Base);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}\/\/ end if one leftover vertex"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this embodiment, the triangles are produced in an order which is far more \u2018vertex cache friendly\u2019. Specifically, the triangles produced are . . .\n\n","In essence, triangles corresponding to various values of \u201cStepSize\u201d of the first embodiment are interleaved. Assuming N is sufficiently large, triangles are produced corresponding to the following levels, at least initially, with the pattern . . .\n\n","With the ordering produced by the second embodiment and, assuming the existence of a 16-entry vertex cache with a FIFO replacement policy, the hit rate for, say, a 120 vertex contour is a respectable 62% which is nearly double that of the first embodiment and on-par with a fan or strip.","An example of an apparatus implementing the invention is shown in . The parameters for a contour are supplied, , to an input buffer, . These are read by a state machine, , which implements the steps described in the pseudo code above.","The state machine has access to a vertex stack. The vertex stack is preferably split into two portions, a first portion  containing P stack entries and a second portion . The state machine  has direct access to the top P entries (in the case of triangulation, P=3) of the first portion of the vertex stack . Because it is desirable to have parallel read and write access to these three entries, these would preferably be implemented as independent registers. The second portion of the vertex stack  holds the remaining stack entries and would only require a single read\/write port, and so could be implemented with a cheaper register file with an index to the element that is 4highest on the stack.","There is a read\/write path, , between the first portion of the vertex stack  containing in this case the top three entries, and the remainder of the stack space, second portion , to allow for pushing and popping of stack data.","Unit  also supports the ability to remove or overwrite central elements (when P=3, the second from top stack element, corresponding to the elements which will be culled or clipped as the contour is processed) as described in the pseudo code above. The stack operations are done under the guidance of the state machine. The primitive output unit, here a triangle output unit, , can be instructed by the state machine to select the top three stack elements, , and output the corresponding triangle.","Using a rendering simulator, the \u201ccycle\u201d counts for filling of the stencil for the arbitrary polygons of , using a number of the described triangle generation techniques are compared against each other. Also, as a target benchmark, the rendering cycles (not including pre-processing costs) of the results of a true triangulation algorithm are supplied. For ease of interpretation, the scores are normalised so that the (modified) fan algorithm scores 1.0. Smaller figures are better. The \u201cSander\u201d algorithm is the inventor's interpretation of Sander et al's document.",{"@attributes":{"id":"p-0083","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":[{},{},{},{},{},"Adapted"]},{"entry":["Model\/method","Fan*","Strip","\u201cSander\u201d","Invention","Seidels"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Map (J)","1.0","1.04","0.45","0.36","0.24"]},{"entry":["Hilbert (K)","1.0","0.55","0.36","0.32","0.06"]},{"entry":["Text (L)","1.0","0.71","0.84","0.83","0.20"]},{"entry":["Rand Walk (M)","1.0","0.97","0.62","0.68","0.10"]},{"entry":["Star (N)","1.0","1.21","0.77","0.53","0.18"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}}},"As can be seen, then invention generally compares favourably against the other stencil-based methods.","The second preferred embodiment can further be adapted so that it is unnecessary to know, in advance, how many vertices are in a particular contour before starting to generate the triangle indices. Such an embodiment would be useful in an application which streams vertices that are generated \u2018on the fly\u2019. Additionally, it can be modified to not require support for indexed triangles in the rendering hardware by also storing vertex coordinates in a wider stack.","Some rendering systems also support the rendering of quads (either convex or arbitrary) or even M-sided \u2018arbitrary\u2019 polygons with, say, M\u226616. Either of the presented preferred embodiments can be easily adapted, without departing from the scope of the invention, to output primitive units other than triangles to suit these more flexible rendering systems.","The invention thus presented, on average, reduces overdraw, improves the triangle shape and\/or reduces the data required, relative to the prior art, but one can encounter pathological situations. A very simple case is shown in  (A). Here, the first three vertices, {v, v, v}, form a concavity in the shape, as do all the other \u201cStepSize=1\u201d triangles, , as shown in grey in  (B). After their processing, the method effectively still has to fill the large pentagonal region, . As can be seen from the figure, all these triangles would form a considerable area of overdraw.","The location of the first vertex in  was \u2018unfortunate\u2019. If the embodiments, instead, received the geometrically equivalent figure shown in  (A), the alternative \u201cStepsize=1\u201d triangles,  in  (B), would instead be produced. This would leave just the region, , to be covered by the remaining \u201cstepsize\u201d triangles and lead to no overdraw at all.","Another embodiment thus attempts to reduce the frequency of these pathological cases. Taking inspiration from Seidel's \u2018true triangulation\u2019 method, the alternative embodiment uses a randomisation technique. For each contour, a random or pseudo random offset value can be supplied to or computed by the embodiment. This offset is then added, modulo N, to all the vertex indices in the contour to reduce the likelihood of recurring worst cases.","In some polygon data, the vertices themselves may be supplied as an array of arbitrary indices into a vertex array. It should be obvious one skilled in the art that the embodiments presented here can be extended to support such indirection.","In the Adobe flash format, the edges of arbitrary polygons are apparently supplied in a random, disconnected order. One skilled in the art will realise that a hashing system can be used to reorder these into connected chains before applying the invention described here.","Once the stencil has been set up by drawing the triangulation by the methods above, they can be filled\/shaded\/textured by any of the known methods known in the art such as those described above, i.e. using the bounding box or re-use of the triangulation. Furthermore, if the winding order of the parent polygon is consistent, the additional enhancement, presented in this invention, may be used whereby the triangulation is resent to the rendering system but instructed to cull triangles with the opposite winding order."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Exemplary embodiments of the invention will now be described in detail with reference to the accompanying drawings, in which:",{"@attributes":{"id":"p-0042","num":"0056"},"figref":"FIGS. 1","i":["a ","e "],"b":"1"},{"@attributes":{"id":"p-0043","num":"0057"},"figref":["FIG. 2","FIG. 1"],"i":"a; "},{"@attributes":{"id":"p-0044","num":"0058"},"figref":["FIG. 3","FIG. 1"],"i":"a; "},{"@attributes":{"id":"p-0045","num":"0059"},"figref":["FIG. 4","FIG. 1"],"i":"a; "},{"@attributes":{"id":"p-0046","num":"0060"},"figref":["FIG. 5","FIG. 1"],"i":"e; "},{"@attributes":{"id":"p-0047","num":"0061"},"figref":"FIGS. 6","i":["a ","e "],"b":"6"},{"@attributes":{"id":"p-0048","num":"0062"},"figref":["FIG. 7","FIG. 1"],"i":"a; "},{"@attributes":{"id":"p-0049","num":"0063"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0050","num":"0064"},"figref":["FIGS. 9","FIG. 6"],"i":["a ","f ","a; "],"b":"9"},{"@attributes":{"id":"p-0051","num":"0065"},"figref":["FIG. 10","FIG. 6"],"sup":"th ","i":"a; "},{"@attributes":{"id":"p-0052","num":"0066"},"figref":["FIGS. 11","FIG. 11","FIG. 6","FIG. 11"],"i":["a ","b ","a ","a","b "],"b":"11"},{"@attributes":{"id":"p-0053","num":"0067"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0054","num":"0068"},"figref":"FIGS. 13","i":["a ","b "],"b":"13"},{"@attributes":{"id":"p-0055","num":"0069"},"figref":["FIGS. 14","FIGS. 13"],"i":["a ","b ","a ","b"],"b":["14","13"]},{"@attributes":{"id":"p-0056","num":"0070"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0057","num":"0071"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
