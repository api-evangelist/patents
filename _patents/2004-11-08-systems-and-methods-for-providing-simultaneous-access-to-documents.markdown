---
title: Systems and methods for providing simultaneous access to documents
abstract: A system and method for representing immutable versions of a document that can be simultaneously accessed by a plurality of processes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09026908&OS=09026908&RS=09026908
owner: Oracle International Corporation
number: 09026908
owner_city: Redwood Shores
owner_country: US
publication_date: 20041108
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","COPYRIGHT NOTICE","INCORPORATION BY REFERENCE","FIELD OF THE DISCLOSURE","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application claims priority from the following application, which is hereby incorporated by reference in its entirety: U.S. Provisional Application No. 60\/573,078, entitled SYSTEMS AND METHODS FOR EFFICIENTLY MANAGING VERSIONED DYNAMIC DOCUMENTS, by Timothy Wagner, filed on May 22, 2004.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The following document is incorporated by reference in its entirety:","Tim A. Wagner, Practical Algorithms for Incremental Software Development Environments (1998) (Masters thesis, University of California, Berkeley).","This disclosure relates to providing simultaneous, non-blocking access to documents by multiple processes. In particular, systems and methods are presented for efficiently providing a plurality of versions of a document.","Dynamic analysis of documents has become an important part of many computer programs. Word processors perform spell checking, autocorrect spelling mistakes and analyze the grammar of sentence as a user types a document. Software editors dynamically color-code program text as a programmer types. Interactive development environments (IDEs), and the parsers that underlie them, go a step further to perform lexical analysis on code and statement completion as a programmer types. These types of programs, which we will generically refer to as editors, all share the need to incrementally execute logic over a stable snapshot of a document as it is being modified.","Interactive editors share the characteristic that there is real-time input or modifications to a document taking place. Editors use separate processes to provide additional features in a responsive fashion. Although the remainder of this disclosure provides examples in terms of \u201cprocesses\u201d, the present disclosure is not limited to or dependent upon any particular unit of execution. Thus, the term \u201cprocess\u201d can mean a unit of any granularity of execution, including but not limited to a running program, function, thread, processor level thread, a remote procedure call to another machine, or other computing operation.","One or more processes are responsible for receiving user input and displaying it in the editor, and building the document. Additional background processes execute other features like auto-correction, statement completion, and color coding. This provides the user with a more responsive user interface experience, but it increases the complexity of the editor's implementation because the data entered by the user must be read and analyzed simultaneously by a number of different processes.","When data is accessed by multiple processes, synchronization is normally used to ensure that data written by one process isn't inadvertently overwritten by another process. In addition, synchronization ensures that processes analyzing the document have a stable, unchanging version to work from. This allows one process to obtain exclusive access to the data in order to make changes or complete an analysis. In this manner, only a single process may be modifying the resource at a given time and only when no readers have the document locked for analysis.","Synchronization requires each process to participate in a scheme where the process may obtain a lock on the data. While locks guarantee that a process has exclusive access to the data, locks can also result in poor performance. Processes may lock data for a long period of time, forcing other processes to wait to access the data and slowing the performance of the system. This is particularly problematic when one or more of the processes waiting to access the data is responsible for updating the display and accepting user input since the user's terminal effectively becomes inoperable during lengthy or frequent locking periods. Deadlocks can also occur in which two or more processes wait to access data locked by another process. This also can adversely impact performance and response time since deadlocks usually require a timeout before the process decides to release its locks and try again.","Synchronization also increases code complexity. The code must be carefully written to avoid holding locks too long and starving other processes from executing. Poor synchronization can also introduce additional bugs, the nature of which may be only detectable at runtime. Synchronization bugs are also notoriously difficult to reproduce, resulting in end users experiencing the adverse effects of a synchronization problem.","In addition, it is often desirable for an application to hold multiple versions of the underlying document. For example, the application may need to compare the current version of the document with a previous version or implement an undo stack for reversing changes to a document. But keeping previous versions of a document is resource intensive and presents the problem of knowing when processes are no longer interested in the certain versions of the document and when those versions can be discarded.","In theory, it is possible to address the issues outlined in this section by simply copying all or part of the document whenever a process requires access. However, there are two downsides to this approach which make it undesirable. First, it can require a lot of memory to maintain the separate copies. And second, it can take a lot of time to copy the data e.g. when new versions are required. The deficiencies of this approach get worse as the size of the data increases. An editor's response time decreases and the developer's user experience becomes less desirable.","Aspects of the invention are illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to \u201can\u201d or \u201cone\u201d embodiments in this disclosure are not necessarily to the same embodiment, and such references mean at least one. In the following description, numerous specific details are set forth to provide a thorough description of the invention. However, it will be apparent to one skilled in the art that the invention may be practiced without these specific details. In other instances, well-known features have not been described in detail so as not to obscure the invention.","The present disclosure includes systems and methods that efficiently provide access to successively updated versions of a document as it is modified by various processes. The term \u201cdocument,\u201d for the purposes of this disclosure means any file or other information, persisted in a machine readable medium such as a computer memory, hard disk, removable media or other suitable storage means, and capable of being accessed or used in some manner by a process. Examples of documents include but are not limited to program source code files, word processing files, databases, computer aided design (CAD) files, sound files, image files, multimedia files, and spreadsheets. The term \u201cversion\u201d of a document, for the purposes of this disclosure, refers to a representation of a document after one or more modifications have been made to the document.","In one embodiment, a new version of a document can be created when a process wishes to modify the document. New versions can be made immutable in order to avoid the problem of locking outlined above. By \u201cimmutable,\u201d it is meant that a version of a document remains constant and unchanged as various processes access it. It is also meant that subsequent changes to the document won't affect immutable versions, rather new versions can be created. For example, a user interface process in an editor can create new versions of a text document as the user adds, deletes or modifies text in the document. These new versions can be immutable in order to allow any process to read them without the use of semaphores or other locking mechanisms. In one embodiment, immutable data can be optimized for read access allowing processes to operate freely on the document.","As more and more versions are maintained, the storage space required to maintain multiple versions of a document can grow large, especially for large documents. In one embodiment, to avoid keeping a complete copy of the document with each version common parts of the document are stored once and referenced by multiple versions. As new versions of the document are created, common parts are reused in the new version.","As the common parts of a document are modified and new versions are created, the system can maintain common subsets of information in the document between different versions in order to reduce the required memory. A common subset may require common parts of the document to be split into smaller sub-parts which can be referenced by different versions. The process of splitting the common parts creates a new version but can also maintain all old versions.","Maintaining common subsets also makes it a trivial to determine whether any two versions contain the same parts of the document. As an example, if two versions reference the same subset, then both versions contain the parts of the document which are represented by that subset. This inquiry can be further expanded to determine whether two or more versions contain any of the same parts of a document or to check which parts of a document are contained in any two or more versions.","In one embodiment, it is possible to manage the lifetime of different versions of a document and reclaim versions as they become obsolete. This can be accomplished by using a standard garbage collection algorithm or other suitable algorithm. By way of illustration, complete versions of the document and the parts they contain that are not referenced elsewhere can be discarded when the last reference to the version object is removed. This makes it possible to automatically reclaim old versions once all processes operating on them are no longer interested. As used in this disclosure, \u201creclaiming\u201d includes but is not limited to dropping, freeing, removing, compressing or storing the obsolete version in another location.","In one embodiment, this approach can also be applied to parts of the document that have been deleted from one or more versions. A document part is not discarded until all references to it are removed. This may hold even if the last version of the document referencing the part is removed. Said differently, document parts can live longer than the versions which reference them provided a reference to the part is maintained by some process. In one embodiment, this process can be handled by the garbage collection facility of the host platform or language. (e.g. Java\u00ae).","In one embodiment, processes detect when new versions are available through a notification from the system. A \u201cnotification\u201d can be any message or piece information sent to a process, informing it that a new version of the document has been created. Many types of notification systems are known in the art and various such systems can be implemented for the purposes of this disclosure. For example, a process could be notified by other processes, signals, log files, status queues, client\/server communications as well as other forms of notification systems. The present disclosure is not limited to or dependent on any one notification system, known or yet to be developed.","When a new version of a document is created, a process can access the version and process it. For example, as a software developer or a process makes changes to source code in the editor, a user interface process in the editor creates a new version of the document. The process that performs syntax and semantic analysis on the code is notified by the system that the new version exists. It can then analyze the new version to determine if the developer has introduced any errors with the changes.","In one embodiment, a token represents any portion of a document. A token stream is an ordered plurality of tokens. For example, a token stream can be generated from lexical analysis of the document to represent parts of the document. In modern IDEs, lexical analysis is performed incrementally as a software developer types. Each increment represents a slightly different version as the developer adds, deletes, and modifies the code. Syntax analyzers and type checkers read the token stream to evaluate the correctness of the code and provide feedback to the developer.","In one embodiment, a token stream is represented as a set of tokens which describe the strings, operators, and other constructs used within a programming language.  depicts an example token stream and its corresponding character buffer that might result from the user typing the text \u201c(foo)\u201d into an IDE editor. As the user types in the characters \u201c(foo)\u201d the IDE creates new tokens, each containing a part of the text. As illustrated, the first token may contain the character with the offset[0] of the character buffer, the next token contain the characters with the offsets[1-3] and the last token contain the character with the offset[4].","When the IDE can marks a token stream as complete, an immutable version is created. In one embodiment, the version can be represented as a binary tree with the tokens as its leaf nodes.  depicts a version of the token stream in a binary tree. Since three tokens have thus far been inserted into the document, version  (v) contains the three tokens illustrated in . Note that a common subset () of the first two tokens may be maintained for use by later versions, for the purpose of saving storage capacity. The binary tree type of structure would allow other processes to access the tokens in version  (v) of the token stream in order by performing a depth first traversal of the resulting tree structure. An ordered binary tree structure can be used so that search operations on the tree run in O(logN) time where N is the number of nodes in the tree. Leaf nodes can be labeled with the offset in the character buffer where the associated token begins. Interior nodes within the tree can be labeled with the offset in the character buffer where their rightmost child node begins. For example, the \u201c(\u201c token is at offset [0], the \u201cfoo\u201d token is at offset [1] and the \u201c) \u201dtoken is at offset [4]. As such, the token at a particular position within the binary tree can be located with a binary search.","Continuing the example, the developer may modify the document by adding code using the IDE. For example, the concatenation operator (+) and the string \u201cbar\u201d could be inserted immediately after the string \u201cfoo\u201d inside the parentheses. In one embodiment, this would generate the set of tokens and corresponding character buffer depicted in . Note that two new tokens have been created in , one containing the text \u201c+\u201d and the other containing the text \u201cbar\u201d.","In one embodiment, the version management system inserts these new tokens into the token stream to represent this modified version of the code. In one embodiment, this is accomplished by creating a new version of the document and inserting the new tokens into the associated tree as children of the new version. The version creation process ensures that the previously created immutable version, for example v, remains consistent as other processes may be reading it. Intermediary nodes are introduced to the tree that group tokens in the appropriate order.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 4"},"In step (), the binary tree is traversed using a binary depth-first search to find the token which occurs immediately to the right of the inserted token(s) within the character buffer based on the insertion position. This locates the insertion point in the tree for the new node. For non-textual information, an assumption is made that the information can be represented in a serial fashion. Binary search algorithms on binary trees are well known in the prior art. While traversing the tree, an ordered list of the visited nodes can be maintained.","In step (), starting with the root node, each node is copied in the ordered list of visited nodes (i.e., on the path from the root to the parent of the token following the insertion point) to create a mutated subsection. For each node, copy the node and connect it with its parent node in the same position as the node that was copied (e.g., if the original node was the left child of its parent, the copy should be connected as the left child of its parent) This creates a new version of the token stream that shares nodes it has in common with the previous version of the token stream.","In step (), the new token is inserted into the tree using a standard binary tree insertion algorithm as is well known in the art. The tree can be rebalanced (optional) using balancing algorithms as are well known in the art. In one embodiment, the process of creating the mutated subsection and the rebalancing process are not independent. There are various ways to handle this; rebalancing hypothetically, then cloning nodes as necessarily on the minimal spanning tree of the (hypothetically) affected nodes and the root is one possible algorithm. Other algorithms that do both simultaneously are well known in the art.","In step (), once the new tokens have been inserted, the token stream can be deemed complete, creating a second immutable version of the tree. This algorithm is efficient and yields a time complexity of O(logN+IlogI) where N is the number of nodes and I is the number of insertions.","For example,  depicts a token stream with two versions that might result from inserting the tokens depicted in , via the algorithm depicted in , into the token stream depicted in . The two versions share a node () representing the portions of the text buffer the versions have in common. Any number of processes can continue using version  (v) without locking the token stream or otherwise disrupting other processes operating on the token stream.","Continuing the example, the developer may remove the concatenation operator (\u201d+\u201d) between the two literal strings \u201cfoo\u201d and \u201cbar\u201d. In one embodiment, this would generate a new set of tokens as depicted in .","In one embodiment, this edit causes the version management system to build a third version of the token stream that omits the concatenation operator. Note that the token for the concatenation operator is not deleted immediately because it is still needed by previous versions of the token stream. After all the versions of the token stream that reference the token for the concatenation operator are discarded and there are no more references to this token, it can be discarded by the garbage collector.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 7"},"In step (), the binary tree is traversed using a depth-first binary search to find the token to be deleted based on its position in the text buffer. Once again, for non-textual information, an assumption is made that the information can be represented in a serial fashion. During the search, maintain an ordered list of the visited nodes from the root to the token.","In step (), starting with the root node, each child node in the ordered list of visited nodes is copied (i.e., on the path from the root node to the grandparent of the token to be deleted) to create a mutated subsection. For each node, copy the node and connect it with its parent node in the same position as the node that was copied. (e.g., if the original node was the left child of its parent, the copy should also be the left child of its parent).","In step (), the requested node is deleted from the new version of the token stream in accordance with binary tree algorithms as are well known in the art. The tree can be rebalanced (optional) using balancing algorithms as are well known in the art. In one embodiment, the process of creating the mutated subsection and the rebalancing process are not independent. There are various ways to handle this; rebalancing hypothetically, then cloning nodes as necessarily on the minimal spanning tree of the (hypothetically) affected nodes and the root is one possible algorithm. Other algorithms that do both simultaneously are well known in the art.","In step (), once the new tokens have been deleted, the token stream can be deemed complete, creating another immutable version of the tree. This algorithm is efficient and yields a time complexity of O(logN+IlogI) where N is the number of nodes and I is the number of deletions.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 8","FIG. 5","FIG. 7"],"b":["1","2","3","1","2","3","8","1","2"]},"In one embodiment, reusing the existing tokens and intervening nodes from previous versions of the token stream can achieve space efficiency by limiting the space complexity for storing versions of the tree to O(logN+IlogI) where N is the number of nodes and I is the number of deletions, insertions or modifications to existing tokens.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 9"},"In , as a document () is being modified, modifications can take the form of either an insertion () or deletion () of information. These insertions and deletions result in new versions (v, v) being created as well as new tokens of the document being stored (in case of insertion). A plurality of processes () can access the tokens of the document through the use of versions. An unlimited number of versions can be created, system resources permitting. These new versions can be immutable as previously described, for example they may be implemented as read-only files. Whenever a new version of a document is created, the plurality of processes can be notified by the system that a new version exists. Processes that subsequently need access to the document, can then use the new version to access the document. Various different systems of notification are available in the art and many of them can be implemented, as previously described. For example the system can update a status queue of all available versions by inserting a new version into the queue. The garbage collector () can free up storage space by cleaning up versions that are no longer needed and removing tokens that are no longer referenced by any version. In one embodiment, once a version is no longer being accessed by any of the processes the garbage collector may remove that version and remove such tokens which are unique to the version being removed. However, the present invention is not limited to this particular form of garbage collection technique, many alternatives are known in the art and they can be implemented for the purposes of this disclosure.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 10","b":["1005","1001"]},"The interface () between the version management system and any application or process which desires to use it, can be any type of interface implementation such as an Application Programming Interface (API). Thus, the sharing of data between applications and the version management systems can take the forms of remote procedure calls (RCPs), standard query language (SQL) queries, file transfer, message deliveries as well as other types of communication.","Whenever a new version of the document is created within the version management system, the interface can provide the functionality of sending notifications to other processes () which may require access to the document being modified. These notifications can be implemented as RCPs, SQL queries, file transfers and message deliveries as described above. These examples are of course not a complete list of all means of notifications and sharing of data. It will be apparent to those skilled in the art that alternatives are possible.","The foregoing examples illustrated the token stream as being contained in a binary tree object. However, a binary tree is not necessary for this disclosure. Any containment structure can be used, such as an acyclic graph or a list.","Various embodiments may be implemented using a conventional general purpose or specialized digital computer(s) and\/or processor(s) programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits and\/or by interconnecting an appropriate network of component circuits, as will be readily apparent to those skilled in the art.","Various embodiments include a computer program product which is a storage medium (media) having instructions and\/or information stored thereon\/in which can be used to program a general purpose or specialized computing processor(s)\/device(s) to perform any of the features presented herein. The storage medium can include, but is not limited to, one or more of the following: any type of physical media including floppy disks, optical discs, DVDs, CD-ROMs, microdrives, magneto-optical disks, holographic storage devices, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, PRAMS, VRAMs, flash memory devices, magnetic or optical cards, nano-systems (including molecular memory ICs); and any type of media or device suitable for storing instructions and\/or information. Various embodiments include a computer program product that can be transmitted in whole or in parts and over one or more public and\/or private networks wherein the transmission includes instructions and\/or information which can be used by one or more processors to perform any of the features presented herein. In various embodiments, the transmission may include a plurality of separate transmissions.","Stored one or more of the computer (e.g. machine) readable medium (media), the present disclosure includes software for controlling both the hardware of general purpose\/specialized computer(s) and\/or processor(s), and for enabling the computer(s) and\/or processor(s) to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include, but is not limited to, device drivers, operating systems, execution environments\/containers, user interfaces and applications.","The execution of code can be direct or indirect. The code can include compiled, interpreted and other types of languages. Unless otherwise limited by claim language, the execution and\/or transmission of code and\/or code segments for a function can include invocations or calls to other software or devices, local or remote, to do the function. The invocations or calls can include invocations or calls to library modules, device drivers and remote software to do the function. The invocations or calls can include invocations or calls in distributed and client\/server systems.","The foregoing description of the preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best describe the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention, the various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 5","FIGS. 1 and 3"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 8","FIGS. 1"],"b":["3","6"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 9","FIG. 9"],"b":["901","909","903","905","911","1","2","907"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
