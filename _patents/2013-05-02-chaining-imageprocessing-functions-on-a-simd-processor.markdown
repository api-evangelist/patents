---
title: Chaining image-processing functions on a SIMD processor
abstract: In a single-instruction-multiple-data (SIMD) processor having multiple lanes, and local memory dedicated to each lane, a method of processing an image is disclosed. The method comprises mapping consecutive rasters of the image to consecutive lanes such that groups of consecutive rasters form image strips, and vertical stacks of strips comprise strip columns. Local memory allocates memory to the image strips. A sequence of functions is processed for execution on the SIMD processor in a pipeline implementation, such that the pipeline loops over portions of the image in multiple iterations, and intermediate data processed during the functions is stored in the local memory. Data associated with the image is traversed by first processing image strips from top to bottom in a left-most strip column, then progressing to each adjacent unprocessed strip column.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08786614&OS=08786614&RS=08786614
owner: Calos Fund Limited Liability Company
number: 08786614
owner_city: Dover
owner_country: US
publication_date: 20130502
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS","Pipeline Example"],"p":["This application is a continuation of U.S. patent application Ser. No. 12\/687,010 filed Jan. 13, 2010, entitled METHOD FOR CHAINING IMAGE-PROCESSING FUNCTIONS ON A SIMD PROCESSOR, which claims benefit of priority to Provisional U.S. Patent Application No. 61\/144,700 filed Jan. 14, 2009, entitled METHOD FOR CHAINING IMAGE-PROCESSING FUNCTIONS ON A SIMD PROCESSOR. The aforementioned priority applications are hereby incorporated by reference in their entireties.","The disclosure herein relates to methods and apparatus for parallel processing, and more particularly image processing methods for single-instruction-multiple-data (SIMD) processing environments.","An image processing function, or kernel, that implements a point operation on an image can be easily mapped to a SIMD processor and efficiently chained. This is because the order of the pixels presented to each SIMD processor is unimportant since each result pixel only depends on one source pixel.","Many image processing kernel functions, however, determine neighboring context to generate an output pixel value. To calculate the new value of a pixel, the kernel often reads surrounding pixel values. Many ways exist to map such kernels to a SIMD processor, where each mapping uses a different partitioning of data among the SIMD processing lanes or traverses the data in a different order. Usually, performance optimized mappings vary based on the underlying algorithms being implemented, which is partly why such a diversity of implementation strategies abound. Because of these differences, image processing kernels cannot be guaranteed to easily chain together without \u201cglue logic\u201d that transposes data between SIMD processing lanes or via an extra global memory transfer. This both reduces performance and lowers productivity.","While existing solutions allegedly work adequately for their intended applications, they are often inflexible in accommodating a large set of image processing algorithms, especially when little to no loss of performance is desired. Thus, improved mapping methods and apparatuses for image processing in SIMD processors are described herein.","Embodiments described herein provide a system and a method for implementing image processing functions on SIMD processors that allows for straightforward and high-performance chaining of consecutive processing functions. A method, such as described, called raster-per-lane (RPL), achieves its results by precisely constraining both the data partitioning among SIMD processors and the data traversal order. Advantages of certain embodiments of this method may include: (1) functions can be chained together to process images without intermediate trips to external memory or \u201cglue logic\u201d to reorganize intermediate pixel data thereby improving performance; and (2) each function can be implemented separately (possibly by independent parties) in a modular fashion and then combined easily.","SIMD Architecture Overview","A SIMD architecture typically consists of multiple processing lanes that all execute the same operations but on different data. Throughout this document including any code listings, N or NUM_LANES, refers to the number of lanes. The lanes each have a fast local private memory, and all the lanes share an interface to a slower global memory. Typically, the private memory is on-chip SRAM (e.g., on the order of 16 KB per lane), and the global memory is off-chip DRAM (on the order of 1 GB shared by all of the lanes). DMA engines often manage transfers to and from global memory. An example of a SIMD architecture is the stream architecture.","SIMD processors execute functions known as kernels. Each kernel implements an image processing algorithm, such as pixel color conversion, scaling, or filtering. Its arguments include scalars as well as streams, which are designations of pre-allocated regions of local private memory where input data can be read and output data can be written by each SIMD lane.","A sequence of kernels that process input image(s) to generate output image(s) is known as a kernel processing graph (or simply kernel graph). Generally, the outputs of one kernel will directly feed the inputs of another. There can be diverging and merging dataflows between kernels. Also, kernels may have multiple inputs and\/or outputs.","A kernel graph may be implemented as a pipeline, where chained kernels usually pass data through streams allocated in on-chip local memory. Since only a portion of an input image resides in local memory, pipelines typically loop over an input image, processing a bit of the image during each iteration of the loop. An iteration typically transfers data from external memory to local memory, calls each kernel in the pipeline, then passes data back from local to external memory. Basically, a pipeline implements a portion of a kernel graph in an optimized fashion where the source originates in global memory and the output is stored back to global memory, but all intermediate data is stored in local memory.","Often, especially in embedded computer systems, an entire image cannot fit into the available global memory\u2014for instance, in imaging applications that process 8 inch by 11 inch or larger pages that are sampled at 1200 dots per inch (dpi) in color. These images are processing incrementally, with a portion of the image in a memory buffer at any given time. Usually the image is processed in sections from top to bottom. Each section is referred to as an incremental buffer and contains some number of lines of the image, with the exact number dependent on the amount of available memory and the type of processing required.","Throughout the disclosure herein, two types of code are shown in various examples: control code and kernel code. The control code runs on a scalar processor that is responsible for coarse grain control of the SIMD lanes and of the DMA engines. Often, this can just be the first SIMD processor, depending on the exact architecture. Kernel code, on the other hand, is executed in lockstep across all SIMD lanes in parallel, with the exact same code running on each lane but with different data. The disclosure herein presents control code in \u201cC\u201d language syntax with an extension for the stream datatype as provided in the StreamC language syntax. Note: allocation for stream data in local memory may be performed statically for optimal performance; however, for simplicity, this disclosure assumes that stream data are allocated dynamically. Kernel code is presented completely in the \u201cStreamC\u201d language syntax. Additionally, all kernel code is contained in functions declared with the kernel keyword.","The raster-per-lane method described herein maps consecutive lines, or rasters, of an image to each of N parallel processor lanes. With reference to , a group of N consecutive lines forms an image strip . An image strip (or simply strip) is an area of image pixels with a height equal to N and a width which is less than or equal to the width of the image. Importantly, a strip resides in local on-chip memory. Within a kernel function, each lane reads and writes pixels from the line in their private memory. The entire strip is processed in parallel from left to right.","Referring now to , a strip column  consists of a vertical stack of strips, usually equal to the height of the image. If the width of a strip is narrower than the width of the image, then the full set of strip columns will completely cover the image with a small amount of horizontal overlap at interior edges. The data traversal order in the RPL method is to process the strips in a strip column from top to bottom, and then the strip columns from left to right.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3","b":["300","302","304","306","308"]},"Application Programming Interface","A programmer can use the following APIs to implement the RPL data partitioning and RPL data traversal order for their kernel functions and pipelines.","To access neighboring vertical context in an image, a row tap function may be used from within a kernel. Exemplary code is shown below:",{"@attributes":{"id":"p-0030","num":"0029"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct row_tap_3_t_ { int ti; int c0; int bl; } row_tap_3_t;"},{"entry":"inline kernel void\u2003row_tap_3_init_controls ("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","offset(in), \/\/ Additional offset: 0 <= offset <="]},{"entry":[{},{},"(NUM_LANES+1\u2212width)"]},{"entry":[{},"int","scn0(in),"]},{"entry":[{},"int","scns(in),"]},{"entry":[{},"vec","row_tap_3_t vpc0(out),"]},{"entry":[{},"vec","row_tap_3_t vpc1(out)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":") ;"},{"entry":"inline kernel vec row_tap_3_t\u2003\u2003row_tap_3_get_taps ("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vec","row_tap_3_t","vpc0 (in) ,"]},{"entry":[{},"vec","row_tap_3_t","vpc1 (in) ,"]},{"entry":[{},"vec","int","prv (in) ,"]},{"entry":[{},"vec","int","src (in)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The code above relates to an example for a 3-high filter. Generating APIs for filters of other sizes is relatively straightforward. The row tap3 init controls inline kernel is called once before entering the main kernel loop. The function initializes a pair of control structures that are used with the function row_tap3_get_taps to extract the vertical context needed by each lane from vectors read from the current and previous strips. The controls take into account where the strips are in the overall frame so that the top and bottom edges are handled properly.","A kernel_state_t API provides access to the parameters and storage that is specific to a kernel. Code for an exemplary datatype is shown below for a kernel that processes data from a single input image and produces data for a single output image; requires less than NUM_LANES of vertical context, and has no other input requirements such as look-up tables or programmable filter coefficients. More complex kernels may seek additional private data and should use a datatype similar to kernel_state_t, but customized for that particular kernel.","The fields in kernel_state_t allow the user to access a satisfactory amount of vertical and horizontal context. The datatype also holds a reference to the history strip used by the kernel to maintain vertical context from one strip to the next. The two additional fields provide a place to save this history buffer between pipeline calls when processing incremental buffers. The exemplary code reads:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","context_width;"]},{"entry":[{},"int","context_height;"]},{"entry":[{},"int","context_height_extra;"]},{"entry":[{},"strip_t","history;"]},{"entry":[{},"image_t","prv; \/\/ for incremental"]},{"entry":[{},"image_t","nxt; \/\/ for incremental"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} kernel_rec_t;"},{"entry":"typedef kernel_rec_t *kernel_state_t;"},{"entry":"kernel_state_t kernel_state_new("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","image_format,"]},{"entry":[{},"int","image_width,"]},{"entry":[{},"int","context_width,"]},{"entry":[{},"int","context height,"]},{"entry":[{},"int","context_height_extra,"]},{"entry":[{},"strip_t","history,"]},{"entry":[{},"image_t","prv, \/\/ for processing incremental buffers"]},{"entry":[{},"image_t","nxt \/\/ for processing incremental buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":") ;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["void","kernel_state_free (kernel_state_t kk);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["int","kernel_state_get_context_width","(kernel_state_t kk);"]},{"entry":["int","kernel_state_get_context_height","(kernel_state_t kk);"]},{"entry":["int","kernel_state_get_context_height_extra","(kernel_state_t kk);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["strip_t","kernel_state_get_history_strip","(kernel_state_t kk);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["void","kernel_state_set_history_strip","(kernel_state_t kk, strip_t ss);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ For incremental buffers"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","kernel_state_load_history","(kernel state t kk);"]},{"entry":["void","kernel_state_store_history","(kernel state t kk);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["image_t","kernel_state_get_prv_buffer","(kernel state t kk);"]},{"entry":["image_t","kernel_state_get_nxt_buffer","(kernel state t kk);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","kernel_state_done","(kernel state t kk);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The API also provides a strip_t datatype that represents an image strip in local memory. Associated functions are used to load data from global memory into the local memory and to store it back out to global memory. Kernel interfaces also operate on strips and produce strips. Each strip has a scalar line0 argument associated with it which is the y position of the strip in some overall frame. It also holds the height of this frame in its lines parameter. The height of the strip itself is always fixed at NUM_LANES. It is ok for strips to have negative line0s as well as line0s larger than lines. A negative value for line0 means that the top line of the input stream aligns above the upper boundary of the image. All the horizontal offsets and widths for the strip are isolated in the column element. Exemplary code reads:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stream_t","stream;","\/\/ type, LRF_location, max_size"]},{"entry":[{},"strip_column_t","column;","\/\/ horizontal position and size"]},{"entry":[{},"int","line0;","\/\/ vertical position in frame"]},{"entry":[{},"int","lines;","\/\/ vertical heightof frame"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} strip_rec_t;"},{"entry":"typedef strip_rec_t *strip_t;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["strip_t","strip_new (strip_column_t column, int lines);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void","strip_free","(strip_t strip);"]},{"entry":["void","strip_load","(strip_t strip, image_t image, int line);"]},{"entry":["void","strip_store","(strip_t strip, image_t image);"]},{"entry":["stream_t","strip_get_stream","(strip_t strip);"]},{"entry":["strip_column_t","strip_get_column","(strip_t strip);"]},{"entry":["int","strip_get_line0","(strip_t strip);"]},{"entry":["int","strip_get_lines","(strip_t strip);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"A strip_column_t datatype is provided in the API to hold the data describing the horizontal offsets and widths for a vertical stack of strips in an image. The functions that operate on this datatype provide access to key DMA load and store parameters for every strip within this column (i.e., load width, load offset, etc.). Additionally, the strip_column_next function should be called after processing each column, as it updates the fields within the strip_column_t data structure with the necessary parameters for the next column to process. For convenience, a pointer to a common strip_column_t is shared by the strips. As an example, relevant code may read:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int rem_width;"]},{"entry":[{},"int image_width;"]},{"entry":[{},"int strip_width_max;"]},{"entry":[{},"int overlap;"]},{"entry":[{},"int load_src_width;"]},{"entry":[{},"int load_src_offset;"]},{"entry":[{},"int store_dst_width;"]},{"entry":[{},"int store_dst_offset;"]},{"entry":[{},"int store_src_offset;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} strip_column_rec_t;"},{"entry":"typedef strip_column_rec_t *strip_column_t;"},{"entry":"strip_column_t strip_colunm_new ("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int image_width,"]},{"entry":[{},"int strip_width_max,"]},{"entry":[{},"int overlap"]},{"entry":[");",{}]},{"entry":["void","strip_columm_free (strip_column_t column);"]},{"entry":["void","strip_column_next (strip_column_t column);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ Used by strip load from external to internal memory"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["int","strip_colunm_get_load_width(\u2003\u2003\u2009strip_column_t column);"]},{"entry":["int","strip_colunm_get_load_src_offset ( strip_column_t column);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ Used by strip store from internal to external memory"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["int","strip_column_get_store_width(\u2003\u2003strip_column_t column);"]},{"entry":["int","strip_column_get_store_src_offset\u2003(strip_column_t column);"]},{"entry":["int","strip_column_get_store_dst_offset\u2003(strip_column_t column);"]},{"entry":["int","strip_colunm_valid (strip_column_t column);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"An image_t datatype keeps track of various useful parameters for a buffer in global memory that contains image data. With reference to , it contains the dimensions of the active image area , how the image data is organized in the memory buffer (height, width and stride), and as shown in , if processing incremental buffers, it also contains the incremental buffer's position within the larger image (or frame). Relevant coding examples may read:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","width;"]},{"entry":[{},"int","height;"]},{"entry":[{},"int","stride;"]},{"entry":[{},"int","frame_line0;"]},{"entry":[{},"int","frame_lines;"]},{"entry":[{},"uint8_t *","data;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} image_rec_t;"]},{"entry":[{},"typedef image_rec_t *image_t;"]},{"entry":[{},"image_t image_new ("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","width,"]},{"entry":[{},"int","height,"]},{"entry":[{},"int","stride,"]},{"entry":[{},"int","frame_line0,"]},{"entry":[{},"int","frame_lines,"]},{"entry":[{},"uint8_t *","data"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},") ;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void","image_free (image_t);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","image_get_width (","image_t img);"]},{"entry":[{},"int","image_get_height (","image_t img);"]},{"entry":[{},"int","image_get_stride (","image_t img);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"uint8_t *","image_get_data (","image_t img);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","image_get_frame_lines (","image_t img);"]},{"entry":[{},"int","image_get_frame_line0 (","image_t img);"]},{"entry":[{},"int","image_get_frame_line1 (","image_t img, int"]},{"entry":[{},{},{},"context_height);"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The following pipeline example uses the above APIs to chain together two kernel functions to operate on an entire image, where the intermediate data produced by the first kernel, foo, is consumed directly by the second kernel, bar, without being saved in global memory.",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20021","void"]},{"entry":["\u20022","foobar_pipe("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20023","kernel_state_t foo,"]},{"entry":["\u20024","kernel_state_t bar,"]},{"entry":["\u20025","image_t src,"]},{"entry":["\u20026","image_t dst)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u20027","{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20028","\/\/ defined manually based on local memory size"]},{"entry":["\u20029","int strip_width_max = MAX_FOOBAR_STRIP_WIDTH;"]},{"entry":["10",{}]},{"entry":["11","int context_width = kernel_state_get_context_width (foo) +"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["12","kernel_state_get_context_width (bar);"]},{"entry":["13",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["14","int context_height = kernel_state_get_context_height (foo) +"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["15","kernel_state_get_context_height (bar);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"16"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["17","strip_column_t column = strip_column_new ("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["18","image_get_width(src),"]},{"entry":["19","strip_width_max,"]},{"entry":["20","context_width);"]},{"entry":["21",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["22","int","lines","= image_get_frame_lines (src);"]},{"entry":["23","int","line0","= image_get_frame_line0 (src);"]},{"entry":["24","int","line1","= image_get_frame_line1 (src, context_height);"]},{"entry":["25","int","line;",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["26","strip_t tmp_strip","= strip_new (column, lines);"]},{"entry":["27",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["28","kernel_state_set_history_strip (foo, strip_new (column,"]},{"entry":[{},"NUM_LANES) );"]},{"entry":["29","kernel_state_set_history_strip (bar, strip_new (column,"]},{"entry":[{},"NUM_LANES) );"]},{"entry":["30",{}]},{"entry":["31","while (column_valid(column))"]},{"entry":["32","{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["33","for (line=line0; line<line1; line=line+NUM_LANES)"]},{"entry":["34","{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["35","strip_load (","tmp_strip, src, line0);"]},{"entry":["36","foo_function ( foo,","tmp_strip, tmp_strip);"]},{"entry":["37","bar_function ( bar,","tmp_strip, tmp_strip);"]},{"entry":["38","strip_store (","tmp_strip, dst);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["39","}"]},{"entry":["40","strip_column_next(column);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["41","}"]},{"entry":["42",{}]},{"entry":["43","strip_free (tmp_strip);"]},{"entry":["44","strip_free (kernel_state_get_history_strip (foo);"]},{"entry":["45","strip_free (kernel_state_get_history_strip (bar);"]},{"entry":["46","strip_column_free (column)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Referring to the lines of code above, the kernel_state API is used in lines 11-15 to compute the overall pipeline vertical and horizontal context requirements by summing the contributions from each kernel. Lines 17-21 compute a new strip_column using the computed horizontal overlap requirement (context_width), strip_width_max and the image width. The next 3 statements extract the frame height (lines), the starting line number of the image buffer (line0) and the main loop termination limit (line1) given the overall vertical context required by the pipeline (context_height). The next statement allocates a new tmp_strip which will serve as the common input\/output strip for the kernels. The next 2 statements allocate and set private history strips for the two kernels. The outer while loop is executed once for each column. The last statement of this loop is the required strip_column_next call. The inner for loop gets called for each strip in the column. The strip_load call initializes the tmp_strip with the image data for the current source column_strip. Each of the kernel calls uses this tmp_strip as both the source and destination strip (in practical implementations, multiple strips are often used to increase parallelism between loads from global memory, stores to global memory, and kernel processing). The vertical line0 associated with tmp_strip is updated by each kernel based on the delay being introduced. When the tmp_strip is stored, this internal line0 is used to position the strip in the output image. The private management of each kernel's history strip is carried on inside the foo_function or bar_function functions.","Note that in the pipeline described above, all transfers with global memory and all processing steps are in units of strips. In contrast, within a kernel function, all accesses and processing steps are in units of pixels.","As alluded to earlier, strips are the unit of processing with kernels accepting source strip(s) in local memory and then producing new destination strip(s) of the same size in local memory. In other embodiments, kernels may be provided that perform arbitrary scaling and controlled handling to ensure that the input and output are quantized to units of strips.","As additional kernels are chained together in longer pipelines, more local memory is allocated to maintaining vertical context strips for each kernel. This reduces the maximum strip width that can be processed.","When the maximum strip width is less than the image width, the image is broken up into multiple overlapping columns of strips. The pipeline is run on all of the strips in the first column, restarted at the top of the next column, and so on until all of the columns are processed.","The strip_column API isolates the computations involved in producing slightly overlapping strip columns. The function strip_column_new takes the image width in words, the maximum strip width manageable and the total edge context words needed and produces a strip_column record with all the horizontal sizes and offsets needed by the kernels, loads and stores.","The left edge of the first strip column and the right edge of the last column will be handled correctly because each kernel assumes the left edge of each strip aligns with the left edge of the image and similarly for the right edge. However, this also means that a few of the pixels at the interior strip edges may be incorrect. The strip_column API accounts for this and will setup the store parameters to only store the valid set of pixels back to global memory. For example, one embodiment includes generating pixels outside the left and right image boundaries by requiring kernels to assign an input line as the full width of the image and loading extra horizontal context for internal vertical edges and selectively storing valid data back to a global memory.","Each kernel operates to avoid introducing any horizontal phase error and (except for scaling) produces the same size strip as the source. The vertical phase shift introduced by each kernel is recorded by each kernel in the output strip line0. This line0, along with the horizontal offsets and sizes of the strip's column data are used by the store at the end of the chained kernels to position the output strip correctly in the output image.","The foo_function and bar_function that are used above are wrappers around the actual kernel code. They are used to simplify the pipeline code and to emphasize the modularity of the chained kernels. In the example implementation of foo_function below, the strip and kernel_state APIs are used to extract the more primitive arguments used directly by the actual kernel. (Many kernels will require a more complex datatype than kernel_state_t in order to manage additional private state such as tables, etc.). Examples are provided below:",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void"},{"entry":"foo_function ("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kernel_state_t kk,"]},{"entry":[{},"strip_t src,"]},{"entry":[{},"strip_t dst)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int dst_line0 =","strip_get_line0 (src) \u2212"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kernel_state_get_context_height (kk) \u2212"]},{"entry":[{},"kernel_state_get_context_height_extra (kk);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"foo_kernel ("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kernel_state_get_context_height_extra (kk),"]},{"entry":[{},"strip_get_line0 (src),"]},{"entry":[{},"strip_get_lines (src),"]},{"entry":[{},"strip_column_get_load_width ( strip_get_column (src) ),"]},{"entry":[{},"strip_get_stream (src),"]},{"entry":[{},"strip_get_stream (kernel_state_get_history_strip (kk) ),"]},{"entry":[{},"strip_get_stream (kernel_state_get_history_strip (kk) ),"]},{"entry":[{},"strip_get_stream (dst)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":");"},{"entry":"strip_set_line0 (dst, dst_line0);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Kernel Interface","Although individual kernels may have additional arguments specific to their function, the nominal kernel interface used above may be illustrated by the following:",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"kernel void foo_kernel("}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int","offset (in),","\/\/ optional - added scan line delay"]},{"entry":[{},"int","line0 (in),","\/\/ lane 0 source line"]},{"entry":[{},"int","lines (in),","\/\/ scan lines in overall frame"]},{"entry":[{},"int","words (in),","\/\/ words to process"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"stream pixel_type src_stm (seq_in), \/\/ source stream"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stream pixel_type prv_stm (seq_in),","\/\/ previous src data in"]},{"entry":[{},"stream pixel_type nxt_stm (seq_out),","\/\/ previous src data out"]},{"entry":[{},"stream pixel_type dst_stm (seq_out)","\/\/ destination stream"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["offset is an optional branch delay equalization input described in the Advanced Topics section.","line0 is the vertical position of the first line of the source strip within the overall image. This can be negative or larger than the lines argument.","lines is the number of scan lines in the frame.","words is the width of the input stream in number of words.","src_stm is the source stream with image data loaded one scan line per processor.","dst_stm is the destination stream","prv_stm is the previous source stream in.","nxt_stm is the previous source stream out\n\nNote: prv_stm and src_stm together provide 2*N lines of vertical context.\n"]}}}},"In general, all streams are typically accessed in a sequential fashion. Often, when used in a pipeline, the argument provided to prv_stm and nxt_stm will be the same stream and the argument provided to src_stm and dst_stm will be the same stream. In this way, chained kernels in a pipeline seem to progressively transform the same area of local memory while rotating a delayed version of the source stream through their private history buffers. However, note, there is a tradeoff between sharing strip allocations in local memory versus parallelism of DMA transfers and kernel execution.","Kernels, with the exception of slave kernels, maintain any additional required vertical context by making copies of the source strip in local memory for use in the next call. So, typically, each processor will have convenient access to a vertical context of N previous scan lines by accessing data in either the current or previous strip in its own or a peer's local memory. More complex kernels may require more than one previous history strip. By making kernels responsible for providing their own additional vertical context, it becomes much easier to swap kernels in and out of pipelines with little effect on other kernels.","As an example, and referring now to , for each source strip loaded, such as at , each chained kernel is called once, at . Kernel K produces a y delayed destination strip, at , and copies the current source strip to its next output, at . This will become the previous K source strip the next time K is called. Kernel K's destination strip becomes the current source strip for the chained K kernel which is called next, at .","Generally speaking, each kernel will introduce some minimum vertical phase delay. Referring to , a 3\u00d73 filter  uses the current scan line, at , with two previous lines, at  and , producing an output scan line at  that is centered on the previous scan line. So the minimum vertical phase delay is 1. The output strip for this filter will have a line0 associated with it that is one less than the source strip's line0 value. When the next kernel in the chain reads this strip, this new value of line0 will be provided.","The following example of a kernel implementing a 3\u00d73 filter illustrates use of the row tap API, described earlier, to simplify accessing the vertical filter taps.",{"@attributes":{"id":"p-0061","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u20021","typedef struct row_tap_3_t_ {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20022","int t1; \/\/ top tap"]},{"entry":["\u20023","int c0; \/\/ center tap"]},{"entry":["\u20024","int b1; \/\/ bottom tap"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20025","} row_tap_3_t;"]},{"entry":["\u20026",{}]},{"entry":["\u20027","\/\/ Separable 3\u00d73 filter"]},{"entry":["\u20028","kernel void filter_3\u00d73_pl1_rpl("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20029","int offset (in), \/\/ additional vertical offset beyond 1"]},{"entry":["10","int line0 (in),"]},{"entry":["11","int lines (in),"]},{"entry":["12","int wrds (in), \/\/ strip width in words"]},{"entry":["13","stream int\u2003cur_stm(seq_in),"]},{"entry":["14","stream int\u2003prv_stm(seq_in),"]},{"entry":["15","stream int\u2003nxt_stm(seq_out),"]},{"entry":["16","stream int\u2003dst_stm(seq_out) )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["17","{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["18","vec row_tap_3_t","ctl0;"]},{"entry":["19","vec row_tap_3_t","ctl1;"]},{"entry":["20","vec row_tap_3_t","taps;"]},{"entry":["21",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["22","vec int hor_l1, hor_c0, hor_r1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["23","int","cycles = wrds\u22121;"]},{"entry":["24","int","cycle = 0;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["25","vec int","cur;"]},{"entry":["26","vec int","prv;"]},{"entry":["27","vec int","val;"]},{"entry":["28",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["29","row_tap_3_init_controls (offset, line0, lines, ctl0, ctl1);"]},{"entry":["30",{}]},{"entry":["31","spi_read( cur_stm, cur);"]},{"entry":["32","spi_read( prv_stm, prv);"]},{"entry":["33","spi_write(nxt_stm, cur);"]},{"entry":["34","taps = row_tap_3_get_taps (ctl0, ctl1, prv, cur);"]},{"entry":["35","hor_c0 = filter_3_getVerResult (taps);"]},{"entry":["36",{}]},{"entry":["37","\/\/ replicate 1 at left side"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["38","hor_l1","= spi_vshuffleu(0x00000000, (vec uint32.times.1)"]},{"entry":[{},{},"hor_c0, 0);"]},{"entry":["39",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["40","while (cycle < cycles)"]},{"entry":["41","{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["42","spi_read( cur_stm, cur);"]},{"entry":["43","spi_read( prv_stm, prv);"]},{"entry":["44","spi_write(nxt_stm, cur);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["45","taps","= row_tap_3_get_taps(ctl0, ctl1, prv, cur);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["46","hor_r1","= filter_3_getVerResult(taps);"]},{"entry":["47",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["48","val","= filter_3_getHorResult_pl1(hor_l1, hor_c0,"]},{"entry":[{},{},"hor_r1);"]},{"entry":["49",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["50","\/\/ Shift horizontal context left"]},{"entry":["51","hor_l1 = hor_c0;"]},{"entry":["52","hor_c0 = hor_r1;"]},{"entry":["53",{}]},{"entry":["54","spi_write(dst_stm, val);"]},{"entry":["55","cycle = cycle + 1;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["56","}"]},{"entry":["57",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["58","hor_r1","= (vec int16.times.2) spi_vshuffleu(0x03030303,"]},{"entry":[{},{},"hor_c0, 0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["59","val","= filter_3_getHorResult_pl1(hor_l1, hor_c0, hor_r1);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["60","spi_write(dst_stm, val);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["61","}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The initialization inline kernel: row_tap3_init controls, specified in the exemplary code above, is called once on entry and uses offset, line0 and lines to compute 2 control structures: ctl0 and ctl1. Each control structure has 3 elements corresponding to the 3 vertical taps. Each control tap is actually a vector of N values. These control taps incorporate all the special top and bottom effects. That is, offset, line0 and lines are not used anywhere else in the kernel.","row_tap3_init_controls is generic and can be used by any 3 high filter.","Once the control structures have been initialized, they can be used by the row_tap3_get_taps inline kernel, shown in the code above, to extract a set to taps from vertical context of 2*N lines represented by prv_stm and cur_stm. In this case, get_taps is called once before the loop and then once for each loop cycle. Since row_tap3_get_taps just returns the taps, it is also generic and may be used by any 3 high filter. The row_tap api includes these inline kernels for all odd sizes from 3 to N\u22121. The particular weighting function specific to this kernel is isolated in two inline calls:","filter3_getVerResult(taps);","filter3_getHorResult_p11(hor11, hor_c0, hor_r1","The number of get taps necessary in the preamble before the loop, and therefore, the number of replication steps in the section after the loop, is a function of how many taps are used by the filter and whether pixels are planar or pixel packed. The next history stream, nxt_stm, is updated every time the source, cur_stm, is read.","The row_tap API assumes that the behavior beyond the top and bottom image edges is to replicate the boundary pixels. Since kernels are provided with the vertical position for their source strips as well as the number of scan lines in the overall frame, they can properly handle required neighbors that are above or below the image boundary, for instance, replicated data from the top or bottom scan line, or generating pixels outside the top and bottom image boundaries within kernel functions by passing the current line number and the total number of lines in the image to the kernel.","Kernels are written such that they process their strips as if the strip represented the full width of the image, even though this is often not the case. This usually means the source data is internally replicated by the kernel at the beginning and end of the processing call to fill in missing context at the edges. This strategy removes the necessity of communicating and implementing different edge cases to the kernel with very little additional processing cost. In the example, this is implemented in lines 38 and 58. This behavior can readily be changed by modifying, for instance, if a constant pixel color is required outside image boundaries.","The kernel produces a strip with a width that is equal to the source by reading ahead one word and replicating it for the initial left horizontal context. The loop then produces all but the last result. The last output is produced after replicating the last horizontal context result.","Full width processing of partial width strips is handled such that no horizontal phase error is introduced. The output strip should not be shifted either left or right relative to the source.","Note that there are only a few lines of code unique to the particular 3\u00d73 filter described above in lines 35, 46 and 48. Interestingly, a new 3\u00d73 filter could be created very quickly using this one as a template. Only the filter3_getHorResult_pl1 and filter3_getVerResult functions need to be replaced with two new functions in order to generate a completely different 3\u00d73 kernel.","Similarly, this kernel implementation assumes that the filter is separable, which means that the pixels can be filtered using a dot-product in one dimension and then the results filtered using a dot-product in the other dimension. This is possible when the 3\u00d73 filter matrix is symmetric. A full matrix multiply can readily be employed instead by modifying the kernel code.","In some embodiments, performance optimizations may be applied to the basic methods presented above. For example, when handling large image sizes, access to sufficient external memory may be constrained. In such cases, the pipelines may be configured such that the external memory buffers only represent a small horizontal slice of the overall frame. After each strip column is processed, the local memory previous strip history for each kernel is saved to external memory. Then, when the next buffer arrives, the history is restored before processing of that column begins. The history load and stores use the same strip column parameters as the primary image load and stores.","Since source strips overlap between columns, two separate buffers in external memory are used to save and restore history streams. After processing all columns, the buffers need to be swapped in preparation for the next call. Also, each external memory carries two additional parameters:\n\n","The six coded statements below provide an example to add the capability to deal with incremental buffers:",{"@attributes":{"id":"p-0076","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void"},{"entry":"foobar_incremental_pipe("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kernel_state_t foo,"]},{"entry":[{},"kernel_state_t bar,"]},{"entry":[{},"image_t src,"]},{"entry":[{},"image_t dst)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int strip_width_max = 1000;"]},{"entry":[{},"int context_width = kernel_state_get_context_width(foo) +"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"kernel_state_get_context_width(bar);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int context_height = kernel_state_get_context_height(foo) +"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"kernel_state_get_context_height(bar);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"strip_column_t column = strip_column_new("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"image_get_width(src),"]},{"entry":[{},"strip_width_max,"]},{"entry":[{},"context_width"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},");"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int lines","= image_get_frame_lines(src);"]},{"entry":[{},"int line0","= image_get_frame_line0(src);"]},{"entry":[{},"int line1","= image_get_frame_line1(src, context_height);"]},{"entry":[{},"int line;",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"strip_t tmp_strip = strip_new(column, lines);"]},{"entry":[{},"kernel_state_set_history_strip(foo, strip_new(column,"]},{"entry":[{},"NUM_LANES));"]},{"entry":[{},"kernel_state_set_history_strip(bar, strip_new(column,"]},{"entry":[{},"NUM_LANES));"]},{"entry":[{},"while (column_valid(column))"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kernel_state_load_history(foo);"]},{"entry":[{},"kernel_state_load_history(bar);"]},{"entry":[{},"for (line=line0; line<line1; line=line+NUM_LANES)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"strip_load( tmp_strip, src, line0);"]},{"entry":[{},"foo_function( foo, tmp_strip, tmp_strip);"]},{"entry":[{},"bar_function( bar, tmp_strip, tmp_strip);"]},{"entry":[{},"strip_store( tmp_strip, dst);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"kernel_state_store_history(foo);"]},{"entry":[{},"kernel_state_store_history(bar);"]},{"entry":[{},"strip_column_next(column);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"kernel_state_done(foo);"]},{"entry":[{},"kernel_state_done(bar);"]},{"entry":[{},"strip_free(tmp_strip);"]},{"entry":[{},"strip_free(kernel_state_get_history_strip(foo);"]},{"entry":[{},"strip_free(kernel_state_get_history_strip(bar);"]},{"entry":[{},"strip_column_free(column);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Branching of the kernel processing graph occurs when a kernel produces multiple output strips or the same output gets used by different kernels. Conversely, two or more branches of a processing graph are joined when they are used by the same kernel. For joins, vertical phase alignment must be considered.","Kernels usually have an additional input (offset) that allows additional vertical delay to be introduced so that the delays of parallel branches in processing graphs can be easily equalized. This offset is assigned a positive number less than or equal to some kernel dependent limit. For kernels using only one history stream, this limit is: N+1\u2212filter_height.  illustrates branching of output strips Y, U and V, at . Various delays may be employed, such as at ,  and , to equalize the delays resulting from the branching. In the example of , the equalized branches are then merged, at .","Kernels that input multiple source strips are usually written assuming that there is zero vertical phase difference between their inputs. Branch delay equalization, mentioned above, can be used to make this happen. In some cases, as an optimization, this delay equalization may be effectively accomplished in the joining kernel. If neither of these is possible, the addition of an explicit delay kernel may be required. A delay kernel is a very simple 1\u00d71 copy filter that maintains a history strip and has the offset input that can then be used to increase the delay from 0.","One of the two ways branching can occur involves using a strip by two or more kernels. If more than one of the kernels inputting the strip is a filter requiring context, they would each normally maintain a private history of the input. Since these private copies would be identical, all but one is redundant. To optimize this case, one of the kernels is designated as the master, and the other filters are replaced with slave versions of their kernel. These slaves are given the master's copy of the previous source as their prv_stm input. A slave kernel is identical to a master except that the input argument nxt_stm is missing and internally, the write to nxt_stm is not present. The only other requirement is that all the slaves are called before the master, which then updates the history strip.","Although, nominally, input and output strips are the same size, some operators may change the width. An x and y scaling operation changes the strip width. The strip height, however, is maintained at N by sometimes not producing an output strip (scaling down in y) or not requiring another input strip before producing the next output strip (scaling up in y).","Scaling is one of the more complex cases since most of the time, some amount of filtering is also involved. Sometimes the filtering is easily factored out. For instance, scaling down by 2 might involve filtering by a 3\u00d73 filter using one kernel and the selecting (nearest neighbor) every other pixel\/scan as the output with another. Both kernels would need history strips. The second kernel's history strip is needed so that there is enough source data (2N scan lines) to produce the N scan lines of one output strip. Although perhaps the most convenient, this approach would not be the most efficient since \u00beths of the 3\u00d73 filter's work is being thrown away by the 2kernel. A more efficient implementation might try to incorporate the x scaling this into the filter so that it only did the work for half the pixels in x. This would leave only the Y nearest neighbor 2:1 scaling to the second kernel. A further optimization might just do the entire filter scale operation in one kernel. This implementation would be the most efficient although two history strips would still be required.","Whether or not filtering is built into the scaling kernel, the following inner pipeline loop pseudo code shows how a generic enlarging or reducing scale kernel can be inserted in a set of chained kernels using this methodology. Since all kernels continue to operate on strips, the only change to the kernels after scaling will be to the strip width argument passed in. Exemplary pseudo code reads:",{"@attributes":{"id":"p-0084","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"foreach strip {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<first_segment_of_pipeline>"]},{"entry":[{},"scaled_strips = <compute_number_of_scaled_output_strips>"]},{"entry":[{},"do {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"scale(scaled_strips,...) \/\/ >0 output, <2=>update"]},{"entry":[{},"if (scaled_strips ==0) break;"]},{"entry":[{},"scaled_strips \u2212=1;"]},{"entry":[{},"<last_segment_of_pipeline>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The scale kernel takes an additional argument, scaled_strips, which is the number of output strips that the scale kernel will be able to produce given the source strip being passed in from the first_segment_of_pipeline. For reduction scaling, this may be zero. For enlargement, this may be greater than 1. Whatever additional vertical context the scale kernel needs is maintained by it when it updates its history strip(s). The scale kernel will produce a new output strip if scaled_strips is greater than zero. It will update its history strip(s) if scaled_strips is less than two. To allow for use of strip columns and incremental buffers, the scale kernel is restartable at sub pixel precision x and y offsets.","The disclosure above provides numerous examples to support the RPL method presented herein. In some embodiments, the constraints and methodical procedures presented in this discussion for kernel and pipeline implementations may be encoded into a computer program (i.e., compiler). For instance, a straightforward language may be employed for specifying the key parameters for each kernel and for specifying how kernels are sequenced in a processing graph. A compiler would take these and map them to a pipeline, or find the performance optimal grouping of the processing graph into one or more pipelines.","As described above, the image processing kernels generated using the method presented here result in a straightforward templatized implementation. This means that multiple kernels can be combined into a single kernel using a formulaic approach, and can even be encoded into a compiler. This could help reduce the invocation overhead inherent for a series of kernels that each only perform limited processing, such as point operations.","With regard to the description provided, some embodiments described herein may be implemented through use of programmatically implemented steps or sub-steps. As used herein, programmatically is intended to mean through the use of code, or computer-executable instructions. A programmatically performed step may or may not be automatic.","Still further, some embodiments described herein may be implemented using programmatic modules or components. A programmatic module or component may include a program, a subroutine, a portion of a program, or a software component or a hardware component capable of performing one or more stated tasks or functions. As used herein, a module or component can exist on a hardware component independently of other modules or components. Alternatively, a module or component can be a shared element or process of other modules, programs or machines.","Furthermore, one or more embodiments described herein may be implemented through the use of instructions that are executable by one or more processors. These instructions may be carried on a computer-readable medium. Machines shown or described with figures below provide examples of processing resources and computer-readable mediums on which instructions for implementing embodiments of the invention can be carried and\/or executed. In particular, the numerous machines shown with embodiments of the invention include processor(s) and various forms of memory for holding data and instructions. Examples of computer-readable mediums include permanent memory storage devices, such as hard drives on personal computers or servers. Other examples of computer storage mediums include portable storage units, such as CD or DVD units, flash memory (such as carried on many cell phones and personal digital assistants (PDAs)), and magnetic memory. Computers, terminals, network enabled devices (e.g. mobile devices such as cell phones) are all examples of machines and devices that utilize processors, memory, and instructions stored on computer-readable mediums. Additionally, embodiments may be implemented in the form of computer-programs, or a computer usable carrier medium capable of carrying such a program."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present disclosure are illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4","i":"a "},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4","FIG. 4"],"i":["b ","a"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
