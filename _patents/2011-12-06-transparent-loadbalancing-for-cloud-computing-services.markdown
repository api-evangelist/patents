---
title: Transparent load-balancing for cloud computing services
abstract: Systems and techniques are described for virtual machine (VM) load-balancing. A described technique includes running VMs that communicate via a virtual network, the VMs being configured to handle requests associated with at least a destination address on a public network and operating gateways that provide connectivity between the virtual network and the public network, and use a consistent mapping operation to perform load-balancing among the VMs. A gateway can obtain VM health information; determine based on the VM health information a group of healthy VMs; receive an incoming packet that includes a source address and the destination address; select a handling VM based on an output of the consistent mapping operation given the source address and the group of healthy VMs; forward the incoming packet to the handling VM via the virtual network; and create an entry to forward one or more additional incoming packets to the handling VM.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08958293&OS=08958293&RS=08958293
owner: Google Inc.
number: 08958293
owner_city: Mountain View
owner_country: US
publication_date: 20111206
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This patent document relates to operating virtual machines in a cloud computing service.","Cloud computing is network-based computing in which typically large collections of servers housed in data centers or \u201cserver farms\u201d provides computational resources and data storage as needed to remote end users. Some cloud computing services allow entities, such as e-retailers, banks with online portals, and universities, to run server software applications (e.g., e-commerce server application, web server, or file server) in the cloud. Running applications in the cloud can include running processes on virtual machines that are provided by cloud service providers. Data centers can use load-balancing to deal out incoming data among two or more machines. A type of load-balancing can be performed by using a special-purpose Open Systems Interconnection model (OSI model) layer-2 hardware device residing between an incoming network connection and a private local area network that forms a contiguous layer-2 network, where the local network includes two or more machines that are interconnected via the contiguous layer-2 network. For example, such a machine can employ an Address Resolution Protocol (ARP) scheme to maintain availability of a virtual Media Access Control (MAC) address on a contiguous layer-2 network that corresponds to a load-balanced network address.","In general, one aspect of the subject matter described in this document can be embodied in a technique that includes executing virtual machines that are each configured to communicate via a virtual network and are configured to handle requests associated with at least a destination address on a public network; and operating gateways, including a first gateway and a second gateway, that are configured to provide connectivity between the virtual network and the public network, the gateways being configured to use a consistent mapping operation to perform load-balancing among the virtual machines. The technique includes obtaining health information of the virtual machines; determining, based on the health information of the virtual machines, a group of healthy virtual machines comprising two or more of the virtual machines; receiving, at the first gateway, an incoming packet that includes a source address and the destination address; selecting, at the first gateway, a handling virtual machine of the group of healthy virtual machines based on an output of the consistent mapping operation given the source address, the destination address, and the group of healthy virtual machines; forwarding, at the first gateway, the incoming packet to the handling virtual machine via the virtual network; and creating, in a data structure at the first gateway, an entry reflecting a mapping between the source address and the handling virtual machine to forward one or more additional incoming packets, each including the source address and the destination address, to the handling virtual machine. Other embodiments of this aspect include corresponding systems, apparatus, and computer programs encoded on computer storage devices.","These and other aspects can optionally include one or more of the following features. The incoming packet can be a first incoming packet. Implementations can include receiving, at the second gateway, a second incoming packet that includes the same source address and the same destination address as the first incoming packet; selecting, at the second gateway, the handling virtual machine based on an output of the consistent mapping operation given the source address and the group of healthy virtual machines; forwarding the second incoming packet to the handling virtual machine via the virtual network; and creating, in a data structure at the second gateway, an entry reflecting a mapping between the source address and the handling virtual machine to forward one or more additional incoming packets to the handling virtual machine.","Obtaining the health information can include sending packets to check respective virtual machines and receiving one or more responses to the sent packets. Selecting the handling virtual machine can include generating a flow identifier based on the source address, the destination address, a source port of the incoming packet, and a destination port of the incoming packet. Selecting the handling virtual machine can include using the flow identifier as input to a hash function to produce a hash value; and selecting a virtual machine based on the hash value. Selecting the handling virtual machine can include using the source address, the destination address, a source port of the incoming packet, and a destination port of the incoming packet. Selecting the handling virtual machine can be further based on a geographical proximity of a virtual machine to a geographical location associated with an origin of the incoming packet.","Forwarding the incoming packet to the handling virtual machine can include sending the incoming packet to the handling virtual machine without changing the destination address. The virtual machines, including the handling virtual machine, can include a network interface that is configured to receive packets that are addressed to the destination address. Forwarding the incoming packet to the handling virtual machine can include performing a network address translation (NAT) on the incoming packet where the destination address of the incoming packet is replaced with a network address of the handling virtual machine, the network address being private to the virtual network. In some implementations, the virtual network is for IP based communications. Operating the gateways can include using separate IP tunnels to effect delivery of IP packets on the virtual network to the virtual machines.","Systems can include two or more host machines that are configured to execute virtual machines that communicate via a virtual network, the virtual machines being configured to handle requests associated with at least a destination address on a public network; and two or more gateways that provide connectivity between the virtual network and the public network, the gateways being configured to use a consistent mapping operation to perform load-balancing among the virtual machines. The two or more gateways can be configured to obtain health information of the virtual machines, determine, based on the health information of the virtual machines, a group of healthy virtual machines comprising two or more of the virtual machines, receive an incoming packet that includes a source address and the destination address, select a handling virtual machine of the group of healthy virtual machines based on an output of the consistent mapping operation given the source address, the destination address, and the group of healthy virtual machines, forward the incoming packet to the handling virtual machine via the virtual network, and create a data structure entry reflecting a mapping between the source address and the handling virtual machine to forward one or more additional incoming packets, each including the source address and the destination address, to the handling virtual machine.","Particular embodiments of the subject matter described in this document can be implemented so as to realize one or more of the following advantages. The application of load-balancing to a virtual network can be accomplished in ways which do not require synchronized state tables among gateways residing at a physical-to-virtual network boundary. Load-balancing a service resource among two or more virtual machines can increase the overall availability of the service resource. One or more described load-balancing techniques can be performed transparently based on one or more properties of the virtual network. One or more of the described load-balancing techniques can be implemented using virtual machines residing on separate layer-2 networks, and do not require a contiguous layer-2 network, broadcast mechanism, or native network support for load-balancing.","The details of one or more embodiments of the subject matter described in this document are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.","Like reference numbers and designations in the various drawings indicate like elements.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","110","112","114","102","104","100","140","110","112","114","100","102","104","140","110","112","114","140","140"]},"Clients  can send packets to a destination address associated with the public network . The packets can be User Datagram Protocol (UDP) based packets or Transmission Control Protocol (TCP) based packets. Other types of packets are possible. The clients , for example, can send a request in a packet to a web site such as \u201cwww.xyz.com\u201d using Hypertext Transfer Protocol (HTTP). The network address associated with \u201cwww.xyz.com\u201d can be load-balanced between virtual machines , ,  interconnected via the virtual network . The load for a web site can be distributed among multiple virtual machines such as hundred virtual machines, a thousand virtual machines, or more.","Load balancers ,  can be configured to control virtual network gateways ,  to distribute traffic from clients  among the virtual machines , , . In this example, virtual network gateways ,  route traffic between virtual machines , ,  and the public network  via the virtual network . In some implementations, the gateways ,  include their corresponding load balancers , . In some implementations, servicing a connection from a client  can require the use of state information, and therefore the load balancers ,  can cause the virtual network gateways ,  to consistently route IP traffic from the same client to the same virtual machine. However, based on a failure of a virtual machine, a load balancer can selected a new virtual machine for servicing requests from a specific client .","In some implementations, virtual network gateways ,  are configurable to selectively load-balance traffic based on parameters set via an application programming interface (API). For example, a cloud service customer can use the API to select a load-balancing option for one or more network addresses. In some implementations, the load-balancing option can be applied to one or more ports such as a TCP port or UDP port.","IP traffic on the virtual network  can be carried by IP tunnels. Machines such as host machines ,  and virtual network gateways ,  can perform IP encapsulation and de-encapsulation for IP traffic to and from each VM , , . Encapsulated IP traffic from one VM is sent to another VM via IP tunneling. An IP tunnel provides a transport layer. For example, IP tunneling can include sending an IP tunnel packet that includes an encapsulated packet. The encapsulated packet can be an IP packet. Other types of encapsulated packets are possible. In some cases, an IP tunnel can originate at a virtual network gateway and terminate at a host machine. In some cases, an IP tunnel can both originate and terminate on the same host machine (e.g., source and destination VMs are on the same host machine). In some cases, an IP tunnel can originate at one host machine and terminate at a different host machine (e.g., source and destination VMs are on different host machines). IP tunnel traffic between machines residing on separate layer-2 networks can be carried over a virtual private network (VPN) via a public network  such as the Internet.","Host machines ,  can use a virtual network routing table to retrieve the endpoint locations of the IP tunnels. In some implementations, based on an input VM identifier or VM IP address, a virtual network routing table provides a routable IP address on network  that corresponds to the host machine that runs the VM associated with the input VM identifier or VM IP address. In some implementations, the host machines ,  can run multiple virtual networks. For example, two virtual machines can be on the same physical machine, but attached to different virtual networks. Furthermore, a virtual machine can have one or more virtual network interface cards (NICs) that are attached to one or more virtual networks. Each virtual network interface can be assigned a network address (e.g., IPv4 address, IPv6 address, or a layer-2 MAC address). In some implementations, a virtual machine stores virtual network addresses and their associated network identifiers.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2","b":["102","104","201","102","104","102","104","216","102","104","250","220","221","216","250"]},"The private network  can include one or more wired (e.g., Ethernet) or wireless (e.g., WI-FI) networks, for example. In some implementations, the private network  includes physical communication assets such as optical fiber or copper wire that connect two data centers. In some implementations, the private network  is implemented over a public network such as the Internet . In some implementations, data centers have respective local area networks (LANs) that are aggregated together to form a private network . IP traffic between data centers can be routed, for example, by using Multiprotocol Label Switching (MPLS). Other types of routing are possible.","Each host machine ,  executes a host operating system , . A host operating system ,  manages host machine resources. In this example, host operating systems ,  run software that virtualizes the underlying host machine hardware and manages concurrent execution of one or more VMs. For example, the host operating system  manages two VMs (VM  and VM ), while a different host operating system  manages a single VM . A host machine can, in general, manage larger quantities of virtual machines; however, the quantity may be limited based on physical resources of the host machine.","The VMs , ,  use a simulated version of an underlying host machine hardware, which can be referred to as virtual hardware (e.g., virtual hardware , and ). Software that is executed by the virtual hardware can be referred to as guest software. In some implementations, guest software cannot determine if it is being executed by virtual hardware or by a physical host machine. If guest software executing in a VM, or the VM itself, malfunctions or aborts, other VMs executing on the host machine will not be affected. A host machine's microprocessor(s) can include processor-level mechanisms to enable virtual hardware to execute software applications efficiently by allowing guest software instructions to be executed directly on the host machine's microprocessor without requiring code-rewriting, recompilation, or instruction emulation.","Each VM (e.g., VMs , , and ) is allocated a set of virtual memory pages from the virtual memory of the underlying host operating system and is allocated virtual disk blocks from one or more virtual disk drives for use by the guest software executing on the VM. For example, host operating  allocates memory pages and disk blocks to VM  and VM , and host operating system  does the same for VM . In some implementations, a given VM cannot access the virtual memory pages assigned to other VMs. For example, VM  cannot access memory pages that have been assigned to VM . A virtual disk drive can be persistent across VM restarts. In some implementations, virtual disk blocks are allocated on physical disk drives coupled to host machines. VMs can be allocated network addresses through which their respective processes can communicate with other processes via a virtual network. For example, guest software executing on VM  can communicate with guest software executing on VM  or VM  via the virtual network using the allocated network addresses.","A VM's guest software can include a guest operating system (e.g., guest operating systems , , and ) which is software that controls the execution of respective guest software applications (e.g., guest applications , , and ), within the VM and provides services to those applications. For example, a guest operating system can be an operating system such as a variant of the UNIX operating system. Other operating systems are possible. Each VM can execute the same guest operating system or different guest operating systems. Booting a VM can include using a virtual boot disk to load a kernel image associated with a guest operating system into memory. A guest operating system's access to resources such as networks and virtual disk storage is controlled by the underlying host operating system.","By way of illustration, and with reference to virtual machine , when the guest application or guest operating system attempts to perform an input\/output operation on a virtual disk, initiate network communication, or perform a privileged operation, for example, the virtual hardware is interrupted so that the host operating system  can perform the action on behalf of the virtual machine . The host operating system  can perform these actions with a process that executes in kernel process space , user process space , or both.","The kernel process space is virtual memory reserved for the host operating system 's kernel which can include kernel extensions and device drivers, for instance. The kernel process space has elevated privileges (sometimes referred to as \u201csupervisor mode\u201d); that is, the kernel can perform certain privileged operations that are off limits to processes running in the user process space . Examples of privileged operations include access to different address spaces, access to special functional processor units in the host machine such as memory management units, and so on. The user process space is a separate portion of virtual memory reserved for user mode processes. User mode processes cannot perform privileged operations directly.","In various implementations, a portion of VM network communication functionality is implemented in a communication process (e.g., communication process ). In some implementations, the communication process executes in the user process space (e.g., user process space ) of a host operating system (e.g., host operating system ). In other implementations, the communication process can execute in the kernel process space (e.g., kernel process space ) of the host operating system. There can be a single communication process for all VMs executing on a host machine or multiple communication processes, one for each VM executing on a host machine. In yet further implementations, some portion of the communication process executes in the user process space and another portion executes in the kernel process space. In some implementations, the communication process can use a hardware level encapsulation mechanism.","A communication process , can communicate with a VM registry service  to establish a virtual network pair (VNP) between two VMs. In a virtual network, a VNP can be used to route traffic between two endpoints using one or more virtual connections or links. Network traffic associated with the VNP can be carried via a local loop (e.g., if both VMs are on the same host machine) or carried via one or more networks, such as a private network , Internet , or a combination thereof. For example, a VNP between a first virtual machine  and a second virtual machine  can be used to route packets sent between VNP endpoints managed respectively by first and second communication processes , over the private network . In some implementations, a server such as a VM registry server  implements the functionality of the VM registry service. The VM registry service  can manage assignments of network addresses (e.g., IP addresses) to VMs, and maintain mappings between VM network addresses on a virtual network and the respective network addresses of the host machines running the VMs.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3","b":["315","315","320","320","320","320","315","315","330","330","330","320","320","340","340","340","350","320"],"i":["a","b","a","b","c","d","a","b ","a","b","c ","a","d ","a","d ","a","b","a","b ","a","d. "]},"The host machines , can connect to the Internet  via respective local area networks (LANs) , . In some implementations, host machines -are assigned IP addresses (e.g., ..., ...) that are visible on the Internet . Traffic on an inter-host-machine IP tunnel (e.g., IP tunnel packets) can be routed from the host machine  on a first LAN to a host machine on a second LAN via the Internet  (tunnel carries traffic between VM-1 and VM-13 ). Traffic on an intra-host-machine IP tunnel can be routed completely inside a host machine ","Virtual network gateways -can route traffic between the Internet  and the virtual network  by changing source or destination address information in packet headers so that the address space of the virtual network  is hidden behind an IP address of a gateway -. In particular, packets arriving at the gateways -from the Internet  and bound for the virtual network  have their IP datagram destination address changed from that of the gateway -(e.g., 134.130.78.1, or 224.10.402.1) to the IP address of a destination VM (e.g., 192.138.1.10). Packets arriving at a gateway -from the virtual network  and bound for the Internet  have their IP source address changed from that of a VM (e.g., 192.138.1.10) to the IP address of the virtual network gateway -that is visible on the Internet  (e.g., 134.130.78.1, 224.10.402.1). Based on the virtual network  using a private subnet, the virtual network gateways -can perform network address translation (NAT) to translate between private subnet addresses and public addresses.","Virtual machines -running on the host machines -can run processes such as webserver processes that interact with browser software running on clients , , . A client -can be a data processing apparatus such as, for example, a server, a personal computer, a laptop computer, a smart phone, an embedded device (e.g., a smart power meter), or a tablet computer. In this example, client communicates with a VM (e.g., VM-21 ) by sending IP packets to a virtual network gateway . In turn, the virtual network gateway encapsulates the packets from the client and sends the encapsulated packets to the host machine running VM-21 via an IP tunnel . The host machine running VM-21 can de-encapsulate the packets and deliver the packets to VM-21 ","Communication processes can use keys to protect IP traffic to and from VMs. In some implementations, before a VM can send packets to or receive packets from other VMs or a gateway, a network agent for a VM retrieves a secret key that corresponds to the VM. In some implementations, a network agent is included in a communication process executing on the VM's host machine. A secret key is a piece of information that serves to uniquely identify a VM among all VMs associated with a virtual network (e.g., the virtual network  of ). The secret key can be a number, a string of characters, other data, combinations of these, or any other string of bits of sufficient entropy. The secret key can be generated in such a way that an entity with no prior knowledge of the key has no computationally feasible way of deriving the key. The secret key can be generated using, for example, a cryptographically secure pseudorandom number generator. In some implementations, the secret key is assigned to a VM by a VM registry service. Secret keys can also be assigned by another process besides the VM registry service. A given VM may not know what its secret key is and does not know the secret key of other VMs. In some implementations, a communication process (e.g., communication process ) on a given host machine (e.g., host machine ) keeps track of the secret keys for VMs managed by the host operating system (e.g. host operating system ).",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 4","b":["404","404","402","402","406","412","406","406","404"]},"The VM registry service  responds to the COM-A process  with a message  containing the secret key for VM-A. As a further example, the communication process  (COM-B process ) on VM-B 's host machine can request a secret key for VM-B  from the VM registry service  by sending a message  to the VM registry service . Based on receiving a message from the COM-B process , the VM registry service  responds with a message  containing the secret key for VM-B .","Before an initial packet from one VM to another is transmitted, a VNP between the two VMs is established. In some implementations, the communication process on a given host machine is responsible for establishing VNPs. Each VM can communicate with one or more other VMs using a separate VNP for each. VM-A  initiates a transmission of a packet  to VM-B . The packet can include one or more headers such as an IPv4 header, IPv6 header, UDP header, or a TCP header. The packet is intercepted by the COM-A process  of the host operating system on which VM-A  is executing. The COM-A process  determines that a VNP between VM-A  and VM-B  has not yet been established. This being the case, the COM-A process  requests a token to be used to communicate with VM-B  from the VM registry service . A token is required in order to establish a unidirectional VNP from a source VM to a destination VM. The token request  can contain the secret key for VM-A  and a network address of the destination VM-B , for example.","In response to the request , the VM registry service  uses the secret key S_a of VM-A  to look up or determine the following attributes of VM-A : IP_VM_a, the IP address assigned to VM-A; Phys_Port_a, the UDP port assigned to VM-A on VM-A's host machine; Phys_IP_a, the IP address of VM-A's host machine; and expiry_a_b, the validity period of the token which, in some implementations, is the current time plus a time-to-live (TTL). The TTL can be on the order of minutes (e.g., 10 minutes) or other granularities. In some implementations, expiry_a_b is set to a value (e.g., \u22121) to indicate that the token never expires. In some implementations, the concatenation of Phys_Port_a and Phys_IP_a can be considered as a VM host address.","In some implementations, the VM registry service  verifies that the request  was actually transmitted from Phys_IP_a and otherwise denies the request. In further implementations, the VM registry service  can consult a traffic policy to determine if VM-A  should be allowed to communicated with VM-B  and, if not, denies the request.","In various implementations, the VM registry service  computes the token T_a_b for traffic from VM-A  to VM-B  as follows (step ): T_a_b=TruncMAC (S_b, Phys_IP_a|Phys_IP_b|Phys_Port_a|Phys_Port_b|IP_VM_a|IP_VM_b|expiry_a_b), where \u2018|\u2019 denotes concatenation, S_b is VM-B 's secret key, and TruncMAC is a Message Authentication Code (MAC) function (e.g., a function based on HMAC-SHA1) that has been truncated, for example, to 64 bits. Other MAC functions are possible. In some implementations, all of the fields being concatenated are fixed size, i.e., the concatenation is uniquely determined without the need for separators. Although the fields are concatenated in a certain order, other field orderings are possible. In some implementations, the concatenation of Phys_Port_b and Phys_IP_b can be considered as a VM host address.","In some implementations, a secret key ties a host machine addressing scheme (e.g., <Phys_IP, Phys_Port>) to a VNP addressing scheme (e.g., IP address of VM on a virtual network). In some implementations, a secret key ties a host machine addressing scheme (e.g., <Phys_IP, Phys_Port>) to a memory region associated with a VM via remote direct memory access (RDMA).","The VM registry service  returns the tuple (Phys_IP_b, Phys_Port_b, T_a_b, expiry_a_b) to COM-A process  in a response  to the request , where Phys_IP_b is the IP address of the host machine on which VM-B  is executing and Phys_Port_b is the UDP port on VM-B's host machine that has been reserved for receiving traffic directed to VM-B . Once the COM-A process  receives the tuple, the packet  can be encapsulated, at .","At , the encapsulated packet is transmitted to VM-B's host machine using the Phys_IP_b and Phys_Port_b as the destination address of the packet. Future packets destined for VM-B  can reuse the tuple information until expiry_a_b has passed. Once the expiry_a_b has passed (if it is not set to a value indicating that the token never expires), a new token can be obtained as described above, for example. For VM-B  to send packet to VM-A , a token can be used to establish a unidirectional VNP from VM-B  to VM-A . The same process can be followed as outlined above or, alternatively, a packet sent from VM-A to VM-B can include the token.","The encapsulated packet is received by the destination host machine for VM-B  where it is intercepted by the COM-B process . At , the COM-B process  de-encapsulates the packet and verifies it based on VM-B's secret key. At , the COM-B process  sends the de-encapsulated packet to VM-B . This can be done by injecting the IP packet into the network stack as an Ethernet frame, for example.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 5","b":["502","502","502","504"],"i":["e ","e ","c"]},"The UDP packet  contains a header that includes a source port number (16 bits), a destination port number (16 bits), a length field (16 bits) which is the length of the data portion , and a checksum (16 bits). In various implementations, the source port is set to Phys_Port_a and the destination port is set to Phys_Port_b. The data portion is variable length and contains the outgoing packet. In some implementations, the data portion can be encrypted. Symmetric or asymmetric encryption key algorithms can be used to encrypt some or all of the data portion , for example. The encryption keys can be distributed by a VM registry service, e.g., VM registry service  of . In some implementations, a conventional key negotiation protocol, e.g., the Diffie-Hellman protocol, can be used in an encryption of the data portion ","The UDP packet's data portion contains a VNP packet . A VNP packet  can include the token T_a_b (64 bits), the expiry time expiry_a_b (32 bits), the outgoing packet (variable length), and an optional options field (variable length). Other lengths for the VNP packet fields are possible. In addition, the fields of the VNP packet  can occur in a different order than that which is illustrated in . In some implementations, the outgoing packet is an IP packet. Other outgoing packet types are possible including, for example, Ethernet packets. Once encapsulation is complete, the communication process or another process on the respective host machine's operating system can transmit the UDP packet  in an IP packet with a source IP address of Phys_IP_a and a destination IP address of Phys_IP_b. Alternatively, the encapsulated packet can be transmitted using a different protocol.","In some implementations, the VNP packet  includes an options field . The options field allows a sending VM to convey additional information to a receiving VM. If the encapsulated packet is a UDP packet, as illustrated in , the length of the options field can be calculated based on the difference of the value specified in the length field and the combined size of the token , expiry , and encapsulated IP packet fields. The size of the encapsulated IP packet is available in the header of the packet . The options field can be omitted from the VNP packet  if its inclusion would push the size of the encapsulated packet (e.g., UDP packet ) above the maximum transmission unit (MTU) which would result in packet fragmentation. In further implementations a field such as a bit flag, for example, can be added to the VNP packet  to indicate the presence of an options field ","The options field can be used to send a return VNP token T_b_a to the receiving VM in order to avoid the receiving VM having to obtain a token in order to reply to the sending VM. The COM-A process  for VM-A  has all information on hand that is needed to compute T_b_a; in particular, the token is signed with VM-A 's secret key S_a. The return token T_b_a can likely be included in the first packet sent between VM-A  and VM-B  since, in the case of TCP, the first packet is a small SYN packet which leaves sufficient room for the options field containing the return token without the resulting encapsulated packet exceeding MTU. The options field can also be used to send various protocol extensions, to exchange encryption keys, to send control flow information, and so on.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 6","b":["600","408","600","218","602"]},"If expiry_a_b is less than the current time minus a skew (step ), the encapsulated packet is discarded (step ). In some implementations, the skew is an estimate of likely clock skew between host machine clocks (e.g., a few seconds). The skew can be set to zero if host machine clocks are synchronized. Otherwise, if expiry_a_b is greater than the current time plus skew and TTL (step ), the encapsulated packet is also discarded (step ). A check is performed to verify whether the host operating system is hosting a VM having the address VM_IP_b (step ). If not, the encapsulated packet is discarded (step ). The extracted fields and VM-B 's secret key S_b are used to calculate T_a_b actual as follows (step ): T_a_b_actual=TruncMAC(S_b, Phys_IP_a|Phys_IP_b|Phys_Port_a|Phys_Port_b|IP_VM_a|IP_VM_b|expiry_a_b).","T_a_b actual is then compared to the token T_a_b from the encapsulated packet (step ). If T_a_b actual is the same as T_a_b then the encapsulated packet (e.g., encapsulated IP packet ) is extracted from the encapsulated packet (e.g., encapsulated packet ) and is delivered to VM-B  (step ). Otherwise, the encapsulated packet is discarded (step ).","A gateway (e.g., gateway , ) can serve as an encapsulation gateway to allow virtual machines on a virtual network to communicate with endpoints on a public network such as the Internet. A host machine can send encapsulated packets to the gateway. When the gateway receives encapsulated packet from a VM destined for the public network, the gateway can validate the token of the VNP packet. If the token validation fails, the packet is discarded. If validation succeeds, the encapsulated packet is de-encapsulated and the encapsulated packet is extracted and injected into the gateway's network stack where it is subject to normal routing.","Upon receiving, from the public network, a non-encapsulated packet destined for a VM, the gateway obtains a token for the destination of the packet and then encapsulates the packet. In some implementations, obtaining a token can include communicating with a VM registry service. In some implementations, obtaining a token can include retrieving a token from a local cache of tokens. The gateway ,  then transmits the encapsulated packet to the destination VM's host machine.","If a communication process associated with a VM queries a VM registry service for a token that is for a destination computer that is not on the virtual network, the VM registry service responds with a tuple (Phys_IP_b, Phys_Port_b, T_a_b, expiry_a_b) where Phys_IP_b, Phys_Port_b and Tab are for the gateway, rather than the ultimate destination, so that the VM's packets are routed through, and de-encapsulated by, the gateway. In some implementations, the VM can use this tuple to send packets to any destination on a public network thus avoiding having to obtain a tuple from the VM registry service for each unique destination.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 7","b":["705","710"]},"At , the process obtains health information of the virtual machines. Obtain health information for a virtual machine can include pinging a virtual machine or sending an application request (e.g., requesting the homepage of a webserver or requesting a file) to a virtual machine. Obtaining the health information can include sending packets to check respective virtual machines and receiving one or more responses to the sent packets. Receiving a response from a virtual machine in a predetermined amount of time (e.g., 1 second, 2 second, or 10 seconds) signifies that the virtual machine is healthy. The process can routinely update virtual machine health information by scheduling periodic pings to the virtual machine (e.g., once every 10 seconds, 30 seconds, or 60 seconds). For example, obtaining the health information can include periodically sending packets at predetermined intervals to check respective virtual machines and receiving one or more responses to the sent packets. At , the process determines, based on the health information of the virtual machines, a group of healthy virtual machines.","At , the process receives, at the first gateway, an incoming packet that includes a source address and the destination address. At , the process selects, at the first gateway, a handling virtual machine based on an output of the consistent mapping operation given the source address, the destination address, and the group of healthy virtual machines. Selecting the handling virtual machine can include generating a flow identifier based on the source address, the destination address, a source port of the incoming packet, and a destination port of the incoming packet. Selecting the handling virtual machine can include using the flow identifier as input to a hash function to produce a hash value; and selecting a virtual machine based on the hash value.","Selecting the handling virtual machine, at , can be further based on a geographical proximity of a virtual machine to a geographical location associated with an origin of the incoming packet. In some implementations, the group of healthy virtual machines used in selecting the handling virtual machine is limited to a subgroup of healthy virtual machines that are geographically closest to the origin of the incoming packet. For example, if there are two healthy virtual machines in Atlanta and two healthy virtual machines in Nevada, a request which is received by a gateway located in New York may prefer to choose the pool of two Atlanta machines rather than the entire pool of four machines in order to improve response time for the request. This decision can be made on a global or per-virtual-address basis.","At , the process forwards, at the first gateway, the incoming packet to the handling virtual machine via the virtual network. In some implementations, forwarding the incoming packet to the handling virtual machine includes sending the incoming packet to the handling virtual machine without changing the destination address. The virtual machines, including the handling virtual machine, can include a network interface that is configured to receive packets that are addressed to the destination address. In some implementations, forwarding the incoming packet to the handling virtual machine includes performing a NAT operation on the incoming packet where the destination address of the incoming packet is replaced with a network address of the handling virtual machine, the network address being private to the virtual network.","At , the process creates, in a data structure at the first gateway, an entry reflecting a mapping between the source address and the handling virtual machine to forward one or more additional incoming packets to the handling virtual machine. The entry can be indexed by the hash value of a flow identifier that is determined by an incoming packet. The entry can also include a network address of the handling virtual machine. In some implementations, the entry can include the flow identifier.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 8","b":["800","3"]},"At , the process computes a hash value based on the packet's flow identifier. For example, a hash function (e.g., MD5 Message-Digest Algorithm or a SHA-2 hash function) maps a packet's flow identifier to a hash value. At , the process looks up the flow in a state table based on the hash value. In some implementations, an entry located in a position corresponding to the hash value is retrieved at  to determine whether the entry contains the packet's flow identifier.","At , the process determines whether the flow is in the state table. In some implementations, determining whether the flow is in the state table includes checking whether an entry contains the packet's flow identifier. If the entry containing the packet's flow identifier, then the flow is deemed to be in the state table. Based on the flow being in the state table, then, at , the process retrieves a virtual machine identifier included in the state table entry. At , the process sends the received packet to the virtual machine corresponding to the virtual machine identifier.","Based on the flow not being in the state table, then the process, at , determines a pool of healthy virtual machines. At , the process selects a virtual machine from the pool of healthy virtual machines via a consistent hash. At , the process creates a state table entry based on the hash value and an identifier for the selected virtual machine. In some implementations, the state table entry includes an identifier for the selected virtual machine. In some implementations, the state table entry includes the packet's flow identifier. In some implementations, the state table entry includes the hash value. At , the process sends the received packet to the selected virtual machine.","A gateway can use consistent hashing to compute a backend array for a pool of healthy virtual machines. In some implementations, the backend array can be recomputed based on a change in the number of healthy virtual machines. A technique for computing a backend array can include allocating an array of size Z, where 0<Z. The technique can include, for each virtual machine in a pool, computing an initial position P(where 0\u2266P<Z) by hashing an identifier K of a virtual machine and marking the slot at position Pusable for load-balancing if the virtual machine is healthy, where P=K % Z. Given a step size S (where 0<S<Z) and P, the technique can mark additional slots as usable for load-balancing. In some implementations, the technique marks the slots corresponding to positions based on the expression P=(P+S) % Z for i=0 to N. Marked slots can include an IP address of the virtual machine associated with identifier K and a usability indicator.","For a flow identifier H, a gateway can select a virtual machine identified by position Y in a backend array based on a hash function F, where X=F(H) and Y\u2267X. In some implementations, F(H)=(H % Z), where Z is the size of the backend array. Other types of hash functions can be used. In some cases, position Y is position X if the entry at position X has an entry that is marked as usable. If position X does not have an entry that is marked as usable, the gateway can iteratively step through higher ranked positions in the backend array until it locates a position Y with an entry that is marked as usable.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 9A","b":["905","905","905","915","910","910","910","910","930"],"i":["a ","b ","c ","a","b ","a","b "]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 9B","FIG. 9A","FIG. 9B"],"b":["910","950","905","950","950","950","950"],"i":["a","b ","a","c"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 9C","FIG. 9A","FIG. 9C"],"b":["960","910","960","905"],"i":["a ","a","c. "]},"A packet , such as a TCP SYN packet or a UDP packet, from the client  arrives at the gateway . The packet  has a source address port pair of 204.178.23.10:45128 and a destination address port pair of 123.24.99.230:80. The gateway can compute a hash value based on a flow identifier derived from the packet . In this example, the flow identifier is a concatenation of source address 204.178.23.10, source port , destination address 123.24.99.230, and destination port . This flow identifier hashes to a hash value, for example, of 1923. Based on VM-A and VM-B being healthy and VM-C being not healthy, only hash values for VM-A and VM-B are available. Therefore, the next-higher value is 2111, which indicates that the packet  should be sent to VM-B. An entry is created in the local state table  at the gateway such that packets having the same flow identifier are forwarded to the same gateway, which in this case is VM-B. The local state table  at the gateway is not required to be propagated to other gateways.","Based on making a routing decision using the local state table , the gateway sends the packet  unchanged to VM-B. Note that the gateway can encapsulate the packet  for transport within a virtual network. In some implementations, the gateway performs a NAT operation on the packet  and changes its destination address of 123.24.99.230 to 10.4.5.6, where 10.4.5.6 is the private address for VM-B on the virtual network. If the gateway is configured to perform NAT, it translates packets from the virtual machine with source address and port of 10.4.5.6:80 so that the source address and port becomes 123.24.99.230:80.","In response to the packet , VM-B can send a response packet, such as a SYN\/ACK packet, which is then received by the gateway (with source address and port of 123.24.99.230:80 and destination address and port of 204.178.23.10:45128), and is sent outbound to the client . In response, the client  sends the return ACK packet (with source address and port of 204.178.23.10:45128 and destination address and port of 123.24.99.230:80) which completes a TCP handshake. If the return ACK packet arrives at the same gateway that handled the original SYN packet , the flow identifier corresponding to the return ACK packet (which is the same as the original SYN packet ) will be found in the local state table  and will be accordingly forwarded to VM-B.","In some cases, a subsequent packet in a flow (such as a return ACK packet) may arrive at a different secondary gateway due to an event such as the primary gateway crashing or a route flap. For example, in a scenario where a gateway crashes and all health information remains the same for a brief period of time (e.g. less than one second) at the remaining gateway(s) , the remaining gateway may have the same health information as the crashed gateway and performs a consistent hashing operation. The secondary gateway use its consistent hash table  to perform a lookup based on the received packet to determine the handling virtual machine. In this example, given the same health state of the virtual machines -, the lookup yields a value of 1923 and the next-higher value of 2111\u2014the same values that the crashed gateway would have computed. If the gateways -have different health states for the virtual machines -, the probability that the same backend will be chosen by a different gateway is 1\u2212(A\/B), where A is the number of virtual machines whose health status has changed, and B is the number of healthy virtual machines in the system.","In an example scenario, where all gateways are operational and VM-C becomes healthy, the return ACK packet is received by the same gateway that saw the initial SYN packet . This gateway finds a match for the ACK packet in its local state table  indicating that VM-B is handling, and sends the packet to VM-B. If the gateway would have not found a match in its local state table , the consistent hash operation would have selected VM-C (based on the ACK packet's hash value of 1923, the next-higher value is now 2044 which maps the packet to VM-C).","A computer storage device can be encoded with a computer program. The program can include instructions that when executed by data processing apparatus cause the data processing apparatus to perform operations. The operations can include obtaining health information of virtual machines that communicate via a virtual network, the virtual machines being configured to handle requests associated with at least a destination address on a public network; determining, based on the health information of the virtual machines, a group of healthy virtual machines comprising two or more of the virtual machines; receiving, from the public network, an incoming packet that includes a source address and the destination address; selecting a handling virtual machine of the group of healthy virtual machines based on an output of a consistent mapping operation given the source address, the destination address, and the group of healthy virtual machines, the consistent mapping operation being configured for load-balancing among the virtual machines; forwarding the incoming packet to the handling virtual machine via the virtual network; and creating a data structure entry that reflects a mapping between the source address and the handling virtual machine to forward one or more additional incoming packets, each including the source address and the destination address, to the handling virtual machine.","Embodiments of the subject matter and the operations described in this document can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this document and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this document can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).","The operations described in this document can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.","The term \u201cdata processing apparatus\u201d encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.","A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.","The processes and logic flows described in this document can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.","To provide for interaction with a user, embodiments of the subject matter described in this document can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.","Embodiments of the subject matter described in this document can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this document, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received from the client device at the server.","While this document contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this document in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.","Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.","Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 9B","FIG. 9A"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 9C","FIG. 9A"]}]},"DETDESC":[{},{}]}
