---
title: Automatic memory management
abstract: The present invention optimizes graphics performance during zone rendering by providing an automatic management of bin memory between the binning and rendering phases. Embodiments of the present invention provide a mechanism by which the binner and renderer automatically share a pool of physical memory pages in order to build bin buffers and recycle them after they have been used in rendering. This is performed in such a fashion that multiple binned scenes can be queued up concurrently, with no requirement for software intervention except under exceptional conditions. The need for software management of zone rendering bin buffer memory is thus eliminated. Multiple scenes for binning and rendering can also be queued without software intervention.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06995773&OS=06995773&RS=06995773
owner: Intel Corporation
number: 06995773
owner_city: Santa Clara
owner_country: US
publication_date: 20040603
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation of Ser. No. 10\/038,921, filed on Dec. 31, 2001, now U.S. Pat. No. 6,747,658, entitled \u201cAutomatic Memory Management for Zone Rendering.\u201d","1. Field","The present invention relates generally to graphics systems and more particularly to graphics rendering systems.","2. Background Information","Computer graphics systems are commonly used for displaying graphical representations of objects on a two-dimensional video display screen. Current computer graphics systems provide highly detailed representations and are used in a variety of applications. In typical computer graphics systems, an object to be represented on the display screen is broken down into graphics primitives. Primitives are basic components of a graphics display and may include points, lines, vectors and polygons, such as triangles and quadrilaterals. Typically, a hardware\/software scheme is implemented to render or draw the graphics primitives that represent a view of one or more objects being represented on the display screen.","The primitives of the three-dimensional objects to be rendered are defined by a host computer in terms of primitive data. For example, when the primitive is a triangle, the host computer may define the primitive in terms of X, Y and Z coordinates of its vertices, as well as the red, green and blue (R, G and B) color values of each vertex. Additional primitive data may be used in specific applications.","Image rendering is the conversion of a high-level object-based description into a graphical image for display on some display device. For example, an act of image rendering occurs during the conversion of a mathematical model of a three-dimensional object or scene into a bitmap image. Another example of image rendering is converting an HTML document into an image for display on a computer monitor. Typically, a hardware device referred to as a graphics-rendering engine performs these graphics processing tasks. Graphics-rendering engines typically render scenes into a buffer that is subsequently output to the graphical output device, but it is possible for some rendering-engines to write their two-dimensional output directly to the output device. The graphics-rendering engine interpolates the primitive data to compute the display screen pixels that represent the each primitive, and the R, G and B color values of each pixel.","A graphics-rendering system (or subsystem), as used herein, refers to all of the levels of processing between an application program and a graphical output device. A graphics engine can provide for one or more modes of rendering, including zone rendering. Zone rendering attempts to increase overall 3D rendering performance by gaining optimal render cache utilization, thereby reducing pixel color and depth memory read\/write bottlenecks. In zone rendering, a screen is subdivided into an array of zones and per-zone instruction bins, used to hold all of the primitive and state setting instructions required to render each sub-image, are generated. Whenever a primitive intersects (or possibly intersects) a zone, that primitive instruction is placed in the bin for that zone. Some primitives will intersect more than one zone, in which case the primitive instruction is replicated in the corresponding bins. This process is continued until the entire scene is sorted into the bins. Following the first pass of building a bin for each zone intersected by a primitive, a second zone-by-zone rendering pass is performed. In particular, the bins for all the zones are rendered to generate the final image.","Conventional zone rendering systems are inefficient in that they require extensive software intervention and\/or management for numerous functions, including but not limited to, bin memory functions and queuing of multiple scenes for binning and rendering.","What is needed therefore is a method, apparatus and system for automatic management of bin memory between the binning and rendering phases.","The present invention optimizes graphics performance during tile based rendering such as zone rendering by providing an automatic management of bin memory between the binning and rendering phases. Embodiments of the present invention provide a mechanism by which the binner and renderer automatically share a pool of physical memory pages in order to build bin buffers and recycle them after they have been used in rendering. This is performed in such a fashion that multiple binned scenes can be queued up concurrently, with no requirement for software intervention except under exceptional conditions. The need for software management of zone rendering bin buffer memory is thus substantially minimized. These characteristics enhance system performance.","In the detailed description, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be understood by those skilled in the art that the present invention maybe practiced without these specific details. In other instances, well-known methods, procedures, components and circuits have been described in detail so as not to obscure the present invention.","Some portions of the detailed description that follow are presented in terms of algorithms and symbolic representations of operations on data bits or binary signals within a computer. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to convey the substance of their work to others skilled in the art. An algorithm is here, and generally, considered to be a self-consistent sequence of steps leading to a desired result. The steps include physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers or the like. It should be understood, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the specification, discussions utilizing such terms as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or the like, refer to the action and processes of a computer or computing system, or similar electronic computing device, that manipulate and transform data represented as physical (electronic) quantities within the computing system's registers and\/or memories into other data similarly represented as physical quantities within the computing system's memories, registers or other such information storage, transmission or display devices.","Embodiments of the present invention may be implemented in hardware or software, or a combination of both. However, embodiments of the invention may be implemented as computer programs executing on programmable systems comprising at least one processor, a data storage system (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. Program code may be applied to input data to perform the functions described herein and generate output information. The output information may be applied to one or more output devices, in known fashion. For purposes of this application, a processing system includes any system that has a processor, such as, for example, a digital signal processor (DSP), a microcontroller, an application specific integrated circuit (ASIC), or a microprocessor.","The programs may be implemented in a high level procedural or object oriented programming language to communicate with a processing system. The programs may also be implemented in assembly or machine language, if desired. In fact, the invention is not limited in scope to any particular programming language. In any case, the language may be a compiled or interpreted language.","The programs may be stored on a storage media or device (e.g., hard disk drive, floppy disk drive, read only memory (ROM), CD-ROM device, flash memory device, digital versatile disk (DVD), or other storage device) readable by a general or special purpose programmable processing system, for configuring and operating the processing system when the storage media or device is read by the processing system to perform the procedures described herein. Embodiments of the invention may also be considered to be implemented as a machine-readable storage medium, configured for use with a processing system, where the storage medium so configured causes the processing system to operate in a specific and predefined manner to perform the functions described herein.","An example of one such type of processing system is shown in FIG. . Sample system  may be used, for example, to execute the processing for methods in accordance with the present invention, such as the embodiment described herein. Sample system  is representative of processing systems based on the microprocessors available from Intel Corporation, although other systems (including personal computers (PCs) having other microprocessors, engineering workstations, set-top boxes and the like) may also be used. In one embodiment, sample system  may be executing a version of the WINDOWS.TM. operating system available from Microsoft Corporation, although other operating systems and graphical user interfaces, for example, may also be used.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","106","108","114","102","102","112","102","100"]},"Processor  issues signals over common bus  for communicating with memory  or graphics and memory controller  in order to manipulate data as described herein. Processor  issues such signals in response to software instructions that it obtains from memory . Memory  may be a dynamic random access memory (DRAM) device, a static random access memory (SRAM) device, or other memory device. Memory  may store instructions and\/or data represented by data signals that may be executed by processor , graphics device  or some other device. The instructions and\/or data may comprise code for performing any and\/or all of the techniques of the present invention. Memory  may also contain software and\/or data. An optional cache memory  may be used to speed up memory accesses by the graphics device  by taking advantage of its locality of access.","In some embodiments, graphics device  can offload from processor  many of the memory-intensive tasks required for rendering an image. Graphics device  processes data signals and may be a complex instruction set computer (CISC) microprocessor, a reduced instruction set computing (RISC) microprocessor, a very long instruction word (VLIW) microprocessor, a process implementing a combination of instruction sets, or other processor device, such as a digital signal processor, for example. Graphics device  may be coupled to common bus  that transmits data signals between graphics device  and other components in the system , including render cache  and display device . Graphics device  includes rendering hardware that among other things writes specific attributes (e.g. colors) to specific pixels of display  and draw complicated primitives on display device . Graphics and memory controller  communicates with display device  for displaying images rendered or otherwise processed by a graphics controller  for displaying images rendered or otherwise processed to a user. Display device  may comprise a computer monitor, television set, flat panel display or other suitable display device.","Memory  stores a host operating system that may include one or more rendering programs to build the images of graphics primitives for display. System  includes graphics device , such as a graphics accelerator that uses customized hardware logic device or a co-processor to improve the performance of rendering at least some portion of the graphics primitives otherwise handled by host rendering programs. The host operating system program and its host graphics application program interface (API) control the graphics device  through a driver program.","Referring to , an embodiment  of various graphics objects, for example geometric primitives (i.e. triangles, lines) , implemented on a zone rendering system  is illustrated. In zone rendering, a screen is subdivided into an array of zones  commonly screen-space rectangles although other geometric variants may be used as well. Each zone  is associated with a bin. Each bin  includes a chained series of command buffers  stored within non-contiguous physical memory pages. The bins  are thus preferably implemented as a chain of independent physical pages.","When a primitive  intersects a zone , the corresponding primitive instruction is placed in the bin  associated with the zone  intersected. Per-zone instruction bins  are thus used to hold primitive instructions and state setting instructions required to render each sub-image and are generated by comparing the screen-space extent of each primitive  to the array of zones . Thus, as the primitives  are received, the present invention determines which zone(s)  each primitive  intersects, and replicates the primitive instructions into a bin  associated with each of these zones . The process of assigning primitives (and their attributes)  to zones  is referred to as binning. \u201cBin\u201d  refers to the abstract buffer used for each zone\u2014where a bin  will typically be realized as a series of instruction batch buffers . Binning performs the necessary computations to determine what primitives  lie in what zones  and can be performed by dedicated hardware and\/or software implementations. In one typical implementation, a driver  writes out a set of commands to be parsed by the graphics-binning engine  for each zone  intersected by a primitive  and the commands are written into buffers  associated with the zones  intersected.","Some primitives  will intersect more than one zone , in which case the primitive instruction is replicated in bins  corresponding to the intersected zones . For example, the lightening bolt depicted in  intersects nine zones . This process is continued until the entire scene is sorted into bins .","Once all the primitives  are sorted and the command structures completed, a second pass is made to render the scene one zone  at a time. Following the first pass of building a bin for each zone  intersected by a primitive , a second zone-by-zone rendering pass is performed. In particular, the bins  for all the zones  are rendered to generate the final image, with each scene rendered one zone  at a time. The order with which the zones  are rendered is not significant. All bins  associated with primitives  that touch pixels within a particular zone  are rendered before the next zone  is rendered. A single primitive  may intersect many zones , thus requiring multiple replications. As a result, primitives  that intersect multiple zones  are rendered multiple times (i.e. once for each zone  intersected).","Rendering performance improves as a result of the primitives  being decomposed into zones  that are aligned to the render cache . Since the graphics device  is only working on a small portion of the screen at a time (i.e. a zone ), it is able to hold the frame buffer contents for the entire zone  in a render cache . The dimensions of the zone  are typically a constant tuned to the size and organization of the render cache . It is by this mechanism that the render cache  provides optimal benefits\u2014reuse of cached data is maximized by exploiting the spatial coherence of a zone . Through use of the zone rendering mode, only the minimum number of color memory writes need be performed to generate the final image one zone  at a time, and color memory reads and depth memory reads and writes can be minimized or avoided altogether. Use of the render cache  thus significantly reduces the memory traffic and improves performance relative to a conventional renderer that draws each primitive completely before continuing to the next primitive.","Referring to , in a typical implementation, a graphics primitive and state-setting instruction stream, referred to as a scene input list , is initially applied to graphics-binning engine ring buffer  associated with graphics-binning engine . The scene input list  may be a single, temporally-ordered scene description (as received by the application programming interface). Graphics-binning engine  is typically implemented as a hardware binning engine (HWB) . One skilled in the art will recognize that a software or software plus hardware binner could be used as well. The graphics-binning engine  parses scene input list  and determines which zone(s)  each primitive  intersects.","As previously noted, the zones  are associated with bins . Graphics-binning engine  compares the screen-space extent of each primitive  to the array of zones , and replicates the associated primitive commands into corresponding bins . As shown in FIG.  and described in detail below, bins  are comprised of chained series of command buffers  typically stored within non-contiguous physical memory pages. A bin list is a list of buffers  which comprise each bin . Pages are initially allocated to the BMP . The bin pointer list  is initialized with the page numbers of the pages and stores a write pointer into the bin list .","The graphics-binning engine  also maintains the current graphics state by parsing associated state-setting instructions contained with the scene input list . Prior to placing a primitive command in any given bin , the graphics-binning engine  typically precedes the primitive command in the bin  with any required state-setting instructions.","After the scene input list  has been completely parsed, the collection of associated bins (i.e. bin , bin  . . . bin n-) are ready to be used by the graphics-rendering engine  to render the scene. As discussed in detail below, instructions are included at the end of the scene input list  to cause the graphics-binning engine  to increment the register in pending scene counter  by one and initiate rendering of the binned scene. For example, graphics-binning engine  sends a render instruction to graphics-rendering engine ring buffer  associated with graphics-rendering engine  via path .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["180","126","136","174","182","148","180","125","128"]},"Referring to , an embodiment  of a bin pointer list (BPL) , including current bin pointers  and bins , is illustrated. The bin pointer list , maintained in memory, is used to store the initial and, subsequent, current pointer  into the bin pointer list  for each bin . BMP ring buffer memory area  holds a list of pointers to free physical pages available for use by binner . In particular, the bin pointer list  is a physically contiguous, size-aligned array of bin pointers , where the size of the bin pointer list  is equal or approximately equal to the maximum number of bins  supported by the graphics device . Each bin pointer  contains the current bin write pointer (e.g., a physical Word address) for a bin , along with a bin state value. In a typical embodiment, bin pointers  are stored in a tiled fashion, where every 8 Dwords (256-bit cache line) contains a re-arranged list of bin pointers  for a 1-wide by 4-high rectangular group of bins .","Referring to , an embodiment of a BMP ring buffer memory area  is illustrated. BMP ring buffer memory area  associated with BMP  holds a list of pointers to free physical pages available for use by the graphics-binning engine . The ring buffer memory area  maybe located in either the system memory  or a dedicated memory. Page numbers of available free pages  are generated and placed in BMP ring buffer . BMP ring buffer register  associated with BMP ring buffer memory area  may have multiple fields within the register. The fields contained within an embodiment of BMP ring buffer register  include, but are not limited to, a start address field (S) , buffer length field (L) , get offset field (G) , put offset field (P)  and other fields. The BMP ring buffer register  defines the start  and length  of the BMP ring buffer memory area , and includes two \u201coffsets,\u201d a get  and put , into the BMP ring buffer memory area . The BMP  itself is stored in an aligned list of physically contiguous memory, typically 4 KB, defined by a starting physical page number and a size in pages, typically 4 KB.","The graphics device , including the graphics-binning engine  and graphics-rendering engine , access BMP ring buffer memory area  via get and put offset registers  and . The BMP  is initially initialized and specified by writing the BMP register which provides for the BMP start  and BMP size . The get offset  and put offset  are typically initialized, prior to any binner usage, to zero to indicate a complete complement of free pages.","Referring to , graphics device  also includes a bin control register  including multiple fields within the register. The fields contained within an embodiment of the bin control register  include, but are not limited to, a restart bit , synchronous end of scene bit , resume bit  and other fields. Once the BMP  is grown, binning of the scene is resumed via a direct write of the bin control register  to set a restart bit .","As a binned scene is rendered, the bin memory is allocated and then recycled for subsequent use in binning the next scene. In particular, each batch buffer  is initiated with a batch buffer start instruction  specifying a physical address and reclaim bit. The graphics-rendering engine  decodes and executes the batch buffer start instruction  when it renders each batch buffer . The graphics-rendering engine  will insert free pages  into BMP  at the end of processing a batch buffer  initiated with a batch buffer start instruction  specifying a physical address and having the \u201creclaim\u201d bit set. This process allows bin buffer memory  (i.e. pages) to be automatically reclaimed without software intervention. The put offset  informs the graphics-rendering engine  of the put offset  at which to write the page number of the next freed-up buffer . The graphics-rendering engine  uses the put offset  to return the pages of bin buffers  to the BMP  as their execution completes.","The graphics-binning engine  and graphics-rendering engine  are in communication with the pending scene counter  which monitors and counts every scene being binned. The pending scene counter  is initialized to zero, and when non-zero, indicates the current processing of at least one binned scene. When there is no pending scene(s), the pending scene counter  is zero. The pending scene counter  is incremented each time a scene is being binned. Correspondingly, the pending scene counter  is decremented each time a binned scene is rendered. In particular, in order to initialize graphics state for the rendering of each bin , a special instruction is placed at the end of the scene render list  that will decrement the pending scene counter  by one. When the pending scene counter  decrements to one, there are no complete scenes queued up for rendering.","BMP ring buffer memory area  can hold one or more bin pointer lists , where each bin pointer lists  is a list of physical page numbers to be used for the initial bin buffer (one page number per zone). Multiple bin lists (typically two for a double buffer) allow binning of the next scene to start while the graphics-binning engine  is actively binning the current scene. In order to allow the binning of the next scene to be started before the current scene has completed binning, more than one bin pointer list  is used to provide a multi-buffered input to the binner . The Dword entries in the BMP ring buffer memory area  contain a physical page number and an associated memory space selection if the device supports multiple physical memory spaces.","Referring to , in the process of creating a new bin buffer , graphics-binning engine  will extract a free page number  from BMP  assuming one is available. In particular, during binning of a scene, graphics-binning engine  queries the BMP ring buffer memory area  to determine if there is a free page available. The get offset  informs graphics-binning engine  of the offset of the page number of the next available free page  to retrieve. The graphics-binning engine  will use this offset to obtain the physical pages  required to build the bins . When the graphics-binning engine  attempts to extract a free page number  but finds the BMP  is empty, the graphics-binning engine  queries the pending scene counter  to determine whether there are any \u201cpending\u201d binned scenes. If the pending scene counter  is non-zero, the graphics-binning engine  remains idle until a free page  becomes available or the pending scene counter  becomes zero","If the pending scene counter  is zero, there are no pending binned scenes and thus no potential source of freed-up pages. At that point, the BMP  is grown by increasing the BMP  by a size necessary to accommodate the required number of additional free page numbers . In a typical implementation, the BMP  is grown in multiples of 4KB. Additional free page numbers are then inserted into the larger BMP  and the BMP ring buffer registers , ,  and  are accordingly adjusted. The new list of free pages  are placed at the top of the BMP ring buffer memory area  and the pointers adjusted. For example, both pointers can be moved as the graphics-binning engine  will simply resume using the new pointer values. The graphics-binning engine  then extracts a free page number  from the BMP  and continue the binning process.","If additional free memory cannot be made, graphics-rendering engine  renders the partially-binned scene to free up bin memory and then restarts binning the remainder of the scene. In a typical embodiment, a direct write of the bin control register  to set a synchronous end scene bit  is performed. This causes the graphics-binning engine  to (a) close all valid bins  by terminating them with an instruction to end the batch buffer, (b) flush out any internally cached data (e.g., cached bin pointers ), and (c) modify the state-tracking information associated with the bins  such that, upon resumption of binning, all necessary state is inserted into a bin  prior to the first primitive  it receives. Any other actions required to render the partially binned scene are also taken. These actions include, but are not limited to, a direct write of a bin scene register  to cause the pending scene counter  to get incremented and actions to ensure that the depth write enable bit of the zone control register is cleared prior to rendering the partial scene (as the rendering of the continuation of the scene will require depth values to have been written to memory).","Binning of the scene is resumed through a direct write of the bin control register  to set a resume bit . As noted above, the synchronous end scene operation will have all bin bit vectors used to track changes to state groups, so each bin  will be refreshed with the current state prior to any new primitive output.","The graphics-rendering engine  will insert free page numbers  into BMP  at the end of processing a batch buffer initiated with a batch buffer start instruction  specifying a physical address and having the \u201creclaim\u201d bit set. This process allows bin buffer memory (i.e. pages) to be automatically reclaimed without software intervention. As a binned scene is rendered, the bin memory is allocated and then recycled for subsequent use in binning the next scene. In particular, the put offset  informs the graphics-rendering engine  of the put offset  at which to write the page number of the next freed-up buffer. The graphics-rendering engine  uses the put offset  to return the pages of bin buffers  to the BMP  as their execution completes.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 7","b":"200"},"Pages are initially allocated to the BMP  (step ). The BMP  is then initialized (step ). The BMP  is specified by writing the BMP buffer register which provides for the BMP start  and BMP size . The BMP's Get Offset  and Put Offset  are initialized, prior to any binner usage, to zero to indicate a complete complement of free pages.","The bin pointer list  is then initialized with the physical page numbers allocated (step ). During binning of a scene, the present invention determines if there are free pages available (step ). When the graphics-binning engine  attempts to extract a free page number  but finds the BMP  empty, it performs one of two actions. If there are any \u201cpending\u201d binned scenes (i.e. the pending scene counter  is non-zero) (step ), the graphics-binning engine  will wait until a free page  becomes available or the pending scene counter  becomes zero (step ).","In the event the graphics-binning engine  encounters an out of memory condition, and there are no pending binned scenes (and therefore no potential source of freed-up pages), an out of memory interrupt is generated. At that point, software has the option to provide more free pages by \u201cgrowing\u201d the BMP  (step ). The BMP  is grown by initially increasing the BMP by a size necessary to accommodate the required number of additional free page numbers . Additional free page numbers are then inserted into the larger BMP  and the get and put offsets registers , ,  and  are accordingly adjusted. If a free page  becomes available (step ), the graphics-binning engine  will extract that page number  from the BMP  and continue the binning process.","If the pending scene counter  is zero (step ) or becomes zero while waiting (step ), the graphics-binning engine  will raise an out of memory exception which is capable of generating a processor interrupt (step ).","At this point, if software can make additional free memory (step ) available, the BMP  is grown, additional free pages  inserted and binning of the scene resumed via a direct write of the bin control register  to set a restart bit  (step ).","If additional free memory (step ) cannot be made the BMP  is considered in an \u201cempty\u201d state available, rendering of the partially-binned scene is forced in order to free up bin memory, then binning of the remainder of the scene is restarted (step ). The graphics-binning engine  will then (a) close all valid bins by terminating them with an instruction to end the batch buffer, (b) flush out any internally cached data (e.g., cached bin pointers ), and (c) modify the state-tracking information associated with the bins  such that, upon resumption of binning, all necessary state is inserted into a bin  prior to the first primitive  it receives. Any other actions required to render the partially binned scene are also taken. Binning of the scene is resumed through a direct write of the bin control register to set a resume bit. As noted above, the synchronous end scene operation will have all bin bit vectors used to track changes to state groups, so each bin  will be refreshed with the current state prior to any new primitive output.","Thus, in accordance with the present invention, the binner and renderer automatically share a pool of physical memory pages in order to build bin buffers during the binning phase and recycle them after than have been during the rendering phase. This is performed in such a fashion that multiple binned scenes can be queued up concurrently, with minimal software intervention.","Having now described the invention in accordance with the requirements of the patent statutes, those skilled in the art will understand how to make changes and modifications to the present invention to meet their specific requirements or conditions. Such changes and modifications may be made without departing from the scope and spirit of the invention as set forth in the following claims."],"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
