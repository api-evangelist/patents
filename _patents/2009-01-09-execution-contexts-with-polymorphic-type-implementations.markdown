---
title: Execution contexts with polymorphic type implementations
abstract: Various domains may wish to specify different implementations of the type; e.g., a compilation domain may describe the type statically, an execution domain may instantiate objects of the given type, while a debugging execution domain may associate additional debugging information such as a symbol name. This may be achieved by specifying a type implementation of a particular type within respective domains which all implement a common type interface. A type binding instruction set may then select a type implementation for the type within the target instruction set according to the domain, and may bind type instances of the type within target instruction set to the selected type implementation for the current domain. This technique yields domain-specific variance in type implementation without having to reconfigure the target instruction set or perform domain-checking logic there-within.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08745605&OS=08745605&RS=08745605
owner: Microsoft Corporation
number: 08745605
owner_city: Redmond
owner_country: US
publication_date: 20090109
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Within the field of computing, many scenarios involve the inspection of a type system in one of several domains that may differ in certain properties. These domains may provide different implementations for a common type interface. For example, a compiler may create and inspect static types at compile time. A debugger may inspect types that exist in a debuggee process. An IDE may inspect types constructed from user code fragments as the code is being developed. A native execution domain or simulator may create objects that are instances of the given types.","The code executed within such domains often involves the storing of type instances in a region of memory of the computer. The type instance may be of various types, such as a primitive type (e.g., an integer or a string); a plurality of several type instances (e.g., an array); a composite of several type instances (e.g., a structure or a class instance); or a reference to a memory location (e.g., a pointer.) The memory allocated for storing these types of type instances may also take many forms, such as a region of randomly accessible memory, a stack, a queue, and a heap.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Because different domains often represent different contexts in which the target instruction set is used, domains may instantiate, format, and use a particular type in a different manner than another domain. As a first example involving an integer, a native execution domain may generate a type instance of the integer according to the native word size of the architecture (e.g., a 64-bit integer created in a 64-bit operating environment); a managed execution domain may generate the type instance according to a format used by a runtime (e.g., a 32-bit integer created by a 32-bit runtime); and a virtual execution domain may generate the type instance according to a standard used by a virtual environment (e.g., a 16-bit integer created for use with a 16-bit virtual machine.) As a second example, a class instance generated by a native execution domain may simply comprise the class instance, while a debugging execution domain may also associate with the class instance some debugging information (e.g., a symbol name) and may substitute member functions with equivalent debugging functions, and a virtual execution domain may associate with the class instance both the logical address of the class instance in the native memory store and the logical address of the class instance in the virtual memory store of the virtual environment. A class instance generated by a compiler contains the information to statically describe this class and persist it to file.","In these and other scenarios, different domains may generate a type in different ways, even if the type is generated by the same target instruction set executing in the different domains. At some point, the computing environment may have to select a particular type implementation for the target instruction set, such as when a user or process requests information about the implementation of a particular type referenced in the target instruction set, or when the target instruction set is configured to generate a type instance of a type according to a particular type implementation (such as during compiling or at runtime.) At that time, the computing environment selects a type implementation for the type within the target instruction set, and binds the type instances of the type within the target instruction set to the selected type implementation (e.g., by displaying information for the user, by instantiating one or more type instances according to the type implementation, etc.)","Many techniques might achieve the binding of the type to the type implementation in a particular target set. In one such technique, a domain may specify an implementation of one or more types when such types are generated by the domain. When one or more type instances are to be bound to a type implementation within a target instruction set, the type implementation of the type within the domain may be consulted, and a type instance may be generated based on the type implementation within the domain. A domain may exist for compilation where types are defined statically and then persisted to storage. A type instance may then be implemented by a component that can read from the storage and implement the type interface. Domains may also be implemented as a set of runtimes configured to execute target instruction sets in various execution contexts, such as a native execution runtime, a debugging execution runtime, and a virtual execution runtime. Respective runtimes may also define one or more type implementations of a particular type used in a target instruction set; and when the target instruction set executing within a runtime generates a type instance of a particular type, the runtime may provide the type implementation of the type. In this manner, each domain may generate a different type implementation of a particular type consistent with the execution context of the domain, and this may be achieved without reconfiguring the target instruction set.","To the accomplishment of the foregoing and related ends, the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects, advantages, and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.","The claimed subject matter is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident, however, that the claimed subject matter may be practiced without these specific details. In other instances, structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.","In the field of computing, the execution of a target instruction set (such as a program) may occur within a particular domain, which may define many aspects of the execution. Respective domains may therefore execute the target instruction set differently in furtherance of particular advantages, such as performance, safety, and inspection capabilities. For example, a first domain may be configured for natively executing a set of fully compiled instructions on the processor, which may provide high performance, but may not be amenable to oversight and may be less able to adapt to the available hardware. A second domain may be configured for executing the instructions in a debugging context, where the executing is states of particular data objects may be monitored, the occurrence of particular events may be logged, and effects may be simulated without perturbing the state of the debuggee. A third domain may be configured for executing the instructions in a virtual machine having a set of emulated hardware components and a separate memory store, which may permit execution of untrusted code without jeopardizing the local computing environment. A fourth domain may be for compilation where types are created from compiling user code and serialized to storage.","Target instruction sets often involve the generating and storing in memory of one or more values or objects, where each value or object is an instance of a particular type, such as a primitive type (e.g., integers, strings, and Boolean values), a data structure (e.g., one or more instances of a class), or a memory reference (e.g., pointers to primitive types, data structures, and functions.) The instances of such types may also be organized in memory in many ways, such as an array or linked list, a tree structure, a hashtable, a stack, etc. When a target instruction set specifies the generation of an instance of a type (such as an integer or a class), the composition of the type is identified (such as the length of an integer, or the members comprising an instance of the class), and memory may be allocated, initialized, and accessed in accordance with the composition of the type instance. As another example, a user or process may wish to inspect or compile a source code version of the contents of a target instruction set. In these and other examples, the computing environment may have to use some information about the type implementation. The computing environment may therefore have to select a particular type implementation of the type for use within the target instruction set, and may then have to bind the type instances within the target instruction set to the type (e.g., by instantiating one or more type instances according to the selected type implementation; by compiling the target instruction set to generate type instances of the type according to the selected type implementation; or by displaying information requested by a user as to the details of the selected type implementation of the type.)","Often, the target instruction set may define the format of a type, such as the precise length and format of an integer (e.g., an unsigned 64-bit integer) and the members of a class. However, a target instruction set may also leave one or more aspects of the type undefined, such as generating an integer of unspecified size or format, or by declaring an object of a variant type or according to a \u201cduck typing\u201d model. The particular implementation may be selected for a type within the target instruction set when one or more type instances are bound to the type; e.g., the length of the integer may be selected based on the architecture of the computing environment, and the properties of an object may be handled differently by different runtimes when bound to the type instances of the type (e.g., when the target instruction set is executed within different execution contexts.) Moreover, the execution context expressed by a domain may preferably alter the implementation of a particular type. For example, a debugging execution domain may associate a symbol name with a particular type instance for easier inspection, and may substitute one or more member functions of a class instance with equivalent functions configured to execute in a debugging domain; and a virtual execution domain may associate with a particular type instance a virtual memory address where the type instance is located within the virtual computing environment. As a result of these considerations, a type instance generated in a first domain may be differently represented than a type instance generated in a second domain. This difference may reflect a type implementation of a type in the first domain that differs from a type implementation of the same type in the second domain.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["10","14","14","16","16","10","18","14","16","14","12","16","14"]},"The target instruction set  is executed by the processor  within one of several domains, such as a native execution domain , a debugging execution domain , and a virtual execution domain . Each domain represents a particular execution context in which the target instruction set  may be executed, and each domain may provide a particular set of advantages and disadvantages with respect to other domains (e.g., the debugging execution domain  may provide debugging capabilities to the executing target instruction set , such as inspection, breakpointing, and monitoring; the virtual execution domain  may permit the execution of the target instruction set  within a virtual machine, which may isolate the target instruction set  from the native computing environment as a security measure; and the native execution domain  may execute the target instruction set  more quickly but with fewer safeguards or monitoring capabilities.)","In furtherance of the capabilities of each execution context, each domain may instantiate the class  on behalf of the target instruction set  in a different way. For example, the native execution domain  may instantiate the class  on behalf of the target instruction set  by generating a native class instance  comprising only the members of the class specified in the class definition . Because the native execution domain  is configured to provide improved performance of the target instruction set , the native execution domain  may also generate the native class instance  with various performance improvements (e.g., by compacting the memory usage of the native class instance  to conserve memory or transmission bandwidth, or contrastingly by word-aligning the class members  of the native class instance  to promote quicker access to the class members .) By contrast, the debugging execution domain  may generate a debugging class instance  that is configured to promote the debugging capabilities of the debugging execution domain . For example, the debugging class instance  may include an additional class member  that identifies a symbol name assigned to the debugging class instance  by the target instruction set ; this may be helpful to a developer, e.g., for identifying the debugging class instance  when placed on a stack during a call stack trace.) As still another contrast, the virtual execution domain  may generate a virtual class instance  that is configured to promote the virtual execution of the target instruction set . For example, the virtual class instance  may include an additional class member  that identifies the virtual address of the virtual class instance  within the memory of the virtual machine within which the target instruction set  executes. The virtual class instance  may also replace a class member with a substituted class member ; e.g., the Compare( ) function may be replaced with a \u201cV_Compare( )\u201d function that compares the virtual addresses of class instances, which may be a quicker and more semantically accurate identity comparison technique when the target instruction set  executes within a virtual environment.","Therefore, as illustrated in , type instances of a type may be generated in different ways based on the nature and capabilities of the execution domain that hosts the target instruction set  that generates the type instances while executing on a processor . Such variable configuration may promote the capabilities and advantages of the execution context represented by the domain. However, it may be appreciated that the target instruction set  does not specify these variances in the instantiations of the type, such as might be achieved if the target instruction set  first determined its execution context and then selected a type implementation among a plurality of such type implementations. This checking might result in overly complicated code, and might be difficult to maintain in view of changing numbers, natures, and configurations of the domains provided within the computing environment.","Many techniques may be devised to achieve this different result, but some such techniques might be disadvantageous, undesirable, and\/or unworkable. As a first example, a domain may upon encountering one or more references to a particular type in a target instruction set, reconfigure the target instruction set to generate particular instances of the type according to a particular type implementation; e.g., a debugging execution domain may insert a field into declared classes to store a symbol name string or track such information through auxiliary maps, and a virtual execution domain may redefine each instantiation of an \u201cint\u201d type according to the integer format of the virtual computing environment. However, such reconfiguration may be difficult, e.g., where the target instruction set is fully compiled and difficult to analyze for the instantiation of particular types. As a second example, a domain may monitor the execution of a target instruction set to identify the instantiation of particular types, and may alter the instantiation to reflect the type implementation within the domain. However, such monitoring may reduce the performance of the execution of the target instruction set and may consume significant computing resources.","An alternative technique for achieving the varying type implementation of a type with respect to a particular domain involves declaring one or more type implementations within the domain. When one or more type instances of a type within a target instruction set are to be bound to a particular type implementation, the computing environment may identify the domain for the target instruction set, may then query the domain for a type implementation of that type, and may then bind the type instances of the type within the target instruction set to the provided type implementation. If the domain specifies a type implementation of the type, a type instance may be generated and stored in memory based on the type implementation. (If the domain does not specify a type implementation of the type, the domain may be configured to produce various outcomes, such as using a default type implementation, attempting to generate a stub type implementation of the type, querying the user for a type implementation, and\/or raising an exception.) In this manner, the types utilized in the target instruction set may be matched with type implementations specified in the domain for the target instruction set, thereby achieving a domain-specific variability of type implementations while economizing computing resources and promoting the performance of the execution of the target instruction set. Moreover, this manner of binding type implementations to respective types may be performed, e.g., by a type binding instruction set provided within the computing environment and configured to generate type instances on behalf of domains that define type implementations of particular types. Such a type binding instruction set may be provided, e.g., by the computing environment, such as within one or more runtimes configured to facilitate the execution of target instruction sets within the computing environment.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["40","14","12","40","14","16","18","14","12","20","24","30","40","40","16","20","44","24","46","30","48"]},"As further illustrated in this exemplary scenario , the target instruction set  is serviced by a type binding instruction set  that binds type instances within the target instruction set  to a particular type implementation. For example, the type binding instruction set  may comprise a runtime that executes the target instruction set  on the processor , in part, by identifying the execution domain of the target instruction set , selecting a class implementation within the domain in which the target instruction set , and generating the class instance based on the selected class implementation. As another example, the type binding instruction set  may comprise a compiler that configures a compiled version of the target instruction set  to generate type instances of a type according to a particular type implementation. As a third example, the type binding instruction set  may comprise an instruction set inspection tool that, when applied to a particular instruction set, provides information about type instances of a type in the instruction set according to a particular type implementation. In these scenarios, the target instruction set  may rely on a particular implementation of respective types, based on the domain of the target instruction set . Moreover, this variance is achieved in the absence of domain-specific logic or a plurality of class definitions  in the target instruction set .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3","b":["50","74","14","72","12","76","50","52","54","42","72","42","56","76","14","58","78","74","76","78","74","50","42","12","72","12","42","78","14","76","14","50","74","64"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4","b":["80","74","14","72","12","76","80","42","12","74","78","14","14","12","80","82","76","14","80","84","78","74","76","80","86","74","14","78","74","80","74","14"]},"Still another embodiment involves a tangible computer-readable medium comprising a type binding instruction set configured to apply the techniques presented herein. An exemplary tangible computer-readable medium that may be devised in these ways is illustrated in , wherein the implementation  comprises a computer-readable medium  (e.g., a CD-R, DVD-R, or a platter of a hard disk drive), on which is encoded computer-readable data . This computer-readable data  in turn comprises a set of computer instructions  configured to operate according to the principles set forth herein. In one such embodiment, the processor-executable instructions  may be configured to perform a method of binding a type instance of a type  specified in a target instruction set  stored in a memory  of a computer having a processor  and defining at least two domains , such as the exemplary method  of . In another such embodiment, the processor-executable instructions  may be configured to implement a system for binding a type instance of a type  specified in a target instruction set  stored in a memory  of a computer having a processor  and defining at least two domains , such as the exemplary system  of . Many such tangible computer-readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.","The techniques discussed herein may be devised with variations in many aspects, and some variations may present additional advantages and\/or reduce disadvantages with respect to other variations of these and other techniques. Moreover, some variations may be implemented in combination, and some combinations may feature additional advantages and\/or reduced disadvantages through synergistic cooperation. The variations may be incorporated in various embodiments (e.g., the exemplary method  of  and the exemplary system  of ) to confer individual and\/or synergistic advantages upon such embodiments.","A first aspect that may vary among embodiments of these techniques relates to the nature of types  to which the variant instantiation may be applied and the manner of defining such types . As a first example, the types  may comprise many forms of data utilized in the target instruction set , including primitive types (e.g., strings, integers, and Boolean values), data containers (e.g., arrays, linked lists, trees, stacks, and heaps), and data structures comprising an organization of members (e.g., structs, classes, and tuples.) As a second example, a type implementation  of a particular type  may be defined in many ways, such as an express declaration of structure in the target instruction set , a reference to an externally defined structure (e.g., an XML schema defining a class), and a reference to a standard (e.g., formatting an integer according to a native format supported by a native or virtual computing environment.) As a third example, a type implementation  of a type  may be wholly defined together in the target instruction set , or may be defined in multiple locations (e.g., in an aspect-oriented language, a cross-cutting module alters an implementation in another module), or may be defined as an alteration of another type implementation  (e.g., a class that inherits from a superclass may specify only the new and altered class members and properties, and a type implementation  within a domain  may specify only alterations to a base type implementation , such as illustrated in .) Those of ordinary skill in the art may apply the techniques discussed herein to many data types of various natures and defined in various ways.","A second aspect that may vary among embodiments of these techniques relates to the different types of bindings of instances of the type  to the type implementation  within the target instruction set . As a first example, the computing environment may bind  the type instances of the type  to the type implementation  during an inspection of the target instruction set  when a user requests information about a particular type that depends on the type implementation, and the binding may comprise displaying for the user at least one aspect of the type implementation  selected for the type  within the selected domain . As another example, a process may examine the target instruction set  (e.g., to identify security vulnerabilities), a compiler may evaluate the target instruction set  in order to compile an executable binary; in these cases, the binding may comprise notifying such processes as to the details of the type implementation . As a third example, the binding may be performed during execution of the target instruction set  on the processor , and the binding may comprise instantiating one or more type instances of the type  according to the selected type implementation  within the selected domain .","A third aspect that may vary among embodiments of these techniques relates the manner in which a computing environment may identify  a type implementation  of a type  in the domain  for the target instruction set . As a first variation of this aspect, respective domains  may contain or reference one or more type implementations , and a suitable type implementation  may be identified by searching the contained or referenced type implementations . As a second variation of this third aspect, the domains  may be queried for a suitable type implementation  of a particular type  and may provide a reference to the selected type implementation . For example, a domain  may comprise a type implementation identifier of a type , which may be configured to select the type implementation  of the type  within the domain .  illustrates an exemplary scenario  wherein the memory  comprises a target instruction set  that may execute on a processor , a set of domains , and a type implementation selecting component  that selects a type implementation of the type on behalf of the target instruction set . In addition, the memory  comprises a set of type implementations, including a first type implementation  and a second type implementation  for a type identified as \u201ctype A,\u201d and a third type implementation  and a fourth type implementation  for a type identified as \u201ctype B.\u201d The respective domains  may include a first type implementation identifier  that identifies a type implementation for type A within the domain, and a second type implementation identifier  that identifies a type implementation for type B within the domain. The type implementation selecting component  may therefore identify a type implementation for type A on behalf of the target instruction set  by querying a domain  for a type implementation of type A, and the domain  may invoke the first type implementation identifier  to identify the selected type identifier for type A. This invoking may occur, e.g., upon loading an assembly specifying the type instance (e.g., when the target instruction set  is first loaded into the memory  for storing or execution, the domains  may generate type implementation identifiers for respective types that are instantiated in the target instruction set ), or upon beginning execution of the target instruction set , or upon instantiating the type instance during execution of the target instruction set .","Other variations of this third aspect may be used where a suitable type implementation  of a particular type  is not found in the domain . In a third variation of this third aspect, a default type implementation  of the type  may be identified and used. For example, the target instruction set  may include a default type implementation of the type  in case the domain  does not contain a domain-specific type implementation . As another example, a domain  may contain a default type implementation  to be used for any type  that does not have a more specific type implementation  in the domain . Conversely, the target instruction set  may expressly omit a definition of the type implementation  of the type , such as in a class defined as an \u201cabstract\u201d class that is to be implemented in each domain  in which the target instruction set  may execute. In a fourth variation of this third aspect, upon failing to identify a type implementation  within the selected domain , a stub type implementation may be inserted into the selected domain . This stub type implementation may comprise a basic implementation with a few generic members (e.g., a newly declared subclass of the generic \u201cobject\u201d class), and if the target instruction set  references a particular member or aspect of the type implementation , a temporary member or aspect may be added to the stub type implementation (e.g., if the target instruction set  references a \u201cstrName\u201d member of the class, a \u201cstrName\u201d member of type string may be added to the class.)","In a fifth variation of this third aspect, the type implementing system or method may attempt to locate a suitable type implementation  among the resources of the computing environment. In one such example, the at least one assembly defining the type implementation  of the type  within the selected domain  may be selected, and the type implementation  may be retrieved from the assembly. In a \u201cclosed\u201d universe of such resources, the at least one assembly may be selected from among a limited assembly set associated with the selected domain  (such as a trusted set of assemblies from which type implementations  may be identified and used.) In an \u201copen\u201d universe of such resources, any assembly that identifies the type implementation  may be utilized; for example, a user selection may be solicited from a user for at least one candidate assembly that defines the type implementation  of the type , and upon receiving the user selection, the computing environment may identify  the type implementation  by selecting the assembly specified in the user selection.","Other variations of this aspect may involve various types of compensation upon failing to locate a type implementation  of a type . For example, the computing environment may fail to instantiate the type (e.g., by returning a null value instead of an object reference for a class that cannot be instantiated), notify a user or process of an error, and\/or throw an exception. Those of ordinary skill in the art may devise many techniques whereby a computing environment (such as a type binding instruction set ) may identify  the type implementation  of a type  while implementing the techniques discussed herein.","A fourth aspect that may vary among embodiments of these techniques involves the manner in which a computing environment may specify a type implementation  for one or more type instances of a type . In a first variation, the type implementation  may comprise a descriptor for the type , such as a class definition or a XML schema. The type instance generating component  may use the descriptor to compose the type instance of the type , e.g., by using a reflection library to add members to an instance of a base class (such as \u201cobject\u201d), or by using a memory allocation library to allocate and initialize memory for a primitive type. As a second variation, the type implementation  may comprise a type instance generator that is configured to generate instances of a type  according to the type implementation , and that the type instance generating component  may invoke to generate the type instance of the type  according to the type implementation . This type instance generator may be configured with respect to a particular type, such as a factory method. Alternatively, the generator may be configured to generate instances of two or more types, and may achieve this configuration (e.g.) through the use of a reflection library to compose a type instance of any such type  according to the selected type implementation .","It may be appreciated that embodiments and variations that use reflection techniques may be comparatively slow, as reflection can be a computationally expensive operation. Therefore, it may be desirable to cache one or more type instances, so that subsequent bindings of type instances of a particular type  to a type implementation  may occur more quickly than the first binding. For example, the memory may comprise at least one type instance cache, which may be configured to associate at least one type with at least cached one type instance. The type implementation binding component  may therefore be configured, upon receiving a request to generate a type instance of a particular type  according to a type implementation , to first search the type instance cache to identify a cached type instance of the type . If a cached type instance of the type  is located, the type implementation binding component  may simply the cached type instance to bind the type instance to the type implementation. However, upon failing to identify a cached type instance of the type , the type implementation binding component  may instead generate a type instance (e.g., through the invocation of a type instance generator), and may store the type instance in the type instance cache associated with the type , which may facilitate the binding of additional type instances of the type  to the type implementation . Those of ordinary skill in the art may devise many ways of improving the binding of type instances of particular types  to respective type implementations  while implementing the techniques discussed herein.","A fifth aspect that may vary among embodiments of these techniques relates to the manner in which a computing environment may store a generated type instance in the memory . As a first example, the memory  may comprise a type instance cache, and a type instance may be stored in the type instance cache to facilitate the generation of additional instances of the type . As a second example, along with the type  may be stored a reference to the type implementation , which may be useful for identifying the manner by which the type instance of the type  was generated. As a third example, along with the type instance of the type  may be stored a reference to the domain  that generated the type instance. This may be useful, e.g., for identifying the domain that created a particular type instance, which may be helpful during a debugging technique such as a stack trace. Those of ordinary skill in the art may devise many additional variations on the storing of type instances of various types  in the memory  while implementing the techniques discussed herein.","A sixth aspect that may vary among embodiments of these techniques relates to additional capabilities of the computing environment that with respect to type instances of various types  generated according to various type implementations  associated with various domains . As a first example, the computing environment (e.g., the type binding instruction set , or a runtime configured to service the execution of the target instruction set ) may be configured to convert type instances of a type  between a first type implementation  associated with a first domain  and a second type implementation  associated with a second domain . This conversion may be useful, e.g., where two processes executing in different domains exchange a type instance (such as an object of a particular class.) In this scenario, the second domain may implicitly depend on the structuring and formatting of the type instance of the type  according to its own type implementation ; e.g., a type instance generated in a debugging execution domain may include debugging information, but a native execution domain may not be properly configured to anticipate or handle such information in type instances of the type . Accordingly, upon receiving a request to convert a type instance  of the first domain  to a type instance  structured according to a second type implementation  within a second domain , the computing environment may be configured to convert the type instance to a second type instance according to the second type implementation , and to store the second type instance associated with the second domain  in the memory . This may be achieved, e.g., through the use of a reflection library that removes members of a class that do not appear in the second type implementation , adds members to the class that newly appear in the second type implementation , and modifies members of the class that differ between the first type implementation  and the second type implementation . This might also be achieved, e.g., by serializing the members of the type instance according to the first type implementation  of the first domain , and deserializing the members of the type instance according to the second type implementation  of the second domain . For example, the type instance might be serialized in XML according to the Simple Object Access Protocol (SOAP), and then deserialized according to the same protocol, which may permit missing members to be added, omitted members to be dropped from the converted representation, and altered members to be reformatted. It may be appreciated that these converting techniques might be facilitated by storing with respective type instances a reference to the domain  that generated the type instance, and\/or a reference to the type implementation  whereby the type instance of the type  was generated.","As a second example, the computing environment may facilitate the comparison of type instances, which may be problematic if such type instances are generated by different type implementations  of the type  within different domains. For example, a memberwise comparison of a first type instance and a second type instance might incorrectly produce a negative comparison result for identical type instances if the type implementation for one type instance adds some members to the type instance that are unrelated to the comparison (e.g., members representing debugging information; or members representing details of file-storage that are irrelevant once the type has been loaded and instantiated) In order to promote such comparisons, the computing environment or a component therein (e.g., the type binding instruction set ) may be configured, upon receiving a request to compare two type instances, to compare abstractions of respective members of the type instances to generate a comparison result, and to return the comparison result to fulfill the request. For example, in order to compare a first type instance of a type  that is generated according to a first type implementation  specifying 32-bit integers and a second type instance of the same type  that is generated according to a second type implementation  specifying 64-bit integers, a memberwise comparison may be performed that abstracts the comparison of integer members to a standard format (e.g., 64-bit integers), and thereby achieves a logical comparison of the contents of respective members without regard to the particular implementation of various members by different type implementations . Those of ordinary skill in the art may devise many techniques for promoting operations involving various type instances generated according to various type implementations  on behalf of various domains  while implementing the techniques discussed herein.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims.","As used in this application, the terms \u201ccomponent,\u201d \u201cmodule,\u201d \u201csystem\u201d, \u201cinterface\u201d, and the like are generally intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a controller and the controller can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","Furthermore, the claimed subject matter may be implemented as a method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof to control a computer to implement the disclosed subject matter. The term \u201carticle of manufacture\u201d as used herein is intended to encompass a computer program accessible from any computer-readable device, carrier, or media. Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 7","FIG. 7"]},"Although not required, embodiments are described in the general context of \u201ccomputer readable instructions\u201d being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media (discussed below). Computer readable instructions may be implemented as program modules, such as functions, objects, Application Programming Interfaces (APIs), data structures, and the like, that perform particular tasks or implement particular abstract data types. Typically, the functionality of the computer readable instructions may be combined or distributed as desired in various environments.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 7","FIG. 7"],"b":["120","122","122","126","128","128","124"]},"In other embodiments, device  may include additional features and\/or functionality. For example, device  may also include additional storage (e.g., removable and\/or non-removable) including, but not limited to, magnetic storage, optical storage, and the like. Such additional storage is illustrated in  by storage . In one embodiment, computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage  may also store other computer readable instructions to implement an operating system, an application program, and the like. Computer readable instructions may be loaded in memory  for execution by processing unit , for example.","The term \u201ccomputer readable media\u201d as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory  and storage  are examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, Digital Versatile Disks (DVDs) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .","Device  may also include communication connection(s)  that allows device  to communicate with other devices. Communication connection(s)  may include, but is not limited to, a modem, a Network Interface Card (NIC), an integrated network interface, a radio frequency transmitter\/receiver, an infrared port, a USB connection, or other interfaces for connecting computing device  to other computing devices. Communication connection(s)  may include a wired connection or a wireless connection. Communication connection(s)  may transmit and\/or receive communication media.","The term \u201ccomputer readable media\u201d may include communication media. Communication media typically embodies computer readable instructions or other data in a \u201cmodulated data signal\u201d such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.","Device  may include input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, infrared cameras, video input devices, and\/or any other input device. Output device(s)  such as one or more displays, speakers, printers, and\/or any other output device may also be included in device . Input device(s)  and output device(s)  may be connected to device  via a wired connection, wireless connection, or any combination thereof. In one embodiment, an input device or an output device from another computing device may be used as input device(s)  or output device(s)  for computing device .","Components of computing device  may be connected by various interconnects, such as a bus. Such interconnects may include a Peripheral Component Interconnect (PCI), such as PCI Express, a Universal Serial Bus (USB), firewire (IEEE 1394), an optical bus structure, and the like. In another embodiment, components of computing device  may be interconnected by a network. For example, memory  may be comprised of multiple physical memory units located in different physical locations interconnected by a network.","Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example, a computing device  accessible via network  may store computer readable instructions to implement one or more embodiments provided herein. Computing device  may access computing device  and download a part or all of the computer readable instructions for execution. Alternatively, computing device  may download pieces of the computer readable instructions, as needed, or some instructions may be executed at computing device  and some at computing device .","Various operations of embodiments are provided herein. In one embodiment, one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media, which if executed by a computing device, will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further, it will be understood that not all operations are necessarily present in each embodiment provided herein.","Moreover, the word \u201cexemplary\u201d is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as advantageous over other aspects or designs. Rather, use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application, the term \u201cor\u201d is intended to mean an inclusive \u201cor\u201d rather than an exclusive \u201cor\u201d. That is, unless specified otherwise, or clear from context, \u201cX employs A or B\u201d is intended to mean any of the natural inclusive permutations. That is, if X employs A; X employs B; or X employs both A and B, then \u201cX employs A or B\u201d is satisfied under any of the foregoing instances. In addition, the articles \u201ca\u201d and \u201can\u201d as used in this application and the appended claims may generally be construed to mean \u201cone or more\u201d unless specified otherwise or clear from context to be directed to a singular form.","Also, although the disclosure has been shown and described with respect to one or more implementations, equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components (e.g., elements, resources, etc.), the terms used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., that is functionally equivalent), even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition, while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes\u201d, \u201chaving\u201d, \u201chas\u201d, \u201cwith\u201d, or variants thereof are used in either the detailed description or the claims, such terms are intended to be inclusive in a manner similar to the term \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
