---
title: Method and system for a call stack capture
abstract: A method of acquiring software profile information of a target software application includes receiving a programmed interrupt while executing an application in a computer system, servicing the interrupt such that call stack information is acquired and processing the call stack information to produce statistical information concerning function calls. The call stack information includes program counter and other information which is derived from the target application as well as operating system. Some or all of the call stack information may be recorded. The statistical information includes statistics concerning the number of samples wherein a series of functions calls are included in the call stack information and the number of samples wherein a set of function calls are at the top of the call stack information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07721268&OS=07721268&RS=07721268
owner: Microsoft Corporation
number: 07721268
owner_city: Redmond
owner_country: US
publication_date: 20041001
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Overview","Exemplary Embodiments of the Invention"],"p":["This application is related to co-pending, commonly assigned, patent application Ser. No. 10\/940,454, entitled \u201cCall Stack Capture Using Interrupt Driven Architecture\u201d filed Sep. 15, 2004, which is incorporated herein by reference in its entirety.","This invention relates in general to the field of software development. More particularly, this invention relates to profiling software performance in an embedded system development environment.","In general, software profiling is a technique for measuring or estimating what parts of a complex hardware and software system are consuming the most computing resources. The most common profiling tools aim to determine which segments of code within an application or service are consuming the most processor time and to find performance \u201cbottlenecks\u201d where optimization can be most beneficial to the running time. Profiling can also be applied to the consumption of other resources, such as processor caches, operating system APIs, memory, and I\/O devices.","The two most common approaches used in processor-time profiling are sampling and \u201cper-occurrence\u201d measurement. Sampling involves choosing a subset of interesting events, determining the cause of those events, and reporting the frequency of those causes. For example processor-time sampling involves measuring, at regular time intervals, which code was running; such as noting, at regularly-spaced times, the value in the processor's instruction pointer register.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIG. 1(","FIG. 1(","FIG. 1("],"i":["a","a","a"]},"\u201cPer-occurrence\u201d measurement is done every time a particular event occurs. The main forms of this measurement are counting the number of times an event occurs, or querying the time at the beginning and end of a work interval and subtracting to find the amount of time taken to perform that work. The \u201cinstrumentation\u201d to count the event or to measure the interval may be added to the code manually, or may be built-in to the code by a compilation tool. ) is an example of \u201cper-occurrence\u201d measurement in a software time profile where instrumentation is used to determine system events. Each test point (TP) in ) represents the beginning or end of an event, such as the beginning or end of a function within the software run profile.","The two techniques of sampling and per-occurrence profiling both have advantages and disadvantages. The per-occurrence measurement cannot be performed for code which does not contain any instrumentation. Also, duration timing measures nearly-exact running time, but the measurement itself can skew results by affecting the duration. For example, the work required to read the time on entry and exit to a function is much larger in proportion to the run-time of small functions than it is in proportion to the run-time of large functions. Per-occurrence measurement can also produce a very large amount of data if the occurrences happen very often. For example, logging the entry and exit of every function in an application shown in ) will add up quickly.","On the other hand, sampling, as in ) typically produces much less data. Rather than capturing every moment in time, time-based sampling is scaled back to sample at a relatively low frequency. In fact, the sampling frequency can be adjusted to suit the situation; sampling too often produces too much data, while sampling too infrequently leads to inaccuracy of measurement. For example, an ill-spaced sampling interval as in ) would miss two of the three occurrences of function FB. That inaccuracy is the disadvantage of sampling; since samples only provide you with captures for a very small portion of the overall whole, the result is only an estimate rather than an exact measurement. Chance sampling within functions that occur very rarely can make those functions appear to take a higher proportion of time than they actually do appear. Sampling is also susceptible to errors related to events that occur at the sampling interval. For example, if a profiler is sampling the processor instruction pointer once every 100 milliseconds, and some other event is occurring once every 100 milliseconds, then the profiler could possibly miss every instance of that event, or it could possibly hit every instance of that event, making it appear as though the event-handling code was running 0% or 100% of the time, respectively, when in truth the event-handling code would be running at some intermediate level between the extremes.","An ideal system would gather all of the data available and then process the data without affecting the run of the application. However, data memory and processing time are normally limited, so a better approach would be to take a minimum amount of data to gain a maximum amount of insight as to how a system was behaving during run time. However, that minimum amount of data is difficult to predict and instrument. Thus, there is a need for a technique which can perform a variety of profiling functions in a time efficient manner, gathering a reasonable amount of data, and produce results without greatly affecting the run time performance of the system under test. The present invention addresses the aforementioned needs and solves them with additional advantages as expressed herein.","An embodiment of the invention includes a method for profiling the software function calls of a system under development. A development system can include target software that a developer desires to optimize. The subject invention allows a user to track function calls made by the target application. These function calls can be made to functional aspects of the target application or to functional aspects of the operating system upon which the target application relies. The user is permitted to select between multiple modes which allow the selection between a level of intrusion and an amount of data collected by a profiler. In one aspect of the invention, a programmable interrupt is used to collect data from the stack of a processor executing the target code. The interrupt driven profiler is less intrusive because it uses user-programmable interrupts which are not compiled into the target code. This reduces the effect of profiling on the runtime operation of the target code.","In an embodiment of the invention, a profiler can collect instruction counter or program counter information from a call stack during a currently running software thread. The call stack data is collected when an application programming interface is activated via an interrupt handler. The captured call stack includes program counter information for the running application as well as within the operating system processes. An embodiment of the invention allows data to be captured in multiple modes allowing the user to select the amount of data to be collected as well as the level of program counter detail relative to the application and system processes.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2","b":["200","205","200","205","210","205"]},"The device side control application  serves to receive communications from the user interface  and communicate with the profiler application programming interface (API)  to start and stop the data collection functions of the call stack capture API . The profiler API  is part of the operating system kernel  of the embedded development system and also functions to transfer information concerning interrupt parameters, such as interval timing and a service routine address to the interrupt handler . After setup, the interrupt handler can then notify the profiler API  of the occurrence of an interrupt.","The call stack capture API  performs three functions. Once the interrupt is enabled, the interrupt will fire automatically at the specified interval. The interrupt handler  will inform the profiler API  to start a data collection session. The profiler API  enables the call stack capture API  to retrieve the call stack. The profiler API  also invokes an event logger to record the call stack for the currently-running thread. In one embodiment, the event logger is a straightforward text file recording mechanism that saves the call stack information. In another embodiment, the event logger is an embedded system data logger used to record both call stack information as well as other data. The event logger uses passes any collected information to a buffer .","The device-side control application  is responsible for eventually removing the call stack data from the buffer  and either communicating it back to the user interface  on the desktop PC, saving it in a file, or performing some other operation on the data. In an alternative embodiment, the user interface may be on the device side. Eventually, on prompt from the user, the device-side control application  will call the kernel profiler API  to stop profiling, at which point it will disable the profiling interrupt and flush any necessary data buffers. Thus, the level of activity in capturing call stack information is dependent upon the user settings. Also note that a re-compiling of the user application with test points is not required in the current invention as may be required with other prior art profilers.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3","b":["300","300","315","345","310","305"]},"For example, a sample at SP  yields a call stack that is indicative of the main application function  and application software function F , F , F  and the write to file call . The call stack request also retrieves the instruction pointers for system functions S  and S . Thus, using the call stack acquisition aspect of the invention, both system calls  as well as application calls  can be collected during a sample of the software process  thread. This ability can provide a body of rich information content for the embedded system operation.","Commonly assigned patent application Ser. No. 10\/940,454 entitled \u201cCall Stack Capture Using Interrupt Driven Architecture\u201d filed Sep. 15, 2004 discloses a method and system for acquiring the full application and system call stack and is herein incorporated by reference in its entirety. The above-referenced disclosure describes the operations performed to capture the call stack of the currently-running thread at the time a profiler interrupt occurs and is described below. The call stack information concerning the thread that was running is gathered when the profiler interrupt is generated. In one embodiment, an interrupt handler is not executed within the context of any thread, so the interrupt handler must obtain call stack information about the thread it interrupted. Once the call stack information has been gathered, it is supplied to the kernel profiler API. The kernel call stack capture API gathers a thread context in order to traverse the thread's stack. A thread context is a set of registers and other state information about the thread which varies within per CPU type. The traversal is performed even on non-x86 processors which do not store a frame pointer for each frame on the stack. In one embodiment of the referenced application, the interrupt handler alters the state of the thread to induce the thread to invoke the kernel's call stack API itself, using its own context. The handler performs this by saving some of the thread's registers into the thread's stack, and then changing the thread's program counter register to contain the address of some code which calls the kernel's call stack API. The process then restores the thread's saved registers from the stack and resumes what the thread was doing before the interrupt. This method of \u201cinjecting\u201d code into a running thread provides the call stack data to the kernel profiler API.","In one embodiment of the current invention of the present application, three operating modes are offered. In a first mode, the statistical sampling mode, the top most program counter in the call stack is acquired upon receipt and servicing of an interrupt. In a second mode, the full call stack mode, the entire call stack is acquired for each sample. This mode makes it possible to see where execution time is being spent anywhere in the system, including in operating system code. The third mode, the application stack mode, captures only the call stack up to the point where the thread leaves its source application. This mode makes it possible to see where execution time is being spent within only the application. For example, this mode of operation would access and record only call stack information that resides below level  in  and has the advantage of reducing the amount of gathered data by a significant amount. This mode also reduces the amount of intrusiveness of the profiler itself as well as the amount of performance impact related to storage or transportation of the gathered data.","In one embodiment of the invention, the above mentioned mode options may be provided to the user giving her the ability to gather extra system information unavailable in prior art profiling equipment. Providing the user with the ability to trade off between information and performance impact and data storage will make the profiler more usable for embedded device development. In many instances embedded devices are far more constrained than desktop PCs in terms of processor power or storage capacity. The desktop-side user interface  of  will provide options for choosing the call stack scope, so that users can make the tradeoff between level of detail and level of intrusion. The kernel profiler API  will also expose these mode options. When the profiler is turned on, it will store the user's settings, so that when the interrupt handler  calls the profiler API , the profiler API  can call the kernel call stack capture API  with the user's preferential mode and parameter settings.","In the first mode, statistical sample, the top most program counter during a series of interrupts is collected over time. The captured data is a stream of program counters from all the interrupts, where the program counter is the address of an instruction. The stream of data may appear as follows:","<addr>","<addr>","<addr>",". . . etc.","Where, since instructions can be executed more than once, the entries in the stream are most likely not all unique; that is, some addresses may be duplicated. Post processing of this data reveals the utility of capturing such data.","During post processing of mode 1 data, the program counter address data is matched to the function that the address corresponds to in the relevant software code. Then, the post processing counts up all the hits for all the functions. For example, if function Foo( ) is in memory between <addr> and <addr>, and the captured sample <addr> is between <addr> and <addr>, then we know that the captured sample was inside function Foo( ). Function Foo( ) would be entered into data corresponding to the span of two addresses within the code. All of the captured samples and added up the number of samples in each function is provided. At the end of this portion of post processing, the functions are sorted by the number of hits in each function, and a report is generated of the functions that had the most samples. Generally speaking, the number of samples per function roughly corresponds to the amount of time spent inside that function. In one embodiment, the processed data is may presented as functions with percentages as shown in Table 1:",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Function","No. of samples","Percentage of total"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Foo( )","300 samples","58%"]},{"entry":["Bar( )","200 samples","39%"]},{"entry":["Moo( )","\u200210 samples","\u20021%"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In another embodiment, the collected sampled data is added up according to all of the functions inside a software module, and the report includes the modules with the most hits. For example, if Foo( ) and Bar( ) are inside mycode.dll, then we will attribute all the hits from Foo( ) and Bar( ) to mycode.dll as shown in Table 2:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Module","Samples","Percentage"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mycode.dll","500 samples","98%"]},{"entry":[{},"other.dll","\u200210 samples","\u20021%"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"When a user is investigating a performance problem, and knows she spends 58% of her time inside function Foo( ), she has two options to reduce that time. One option is to make Foo( ) run in less time by reducing the work it does or improving its algorithm, and the second option is to call Foo( ) fewer times. A profiler having aspects of the current invention can help users identify what code they can rewrite to run in less time. But the user may still not be able to determine where the calls to Foo( ) are originating. A deeper level of information may be necessary and this deeper level is provided in modes 2 and 3.","In one embodiment, a variant of mode 1 captures a single call stack frame instead of capturing the top program counter. In general, the single frame can either be the top of the whole call stack including system calls or the top of the application's part of the call stack. The advantage of capturing only a single stack frame is that it reduces the performance impact of the profiler itself, and reduces other secondary effects such as network usage or storage consumption. By providing it as an option, this mode 1 single stack operation gives the user the ability to choose between gathering a large amount of data and corresponding detail for diagnosing problems and gathering a bare minimum of information.","In the single stack frame mode, the operation of the profiling system  of  is similar except that the call stack API  is not invoked. Referring to , the desktop-side user interface  will provide options to the user for choosing call stack scope, so that users can make the tradeoff between level of detail and level of intrusion. The kernel profiler API  will also expose these options. When the profiler is turned on, it will store the user's setting. If only a single stack frame is being captured, the profiler API  does not need to invoke the kernel call stack API . Instead, the profiler API  can copy the register that contains the interrupted thread's program counter. This greatly reduces the amount of work that must be done while servicing the profiler interrupt, as well as greatly reduces the amount of data used to store one profiler sample.","Mode two, full call stack mode, captures the entire call stack including system calls during an interrupt. The captured data is a stream of program counters plus call stacks from all the interrupts. In one embodiment, there is a process of mapping addresses to functions as previously described. A log of which functions were running at the interrupt sample times is also generated. As an example, suppose an application has function A( ) which calls functions A( ) and A( ). Function A( ) calls into system function S( ), which calls system function S( ). Function A( ) calls function A( ). To help illustrate, you might draw a call graph like that shown in . The data that the profiler captures while this program is running might look something like that shown in Table 3:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Function","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1","Sampled when A1 was the only function running"]},{"entry":["A1 to A2","Sampled while A2 is running, and was called by A1"]},{"entry":["A1 to A2 to","Sampled while S2 is running"]},{"entry":"S1 to S2"},{"entry":["A1 to A2 to","The same sample again, perhaps S2 was running for"]},{"entry":["S1 to S2","a very long time or was called more than once."]},{"entry":["A1 to A3 to","Sampled while A2 is running, but this time A2 was"]},{"entry":["A2","called by A3 which was called by A1."]},{"entry":["A1 to A3 to","Sampled while S2 was running called by S1 which"]},{"entry":["A2 to S1 to","was called by A2 which was called by A3 which was"]},{"entry":["S2","called by A1."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In mode 2, each sample is an entire call stack instead of a single code address as in mode 1. The stream of data is a set of call stacks, where each call stack may be repeated more than once. The call stacks are not captured at the moment the calls are made, but at the times when the profiler interrupt fires. The interrupt fires unpredictably from the point of view of what code is running in the target program. For example, on some runs the profiler interrupt may happen to never fire inside a call to S, and so no call stacks including S would be recorded. However, a greater granularity of data reporting can be obtained by setting the interrupt interval to be shorter as to capture an instance of a function within a target program.","In one embodiment, a number of reports are presented concerning the collected data set. For example, it is possible to derive the same data reported in mode 1 from mode 2 data. The program counter recorded in mode 1 corresponds to the top function on the stack that's recorded in mode 2. Table 4 shows how the mode 2 data from Table 3 can be processed to produce results similar to those in Table 1.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Module","Samples","Percentage"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["S2","3 samples","50%"]},{"entry":["A2","2 samples","33%"]},{"entry":["A1","1 sample","17%"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Similarly, one report can add up time inside the modules that S, A and A are inside. As part of another report, the mode 2 data can be processed to accumulate inclusive and exclusive sample counts for each part of the call graph. Where \u201cinclusive\u201d counts are the number of profiler samples that included that part of the graph, and \u201cexclusive\u201d counts are the number of profiler samples that were that exact graph. For example, post-processing could accumulate inclusive counts for all possible call graphs from the samples listed in Table 3 above. The results may be presented in a format similar to Table 5.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},{},{},"Inclusive %"]},{"entry":[{},"Graph","Inclusive count","(of 6 samples)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A1","6 (since all 6 samples from","100%\u2002"]},{"entry":[{},{},"Table 3 have the graph \u201cA1\u201d"]},{"entry":[{},{},"at the base)"]},{"entry":[{},"A1 to A2","3 (since 3 of the 6 samples","50%"]},{"entry":[{},{},"from Table 3 have the graph"]},{"entry":[{},{},"\u201cA1 to A2\u201d at the base)"]},{"entry":[{},"A1 to A2 to","2 (this is at the base of 2","33%"]},{"entry":[{},"S1","samples)"]},{"entry":[{},"A1 to A2 to","2","33%"]},{"entry":[{},"S1 to S2"]},{"entry":[{},"A1 to A3","2","33%"]},{"entry":[{},"A1 to A3 to","2","33%"]},{"entry":[{},"A2"]},{"entry":[{},"A1 to A3 to","1","17%"]},{"entry":[{},"A2 to S1"]},{"entry":[{},"A1 to A3 to","1","17%"]},{"entry":[{},"A2 to S1 to"]},{"entry":[{},"S2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Inclusive counts can provide an approximation of the amount of time that it took to call a function, from entry to exit. From the time the program entered A to the time it exited A, 100% of the program ran-time passed. From the time A called A until the time A returned, 50% of the program run-time passed. Accumulated exclusive counts for all possible call graphs from the samples listed above result in the data of Table 6.",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},{},{},"Exclusive %"]},{"entry":[{},"Graph","Exclusive count","(of 6 samples)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A1","1 (since one sample above is","17%"]},{"entry":[{},{},"just \u201cA1\u201d)"]},{"entry":[{},"A1 to A2","1 (since there is one sample","17%"]},{"entry":[{},{},"that is just \u201cA1 to A2\u201d)"]},{"entry":[{},"A1 to A2 to","0 (since there are no","\u20020%"]},{"entry":[{},"S1","samples that are just this"]},{"entry":[{},{},"graph)"]},{"entry":[{},"A1 to A2 to","2","33%"]},{"entry":[{},"S1 to S2"]},{"entry":[{},"A1 to A3","0","\u20020%"]},{"entry":[{},"A1 to A3 to","1","17%"]},{"entry":[{},"A2"]},{"entry":[{},"A1 to A3 to","0","\u20020%"]},{"entry":[{},"A2 to S1"]},{"entry":[{},"A1 to A3 to","1","17%"]},{"entry":[{},"A2 to S1 to"]},{"entry":[{},"S2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Exclusive counts correspond to a more in-depth version of the data than collected in mode 1. For example, if running Mode 1, a user could interpret that there are 3 samples in S and that S was executing for 50% of the program time. In Mode 2, a user can interpret that S had 2 samples where the call came from A to A to S, and 1 sample where the call came from A to A to A to S. Mode 1 data provides a percentage of time spent executing the code in S, but mode 2 data indicates how that time divides among the various functions that called S.","In one embodiment, the inclusive and exclusive counts can be presented together in a single graphic format such that a user could expand or collapse parts of the graph, to assist the discovery of subsets of data that are interesting to the user. For example, there are additional views that are possible with mode 2 data. A user may desire to generate a view that adds up inclusive and exclusive counts for subsets of the data. For example, the subset of all calls made by A, regardless of what function called A, can be presented as in Tables 7 and 8.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},"Inclusive % (of","Inclusive % (of"]},{"entry":[{},{},"the 5 samples","the 6 total"]},{"entry":["Graph","Inclusive count","that include A2)","samples)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A2","5 (five of the six","100%\u2002","83%"]},{"entry":[{},"original sampled"]},{"entry":[{},"callstacks include"]},{"entry":[{},"A2 somewhere in"]},{"entry":[{},"the middle)"]},{"entry":["A2 to S1","3","60%","50%"]},{"entry":["A2 to S1 to","3","60%","50%"]},{"entry":"S2"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},"Exclusive % (of","Exclusive % (of"]},{"entry":[{},{},"the 5 samples","the 6 total"]},{"entry":["Graph","Exclusive count","that include A2)","samples)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A2","2 (two sampled call-","40%","33%"]},{"entry":[{},"stacks have the sub-"]},{"entry":[{},"graph \u201cA2\u201d on the"]},{"entry":[{},"top)"]},{"entry":["A2 to S1","0 (no callstack has","\u20020%","\u20020%"]},{"entry":[{},"the sub-graph \u201cA2"]},{"entry":[{},"to S1\u201d on the top)"]},{"entry":["A2 to S1 to","3","60%","50%"]},{"entry":"S2"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Using mode 1 data, a user may only know that A itself was running for 33% of time; corresponding to the statistic that 33% of overall time was spent exclusively inside A. Using mode 2 data, a user can discern the exclusive and inclusive break-downs of what functions called A, what functions A called. Similarly, another view could add up the subset of all calls made to A, regardless of what functions A called afterwards as shown in Table 9.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},"Inclusive % (of","Inclusive % (of"]},{"entry":[{},{},"the 5 samples","the 6 total"]},{"entry":["Graph","Inclusive count","that include A2)","samples)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1 to A2","3","60%","50%"]},{"entry":["A1 to A3 to","2","40%","33%"]},{"entry":"A2"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In the third mode, the application stack mode, a call stack representing only the application portion of a call stack is collected and recorded as a result of a profile interrupt. Mode 3 is just like mode 2, except that we record only the part of the call stack that is within the application software thread. Using the same example program data as in the table 3 data of mode 2 data, the application only data would appear as in Table 10.",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Function","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1",{}]},{"entry":"A1 to A2"},{"entry":["A1 to A2","The call to S1 to S2 was not recorded, so this stack"]},{"entry":[{},"is indistinguishable from the previous one"]},{"entry":"A1 to A2"},{"entry":"A1 to A3 to"},{"entry":"A2"},{"entry":["Al to A3 to","Again, the call to S1 to S2 was not recorded"]},{"entry":"A2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Post processing the exemplary data in Table 10 as before in Table 5 results in the inclusive data of Table 11. Notice that although there are fewer rows in Table 11, the results do not vary from the results of Table 5.",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 11"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Graph","Inclusive count","Inclusive % (of 6 samples)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A1","6","100%\u2002"]},{"entry":[{},"A1 to A2","3","50%"]},{"entry":[{},"A1 to A3","2","33%"]},{"entry":[{},"A1 to A3 to A2","2","33%"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Similarly, the exclusive results from Table 10 are provided as in Table 12. Notice that there are fewer rows than Table 6 from which to add exclusive counts, and the exclusive results of Table 12 are different from the mode 2 data of Table 6.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Graph","Exclusive count","Exclusive % (of 6 samples)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A1","1","17%"]},{"entry":["A1 to A2","3","50%"]},{"entry":["A1 to A3","0","\u20020%"]},{"entry":["A1 to A3 to A2","2","33%"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 5","b":["500","505","510","515"]},"Once an interrupt is received (step ), an interrupt handler services the interrupt by acquiring call stack information. This call stack information can include both application and system level program counter and other ancillary information. Depending of the mode selected by the process  records the call stack information (step ) in a variety of data levels. In a first mode, only a top most program counter information is recorded. This information could be an address of code in either a target application or in the operating system. In a second mode, stack data with addresses of both target application and target operating system code is recorded. In a third mode, only the stack data for a target application is recorded.","Once recorded, the process  awaits the receipt of another interrupt (step ). Another interrupt may occur as a result of the appearance of a programmed interrupt or an expectation by the controller application that another interrupt will occur. If another interrupt does occur, then the process  receives another interrupt (step ) and steps  and  are repeated.","If another interrupt is not expected, if a timeout occurs, or if the user terminates the process, then post-processing begins (step ). Post-processing retrieves information concerning the call stack information for each interrupt received and serviced. The call stack information may be processed to develop statistics concerning the operation of the application or operating system at the time the interrupts occurred. The post-processing may include generating statistics corresponding to the mode of operation of data collection. If application data only is collected, then only application data is processed into statistical information. But if both application and system data is selected via the user selected mode, then both may be processed. The processed data may include statistics concerning the percentage of time that a specific function was operating as a result of executing the target code. The function could include an application function or a system function as reflected by the user selected mode. The data can be a listing of the functions entered and exited, or it may be more complex counts of occurrences of call stacks including or excluding the sub-calls made from those stacks.","Upon generation of statistics concerning the data collected in the user-selected mode (step ), the post processed data and statistics may be displayed to the user (step ). This display of results may be in the form of graphs, tables or figures, and format selection may be dependent on user preferences.","Exemplary Computing Device",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 6"},"Although not required, embodiments of the invention can also be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, appliances, lights, environmental control elements, minicomputers, mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network\/bus or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 6","b":["600","600","600","600"]},"With reference to , an exemplary system for implementing an embodiment of the invention includes a general purpose computing device in the form of a computer system . Components of computer system  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer system  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, Random Access Memory (RAM), Read Only Memory (ROM), Electrically Erasable Programmable Read Only Memory (EEPROM), flash memory or other memory technology, Compact Disk Read Only Memory (CDROM), compact disc-rewritable (CDRW), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer system , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer system  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM, CDRW, DVD, or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer system . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer system  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory (not shown). In addition to monitor , computer systems may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer system  may operate in a networked or distributed environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer system , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer system  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer system  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer system , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web-enabled interface for applications and computing devices, making computing activities increasingly Web browser or network-oriented.","For example, MICROSOFT\u00ae's .NET\u2122 platform, available from Microsoft Corporation, includes servers, building-block services, such as Web-based data storage, and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device, one or more portions of an embodiment of the invention may also be implemented via an operating system, application programming interface (API) or a \u201cmiddle man\u201d object between any of a coprocessor, a display device and a requesting object, such that operation may be performed by, supported in or accessed via all of .NET\u2122's languages and services, and in other distributed computing frameworks as well.","As mentioned above, while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to implement a software program profiler for an embedded system. Thus, the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages, names and examples are chosen herein as representative of various choices, these languages, names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same, similar or equivalent systems and methods achieved by embodiments of the invention.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the signal processing services of an embodiment of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While aspects of the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Therefore, the claimed invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of exemplary embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating embodiments of the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 1(","i":["a","b"],"b":"1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
