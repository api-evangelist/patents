---
title: Information validation
abstract: A computer implemented method for knowledge validation includes identifying a fact for validation. A semantic model representing the fact for validation can be created. A context associated with the fact can be identified, and an automaton can be created based at least in part on the identified context. The fact can be validated using the automaton.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08805769&OS=08805769&RS=08805769
owner: SAP AG
number: 08805769
owner_city: Walldorf
owner_country: DE
publication_date: 20111208
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DESCRIPTION OF TABLES","DESCRIPTION OF ALGORITHMS","DESCRIPTION OF LISTINGS","DETAILED DESCRIPTION"],"p":["This invention relates to information validation, and more particularly to content-based knowledge validation using, for example, deterministic finite automata.","Structured data can be used to graphically display the information to a user or used for programmatically processing. Invalid information, which may come from different sources, may compromise the quality of structured data. Validation of the information may preserve the quality of structured data according to its model, e.g., consolidated model in the business trading network domain.","In general, this disclosure pertains to content-based validation of knowledge (structured data). It includes the validation of the content of the detected and injected knowledge, as well as its conformance with a given model, e.g. the Consolidated Model. The validation includes the validation of (user defined) dependencies of the knowledge. This disclosure describes a design and implementation of a system, method, and computer program product that validates the knowledge shown for the trading web of an enterprise according to the Consolidated Model.","In certain embodiments, a computer-implemented method for knowledge validation may include identifying a fact for validation. A semantic model may be created, the semantic model representing the fact for validation. A context associated with the fact may be identified, and an automaton can be created based at least in part on the identified context. The fact can be validated using the automaton.","In certain embodiments, a computer program product for knowledge validation may be stored on a tangible, non-transitory media, operable to execute instructions that can include identifying a fact for validation. A semantic model may be created, the semantic model representing the fact for validation. A context associated with the fact may be identified, and an automaton can be created based at least in part on the identified context. The fact can be validated using the automaton","Certain implementations of the embodiments can also include identifying a consolidated model. The consolidated model can include information about business trading networks within and between companies. The fact for validation may be associated with the consolidated model.","In certain implementations of the embodiments, the automaton is a deterministic finite automaton. The deterministic finite automaton may be derived from an epsilon non-deterministic finite automaton. The deterministic finite automaton may be defined by one or more of a state, an input symbol, a transition function, a starting state, and a final state. The final state can be an accepting state, and the automaton can enter the accepting state after successfully validating the fact.","In certain implementations of the embodiments, the automaton is created based, at least in part on, the semantic model.","In certain implementations of the embodiments, the semantic model further represents fact dependencies associated with the fact.","In certain implementations of the embodiments, the fact to be validated may be a subset of the context.","In certain implementations of the embodiments, creating an automaton based at least in part on the identified context may include creating an automaton for each instance of a model entity.","In certain implementations of the embodiments, the fact may be a Datalog fact.","In certain implementations of the embodiments, the fact may be one or more of a fact, knowledge, or data.","Certain implementations of the embodiments can also include providing a runtime graphical output identifying error states.","Certain implementations of the embodiments can also include providing a runtime textual log output identifying errors.","In certain implementations of the embodiments, validating the fact using the automaton can include validating one or more of structure or content of structured data.","In certain implementations of the embodiments, a domain specific language may be used for a programming model to specify a validation program.","In certain implementations of the embodiments, a validation program can be generated from the semantic model. The semantic model may be in a domain specific language, and the automaton can be generated at runtime from the semantic model. The automaton can be generated automatically by an intelligent algorithm.","In certain implementations of the embodiments, the fact is a fact in a consolidation model, the consolidation model subject to validation by the automaton.","The systems, methods, and computer program products described here in apply to the quality of structured data in different dimensions (structure, content, etc). This disclosure provides an automatic but configurable structure and content validation of structured data. A Domain Specific Language (DSL) or fluent Application Programming Interface (API) can be used for a programming model to specify a validation program. The validation program is generated from, for example, the DSL, and is called a semantic model. From the semantic model, a runtime model is generated, for example, as an automaton. In certain implementations, the automaton is automatically generated by intelligent algorithm. The runtime model is able to run different evaluation procedures such as top-down, bottom-up or random evaluation of the validation program.","The approach described herein is designed for efficient storage and loading of data, parallel processing of validation programs, as well as shared memory computing (e.g., concurrency for validation programs defined).","The approach is applicable for the validation of facts, which may be a part of a Datalog program. Datalog facts are structured and thus applicable to the disclosure. The techniques described herein are also applicable to complex fact models, e.g., the consolidation model described herein, and the techniques described herein can be used to validate facts for that domain (e.g., model-based validations).","The validation programs are debuggable to make the validation programming model usable as any other programming language. Debugging can be facilitated by graphical and textual outputs for real-time debugging.","This disclosure provides for defining a configurable but automatic validation schema as a programming model in the area of regular and context sensitive languages. It allows for domain-specific data quality and allows for various kinds of checks, such as value lists, structural, etc. Validation programs can be written by persons of varying degrees of knowledge in programming.","States apply to operators of a validation program. These states can be self-defined and thus the techniques described herein can be extended by custom validation operations, such as filter states, length checks, starts with or ends with checks for strings, boundary checks for numeric types, etc.","The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the invention will be apparent from the description and drawings, and from the claims.","Table 1 is an extract of an example of discovered facts used in the consolidation algorithm of .","Table 2 is an extract of discovered facts in an example extended consolidated model.","Algorithm 1 is an example algorithm for determining the state list for a fact.","Algorithm 2 is an example algorithm for determining the level of a fact model.","Algorithm 3 is an example algorithm for preprocessing for fact validation.","Algorithm 4 is an example algorithm for determining a next state for the automaton.","Algorithm 5 is an example algorithm for validation of a fact.","Algorithm 6 is an example algorithm for fact validation post-processing.","Algorithm 7 is an example algorithm for a fact validation transition function.","Algorithm 8 is an example algorithm for determining dependency facts of an argument.","Algorithm 9 is an example algorithm for determining a return state for a fact validation transition function.","Listing 1 is an example excerpt from a definition file.","Listing 2 is an example textual output of the automaton for a valid data fact.","Listing 3 is an example description of a dot graph for a valid data fact.","Listing 4 is an example definition file for a runs_on fact with an invalid system fact.","Listing 5 is an example textual output of an automaton for a runs_on fact with an invalid system fact.","Listing 6 is an example definition file for a runs_on fact with a corresponding system Fact and no data Fact.","Listing 7 is an example textual output of the automaton for a runs_on fact with an invalid system fact.","Listing 8 is an example textual output of the automaton for an invalid runs_on fact.","Listing 9 is an example definition file for a valid runs_on fact.","Listing 10 is an example textual output of the automaton for a valid runs_on fact.","Like reference symbols in the various drawings indicate like elements. The algorithms and code listings described in this disclosure are meant to illustrate examples. Other algorithms and code not shown here may be applicable","Subsequently the example domain (Business Trading Web) is discussed to which the subject matter disclosed herein can be applied. It is understood, however, that the subject matter is not limited only to that domain. For example, the subject matter described herein can be used for any structured data, including that associated with the consolidation model described below. In addition, the subject matter described herein is applicable for other domains, such as input to deductive systems, data quality validation for linked data community, process mining, etc.","The Business Trading Web is a software developed by SAP AG that graphically gives a central overview of the trading networks of enterprises. In order to do this, information about the customer landscape is collected, consolidated and stored in a model, whose logical knowledge representation is implemented in Datalog. As users can affect the injection of facts by developing their own data extractors and processors, the facts have to be validated according to their content and interdependencies to ensure a consistent knowledge base. To tackle this issue, a programming model, based on Deterministic Finite Automata, has been developed. It allows to generically process knowledge encoded in Datalog and it empowers custom extensions to the validation logic.","This disclosure discusses different methods of content-based fact validation and gives a detailed description on the concept, implementation and programming model of the fact validation using Deterministic Finite Automata. The implemented Fact Validation Automaton (FVA) facilitates the distributed validation of facts in a given context using different validation strategies. The validation can be manipulated by the definition of the structure of the facts using a domain-specific language. Moreover, for the FVA, custom states containing validation logic can be implemented. Furthermore, this disclosure describes the application of the developed FVA in the context of the Business Trading Web. It evaluates different root causes in this context and shows performance measurements for different validation strategies. Additionally, there is some guidance on debugging, i.e., analyzing the reason for a fact being invalid.","Enterprises manage their knowledge, which does not only include the skills and competencies of the employees, but also information about the variety of business networks that the enterprise participates in. However, independent of the amount of knowledge that is collected and managed, the benefits of the knowledge are only as good as its quality. The knowledge has to be consistent, thus it needs to be validated.","The Business Trading Web is a software that collects information about business trading networks within and between companies and stores them in a model (called the","Consolidated Model) in order to graphically display them to the user. However, as there are different causes of invalid information (e.g., the possibility for users to inject facts manually), the information has to be validated in order to preserve the quality of the knowledge about the business trading networks. Therefore, the main topic of this thesis is the content-based validation of knowledge. It includes the validation of the content of the detected and injected knowledge as well as its conformance with the predefined Consolidated Model. This includes the validation of possible dependencies of the knowledge. However, this research does not include the validation of the Consolidated Model itself in terms of completeness or consistency.","Enterprises have large business trading networks that execute their business processes in a non-central controlled way. Business trading webs are formed by different kinds of business networks, resulting from contracts, virtual organizations, subcontracting, franchising, joint ventures, holding organizations and others. Until now, there is no way to gain a central overview, neither within the enterprise nor between enterprises. It is very complex to outline a network that results from the Business to Business (B2B) processes between enterprises, which are processes of selling a good or service to another enterprise.","That means, if different information technology, middleware, and applications have to be managed, this can only be done with big effort. For example, the knowledge about the \u201cas-is\u201d network has to be gathered from domain experts or documentation, if available. Middleware can be considered as an abstract software layer that enables the platform-independent communication between application systems and data sources without regard to the used programming language and communication protocol.","Therefore, the Business Trading Web is being developed. Its aim is to precisely and explicitly express a company's business trading web. Thus, it makes the B2B relations of a networked enterprise visible and eases the end-to-end lifecycle behind integration developments as well as applications and allows collaboration on different interlinked information for faster execution. In order to do this, the Business Trading Web facilitates an automatic generation of the \u201cas-is\u201d network from real instances of business, social and integration artifacts. It also enables different people to collaborate on the definition of the \u201cto-be\u201d aspects on the inferred network. This can possibly be done blueprint-based, which means that the \u201cto-be\u201d network is newly created, for example as Event-driven Process Chains (EPC) or white-board drawings, without using the already existing \u201cas-is\u201d aspects. Furthermore, they can contextualize and enrich the inferred network with business semantics (e.g., business tags or document entities). In addition to that, it is possible to define policies and Service Level Agreements (SLA), which are contracts about the cost, price and aims, service level and the quality of a running system as well as the procedures if the agreements are not fulfilled. It is also possible to write back changes into the original data sources. The network can be monitored for business and integration exceptions or events, which can be resolved collaboratively at any time.","The benefits of Business Trading Web include trading web visibility, partner onboarding, business exception management and contract determination. All of the features can be done in the context of the customer's own trading web.","The creation of the business network graph, which is shown in , is facilitated by different layers.  are activity diagrams  of the Business Graph Engine. There are different layers involved in the creation of the business network graph. The lowest layer, Network\/Customer Landscape layer , where the information about the business trading web is extracted, is on the right side. The highest layer, Business Graph User Interface\/Application , where the graph is displayed, is on the left side of . The Network Source Layer  searches for sources in the Network\/Customer Landscape . Certain Domain Analysis components, which are part of the Network Source Layer  and contain domain-specific knowledge to read and process the information from the systems, get the data from the source systems using a Connector Infrastructure. A Connector communicates with the systems in this landscape, for example via Hypertext Transfer Protocol (HTTP) or Enterprise Services, and loads the information about them. For example, a Discover Data component  connects to an Extract Data component  over a secure channel. Extract Data  is connected to Process Data Analysis to Facts , where the information is stored in the form of facts. The next step is to provide the facts via an exported file or a published atom feed (Publish Analysis Facts ) to the Network Consolidation Layer . This is done in the Demilitarized Zone (DMZ) , which generally is a subnet in a computer network that allows access to servers that need to be reached from outside the intranet without allowing the access to it. In the context of the Business Graph Engine , the facts may be accessed from the Network Consolidation Layer , which may be in the Cloud, which means it is not installed on the client's computer. The facts are extracted, however, from the Network\/Customer Landscape layer . In order to separate these two layers, there is a DMZ . The Linked Data Engine , which consists of the Network Integration Model Layer  and the Network Consolidation Layer , uses the preprocessed facts out of the DMZ  and the corresponding rules to consolidate the facts using an inference algorithm .","The inference algorithm  includes a consolidation process. The consolidation includes the discovered data and also the information that has already been stored in the knowledge base. During consolidation, the information about the systems is translated into a common format (e.g., like that of the Consolidated Model). This model will be explained further below. After consolidation, the Consolidated Model is persisted. The next step is to transform the Consolidated Model into a Network Integration Meta-Model (NIMM) resource graph . The NIMM model  is an extension and specialization of Business Process Modeling Notation (BPMN) 2.0, which is a graphical standard to model business processes within and across companies. Therefore, the NIMM  describes different entities and their relationships within and across companies. This is done in the Network Integration Model Layer . Finally, in the Business Graph User Interface\/Application , the business graph can be resolved and displayed  on the user interface.","The Business Graph is a graph that consists of different enterprises and people, but also networks of systems and applications that collaborate with each other. Generally, Business Graphs of large enterprises are composed of two networks: one network of applications and middleware for internal processes and another one for external processes used for the interaction with business partners (e.g., suppliers, carriers, or dealers). Even though it might not be obvious, a huge amount of data in Enterprise Resource Planning (ERP) systems comes from outside of networked enterprises. The cause of this is, that in reality, Business to Business (B2B) processes are often implemented as a transactional exchange of documents with business partners in order to do business more collaboratively. This leads to a linked-data architecture style in the context of partner networks and relationships. Therefore, there is a strong need for orchestrating processes across multiple enterprises. Orchestration is the description of executable business processes and their interaction with internal and external web services as well as their interaction. A generalized view, which combines connectivity, business and social aspects, can be described as a Linked Business Graph.","A typical traditional technical network is shown in .  is a schematic representation of an example trading network landscape .  shows an excerpt of a more integration-oriented business trading network that consists of systems in the Intra- and Internet. On these systems, there are different applications and middleware running and interacting with each other. For example, System A  includes Application A and Enterprise Service Bus (ESB)-A, which may be an Enterprise Service (ES) proxy, which is a web-service-based application proxy, which is of the category of system embedded integration. Systems connected in the Intranet may communicate with each other, or may communicate with Systems in the DMZ or across the Internet. For example, System D  communicates across a firewall with System , which in this case is a B2B Gateway. This customer landscape might be implemented by integration consultants and architects and it may be administrated by IT-operations and administration persona. At this point of time, a general view of the complete network can only be accomplished by gathering the integration knowledge in the enterprise. Furthermore, this business trading web is implicit, which means it only shows the systems and the relationships between them. However, the enterprises in a business trading web play different roles (e.g., customer or vendor) depending on the type of business partner interaction. This information and the corresponding semantics are hidden in master data, business processes and domain specific configurations.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":["FIG. 3","FIG. 3"],"b":["300","302","304","306","308","310","310","312","314","300"]},"The Linked Business Graph, which the user looks at on his screen, is based on a model: the Consolidated Model. As mentioned above, a first raw form of the Consolidated Model is formed by adopting the domain-specific information gathered by the Network Analysis. Using this raw data, the consolidated network, which is a view on the network across different application and integration systems as well as business aspects, is determined by the consolidation mechanism. The mechanism contains just the amount of information to fulfill this task.","The structure of the Consolidated Model is shown in .  is a schematic representation of a Consolidated Network Model . This model shows the main participants and relationships of a Business Trading Web.  illustrates certain participants within business networks. The main participants are systems (e.g., system  and hosts ). A system is a logical entity that can be assigned to a physical entity (i.e., host) using the runsOn semantic. The relationship between two systems can be defined by MessageFlows  or SystemLinks . Furthermore, a MessageFlow , which represents an exchange of messages between two participants, may also exist between a system and a configuration or between two configurations. Configurations belong to systems and describe technical or business information about a relation between systems. There are two types of configurations: incoming configurations, which indicate incoming MessageFlows, and outgoing configurations, which express outgoing MessageFlows.","One important characteristic of the Consolidated Model is that all entities except the semantics runsOn , sameSystem , and sameHost  and the systemProperties  fact are linked to a data entity, which contains technical information about them, e.g., their URI. Consequently, there has to exist one data entity that matches the corresponding entity.","In general, the idea is to represent a physical host as Participant and afterwards find the interfaces provided or called by this hosts and the systems running on it. Different kinds of systems have different applications and integration logic running on them. For the consolidation, integration logic and business entities are unified by the term system. The brackets [ ] in  indicate the type of analysis and discovery of the data: [user] means the information was injected by a user, while [bus] or [disc] mean business or integration-related data.","The discovered information that the Consolidated Model deals with, is formalized using facts (such as Datalog facts). Datalog is one kind of the representation of knowledge using first-order logic. That is, it is a language that expresses operations on relations using Horn clauses. In general, a clause is the sum of an amount of literals. A literal is an atomic formula or a negated atomic formula. One part of an atomic formula is the predicate symbol p. As each atomic formula has one predicate, the first-order logic is also called predicate logic. The other part of the atomic formula is a list of arguments (q). Therefore, it can be noted in the following way:\n\np(q, q, . . . , q).\n\nIn general, a Horn clause is a clause that has, at most, one positive literal. There are different kinds of Horn clauses:\n\n","This rule means that if pand pand . . . and pare true, then h is true. The storage of rules in the knowledge base is called Intentional Database (IDB).","Furthermore, a collection of Horn clauses is called logic program. This program is executed by a Datalog engine which applies logical inference on the facts and rules. The Business Trading Web engine uses a special Consolidation Algorithm to do so. It is coordinated and executed by the Consolidator, which delegates large parts of the analysis to specific Explore and Analyze components that interact with the specific source models. Therefore, the Consolidator is able to stay independent from the source models of different systems.","As aforementioned, the Consolidation Algorithm is described as a set of rules (e.g., Datalog rules), which are used to derive new facts from the discovered ones. All facts that are processed by the Consolidation Algorithm are explained in Tables 1 and 2. Table 1 is an extract of an example of discovered facts used in the consolidation algorithm of . The table shows a selection of discovered facts, their meaning and in which step of the Consolidation Algorithm they were discovered.",{"@attributes":{"id":"p-0099","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Extract of the Discovered Facts Used in the Consolidation Algorithm"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Step","Fact","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["1","host_discx(name, description,","relates a name to the unique URI of a host."]},{"entry":[{},"hostURI)","It may also contain a description of the"]},{"entry":[{},{},"host."]},{"entry":["1","same host_discx(hostURI1,","defines an equivalence relation on two"]},{"entry":[{},"hostURI2)","hosts."]},{"entry":["1","system_discx(name, description,","relates a name to the unique URI of a"]},{"entry":[{},"systemURI)","system. It may also contain a description"]},{"entry":[{},{},"of the system."]},{"entry":["1","same system_discx(systemURI(1),","defines an equivalence relation on two"]},{"entry":[{},"systemURI(2))","systems."]},{"entry":["1","runs_on_discx(systemURI, hostURI)","connects a system to the host it runs on."]},{"entry":["2","incoming_discx(systemURI,","relates the URI of a system to a congURI"]},{"entry":[{},"interfaceName, interfaceNamespace,","which may be used to find more"]},{"entry":[{},"congURI)","information about the incoming call"]},{"entry":[{},{},"configuration of a system. It also contains"]},{"entry":[{},{},"the name of the interface used. The"]},{"entry":[{},{},"namespace of the interface is optional."]},{"entry":["2","outgoing_discx(systemURI,","relates the URI of a system to a congURI"]},{"entry":[{},"interfaceName, interfaceNamespace,","which may be used to find more"]},{"entry":[{},"congURI)","information about the outgoing call"]},{"entry":[{},{},"configuration of a system. It also contains"]},{"entry":[{},{},"the name of the interface used. The"]},{"entry":[{},{},"namespace of the interface is optional."]},{"entry":["3","message flow_discx(senderURI,","relates the URI of a sender and a receiver to"]},{"entry":[{},"receiverURI, messageFlowURI)","the messageFlowURI, which may be used"]},{"entry":[{},{},"to find more information about the"]},{"entry":[{},{},"messageFlow. A sender can be either a"]},{"entry":[{},{},"system or an outgoing call configuration"]},{"entry":[{},{},"while a receiver can be either a system or"]},{"entry":[{},{},"an incoming call configuration."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0100","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Extract of the Discovered Facts in the Extended Consolidated Model"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Fact","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["binding_discx(congURI,","relates the URI of a configuration to a"]},{"entry":["transport,messageProtocol, bindingURI)","bindingURI, which may be used to find"]},{"entry":[{},"more information about the binding. It"]},{"entry":[{},"may also contain the transport and message"]},{"entry":[{},"protocols used."]},{"entry":["operation_discx(congURI, operationName,","relates the URI of a configuration with an"]},{"entry":["message, operationURI","operationURI, which may be used to nd"]},{"entry":[{},"more information about the operation. I"]},{"entry":[{},"may also contain the name of the operation"]},{"entry":[{},"and the message protocol."]},{"entry":["application_discx(systemURI,","relates the URI of an application running"]},{"entry":["applicationName, version, applicationURI)","on a system to the URI of the system. It"]},{"entry":[{},"may also contain the application name and"]},{"entry":[{},"its version."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"figref":["FIG. 5","FIG. 5"],"b":"502"},"As mentioned above, the problem is that there is no universal identification scheme. For example, over time, different Domain Name System (DNS) names can be used for a host with a specific IP address, and vice versa. To solve this problem, equivalence classes are created over the set of all possible identifiers. One equivalence class contains all identifiers that are known to identify the same system or host. As at least one element of an equivalence class does not change when the others change, the identification of hosts and systems can be maintained over long periods of time while there is a constant but gradual change. The process of adding new and removing outdated information is continuous. Consequently, the way of determining which information is relevant and which is outdated is done by adding a timestamp to each piece of discovered information.","Then, the determination of the incoming and outgoing calls from a system is performed . Using the source models, it is possible to determine incoming and outgoing calls between different systems. It is assumed that on one hand, there is an incoming call configuration for most of the incoming calls to a system (but probably not for all). On the other hand, there should be an outgoing call configuration for most outgoing calls of a system. However, for some cases, such as Remote Function Calls (RFC), where a function of a system is called by another system, there are no incoming call configuration required other than the function that is being used remotely. Therefore, no configuration can be detected. The result of this step should be an outgoing and incoming call graph for a system with a particular identifier, such as shown in .  is a schematic representation of an outgoing call graph for a system . The uniquely identified system S has different outgoing call configurations (e.g., OCx , OCa ), which directly or indirectly connect it to other systems.","The next step is the determination of message flows from a system based on outgoing calls . As outgoing calls are directed towards a specific system, the corresponding call configuration often contains the identifier of the system that receives the call. In this case, the identifiers will be matched against the identifiers of the systems discovered in the first step. This step will result in an extended call graph for a system with a specific identifier, as shown in . This happens by adding the systems to which an outgoing call configuration exists.  is a schematic representation of an example extended call graph for a system . The uniquely identified system S has different incoming call configurations (e.g., ICz  and ICy ), which are connected to outgoing call configurations (e.g., OCb ) for other unique systems (e.g., S) via message flows.","Then, the message flows to a system based on incoming calls are determined . For each incoming call configuration of a particular system, the identifier of the calling system is matched against the systems found in step . This is similar to step , but in this case the algorithm searches for systems sending to the system being inspected, while in step , it was looking for systems that received calls from the examined system. However, even though it is common to find a receiver in an outgoing call configuration, it is not very common to find a sender in an incoming call configuration. The reason for this is very simple. For example, person A can send a post card to another person B. In order for the post card to reach B, A needs to write the address of B on it, otherwise the post office would not know where B lives. However, for the post office, it is not relevant to know where A lives. Therefore, in order to bring the post card to B, it is not mandatory for A to write his or her address on the post card. The same is true for systems and call configurations. For that reason, a lot more outgoing\/receiver pairs will be discovered than incoming\/sender pairs. All in all, this step will further extend the graph formed by step  as it will add the systems from which incoming calls are received. An example for the resulting graph is shown in .  is a schematic  of an example extension of the call graph by adding systems. The system S communicates with the other systems (e.g., S) directly or indirectly via its incoming call configurations (e.g., ICa ) and the outgoing call configurations of the other system (e.g., OC ). The addition of the systems that the communication comes from further extends the call graph.","In the next step, the call graphs for the systems are merged and the Network is formed . In this step, the algorithm will try to determine more message flows by matching already discovered incoming and outgoing call configurations from different identified systems. This is done by matching compatible message types or protocols. It is possible that some incoming call configurations do not match the already identified outgoing call configurations or the other way around. Nevertheless, these configurations are still kept in the Consolidated Model. After this step is successfully done, there will be some additional links between the already created graphs.  is a schematic of a merged graph  for the system Sas a result of Steps ,  and  (of ). This graph  shows all systems (e.g., S) and configurations (e.g., OCa  and ICz ) that are directly or indirectly communicating with system S via message flows.","The next step links the message flows with the application and integration content . The reason for this step is that the result of the previous steps is a view on the network, but the discovered message flows only represent the communication between hosts and systems. However, outgoing call configurations may also have a link to application and integration content which is deployed and running on the systems. For an application host or system and a specific outgoing or incoming call configuration, the link to a particular application proxy or to the system itself is determined. This is important because there might be a lot of applications running on one host at the same time. For an integration bus, enterprise service bus or B2B gateway and a particular incoming call configuration, this step determines one or a set of outgoing call configurations. This is referred to as an integration process later.","The final step is the incorporation of user enrichment . The quality of the Consolidated Model will improve over time as the algorithm gathers information from different data sources. Furthermore, it can learn from direct user input, also called \u201cuser enrichment.\u201d These facts are marked by the postfix user to highlight the different origin compared to the discovered facts, which are indicated by the postfix_discx.","Even though they are not mentioned in the steps of the Consolidation Algorithm, there is more information that the Consolidated Model administrates, for example about interfaces of system or applications that run on systems. These types of information are not (yet) processed during the consolidation. Nevertheless, they should be displayed on the Linked Business Graph.","In order to ensure the Consolidated Model to be consistent, the facts have to be validated. In the context of the Business Trading Web (see ), knowledge validation is a process which ensures that all facts in a fact set are consistent. This implicates that each fact belongs to the model of the Business Trading Web, i.e., its structure is as expected and it contains the essential information needed to create the business graph. Therefore, validity includes\n\n","The incentive for knowledge validation is to prevent the knowledge base from becoming inconsistent due to different causes. There may be implementation errors in the data discovery and extraction from the source systems. For example, when there is a change in the source code of these components, the discovery may not work correctly anymore and thus distort the rather correct facts. In order to notice these implementation errors, the knowledge validation may be useful. Furthermore, users are allowed to inject facts as well. This is also a potential source of incorrect and inconsistent facts. Finally, customers or partners may build their own \u201cfact providers\u201d, which extract facts from source systems and thus are possible causes of incorrect facts. Irrespective of the source of the facts stored in the knowledge base, they ought not cause the whole knowledge base to become inconsistent. For these reasons, the validation is crucial.","As mentioned before, the knowledge base is supposed to be consistent. Therefore, a validation before the persisting of the facts seems to be reasonable. The best point of time is during or after the inbound processing of the facts because if the validation is done right before the persisting process, the whole consolidation process has been finished. If there is one invalid fact, it is reasonable to detect it before the consolidation process starts. On the other hand, as the Datalog facts may also be exported into the standard \u201cfact providers\u201d or the ones compiled by the partners or customers, another reasonable point of time is before the export of the facts. This ensures that only valid facts are exported.","Deterministic Finite Automata may be used for fact validation. Technical systems may behave based on events. That is, they stay in a state until a specific event happens. Depending on their state and the event, they react with a specified action. Thus, the state is the \u201cmemory\u201d of the system. Consequently, an event has two effects. On one hand, it causes the machine to noticeably react and on the other hand, it may lead to a change of the machine's internal state.","This concept can be applied for the issue of fact validation. The input of a fact causes the set of facts to be either consistent or not. Furthermore, looking at the issue more granular, the validation of an argument may cause the fact to be valid or not. Therefore, this issue can be solved using the concept of Finite Automata, which are automata with a finite set of states. There are two kinds of finite automata: acceptors, which accept or decline an input, or transducers, which read an input and use it to generate an output.","The matter of fact validation has to be done by an acceptor automaton as it either accepts a valid fact or declines an invalid fact. However, before the finite automata can be further introduced, some main concepts of automata theory have to be brought up. There is the alphabet \u03a3, which is a finite, nonempty set of symbols. For example, the alphabet\n\n\u03a3={\n\nrepresents all lower-case letters. Furthermore, a string is a finite sequence of some alphabet's symbols. If a string consists of zero symbols, it is called the empty string (\u03b5). The amount of symbols that form a string w is called the length of the string, which is |w|. For example, the length of the empty string |\u03b5|=0. For any alphabet \u03a3, the set of all strings of a certain length k are expressed as \u03a3. For any alphabet \u03a3, the set of all strings with the length 0 is \u03a3={\u03b5}. This means that the only string whose length is 0, is the empty string \u03b5. Taking the example alphabet with the lower-case characters, the set of strings with the length 2, \u03a3={aa, ab, ac, . . . , zz}. The set of all strings over an alphabet \u03a3 is denoted \u03a3*, which is defined as\n\n\u03a3*=\u03a30\u03a31\n\nThe set of all strings chosen from some \u03a3* for a particular alphabet \u03a3is also called language. For so me alphabet \u03a3, L is the language over \u03a3, if\n\nL\u03a3*\n\nThe only constraint of a language is that all alphabets are finite. Even though they may have an infinite number of strings, languages are restricted to only contain strings that are in one fixed, finite alphabet. The decision of whether a given string is a member of a given language is called a problem. For fact validation, the problem is to decide whether a fact is valid, i.e., whether it is a member of the language which only consists of valid facts.\n","As already mentioned above, there are different types of automata. There are finite and non-finite automata. One type of a finite automaton is the Deterministic Finite","Automaton (DFA), which is a finite automaton that can only be in one state at the same time. In response to some input, there is a transition to one state out of the set of states of the DFA. In contrast to Nondeterministic Finite Automata (NFA), which can be in more than one state at the same time, DFA can directly be executed on a computer. The NFA first has to be compiled into a DFA in order to execute it, but in return, it allows use of a \u201chigher-level language\u201d.","Formally defined, a DFA has the following characteristics:\n\n","One way of describing a DFA is using the five-tuple notation:\n\n=().\n\nThere are other ways to represent an automaton. One notation is the transition diagram, which is a graph that contains one node for each state in Q. Furthermore, there is an arch from node q to node p labeled a for each state q in Q and each input symbol a in \u03a3. Furthermore, there is one arrow, having no origin from any state, into the start state qof the automaton. Nodes that represent accepting states are marked by a double circle while all states that are not in F (and therefore are non-accepting states) are marked by a single circle. An example of a transition diagram is shown in .  is a schematic representation of a transition diagram  of a Deterministic Finite Automaton (DFA). The DFA has three states. Depending on the input, it uses the available transitions to either go to its accepting state or to the non-accepting state.\n","For each of the three states q, q, and q, there is one node in the graph. The start state is qas there is an arrow with no origin going into it. The state gis the only node marked by a double circle, therefore it is the only final state of the DFA. Moreover, there are arches between the states. For example, there is an arch labeled a from qto q, which represents the transition function \u03b4(q, a)=q. The automaton in  is also represented by the following five-tuple notation:\n\n=({}).\n\nThe alphabet of the DFA is \u03a3={a, a}, which means for this example, the input is differentiated in being either a or not a ( a). Note that in the transition diagrams for DFA, there is one arch for each input symbol out of the alphabet \u03a3, which goes out of this state.\n","As mentioned above, an automaton can either be an acceptor or a transducer. Talking only about acceptors, the action of accepting is not determined by the state the acceptor automaton is in for a single input symbol, but rather for a list of input symbols, which is called a string. The issue is the determination of the state the automaton is in after processing the whole input string w. In order to determine the last state of an automaton, the extended transition function has to be defined. Unlike the transition, which determines the next state for a given state and a given input symbol, the extended transition function determines the last state for an input string. The extended transition function {circumflex over (\u03b4)} of DFA can be defined by induction on the length of the input string.","When there is no input symbol, the automaton stays in state q, which is its present state:\n\n{circumflex over (\u03b4)}(\u03b5)=\n\nIf there is a string w that is composed of a substring x and its last symbol a, then:\n\n{circumflex over (\u03b4)}()=\u03b4({circumflex over (\u03b4)}(),).\n\nThis means, in order to determine {circumflex over (\u03b4)} (q, w), the state the automaton is in after processing the substring x (which is {circumflex over (\u03b4)} (q, x)) is determined first. Assuming this state is called p, then {circumflex over (\u03b4)} (q, x)=p. Therefore, {circumflex over (\u03b4)} (q, w) describes the state that the automaton is in after the transition from p with the input symbol a. This results in {circumflex over (\u03b4)} (q, w)=\u03b4 (p, a). Using the information about the DFA, its states and transitions, the concept of an acceptor can now be applied for knowledge validation.\n","The knowledge to be validated may be described using Datalog facts or other fact model. Facts may depend on other facts in accordance to the Consolidated Model. Some of the facts of the business trading web and their dependencies are shown in .  is a graph showing an excerpt  of the dependencies of the facts. This graph shows an excerpt of the facts that depend on other facts. For example, for a system_discx fact  to be valid there has to be a data_discx fact  with the same key (e.g., URI). Another example is an operation_discx , which depends on an incoming_discx  and\/or outgoing_discx  with its configURI and on a valid data discx with its operationURI. Furthermore, it is possible that one fact depends on one of two facts, e.g., a message_flow_discx, whose senderURI and receiverURI depend on either a valid incoming_discx \/outgoing_discx  or a valid system_discx .","As  shows, there are some \u201cclusters\u201d of facts that may be validated independently from others. For example, when validating a message_flow_discx , the host_discx  facts are not relevant. However, the system_discx  facts are all relevant as the senderURI and receiverURI depend on either an incoming_discx \/outgoing_discx or a system_discx . If it depends on two configuration facts, these facts also depend on system_discx  facts and so on. This issue is shown in .",{"@attributes":{"id":"p-0124","num":"0138"},"figref":["FIG. 12","FIG. 12"],"b":["1200","1202","1202"]},"For example, a fact of level   or higher does not necessarily depend on all lower-level facts. As a result, it is possible to split a set of facts to be validated into subsets if and only if the shared facts are duplicated. For example, a set that is composed of operation_discx, binding_discx (as shown in ), and message_discx , incoming_discx , outgoing_discx , system_discx (e.g., ), host_discx (e.g., as shown in ) and data_discx (e.g., ) facts, one possibility to distribute the facts is using the following subsets S(the_discx of the fact predicates is omitted due for readability):\n\n","In order to be able to validate a fact, its dependencies are resolved. This resolution is facilitated by the Deterministic Finite Validation Automaton (DFVA). The automaton used for fact validation (FVA) can be described just like the finite automaton described above. It also has a set of states (Q\u2032), a set of input symbols (\u03a3\u2032), a transition function (\u03b4\u2032), a start state (q\u2032), and a set of accepting states (F\u2032). The five-tuple description of this automaton is shown below:\n\n=(\u2032).\n\nSome parts of this definition, however, can be interpreted in a different way than for the standard deterministic finite automaton that accepts regular languages:\n\n","The generative power of languages can be classified into formal grammars and the languages that they describe into four categories. A grammar G is defined as a four-tuple (V, \u03a3, P; S):\n\n","A Nondeterministic Finite Automaton (NFA) is a finite automaton that can be in more than one state at once. This enables it to \u201cguess\u201d something about its input. For example, it can \u201cguess\u201d that the fact has more arguments or that it does not. The interesting thing about NFAs it that they can accept the same language as DFA even though they might be designed easier than the corresponding DFA. The definition of an NFA is similar to the definition of a DFA:\n\n().\n","Furthermore, the language of a NFA that processes regular expressions is defined as\n\n()={|{circumflex over (\u03b4)}()\u2229\n\nThat means, that L(NFA) is the set of strings w in \u03a3* such that the extended transition function {circumflex over (\u03b4)} (q;w) contains at least one final state while the set of final states is not empty. The main difference between NFAs and DFAs is the type of value that the transition function \u03b4 returns. While a DFA returns one state, a NFA returns a set of states. Furthermore, there does not have to be a transition out of each state, which means, the sequence of states may \u201cdie.\u201d However, the extended transition function is similar to a DFA's except that the next states of one state are determined by following all arcs out of this state labeled with the last input symbol.\n","Considering the differences of NFAs and DFAs, the question now is how they can both accept the same language. As mentioned above, every language described by a NFA can also be described by some DFA, even though in the worst case, the DFA will have more states than the corresponding NFA. Usually, the DFA has about as many states as the NFA, although it may have a lot more transitions. In order to find the corresponding DFA for a given NFA, a procedure called subset construction has to be used. The basis of the subset construction is an NFA N=(Q; \u03a3; \u03b4; q; F). The aim is to construct a DFA D=(Q; \u03a3; \u03b4; {q}; F) such that L(D)=L(N) while the alphabets (\u03a3) of both automata are the same. The main idea of subset construction is that the constructed states of the DFA are sets of states of the NFA. For example, the start state of D is the only state included in the set that represents the start state of N. The construction of the other components of D is done as follows:\n\n",{"@attributes":{"id":"p-0131","num":"0167"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"msub":{"mi":["\u03b4","D"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["S","a"],"mo":","}}},{"munder":{"mo":"\u22c3","mrow":{"mi":["p","in","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},"mo":"\u2062","mrow":{"msub":{"mi":["\u03b4","N"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["p","a"],"mo":","}}}}],"mo":"="},"mo":","}}}},"is determined.","Subset construction is usually done using transition tables. However, as this seems to be very time-consuming, there is an approach, call \u201clazy evaluation,\u201d which can be performed on the subsets:","1. There is the singleton set that consists of only the start state of the NFA and is accessible at the beginning.","2. After determining the set S of accessible states, for each input symbol a, the set of states \u03b4(S; a) is computed. All of these states are accessible as well.","Epsilon Nondeterministic Finite Automaton (\u03b5-NFA) is defined similarly to the NFA described above:\n\n\u03b5-=().\n\nAll the components of the definition can be interpreted the same as for an NFA, except \u03b4, which is now a function that takes two arguments. First, it takes one state out of Q, which is the state the automaton \u201ccomes from.\u201d Second, it takes a member of S U {\u03b5}, which is either an input symbol out of the alphabet, or the symbol \u03b5. Note that in this definition, \u03b5, the empty string, is not a member of the alphabet \u03a3.\n","The so-called \u03b5-transition enables the \u03b5-NFA to go to the next state spontaneously, i.e., without any input. This possibility does not change the language accepted by the automaton, but it provides some \u201cconvenience\u201d on the automata construction. For example, an optional input symbol can be modeled this way.","However, with new input symbols, there are also new procedures to handle them. Therefore, the \u03b5-closure needs to be introduced in order to define the extended transition function. Formally, the \u03b5-closure is defined by recursion:","Basis: State q is in ENCLOSE(q).","Induction: If state p is in ENCLOSE(q) and there is an arc from p to another state r labeled \u03b5, then r is ENCLOSE(q). Therefore, ENCLOSE(q) also contains all states in \u03b4(p, \u03b5).","This means that the epsilon closure of a state contains all states that can be reached from this state with arcs exclusively labeled \u03b5. Similar to standard NFAs, the extended transition function of the \u03b5-NFA reflects what the automaton does on the input of a string w consisting of symbols out of the alphabet \u03a3. Therefore, {circumflex over (\u03b4)}(q, w) is the set of states reached along the path whose labels form w where \u03b5's do not contribute to w.","Construction of an \u03b5-NFA for Fact Validation may use the knowledge about DFAs, NFAs and \u03b5-NFAs, and it is possible to design an automaton that validates facts. The following inductive proof will construct an \u03b5-NFA, which is able to validate facts.","Theorem: There exists some \u03b5-NFA that validates facts.","Proof: This proof will show that there is some \u03b5-NFA that is able to validate facts. This \u03b5-NFA has the following characteristics:","1. Exactly one accepting state.","2. No arcs into the initial state.","3. No arcs out of the accepting state.","Assuming that each fact has at least one argument and there is at least one fact that has no arguments depending on other facts, the proof is done by structural induction on the input of the automaton.","There are two types of arguments: a normal argument or an argument that depends on a fact whose level is lower than the level of the fact being validated. These two types of arguments are shown in .  is a graphical representation  of two types of argument validations. There are two types of argument validations: the first type is a normal argument and the second type is an argument that depends on another fact. It is assumed that the basic input of the automaton is an argument to be validated.","If the input is a normal argument, the automaton goes from a first state  to the next state  if and only if the argument is valid. On the other hand, an argument depending on other facts is valid if and only if the lower-level fact is valid. If it is invalid, the argument is also invalid. Therefore, the lower-level fact has to be validated in the transition function. This fact validation is shown by the dotted edge in  transitioning from state  to  for a valid fact. The reason for the edge being dotted is that there may be more than one initial and one final state in this automaton.","There are two different cases depending on the amount n of arguments of a fact.  is a graphical representation  of a fact validation. There is one argument validation for each argument of the fact.\n\n","In both cases, as soon as one argument is invalid, the automaton is stuck in any of the non-final states. It does not matter whether any following arguments are valid or not, the automaton cannot reach its final state any more. Therefore, the accepting state can be interpreted as the indicator of the success of the fact validation.","As a fact consists of a list of arguments, the validation of a fact includes the validation of this list. An argument can be either required or optional. In the latter case, the validation is skipped by the &transition. However, if the argument is required, there is either the validation of a normal fact (the normal transition) or the validation of a fact that depends on another fact (the small \u201cValidation of a Fact\u201d box). As soon as one argument is not valid, the automaton is stuck in its state and will never reach the final state any more. The complete \u03b5-NFA constructed in the induction above is shown in .  is a graphical representation  of a completely constructed Epsilon-NFA for validating facts. This figure shows the embedding of the validation of a fact box  into the validation of list of arguments box . Validation of fact box  includes two states  and . The dotted line is to signify the possibility of more than one initial and one final state. The automaton uses the &transition to go back to the state  in order to validate the next argument.","In order to determine the final state  of the automaton with a given fact as its input, the constructed &NFA has to be transformed to a corresponding DFA first. This is done by subset construction. The automaton which is assumed to be the basis of the subset construction is shown in .  is a graphical representation  of fact validation \u03b5-NFA used for subset construction. This is the same automaton as in , but its states are named alphabetically in order to uniquely identify them","Applying subset construction, the first state of the corresponding DFA is the set of states that includes the start state of the \u03b5-NFA and all states which can be reached by \u03b5-transitions from this state on. Therefore, the set of start states of the DFA includes the states a  and b . If the input is a valid argument, the \u03b5-NFA goes from state b  to state c . From c , the states b  and d  can be reached by \u03b5-transitions. Therefore, the next state of the DFA includes the states b , c , and d . From this state, the automaton goes to the same state on the input of any other valid argument. If there have been only valid arguments, at the end of the validation, the \u03b5-NFA goes to its accepting state using the last \u03b5-transition. Therefore, the state {b, c, d} of the DFA is an accepting state.","If the first argument is invalid, the \u03b5-NFA goes to state b using its \u03b5-transition. Then, it stays in this state because it can only go to state c if the input is a valid argument. Therefore, the corresponding DFA goes to state {b}, which is a non-accepting state. It stays in this state, no matter whether the following argument is valid or not. If all previous arguments have been valid but the next argument is not, the \u03b5-NFA stays in state b. Therefore, the DFA again goes from {a, b}  to state {b} . Thus, the fact becomes invalid on the input of an invalid argument, no matter whether it is the first argument or any other. The constructed DFA is shown in .  is a graphical representation  of a fact validation DFA created by subset construction. The automaton finishes the fact validation either in {b, c, d} , if the fact consists of only valid arguments, or in {b} , if there is at least one argument invalid.","The Extended Transition Function After constructing a DFA out of an \u03b5-NFA, the question is whether both automata are equivalent in terms of fact validation. The Validation DFA accepts facts with at least one argument, just as the \u03b5-NFA. The success of the fact validation of both automata is represented by the state they finish their validation in. However, which state is this last state for a given argument? In order to determine the state the automaton finishes the validation in, the extended transition function has to be used. Unlike the usual DFA, which processes strings, the Validation","DFA processes Datalog facts. Nevertheless, the extended transition function {circumflex over (\u03b4)} is defined similarly by using a fact instead of a string and an argument instead of a symbol:","Basis: When the automaton has not started the validation, i.e., there is no fact to be validated, it stays in state q, which is the state it is in right now:\n\n{circumflex over (\u03b4)}()=\n","Induction: If there is a fact f(a, . . . a, a), where a, aare the arguments of the fact with n\u22671, then:\n\n{circumflex over (\u03b4)}(())=\u03b4({circumflex over (\u03b4)}(()),).\n","This means, in order to determine {circumflex over (\u03b4)}(q,f(a, . . . , a, a), a), the state the automaton is in after the processing all arguments until a, which is\n\n{circumflex over (\u03b4)}(()),\n\nis determined first. Assuming this state is called p, then:\n\n{circumflex over (\u03b4)}(()=\n","Therefore, {circumflex over (\u03b4)}(q,f(a, . . . . a, a)) describes the state that the automaton is in after the transition from p with the argument a. This results in\n\n{circumflex over (\u03b4)}(())=\u03b4()\n","Thus, the extended transition function {circumflex over (\u03b4)} can be defined as\n\n{circumflex over (\u03b4)}()=({circumflex over (\u03b4)}((),,\n\nwhich means that to determine the last state of the automaton validating a fact, the state that the automaton is in after the validation of the second-last argument of the fact has to be determined first.\n","Equivalence of the Validation DFA and the \u03b5-NFA After the definition of the extended transition function, it is now possible to proof the equivalence of the DFA and the \u03b5-NFA. Therefore, it has to be shown that both automata accept the same language.","Proof. Let E =(Q; f, \u03b4; a; F) be the \u03b5-NFA and D=(Q; f, \u03b4; a; F) be the where qis the start state of the DFA produced by subset construction. Assuming that L=L(D) for the DFA and L=L(E) for the \u03b5-NFA, it may be shown that\n\n()=().\n","This is done by showing that the extended transition functions of both automata for the input of a fact f(a, a, . . . , a) are the same:\n\n{circumflex over (\u03b4)}()={circumflex over (\u03b4)}().\n\nNote that the symbol a is representing the start state of the \u03b5-NFA. Assuming that f consists of at least one argument aand that this argument can be either valid (which is denoted as a) or invalid (a), the equivalence of the automata is shown by induction on the amount of arguments.\n","Basis: First, the input of a fact with one single argument is assumed. Depending on the validity of the argument, the validation will be either successful or not:\n\n","Induction: The input of a fact with more than one argument is assumed. Different constellations of valid and invalid arguments of a fact can occur:\n\n","Implementation choices are described below. Implementation of the automaton includes a structural and an object-oriented approach. In the structural approach, the states of an automaton are implemented as integer variables. A variable is used to save the actual state. When validating a fact, the actual state is looked up first and depending on it, the validation is done. For example, the following shows the class diagram of an automaton that validates data facts using the structure:",{"@attributes":{"id":"p-0168","num":"0212"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DataAtomaton"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"+URI: int = 0"]},{"entry":[{},"+DATA: int = 1"]},{"entry":[{},"+CONTENTTYPE: int = 2"]},{"entry":[{},"+ORIGIN: int = 3"]},{"entry":[{},"\u2212actualState: int"]},{"entry":[{},"+goToNextState (argument:String)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"For each argument of the data fact, there is one state which is represented by an integer constant. The state the automaton is in at the moment is saved in the actualState integer variable. The transition function is implemented in the goToNextState method which looks up the actual state and does the corresponding transition depending on the actual state (and argument respectively). If there are only facts with the same structure (i.e., predicate), this approach works fine. However, as the number of predicates increases, the amount of automata to be maintained increases as well. Furthermore, if the argument structure of a fact changes, the goToNextState method has to be adjusted as well in order to ensure the correct argument validation. For example, let the arguments data and origin of a data fact be validated differently. If these two arguments are switched in the model of dependencies, the whole class (including its integer constants and transition function) has to be changed as well. Furthermore, many arguments may be validated in the same way. For example, the data, content type and origin arguments of a data fact are all optional arguments with no special restriction. However, the transition function has to be implemented three times (once for each argument) as the transition function depends on the argument. As a result, the maintenance effort for this approach is very high.","The question now is whether there is any technique where the states can be reused in order to reduce maintenance effort and improve readability. One way of solving these problems is the encapsulation of the transitions into the states which is the main idea of the object-oriented approach. Furthermore, the states may have the same common interface as the automaton for the validation. Therefore, when an argument is supposed to be validated, the automaton delegates the validation to the actual state. Speaking in the terms of the design pattern, the Context is the FVA and the Concrete States are all states needed to model the validation. The transition function of each state returns the next state that the automaton should go to. However, the automaton has the control to go to the next state, which may or may not be state \u201csuggested\u201d by the actual state. The main advantages of the implementation of the design pattern are the improved maintainability and reusability. Especially for facts of the model of dependencies that have a plurality of arguments with similar characteristics (e.g., their optionality), one state implementation can be reused for all arguments with the same characteristics, no matter to which fact they belong. As the maintainability and reusability of the object-oriented approach outperform the structural approach, the object-oriented approach is takes as a basis from now on. As a result, the transition functions are attached to the specific state. Furthermore, the automaton is not only able to validate one fact type (i.e., facts with the same predicate), it is rather able to validate many facts with different predicates.","As mentioned above, each argument has a cardinality which tells whether the argument is optional or required. Therefore, the transition function of one state has to skip the validation of the argument. However, if the argument is required, it has to be validated.","If it is a simple argument, the transition function just has to check whether it is specified (i.e., a non-empty string) or not. However, if the argument is an URI which refers to a lower-level fact, this fact has to be validated as well. Therefore, the following states have been implemented:\n\n","All facts are modeled in a semantic model, which, once constructed, represents dependencies of the facts. The abstract fact and argument models are shown in .  is a graphical illustration of a semantic model . This class diagram shows the semantic model . A fact model consists of a number of argument models. In general, a semantic model is a subset of a domain model, which is the consolidated model described above. More precisely, the semantic model is an EDB (i.e., External Database) representation of the consolidated model.","The fact model contains information about the predicate and the arity of the fact. The list of argument models is composed of argument models, which are identified by a name. The cardinality tells whether the argument is optional (which is represented by the value 0) or required (1). The isRef variable tells whether the argument depends on other facts, which are included in the set of references (refSet). Furthermore, each fact model has a key value which specifies the argument that uniquely identifies the fact. Lastly, each fact has a list of states (stateList), which the FVA goes through.","The information is validation-specific, and, accordingly, the user who wants to validate the facts has to specify them. Therefore, an external domain-specific language (DSL) has been developed. In general, a DSL is a computer program language of limited expressiveness focused on a particular domain. Furthermore, an external DSL is separate from the language of the main program. External DSL can have a custom syntax or be any other language (often XML). In this case, a custom language was defined. A definition file has to be written in the DSL to describe the semantic model. The process of creating, modifying and using the definition file is described above.","In general, the validation automaton is not only able to validate one fact; it is also able to validate a set of facts. In fact, a normal user rather needs the validation of a set of facts than the validation of a single fact as the main reason for the need of the fact validation is the dependencies of the facts. The validation of a single fact is mostly used by the automaton itself. Therefore, the validation process is defined as the process in which the validation automaton validates a given set of facts.","Certain preparations are considered. For example the creation of the semantic model is needed by many components of the validation framework. Therefore, when the validation framework is started, the definition file is parsed and the semantic model is created. As mentioned above, the fact models do not only include information about the arguments, they also include the state list that the automaton will need in order to validate the particular fact. The creation of the state list is shown in Algorithm , which needs the corresponding fact model as an input in order to resolve the dependencies of the fact. Algorithm  is an example algorithm for determining the state list for a fact.","For all argument models, the first step is to check whether the argument is optional (see line ). In this case, the validation of the argument needs to be skipped. If the argument is required, the next step is to check whether the argument refers to other fact models (see line ). If there are no references to other facts, the algorithm searches for a fact- and argument-specific state, which has a specific naming. If there is such a state, the algorithm will take it (line ). Otherwise, it will use the default state for argument validation (line ). However, if there are dependencies to lower-level facts, a state for fact validation is added (line ). At the end, the previously determined and the accepting state are added to the state list (lines  and ) and the state list is returned (line ).","Then, the automaton has to be prepared. This means, it needs some information before it is able to validate facts. It needs a context in which the facts will be validated. In general, a fact set includes a number of facts that may or may not have the same predicate. If the facts do not have the same predicate, they may depend on each other. The set of facts, that will be validated later on, is a subset of the context or the context itself:\n\nValidationFactSet Context\n\nFor example, let the context C be a fact set that consists of a runs_on fact R with a system and a host fact (S and H) that each have a corresponding data fact (Dand D):\n\nC={R, S, H, D, D}\n\nA fact set S, that is a subset of this context may be\n\nS={S}\n\nIf the arguments of all facts are valid, the fact set Swill be valid as well, as for the system fact, there is a corresponding data fact in the context. Now, let another subset Sbe\n\nS={R,I}\n\nwhere I is an incoming configuration fact. The fact set Swill not be valid even though the arguments of all facts will be valid because there is no data fact DI that matches the configURI of the incoming configuration. Let the last fact set Sbe\n\nS={R,S,H,D,D}=C\n\nThe fact set Swill be valid as there are the corresponding lower-level facts in the fact set itself. Therefore, the automaton is not only able to validate a set of facts in the context, it is also able to validate the whole context.\n","In the validation fact set, there may be a large number of facts depending on other facts in the context. As a result, there are different strategies to validate facts. The first possible approach is the Random Approach, where the facts are validated as they are taken out of the set of facts to be validated. However, there are two other approaches that use the levels of the facts in the dependencies hierarchy to determine the validation order. The computation of the level is a recursive function applied on a fact model (see Algorithm ). Algorithm  is an example algorithm for determining the level of a fact model.","The default level is 0 (line ). In order to calculate the level of a fact model, to the level of each fact model, which the actual fact model depends on, 1 is added (line ). Then, the sum is compared to the highest level found until now. If the sum is higher than the highest level found, it is taken as the new level (line ). After iterating through all fact models, the calculated level is returned (line ). The calculated level can be used for two different validation approaches. The higher-level facts can be validated first. This is called Top-down Approach.","When a higher-level fact is validated, the fact it depends on is validated during the validation of the dependent fact. For example, during the validation of a system fact, there has to be a check whether a corresponding data fact exists. During this test, an automaton which validates the data fact is called. It validates the corresponding data fact and, if it is valid, returns the next state to the parent (system) automaton. Therefore, most of the lower-level facts are validated during the validation of higher-level facts. In contrast to that, there is the Bottom-up Approach where the lower-level facts are validated first. Therefore, when the higher-level facts are validated, the facts that they depend on do not have to be validated again. They will be skipped.","If the Top-Down and Bottom-Up approaches are supposed to be used effectively, a shared memory has to be used.  is a schematic representation of an example implementation  a shared memory . In addition to the local memory , where it places invalid facts, each FVA (e.g., FVA ) uses a part of the shared memory  to put valid facts in. These spots can also be used by more than one automaton. The implemented shared memory facilitates the storage of all facts that have already been validated. Consequently, each FVA needs the ID of the part of the shared memory  it is supposed to use. This enables it to put all valid facts into this part of the shared memory . When any of the lower-level, already validated facts is supposed to be validated again, the automaton can skip this validation. Therefore, any time a sub-automaton is called, it gets the ID of a shared memory  section as an input. As a result, it also puts all valid facts into the same part of the shared memory  that the parent automaton uses. This facilitates a fact validation distributed between different automata. Furthermore, each automaton has a local memory  where it puts all facts that have not been successfully validated. As a result, when it is supposed to validate the invalid fact again, the automaton can skip the validation because it already \u201cknows\u201d that this fact is invalid.","As soon as the automaton has got all the information it needs, it can start to validate a set of facts. As mentioned above, it does that using a given approach. The approach determines the order for the validation and the automaton will validate one fact after another in the order that the approach defines. However, before the actual validation can start, there has to be done some preprocessing (see Algorithm ), which checks whether all conditions, needed to validate the fact, are fulfilled.","Algorithm  is an example algorithm for preprocessing for fact validation. At the beginning, the automaton checks whether the validation of the actual fact can be skipped because it is contained in the shared memory and thus has been validated before (line ). If this is not the case, the automaton makes sure that:\n\n","Algorithm  is an example algorithm for determining a next state for the automaton. In general, for each argument a, with the index i in the argument list, there is a state Sin the state list that includes the corresponding transition function so that i=j. This means that in order to get the state that includes the transition function that validates the next argument, the state S=I+1, whose index is one higher than the index of the actual argument, is returned (line ). If there is no state Sfor the argument asuch that i=j, this means that either the fact has more arguments than the corresponding fact model or the automaton is already in its final state and thus does not expect more arguments. Therefore, an error state is returned (line ). For the determination of the start state for a particular fact, it is assumed that, as long as no argument is validated yet, the index of the actual argument is \u22121. In this case, the \u201cnext\u201d state is the start state of the automaton.","After the determination of the start state, the actual fact validation can start. It is shown in Algorithm . Algorithm  is an example algorithm for validation of a fact. For each argument of the fact, the transition function of the actual state is called (line ). It will return a state depending on the validation success. If this return state is the same state that the automaton is in at the moment, the validation of the argument was not successful. Then, the loop over the argument is stopped because if one argument is invalid, the fact cannot become valid any more (line ). Otherwise, the actual state is set to the state returned by the actual state (line ).","After the fact is validated (which means that either all arguments are valid or the validation was stopped as one argument was not valid), there is some post-processing. It mainly includes setting a variable which tracks the success of the validation of the fact set. The post-processing is shown in Algorithm .","Algorithm  is an example algorithm for fact validation post-processing. If the actual state of the automaton is its accepting state, the validation of the fact was successful. If so, and if the valid fact is the first fact that has been validated, the successful variable is set to be true (line ). Note that this is only done for the first fact because the default value of the successful variable is false. The reason for this is that if no fact has been validated yet, the validation cannot be successful. Furthermore, the fact is added to the shared memory containing all valid facts if and only if the validation was successful (line ). However, if the fact is invalid, the successful variable is set to be false (line ) and the fact is added to the local set of invalid facts (line ).","Hierarchical Call of FVA Until now, the transition function responsible for the validation of lower-level facts that the actual fact depends on was not further discussed. However, as mentioned above, this transition function is different from others as other automata are called. The fact validation transition function is shown in Algorithm .","Algorithm  is an example algorithm for a fact validation transition function. At first, the context for the local FVA is defined as the set union of the fact set that the parent FVA validates, the context of the parent FVA and the shared memory that contains all facts that have already been validated by the parent FVA (line ). The parent FVA is the automaton whose transition function calls another automaton (in this case the local FVA). Then, all lower-level facts that the actual argument depends on are determined (line ), which is shown in Algorithm .","Algorithm  is an example algorithm for determining dependency facts of an argument. After the determination of the actual argument model (line ), for all fact models that the argument model depends on, all facts in the context with the same predicate are added to the set of prospect dependency facts (line ). This means, that all facts that the actual fact may depend on are to be validated later on (Algorithm , line  ).","The procedure now is similar to the general fact validation (Algorithm ) as the validation is skipped if the fact has already been validated. In this case, the next state of the parent automaton is added to a return state list (Algorithm , line ), which collects the return states of all local FVAs in order to determine the final return state.","If the fact has not been validated yet, a local FVA is called to perform the validation (line ). If the validation was successful, the fact is added to the shared memory and the next state is added to the return state set (lines  and ). However, if the lower-level fact is not valid, it is added to the invalid fact set of the local FVA and the actual fact is added to the invalid fact set of the parent FVA (line ). Furthermore, the actual state is added to the set of prospect return states (line ). At the end, the return state out of the set of prospect return states is determined (line ). This is shown in Algorithm .","Algorithm  is an example algorithm for determining a return state for a fact validation transition function. If the set of return states contains only one state, this state is returned (line ). If there are more states in the set of prospect return states, an error state is returned if there is one in the set (line ) because if this happens, an error has occurred during the validation of the local FVA. However, if the set contains the actual state, it is returned (line ) as this means that the lower-level fact is not valid. If none of the cases mentioned occur, any state is returned (line ). Then, the parent FVA can continue with its validation process.","The definition of the programming model, with the semantic model for validation programs that can be executed on the automata runtime, may be described. The programming model is shown in .  is a graphical representation of an example programming model  for the automaton . The automaton  gets the facts  and the definition file  as inputs. A semantic model  is built using the definition file . Using this model, the automaton  is able to validate a set of facts. The output is realized as a textual log  and a dot graph .","First, there are a set of inputs, which may or may not be preprocessed by the validation framework. The definition file is used to create the semantic model. It is used by the automaton that validates the given facts. At the end of the validation, there is some output which can be used to diagnose the result of the validation.","As discussed above, the definition file, written in an external domain-specific language, is used to create the semantic model. Therefore, the model has to be described in the definition file at design time. This means that the user specifies the facts, their predicates, arguments and the relationships between them. The language that the definition file is written is defined by the following grammar:\n\n<fact predicate>[<key index>]:<argument list>.\n\nThe key index is the integer value that indicates the index of the argument in the argument list that uniquely identifies the fact. Therefore, in most cases, this will be a URI. The key index is an optional value as there are facts that do not have a single key argument, for example the runs_on fact, which can only be uniquely identified by both arguments, the systemURI and the hostURI. The key index of a fact is written in brackets ([ ]). Furthermore, the arguments in the argument list are separated by a comma (,). The definition of one argument is shown below:\n\n<argument name>({<fact predicates that the argument depends on>}, <cardinality>)\n\nIf the argument depends on more than one fact, the predicates of the lower-level facts are separated by a comma (,). After the definition of one fact, there is a dot (.) that marks the end of the fact definition. The next fact can then be defined in the next line. Comments may be included using the number sign (#). An excerpt from the definition file is shown in Listing .\n","Listing  is an example excerpt from a definition file. Listing  shows the definition of the data_discx and the system_discx facts, as well as two comments. In the first line, there is a comment that shows that the definition of some level  facts will follow. In the second line, the data_discx fact is defined. Its key argument is the URI, the other three arguments are optional. Furthermore, none of the arguments depend on other facts. In the next line, there is another comment which is followed by the definition of the system_discx fact in the last line. The name of this fact is not optional as the cardinality is 1 while the description is optional. The last argument, which is the systemURI at index  of the argument list, is a required argument which depends on a valid and matching data_discx fact.","During the definition of the fact and argument models, there may an argument requiring a special validation procedure which has not been implemented yet. For example, the user may not only want the system name to be a non-empty string, he may also want it to be less than 255 characters long. Therefore, a new transition function (and thus a new state) has to be implemented. Such new states have to follow a strict naming scheme in order to be found and used by the validation framework. A state is a Java class that is named using the following schema:\n\nValidate<fact predicate><argument name>\n\nThe name starts with the literal \u201cValidate\u201d followed by the fact predicate and the name of the argument that this state is for. For example, the name for a state that validates system names should be\n","ValidateSystem_discxName","It is very important that the fact predicate and the argument name are the ones that were defined in the definition file. In the example above, the first letters of the fact predicate and argument name are in capitalized. The reason for that is a better readability. However, the validation framework will also recognize lowercase predicates and names.","The validation programs can be logged and used for debugging purposes (in certain embodiments, in realtime). When the validation is done, the result of the validation is either successful or not. In order to analyze the validation result, the automaton facilitates logging of what it does. The following events can be logged:","1. The Beginning of the Validation of a Set of Facts;","2. The Beginning of the Validation of a Fact;","3. The Beginning of the Validation of an Argument;","4. The End of the Validation of an Argument;","5. The End of the Validation of a Fact;","6. The End of the Validation of a Set of Facts; and","7. The Occurrence of an Exception.","If any of the events mentioned above occur, the automaton calls its logger, which is the implementation of a Visitor design pattern and logs the event. As the logger has a reference to the automaton, it can access all the information needed to produce a useful log in the way the user wants the output.","There are two types of log outputs: textual and graphical. The textual output is a description of what the automaton does at the moment, i.e., which part of the validation it has just finished. For example, when an automaton validates one data fact, the output would look like the output shown in Listing .","Listing  is an example textual output of the automaton for a valid data fact. The logger logs the start of the automaton, the start of the validation of the data fact, the validation of the arguments and the end of the fact and the automaton. It also logs whether the validation of one fact and all facts was successful or not.","First, the logger logs the start of the automaton and how many facts are in the fact set to be validated. Then it logs the start of the validation of the data fact. Next, it logs the validation of the arguments and their success. After this, it logs the end of the validation of the data fact and whether it is valid or not. After all facts are validated, it logs the end of the automaton and the status of the overall validation, i.e., whether all facts are valid or not.","The second way of logging is the graphical output, which is implemented using dot graphs. In general, dot is used to \u201cdraw directed graphs as hierarchies.\u201d Therefore, it reads text files, which contain the description of the graph in a specific format, and creates drawings in different graphics formats. Listing  shows a text file which contains the description of a dot graph for a valid data fact.","Listing  is an example description of a dot graph for a valid data fact. Listing  includes the states and the transitions of an FVA described in dot. The digraph G in line  means that the graph G is supposed to be a directed graph. The braces are used to mark which parts of the graph belong together just like in any programming language. In line , the rankdir=LR; anticipates that the graphs are drawn from left to right. The semicolon is used to end an instruction, which is also similar to some programming languages (e.g., Java). The subgraph in line  expresses the creation of a new subset of nodes and edges within the main graph. In order to name the subgraph, the command label=\u201c [. . . ]\u201d; is used. As a result, the entity is not labeled with its unique name, but rather with the specified label. Unlike the unique name of a graph, subgraph or node, the label does not have to be unique. For example, the label of the subgraph is defined in line . To assign a node to a subgraph, the node's unique name has to be written into the subgraph's body. Similar to subgraphs, nodes can also be labeled. In Listing , there are five nodes assigned to the subgraph. For logging, each node represents one state that the automaton was in. Edges represent the transitions of the automaton. In the textual description of the dot graph, the edges are defined at the end of the main graph. To define a directed edge between two nodes, the first node has to be written down at the beginning of the line, followed by an arrow (\u2192). At the end of the line, there is the node the directed edge goes to, followed by the semicolon to end the command. For example, the edge between the first and the second state of the automaton is defined in line . After validation the argument of the data fact, the automaton goes to the next state (SkipArgumentValidation), therefore these two states were connected by an arrow.","In order to view the graph and not just the description of the graph, a graph visualization software has to be used, for example dotty, which is the dot graph viewer included in the open source software Graphviz 1. The graphical output of the dot graph defined in Listing  is shown in .  is a graphical output  for an example data fact. For the validation of a data fact, the automaton first has to validate the dataURI and then skip the validation of three optional arguments. If no errors occur during these validations, the final state is denoted with an overlapping square.","The label of the subgraph for the data fact in line  of the textual description of the dot graph (Listing ) is the label at the top of the graph. It contains the fact that has been validated. The states the automaton went through during the validation are represented by the nodes of the dot graph. As data facts have an URI, a data argument, a content type and an origin, the URI has been validated first. Therefore, the first node is called ValidateArgument. This state was logged by the logger after the automaton has finished the validation of the URI. The next three arguments of the automaton are optional, therefore the validation can be skipped. After skipping the validation of an argument, the corresponding state is logged. As soon as the automaton has finished the validation of a fact, it calls the logger which logs this event. The graphical logger analyzes whether the automaton has validated the fact successfully. If so, the final state denoted with an overlapping square. If the state the automaton is in after validating a fact is not its accepting state, the state is denoted with an overlapping triangle. Therefore it is convenient to use the dot graph to determine whether the validation was successful. If the fact to be validated is a fact whose level is higher than zero, there may be a call of an automaton in the transition function that validates the argument that is the key of another fact. In this case, the \u201cpath\u201d the automaton went is shown with a solid arrow. The path the automaton would have gone if there was no call of another automaton is presented with a dotted arrow. For example, let there be a runs_on fact and the corresponding system and host facts, each having a corresponding data fact. Usually, in this case, the dot graph also shows which automaton was called. If the valid lower-level fact is supposed to be validated again, the automaton will skip the validation and the dot graph will show an automaton that has only one state: the accepting state (AllArgumentsValidated).","It is not only important that the automaton finds the invalid facts in a set of facts, it is also significant to find out why the facts are not valid. Therefore, the automaton logs whenever it validates a set of facts, a single fact or an argument. Until now, the validation automaton has two different possibilities to log what is does: one way of logging is textual by writing a short description what it is doing at the moment, another one is graphical by outputting a dot graph. In order to debug the automaton, both outputs can be combined in order to find the issues with the facts to be validated. To create a useful graphical output, in all cases, the top-down approach was used.","Let there be a user who tries to create a runs_on fact to be injected into the knowledge base. The user starts creating the runs_on fact by typing the predicate and the system URI argument. He then realizes that he has also has to create a system fact; therefore, he stops working on the runs_on fact and starts working on the system fact instead. He has copied the system name \u201cHXPCLNT001\u201d from another place and pastes it into his text editor. However, the user may \u201caccidentally\u201d hit the paste button 47 times. That is why the system name argument includes the system name 47 times. The user also types a description and the URI of the system. The final file is shown in Listing . Note, that due to readability, only part of the system name is shown.","Listing  is an example definition file for a runs_on fact with an invalid system fact. There is a runs_on fact with a corresponding system whose name is too long. Thus, it is invalid, which causes the runs_on fact to be invalid as well. The user then starts the validation of the file. The automaton has logged the dot graph displayed in . There are three facts shown in . At first, there is a runs_on fact  with a single state which is the start state of the validation automaton. Out of this state, there is a directed edge towards the start state of the automaton that was called in order to validate the corresponding system fact . This means that the automaton found a corresponding system fact. However, in this example, when it tried to validate the name of the system, something went wrong. As the user does not realize that the invalid system name is the reason for the validation failure, the user looks at the textual output for this validation (see Listing ).","Listing  is an example textual output of an automaton for a runs_on fact with an invalid system fact. The automaton realized that the name of the system is invalid, thus the fact is invalid. Consequently, the runs_on fact is invalid as well. As the log states, the reason for the failure of the validation is the name of the system, which exceeds the allowed length.","Consequently, the user, who has also analyzed the outputs of the automaton, fixed his error in the description file by changing the system name. The user may also forget to add a data fact for the fixed system fact, which he or she would correct for. The fixed description file is shown in Listing . Listing  is an example definition file for a runs_on fact with a corresponding system fact and no data fact.","However, this time, he made a mistake when adding the URI of the data disc as he accidentally typed a 2 as the last character of the URI instead of a 1.","The graphical output of the validation of this definition file is shown in .  is a graphical output  of an example automaton for a runs_on fact  whose corresponding system fact  has no corresponding data fact. The automaton validating the system fact  was not able to find a matching data fact even though there is a valid data fact . However, this data fact's URI differs from the system URI, thus the validation is not successful. Similarly to , the automaton started with the validation of the runs_on fact . During this validation, it called another automaton responsible for the validation of the corresponding system fact. This automaton successfully passes the state which validates the system name, thus the fix of the system name was successful. However, this time, the automaton was not able to find a data fact with the same URI as the system fact , which is displayed by the automaton being stuck in the ValidateFact state .","In fact, there is a data fact in this fact set and it has also been (successfully) validated; nevertheless, its URI differs from the URI of the system fact. Therefore, the automaton cannot find a relation between the two facts. This is also indicated by the textual log. This is also indicated by the textual log, which is shown in Listing .","Listing  is an example textual output of the automaton for a runs_on fact with an invalid system fact. The problem is that the corresponding system fact has no matching data fact. There is only one data fact, but it has a different URI than the system as the last characters of the URIs differ. One pertinent part of the textual output is the following one (line  in Listing ):\n\nsystem_discx: Could not find a valid data discx with the same key systemURI: com .sap .bnm .nd. discovery .ale. facts. internal.\u2003\u2003AleFactsProviderHXPCLNT001).\n\nIt shows that the automaton was not able to find a data fact with the same URI. This is the reason for the failure of the validation. Again, the user realized his mistake and changed the URI of the data fact to match the system fact. Again he lets the automaton validate the facts. The graphical output is shown in .  is a graphical output  of an example automaton for a runs_on fact  whose host URI is not specified. After successfully validating the system fact  that matches the systemURI of the runs_on fact , the automaton was not able to validate the hostURI, which was actually not specified. Therefore, the automaton stays in the (non-final) state ValidateFact. Following the directed edges in the graph, the automaton started the validation of the runs_on fact . Next, it called another automaton to validate the system fact and its corresponding data fact. As these validations were successful, the control returned to the main automaton, which finally tried to validate the hostURI. Apparently, the automaton is stuck in this state. Maybe the textual output tells what the problem was with the hostURI. The complete output is shown in Listing .\n","Listing  is an example textual Output of the Automaton for an Invalid runs_on fact. The issue is that the host URI is not specified. The automaton was able to validate the matching system fact. When it tried to validate the hostURI of the runs_on fact, it realized that it contains an empty string. Therefore, the validation failed. The most important part of the log is shown below (line  in Listing ):\n\nruns_on_discx: No hostURI specified.\n\nUsing this output, the user changed his definition file by adding the hostURI into the runs_on fact. When he does that, he realized that he did not create a host fact yet. To prevent himself from making the same mistake again, he also creates a host fact and its corresponding data fact. The definition file then looks as shown in Listing . Listing  is an example definition file for a valid runs_on fact. There is a runs_on fact with a corresponding system and host fact that each has a matching data fact.\n","The dot graph produced by the logger of the automaton is shown in .  is a graphical output  of an example automaton for a valid runs_on fact . The validation of the runs_on , system , and data  facts were all successful, thus all final states are denoted with overlapping squares. In this graph, the final states of all automata are denoted with overlapping squares, which means that all facts are valid. Listing  is an example textual output of the automaton for a valid runs_on fact. The final message of the textual output (line  in Listing ) is as follows:\n\nValidation Successful\n\nAs all facts are valid, the validation of the fact set is successful. Therefore, the user was able to inject the facts he created.\n","In general, if the set of facts is very small (as in the examples above), it is a good idea to first have a look at the dot graph in order to gain an overview of the validation. If there are any states marked red, the textual log can be helpful as is give a more detailed description of the error. If there is a bigger fact set, it is better to have a look at the last line of the textual output first. It will tell whether the validation of the fact set was successful. If it is not, the graphical output helps to find the state that the validation automaton got stuck. If this information does not help either, there is still the detailed textual log, which contains information of the success of the validation of each argument. Consequently, a combination of the graphical and the textual output can be used to debug the automaton and therefore find the reason for a possible failure of the validation.",{"@attributes":{"id":"p-0231","num":"0289"},"figref":["FIG. 25","FIG. 25","FIG. 25","FIG. 25"],"b":["2500","2500","2500","2500","2504","2502","2530","2502","2500","2504","2500","2500","2500","2500"]},"As illustrated, the system  may be communicably coupled with a remote repository . The repository  may include one or more persistent storage devices (e.g., hard drives, etc.) that form a storage backbone for the system . The repository  may include any intra-enterprise, inter-enterprise, regional, nationwide, or substantially national electronic storage facility, data processing center, or archive. In another embodiment, the repository  may include one or more hard disk drives, semiconductor memories, and the like that are coupled, either internally or externally, to the system  via a direct connection, such as an integrated drive electronics (IDE) connection, a small computer systems interface (SCSI) connection, a Serial ATA (SATA) connection, or other suitable communicable connection.","The repository  may be a central database communicably coupled to the system  via a virtual private network (VPN), Secure Shell (SSH) tunnel, or other secure network connection. The repository  may be physically or logically located at any appropriate location including in one of the example enterprises or off-shore, so long as it remains operable to store information associated with system  and communicate such data to the system . For example, the repository  may comprise a data store or warehouse.","The repository  allows for the system  and\/or one or more the trading participants to dynamically store and retrieve instructions  or facts  from the repository . For example, the instructions  may include code that when executed by the system  generate validation programs from semantic models . The instructions  may include code that is web-executable (e.g., java code) over the network . For example, client system  may execute code from the instructions  over the network . Facts  may be generated that may be subjected to validation. Repository  may be a cloud based memory. It may be a distributed memory accessed across network . Repository  may be a shared memory, like that shown in .","The instructions  may include software, firmware, wired or programmed hardware, or any combination thereof as appropriate. Indeed, the instructions  may be written or described in any appropriate computer language including C, C++, Java, J#, Visual Basic, assembler, Perl, any suitable version of 4GL, as well as others. For example, the instructions  may be implemented as Enterprise Java Beans (\u201cEJBs\u201d) or the design-time components may have the ability to generate run-time implementations into different platforms, such as J2EE (Java 2 Platform, Enterprise Edition), ABAP (Advanced Business Application Programming) objects, or Microsoft's .NET. Further, while illustrated as being internal to the repository  and\/or the system , one or more processes associated with the instructions may be stored, referenced, or executed remotely. For example, a portion of instructions  may create a web service that is remotely called (e.g., by the retailer system), while another portion of instructions  may be an interface object bundled for processing at a client (e.g., one of the trading participants). In another example, the majority of the instructions may also reside\u2014or their processing take place\u2014on one of the trading participants. Moreover, the instructions  may be a child or sub-module of another software module or enterprise application (not illustrated) without departing from the scope of this disclosure.","The repository  may store also store facts . The facts  may include any business, enterprise, application or other transaction data and metadata involving the trading participants. For example, the facts  may include purchase histories, purchase trend information, entries in the master catalog, business profiles, other business attributes, and\/or the business ratings, as described above, as well as other suitable marketplace related data. As such, the system  may mine the repository  for the information needed used identify matches (i.e., new potential relationships) between the trading participants.","The system  may also include a processor . The processor  executes instructions and manipulates data to perform the operations of the system . In various configurations, the processor  may be, for example, a central processing unit (\u201cCPU\u201d), a blade, an application specific integrated circuit (\u201cASIC\u201d), a field-programmable gate array (\u201cFPGA\u201d), or other suitable logic device. Although  illustrates a single processor  in system , multiple processors may be used according to particular needs and reference to processor  is meant to include multiple processors where applicable.","The system  also includes local memory . As illustrated, the memory  may include instructions  and facts , which may each be a subset of the instructions  and the facts . As those of ordinary skill in the art will appreciate, the instructions  and facts  may be copied over to the memory prior to being executed or manipulated by the processor . The memory  may include any memory or other computer readable storage module and may take the form of volatile or non-volatile memory including, without limitation, magnetic media, optical media, random access memory (\u201cRAM\u201d), read-only memory (\u201cROM\u201d), removable media, or any other suitable local or remote memory component. The memory  may be internally or externally coupled to the system .","The system  may also include interface  for communicating with other computer systems, such as the other trading participants, over the network . In certain embodiments, the system  receives data from internal or external senders through the interface  for storage in the memory , for storage in repository , and\/or for processing by processor . Generally, the interface  comprises logic encoded in software and\/or hardware in a suitable combination and operable to communicate with network . More specifically, the interface  may comprise software supporting one or more communications protocols associated with the network  or hardware operable to communicate physical signals.","The network  facilitates wireless or wireline communication between the system  and any other local or remote computer, such as the trading participants. The network  may be all or a portion of an enterprise or secured network. In another example, network  may be a VPN merely between one or more of the trading participants across a wireline or wireless link. Such an example wireless link may be via 802.11a, 802.11b, 802.11g, 802.11n, 802.20, WiMax, and many others. While illustrated as a single or continuous network, network  may be logically divided into various sub-nets or virtual networks without departing from the scope of this disclosure, so long as at least portion of network  may facilitate communications between system  and at least one of the trading participants.","The network  encompasses any internal or external network, networks, sub-network, or combination thereof operable to facilitate communications between various computing components in system . Network  may communicate, for example, Internet Protocol (\u201cIP\u201d) packets, Frame Relay frames, Asynchronous Transfer Mode (\u201cATM\u201d) cells, voice, video, data, and other suitable information between network addresses. Network  may include one or more local area networks (\u201cLANs\u201d), radio access networks (\u201cRANs\u201d), metropolitan area networks (\u201cMANs\u201d), wide area networks (\u201cWANs\u201d), all or a portion of the global computer network known as the Internet, and\/or any other communication system or systems at one or more locations. In certain embodiments, network  may be a secure network associated with the enterprise and certain local or remote clients.","Client  may include any computing device operable to connect or communicate with the system  or the network  using any communication link. At a high level, each of the trading participants may include or execute at least a graphical user interface (\u201cGUI\u201d)  and comprise an electronic computing device operable to receive, transmit, process and store any appropriate data associated with system . For ease of illustration, each of the trading participants is described in terms of being used by one user. But this disclosure contemplates that many users may use one computer or that one user may use multiple computers. In certain situations, users may include owners, bookkeepers, as well as third party or outside accountants.","The GUI  comprises a graphical user interface operable to allow the user of client  to interface with at least a portion of system  for any suitable purpose, such as viewing application or other transaction data. Generally, GUI  provides the particular user with an efficient and user-friendly presentation of data provided by or communicated within system . The GUI  may comprise a plurality of customizable frames or views having interactive fields, pull-down lists, and buttons operated by the user. For example, the GUI  is operable to display certain elements, such as graphical and\/or textual outputs of the validation process. The GUI  may also present a plurality of portals or dashboards. For example, GUI  may display a portal that allows users to view, create, and manage validation program modeling and validation debugging. It will be understood, however, that the GUI  contemplates any graphical user interface, such as a generic web browser or touchscreen, which processes information in system  and efficiently presents the results to the user. The GUI  can accept data from the system  or the trading participants via the web browser (e.g., Microsoft Internet Explorer or Netscape Navigator) and return the appropriate HTML or XML responses using network .",{"@attributes":{"id":"p-0244","num":"0302"},"figref":"FIG. 26","b":["2600","2602","2604","2606","2608","2610","2612","2614"]},"A number of embodiments of the invention have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the invention. For example, a target model different from the consolidated model can be used. Another runtime\/validation program incarnation can be used. That is, a SAT solver or other non-automaton based implementation can be used. In addition, other ways of defining automata are contemplated. For example, automata may be non-embedded, such as chained automata. Different output methods may be used for the debugging process. Different ways of representing the validation program than external DSL are also contemplated, such as internal DSL and fluent API. In addition, the disclosure contemplates an individually owned semantical model. Accordingly, other embodiments are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF FIGURES","p":[{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 1A-1B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 9","FIG. 5"],"sub":"1 ","b":["2","3","4"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 26"}]},"DETDESC":[{},{}]}
