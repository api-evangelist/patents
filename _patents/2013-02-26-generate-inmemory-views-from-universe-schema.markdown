---
title: Generate in-memory views from universe schema
abstract: In one aspect, a Universe designed and built in a database is used for modeling data in an in-memory database. The Universe is loaded in a front-end development application to display a universe schema contained in the Universe. The logic built in the front-end development application enables parsing the universe schema, to determine patterns matching in-memory views such as attribute views and analytic views. The determined patterns are generated as attribute views and analytic views, and displayed for user selection. Selected attribute views and analytic views are stored in the in-memory database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09110935&OS=09110935&RS=09110935
owner: SAP SE
number: 09110935
owner_city: Walldorf
owner_country: DE
publication_date: 20130226
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Today enterprises have a rich choice of databases. Customers may choose to migrate from their existing database to any new database offered by their enterprise vendors. The new database may comprise some new features or functionalities that are not available in the existing database. In such a scenario, customers may be required to understand the methodology in which such new features are to be designed in the new database. Typically this is a manual process where customers invest a lot of time and effort in understanding and designing the new features of the new database.","Embodiments of techniques for generating in-memory views from universe schema are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize, however, that the embodiments can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","Enterprises store enormous amount of data in storage repositories such as databases. In any database, data is organized in a data structure supported by that database. Enterprises may have a need to migrate from one database to another, or to upgrade the version of database software being used. In some of these cases, a major data transformation process may be required, since the underlying data format can change significantly. In one embodiment, the modeling and accessing techniques of one database may significantly differ from other databases such as in-memory databases.","According to one embodiment, in-memory database typically relies on main memory for computation and storage. The in-memory database may be a relational database, an object oriented database or a hybrid of both. In-memory technology utilizes the maximum capabilities of the underlying hardware, to increase application performance. Information required for processing is usually available in the main memory, so computation and read operations can typically be executed in the main memory, without involving a hard disk input or output operation, for instance.","Traditionally, a database table is a two dimensional data structure with cells organized in rows and columns. However, according to one embodiment within an in-memory database, memory organization is linear. In a linear memory organization, data may be stored as a row store or a column store. In the row store, the fields of every row in the table are stored in a row sequentially, whereas in the column store, the fields of a column are stored in a column, in contiguous memory locations. Row based storage and column based storage, store data that can be modeled and accessed by various components of the in-memory management system, such as any front-end development application, database application, a query processing engine and the like.","Customers may choose to migrate from an existing database to the in-memory database for various reasons such as increased performance. In one of the steps of such a migration, data needs to be transformed and modeled to the data structure of the in-memory database. Typically, this is a manual process where customers spend a substantial amount of time in understanding the data structure, functionalities and modeling techniques of the in-memory database. In a first approach of manual modeling, customers create tables, views, etc., manually in the in-memory database. Second approach of manual modeling allows the customer to point their database connection to the in-memory database. In the second approach, if the existing database supports structured query language (SQL) queries in a particular syntax, after the manual modeling by pointing the database connection to the in-memory database, SQL queries syntax may vary, requiring significant effort by the customer to get the SQL syntax compatibility with the in-memory database. Therefore these manual approaches are inefficient and time consuming.","Thus, customers require a mechanism to perform data modeling to increase performance, by using a semantic layer of the existing database, at a front-end development application. Some databases have a semantic layer that is an intermediary layer between the database or data source, and dependent queries, reports or dashboards. The semantic layer enables an end-user to interact with data, without having to understand the complexities of database logic or the physical data that is stored. One such semantic layer is the Universe, which a file that contains a structure and layout of classes and objects, schema of tables, views and joins from the database, contexts, connection information to the database and mapping details of the structures to the database.","Such universe designed and built in any database can be used for modeling data in the in-memory database. The front-end development application can be built by implementing the required logic to enable such modeling. In one embodiment, the front-end development application may be a software application providing developers or customers the facility to work with the underlying database, a web application, a desktop application, a software-as-a-service application and the like, by coding software program or visually modeling a software program using an underlying prebuilt code.","In one embodiment, the in-memory database allows users to model data as tables and views. Tables are tabular data structures, each row identifying a particular entity, and each column having a unique name. The data fields of one row are called the attributes of the entity. Views are combinations and selections of data from tables, modeled to serve a specific purpose. Views can be a simple selection of some columns and\/or rows from any table. Universe schema refers to the structure of the database, its tables and the relationships between them. Various types of databases comprising various types of schemas often contain many more tables and join relationships, both in number and type, depending on the business purpose.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["120","110","140","120","130","125","120","125","130","125","125","125","150","150","140"]},"In one embodiment, an exemplary sales universe created in the database  can be used to generate in-memory views  in the in-memory database . Sales universe is loaded and correspondingly a sales universe schema  can be viewed in the front-end development application (tool) , as shown in  of . The sales universe schema  comprising tables such as \u2018Country\u2019 , \u2018Region\u2019 , \u2018City\u2019 , \u2018Customer\u2019 , etc., along with the join relationships is displayed to the user in the front-end development application . The join relationship  between the \u2018Country\u2019  table and the \u2018Region\u2019  table indicates a one-to-many join relationship between them. One country can have many regions and hence the join relationship is one-to-many. The \u2018Country\u2019  table has a primary key \u2018country_id\u2019 and the \u2018Region\u2019  table has a corresponding foreign key \u2018country_id\u2019. The join relationship  between the \u2018Customer\u2019  table and the \u2018City\u2019  table indicates a many-to-one relationship between them. The sales universe schema  is parsed by the logic built in the front-end development application , to determine patterns that would match the in-memory views of the in-memory database .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":["310","330","320","300","360","370","350","340"]},"In one embodiment, a star schema consists of one or more fact tables referencing any number of dimension tables. A fact table is the central table in the star schema, and the fact table stores quantitative or factual measures of a business process for analysis. Dimension tables hold descriptive data that reflects the dimensions, or attributes of the business. Queries issued by the user use the join between the fact and dimension tables, and filter the data to return selected information. The fact table and the dimension table differ from each other in their use with the universe schema. For example, a sales manager analyzes revenue, actuals, budget etc. These items belong to the \u2018Sales_analysis\u2019 fact table as they are analyzed by the sales manager. Business dimensions by the item are product, line item etc., and they belong to the dimension table \u2018Product_info\u2019. Therefore to analyze revenue by product, the query joins the \u2018Sales_analysis\u2019 fact table and the \u2018Product_info\u2019 dimension table and filter the data in these two tables to return selected information.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4","b":["400","450","450","450","455","430","450","460","410","450","430","410","400"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5","b":["500","510","130","125","130","515","125","520","125","530"]},"If the adjacent table \u2018Sample B\u2019 has just one join, it is implied that the one join relationship is with table \u2018Sample A\u2019. The logic to determine \u2018attribute view pattern\u2019 is executed to determine if table \u2018Sample A\u2019 has one-to-many join relationship with table \u2018Sample B\u2019 . Upon successful determination, the attribute view with \u2018Sample A\u2019 and \u2018Sample B\u2019 is generated as shown in . Alternatively, if the adjacent table \u2018Sample B\u2019 has two joins, and the table \u2018Sample A\u2019 has one-to-many join relationship with the table \u2018Sample B\u2019 , then also the attribute view with \u2018Sample A\u2019 and \u2018Sample B\u2019 is generated as shown in . In one embodiment, \u2018add to attribute view pattern\u2019 comprises the second table with two joins and a one-to-many join relationship with a third table, where the second table is already a part of the generated attribute view along with the first table. \u2018Add to attribute view pattern\u2019 is referred to as a \u2018third pattern\u2019. In a scenario where the attribute view is already generated with a table \u2018Sample X\u2019 and the table \u2018Sample A\u2019. Here the table \u2018Sample A\u2019 is adjacent to the table \u2018Sample X\u2019, and the table \u2018Sample B\u2019 is adjacent to the table \u2018Sample A\u2019. The logic in  to determine the \u2018add to attribute view pattern\u2019 is executed, and accordingly it is determined if the adjacent table \u2018Sample B\u2019 has two joins and if the table \u2018Sample A\u2019 has one-to-many join relationship with the table \u2018Sample B\u2019. Upon successful determination of \u2018add to attribute view pattern\u2019, the table \u2018Sample B\u2019 is added to the previously generated attribute view as shown in .","An example embodiment to illustrate the logic involved in determining the \u2018attribute view pattern\u2019, \u2018add to attribute view pattern\u2019 and generating the attribute view with reference to the sales universe schema  of  is provided below. The \u2018Country\u2019  table has one join, and the logic parses the sales universe schema  to get the adjacent table \u2018Region\u2019  and the number of joins of \u2018Region\u2019  table as \u20182\u2019. Since the adjacent table \u2018Region\u2019  has two joins, the logic in  is executed to determine if the \u2018Country\u2019  table and the \u2018Region\u2019  table have one-to-many join relationship with each other. Upon successful determination of the \u2018attribute view pattern\u2019, attribute view \u2018AT\u2019 is generated with the \u2018Country\u2019  table and the \u2018Region\u2019  table. In a scenario where the \u2018City\u2019  table has two joins, and the attribute view \u2018AT\u2019 is already generated with the \u2018Country\u2019  table and the \u2018Region\u2019  table, the logic in  is executed to determine if the \u2018Region\u2019  table has one-to-many join relationship with the \u2018City\u2019  table. Upon successful determination of the \u2018add to attribute view pattern\u2019, the \u2018City\u2019  table is added to the previously generated attribute view \u2018AT\u2019. In one embodiment, the execution of the logic involved in determining and generating the attribute view is repeated, until there are no more tables to parse in the sales universe schema , or a table with more than two joins is determined.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6","b":["600","500","600","610","125","125","620","630"]},"In one scenario, the table \u2018Sample F\u2019 has more than one numeric field and many-to-one join relationship with the adjoining tables in the star schema. Upon successful determination of the \u2018analytic view pattern\u2019, the analytic view is generated with the fact table \u2018Sample F\u2019 and the adjoining tables as shown in . In another scenario, if the table \u2018Sample F\u2019 does not match the criteria of the fact table, the table \u2018Sample F\u2019 and an adjoining table \u2018Sample G\u2019 can be processed to determine if any \u2018new attribute view pattern\u2019, or \u2018add to attribute view pattern\u2019 can be determined. If the table \u2018Sample F\u2019 has many-to-one join relationship with the adjoining table \u2018Sample G\u2019 , a new attribute view can be generated with the tables \u2018Sample F\u2019 and \u2018Sample G\u2019 as shown in . Alternatively, if the table \u2018Sample F\u2019 has many-to-one join relationship with the adjoining table \u2018Sample G\u2019 , and the table \u2018Sample G\u2019 is already part of the previously generated attribute view, the table \u2018Sample F\u2019 is added to the previously generated attribute view as shown in . In one embodiment one attribute view can comprise one or more attribute views.","An example embodiment to illustrate the logic involved in determining the \u2018analytic view pattern\u2019 and generating the analytic view with reference to sales universe schema  of  is provided below. The logic determines if \u2018Customer\u2019  table is the fact table. The \u2018Customer\u2019  table has more than two joins, more than one numeric field, and many-to-one join relationship with the adjoining tables such as \u2018Age_group\u2019  table, \u2018Sponsor\u2019  table, \u2018City\u2019  table, in the star schema. Upon successful determination of the \u2018analytic view pattern\u2019, analytic view \u2018AN\u2019 is generated with the \u2018Customer\u2019  table and the adjoining tables \u2018Age_group\u2019 , \u2018Sponsor\u2019  and \u2018City\u2019 .","In a scenario where \u2018Customer\u2019  table did not match the criteria for the fact table, the \u2018Customer\u2019  table and the adjoining table \u2018City\u2019  table can be processed to determine if any \u2018new attribute view pattern\u2019 or \u2018add to attribute view pattern\u2019 can be determined. If \u2018Customer\u2019  table has many-to-one join relationship with one of the adjoining tables such as \u2018City\u2019 , the \u2018new attribute view pattern\u2019 matches, and a new attribute view can be generated with the \u2018Customer\u2019  table and the \u2018City\u2019  table. Alternatively, if the \u2018Customer\u2019  table has many-to-one join relationship with the adjoining table \u2018City\u2019 , and the \u2018City\u2019  table is already part of the previously generated attribute view \u2018AT\u2019, the \u2018add to attribute view pattern\u2019 matches, and the \u2018Customer\u2019  table is added to the previously generated attribute view \u2018AT\u2019.","In one embodiment, the data in the tables of the previously generated attribute view \u2018AT\u2019 is instrumental in determining if the \u2018Customer\u2019  table can be added to the previously generated attribute view \u2018AT\u2019. For example, if adding the \u2018Customer\u2019  table to the previously generated attribute view \u2018AT\u2019 results in data loss in the tables of \u2018AT\u2019, a new attribute view is generated with the \u2018Customer\u2019  table and the \u2018City\u2019  table. This new attribute view can reside in \u2018AT\u2019, and therefore one attribute view can reside within another attribute view. In one embodiment, the execution of the logic involved in determining the \u2018analytic view pattern\u2019 and generating the analytic view is repeated, until there are no more tables to parse in the sales universe schema .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 7","b":["700","120","125","130","125","710","130","125","720","730","125","740"]},"In one embodiment, the generated attribute views and analytic views can be displayed to the user for validation and selection as shown in  of . The selected attribute views and analytic views are stored in the in-memory database .  illustrates an exemplary user interface  in the front-end development application  for displaying the generated attribute views and analytic views. For example, the attribute view \u2018AT\u2019 and the analytic view \u2018AN\u2019 generated in  is displayed in the user interface , as  and  respectively. Similarly various attribute views such as \u2018AT\u2019 , \u2018AT\u2019 , and analytic views such as \u2018AN\u2019 , \u2018AN\u2019  and \u2018AN\u2019  generated by the execution of the logic in the flow diagram  and the flow diagram  is displayed to the user in , for the user to validate and select.","Users can specify the selection of attribute views and analytic views in the indicated locations associated with the views. Accordingly the attribute views \u2018AT\u2019  and \u2018AT\u2019 , and the analytic views \u2018AN\u2019 . \u2018AN\u2019  and \u2018AN\u2019  are marked for selection by the user. Selected attribute views \u2018AT\u2019  and \u2018AT\u2019 , and the selected analytic views \u2018AN\u2019 , \u2018AN\u2019  and \u2018AN\u2019  are received by the logic in the front-end application , and stored in the in-memory database  as in-memory views . In-memory views  is shown storing \u2018AT\u2019 , \u2018AT\u2019 , \u2018AN\u2019 . \u2018AN\u2019  and \u2018AN\u2019 . Attribute view \u2018AT\u2019  is not selected for storing in the in-memory database  by the user, and accordingly the attribute view \u2018AT\u2019 is not stored in the in-memory database . In one embodiment, the list of possible attribute views and analytic views with the tables used and the type of joins they have, are displayed to the user for selection.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 9","b":["1","2","9","910","500","910","1","2","1","1","2","1","2","1"]},"Similarly, on continuing to parse the sample universe schema, the logic determines that the table \u2018T\u2019 and table \u2018T\u2019 match the \u2018attribute view pattern\u2019. Based on the determined \u2018attribute view pattern\u2019, attribute view \u2018AT\u2019 is created with the tables \u2018T\u2019 and \u2018T\u2019. The sample universe schema displaying the generated attribute views \u2018AT\u2019 and \u2018AT\u2019 is shown in . The logic in the flow diagram , involved in determining the \u2018analytic view pattern\u2019 corresponding to the analytic view, and generating the determined analytic view, is executed in the sample universe schema shown in . The sample universe schema is parsed and the logic determines that the table \u2018T\u2019 matches the criteria of the fact table. The logic determines if the fact table \u2018T\u2019, the adjoining tables \u2018T\u2019, \u2018T\u2019 and the tables in the attribute view \u2018AT\u2019, match the \u2018analytic view pattern\u2019. Based on the determined \u2018analytic view pattern\u2019, analytic view \u2018AN\u2019 is created with tables \u2018T\u2019, \u2018T\u2019, and tables in the attribute view \u2018AT\u2019. The sample universe schema displaying the generated analytic view \u2018AN\u2019 is shown in .","The various embodiments described above have a number of advantages. For example, for a customer requiring migration from \u2018database X\u2019 to the in-memory database, it is easy and convenient for the customers to use the universe schema in the \u2018database X\u2019 for modeling in the in-memory database, since the customer has prior knowledge and understanding of the universe schema. Thus, this approach eliminates the substantial time spent using manual approach of modeling in the in-memory database. Therefore, performance of modeling using the universe schema in the front-end application provides a significant improvement over the manual approach of modeling. The logic built in the front-end application reduces the time taken to generate in-memory views drastically. The display of the generated in-memory views in the front-end application provides ease of use for the customers in validation and selection of the in-memory views.","Some embodiments may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. A computer readable storage medium may be a non-transitory computer readable storage medium. Examples of non-transitory computer readable storage media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (ASICs), programmable logic devices (PLDs) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 10","b":["1000","1000","1005","1055","1005","1000","1040","1055","1010","1015","1010","1015","1015","1010","1015","1015","1005","1015","1000","1025","1030","1000","1025","1030","1000","1335","1000","1050","1050","1000","1045","1000","1020","1060","1060","1060","1050","1060"]},"A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a mark-up language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as. Open Data Base Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize, however that the embodiments can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in detail.","Although the processes illustrated and described herein include series of steps, it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps, as some steps may occur in different orders, some concurrently with other steps apart from that shown and described herein. In addition, not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover, it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.","The above descriptions and illustrations of embodiments, including what is described in the Abstract, is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of, and examples for, the one or more embodiments are described herein for illustrative purposes, various equivalent modifications are possible within the scope, as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather, the scope is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments with particularity. The embodiments are illustrated by way of examples and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. The embodiments, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
