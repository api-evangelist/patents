---
title: Method and system for providing coordinated checkpointing to a group of  independent computer applications
abstract: A method and system of checkpointing single process application groups and multi-process application groups. In an exemplary embodiment, the method may include creating at least one full checkpoint for each application in an application group, and creating at least one incremental application checkpoint for each application in the application group. Further, each of the at least one incremental application checkpoint may be automatically merged against a corresponding full application checkpoint. Further, checkpointing may be synchronized across all applications in the application group. In the exemplary embodiment, each application may use both fork( ) and exec( ) in any combination.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08347140&OS=08347140&RS=08347140
owner: Open Invention Network LLC
number: 08347140
owner_city: Durham
owner_country: US
publication_date: 20111122
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCHER DEVELOPMENT","INCORPORATION-BY-REFERENCE OF MATERIAL SUBMITTED ON A COMPACT DISC","NOTICE OF MATERIAL SUBJECT TO COPYRIGHT PROTECTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","1. INTRODUCTION","2. CHECKPOINTING ACROSS FORK AND EXEC","3. INCREMENTAL CHECKPOINTING OF APPLICATION GROUPS STARTED FROM ONE APPLICATION","4. INCREMENTAL CHECKPOINTING OF APPLICATION GROUPS","5. LAUNCHING INDEPENDENT APPLICATIONS","6. RESTORING AN APPLICATION GROUP","7. STORAGE CHECKPOINTING","8. INCREMENTAL CHECKPOINTING OF MEMORY PAGES WRITTEN FROM KERNEL SPACE","9. HANDLING OF EFAULT","10. LOSS-LESS MIGRATION OF APPLICATION GROUPS","11. VIRTUALIZATION AND LIVE MIGRATION OF APPLICATION GROUPS","12. DEPLOYMENT SCENARIOS","13. SYSTEM DIAGRAM","14. CONCLUSION"],"p":["This application is a continuation of U.S. application Ser. No. 12\/334,634 filed on Dec. 15, 2008, entitled METHOD AND SYSTEM FOR PROVIDING COORDINATED CHECKPOINTING TO A GROUP OF INDEPENDENT COMPUTER APPLICATIONS, which is incorporated herein by reference in its entirety. This application is related to U.S. provisional application Ser. No. 60\/797,219 filed on May 2, 2006, U.S. patent application Ser. No. 11\/213,678 filed on Aug. 26, 2005, and U.S. patent application Ser. No. 11\/741,535 filed on Apr. 27, 2007, each of which are incorporated herein by reference in their entirety.","Not Applicable","Not Applicable","A portion of the material in this patent document is subject to copyright protection under the copyright laws of the United States and of other countries. The owner of the copyright rights has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the United States Patent and Trademark Office publicly available file or records, but otherwise reserves all copyright rights whatsoever. The copyright owner does not hereby waive any of its rights to have this patent document maintained in secrecy, including without limitation its rights pursuant to 37 C.F.R. \u00a71.14.","1. Field of the Invention","This invention pertains generally to enterprise computer systems, computer networks, embedded computer systems, wireless devices such as cell phones, computer systems, and more particularly with methods, systems and procedures (i.e., programming) for providing high-availability, virtualization and checkpointing services for a group of computer applications","2. Description of Related Art","Enterprise and wireless systems operating today are subject to continuous program execution that is 24 hours a day and 7 days a week. There is no longer the concept of \u201covernight\u201d or \u201cplanned downtime\u201d. All programs and data must be available at any point during the day and night. Any outages or deteriorated service can result in loss of revenue as customers simply take their business elsewhere, and the enterprise stops to function on a global scale. Traditionally, achieving extremely high degrees of availability has been accomplished with customized applications running on custom hardware, all of which is expensive and proprietary. Furthermore, application services being utilized today are no longer run as single applications or processes; instead, they are built from a collection of individual programs jointly providing the service. Traditionally, no mechanisms have existed for protecting such multi-application services This problem is compounded by the fact that the individual applications comprising the service are typically provided by different vendors and may get loaded at different times","Two references provide a background for understanding aspects of the current invention. The first reference is U.S. patent application Ser. No. 11\/213,678 filed on Aug. 26, 2005, incorporated above in its entirety, which describes how to provide transparent and automatic high availability for applications where all the application processes run on one node. The second reference is U.S. Pat. No. 7,293,200 filed on Aug. 26, 2005 which describes how to transparently provide checkpointing of multi-process applications, where all processes are running on the same node and are launched from one binary. The present invention is related to applications comprised of one or more independent applications, where the independent applications dynamically join and leave the application group over time.","A method, system, apparatus and\/or computer program are described for achieving checkpointing, restoration, virtualization and loss-less migration of application groups. The invention provides transparent migration and fail-over of application groups while ensuring that connected clients remain unaware of the migration. The client's connection and session are transparently transferred from the primary to the backup server without any client involvement","The term \u201ccheckpointing\u201d and \u201ccheckpointing service\u201d is utilized herein interchangeably to designate a set of services which capture the entire state of an application group and stores all or some of the application group state locally or remotely. The checkpointing services run (execute) on all nodes where one or more the application group's applications run (execute) or can fail over to.","The term \u201cnode\u201d is utilized herein to designate one or more processors running a single instance of an operating system. A virtual machine, such as VMWare or XEN VM instance, is also considered a \u201cnode\u201d. Using VM technology, it is possible to have multiple nodes on one physical server.","The term \u201capplication group\u201d is utilized herein to describe a set of independent applications that jointly provide a service. The term \u201cindependent\u201d is utilized herein to mean that the applications need no prior knowledge of each other. An application group is simply a logical grouping of one or more applications that together or independently provide some service. The independent applications do not need to be running at the same time. A member of the application group can also load, perform work and exit, essentially joining and leaving the group.","The terms \u201capplication\u201d and \u201cindependent application\u201d are utilized interchangeably to designate each of the applications in an application group. Each independent application can consist of one or more processes and be single threaded or multi-threaded. Operating systems generally launch an application by creating the application's initial process and letting that initial process run\/execute. In the following teachings, we often identify the application at launch time with that initial process and then describe how to handle creation of new processes via fork and\/or exec.","In the following, we use commonly known terms including but not limited to \u201cprocess\u201d, \u201cprocess ID (PID)\u201d, \u201cthread\u201d, \u201cthread ID (TID)\u201d, \u201cdisk\u201d, \u201cCPU\u201d, \u201cstorage\u201d, \u201cmemory\u201d, \u201caddress space\u201d, \u201csemaphore\u201d, \u201cSystem V, SysV\u201d, and \u201csignal\u201d. These terms are well known in the art and thus will not be described in detail herein.","The term \u201ccoordinator\u201d is utilized for designating a special control process running as an element of the invention. The coordinator is generally responsible for sending out coordination events, managing application group registration and for coordinating activities across all applications in an application group. For the sake of simplicity, the coordinator is often depicted as running on the same node as the application-group, however this is not a requirement as the coordinator can run on any node.","The term \u201ctransport\u201d is utilized to designate the connection, mechanism and\/or protocols used for communicating across the distributed application. Examples of transport include TCP\/IP, Message Passing Interface (MPI), Myrinet, FiberChannel, ATM, shared memory, DMA, RDMA, system busses, and custom backplanes. In the following, the term \u201ctransport driver\u201d is utilized to designate the implementation of the transport. By way of example, the transport driver for TCP\/IP would be the local TCP\/IP stack running on the host.","The term \u201cfork( )\u201d is used to designate the operating system mechanism used to create a new running process. On Linux, Solaris, and other UNIX variants, a family of fork( ) calls are provided. On Windows, one of the equivalent calls is \u201cCreateProcess( )\u201d. Throughout the rest of this document we use the term \u201cfork\u201d to designate the functionality across all operating systems, not just on Linux\/Unix. In general fork( ) makes a copy of the process making the fork( ) call. This means that the newly created process has a copy of the entire address space, including all variables, I\/O etc of the parent process.","The term \u201cexec( )\u201d is used to designate the operating system mechanism used to overlay a new image on top of an already existing process. On Linux, Solaris, and other UNIX, a family of exec( ) calls are provided. On Windows, the equivalent functionality is provided by e.g. \u201cCreateProcess( )\u201d via parameters. Throughout the rest of this document we use the term \u201cexec\u201d to designate the functionality across all operating systems, not just Linux\/Unix. In general, exec( ) overwrites the entire address space of the process calling exec( ). A new process is not created and data, heap and stacks of the calling process are replaced by those of the new process. A few elements are preserved, including but not limited to process-ID, UID, open file descriptors and user-limits.","The term \u201cshell script\u201d and \u201cshell\u201d is used to designate the operating system mechanism to run a series of commands and applications. On Linux, Solaris, and other Unix variants, a common shell is called \u2018bash\u2019. On Windows, equivalent functionality is provided by \u201ccmd.exe\u201d and .bat files or Windows PowerShell. Examples of cross-platform scripting technologies include JavaScript, Perl, Python, and PHP. Throughout the rest of this document we use the term \u201cshell\u201d and \u201cshell script\u201d to designate the functionality across all operating systems and languages, not just Linux\/Unix.","The term \u201cinterception\u201d is used to designate the mechanism by which an application re-directs a system call or library call to a new implementation. On Linux and other UNIX variants interception is generally achieved by a combination of LD_PRELOAD, wrapper functions, identically named functions resolved earlier in the load process, and changes to the kernel sys_call_table. On Windows, interception can be achieved by modifying a process' Import Address Table and creating Trampoline functions, as documented by \u201cDetours: Binary Interception of Win32 Functions\u201d by Galen Hunt and Doug Brubacher, Microsoft Research July 1999\u201d. Throughout the rest of this document we use the term to designate the functionality across all operating systems.","In the following descriptions, the product name \u201cDuration\u201d is utilized in referring to a system as described in the first and second references cited previously. It should be appreciated, however, that the teachings herein are applicable to other similarly configured systems.","By way of example, consider an e-Commerce service consisting of a WebLogic AppServer and an Oracle Database. In this case WebLogic and Oracle would be the independent applications, and the application group would consist of WebLogic and Oracle database.","By way of example, consider a cell phone with an address book and built-in navigation system. In this case the address book and the navigation would be the independent applications, and the application group would consist of the address book and the navigation application.","By way of example, consider a shell-script running a series of applications and other scripts. In this case the script and all applications and scripts launched by the script comprise the application group, and all the individual applications and other scripts called within the script, are the independent applications.","The two references sited above cover the cases where the multi-process applications are created starting with one binary. As described in U.S. Pat. No. 7,293,200, this is generally accomplished by the application using a series of fork( ) calls to create new sub-processes. The present invention broadens the checkpointing services to cover all types of multi process applications, including those that exec( ).","In at least one embodiment, a method of checkpointing single process application groups and multi-process application groups is provided. The method may include","creating at least one full checkpoint for each application process in an application group, and may include creating at least one incremental checkpoint for each application process in the application group. Further, the method may automatically merge each of the at least one available incremental application checkpoint against a corresponding full application checkpoint, and synchronize checkpointing across all applications in the application group. Each application may use both fork( ) and exec( ) in any combination.","In at least one embodiment, a special mechanism is provided to handle exec-only calls. With exec essentially overwriting the entire address space of the calling process, all registration and checkpointing information is lost. Special care needs to be taken to preserve this information across the exec call. One example embodiment of the present invention provides a mechanism to preserve such information using a combination of shared memory and environment variables.","In at least one embodiment, checkpointing services are configured for automatically performing a number of application services, including: injecting registration code into all applications in the application group during launch, registering the group's application as they launch, detecting execution failures, and executing from backup nodes in response to application group failure, application failure or node failure. The services can be integrated transparently into the system in that they are implemented on the system without the need of modifying or recompiling the application program, without the need of a custom loader, or without the need for a custom operating system kernel. In another embodiment, a custom loader is used.","In at least one embodiment, the checkpointing services are configured to support fork( ) and exec( ) in any combination. Exec( ) without an prior fork( ) overwrites the entire address space of the application, including all registration with the coordinator, fault detectors etc. The present invention provides techniques to handle the fact that all memory and registration information is being overwritten during exec( ).","In at least one embodiment, the checkpointing services supports shell scripts, where the core shell script application launches (using fork( )\/exec( )) and overlays (using exec( )), new independent applications in any order.","The present invention comprises a set of checkpointing services for application groups. The checkpointing services run on every node where the group application can run. One embodiment of the invention generally functions as an extension of the operating system and runs on all nodes. A coordination mechanism is utilized to ensure that the execution of the independent applications are coordinated at certain points.","By way of example, and not of limitation, the present invention implements checkpointing services for stateless applications (e.g., sendmail), stateful applications (e.g., Voice over IP (VOIP)), multi-tier enterprise applications (e.g., Apache, WebLogic and Oracle Database combined), wireless devices, such as cell phones, pages and PDAs, and large distributed applications, for example those found in High Performance Computing (HPC), such as seismic exploration and financial modeling.","According to one aspect of the invention, the application group runs on a node, with one or more of the independent applications running at any point in time. Each independent application is running independently, but is protected and checkpointed together with all other independent applications in the application group.","According to one aspect of the invention the application group has one or more backup nodes ready to execute the independent application in the place of the original in the event of a fault. The protection of the application group is thus coordinated and guaranteed to be consistent across fault recovery.","An application group can be configured according to the invention with any number of independent applications. Each independent application runs on the primary node while the backup node for the applications stands ready to take over in the event of a fault and subsequent recovery. The primary and backup can be different nodes or the primary and backup can be the same node, in which case the fault recovery is local.","The invention provides layered checkpointing services for application groups, with checkpointing services provided both at the application group level and at the individual independent application level. High availability, including fault detection and recovery, for the individual independent application is provided by Duration's existing stateful High Availability Services. The invention layers a distributed fault detection and recovery mechanism on top of the local fault detection and ensures that fault detection and recovery is consistent across the entire grid.","According to one aspect of the invention, a coordinator provides general coordination and synchronization for the individual independent applications of the group applications. By way of example, and not limitation, the coordinator is shown running on the same node as the independent applications to simplify the following teachings. It should be appreciated, however, that this is not a requirement as the coordinator can run on any node in the system.","By way of example, and not of limitation, the invention implements stateless or stateful recovery of application groups by recovering each independent application and ensuring all independent applications are recovered in a consistent state. The recovery is automatic without any application group or independent application involvement.","According to an aspect of the invention, there is a clean separation of the application logic from the checkpointing services code. This allows application programmers to focus on writing their application code, rather than on writing checkpointing code. An administrator can make applications highly available by simply configuring the desired settings, such as by using a graphical configuration tool implemented according to the invention. The result is that high availability applications are developed easily and deployed quickly without the necessity of custom coding.","According to another aspect of the invention, protection is provided against node faults, network faults and process faults. The present invention provides user-controlled system management, automatic availability management, and publish\/subscribe event management, including notification of faults and alarms.","In various embodiments of the invention, features are provided that are useful for application groups that must be highly available, including but not limited to the following:","(a) Stateful high availability and checkpointing for application groups, scripts, including high performance computing, financial modeling, enterprise applications, web servers, application servers, databases, Voice Over IP (VOIP), Session Initiation Protocol (SIP), streaming media, Service Oriented Architectures (SOA), wireless devices, such as cell phones, and PDA.","(b) Coordinated Restart and stateful restore for applications groups.","(c) Coordinated and transparent checkpointing of application groups,","(e) Coordinated full and incremental checkpointing for applications groups.","(f) Checkpoints stored on local disks, shared disks, or memories.","(g) Automatic and transparent fault detection for application groups.","(h) Node fault detection.","(i) Process fault detection.","(j) Application group deadlock and hang protection through external health checks.","(k) Coordinated automatic and transparent recovery of applications groups.","(l) Auto-startup of applications groups.","(m) Script support of starting, stopping, or restarting.","(n) Dynamic policy updates.","(o) User-controllable migration of distributed applications.","The invention can be practiced according to various aspects and embodiments, including, but not limited to, those described in the following aspects and embodiments which are described using phraseology which is generally similar to the claim language.","According to an aspect of the invention a method for achieving transparent integration of a application group program with a high-availability protection program comprises: (a) injecting registration code, transparently and automatically, into all independent applications when they launch, without the need of modifying or recompiling the application program and without the need of a custom loader; (b) registering the independent applications automatically with the high-availability protection program; (c) detecting a failure in the execution of the application group or any independent application within the group; and (d) executing the application group with application group being executed from their respective backup servers automatically in response to the failure. The high-availability protection program is preferably configured as an extension of the operating system wherein recovery of application groups can be performed without modifying programming within said application programs. The high-availability protection can be configured for protecting against node faults, network faults, and process faults.","According to another aspect of the invention, a method, system, improvement or computer program for performing loss-less migration of an application group, including loss-less migration of all independent applications from their respective primary nodes to their backup nodes and while being transparent to a client connected to the primary node over a TCP\/IP, MPI, system bus or other transport. The transport, i.e. TCP\/IP, MPI, or system bus will optionally be flushed and\/or halted during checkpointing.","According to another aspect of the invention, a method, system, improvement or computer program performs loss-less migration of an application group, comprising: (a)","migrating the independent applications within an application, without loss, from their respective primary nodes to at least one backup node; (b) maintaining transparency to a client connected to the primary node over a transport connection; (c) optionally flushing and halting the transport connection during the taking of checkpoints; and (d) restoring the application group, including all independent applications, from the checkpoints in response to initiating recovery of the application. The execution transparency to the client is maintained by a high-availability protection program configured to automatically coordinate transparent recovery of distributed applications. Transparency is maintained by a high-availability protection program to said one or more independent applications running on a primary node while at least one backup node stands ready in the event of a fault and subsequent recovery.","According to another aspect of the invention, a method, system, improvement or computer program performs fault protection for applications distributed across multiple computer nodes, comprising: (a) providing high-availability application services for transparently loading applications, registering applications for protection, detecting faults in applications, and initiating recovery of applications; (b) taking checkpoints of independent applications within applications groups; (c) restoring the independent applications from the checkpoints in response to initiating recovery of one or more the applications; (d) wherein said high-availability application services are provided to the independent applications running on a primary node, while at least one backup node stands ready in the event of a fault and subsequent recovery; and (e) coordinating execution of individual independent applications within a coordinator program which is executed on a node accessible to the multiple computer nodes.","According to another aspect of the invention, a method, system, improvement or computer program performs loss-less migration of an application group, comprising: (a) a high-availability services module configured for execution in conjunction with an operating system upon which at least one application can be executed on one or more computer nodes of a distributed system; and (b) programming within the high-availability services module executable on the computer nodes for loss-less migration of independent applications, (b)(i) checkpointing of all state in the transport connection, (b)(ii) coordinating checkpointing of the state of the transport connection across the application group (b)(iii) restoring all states in the transport connection to the state they were in at the last checkpoint, (b)(iv) coordinating recovery within a restore procedure that is coupled to the transport connection.","According to another aspect of the invention, there is described a method, system, improvement and\/or computer program for maintaining all transport connection across a fault. Transport connections will be automatically restored using Duration's virtual IP addressing mechanisms.","Another aspect of the invention is a method, system, improvement and\/or computer program that provides a mechanism to ensure that the independent applications are launched in the proper order and with the proper timing constraints during recovery.","In one embodiment, a mechanism is also provided to ensure that application programs are recovered in the proper order.","Another aspect of the invention is a method, system, computer program, computer executable program, or improvement wherein user controllable launch of independent applications for the application group is provided.","Another aspect of the invention is a method, system, computer program, computer executable program, or improvement wherein user controllable stop of independent applications and application group is provided.","Further aspects of the invention will be brought out in the following portions of the specification, wherein the detailed description is for the purpose of fully disclosing preferred embodiments of the invention without placing limitations thereon.","Referring more specifically to the drawings, for illustrative purposes the present invention will be described in relation to  through . It will be appreciated that the system and apparatus of the invention may vary as to configuration and as to details of the constituent components, and that the method may vary as to the specific steps and sequence, without departing from the basic concepts as disclosed herein.","The context in which this invention is described is an application group consisting of any number of independent applications. Each independent application runs on the primary node and can be supported by one or more designated backup nodes. Without affecting the general case of multiple backups, the following describes scenarios where each independent application has one primary node and one backup node. Multiple backups are handled in a similar manner as a single backup.","The mechanisms for transparently loading applications, transparently registering applications for protection, preloading libraries, transparently detecting faults, and transparently initiating recovery are described in the first reference above which was incorporated by reference. The mechanisms for taking checkpoints of multi-process, multi-threaded processes including processes using fork, and restoring from those checkpoints are described in the second reference above which was incorporated by reference. The mechanism for launching the coordinator, which in turn launches the application, is described in the first and second references, which were incorporated by reference. The mechanism used by the \u201cDuration AM\u201d to launch any process, including the coordinator, is described in the first and second reference and incorporated by reference. All applications in this invention may be launched by the Duration AM, through either a coordinator or directly.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 1","b":["10","12","11","11","24","14","16","24","18","20","24","26","28","24","28","14","15","18","20","20","20","27","28","29","20","28","22","30","32"]},{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 2","FIG. 3"],"b":["40","42","41","41","54","46","54","48","50","54","56","58","58","50","58","60"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 3","FIG. 3","FIG. 2"],"b":["70","54","71","73","75"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["Checkpoint barrier info, including barrier semaphore ID","Virtual PID table","Pipe table","Semaphore ID table for non-checkpointer semaphores","SysV shared memory segment ID table (non-checkpointer segments)\n\nAfter attaching to the global state in shared memory, the application resumes execution . The exec interceptor  is called when the main application calls exec. The interceptor  proceeds to capture all process data that must be preserved across exec. The example embodiment  preserves the following data using shared memory\n","Registration Info","Fifo to communicate to coordinator","Checkpointer policies from parent","File info for files that don't close-on-exec (descriptors, creation attributes, flags, dup info, etc.)","Dynamic priority and scheduling policy\/parameters","Signal mask","Virtualized resource limits","Virtualized IP info","Virtualized SysV shared memory segment IDs for segments the process is attached to (non-checkpointer segments)","Application group logical name (HA_APPLICATION)","Coordinator process ID","Defunct children info\n\nIn this context \u201cvirtualized\u201d is utilized to mean the resource abstraction and remapping described in the two reference cited above. When all data has been assembled , it's written to shared memory . The shared memory is identified by a shared memory ID. In an example embodiment using POSIX shared memory, the shared memory ID can be constructed directly from the process ID of the process and the HA_APPLICATION name, so it is not necessary to save it to the environment. The exec-counter CPENV_EXEC is stored in the local environment , and the interceptor preserves it across the exec call. The shared memory is external to the process and remains unaffected by exec. With the exec-count stored in the local environment  and the state preserved in shared memory , the checkpointer library, using the exec-count and data retrieved from shared memory, takes the newly exec'ed process  through initialization as described under . In another embodiment, the shared memory ID and the CPENV_EXEC count are both written to the environment and used for correct re-initialization.\n"]}}}},"The mechanisms for taking checkpoints of multi-process, multi-threaded processes launched from one binary and restoring from those checkpoints are described in the second reference above which was incorporated by reference.  illustrates by way of example embodiment (), how an application group that uses both fork\/exec and exec is incrementally checkpointed. The coordinator  launched the application , and then installs interceptors and registers the process as described previously. Upon completion of the initialization the application  is ready and starts running . The first checkpoint  is a full checkpoint as there are no prior checkpoints. The 2checkpoint  is incremental and only contains the memory pages changed since the first checkpoint. The application now calls fork and creates a new process , which registers and installs interceptors. The 3checkpoint  is a bit more involved: both the original process  and the new process  are checkpointed incrementally. Following fork, both parent and child have identical address spaces, page tables, and identical lists of dirty pages. As each process ,  resume running, each become independent, but still have incremental information against the same full checkpoint; they can therefore both be checkpointed incrementally and merged against the pre-fork full checkpoint. If the child process  forks another process, the same description applies. The 4checkpoint  is incremental for both processes  and . The process  now calls exec and overlays a new image. Following the procedure described under  and  checkpointer infrastructure is preserved and the checkpointing continue to operate across the complete replacement of the address space. The 5checkpoint  is now a full checkpoint for process  while it continues to be incremental for . The 6checkpoint  is incremental for both processes  and . Upon termination of both processes ,  the application terminates .","Up until now we've described checkpointing of application groups where the independent applications are created using fork( ) and exec( ) from one application. We now turn to application groups consisting of multiple independent applications launched independently at different times.  illustrates by way of an example embodiment  how the coordinator  first launches application  and then installs interceptors and registers  with the coordinator. Application  is ready to run  and proceeds to run . In the meantime the Duration AM  launches a second independent application  and provides passes the coordinator  process ID and HA_APPLICATION name in the environment. Using the Coordinator PID and the HA_APPLICATION name, the application  registers with the coordinator . The second application is ready to run  and proceeds to run . While  looks similar to  there is one very significant difference: in , the second application  is created by fork( ) from the first application , while in  the second application  is launched independently from the first application . The mechanism by which application  joins an already running coordinator and checkpoint barrier is described in . The first checkpoint  is taken as a full checkpoint of application process . This is followed by an incremental checkpoint . The third checkpoint  includes the second independent application , and contains an incremental checkpoint for application  and a full checkpoint of application process . The fourth checkpoint  is incremental for both applications  and . The embodiment in  shows applications  and  without any use of fork( ) and exec( ).","It is readily apparent to someone skilled in the art, that application , could use fork( ) and\/or exec( ) and combined with the teachings above application groups containing any number of independent application, launched independently or via fork\/exec can be checkpointed using the present invention.","In order to let any independent application join an existing coordinator and application group, that new application needs to be able to find and communicate with the coordinator.  is an example embodiment  of how that can be achieved. The coordinator  launches the first application  and, as previously described, takes it through registration  and proceeds to let it run . At a later time, the Duration AM  launches a second application  and passes the coordinator  PID and HA_APPLICATION name via the environment. As described in the second reference, checkpointing is coordinated using a checkpointer semaphore. As described above the checkpointer semaphore is always stored in shared memory, and can be accessed via the shared memory ID constructed from the coordinator PID and HA_APPLICATION name both of were provided to the application  via the environment. The coordinator  is unaware of the second application  until registration, and could conceivably trigger a checkpoint during the registration process. To prevent checkpointing of partially launched applications, the second application  first acquires the checkpointer semaphore , which prevents the coordinator , from triggering checkpoints. This is followed by registration  with the coordinator  and followed by the release of the checkpointer semaphore . The mechanism for obtaining and releasing semaphores are well known in the art and will not be described further here. The new application  is now ready to run .","The launch mechanism described here combines with the previous teaching and completes the support for coordinated checkpointing of application groups to include both programmatic creation of processes with fork( ) and external loading of new processes with the AM. The teachings also support loading the applications at different times, as just described above.","The mechanisms for restoring multi-process, multi-threaded applications launched from one binary are described in the second reference above which was incorporated by reference. The checkpoints for the application groups contains all the process and thread tree hierarchy information, the environmental information needed to register independent applications and checkpoint across exec.  illustrates an example embodiment  of restoring an application groups. As described in the second reference, the coordinator  is initially launched as a place holder for all processes to be restored. The coordinator reads the process tables  from the checkpoint and creates the process hierarchy ,  for the entire application group. For the first process  the image is restored from the checkpoint and the environment variables . After the process hierarchy has been recreated each process exec its binary image the same number of times it previously exec'ed using checkpoint and environment variables. The second process  is similarly restored from checkpoint and environment variables , and each process exec as described for the first process. Interceptors for both application processes  and  are also installed at this point. The independent applications ,  are now ready to run and proceed to execute as of the restored checkpoints , . Both independent applications ,  now run and are checkpointed  using the techniques previously taught.","The mechanism for checkpointing the storage associated with a multi process application is described in reference two and incorporated by reference. The mechanisms as taught works as described for each application in an application groups. Combining the above teaching of coordinated checkpointing of application groups with the storage checkpointing for individual applications, the combined teachings fully covers storage checkpointing of application groups.","The mechanism for incremental checkpointing and how to mark\/clear dirty pages written from user-space is described in reference two and incorporated by reference. The mechanism relies on interception of SIGSEGV signal as described. However, attempts to write to read-only use-space pages in memory from kernel-mode, i.e. from a system call, do not trigger SIGSEGV; rather they return EFAULT as an error code. Systems calls in general return an EFAULT error in stead of triggering the SIGSEGV should they write to read-only application memory. The present invention adds full support for EFAULT from system calls, in addition to SIGSEGV. It should be noted that in the example embodiment system library functions can also return EFAULT. Since the system library EFAULTS originate outside kernel-mode, the previous teachings above apply; here we're only concerned with pages written from kernel space, i.e. system calls.  illustrates an example embodiment  of the coordinator  initializes  and launches the application or application group  as previously described. In one embodiment of the invention, a customized system library  is used. The customized system library  contains predefined pre-system-call and post-system-call function-calls to the checkpointer library.","By way of example, we consider the case where the application  calls a system-library call \u201clibrary_callX( )\u201d located in the system library . Initially the entry point library_callX( )  is called. Before reaching the system call  it executes the pre-call callback  and registers information with the checkpointer , then the system call  named \u201csystem_callA( )\u201d by way of example is run. The system call reaches the kernel  and system_callA( ) runs and returns potentially with an EFAULT error condition. The post-call callback  processes the error codes, if any, and updates via the callbacks  the page tables maintained by the checkpointer. Finally, control returns  to the application  and execution continues.","In another embodiment the standard system library is used, and the pre-system-call and post-system-call callbacks are installed dynamically by the coordinator as part of application initialization","As described in reference two and incorporated by reference, processing a SIGSEGV fault is done by updating the page table and making the page writable. We now proceed to describe the handling of EFAULT is more detail. Continuing with the example embodiment  in . If the system call \u201csystem_callA( )\u201d safely can be called again, the pre\/post callbacks operate as follows:","1. pre-call callback  does nothing","2. post-call callback  determines if EFAULT was returned. If EFAULT was returned due to the checkpointer write-protecting one of more of system_callA( )'s call-arguments memory pages, the pages are marked as writable, the checkpointers page table updated, and the system_callA( ) is called again.","If system_callA( ) cannot be safely called again, the present invention proceeds as follows:","1. the pre-call callback  marks memory pages belong to the calls arguments as dirty and disables write-protection for the duration of the system call.","2. let the call to system_callA( ) go through ","3. the post-call callback  then re-enables write protection for the affected pages","The terms \u201ccall-arguments memory pages\u201d and \u201cmemory pages belonging to call argument\u201d is utilized to mean the following. By way of example, a function might have a number of parameters, some of which are pointers to memory locations. The aforementioned \u201cmemory pages\u201d are the memory pages referenced, or pointed to, by pointers in argument list.","In another embodiment all EFAULT handling is done in a kernel module sitting under the system library.","Referring once again to  for illustrative purposes, the case of migrating the distributed application from one set of nodes to another set of nodes is considered. Migration of live applications is preferably utilized in responding to the anticipation of faults, such as detecting that a CPU is overheating, a server is running out of memory, and the like, when the administrator wants to re-configure the servers or when the servers currently being used have to be freed up for some reason.","Building on the disclosures above, a loss-less migration is achieved by: first checkpointing the application group, including all independent applications and optionally the local transports, then restoring all independent applications and optionally the local transports from the checkpoints on the backup nodes. The migration is loss-less, which means that no data or processing is lost.","Loss-less migration of application groups can be viewed differently. The ability to checkpoint and migrate entire application groups, makes the application location-independent. The application groups can be moved, started and stopped on any server at any point in time. The present teaching therefore shows how to de-couple a live running instance of an application from the underlying operating system and hardware. The application execution has therefore been virtualized and enables live migration, ie a migration of a running application, without any application involvement or even knowledge.",{"@attributes":{"id":"p-0111","num":"0127"},"figref":"FIG. 9","b":["240","242","244","246","248","252","244","246","250","258","256","244","246","242","254","256","244","246","252","242","244","246","250","252","254"]},{"@attributes":{"id":"p-0112","num":"0128"},"figref":"FIG. 10","b":["260","262","264","270","266","268","272","274","276","276","264","282","278","284","280"]},"In the embodiments described herein, an example programming environment was described for which an embodiment of programming according to the invention was taught. It should be appreciated that the present invention can be implemented by one of ordinary skill in the art using different program organizations and structures, different data structures, and of course any desired naming conventions without departing from the teachings herein. In addition, the invention can be ported, or otherwise configured for, use across a wide-range of operating system environments.","Although the description above contains many details, these should not be construed as limiting the scope of the invention but as merely providing illustrations of some of the exemplary embodiments of this invention. Therefore, it will be appreciated that the scope of the present invention fully encompasses other embodiments which may become obvious to those skilled in the art, and that the scope of the present invention is accordingly to be limited by nothing other than the appended claims, in which reference to an element in the singular is not intended to mean \u201cone and only one\u201d unless explicitly so stated, but rather \u201cone or more.\u201d All structural and functional equivalents to the elements of the above-described preferred embodiment that are known to those of ordinary skill in the art are expressly incorporated herein by reference and are intended to be encompassed by the present claims. Moreover, it is not necessary for a device or method to address each and every problem sought to be solved by the present invention, for it to be encompassed by the present claims. Furthermore, no element, component, or method step in the present disclosure is intended to be dedicated to the public regardless of whether the element, component, or method step is explicitly recited in the claims. No claim element herein is to be construed under the provisions of 35 U.S.C. 112, sixth paragraph, unless the element is expressly recited using the phrase \u201cmeans for.\u201d"],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING(S)","p":["The invention will be more fully understood by reference to the following drawings which are for illustrative purposes only:",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
