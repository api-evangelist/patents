---
title: System and method for communication between portal applications and portlet containers
abstract: This disclosure provides various embodiments for providing a communication layer between a portal application and a separate and independent portlet container. In one embodiment, a computer program product comprising computer readable instructions is operable when executed to expose an application programming interfaces (APIs) associated with methods permitting a portal application to invoke a portlet via the portlet container, where the portlet is run inside the portlet container. The computer program product exposes one or more service provider interfaces (SPIs) providing services implemented and used by the portlet container to obtain information about the portlet to be invoked. The computer program product further exposes an interface providing methods facilitating communications between the portal application and the portlet container during runtime of the portal application. The portal application running in combination with the portlet container implements the API, SPI, and interface during the portal application's runtime to allow for portal execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782676&OS=08782676&RS=08782676
owner: SAP AG
number: 08782676
owner_city: Walldorf
owner_country: DE
publication_date: 20090930
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This present disclosure relates to software, and, more particularly, to a system and method for communication and the exchange of runtime information between a portal application and a portlet container.","Many organizations implement an enterprise portal to host internal and external applications. A portal is an application which aggregates applications together in a presentable format. Beyond merely being a presentation layer, a portal (or portal application) typically allows users to customize the presentation, including what applications to display. A portal can also provide a convenient single sign-on mechanism for users.","In general, portlets, one of the building blocks of portals, started to become popular with developers and programmers after the first version of the Java Portlet Specification (JSR 168) was released in 2003. Many vendors in the Java portal space, both commercial and open-source vendors, have implemented this standard, and developers have written portlets using the Java Portlet Application Programming Interface (API). JSR 168, however, stopped at defining the overall user interface (UI) component model, and did not define means for building integrated composite applications out of these components. Many limitations from JSR 168 were addressed with the release of Java Portlet Specification version 2.0 (JSR 286).","The main new features of JSR 286 are the capabilities for coordination between different portlets that can be implemented by different parties and packaged in different web application archive (WAR) files. Specifically, the coordination features of JSR 286 are based on a publish\/subscribe model that does not request different portlet developers to know about each other's work. At development time, only data an individual portlet understands is defined, and the actual connections between portlets are created at deployment or at runtime. Leveraging these features, portal administrators or business users can build composite applications out of portlet components without predefined programming\u2014for example, the portals described above.","Previous methods of communication between the portal application and the Portlet Container included embedding the Portlet Container within the portal application, such that the portal application and the Portlet Container are the same component. In these instances, communication between the portal application and the Portlet Container can be handled internally by the combined component, and no additional communication definitions or operations need to be defined. However, this solution applies several restrictions to a solution\u2014namely, to change the portal application, a new portlet container must be defined in order to correspond to the modified portal application. Thus, modifications to either component cause significant hardship to developers and make ongoing integration of the components, or later modification to either of the components, difficult.","This disclosure provides various embodiments for providing a communication layer between a portal application and a separate and independent portlet container. In one embodiment, a computer program product comprising computer readable instructions is operable when executed to expose an application programming interfaces (APIs) associated with methods permitting a portal application to invoke a portlet via the portlet container, where the portlet is run inside the portlet container. Further, the computer program product exposes one or more service provider interfaces (SPIs) providing services implemented and used by the portlet container to obtain information via the calling portal application about the portlet to be invoked. The computer program product further exposes an interface providing methods facilitating communications between the portal application and the portlet container during runtime of the portal application. The portal application running in combination with the portlet container implements the API, SPI, and interface during the portal application's runtime to allow the portal application to execute the portlet.","The details of one or more embodiments of the present disclosure are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the present disclosure will be apparent from the description and drawings, and from the claims.","With the release of the Java Portlet Specification version 2.0 (JSR 286), programmers and developers have increasingly been able to more closely integrate proprietary technologies and platforms previously used with the standardized component model for building componentized user interfaces (UIs) for services as defined by JSR 286. To do so, a common programming model for integrating proprietary and non-proprietary content into a single portal has been developed. Specifically, by providing an implementation of an advanced Portlet Container that can host and run portlets defined by the standard, simple integration of non-proprietary content into a formerly proprietary-only portal or portal application can be performed. Additionally, a Portlet Container compliant with the new JSR 286 standard provides the ability for proprietary portal applications and their portlets to use different UI technologies.","While the JSR 286 standard provides how web components and portlets can be invoked, the specification does not provide how the portal application communicates with the portlet itself. Clients associated with the portal application use specific Uniform Resource Locaters (URLs) to request a specific web page, the web page associated with or representing an overall portal application. As the portal application aggregates a plurality of portlets, the portal application searches the associated portlets and notifies the Portlet Container that specific portlets should be invoked. The portlets themselves reside within the Portlet Container, which provides the portlets with the appropriate runtime environment to perform their operations. JSR 286 specifies how these portlets are to be invoked, but does not provide the necessary information on how portal applications actually communicate with the Portlet Container. Thus, the present disclosure describes a particular embodiment of a Portlet Container that provides interfaces, methods, and other services that define the communication layer between the portal application and the Portlet Container.","The present disclosure describes a separation of the portal application and Portlet Container, in turn providing flexibility to users and developers, in that the Portlet Container is used for portlet deployment, portlet runtime, and other portlet-related tasks, separate from the portal application. Should changes to the portal application be necessary, there is no need to modify the Portlet Container. Further, customers and other developers can elect to use any portal application that is compatible with JSR 286, including open-source portal applications, as well as proprietary portal applications specific to a type of enterprise or other software. Additionally, the separation of the Portlet Container allows the design of a Portlet Container that is similar to previously-defined servlet containers. At a high level, the servlet container is another type of container that provides a runtime environment for web applications called servlets. By using the servlet container as a starting point, the Portlet Container described herein can leverage the functionality provided by the servlet container.","The goals of the advanced Portlet Container described in the present disclosure are to provide an implementation of the Portlet Container that is compliant with JSR 286, to provide an application programming interface (API) to be used by a proprietary or non-proprietary enterprise portal to invoke portlets and to perform various administrative tasks associated with the invoked portlets, and to provide an SPI to be implemented by the proprietary enterprise portal and used by the Portlet Container implementation to obtain information about the portlet to be invoked, events and public render parameters to be distributed to the invoked portlets, to conveniently store preferences associated with a particular portlet, to manage a portlet's caching mechanism, and means to generate a particular portlet URL.","The functional requirements of the advanced Portlet Container may include one or more of the following:\n\n","Turning to the example implementation of , the illustrated environment  which illustrates a particular implementation of the advanced Portlet Container, or Portlet Container 2.0, and includes or is communicably coupled with server  and one or more clients , at least some of which communicate across network . In general, environment  depicts an example configuration of a system implementing an advanced implementation of Portlet Container 2.0, which provides additional Portlet Container APIs and SPIs to implement the communication layer between the portal application and the Portlet Container, and in turn, each of the individual portlets.","In general, the server  is any server that stores one or more portal applications , where at least a portion of the portal applications  aggregate portlet applications, or portlets, together in a presentable format in response to requests sent or received from users or clients within and communicably coupled to the illustrated environment . In some instances, the server  may store a plurality of portal applications  and portlets, while in other instances, the server  may be a dedicated server meant to store and execute only a single portal application . In some instances, the server  may comprise a web server, where the portal applications  represent one or more web-based applications accessed and executed via network  by the clients  of the system to perform the programmed tasks or operations of the portal application .","At a high level, the server  comprises an electronic computing device operable to receive, transmit, process, store, or manage data and information associated with the environment . Specifically, the server  illustrated in  is responsible for receiving requests from one or more client applications  associated with the clients  of environment  and responding to the received requests by processing said requests in the associated portal application  (and communicably coupled portlets and\/or portlet applications), and sending or displaying the appropriate response from the portal application  (and aggregated portlets and\/or portlet applications) back to the requesting client application . In addition to requests from the external clients  illustrated in , requests associated with the portal application  may also be sent from internal users, external or third-party customers, other automated applications, as well as any other appropriate entities, individuals, systems, or computers. As used in the present disclosure, the term \u201ccomputer\u201d is intended to encompass any suitable processing device. For example, although  illustrates a single server , environment  can be implemented using two or more servers , as well as computers other than servers, including a server pool. Indeed, server  may be any computer or processing device such as, for example, a blade server, general-purpose personal computer (PC), Macintosh, workstation, UNIX-based workstation, or any other suitable device. In other words, the present disclosure contemplates computers other than general purpose computers, as well as computers without conventional operating systems. Further, illustrated server  may be adapted to execute any operating system, including Linux, UNIX, Windows, Mac OS, or any other suitable operating system. According to one embodiment, server  may also include or be communicably coupled with a mail server.","In the present implementation, and as shown in , the server  includes a processor , an interface , a memory , and one or more portal applications . The interface  is used by the server  for communicating with other systems in a client-server or other distributed environment (including within environment ) connected to the network  (e.g., client , as well as other systems communicably coupled to the network ). Generally, the interface  comprises logic encoded in software and\/or hardware in a suitable combination and operable to communicate with the network . More specifically, the interface  may comprise software supporting one or more communication protocols associated with communications such that the network  or interface's hardware is operable to communicate physical signals within and outside of the illustrated environment .","Generally, the network  facilitates wireless or wireline communications between the components of the environment  (i.e., between the server  and the clients ), as well as with any other local or remote computer, such as additional clients, servers, or other devices communicably coupled to network  but not illustrated in . The network  is illustrated as a single network in , but may be a continuous or discontinuous network without departing from the scope of this disclosure, so long as at least a portion of the network  may facilitate communications between senders and recipients. The network  may be all or a portion of an enterprise or secured network, while in another instance at least a portion of the network  may represent a connection to the Internet. In some instances, a portion of the network  may be a virtual private network (VPN), such as, for example, the connection between the client  and the server . Further, all or a portion of the network  can comprise either a wireline or wireless link. Example wireless links may include 802.11a\/b\/g\/n, 802.20, WiMax, and\/or any other appropriate wireless link. In other words, the network  encompasses any internal or external network, networks, sub-network, or combination thereof operable to facilitate communications between various computing components inside and outside the illustrated environment . The network  may communicate, for example, Internet Protocol (IP) packets, Frame Relay frames, Asynchronous Transfer Mode (ATM) cells, voice, video, data, and other suitable information between network addresses. The network  may also include one or more local area networks (LANs), radio access networks (RANs), metropolitan area networks (MANs), wide area networks (WANs), all or a portion of the Internet, and\/or any other communication system or systems at one or more locations.","As illustrated in , server  includes a processor . Although illustrated as a single processor  in , two or more processors may be used according to particular needs, desires, or particular embodiments of environment . Each processor  may be a central processing unit (CPU), a blade, an application specific integrated circuit (ASIC), a field-programmable gate array (FPGA), or another suitable component. Generally, the processor  executes instructions and manipulates data to perform the operations of server  and, specifically, the one or more plurality of portal applications . Specifically, the server's processor  executes the functionality required to receive and respond to requests from the clients  and their respective client applications , as well as the functionality required to perform the other operations of the portal application , such as retrieving and rendering data associated with the one or more portlet applications associated with and aggregated by the portal application . Regardless of the particular implementation, \u201csoftware\u201d may include computer-readable instructions, firmware, wired or programmed hardware, or any combination thereof on a tangible medium operable when executed to perform at least the processes and operations described herein. Indeed, each software component may be fully or partially written or described in any appropriate computer language including C, C++, Java, Visual Basic, assembler, Perl, any suitable version of 4GL, as well as others. It will be understood that while portions of the software illustrated in  are shown as individual modules that implement the various features and functionality through various objects, methods, or other processes, the software may instead include a number of sub-modules, third party services, components, libraries, and such, as appropriate. Conversely, the features and functionality of various components can be combined into single components as appropriate. In the illustrated environment , processor  executes one or more portal applications  on the server .","At a high level, each of the one or more portal applications  is any application, program, module, process, or other software that may execute, change, delete, generate, or otherwise manage information according to the present disclosure, particularly in response to and in connection with one or more requests received from the illustrated clients  and their associated client applications . In certain cases, only one portal application  may be located at a particular server . In others, a plurality of related and\/or unrelated portal applications  may be stored at a single server , or located across a plurality of other servers , as well. In certain cases, environment  may implement a composite portal application . For example, portions of the composite application may be implemented as Enterprise Java Beans (EJBs) or design-time components may have the ability to generate run-time implementations into different platforms, such as J2EE (Java 2 Platform, Enterprise Edition), ABAP (Advanced Business Application Programming) objects, or Microsoft's. NET, among others. Additionally, the portal applications  may represent web-based applications accessed and executed by remote clients  or client applications  via the network  (e.g., through the Internet). Further, while illustrated as internal to server , one or more processes associated with a particular portal application  (such as some or all of the associated portlet and\/or portlet applications) may be stored, referenced, or executed remotely. For example, one portion of a particular portal application  may be a web service associated with the application that is remotely called, while another portion of the portal application  may be an interface object or agent bundled for processing at a remote client . Moreover, any or all of the portal applications  may be a child or sub-module of another software module or enterprise application (not illustrated) without departing from the scope of this disclosure. Still further, portions of the portal application  may be executed by a user working directly at server , as well as remotely at client .","At least one of the portal applications  represents a web application that can aggregate portlets and\/or portlet applications together in a presentable format. Beyond merely being a presentation layer, the portal application  typically allows users to customize their presentation, including what portlets and\/or portlet applications to display. Additionally, certain portal applications  can be used to provide a convenient single sign-on mechanism for users, providing access to each portlet and\/or portlet application associated with the portal application  once the user is logged in, such that the user does not have to log into every application separately. Each portal application  may be associated with a specific URL, such that users and clients  requesting the specific URL are directed to the portal application . When the portal application  receives the request, it can access the one or more portlets and\/or portlet applications via the Portlet Container  associated with the portal application  to generate a response aggregating the processing and data associated with the various portlet applications.","Server  contains, and processor  executes, several portlets associated with the portal application  and stored within the Portlet Container . In the illustrated embodiment of , server  stores three portlets: Portlet A , Portlet B , and Portlet C . Although each of the illustrated portlets is located internal to server , the portlets may in some instances be stored within, or hosted by, the Portlet Container . Additionally, one or more of the portlets may be located external to server , as well as external to illustrated environment , and still be included within the set of portlets aggregated within the portal application . As illustrated in , the portal application  aggregates information generated by or received from each of Portlet A , Portlet B , and Portlet C  to form a complete web or portal page. Additionally, any or all of the illustrated portlets may be a portlet application or a portion thereof. A portlet application is a collection of portlets, classes, HTML pages, servlets, JavaServer Pages (JSPs), and other resources necessary for a portlet to build the associated UI component. Restated, portal pages may be associated with one or more portlet applications in order to provide certain functionality or other content to the portal application . Additionally, one portlet can be a part of different portal pages. Still further, one portal page can embed portlets from different portlet applications.","The Portlet Container  interacts with each of the portlets (, , ) via the Portlet 2.0 API , a defined API included with the JSR 286 specification defining the interfaces, methods, and classes for interacting with the portlets. Portlet Container  uses the Portlet 2.0 API  to communicate and interact with each of the portlets associated therewith. Broadly, the Portlet API  defines the contract between the Portlet Container runtime environment and the portlets contained therein. The interfaces, methods, and classes of the Portlet 2.0 API  are used to communicate with the portlets so that requests from the portal application  (and thus, the client ) are processed by each individual portlet, and any information and markup generated in response to the portal application's  request are returned via the Portlet Container .","In general, a portlet is an individual web component made accessible to users or clients via the portal application . Typically, a single portlet generates only a fragment of the markup and information that a client or user views in a visualization of a related portal application, such as portal application . Portlets are reusable software (and in some cases, web) modules that provide access to web-based content, applications, and other resources. Because portlets are reusable, multiple instances of a single portlet can be used in connection with a portal application  to provide different data to each client or user. From a client's perspective, a portlet can be a window on a portal page providing a specific service or set of information. Generally, each portlet on the portal page is responsible for providing its output in the form of markup fragments to be integrated into the portal page. The portal application  is responsible for providing the markup surrounding each individual portlet. In Hypertext Markup Language (HTML), for example, the portal application  can provide markup that gives each portlet a title bar with minimize, maximize, help, and edit icons.","Portlet Container  provides the runtime environment for portlets using the JSR 168 and 286 portlet specification. In general, the portlet container  contains the portlets illustrated in , and manages their lifecycle. The Portlet Container  receives requests from the portal application  to execute requests on the one or more portlets hosted by the Portlet Container . While the Portlet Container  manages the lifecycles of the various portlets, the Portlet Container  is not responsible for aggregating the content produced by the individual portlets. Instead, it is the portal application's  responsibility to handle the aggregation of data and content received from the individual portlets. The Portlet Container  forwards requests from the portal application  to the appropriate portlet, and receives and forwards the related responses from the portlets to the portal application  for aggregation. The Portlet Container  can be implemented as an extension of the servlet container and can expose the PortletContainerInterface interface for integration with the portal application . In some instances the Portlet Container  will reuse the integration of Portlet Container 1.0 as an extension of the servlet container and implement the needed interfaces from a known location to be able to reuse the class loading, deploy, and web application lifecycle management of a web container.","For a portlet hosted in a non-distributed environment, the Portlet Container  will instantiate and use only one portlet object per portlet definition. The loading and instantiation of portlets occurs when the Portlet Container  starts the associated portlet and\/or portlet application. In most cases, the Portlet Container  uses the same ClassLoader that a web container would use for the web application portion of the portlet application. After the portlet object is instantiated, the Portlet Container  tries to initialize the portlet. If an error occurs during the initialization process, the Portlet Container  does not place the portlet in service. Instead, the Portlet Container  tries to reinitialize the portlet later when the portlet is needed to service a future request.","As illustrated in , the Portlet Container  includes a PortletContainer API  and a PortletContainer SPI . In general, the PortletContainer API  defines the functionality the Portlet Container  provides to the portal application . Through the PortletContainer API , the portal application  can invoke portlets and can receive information about the portlets deployed on the server , as well as provide a means for the portal application  to perform administrative tasks on the deployed portlet applications and portlets. The PortletContainer SPI  defines a collection of interfaces that the portal application  (or other Portlet Container  consumers such as a different portal application) can implement. Through the PortletContainer SPI , the Portlet Container  receives information about the invoked portlet and other portal-related information. The information is received through several services:\n\n","In some instances, the ServerCaching and ClientCaching services may be combined into a single CachingService service. Further discussion of the specific interfaces, methods, and operations performed by the PortletContainer API  and the PortletContainer SPI  will be discussed with regard to  below.",{"@attributes":{"id":"p-0036","num":"0053"},"figref":"FIG. 1A","b":["126","146","126","150","146","102","126","146","150","126","102","106","146"]},"The server  also includes memory . Memory  may include any memory or database module and may take the form of volatile or non-volatile memory including, without limitation, magnetic media, optical media, random access memory (RAM), read-only memory (ROM), removable media, or any other suitable local or remote memory component. Memory  may store various objects or data, including classes, frameworks, applications, backup data, business objects, jobs, web pages, web page templates, database tables, repositories storing business and\/or dynamic information, and any other appropriate information including any parameters, variables, algorithms, instructions, rules, constraints, or references thereto associated with the purposes of the server  and its one or more portal applications . Additionally, memory  may include any other appropriate data, such as VPN applications, firmware logs and policies, firewall policies, a security or access log, print or other reporting files, as well as others.","Specifically, illustrated memory  includes a set of portal preferences  and a set of cached portlet content . Although illustrated within memory , some or all of the illustrated elements may be located or stored outside of memory  and\/or server  (e.g., in different memories and\/or on multiple different servers, as well as in other locations external to, but communicably coupled with, environment ). For example, the set of portal preferences  and\/or the cached set of portlet content  may be included within the portal application  such that both (or one of) sets are inherent to the portal application  itself. Additionally, some or all of the set of portal preferences  may be stored at and specific to a particular client , and stored in the respective client's memory. In those instances, the portal application  may access such information stored at the client  prior to or concurrently with receiving the client request. In some instances, the preferences themselves may be included within the client request, allowing the portal application  to set itself to the proper configuration prior to providing the client  with the initial request. In general, the set of portal preferences  may include client-specific information associated with the visualization and operations of a particular portal application , and may be different for, or specific to, each client  interacting with the portal application . The set of cached portlet content  may include content generated from various portlets associated with the portal application , both internal and external to server . In some instances, information stored in the set of cached portlet content  may be associated with a particular ETag provided by the client . The ETag token may be generated by a portlet and returned to the portal application . When the client  interacts with the portal application , the portal application  determines the target portlets and sends a request to the Portlet Container . The Portlet Container  may then turn to the corresponding portlet passing the received ETag token to the portlet. The portlet associated with the received ETag can validate whether the cached content is still valid and instruct the portal application  to used the cached content or to generate new content. In other words, when the ETag is received with a client request, the portal application  may determine whether the information associated with the received ETag and stored in memory  is current. If such information is still valid, the portal application  may elect to use the cached content. If the information is not valid, the portal application  can request, via the Portlet Container , the associated portlet to generate updated content. The cached content may also be tied to a particular timeout value, such that when the timeout value is exceeded the cached content is deleted and\/or destroyed. When an ETag associated with the deleted content is received from the client , the portal application  will send a new request to the relevant portlet for updated content.","The illustrated environment of  also includes one or more clients . Each client  may be any computing device operable to connect to or communicate with at least the server  and\/or via the network  using a wireline or wireless connection. Further, as illustrated, each client  includes a processor , an interface , a graphical user interface (GUI) , a client application , and a memory . In general, each client  comprises an electronic computer device operable to receive, transmit, process, and store any appropriate data associated with the environment  of . It will be understood that there may be any number of clients  associated with, or external to, environment . For example, while illustrated environment  includes a single client , alternative implementations of environment  may include multiple clients  communicably coupled to the server , or any other number suitable to the purposes of the environment . Additionally, there may also be one or more additional clients  external to the illustrated portion of environment  that are capable of interacting with the environment  via the network . Further, the term \u201cclient\u201d and \u201cuser\u201d may be used interchangeably as appropriate without departing from the scope of this disclosure. Moreover, while each client  is described in terms of being used by a single user, this disclosure contemplates that many users may use one computer, or that one user may use multiple computers. As used in this disclosure, client  is intended to encompass a personal computer, touch screen terminal, workstation, network computer, kiosk, wireless data port, smart phone, personal data assistant (PDA), one or more processors within these or other devices, or any other suitable processing device. For example, each client  may comprise a computer that includes an input device, such as a keypad, touch screen, mouse, or other device that can accept user information, and an output device that conveys information associated with the operation of the server  (and portal application ) or the client  itself, including digital data, visual information, the client application , or the GUI . Both the input and output device may include fixed or removable storage media such as a magnetic storage media, CD-ROM, or other suitable media to both receive input from and provide output to users of the clients  through the display, namely, the GUI . In some instances, client  may be specifically associated with an administrator of the illustrated environment . The administrator can modify various settings associated with one or more of the other clients , the server , the portal application , and\/or any relevant portion of environment . For example, the administrator may be able to modify the relevant timeout values associated with the set of cached portlet content , as well as any of the set of portal preferences .","Each client  includes a client application  associated with the portal application . In particular, the client application  is any software, such as a web browser or remote portion of the portal application , that allows the client  to access and work with the portal application . Particularly, the client application  is a software application that enables the client  (or a user thereof) to display and interact with one or more of the portal pages provided by the portal application  executed at the server . Where the portal applications  are web-based applications, the client application  may be a specific application dedicated to use with a particular portal application , a general web browser with functionality allowing it to interact with the portal application , or any other appropriate software.","Further, the illustrated client  includes a GUI  comprising a graphical user interface operable to interface with at least a portion of environment  for any suitable purpose, including generating a visual representation of the client application  (in some instances, the client's web browser) and the interactions with the portal application , including the responses received from the portal application  received in response to the requests sent by the client application . Generally, through the GUI , the user is provided with an efficient and user-friendly presentation of data provided by or communicated within the system. The term \u201cgraphical user interface,\u201d or GUI, may be used in the singular or the plural to describe one or more graphical user interfaces and each of the displays of a particular graphical user interface. Therefore, the GUI  can represent any graphical user interface, including but not limited to, a web browser, touch screen, or command line interface (CLI) that processes information in environment  and efficiently presents the information results to the user. In general, the GUI  may include a plurality of user interface (UI) elements, some or all associated with the client application , such as interactive fields, pull-down lists, and buttons operable by the user at client . These and other UI elements may be related to or represent the functions of the client application , as well as other software applications executing at the client . In particular, the GUI  may be used to present the client-based visualization or perspective of the portal application , and may be used (as a web browser or using the client application  as a web browser) to view and navigate the portal application , as well as various web pages located both internal and external to the server, some of which may be associated with the portal application . In some instances, the GUI  may be a part of or the entirety of the client application , while in others merely a tool for displaying the visual representation of the client and portal applications'  actions and interactions. In some instances, the GUI  and the client application  may be used interchangeably, particularly when the client application  represents a web browser associated with the portal application .","Similar to server , the illustrated client  includes both an interface  and processor . The interface  of each client  may be similar to the interface  of the server , in that it may comprise logic encoded in software and\/or hardware in a suitable combination and operable to communicate with the network . More specifically, interface  may comprise software supporting one or more communication protocols such that the network  or hardware is operable to communicate physical signals to and from the client . The client's processor  may also be similar in nature to that of the server's processor . Again, although only illustrated as a single processor , two or more processors may be used according to particular needs, desires, or embodiments of environment . Similar to the server's processor , each client processor  may be a central processing unit (CPU), a blade, an application specific integrated circuit (ASIC), a field-programmable gate array (FPGA), or another suitable component. Generally, the processor  executes instructions and manipulates data to perform the operations of the client  and, specifically, the associated client application  described above. Specifically, the client's processor  executes the functionality required to send requests from the client  and its client application , as well as receive and process the associated responses from the portal application .","Each client  also includes a memory . Memory  may be similar to the server's memory , and may include any memory or database module, taking the form of either volatile or non-volatile memory including, without limitation, magnetic media, optical media, random access memory (RAM), read-only memory (ROM), removable media, or any other suitable local or remote memory component. For example, memory  may store backup data, parameters, cookies, variables, algorithms, instructions, rules, or references thereto, as well as any other suitable data.","As illustrated in , memory  includes a set of cached portal data  associated with the client application  and portal application . The set of cached portal data  is used by the client application  to cache, or store, portlet and\/or portal data associated with the responses received from the portal application  during client-portal application interactions. In some instances, the set of cached portal data  may store only the most recent information associated with the portal application , while in other instances, the set of cached portal data  may store additional information about previous content, thereby allowing the client application  to provide certain cached data to the user, if requested. Additionally, the cached portal data  may store certain ETags associated with certain portlets of the portal application , such that when a request for information from the portal application  is sent, information from the set of stored ETags is included. This may signal to the portal application  a certain user's identity or previous state, and allow the portal application  to load the cached information associated with a particular ETag from the set of cached portlet content . In general, the ETags may behave and be used similarly to cookies in a browser setting, allowing certain information associated with a particular user to be stored at the client  and accessed quickly by the server  when a request is sent. For example, when the client application  generates a request to be sent to the portal application , the client application  can access the set of cached portal data  to retrieve and integrate the current set of cached information into the request prior to transmission to the portal application .","While  is described as containing or being associated with a plurality of elements, not all elements illustrated within environment  of  may be utilized in each alternative implementation of the present disclosure. Additionally, one or more of the elements described herein may be located external to environment , while in other instances, certain elements may be included within or as a portion of one or more of the other described elements, as well as other elements not described in the illustrated implementation. Further, certain elements illustrated in  may be combined with other components, as well as used for alternative or additional purposes, in addition to those purposes described herein.",{"@attributes":{"id":"p-0046","num":"0063"},"figref":"FIG. 1B","b":["190","106","190","106","180","160","190","192","192","194","196","192","196","106","102","106","106","190","190","106","106","190"]},{"@attributes":{"id":"p-0047","num":"0064"},"figref":["FIG. 2","FIG. 2"],"b":["200","134","138","142","126","190","160","106","154","160","176"]},"The client request is received by portal application . In response, portal application  determines the set of portlets that should be executed in order to fulfill the client's request. By using the application programming interfaces (APIs) of a corresponding Portlet Container , portal application  invokes the various portlets. Portlet Container  maintains all available portlets and runs independently, but in response to requests, from portal application . Portlet Container  invokes the appropriate portlets\u2014as illustrated here, Portlet A , Portlet B , and Portlet C . The Portlet Container  receives the content generated by each of the portlets, and provides the corresponding fragments to the portal application . Portal application  aggregates these fragments according to the page's defined structure, and creates the associated portal page . Once created, portal application  sends the created portal page  to the client via network , where it is then presented to the client or associate via the client's GUI .","As described, client requests reach a portlet via the portal application . The portal application  invokes the portlet through the PortalContainer API . The API  allows the portal application  to request each of the methods defined in the Portlet interface\u2014processAction and render. In addition, if the portlet implements any of the optional lifecycle interfaces EventPortlet and ResourcePortlet, the additional lifecycle methods processEvent and serveResource may be invoked. When the portal application  invokes any of these lifecycle methods, it can provide the HttpServletRequest and HttpServletResponse objects. These objects convey the information from the original client request\/response associated with the client request to the Portal Application. In addition, it can provide the PortletNode object that represents the portal context in which the portlet runs. Then, the Portlet Container  creates the respective PortletRequest and PortletResponse objects to be used in invocation of the lifecycle methods.","Commonly, client requests are triggered by URLs created by portlets. A portlet URL is targeted to a particular portlet. For example, client requests triggered by an action URL include one action request, zero or more event requests, many render requests (one per portlet in the portal page), and zero or more resource requests. Client request triggered by a render URL include many render requests (one per portlet in the portal page) and zero or more event requests (no sequence is specified). Client requests triggered by a resource URL include one serve resource request.","When Action Request is triggered, the portal application  invokes the processAction method of the PortletContainer interface. The Portlet Container  then creates the corresponding ActionRequest and ActionResponse objects out of the HttpServletRequest and HttpServletResponse objects. These objects are passed to the processAction method of the portlet referred by the PortletNode.","When the portal application  determines that the client request triggers an EventRequest, the portal application  invokes the processEvent method of the PortletContainer interface. The Portlet Container  then creates the corresponding EventRequest and EventResponse objects out of the HttpServletRequest and HttpServletResponse objects. These objects are passed to the processEvent method of the portlet referred by the PortletNode interface.","With the EventRequest object, the Portlet Container  provides access to the event payload, window state, portlet mode, current render parameters, portal context, portlet session, and portlet preferences data. This data is available through the PortletNode object passed to the processEvent method. Further, the event payload can be obtained from the CoordinationService provided with the PortletNode object. The current public render parameters are obtained from the EventRequest object and from the CoordinationService. The target portlet may also set new render parameters in the EventResponse object. If public render parameters are set then this is reflected in the CoordinationService. The portlet may also publish events via the EventResponse.setEvent method. To publish the state changes and the notifications to the other portlets, the Portlet Container  can set the events in the CoordinationService via the setEvent method.","For invoking the render phase of portlets, the portal application  calls the render method of the PortletContainer interface. The Portlet Container  then creates the corresponding RenderRequest and RenderResponse objects out of the HttpServletRequest and HttpServletResponse objects. These objects are passed to the render method of the portlet referred by the PortletNode. The implementation of the RenderRequest object provides access to the following information: the parameters of the render request (including public render parameters that are made available via the CoordinationService), window state, portlet mode, portal context, portlet session, and portlet preferences data. Again, this data is available via the PortletNode object.","Resource request is a new request type introduced with JSR 286. Via this request, the portlet can serve resources or render content fragments. In order for the portal application  to invoke such methods on the target portlet, a method called serveResource is supplied to the PortletContainer interface. Again, the Portlet Container  creates the corresponding ResourceRequest and ResourceResponse objects out of the HttpServletRequest and HttpServletResponse objects. These objects are passed to the serveResource method of the portlet referred by the PortletNode. With the ResourceRequest object, the Portlet Container  provides the following information: parameters of the resource request, the input stream, the window state, the portlet mode, the portal context, the portlet session, and the portlet preferences data. The data is retrieved from the PortletNode, except for the input stream and portlet session, which are based on the underlying HttpServletRequest. For generating the content the Portlet Container  provides an output stream in the ResourceResponse object.","Usually, portlet developers extend the GenericPortlet abstract class when they want to get default functionality and convenient handling of action, event, resource and render requests. This approach is also robust against future changes in Portlet specification. For such cases the GenericPortlet class handles dispatching requests to the target methods that have the corresponding annotations. This class implements the Portlet, EventPortlet, and ResourceServingPortlet. However, portlet developers can use his\/her own implementation of these interfaces and use annotations to define the implementation methods. Portlet Container  can, in some instances, support this case and process the following annotations:\n\n","This is done in the following way for action dispatching, event dispatching, resource serving dispatching, and rendering dispatching.","Action Dispatching","When processAction method on PortletContainer interface is invoked, the Portlet Container  searches for a method annotated with @ProcessAction(name=<action name>), where the <action name> is equal to the request parameter ActionRequest.ACTION_NAME, and the following signature is defined in the targeted portlet:",{"@attributes":{"id":"p-0060","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void <methodname> (ActionRequest,"]},{"entry":[{},"ActionResponse) throws PortletException,"]},{"entry":[{},"java.io.IOException."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Event Dispatching","When processEvent method on PortletContainer interface is invoked, the Portlet Container  searches in the targeted portlet for the method annotated with @ProcessEvent (name=<event name>, where the <event name> specifies the event to be processed, and the method signature is:",{"@attributes":{"id":"p-0063","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void <methodname> (EventRequest,"]},{"entry":[{},"EventResponse) throws PortletException,"]},{"entry":[{},"java.io.IOException."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The Portlet Container  distinguishes both types of event name format\u2014\u201c{\u201c+Namespace URI+\u201d}\u201d+local part. If only the local part is provided, then the Portlet Container  will search for the alternative annotation \u201c@ProcessEvent (name=<event name_local_part>.\u201d If no such methods are found, the Portlet Container  sets the received render parameters as new render parameters, similar to the GenericPortlet.","Resource Serving Dispatching","When serveResource method of PortletContainer interface is invoked by the portal application , the Portlet Container  invokes the serveResource method of the targeted servlet. If the target servlet does not implement the ResourceServingPortlet, the Portlet Container does nothing.","Rendering Dispatching","When the render method of the PortletContainer interface is invoked by the portal application , the Portlet Container  searches in the target portlet for the method annotated with tag @RenderMode (name=<portlet mode name>) and the following signature:",{"@attributes":{"id":"p-0069","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void <methodname> (RenderRequest,"]},{"entry":[{},"RenderResponse) throws PortletException,"]},{"entry":[{},"java.io.IOException."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If no such methods are found, the Portlet Container  will throw PortletException. Also, the render method of PortletContainer evaluates the RenderRequest. RENDER_PART request attribute. This attribute can have two values: RenderRequest.RENDER_HEADERS and RenderRequest.RENDER_MARKUP, indicating the two parts of the render request. If the RENDER_HEADERS part is set, the portlet should set only header related data and the title. In this case, the Portlet Container  will only look for a render method in the target portlet. In those instances, the portlet should set headers, invoke setTitle and set nextPossiblePortletModes). If the request contains the RENDER_MARKUP attribute, then the Portlet Container  will search for the annotated render methods.","FIGS. -I--II illustrate an example sequence diagram  of an embodiment for creating a portal page with the additional functionality provided by the additional capabilities of the JSR 286 specification, and the various requests described above. Specifically, FIGS. -I--II show how content from a particular portlet (Portlet A ) may be assembled by the Portlet Container  to create portal page . As illustrated, client (or user)  sends a request to the portal application . As illustrated, the request is performed after the client  clicks on a link or button associated with a particular URL. Additional parameters associated with the action request are encoded within the URL. Action parameters are not render or public render parameters. The next set of parameters are request parameters associated with the client request. After publishing request parameters, post data is no longer available from the stream. Generally, previously set render parameters are automatically cleared when new action and\/or request parameters are sent. Action and request parameters are not propagated to subsequent render calls. Additionally, render parameters can be set in the ActionResponse object  during the processAction interaction.","As illustrated, the client  initially activates, clicks on, or requests an actionURL. Certain action parameters are encoded in the activated URL. The client's action is associated with a client request send to portal application . The portal application  processes the actionURL request by invoking the processAction method to the Portlet Container . The Portlet Container , as described above, generates an ActionRequest object  and an ActionResponse object  based on one or more action parameters typically included within the processAction request and provided via an HttpServletRequest object  created by the portal application . The Portlet Container  then gets a set of additional parameters from the HttpServletRequest object  for use in invoking the action request, and sets the retrieved parameters in the ActionRequest object  itself. Once the ActionRequest object  is prepared, the Portlet Container  invokes the portlet associated with the client request (Portlet A ) using the appropriate processAction method and the ActionRequest object .","Upon receiving the processAction request, Portlet A  sets one or more render parameters associated with Portlet A  in the ActionResponse object . As illustrated in , when Portlet A  wants to send an event to another portlet, it sets the event in the received PortletResponse object via the setEvent method. The setEvent method is sent to the ActionResponse object , which in turn is passed to the CoordinationService . The CoordinationService  is part of the communication layer between the portal application and the Portlet Conatiner  that coordinates and broadcasts events among various portlets. In other words, the CoordinationService  allows for coordination between multiple portlets, assisting in the provision of interactive portlets on a single portal page.","Next, the Portlet Container  uses the getRenderParameter( ) method to retrieve the one or more render parameters from the ActionResponse object . After completing the execution of the processAction method of the portlet, the Portlet Container  removes all previously set private render parameters from the PortletNode A  and sets the parameters from the action response. Parameters set in PortletNode A  are used in subsequent event and render calls.","Parameters set during the processAction method are used as render parameters during processEvent calls. Previously set render parameters are generally not propagated. Render parameters for subsequent calls can be set during the processEvent method in the EventResponse object . As shown, the portal application  sends a getEvent method request to the CoordinationService  associated with the processAction method. Additionally, the portal application  sends a processEvent method request to the Portlet Container . In response, the Portlet Container  creates both an EventRequest object  and an EventResponse object . Once the objects are created, the Portlet Container  retrieves the set of parameters set during the processAction method call from PortletNode A , and sets those retrieved parameters in the EventRequest object . The Portlet Container  then sends a processEvent request to Portlet A , and in response, Portlet A  sets one or more render parameters in the EventResponse object .","After execution of the processEvent method, the Portlet Container  removes or deletes the render parameters set in the PortletNode A  during the processEvent method. Portlet Container  then retrieves the parameters set in the EventResponse object , and sets those parameters in PortletNode A  to be used in subsequent event or render calls. As illustrated, portal application  then renders Portlet A  via the Portlet Container  as a result of the actions described above. In some instances, such as those shown here, additional portlets are also rendered via the Portlet Container  based on concurrent or additional execution of the portal application  and the Portlet Container . Although described as above in FIGS. -I--II, various implementations may be similar to or different from that illustrated. For example, certain portions or actions of FIGS. -I--II may be performed in a different order or not performed at all, while additional actions, requests, or other events may be included that are not currently illustrated. For example, the sequence diagram  may also include one or more serveResource method calls, allowing the portlet to serve additional resources to the portal application . Other variations will be understood by one of skill in the art.",{"@attributes":{"id":"p-0077","num":"0097"},"figref":"FIG. 3","b":"300"},"In the embodiment illustrated in , client  sends a client request  to a portal application  that requires portal page  to be generated. An HTTP session  is established between the client  and the portal application . The portal application  has to obtain portlets from a plurality of portlet applications and aggregate their content in order to generate portal page . Therefore, the client request  is forwarded to Portlet Container , which manages the portlet applications, or individual portlets (such as Portlet A , Portlet B , and Portlet C  of ). Portlet sessions  are created for every portlet that needs to be invoked. Each portlet session, from portlet session_  to portlet session_N , refers to an HTTP session specific to the portlet application and the current portlet session. For example, portlet session_  refers to HTTP session_ , and so on, to portlet session_N , which refers to HTTP session_N .","These HTTP sessions differ from the initial HTTP session established between the client  and the portal application . Thus, the different portlets do not share the same HTTP session. However, portlets, servlets, and JSPs within a particular portlet application share the same HTTP session. For portlets that reside within one and the same portlet application, each portlet request is generated as a result of a group of requests originating from the portal application  to complete a single client request , each portlet acquiring the same portlet session. The portlet session stores all attributes in the HTTP session of the portlet application. User attributes set in the portlet session are visible in the HTTP session associated with the portlet and vice versa. When a portlet invalidates a portlet session, the HTTP session also gets invalidated, and vice versa. In addition, crating a new portlet session results in creation of a new HTTP session on which the portlet session is based.",{"@attributes":{"id":"p-0080","num":"0100"},"figref":["FIG. 5","FIG. 1A"],"b":["500","106","106","106","126"]},"At runtime, the Portlet Container  registers, and thus exposes, a PortletContainerinterface runtime interface (not illustrated), in the runtime system . The portal application  looks up the PortletContainerinterface in the runtime registry, and uses the interface to implement and gain access to the APIs and SPIs defined by the PortletContainer API  and PortletContainer SPI . Specifically, the Portlet Container  implements the PortletContainerinterface interface to be used by the portal application  for access to the Portlet Container's  PortletAdmin and PortletContainer interfaces ( and  of , respectively). The portal application  uses the PortletAdmin and PortletContainer interfaces to administrate portlets and to call the Portlet Container  to run or invoke particular portlets in response to client requests.","As client requests are received, the portal application  determines that the client requests are targeted to particular portlets on the portal application's  associated portal page . In response, the portal application  obtains the PortletContainer interface from the PortletContainerInterface interface, and subsequently invokes the requested portlets via the obtained PortletContainer interface. Because of the Portlet Container's  compliance with both JSR 168 and JSR 286, the invoked portlets may be written to either standard.","Using the PortletContainer interface, the portal application  can invoke one of four phases for any of the portlets: a processAction phase, a processEvent phase, a serveResource phase, or a render phase. For each phase, the portal application  supplies information about the portlet to be invoked through the PortletNode interface ( of ) of the PortletContainer SPI . The PortletNode object represents the portlet instance that the portal application wants to invoke. The PortletNode object also carries additional information about the portal context in which the portlet runs. The portal application  provides an already-wrapped request and response object that represent the requests the client has made to the portal application  and that, in turn, need to be handled by the invoked portlet.","During the administration phase of portlet interaction, such as when the portal administrator composes the portal page  or designs the visualizations of the portal application , the portal application  needs particular information about the portlets hosted in the Portlet Container . The portal application  obtains this information via the PortletAdmin interface exposed by the PortletContainerInterface interface. In various embodiments, some or all of the following information about the portlets hosted by the Portlet Container  is available:\n\n","When the portal application  invokes a portlet via the PortletContainer interface, the Portlet Container can retrieve the following information from the supplied PortletNode interface of the PortletContainer SPI :\n\n","Additionally, when the portal application  invokes a portlet via the PortletContainer interface, the Portlet Container  can propagate back to the portal application  the following information via the PortletNode interface of the PortletContainer SPI :\n\n","Through its implemented connections to the Portlet Container , the portal application  receives notification, information, and events regarding the deployment, stoppage, and termination of certain portlets and portlet applications. Upon receiving these events and information, the portal application  can invalidate, clear, or update the cached content associated with any portlet and\/or portlet application (and stored in the set of cached portlet content  of ), as well as update the set of portal preferences  associated with a particular portlet or portlet application.","The portal application  also implements the PortletNode interface in order to identify requested portlets and to provide information related to the portal runtime environment. Using these interfaces, the portal application  manages the order of invocation for processAction, processEvent, serveResource, and render requests of the portlets associated with the portal page. Further, because the portal application  manages how portlets in a portal page  are wired together or interrelated, the way events are to be distributed between the portlets is also managed by the portal application . Similarly, the portal application  manages how public render parameters received with a client request will be shared among the portlets in the single portal page.","The portal application  can supply the implementation of the CoordinationService within the PortletNode. Specifically, the CoordinationService provides information to the Portlet Container  about the public render parameters and the events to be processed. In response, the Portlet Container  propagates back to the portal application  the published public render parameters and events associated with the currently invoked portlet.","The persistent storage of portlet preferences is performed by the portal application . The Portlet Container  retrieves the persisted portlet parameters (stored with the set of portal preferences  in server ) via the PortletPreferencesService within the PortletNode.","The portal application  also implements the PortletURLProviderService to provide means for providing string representations of portlet URLS to be embedded in the markup provided with the render portal page. The PortletURLProviderService is provided with the PortletNode. Additionally, the portal application  implements the CachingService in order to support the expiration and validation cache for portlet content. The Portlet Container  uses CachingService to propagate portlet runtime sets for the caching mechanism.","As new requests are received, the portal application  may be responsible for starting a new application thread for each portlet that will be invoked. The portal application  sends an already-wrapped request and response to the Portlet Container . This is done with the purpose of hiding portal application-specific details. The response is wrapped in order for the portal application  to be able to correctly aggregate the generated portlet content. Alternatively, the portal application  can reuse an application thread to perform the processAction method. For the rendering phase, more threads can be concurrently spawned in order to speed up portal page generation.","The portal application  implements the PortalContext (containing version, supported modes, and window states), and provides the information to the Portlet Container  at request time via the PortletNode. In some instances, the portal application  will store, or cache, portlet data and content next to user-specific portal data at server . This decision allows the portal application  and Portlet Container  to take the full benefit of the portal application platform persistence layer. Alternative methods of storing portlet data are also available.","FIGS. -I--II illustrate an example block diagram  of an embodiment illustrating the PortletContainer API  and PortletContainer SPI  associated with the advanced runtime implementation of Portlet Container 2.0 illustrated in , the API and SPI used to provide the communication layer between the portal application  and the Portlet Container  for the invocation and execution of portlets in the runtime system . It will be understood that certain methods, interfaces, and attributes may be associated with different APIs and\/or SPIs than illustrated in FIGS. -I--II, as well as in other APIs or SPIs not shown herein. Furthermore, some functionality associated with one or more of the illustrated APIs or SPIs may be combined or split among various interfaces and\/or APIs\/SPIs.","As previously described, the Portlet Container  includes a PortletContainerInterface runtime interface (not illustrated) that the Portlet Container  registers, and that subsequently can be used by the portal application . The PortletContainerInterface runtime interface has two methods which provide access to the main interfaces provided by the Portlet Container . The PortletContainerInterface runtime interface includes at least a subset of the following methods: \u201cpublic PortletAdmin getPortletAdmin( )\u201d and \u201cpublic PortletContainer getPortletContainer( )\u201d.","The \u201cgetPortletAdmin( )\u201d method allows the portal application  to obtain the PortletAdmin interface  from the PortletContainer API , the PortletAdmin interface  is responsible for supplying the information that the portal application  needs during the administration phase of building the associated portal page . The \u201cgetPortletContainer( )\u201d method allows the portal application  to obtain the PortletContainer interface  from the PortletContainer API , the PortletContainer interface  responsible for invocation of different phases of a portlet.","As previously described, the PortletContainer interface  allows the portal application  to invoke portlets. The Portlet Container  itself manages the life cycle of the portlets. The Portlet Container  implements the PortletContainer interface  in order to invoke portlets to process requests in one of four phases: processAction phase, processEvent phase, serveResource phase, and render phase. The PortletContainer interface  includes at least a subset of the following methods: \u201cprocessAction( )\u201d \u201crender( )\u201d \u201cserveResource( )\u201d and \u201cprocessEvent( )\u201d.","For each of the methods included in the PortletContainer interface , the portal application  is responsible for supplying the request and response objects corresponding to those requests made by the client  to the portal application . Additionally, the portal application  is to provide an implementation of the PortletNode interface  that uniquely describes the specific portlet on which the various methods are to be invoked.","The \u201cprocessAction( )\u201d method invokes the processAction phase of the particular portlet specified in a passed PortletNode object. The Portlet Container  creates the ActionRequest and the ActionResponse objects using passed HttpServletRequest and HttpServletResponse objects. Additionally, the method sets the appropriate request parameters and invokes the processAction method of the portlet defined by the PortletNode object.","The \u201crender( )\u201d method invokes the render method of the portlet specified in the given PortletNode object. The Portlet Container  creates the RenderRequest and the RenderResponse objects using the passed HttpServletRequest and HttpServletResponse objects. The method sets the render request parameters and invokes the render method of the portlet defined by the PortletNode object.","The \u201cserveResource( )\u201d method invokes the serveResource method of the portlet specified in the given PortletNode object. The Portlet Container  creates ResourceRequest and the ResourceResponse objects using the passed HttpServletRequest and HttpServletResponse objects.","The \u201cprocessEvent( )\u201d method invokes the processEvent method of the portlet specified in the given PortletNode object. The Portlet Container  creates the EventRequest and the EventResponse objects using the passed HttpServletRequest and HttpServletResponse objects. The method sets the Event to be processed in the EventRequest object and invokes the processEvent method of the portlet defined by the PortletNode object.","The PortletAdmin interface  of the PortletContainer API  allows the portal application  to retrieve and receive information regarding deployed portlets and portlet applications during the portlet administration phase of the portal application  design and modifications. Using the PortletAdmin interface , administrators can construct a full tree with all portlets deployed on the server in a hierarchical manner, such as \u201cvendor\/application name\/module name\/portlet.\u201d The PortletAdmin interface  also provide methods to allow and implement wiring between portlets on the portal page  as described in JSR 286. The portlet application may be able to retrieve and receive information regarding the events the portlet has declared to publish and accept. Similar functionality is also provided for the public render parameters.","The PortletAdmin interface  includes at least a subset of the following methods: \u201cgetVendors( )\u201d \u201cgetPortletApplicationNames( )\u201d \u201cgetPortletModuleNames( )\u201d \u201cgetAllPortlets( )\u201d \u201cgetPortletPreferences( )\u201d \u201cgetExpirationCache( )\u201d \u201cgetExpirationCache Scope( )\u201d \u201cgetSupportedModes( )\u201d \u201cgetPublicRenderParameterNames( )\u201d \u201cgetPublicRenderParameterType( )\u201d \u201cgetPublishingEventQNames( )\u201d \u201cgetProcessingEventQNames( )\u201d \u201cgetEvent( )\u201d and \u201cgetContainerRuntimeOptions( )\u201d.","The \u201cgetVendors( )\u201d method returns a list of all vendor names of the applications that contain portlet modules. The \u201cgetPortletApplicationNames( )\u201d method returns a list of J2EE applications that contain portlet web modules.","The \u201cgetPortletModuleNames( )\u201d method returns a list of all portlet-web-module names which belong to the specified portlet-J2EE-application. If the portlet application name is the full application name (i.e., \u201cvendor\u201d\/\u201capplication name\u201d), then the portlet-web-module's names corresponding to this application name and vendor will be returned. If only the portlet application name (without the vendor information) is specified and there are deployed applications with one and the same application name, but with different vendors, then an IllegalStateException will be thrown, or else the portlet-web-module's names corresponding to the specified portlet application name will be returned.","The \u201cgetAllPortlets( )\u201d method returns a list of all portlets in a specified portlet-web-module. The \u201cgetPortletPreferences( )\u201d method returns a new object of a specified portlet's initial preferences as loaded from the specified portlet's deployment descriptor.","The \u201cgetExpirationCache( )\u201d method returns the expiration cache timeout value defined in a particular portlet's deployment descriptor. If the expiration cache timeout value returned for a particular portlet is 0 (zero), then caching is determined to be disabled for that particular portlet. If the expiration cache timeout value returned is \u22121 (negative one), then the cache for that portlet does not expire. If the value returned is \u201cnull,\u201d then the portlet does not have a defined expiration cache.","The \u201cgetExpirationCacheScope( )\u201d method returns the caching scope of the particular portlet as defined in the particular portlet's deployment descriptor. The values returned by the methods are the values defined for the CACHE SCOPE constant defined in the MimeResponse interface. If no scope is provided in the deployment descriptor for the particular portlet, then the method will return PRIVATE_SCOPE as the default cache scope.","The \u201cgetSupportedModes( )\u201d method constructs a new java.util.Map object of mapped mime-types to arrays of PortletMode objects as declared in a particular portlet's deployment descriptor's <supports> elements. The map will not include the VIEW mode if it is not declared in the deployment descriptor. If there are no supported types declared for a particular mime type, that mime type's value in the map is an array with a length of 0.","The \u201cgetPublicRenderParameterNames( )\u201d method returns identifiers of the public render parameters supported by a particular portlet as an enumeration of string objects, or an empty enumeration if the particular portlet has not defined public render parameters. Public render parameters are generally defined in the particular portlet's deployment descriptor with the supported-public-render-parameter element.","The \u201cgetPublicRenderParameterType( )\u201d method returns a detailed type description for a specified public render parameter, including at least a subset of a description, an identifier, a QName, and an alias. Specifically, the method returns a PublicRenderParameterType object that fully describes the public render parameter.","The \u201cgetPublishingEventQNames( )\u201d method returns the QNames of the publishing events supported by a particular portlet as an enumeration of QName objects, or an empty enumeration if the portlet has not defined any publishing event. Publishing events are defined in the portlet deployment descriptor with the supported-publishing-event element.","The \u201cgetProcessingEventQNames( )\u201d method returns the QNames of the processing events supported by a particular portlet as an enumeration of QName objects, or an empty enumeration if the portlet has not defined any processing events. Processing events are defined in the portlet deployment descriptor with the supported-processing-event element.","The \u201cgetEvent( )\u201d method returns an Event object with a specified QName specified with the method's call.","The \u201cgetContainerRuntimeOptions( )\u201d method returns the container runtime options and values for a particular portlet. The portlet can set container runtime options in the portlet.xml via the container-runtime-option element with a name and a value on the application and portlet level. If a container runtime option is set on the portal application level and on the portlet level with the same name, the setting on the portlet level takes precedence and overwrites the option set on the portal application level. Further, this method returns a map providing the subset of runtime options that the Portlet Container  supports of the options the portlet has specified in the portlet.xml. Options that the Portlet Container  does not support will not be included in the returned map. The map will contain the name of the runtime option as a key of type String and the runtime options as values of the type String array (String[ ]) with the values specified in the portlet.xml deployment descriptor.","As previously described, the PortletContainer SPI  is a collection of interfaces that the portal application , or another user of the Portlet Container , implements in order to allow the Portlet Container  to receive and share information about invoked portlets and other portal-related information. The PortletContainer SPI  includes and makes available multiple services, each available through the implementation of the PortletContainer SPI . The SPI  includes the following interfaces: the PortletNode interface , the CoordinationService interface , the CachingService , the PortletPreferenceService interface , and the PortletURLProviderService .","The first interface included in the PortletContainer SPI  is the PortletNode interface . The PortletNode interface  provides additional information for the invoked portlet that is related to the portal application  runtime environment. A number of methods are included with the interface, including at least a subset of the following: \u201cgetPortletApplicationName( ),\u201d \u201cgetPortletName( ),\u201d \u201cgetWindowState( ),\u201d \u201csetWindowState( ),\u201d \u201cisWindowStateAllowed( ),\u201d \u201cgetPortletMode( ),\u201d \u201csetPortletMode( ),\u201d \u201cisPortletModeAllowed( ),\u201d \u201csetNextPossiblePortletModes( ),\u201d \u201cgetPrivateRenderParameters( ),\u201d \u201cgetRequestParameters( ),\u201d \u201cgetContextName( ),\u201d \u201csetProperty( ),\u201d \u201caddProperty( ),\u201d \u201csetPrivateRenderParameters( ),\u201d \u201cgetPortalContext( ),\u201d \u201cgetUser( ),\u201d \u201csetPortletTitle( ),\u201d \u201caddCookie( ),\u201d \u201cgetCookies( ),\u201d \u201cgetPortletPreferencesService( ),\u201d \u201cgetPortletURLProviderService( ),\u201d \u201cgetCoordinationService( ),\u201d \u201cgetCachingService( ),\u201d \u201cgetCacheability( ),\u201d and \u201cgetResourceID( ),\u201d.","The \u201cgetPortletApplicationName( )\u201d method returns the name of an application, part of which is the present portlet. The \u201cgetPortletName( )\u201d method returns the name of the current portlet. The \u201cgetWindowState( )\u201d method returns the current Window State of the current portlet. The \u201csetWindowState( )\u201d method updates the Window State of the current portlet as defined in the method call. The \u201cis WindowStateAllowed( )\u201d checks whether the current user is allowed to switch to a particular state.","The \u201cgetPortletMode( )\u201d method returns the current portlet mode of the current portlet. The \u201csetPortletMode( )\u201d method updates the portlet mode of the current portlet. The \u201cisPortletModeAllowed( )\u201d method checks whether the current user is allowed to switch to the specified mode. The \u201csetNextPossiblePortletModes( )\u201d method allows the Portlet Container  to tell the portal application  the next possible portlet modes that make sense from the portlet point of view. If set, the portal application  should honor the enumeration of portlet modes and only provide the end user with choices to the provided portlet modes or a subset of these modes based on access control considerations. If the Portlet Container  does not set any next possible portlet modes, then the default is that all portlet modes that the portlet has been defined to support in the portlet's deployment descriptor are meaningful and available portlet modes.","The \u201cgetPrivateRenderParameters( )\u201d method returns a Map containing all private render parameters. If there are no private render parameters set, then the method returns an empty Map. Private render parameters are only set from the portal application  if there is a render request as a result of a render URL to the current portlet. Public render parameters can be obtained from the CoordinationService. The \u201cgetRequestParameters( )\u201d returns a merged set of parameters set on the URL (if the call is a result of a portlet URL) and client request parameters. If there is a parameter with the same name in the URL and the client request, then the values set on the URL should precede the values for the client request. The \u201cgetContextName( )\u201d method retrieves a unique ID for the portlet, even if the same portlet is included twice in a portal page .","The \u201csetProperty( )\u201d method sets a String property for the subsequent render request. This property will be accessible in all subsequent render calls via the PortletRequest.getProperty call until a request is targeted to the portlet. This method is called each time the PortletResponse.setProperty method is called. The \u201caddProperty( )\u201d method adds a String property to an existing key property for the subsequent render request. This property will be accessible in all subsequent render calls via the PortletRequest.getProperty call until a request is targeted to the portlet. This method is called each time the PortletResponse.setProperty method is called.","The \u201csetPrivateRenderParameters( )\u201d method sets a private parameter map for the subsequent render request. As discussed above, private render parameters need only to be set from the portal application  if there is a render request as a result of a render URL to the current portlet. Public render parameters should be set in the CoordinationService. The \u201cgetPortalContext( )\u201d method retrieves the current portal context. The \u201cgetUser( )\u201d method gets the user making the request, and provides read-access to the user's attributes.","The \u201csetPortletTitle( )\u201d method passes a preferred portlet title to be used by the portal application  for the title bar. The title from the resource bundle title may be overridden by the portal application  or by the portlet. The \u201caddCookie( )\u201d method adds an HTTP cookie via PortletResponse.addProperty (Cookie). The portlet should note that the cookie may not make it to the client, but may instead be stored at or by the portal application . The method \u201cgetCookies( )\u201d retrieves cookies set by the portlet via PortletResponse.addProperty (Cookie).","The \u201cgetPortletPreferencesService( )\u201d returns the Portlet Preferences Service, the \u201cgetPortletURLProviderService( )\u201d method returns the PortletURLProviderService, the \u201cgetCoordinationService( )\u201d method returns the CoordinationService, and the \u201cgetCachingService( )\u201d method returns the CachingService. The \u201cgetCacheability( )\u201d method returns the cache level of the resource request. Possible return values are ResourceURL.FULL, ResourceURL.PORTLET, or ResourceURL.PAGE. The \u201cgetResourceID( )\u201d returns the resource ID set on the ResourceURL or \u201cnull\u201d if no resource ID was set on the URL.","The next interface included in the PortletContainer SPI  is the CoordinationService interface . The CoordinationService interface  provides information about the events and public render parameters to be distributed to the current (or a particular) portlet. The CoordinationService interface  includes at least a subset of the following methods: \u201cgetPublicParameterMap( ),\u201d \u201cgetPublicRenderParameter( ),\u201d \u201cgetPublicRenderParameterValues( ),\u201d \u201csetPublicRenderParameter( ),\u201d \u201csetRenderParameter( ),\u201d \u201cremovePublicRenderParameter( ),\u201d \u201cgetPublicRenderParameterNames( ),\u201d \u201cgetEvent( )\u201d and \u201csetEvent( )\u201d.","The \u201cgetPublicParameterMap( )\u201d method returns a map containing all public parameters relevant for this CoordinationService. The \u201cgetPublicRenderParameter( )\u201d method returns the value of a parameter specified in the method call. If a value is not set, \u201cnull\u201d is returned. If the method is used with a multivalued parameter, the value returned is equal to the first value in the array returned by the \u201cgetPublicRenderParameterValues( )\u201d method. The \u201cgetPublicRenderParameterValues( )\u201d method returns an array of String objects containing all of the values the given render parameter has, or \u201cnull\u201d if the parameter does not exist. If the parameter has a single value, the array has a length of 1.","The \u201csetPublicRenderParameter( )\u201d method sets the value of a public render parameter with an identified parameter ID provided in the method call with a particular value also provided in the call. The \u201csetRenderParameter( )\u201d method sets a String array parameter for the subsequent render request. These parameters are accessible in all subsequent render calls via the PortletRequest.getParameter call until a request is targeted to the portlet. This method is called each time the ActionResponse.setRenderParameter method is called. The \u201cremovePublicRenderParameter( )\u201d method removes a specified public render parameter. The \u201cgetPublicRenderParameterNames( )\u201d method returns Enumeration of identifiers of public render parameters relevant for this CoordinationService. The \u201cgetEvent( )\u201d method returns the current event and removes it from the CoordinationService. If there is no event set, Null is returned. The \u201csetEvent( )\u201d method adds a specified event to the already existing events.","The next interface included in the PortletContainer SPI  is the CachingService interface . The JSR 286 defines an expiration-based caching mechanism applied to each portlet, and also introduces cache scopes. In other words, cached content is not shared across different clients displaying the same portlet for \u201cprivate\u201d cache scopes. The CachingService is responsible for managing the expiration cache and the client cache.","A portlet can specify that it wants its content to be cached in the expiration-cache element of its deployment descriptor. If the element is missing, the Portlet Container  will treat each portlet as always expired, causing the portlet to regenerate its content when a request is received. The portlet can also specify its cache scope as \u201cpublic\u201d or \u201cprivate,\u201d indicating whether its content can be shared across users or not. The default value for cache scope is \u201cprivate.\u201d In order to maintain the proper cache, the Portlet Container  propagates the expiration cache and the cache scope settings to the portal application  via the CachingService. The service is available for the Portlet Container  via the PortletNode interface. By providing this information to the portal application , the portal application  can determine whether or not to cache the content of a particular portlet. If content is cached and not expired, and the portlet is not a target of an action or event request, the portal application  may decide not to re-invoke the portlet, instead using the cached content to populate the portal page . In some instances, the cached content should be discarded when a processAction( ) or processEvent( ) method is directed toward the portlet.","Additionally, validation-based caching allows the portlet to return a validation token with the response content and an expiration time. The portlet sets the validation token via the ETag property on the RenderResponse and ResourceResponse or via the CacheControl.setETag( ) method. These values can be communicated back to the portal application  via the CachingService.","The portal application  sends a render or serveResource request to the portlet with the validation cache after the content is expired. The token is provided to the portlet via the ETag property of the RenderRequest or ResourceRequest. The Portlet Container  delivers this property to the portlet via the CachingService's getETag( ) method. If the portlet determines that the ETag is still valid, the portlet will not generate new content and can notify the Portlet Container  and thus the portal application  by setting the USE_CACHED_CONTENT of the RenderResponse and ResourceResponse with a new time, or via setUseCachedContent on the CachedControl object of the RenderResponse and ResourceResponse and set a new expire time.","The CachingService interface  provides services for managing the expiration cache of the portal application  and the client cache of a portlet. The CachingService interface  includes at least a subset of the following methods: \u201csetETag( ),\u201d \u201cgetETag( ),\u201d \u201csetUseCachedContent( ),\u201d \u201csetExpirationCache( ),\u201d and \u201csetCacheScope( )\u201d.","The \u201csetETag( )\u201d method is invoked by the Portlet Container  when the portlet invokes the CacheControl.setETag( )method. The \u201cgetETag( )\u201d method returns the validation tag for a particular ETag if the portal application  has a cached response for the particular ETag, or null if no cached response exists. The \u201csetUseCachedContent( )\u201d method sets the indication of whether the cached content for the provided ETag at the request is still valid or not. If set to true, no output will be generated by the portlet and a new expiration time is set for the markup with the given ETag. The \u201csetExpirationCache( )\u201d method sets a particular expiration cache timeout for the cached content associated with the ETag and overwrites the expiration cache timeout value defined in the associated portlet's deployment descriptor. When the expiration cache timeout value is changed, the portal application  is notified. If the specified expiration value is set to 0 (zero), then caching will be disabled for the associated portlet. If the value is set to \u22121 (negative one), then the cache does not expire. If the value is set to null, then the portlet has not defined an expiration cache. The \u201csetCacheScope( )\u201d passes the cache scope type that the portlet has selected for its cached content.","Another interface included in the PortletContainer SPI  is the PortletPreferencesService interface . The PortletPreferencesService interface  provides services for reading and storing portlet preferences in the server's  persistent store (i.e., the set of portal preferences ). Specifically, the PortletPreferencesService provides a method for retrieving portlet preferences from the persistent store, the portlet preferences containing user-specific properties set in addition to the preferences defined with the portlet's deployment descriptor. The PortletPreferencesService interface  includes at least a \u201cgetPortletPreferences( )\u201d method, which retrieves the user-specific portlet preference set.","The PortletContainer SPI  further includes the PortletURLProviderService interface . A portlet often needs to create URLs as part of its content that references the portlet itself. The PortletContainer API  defines a PortletConsumerURL interface , which includes the specifications PortletURL  and ResourceURL  interfaces that can be used to create action, render, or resource URLs. However, the URLs generated by the portlet are understandable only in the context of the portal application . In the Portlet 2.0 API , the usual way of writing the portlet URL in the generated content is to use a \u201cwrite( )\u201d method instead of the \u201ctoString( )\u201d method (used in the Portlet 1.0 API) in order to avoid string object creation. The PortletConsumerURL interface  can be inspected for the exact type of the URL by using its getType( ) method. This mechanism adds more URLs by future portlets possible without modifying the current SPI or API packages. If the type of the URL is ACTION or RENDER, the portletConsumerURL parameter can be safely cast down to the PortletURL interface . In the case of a RESOURCE type the portletConsumerURL can be cast to the ResourceURL interface . Both PortletURL interface  and ResourceURL interface  provide access to their corresponding attributes. Next to the URL properties and parameters the PortletURL interface  also delivers the portlet mode, window state, and public render parameters suitable for the target portlet instance. The getMode( ) method of PortletURL returns values defined by javax.portlet.WindowState (Maximized, Minimized, and Normal). Similarly, ResourceURL returns the cache level of the resource and resource ID.","The PortletURLProviderService interface  provides a method for the Portlet Container  to create and manipulate portlet URLs. For example, the PortletURLProviderService interface  provides methods that allow for a portlet URL to be converted to a string for use in the generated portlet content, as well as methods for writing a particular portlet URL to the output stream of a specified writer. The PortletURLProviderService interface  also provides a method of encoding URLs of various resources, such as servlets, JSPs, images, and other static files, at a particular path for use by the portlet and the portal application . The PortletURLProviderService interface  includes at least a subset of the following methods: \u201cconvertPortletURLToString( ),\u201d \u201cwrite( ),\u201d and \u201cencodeURL( ).\u201d","The \u201cconvertPortletURLToString( )\u201d method converts a specified portlet URL to a string value for use in the portlet's render method. The \u201cwrite( )\u201d method writes the portlet URL to the output stream using a provided writer. The \u201cencodeURL( )\u201d method returns the encoded URL of a particular resource, such as a servlet, JSPs, image, and other static files, at a given path. Portlets should encode all resource URLs pointing to resources in the portlet or portlet application using this method to ensure that the URLs are served via the portal application . Some portal\/portlet container implementations may require specific URLs to contain certain implementation-specific data encoded therein. The \u201cencodeURL( )\u201d method may include the session ID and other portal\/portlet-container specific information into the generated URL. If encoding is not necessary, the method will return the URL unchanged. Portlet developers need be aware that the returned URL after the \u201cencodeURL( )\u201d call may not be a well-formed URL, but instead a special token to be used during content generation by the portlet. Thus, portlets generally should not add additional parameters on the resulting URL or expect to be able to parse the URL.","In some instances, the PortletContainer SPI  may include an additional interface, the PortalContextExt interface (not illustrated). The PortalContextExt interface can provide a method for the Portlet Container  to retrieve the runtime options supported by the portal application . The PortalContextExt interface includes at least a \u201cgetSupportedRuntimeOptions( )\u201d method which returns the container runtime options supported by the portal application .","A number of embodiments of the present disclosure have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the present disclosure. Accordingly, other embodiments are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},"FIGS. -I--II illustrate an example sequence diagram of an embodiment for creating a portal page with the additional functionality provided by the additional portlet container APIs and SPIs illustrated in .",{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 5","FIG. 1A"]},"FIGS. -I--II illustrate an example block diagram of an embodiment illustrating the APIs and SPIs associated with the advanced runtime implementation of Portlet Container 2.0 illustrated in ."]},"DETDESC":[{},{}]}
