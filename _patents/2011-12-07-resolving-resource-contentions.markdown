---
title: Resolving resource contentions
abstract: A computer-implemented method for managing access to a shared resource of a process may include identifying a plurality of process steps, each process step of the plurality of process steps, when executed, accessing the shared resource at a same time. The method may also include rearranging at least one of the process steps of the plurality of process steps to access the shared resource at a different time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08918793&OS=08918793&RS=08918793
owner: SAP SE
number: 08918793
owner_city: Walldorf
owner_country: DE
publication_date: 20111207
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates to resolving resource contentions and, more particularly, to resolving resource contentions in process modeling.","Process modeling may result in resource contentions and race conditions based on conflicting accesses to shared resources. Complex processes often suffer from resource contentions, which include simultaneous accesses to shared resources from multiple process steps. Concurrent modifications of shared resources from parallel process branches may also lead to race conditions such as lost update phenomena, which includes a scenario in which concurrent process steps update the same resource, where one process step overwrites the effects of the other process step.","Embodiments of the disclosed subject matter include a computer implemented method for managing access to a shared resource of a process may include identifying a plurality of process steps, each process step of the plurality of process steps, when executed, accessing the shared resource at a same time. The method may also include rearranging at least one of the process steps of the plurality of process steps to access the shared resource at a different time.","A system for resolving conflicting resource accesses by process steps in a process model. The system may include a memory for storing instructions and at least one processor. The processor may be configured to execute the instructions stored on the memory. In some embodiments, the instructions operable when executed to identify a plurality of process steps that are executed in parallel, each process step of the plurality of process steps accessing, when executed, a shared resource at the same time. The instructions may also include rearranging at least one of the process steps of the plurality of process steps to access the shared resource at a different time to create a new process model. The new process model can be stored in the memory.","A computer program product may be stored on a tangible, non-transitory media, and may be operable when executed to identify a plurality of process steps that are executed in parallel, each process step of the plurality of process steps accessing, when executed, a shared resource at the same time. The computer program product may also be operable when executed to rearrange at least one of the process steps of the plurality of process steps to access the shared resource at a different time to create a new process model. The new process model may be stored in a memory.","In certain implementations of the embodiments, at least one process step of the plurality of process steps performs a write access to the shared resource. In certain implementations of the embodiments, at least one of the process steps of the plurality of process steps performs an update to the shared resource.","In certain implementations of the embodiments, each processing step of the plurality of processing steps may be executed on corresponding parallel branches of the process. Rearranging at least one of the process steps to access the shared resource at a different time may include moving the at least one process step to a position outside of the corresponding parallel branch of the process. In certain instances, the position outside of the parallel branches of the process is a position prior to the start of the parallel branches of the process. In certain instances, rearranging at least one of the process steps to access the shared resource at a different time may include changing an order of process steps of at least one of the branches of the parallel branches of the process.","In certain implementations of the embodiments, a dependency graph relating one or more resources used during the process and the plurality of process steps may be generated. The resources and each process step of the plurality process steps may be nodes of the dependency graph, and each edge of the dependency graph may represent an access of the resource by the process step. In certain instances, one or more conflicting accesses to the resource from two or more process steps can be identified based on the dependency graph. In certain instances, the one or more conflicting accesses to the resource include at least one write access to the resource. In certain instances, the two or more process steps may be executed on parallel branches of the process concurrently.","In certain instances, identifying the one or more conflicting accesses may include identifying the resource in the dependency graph. The plurality of process steps that access the resource may be identified. The plurality of process steps may be grouped into distinct pairs. Pairs of process steps can be identified wherein both accesses to the resource by the process steps are read accesses. Pairs of process steps, wherein both accesses to the resource by the process steps are read accesses, can be excluded. In certain instances, pairs of process steps that are identified to execute sequentially are excluded.","In certain implementations of the embodiments, the resource may be one or both of an explicit resource that is intrinsic to the process, or an implicit resource that is extrinsic to the process.","In certain implementations of the embodiments, the plurality of process steps are performed on corresponding parallel branches of the process. At least one of the process steps of the plurality of process steps can be rearranged to access the shared resource at a different time includes transforming the corresponding parallel branches into sequential branches.","In certain implementations of the embodiments, the plurality of process steps may include a first conflicting process step performed on a corresponding first parallel branch of the process and a second conflicting process step performed on a corresponding second parallel branch of the process. For each conflicting process step, there may be on each corresponding parallel branch, at least one previous process step and at least one subsequent process step.","In certain implementations of the embodiments, rearranging at least one of the process steps of the plurality of process steps to access the shared resource at a different time may include identifying a first value for the previous process step on a first branch of the parallel branches of the process. A first value in a first data object can be stored. A second value for the previous process step on a second branch of the parallel branches of the process may be identified. The second value in a second data object can be stored. One of the first or second conflicting process steps based on the value in the data object can be executed.","The details of one or more embodiments of the disclosure are set forth in the accompanying drawings and the description below. Other features, objects, and advantages described in this disclosure will be apparent from the description and drawings, and from the claims.","Like reference symbols in the various drawings indicate like elements.","Business Process Model Notation (BPMN) facilitates the concurrent execution of process steps by splitting the control flow into parallel branches. The BPMN standard provides for \u201cInclusive Gateways\u201d (also referred to as \u201cOR\u201d split\/join), \u201cParallel Gateways\u201d (also referred to as \u201cAND\u201d split\/join), and \u201cComplex Gateways,\u201d each of which facilitate the forking (or branching) and\/or synchronization of concurrent threads of control simultaneously executing process steps on separate branches. Concurrency can improve process turnaround times by making progress on multiple process steps in parallel. Concurrency may lead to resource contentions (i.e., conflicting accesses to an exclusive resource happening in parallel), which adversely affect performance due to concurrency control mechanisms, such as delayed lock acquisition (i.e., having to wait for a lock until it is freed up by another thread) or repetitive transaction rollbacks\/retries (i.e., having to abort and re-schedule a transaction that failed to acquire a lock after waiting some time). Using locks to implement a concurrency control mechanism does not exclude alternative means to accomplish the same, such as optimistic measures (like timestamp ordering) which suffer from the same problems. Concurrent modifications of shared resources from parallel process branches may lead to race conditions, such as lost update phenomena (i.e., concurrent process steps that update the same resource where one process step overwrites the effects of the other process step).","Sequentializing resource contentions may address resource contentions and race conditions. Sequentializing resource contentions include, in general, (1) identifying process steps on parallel branches performing conflicting accesses to shared resources. This concept considers both (1a) explicit conflicts, such as concurrent data context accesses, and (1b) implicit conflicts, such as external service invocations. Sequentializing also includes, in general, (2) rearranging those process steps in an intent-preserving manner such that the conflict is resolved. This concept can include (2a) changing the order of process steps on a branch, and\/or (2b) moving process steps out of (i.e., front of or behind) the parallel branches.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1","b":["100","102","135","112","100"]},"In general, the server  is any server that stores one or more hosted applications , where at least a portion of the hosted applications  are executed via requests and responses sent to users or clients  within and communicably coupled to the illustrated environment  of . In some instances, the server  may store a plurality of various hosted applications , while in other instances, the server  may be a dedicated server meant to store and execute only a single hosted application . In some instances, the server  may include a web server, where the hosted applications  represent one or more web-based applications accessed and executed via network  by the clients  of the system to perform the programmed tasks or operations of the hosted application . Hosted application  may be a hosted process modeling environment or may be a process execution environment in which processes modeled by client  are executed. At a high level, the server  includes an electronic computing device operable to receive, transmit, process, store, or manage data and information associated with the environment . Specifically, the server  illustrated in  is responsible for receiving application requests from one or more client applications  associated with the clients  of environment  and responding to the received requests by processing said requests in the associated hosted application , and sending the appropriate response from the hosted application  back to the requesting client application . In addition to requests from the external clients  illustrated in , requests associated with the hosted applications  may also be sent from internal users, external or third-party customers, other automated applications, as well as any other appropriate entities, individuals, systems, or computers. As used in the present disclosure, the term \u201ccomputer\u201d is intended to encompass any suitable processing device. For example, although  illustrates a single server , environment  can be implemented using two or more servers , as well as computers other than servers, including a server pool. Indeed, server  may be any computer or processing device such as, for example, a blade server, general-purpose personal computer (PC), Macintosh, workstation, UNIX-based workstation, or any other suitable device. In other words, the present disclosure contemplates computers other than general purpose computers, as well as computers without conventional operating systems. Further, illustrated server  may be adapted to execute any operating system, including Linux, UNIX, Windows, Mac OS, or any other suitable operating system. According to one embodiment, server  may also include or be communicably coupled with a mail server.","Generally, the network  facilitates wireless or wireline communications between the components of the environment  (i.e., between the server  and the clients ), as well as with any other local or remote computer, such as additional clients, servers, or other devices communicably coupled to network  but not illustrated in . The network  is illustrated as a single network in , but may be a continuous or discontinuous network without departing from the scope of this disclosure, so long as at least a portion of the network  may facilitate communications between senders and recipients. The network  may be all or a portion of an enterprise or secured network, while in another instance, at least a portion of the network  may represent a connection to the Internet. In some instances, a portion of the network  may be a virtual private network (VPN), such as, for example, the connection between the client  and the server . Further, all or a portion of the network  can include either a wireline or wireless link. Example wireless links may include 802.11a\/b\/g\/n, 802.20, WiMax, and\/or any other appropriate wireless link. In other words, the network  encompasses any internal or external network, networks, sub-network, or combination thereof operable to facilitate communications between various computing components inside and outside the illustrated environment . The network  may communicate, for example, Internet Protocol (IP) packets, Frame Relay frames, Asynchronous Transfer Mode (ATM) cells, voice, video, data, and other suitable information between network addresses. The network  may also include one or more local area networks (LANs), radio access networks (RANs), metropolitan area networks (MANs), wide area networks (WANs), all or a portion of the Internet, and\/or any other communication system or systems at one or more locations.","As shown in , the server  includes a processor , an interface , a memory , and one or more hosted applications . The interface  is used by the server  for communicating with other systems in a client-server or other distributed environment (including within environment ) connected to the network  (e.g., client , as well as other systems communicably coupled to the network ). Generally, the interface  includes logic encoded in software and\/or hardware in a suitable combination and operable to communicate with the network . More specifically, the interface  may include software supporting one or more communication protocols associated with communications such that the network  or interface's hardware is operable to communicate physical signals within and outside the illustrated environment .","As illustrated in , server  includes a processor . Although illustrated as a single processor  in , two or more processors may be used according to particular needs, desires, or particular embodiments of environment . Each processor  may be a central processing unit (CPU), a blade, an application specific integrated circuit (ASIC), a field-programmable gate array (FPGA), or another suitable component. Generally, the processor  executes instructions and manipulates data to perform the operations of server  and, specifically, the one or more plurality of hosted applications . Specifically, the server's processor  executes the functionality required to receive and respond to requests from the client(s)  and their respective client applications , as well as the functionality required to perform the other operations of the hosted application . Regardless of the particular implementation, \u201csoftware\u201d may include computer-readable instructions, firmware, wired or programmed hardware, or any combination thereof on a tangible medium operable when executed to perform at least the processes and operations described herein. Indeed, each software component may be fully or partially written or described in any appropriate computer language including C, C++, Java, Visual Basic, assembler, Perl, any suitable version of 4GL, as well as others. It will be understood that while portions of the software illustrated in  are shown as individual modules that implement the various features and functionality through various objects, methods, or other processes, the software may instead include a number of sub-modules, third-party services, components, libraries, and such, as appropriate. Conversely, the features and functionality of various components can be combined into single components, as appropriate.","Environment  includes a process compiler  and a resource contention resolver  that transforms process models (like BPMN diagrams or other process models ) into an executable format (e.g., JAVA\u00ae Enterprise Edition (JEE) applications). As part of that transformation, detected resource contentions are identified, and if possible resolved, to improve the process's runtime behavior. Resolving resource contentions occurs prior to process execution at runtime.","In the illustrated environment , processor  executes one or more hosted applications  on the server . At a high level, each of the one or more hosted applications  is any application, program, module, process, or other software that may execute, change, delete, generate, or otherwise manage information according to the present disclosure, particularly in response to and in connection with one or more requests received from the illustrated clients  and their associated client applications . In certain cases, only one hosted application  may be located at a particular server . In others, a plurality of related and\/or unrelated hosted applications  may be stored at a single server , or located across a plurality of other servers , as well. In certain cases, environment  may implement a composite hosted application . For example, portions of the composite application may be implemented as Enterprise Java Beans (EJBs) or design-time components may have the ability to generate run-time implementations into different platforms, such as J2EE (Java 2 Platform, Enterprise Edition), ABAP (Advanced Business Application Programming) objects, or Microsoft's .NET, among others. Additionally, the hosted applications  may represent web-based applications accessed and executed by remote clients  or client applications  via the network  (e.g., through the Internet). Further, while illustrated as internal to server , one or more processes associated with a particular hosted application  may be stored, referenced, or executed remotely. For example, a portion of a particular hosted application  may be a web service associated with the application that is remotely called, while another portion of the hosted application  may be an interface object or agent bundled for processing at a remote client . Moreover, any or all of the hosted applications  may be a child or sub-module of another software module or enterprise application (not illustrated) without departing from the scope of this disclosure. Still further, portions of the hosted application  may be executed by a user working directly at server , as well as remotely at client .","Hosted application  may execute processes modeled by client . Similarly, hosted application  may be a modeling environment through which client  models processes. For example, hosted application  may access a memory  that stores process models , data objects , business objects , process content directory , and resources .","Resources  include implicit and explicit resources, such as concurrent data context accesses and external service invocations, respectively. More specifically, an explicit (internal) resource includes a resource that is exclusively owned by the process (i.e., its lifecycle is managed by the business process management system (BPMS) runtime) and whose \u201cuses\u201d (i.e., updates [writes] and consumption [reads]) can be looked up from the process model. External components that wish to access the internal resource may use BPMS Application Programming Interfaces (APIs) to do so (e.g., to alter the process context from some administration user interface (UI)). Example explicit resources include, though are not limited to, data objects from the process context that are accessed in data mappings, gateway conditions, and correlation conditions; and events (signals, errors, escalations, messages, etc.) that are produced and consumed by various flavors of Throw Events and Catch Events, respectively.","Implicit (external) resources include a non-process resource (e.g., the state in some external business application) that is external to the process. The way an implicit resource is generally used is not information exhaustively stored in the process model (i.e., external applications may \u201cbypass\u201d the process and directly alter the resource). The process model itself may \u201cobfuscate\u201d its use of the resource such that the optimization algorithm needs to apply heuristics to both narrow down what is a separate resource and how it is used (updated and consumed) from the process. Example implicit resources include, but are not limited to, business systems that are identified by joint hosts from endpoint Uniform Resource Locators (URL) of service calls (depending on the message exchange pattern, read accesses can be assumed for (stateless) synchronous calls and write accesses for (stateful) asynchronous calls); and business entities, such as business objects, or applications, that are identified by the service signature (e.g., Simple Object Access Protocol (SOAP): portType and operation name; REST: endpoint URL). For Representational State Transfer (REST)-based calls, the HyperText Transfer Protocol (HTTP) protocol \u201cverbs\u201d (GET, POST, PUT, DELETE, etc.) may be used to infer a read or write access.","In general, the overall structure of the process model  ensures the consistency of the interfaces that are derived from the process model . The derivation helps ensure that the same business-related subject matter or concept can be represented and structured in the same way in various interfaces. The process model  defines the business-related concepts at a central location for a number of business transactions. In other words, it reflects the decisions made about modeling the business entities of the real world acting in business transactions across industries and business areas. For ABAP applications, the process model  is defined by the business objects  and their relationship to each other (the overall net structure). For BPMN-based processes, the process model  is a control flow graph that orchestrates process steps (activities, events, gateways, etc.) that may perform tasks such as user interactions, service calls, manipulating data objects, etc. A \u201cbusiness object\u201d is an entity outside of a process that is typically accessed through services. As such, it may be considered an implicit resource.","Each business object  is thus a capsule with an internal hierarchical structure, behavior offered by its operations, and integrity constraints. Business objects  are generally semantically disjointed, i.e., the same business information is represented once. In some embodiments, the business objects  are arranged in an ordering framework such that they can be arranged according to their existence dependency to each other. For example, in a modeling environment, the customizing elements might be arranged on the left side of the process model , the strategic elements might be arranged in the center of the process model , and the operative elements might be arranged on the right side of the process model . Similarly, the business objects  can be arranged in this model from the top to the bottom based on defined order of the business areas, e.g., finance could be arranged at the top of the business object model with customer relationship management (CRM) below finance, and supplier relationship management (SRM) below CRM. To help ensure the consistency of interfaces, the business object model may be built using standardized data types, as well as packages, to group related elements together, and package templates and entity templates to specify the arrangement of packages and entities within the structure.","A business object may be defined such that it contains multiple layers, such as in the example business object . The example business object  contains four layers: the kernel layer, the integrity layer, the interface layer, and the access layer. The innermost layer of the example business object  is the kernel layer. The kernel layer represents the business object's  inherent data, containing various attributes of the defined business object . The second layer represents the integrity layer. In the example business object , the integrity layer contains the business logic of the object. Such logic may include business rules for consistent embedding in the environment  and the constraints regarding the values and domains that apply to the business object . Business logic may include statements that define or constrain some aspect of the business, such that they are intended to assert business structure or to control or influence the behavior of the business entity. It may pertain to the facts recorded on data and constraints on changes to that data. In effect, business logic may determine what data may, or may not, be recorded in business object . The third layer, the interface layer, may supply the valid options for accessing the business object  and describe the implementation, structure, and interface of the business object  to the outside world. To do so, the interface layer may contain methods, input event controls, and output events. The fourth and outermost layer of the business object  in is the access layer. The access layer defines the technologies that may be used for external access to the business object's  data. Some examples of allowed technologies may include COM\/DCOM (Component Object Model\/Distributed Component Object Model), CORBA (Common Object Request Broker Architecture), RFC (Remote Function Call), Hypertext Transfer Protocol (HTTP) and Java, among others. Additionally, business objects  of this embodiment may implement object-oriented technologies such as encapsulation, inheritance, and\/or polymorphism.","Some or all of the data objects , process models , and information associated with or stored in the process content directory  may be stored or referenced in a local or remote memory , which can be a development or metamodel repository. This memory  may include parameters, pointers, variables, algorithms, instructions, rules, files, links, or other data for easily providing information associated with or to facilitate modeling of the particular object. More specifically, each memory  may be formatted, stored, or defined as various data structures in eXtensible Markup Language (XML) documents, text files, Virtual Storage Access Method (VSAM) files, flat files, Btrieve files, comma-separated-value (CSV) files, internal variables, one or more libraries, or any other format capable of storing or presenting all or a portion of the interface, process, data, and other models or modeling domains. In short, each repository may include one table or file or a plurality of tables or files stored on one computer or across a plurality of computers in any appropriate format as described above. Indeed, some or all of the particular repository may be local or remote without departing from the scope of this disclosure and store any type of appropriate data.","The server  also includes memory . Memory  may include any memory or database module and may take the form of volatile or non-volatile memory including, without limitation, magnetic media, optical media, random access memory (RAM), read-only memory (ROM), removable media, or any other suitable local or remote memory component. Memory  may store various objects or data, including classes, frameworks, applications, backup data, business objects, jobs, web pages, web page templates, database tables, repositories storing business and\/or dynamic information, and any other appropriate information including any parameters, variables, algorithms, instructions, rules, constraints, or references thereto associated with the purposes of the server  and its one or more hosted applications . Additionally, memory  may include any other appropriate data, such as VPN applications, firmware logs and policies, firewall policies, a security or access log, print or other reporting files, as well as others.","Memory , whether local or distributed, can also store a process content directory . The process content directory  can store detailed relationship and connection information defined between the models and entities designed in the modeling environment , as well as provide the data and other information needed to allow for the automated addition of model-related and model-defining information into high-level models created by business users and technical developers. For example, the process content directory  may store detailed information regarding additional and\/or more detailed connections defined for the high-level elements created or modeled in the modeling environment . The process content directory  can store information used to define previously-generated models, including the connections and operations included in and associated with various modeled entities. Therefore, the information stored in the process content directory  can be used for the automatic generation of later-developed or updated models when one or more elements added to a particular model have previously been used or modeled in earlier-defined models. Additionally, changes to one or more of the models associated with the process content directory  can be reflected in the data stored therein. Process models  defined or generated using information from the process content directory  can be automatically updated by reloading or re-analyzing the modified information stored within the directories.","In some instances, the process content directory  can store information defining which entities are available for a particular process, business area, or work center, among others. For instance, where a particular component has already been defined in the modeling environment , information stored in the process content directory  can be used to describe a set of entities to which that particular component can navigate to or be associated with. Using information retrieved from the process content directory , a model describing the navigation available from a particular component can be at least partially generated or described.","The illustrated environment of  also includes one or more clients . Each client  may be any computing device operable to connect to or communicate with at least the server  and\/or via the network  using a wireline or wireless connection. Further, as illustrated by client , each client  includes a processor , an interface , a graphical user interface (GUI) , a client application , and a memory . In general, each client  includes an electronic computer device operable to receive, transmit, process, and store any appropriate data associated with the environment  of . It will be understood that there may be any number of clients  associated with, or external to, environment , even though environment  shows a single client. Additionally, there may also be one or more additional clients  external to the illustrated portion of environment  that are capable of interacting with the environment  via the network . Further, the term \u201cclient\u201d and \u201cuser\u201d may be used interchangeably as appropriate without departing from the scope of this disclosure. Moreover, while each client  is described in terms of being used by a single user, this disclosure contemplates that many users may use one computer, or that one user may use multiple computers. As used in this disclosure, client  is intended to encompass a personal computer, touch screen terminal, workstation, network computer, kiosk, wireless data port, smart phone, personal data assistant (PDA), one or more processors within these or other devices, or any other suitable processing device. For example, each client  may include a computer that includes an input device, such as a keypad, touch screen, mouse, or other device that can accept user information, and an output device that conveys information associated with the operation of the server  (and hosted application ) or the client  itself, including digital data, visual information, the client application , or the GUI . Both the input and output device may include fixed or removable storage media such as a magnetic storage media, CD-ROM, or other suitable media to both receive input from and provide output to users of the clients  through the display, namely, the GUI .","Further, the illustrated client  includes a GUI  comprising a graphical user interface operable to interface with at least a portion of environment  for any suitable purpose, including generating a visual representation of the client application  (in some instances, the client's web browser) and the interactions with the hosted application , including the responses received from the hosted application  received in response to the requests sent by the client application . Generally, through the GUI , the user is provided with an efficient and user-friendly presentation of data provided by or communicated within the system. The term \u201cgraphical user interface,\u201d or GUI, may be used in the singular or the plural to describe one or more graphical user interfaces and each of the displays of a particular graphical user interface. Therefore, the GUI  can represent any graphical user interface, including but not limited to, a web browser, touch screen, or command line interface (CLI) that processes information in environment  and efficiently presents the information results to the user. In general, the GUI  may include a plurality of user interface (UI) elements, some or all associated with the client application , such as interactive fields, pull-down lists, and buttons operable by the user at client . These and other UI elements may be related to or represent the functions of the client application , as well as other software applications executing at the client . In particular, the GUI  may be used to present the client-based perspective of the hosted application , and may be used (as a web browser or using the client application  as a web browser) to view and navigate the hosted application , as well as various web pages located both internal and external to the server, some of which may be associated with the hosted application . The GUI  may be a part of or the entirety of the client application , while also merely a tool for displaying the visual representation of the client and hosted applications'  actions and interactions. In some instances, the GUI  and the client application  may be used interchangeably, particularly when the client application  represents a web browser associated with the hosted application .","While  is described as containing or being associated with a plurality of elements, not all elements illustrated within environment  of  may be utilized in each alternative implementation of the present disclosure. Additionally, one or more of the elements described herein may be located external to environment , while in other instances, certain elements may be included within or as a portion of one or more of the other described elements, as well as other elements not described in the illustrated implementation. Further, certain elements illustrated in  may be combined with other components, as well as used for alternative or additional purposes in addition to those purposes described herein.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 2","b":["200","200","216","218","220","202","216","222","218","204","202","208","212","202","208","212"]},"Process model  includes six activities. (Each artifact (start event, end event, AND split, AND merge gateway plus the five activities) is a process step, so the term \u201cactivities\u201d is used to distinguish.) At the start , a user ID may be accessed to access the user profile for sending mail. Activity  is the \u201cLookup Address in MDM\u201d step, which reads from UserID data object  and performs a synchronous call to lookup address in MDM. The process model then permits the user to manually enter an updated address in the \u201cEnter Updated Address\u201d activity . The \u201cEnter Updated Address\u201d activity  performs a read from User ID data object  and from the Address data object . If the address is updated, the \u201cEnter Updated Address\u201d activity  performs a write access (or an update access) to the Address data object . \u201cLookup Address in MDM\u201d activity  and \u201cEnter Updated Address\u201d activity  are shown to be performed in sequence (or in series) on a \u201csequential branch\u201d  of the process model .","After the \u201cEnter Updated Address\u201d activity , the process splits into two parallel branches. The two parallel branches can be described as being part of a set of parallel branches . In this case, the set of parallel branches  includes two parallel branches. In , the sequential branch  forks into the set of parallel branches  by a parallel split , which is also referred to as \u201cAND\u201d split because process steps from both branches of the set of parallel branches  are executed. The \u201cupper branch\u201d  of the set of parallel branches  includes two process steps: \u201cZIP Code Lookup\u201d  and \u201cSend Letter\u201d . The \u201clower branch\u201d  includes one process step: \u201cUpdate Address in MDM\u201d . In this particular scenario, \u201cZIP Code Lookup\u201d  is in conflict with \u201cUpdate Address in MDM\u201d  because the two process steps occur in parallel, the two process steps access the same resource, and at least one of the two process steps performs a write access on the resource (in this case, \u201cUpdate Address in MDM\u201d  writes to the Address data object ). Such a conflict can result in a resource contention.","Sequentializing resource contentions may address resource contentions and race conditions. Sequentializing resource contentions includes, in general, (1) identifying process steps on parallel branches performing conflicting accesses to shared resources. This concept considers both (1a) explicit conflicts, such as concurrent data context accesses, and (1b) implicit conflicts, such as external service invocations. Sequentializing also includes, in general, (2) rearranging those process steps in an intent-preserving manner such that the conflict is resolved. This concept can include (2a) changing the order of process steps on a branch, and\/or (2b) moving process steps out of (i.e., front of or behind) the parallel branches.","To facilitate the two general concepts described above, the process model may be augmented by dependency graph, which makes dependencies among process steps explicit. Each process step (activities, gateways, events) becomes a node in the dependency graph. Likewise, each internal and external resource that is referenced from those process steps also becomes a node in the dependency graph. An example dependency graph is described in .",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 3","FIG. 2","FIG. 3"],"b":["300","200","300","301","302","304","308","310","312","328","316","318","326","320","316","301","316"]},"Edge  shows a read access from UserID data object  from \u201cEnter Updated Address\u201d activity . Edge  indicates a two-way access (i.e., read\/write). This sort of dependency does not relate to some control flow connectors in the process model. In , no two process steps nodes are directly connected. Resource nodes may be interconnected, denoting a hidden dependency between these resources. For instance, a role definition (e.g., potential owners of a user task) may be defined as an expression atop the process data context (i.e., a number of data objects). Updating the role happens automatically whenever the underlying data objects are altered (i.e., there is no process step explicitly doing so). Altogether, a directed edge from one resource node to another resource node indicates that when updating the former resource node, the latter resource node will be updated, as well. The dependency between resource nodes is transitive.","Depending on the type of process steps, there may be more external dependencies such as jointly used user interfaces or other \u201cuser exits\u201d that may be used to access a shared state. In addition, the order of the predecessor and successor steps may be rearranged (ignoring any order of token flows), provided that no other conflicting dependency exists.","Algorithms may be applied to resolve conflicting accesses to shared resources. First, the process steps causing conflicting accesses can be identified. Generally, accesses from two (or more) process steps to a resource may be in conflict if:","(1) At least one of two accesses is a \u201cwrite access\u201d to the resource; and","(2) The process steps performing the conflicting accesses reside on different process branches that run in parallel.","A \u201cwrite access\u201d includes an update or an alteration to data within the resource. Read-only accesses do not cause conflicts and may well happen in parallel. Whether the process step performs a write access can be verified by identifying conflicting accesses by (1) traversing each resource Ri; (2) identifying the set of process steps accessing that resource (e.g., A(Ri)={P, P, P}); (3) grouping those process steps into distinct pairs (e.g., PP, PP, PP; and (4) excluding those pairs where both process steps merely read the resource.","The latter criterion (whether the process steps performing conflicting access reside on different process branches that run in parallel) checks if the two process steps that make up a pair actually may execute concurrently at runtime. Performing such a check statically (i.e., at compile time) does not necessarily yield an accurate result and may include false positives (pairs of process step which do not actually execute in parallel) and false negatives for non-block-structured processes. Inaccurate results from a static check may be due to BPMN artifacts, such as OR splits and a Complex Gateway's fork parallelism, which may depend on the state of the process, which is unknown at compile time. In certain instances, inaccuracies resulting from static, compile-time checks are acceptable engineering trade-offs. That is, the present disclosure contemplates resolving resource contentions, which improves performance and correctness characteristics, but contemplates a margin for error, the size of which is an engineering choice. One or more resource contentions may still remain unaddressed, while still achieving improved performance due to resolving other contentions. Similarly, certain contentions may be prioritized over others to achieve the highest desirable system performance improvement.","If for a pair of process steps PiPj, Pi can be reached from Pj by transitively following its inbound or outbound sequence connectors upstream or downstream, respectively, Pi and Pj can be considered to be happening in sequence. Otherwise the inbound sequence connectors of Pi and Pj are both traversed upstream until a joint XOR split is reached, upon which traversal is stopped and exclusive execution is assumed (i.e., no parallelism). In other instances, another joint predecessor step is reached, upon which traversal is stopped, and parallel execution is assumed.","The static, compile-time check mentioned is efficient to perform (takes linear time in the number of process steps), though it may yield inaccurate results. If appropriate, other (more expensive) graph analysis algorithms may be used that may yield fewer false positives\/negatives. For instance, some advanced algorithms may be tuned to detect control flow cycles which may let two process steps run in parallel even if they are either sequential or have a joint XOR split predecessor. For the vast majority of correctly modeled processes, the algorithm described above can yield improved system performance, balancing system efficiency with false positives and false negatives.","After checking each pair of process steps for conflicting accesses to resources, and filtering out pairs of process steps that do not run in parallel, the remaining pairs of process steps can be categorized into two groups: those whose conflict resolution is trivial (\u201cFirst Cases\u201d), and those whose conflicts are more complex to resolve (\u201cSecond Cases\u201d). In order to do so, the joint predecessor step (e.g., AND split or OR split, etc.) is considered, which was a prerequisite for assumed parallelism. Additionally, a joint successor step (e.g., AND join or OR join, etc.) can be identified, where the two branches are assumed to synchronize.","In a First Case, two conflicting process steps Pi and Pj on two parallel branches are initially arranged in a way that Pi or Pj is placed directly behind a joint predecessor step or directly in front of a joint successor step of Pi and Pj. That is, Pi or Pj is the first or last process step on its branch. Pi or Pj is the first process step behind the joint predecessor step on its respective branch, or Pi or Pj is the last process step in front of the joint successor step on its respective branch. For the Second Cases, both Pi and Pj have both other process steps between them and the joint predecessor and successor step.","The First Cases can be resolved by pushing a conflicting process step in front of the joint predecessor step or behind the joint successor step. Differences arise from what artifact the joint predecessor or successor step is. For AND splits\/joins, the conflicting process step can be placed directly in front of\/behind the AND split\/join. This is due to the fact that it is known that all outbound branches of an AND split to be activated when splitting the flow and all inbound branches required to be activated in order to trigger the AND join. In effect, the process step that is to be pushed from a parallel branch to in front of the AND split or to behind the AND join would be executed in either case\u2014no matter where it resides.  is an example process model  illustrating a First Case and an AND join predecessor step. In , activity \u201cZip Code Lookup\u201d  conflicts with \u201cUpdate Address in MDM\u201d . \u201cZip Code Lookup\u201d  is the first process step on its branch (directly behind the joint predecessor, parallel split ), and \u201cUpdate Address in MDM\u201d  is both the first and the last process step on its branch (directly behind the joint predecessor  and directly in front of the joint successor, parallel join ).",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 4A","FIG. 2","FIG. 4A"],"b":["400","401","402","416","404","404","416","418","404","418","402","404","414","421","421","404","414","406","414","420","414","422","414","408","410","424","412","408","412","408","418"]},"As introduced above, the \u201cZIP Code Lookup\u201d activity  of the upper branch  is in conflict with the \u201cUpdate Address in MDM\u201d activity  residing on the lower (parallel) branch . That is, both activities compete for accessing the \u201cAddress\u201d data object  (internal resource) and the \u201cMDM\u201d system (external resource).  illustrates a so-called First Case because the conflicting activities are (1) the first process step (\u201cZIP Code Lookup\u201d Activity) or (2) the first and last process step (\u201cUpdate Address in MDM\u201d activity) at the same time on their respective branches. For a First Case, it would even be sufficient if one of the two conflicting process steps is a first or last process step on its branch. This figure is an example of a First Case for three (redundant) reasons: First, one of the conflicting activities, \u201cZip Code Lookup\u201d , is the first process step on the upper branch. Second, conflicting activity \u201cUpdate Address in MDM\u201d  is the first process step on the lower branch. And third, conflicting activity \u201cUpdate Address in MDM\u201d  is also the last process step on the lower branch.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 4B","FIG. 4A","FIG. 4A","FIG. 4B","FIG. 4A","FIG. 4B"],"b":["450","408","418","408","416","412","408","407","402","404","408","415","423","425","423","410","425","412","410","412","418","415","412"]},{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 4C","FIG. 4A","FIG. 4C","FIG. 4A","FIG. 4C","FIG. 4A","FIG. 4A","FIG. 4A","FIG. 4C","FIG. 4B","FIG. 4C","FIG. 4B"],"b":["460","460","412","421","460","402","404","408","410","412"]},{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 5A","FIG. 5A","FIG. 5A","FIG. 5A"],"b":["500","502","500","502","502","500","520","522","520","504","506","504","522","508","508","522","504"]},"For OR splits and Complex Gateways, pushing the conflicting process step in front of the gateway would alter the execution semantics in a way such that the activation condition for the corresponding branch may not be evaluated before executing the conflicting process step at runtime.  is an example process model  showing an XOR split  and XOR join  (formally, \u201cExclusive Split Gateway\u201d  and \u201cExclusive Merge Gateway,\u201d  respectively) in front of the parallel branches. The \u201cConflicting Activity\u201d  is moved from the upper branch  of  to the sequential branch  preceding the parallel branches (as shown in ). Process  includes an XOR sequential branch  and a set of parallel branches, including an upper branch  that includes \u201cRest of Branch\u201d  and a lower branch  that includes \u201cParallel Branch\u201d . The XOR split  in front of the relocated \u201cConflicting Activity\u201d  facilitates triggering that step only when its original branch  is activated. Inserting an extra XOR split may cost extra CPU cycles and time, but may be (partially) compensated for by caching the outcome of the XOR split's evaluation (i.e., the original branch condition) in some buffer data object . The upstream XOR split checks the same condition as the upper branch  of the OR split . To avoid potential race conditions, the outcome of the XOR split  may be buffered in a dedicated data object  and later reused in the OR split.","In certain instances, the joint predecessor process step of two branches carrying mutually conflicting process steps may be an activity or a process step.  is an example process model  showing \u201cPredecessor Activity\u201d  as the joint predecessor of a set of parallel branches. When the joint predecessor is not a gateway, but another process step (e.g., activities, events, etc.), an implicit AND-split semantics may apply. That is, a predecessor step having multiple outbound branches is semantically equivalent to a predecessor having a single outbound edge that points to an AND split which forks the parallel branches. In effect, the treatment for AND splits may apply, and the conflicting process step may be relocated to a place in between the original predecessor step and the (now separated) AND split behind. In , \u201cPredecessor Activity  is a predecessor activity prior to parallel branches of the process . The upper branch  includes the \u201cConflicting Activity\u201d  and the \u201cRest of Branch\u201d . The lower branch  includes \u201cParallel Branch\u201d , which is in contention for a resource with \u201cConflicting Activity\u201d .","The conflict can resolved as shown in .  is an example process model  in which \u201cConflicting Activity\u201d  is moved to a position in series and after \u201cPredecessor Activity\u201d . The \u201cConflicting Activity\u201d  is moved out of the upper branch  (of ), and a new sequential branch  is defined that includes the \u201cPredecessor Activity\u201d  and the \u201cConflicting Activity\u201d  (though, it is no longer conflicting). The upper branch  now includes \u201cRest of Branch\u201d , and the lower branch  includes \u201cParallel Branch\u201d . An AND split  may be added as the joint predecessor to the parallel branches. \u201cConflicting Activity\u201d , however, can directly fork the two branches. In other words, \u201cConflicting Activity\u201d  can be the joint predecessor to the parallel branches  and .  is an example process model  in which \u201cConflicting Activity\u201d  is the joint predecessor of the parallel branches. In , the sequential branch  includes the \u201cPredecessor Activity\u201d . \u201cConflicting Activity\u201d  is also in the sequential branch . Sequential branch  does not include an AND split. Instead, parallel branches  (that includes \u201cRest of Branch ) and  (that includes \u201cParallel Branch\u201d ) branch directly from \u201cConflicting Activity\u201d .",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 7","FIG. 7"],"b":["700","700","702","700","704","720","722","720","706","708","710","722","712","714","716","718"]},"The conflicting process step cannot immediately be pushed in front of or behind the parallel branches. Techniques for resolving conflicting resource access include swapping process steps (under consideration of the dependency graph (see FIG. )), by which the Second Case can be transformed into a First Case, which is handled as shown above. If transformation into a First Case is not feasible, however, a variant of the milestone pattern can be used to enforce synchronizing conflicting process steps even though they reside on parallel branches.","Process model  above illustrates a Second Case in which the conflicting process steps reside in the middle of their parallel branches. Transforming a Second Case into a First Case is an approach that both does not increase the number of artifacts (process steps) in the resulting process model (by changing the order of process steps before handling the resulting Second Case) and does not introduce any extra synchronization between the parallel branches. Feasibility is constrained by dependencies between the conflicting process step(s) and the process step(s) that are exchanged against on their branches. In the example process, transformation of the scenario where the \u201cConflicting Process Step (Upper Branch)\u201d  is in conflict with \u201cConflicting Process Step (Lower Branch)\u201d  could happen by any of:\n\n",{"@attributes":{"id":"p-0088","num":"0091"},"figref":"FIG. 8A","b":["800","800","802","804","802","804","826","828","826","806","808","810","828","812","814","816","800","808","814","816","2","822","806","812","1","820","810","816","3","824","2","822","808","814","816","818"]},"Swapping a sequence of activities A\u2192B into B\u2192A (i.e., moving A right and B left) may be constrained by the mutual dependencies between A and B. As both A and B are process steps that access different resources (R  and R , respectively), no direct dependencies exist. Therefore, we define an \u201cinteracts with\u201d relation as follows: activity A interacts with another activity B if, and only if: (a) there is some resource R that is updated by B (i.e., B \u201cwrites to R\u201d), and (b) there is a resource R\u2032, which is identical to R, or R\u2032 is transitively dependent from R, and A reads from or writes to R\u2032.","Put differently, an activity A interacting with another activity B denotes that A is in some way affected by the effects of B on a shared resource. Having both A and B read a shared resource does not denote an interaction in that sense. Conversely, if B writes to a resource (say, some data object), and A reads that resource, A interacts with B (in other words, A depends on B in a sense that A consumes the effects of B materialized in the shared resource). Due to the fact that (1) updating a resource often entails reading the resource beforehand, and (2) to avoid \u201clost update\u201d phenomena, A also interacts with B if A updates (writes to) the shared resource that is also updated by B, the \u201cinteracts with\u201d relationship also applies to transitive resource relationships. For instance, B might be updating some data object while A reads from some role definition that is defined as a dependent view atop the data object. Altering the data object may propagate to the role through its view definition such that A may be reading the effects of B.","Returning to the concept of swapping a predecessor activity A against another activity B, the sequence A\u2192B can be altered into B\u2192A if, and only if, neither A interacts with B nor B interacts with A. In other words, none of the two process steps has effects that may alter the effects of the other activity.",{"@attributes":{"id":"p-0092","num":"0095"},"figref":["FIG. 8B","FIG. 8A","FIG. 8B"],"b":["850","804","804","802","818","818","806","808","825","806","808","810","808","806","810","826","812","814","816","1","820","2","822","3","824","806","808"]},"The complex conflicting scenario shown in  (activity B  from upper branch  competes with activities E  and F  on lower branch  on accessing the data object R ) can be resolved by transforming it into a First Case. Activity A  can be swapped with activity B  because neither A  interacts with B ; nor does B  interact with A . The two activities A  and B  access different resources, such that their order does not matter. After doing so, B  is the first activity on the upper branch , as shown in .","After swapping the positions of activities A  and B , the transformation rules of the First Case can be applied. Specifically, activity B  can be moved in front of the AND split  to ultimately resolve the conflict.  is an example process  resulting from transforming a Second Case into a First Case to resolve conflicting accesses to a shared resource. In process , activity B  is moved to a sequential branch , and is shown to be between the start  and the AND split . AND join  joins the upper branch  with lower branch . Activity B  write-accesses resource R  prior to the start of the parallel branches, and thus, the write access does not conflict with either E  or F . Upper branch  now includes activities A  (read-accessing R ) and C  (read-accessing R ). Lower branch  remains unchanged. Activity D  read accesses R ; activity E  write accesses resource R , and activity F  write accesses R  and read accesses R . Activity E  is not in conflict with activity F  for access to R  because activities E  and F  are performed in series.","Transforming a Second Case into one of the First Cases may not always be feasible because the \u201cinteracts with\u201d relationship may inhibit swapping the position of the conflicting activity with another step on the branch.  is an example process model  in which activities interact. Process  includes an AND split  after the start . Process  includes two parallel branches joined by an AND join . The upper branch  includes activities A , B , and C . The lower branch  includes activities D , E , and F . Activities A , D , and E  read from resource R . Activity A  reads from resource R ; activities B , C , E , and F  write to resource R . Activities C  and F  read from resource R . In process , activity A  interacts with B  because A  reads R , which is updated by B . Activity B  interacts with C  because process B  updates R , which is also updated by C . Similarly, activity E  interacts with F  because E  and F  write to R . In effect, neither B nor E (a conflicting pair of activities) can be moved away from their positions on their respective branches.","Techniques for resolving access conflicts for the situation described above in connection with  may include combining a \u201cmilestone\u201d and a \u201ccritical section\u201d workflow pattern. Resource contentions that may have the effect of accessing shared resources are primarily addressed. That is, conflicting activities may remain on their respective (parallel) branches, provided that they are not actually attempted to be executed simultaneously. Thus, a synchronization mechanism can be introduced across branches that serializes accessing process steps on different branches.","BPMN does not natively support certain synchronization approaches (e.g., milestone and critical section patterns), and so such approaches are modeled using existing artifacts, such as AND splits and joins.  is an example process model  that includes a critical section  for synchronizing parallel activities. The process model  shown in  illustrates how the execution of activities B  and E  can be synchronized by introducing a \u201ccritical section\u201d  pattern around those two process steps. Process model  begins at  and proceeds to an AND split . In addition to the parallel branches (including first upper branch  and first lower branch ), a third branch  is initially forked from the initial AND split . A token from that branch  is merged with a token representative of the completed activities A  or D  (i.e., the process is ready to execute B or E on the upper or lower branch, respectively) at Parallel Join . The branch that is entering the critical section  is recorded in the Boolean data objects \u201cupperBranch\u201d  and \u201clowerBranch\u201d , which are set to \u201ctrue\u201d in the predecessor activities (A and D). The parallel branches  and  are combined at uncontrolled merge .","Inside the critical section , the branch to be executed is identified, and either runs B  or E , respectively, based on the identification (the Exclusive OR (XOR), split  facilitates the conditional pathway for process step execution, which is based on the tokens received at parallel join ). The identification can be based on a state following the completion of activity A  and\/or D  using the \u201cupperBranch\u201d  and \u201clowerBranch\u201d  data objects. A token is passed back to the start of the critical section  and the rest of the current branch is continued. Thus, a token from the opposite branch can enter the critical section  by synchronizing the passed-back token with the token from the upstream part of the branch. Activities C  and F  can be executed after the process steps in the critical section  are executed.","Using a mixture of the \u201ccritical section\u201d and \u201cmilestone\u201d workflow patterns for this sort of cross-branch synchronization considers how to structure the process. For one, the \u201cactive\u201d branch is recorded in a separate data object (in , in either \u201cupperBranch\u201d  or \u201clowerBranch\u201d ) to avoid that concurrent process step's \u201crace\u201d on accessing a single data object for that purpose. Second, a Terminating End Event can be used to complete the (sub-) process in which the pattern is used, thus enabling that any pass-back tokens are cleaned up when the process terminates.","Cross-branch synchronization both obfuscates and (to some extent) inflates the process model with additional artifacts. Namely, additional artifacts include additional data objects (to store the branch activation status), one or more additional AND-splits (to pass back a token) for each process branch, and one or more additional AND-splits, XOR splits, and XOR merges, globally. Obfuscation, however, can be reduced by \u201coutsourcing\u201d the affected process fragments into sub-processes. The overhead of additional artifacts may well be acceptable in the light of resource contentions that can be avoided in this manner. In particular, gateways (which make up for the largest part of the synchronization pattern) have a minimal runtime overhead. The extra data objects for storing the branch activation (and the corresponding data mappings which set\/unset those data objects) can be avoided at the expense of introducing another AND split\/AND join pair per branch plus a \u201cglobal\u201d AND split which replaces the XOR split as shown in .",{"@attributes":{"id":"p-0101","num":"0104"},"figref":["FIG. 9C","FIG. 9C","FIGS. 9B and 9C"],"b":["960","906","912","962","964","908","914","966","970","908","914"]},"Sequentializing resource contentions helps to reduce the occurrence of resource contentions that arise from concurrent accesses to shared resources. In effect, fair progress inside process instances (among different branches) also benefits from avoiding recurrent rollback\/retry cycles of process steps that fail due to resource conflicts. Similarly, process turnaround times may be reduced by fewer occasions where process steps need to wait for blocked resources.",{"@attributes":{"id":"p-0103","num":"0106"},"figref":"FIG. 10","b":["1000","1002","1004","1006","1008","1010","1012","1014","1010","1016","1018","1004","1020"]},{"@attributes":{"id":"p-0104","num":"0107"},"figref":"FIG. 11","b":["1100","1102","1104","1106","1108","1110"],"sub":["i ","1","1","2","3","i","1","2","1","3","2","3"]},"A number of embodiments have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly, other embodiments are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 4B","FIG. 4A"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 4C","FIG. 4A"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 8A","FIG. 7"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8C"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 9C"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
