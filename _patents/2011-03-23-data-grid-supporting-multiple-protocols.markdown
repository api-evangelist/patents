---
title: Data grid supporting multiple protocols
abstract: A proxy server for a data grid receives an object and a client request to store the object in a database using a first database protocol, wherein the request and the object have a first format that complies with the first database protocol. The first proxy server translates at least one of the object or the request into a second format that complies with a second protocol used by the data grid. A node of the data grid then processes the request to store the object on the data grid.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08949294&OS=08949294&RS=08949294
owner: Red Hat, Inc.
number: 08949294
owner_city: Raleigh
owner_country: US
publication_date: 20110323
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED CASES","TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["The present application is related to co-pending U.S. patent application Ser. No. 13\/070,314, filed Mar. 23, 2011, entitled \u201cSYSTEM AND METHOD FOR PERFORMING OBJECT RELATIONAL MAPPING FOR A DATA GRID.\u201d","Embodiments of the present invention relate to data grids, and more specifically to using data grids to provide data as a service (DaaS) functionality.","Cloud computing is a model for enabling convenient, on-demand network access to a shared pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that can be rapidly provisioned and released with minimal management effort or service provider interaction. Cloud computing providers currently offer infrastructure as a service (IaaS) and platform as a service (PaaS). IaaS is a provision model in which equipment such as storage equipment, computing equipment, networking equipment, etc. is provided on a per use basis. PaaS is a provision model in which a computing platform and solution stack are delivered to clients as a service on a per use basis. Each of these services has the properties of elasticity (ability to deal with new nodes being added and existing nodes being removed dynamically), high availability, scalability, and linear response times.","One service that has not been successfully moved to the cloud computing model is managed data storage, which is conventionally performed by databases. Data storage is stateful, which makes data as a service (DaaS) much more challenging than any of the other categories of cloud computing. Traditional data storage uses databases such as structured query language (SQL) and not only SQL (NoSQL) databases. Databases do not scale, so they tend to run on a single machine or a few machines running in a fixed cluster. Therefore, databases are not distributed by nature. This becomes a problem in the cloud because in clouds there is no guarantee that a particular server will be available at any given time. The lack of distribution for databases hampers elasticity and high availability, two of the requirements for cloud computing services. Therefore traditional database data storage does not work for DaaS.","Described herein are a method and apparatus for enabling a data grid to communicate with clients using multiple protocols. In one embodiment, a first proxy server for a data grid receives an object and a client request to store the object in a database using a first database protocol. The request and the object have a first format that complies with the first database protocol. The first proxy server translates at least one of the object or the request into a second format that complies with a second protocol used by the data grid. A node of the data grid then processes the request to store the object on the data grid. Similarly, a second proxy server for the data grid may receive an object and client request that have a format compliant with another database protocol, and may translate the object and\/or the request from the other database protocol into the second protocol. The first proxy server may also translate responses and objects from the format for the second protocol into the format for the first database protocol, and the second proxy server may translate responses and objects from the format for the second protocol into the format for the third database protocol. Therefore, clients may communicate with the data grid using multiple different protocols. This enables multiple clients that use different protocols to share data via the same data store.","Unlike traditional object relational mapping, the object relational mapping performed by embodiments of the present invention map an object to a collection of linked key value pairs. An object may be a record to be added to a database, a portion of a database record (e.g., a field), an in memory data structure, or any other data. These key value pairs are then stored in a data grid (e.g., a distributed data grid) rather than in a database. The data in the data grid can be distributed across the data grid nodes. Therefore, stateful data can be maintained in a reliable, highly available, linearly scalable and elastic manner. Accordingly, embodiments of the present invention enable a data grid to provide data as a service (DaaS) functionality.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","100","105","110","115","120"]},"Machines , , ,  may be hardware machines such as desktop computers, laptop computers, servers, or other computing devices. Each of the machines , , ,  may include an operating system that manages an allocation of resources of the computing device (e.g., by allocating memory, prioritizing system requests, controlling input and output devices, managing file systems, facilitating networking, etc.). In one embodiment, one or more of the machines , , ,  is a virtual machine. For example, one or more of the machines may be a virtual machine provided by Amazon\u00ae Elastic Compute Cloud (Amazon EC2), a VMWare\u00ae virtual machine, etc. In some instances, some machines may be virtual machines running on the same computing device (e.g., sharing the same underlying hardware resources). In one embodiment, one or more of the machines , ,  is a java virtual machine (JVM), which may run on a hardware machine or on another virtual machine.","Machines , ,  each include a data grid node  that runs on the machine. The data grid node  is a data grid application, such as an instance of JBoss\u00ae Infinispan\u00ae, Oracle\u00ae Coherence\u00ae or Hadoop\u2122. Each data grid node  may act as a server for data to clients and as a peer to other data grid nodes . Data grid nodes  are discussed in greater detail below with reference to .","The data grid nodes  may communicate via the network to form a data grid . This may include using peer-to-peer protocols to establish and manage membership of the data grid . The peer-to-peer protocols may include functionality for group creation and deletion, peer discovery, peer communication, and so on. In one embodiment, JGroups is used as an underlying peer-to-peer communication mechanism. Alternatively, other peer-to-peer protocols may be used.","The data grid  is a data store that spans multiple machines , ,  that are joined in a dynamic cluster. In one embodiment, the data grid  is a NoSQL based data store. The data grid  can be provided to clients using a DaaS model. In one embodiment, the data grid  operates in a client-server mode, in which the data grid  serves resources (e.g., a stateful data store such as a cache) to client applications . In one embodiment, the data grid  acts as a shared storage tier for client applications . A separate memory space may be generated for each client application .","The data grid  may include a volatile in-memory data structure such as a distributed cache. The data grid  may also provide a persistent data structure (e.g., a data structure stored in non-volatile disk storage). In one embodiment, the data grid  provides a distributed cache with write through or write behind to persistent storage. In one embodiment, Amazon Simple Storage (S3) platform hosts the data for the data grid  as part of a cache store. Other key value based storage systems may also be used to host the data grid's  data.","In one embodiment, the data grid  is indistinguishable from a database to users and client applications . Therefore, client applications  may use conventional database formats, protocols and semantics for communicating with the data grid . For example, client applications  may communicate with the data grid  using the memcached protocol, the REST protocol, the OData protocol, the Websockets protocol, SQL, etc.","However, unlike a database, the data grid  actually distributes stored data across multiple machines , , . The data grid  is elastic (can deal with new nodes being added and nodes being removed), scalable and highly available. The data grid  may also perform load balancing and failover of individual data grid nodes . Therefore, the data grid  performs the functions normally provided by databases, but can provide these functions using a DaaS model.","In one embodiment, the data grid nodes  form a distributed cluster, which causes the data grid  to be a distributed data grid. This enables the data grid  to scale linearly as more data grid nodes  are added to the cluster. In one embodiment, distribution makes use of a consistent hash algorithm to determine where in the cluster entries should be stored. The hashing algorithm may be configured to maintain a specified number of copies of each entry in the data grid . In one embodiment, the hashing algorithm is deterministic in locating entries without resorting to multicasting requests or maintaining expensive metadata.","In one embodiment, the data grid  provides a rich and powerful application programming interface (API) that looks and feels like a database. A client may communicate with any data grid node  of the data grid  to access data stored in the data grid . A data grid node  may receive database commands, such as commands to store objects, to retrieve objects, to perform searches, etc. When a data grid node  receives a command to store an object, the data grid node  divides the object into a collection of linked key value pairs. The data grid node  then stores some or all of these key value pairs. Additional data grid nodes  may also store some or all of the key value pairs.","When any of the data grid nodes  receives a request for the stored object, that data grid node  gathers up all of the key value pairs for that object, and reconstructs the object from the key value pairs. This may involve requesting the key value pairs from one or more other data grid nodes . Once the object is reconstructed, the data grid node  returns the object to the client from which the request was received.","The data grid nodes  are each configured to operate using a specific protocol. Therefore, the data grid nodes  expect to receive objects having a specific type and commands having a specific format. The data grid nodes operate on objects having a predefined type. In one embodiment, the data grid nodes operate on Java objects and\/or on Javascript object notation (JSON) objects. Client applications  may communicate with the data grid  using the specific protocol that the data grid  uses to manage data. In one embodiment, the data grid nodes  are configured to respond to commands formatted in a key value based NoSQL database format. Alternatively, clients may communicate with the data grid  using additional protocols.","To enable clients configured for different protocols to access the data grid , the data grid  may include one or more proxy servers , , . Each proxy server , ,  may be used to translate objects and requests into the specific formats used by the data grid nodes . Each proxy server , ,  includes internal rules on how to translate an incoming protocol into a protocol used by the data grid , and how to translate responses going out from the protocol used by the data grid  into the protocol used by the client application  or by a specific component , ,  of the client application .","In one embodiment, one or more of the data grid nodes  is collocated with a proxy server , , . Additionally, a data grid node  may be collocated with multiple proxy servers , , . The proxy servers , ,  provide a layer of indirection for the data grid . Each proxy server , ,  is configured to translate objects and requests between the specific protocol supported by the data grid nodes  and an external protocol. Examples of proxy servers include a REST proxy server , a memcached proxy server  and an OData proxy server . Other examples of proxy servers include a web socket proxy server, etc.","Each proxy server , ,  may be an endpoint that appears to client applications  as a backend storage server. Client applications  may communicate with the proxy servers , ,  as though the proxy servers are full backend storage servers. Each proxy server , ,  may be configured to listen to a specific port or ports, and act on messages sent to those ports.","To use the data grid , a client application  acquires a session from the data grid , and sends commands to the data grid  via the session. Client application  may be a standalone application running on a single machine. Alternatively, client application  may be a system with multiple clients , , , each of which may run in a separate machine , , . The clients , ,  may each run on a different system, use a different protocol, be written in a different language, operate on a different platform, etc. For example, a web application may have a Java middleware component that serves up web applications, and another component that is a part of one of the web applications. For example, if a web application uses Ajax and client side java script in a user's browser, the user's browser may communicate directly to the data grid  to populate the browser's screen. A third component of the client application  may be a python script that monitors all data and processes orders as and when they are placed in the data grid .","In one example embodiment, the client application  includes a memcached client , a REST client , and an OData client . Each of these clients , ,  may communicate with the distributed data grid  using their specific protocols. In one embodiment, each client is configured to communicate with a particular proxy server (e.g., is configured with a network address of the particular proxy server). Each client may also be configured with network addresses of multiple proxy servers, and may be able to fail over across the proxy servers. For example, each client may be configured with a network address or addresses for a cluster of proxy servers, wherein each proxy server in the cluster handles communications formatted according to the protocol used by the client. In one embodiment, a load balancer (e.g., an HTTP load balancer for a REST proxy server ) manages load for the cluster. Examples of HTTP load balancers include Apache\u00ae mod_cluster, Jboss\u00ae mode_cluster, Big-IP\u00ae, etc. Other load balancers may be used for the REST proxy servers and\/or for other proxy servers.","In an example, the REST client  may send an object and request formatted according to the REST protocol to the distributed data grid . The request and object may be received by the REST proxy server  and translated into the backend protocol used by data grid nodes . The data grid nodes  may then perform one or more operations in response to the request.","In one embodiment, communications may be routed to an appropriate proxy server , , , which may then translate the communications into the protocol used by the data grid nodes  on the back end (e.g., into a key value based NoSQL database format). In one embodiment, each data grid node  includes a request router (not shown). Additionally, or in the alternative, each proxy server may include a request router. The request router may determine, based on a format of a received communication, the protocol in which the communication was formatted. For example, the request router may include different communication categorization rules. If a received communication satisfies, for example, a REST protocol communication categorization rule, the data grid node  may determine that the communication is formatted according to the REST protocol. The request router may forward the communication to an appropriate proxy server that is configured to handle communications having the determined protocol. In one embodiment, the request router includes a table of proxy servers, each entry in the table including one or more addresses for proxy servers and an associated protocol. The table may be used to determine a proxy server to forward a communication to.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 2A","FIG. 1"],"b":["205","205","125","205","250","205","205"]},"The data grid node  operates in a cluster with other data grid nodes to form a data grid. Each data grid node  may act as a server for the data grid. Therefore, a client may access any of the data grid nodes  to gain access to the entire data grid. New data grid nodes can be started and connected to the other data grid nodes without performing rehashing or state transfer. Therefore, startup times for new data grid nodes can be predictable and relatively short.","In one embodiment, the data grid node  includes a client interaction module , an object relational mapper , a data manager , a query module , an object reconstructer , a node interactor  and an event listener . The node interactor  makes use of internet protocol (IP) based networking (e.g., transmission control protocol (TCP), user datagram protocol (UDP), etc.) to communicate with other data grid nodes. In one embodiment, the node interactor  issues remote procedure calls (RPCs) to neighbor nodes. The neighbor nodes invoke the RPCs, generate a response, and return the response to the data grid node that generated the RPCs. In one embodiment, the node interactor  uses JGroups Transport to communicate with other data grid nodes.","Node interactor  performs peer discovery and manages membership of the data grid. In one embodiment, node interactor  maintains a grid membership data structure  that includes entries for each data grid node in the data grid. Each entry may include an address and\/or a port of a data grid node. This membership data structure  may be used to determine which neighbor nodes to communicate with.","The client interaction module  receives requests from clients and sends responses to clients. Requests may include requests to store objects, to retrieve objects, to search for objects, to retrieve information about objects, and so on. Responses may include objects, information about objects, confirmation messages, error messages, etc. The requests and responses are configured in a specific format understandable to the data grid node . Received requests may have been translated into the specific format by a proxy server. In one embodiment, the requests and responses have a key value based NoSQL database format. For example, the requests, responses and\/or objects (payloads) may have a simple format of keys mapped to values.","A number of operations can be performed on the data grid such as get, put, remove, notify and unnotify. Getting and updating data in the data grid may be performed by calling the get, put and remove functions on an instance of the data grid. These operations could be triggered by user interaction with a web form, for example. In one embodiment, a callback function is registered with the data grid for the get and notify operations. This callback function receives all add\/update\/remove notifications entries in the data grid for which the notify function was invoked.","Requests to store objects include the objects that are to be stored. These objects may be objects of a specific type that the data grid node  is configured to operate on. Object relational mapper  performs object relational mapping for data grids on received objects. In one embodiment, the object relational mapper  operates on java objects such as plain old java objects (POJOS). In one embodiment, the object relational mapper  operates on extensible JavaScript Object Notation (JSON) objects and\/or JSON arrays. Alternatively, the object relational mapper  may operate on objects that are in the form of extensible markup language (XML) data.","A JSON object is an unordered collection of name value pairs. The values can be of the following types: Boolean, JSONArray, JSONObject, Number, String, or JSONObject.null. The external form of a JSON object is a string wrapped in curly braces with colons between the names and the values, and commas separating name value pairs. The internal form is an object having get and opt methods for accessing values by name, and put methods for adding or replacing values by name. A JSON object constructor can convert a JSON object from the external form to the internal form.","In one embodiment, the data grid node  includes one or more event listeners . Event listeners  may be configured to monitor for specific types of events, and to notify clients when events occur. For example, an event listener  may be configured to listen for changes to specific objects, and to report such changes to particular clients. The event listener  may be configured to notify a client before an event occurs and\/or after the event occurs. Notifications may be dispatched synchronously or asynchronously.","Conventional object relational mapping maps objects to tables. However, tables do not scale, and so are inappropriate for use in a data grid. In contrast, the object relational mapping for data grids performed by object relational mapper  maps objects to a collection of key value pairs. These key value pairs may be maintained in a cache and\/or may be stored in persistent storage. For example, the key value pairs may be stored as files in a file system or in another format for persistent storage. The format of the persistent storage and\/or cache may be configurable.","A distinct key value pair may be generated for each field of the object. The key for a key value pair may be based on the field, and the value may be the contents of that field. In one embodiment, a primary key value pair is generated for the object that will be used as a unique identifier for the object. A primary key value pair is a key value pair that is used to reference the object and to link the key value pairs generated from the object. The key for the primary key value pair may be the object's unique identifier. The values in the primary key value pair include references (e.g., pointers) to other key value pairs of the object. The primary key value pair may have references to all of the other key value pairs generated from the object, or to just some key value pairs. In one embodiment, the primary key value pair includes references to key value pairs generated for each primitive field (e.g., string, Boolean, integer, etc.) included in the object, and to additional primary key value pairs for each complex field.","Consider an example of a received user object such as a java user object. The user object may include fields for a user name, a user age and a user address. Each field may have a type of \u201cstring.\u201d The object relational mapper  breaks this object up into key value pairs. A unique identifier (e.g., a universally unique identifier (UUID)) is generated for the object and used as the key for the primary key value pair. A separate key value mapping is generated for each field (e.g., for each attribute). The generated key value pairs may include \u201cuser1_name: John Doe,\u201d \u201cuser1_address: 123 Clipper Way,\u201d and \u201cuser1_age: 72.\u201d These key value pairs may be stored in the data grid and distributed across the grid. That way the stored object is fault tolerant and highly available.","The object relational mapper  is able to handle complex objects. A complex object is an object that has at least one complex field (a field that has a type other than a primitive type) or a relationship to another object or array. A complex field represents an internal or nested object. An object may include multiple layers of nested objects. For example, an object may include a complex field, which in turn may include another complex field, which may include another complex field, and so on. An additional layer of indirection may be introduced by each layer.","For a complex object, each internal object may be assigned its own primary key and its own unique identifier. Relationships between objects may be handled by using references (e.g., pointers) between primary key value pairs. Consider an example in which one object has a relationship to another object. The object that has the relationship to the other object would store in its primary key a reference to the unique identifier of that other object. The reference may be a pointer that resembles an in memory pointer except that instead of storing a memory reference, a UUID is stored.","In one embodiment, it is the responsibility of clients to designate unique identifiers for objects. The unique identifier designation may be included in the request to store the object. Alternatively, the data grid node  may generate unique identifiers for received objects and\/or for internal objects of received objects. For example, a first field in the object may be used to generate a unique identifier for the object. A client may later retrieve an object based on that object's unique identifier. Note that the client does not need to remember the unique identifier for the object in one embodiment. Instead, the client may perform a query to determine the unique identifier for the object.","Object reconstructor  reconstructs objects from key value pairs . When a client needs to retrieve a stored object, the client sends the data grid node  a message  that includes the unique identifier for that object. The unique identifier may be a primary key in a primary key value pair that was generated for the object. The object reconstructor  gathers up all of the key value pairs  associated with that object, and puts them back together to reform the object.","In one embodiment, the object reconstructor  retrieves the primary key value pair that was generated for the object using the unique identifier. That primary key value pair includes references to key value pairs for each of the fields of that object. The primary key value pair and\/or additional key value pairs may be stored on the data grid node  or on other data grid nodes. If any of the key value pairs are not stored on the data grid node , node interactor  communicates with other data grid nodes to retrieve those key value pairs .","If the object included an internal object (a complex field), then the primary key value pair includes a reference to another primary key value pair of the internal object. That internal object may have its own unique identifier, and may also have been divided into key value pairs. On retrieving the primary key value pair for the internal object (complex field), the object reconstructor  uses references included in that primary key value pair to retrieve additional key value pairs. This process continues until all key value pairs for the object and all internal objects have been retrieved.","Once all key value pairs are retrieved, the object reconstructor  uses those key value pairs to reconstruct the original object. The object can be reconstructed with all internal objects, references, types, values, etc. that the object originally had before it was stored.","In one embodiment, the data grid node  supports multi-tenancy. Therefore, data from different applications can be isolated in the same data store. Having multi-tenancy enabled allows different applications to store data having the same name or same primary key without any of this data being overwritten. Therefore, changes made to objects in a first application do not cause any modifications to objects of a second application, even if those objects share the same name and unique identifier. Thus, multi-tenancy provides a way to isolate data while still sharing the same data store. Data associated with different applications may be distinguished by using name spacing, in which the application's unique identifier as attached to the object's unique identifier in each primary key. Therefore, the unique identifier for an object may be a combination of the application's unique identifier and the object's unique identifier.","In one embodiment, data grid node  adds annotations to objects for indexing. For example, object relational mapper  may add annotations to key value pairs as they are generated. In one embodiment, data grid node  includes a query module . The query module  indexes objects stored in the data grid based on the annotations, and enables clients to perform searches on the objects. This enables clients to obtain objects within the data grid without needing to know the unique identifiers (primary keys) to each object that the client wants to obtain. For example, a user may search for the field name, and the name john. The query module  may then search the key value pairs for the value \u201cjohn\u201d in a key for the name field. For every match, the query module  may identify the object associated with that key value pair and the unique identifier for that object. This information may be returned to the client. In one embodiment, queries are expressed in Drools query language. Alternatively, other query languages may be used. For example, queries may be defined in XML, or may be Apache\u00ae Lucene\u00ae queries.","In one embodiment, the query module  provides fault tolerant queries. If the data grid node  crashes while executing a query, another data grid node will continue performing the query.","In one embodiment, data manager  keeps track of the number of references that are made to each object. If a reference count for an object is zero, then data manager  may enable that object to be deleted. This enables garbage collection.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 2B","FIG. 1"],"b":["250","250","130","135","140","250","250","205","250","205","250"]},"Each proxy server  listens on a specified port or ports. Clients connect to a port, send commands to the proxy server, read responses, and eventually close the connection. Each proxy server  provides a distinct mechanism (e.g., an application programming interface (API)) for connecting to the same data grid, and operates as a distinct endpoint for the data grid. For example, the REST proxy server includes a REST API that enables a REST client to interact with the data grid using standard hypertext transport protocol (HTTP) commands. By providing multiple protocols for communicating with the data grid, multiple different clients written in different languages, running on different platforms, and performing different actions can all use the same data.","In one embodiment, each proxy server  includes a client side translator , a data grid side translator  and a message forwarder . Proxy server  receives a message  from a client that is formatted according to a first protocol. The received message  may include an object (data) to be stored. Client side translator  receives this message and any object included in the message, and translates the message and\/or the object into a second format that is compliant with a second protocol used by the data grid. In one embodiment, the object is translated into a java object or a JSON object. Message forwarder  then forwards the translated message  and object to the data grid.","The data grid generates a response message  having a format compliant with the second protocol, and sends this response to proxy server . The response  may include an object (e.g., if the message was a request for an object). Data grid side translator  translates the response message  and\/or the object from the second protocol to a format compliant with the first protocol. For example, data grid side translator  may translate a JSON object into a binary array or base 64 encoded binary data. Message forwarder  then forwards the translated response  and\/or object to the client. Therefore, each proxy server  is able to encode and decode data so that it is able to communicate with clients in a manner compliant to a first protocol and is able to communicate with data grid nodes in a manner compliant to a second protocol.","In one embodiment, the proxy server  is clustered with other proxy servers of the same type. This can enable the proxy server  to perform load balancing and failover. Clients wanting to load balance or failover between REST proxy servers can do so using any standard HTTP load balancer such as mod_cluster. Unlike conventional memcached servers, the memcached proxy servers can be clustered. Therefore, the memcached proxy servers can replicate or distribute data using, for example, consistent hash algorithms. Since websockets work on the HTTP port, any HTTP load balancer can be used to perform load balance and failover for a websocket proxy server.","In one embodiment, the proxy server  is a REST proxy server. The REST proxy server translates messages and data between a format compliant with the REST protocol and a format compliant with another protocol used by the data grid. The REST proxy server makes use of simple GET, PUT, REMOVE, etc. HTTP commands for communication with clients. To connect to the REST proxy server, any HTTP client can be used.","The REST proxy server enables clients to access data via universal resource locators (URLs). Clients may use HTTP PUT and POST commands to place data into the data grid, with URLs to address a storage data structure name (e.g., a cache name in the data grid) and keys associated with specific data (e.g., with a specific object or objects). Similarly, clients may use the HTTP GET command to retrieve data from the data grid. The data being stored and\/or retrieved is the body of the request and\/or response. This data can be any type of data, but is frequently base 64 encoded binary data.","A PUT request may have the form PUT\/{cacheName}\/{cacheKey}. This will place the payload (body) of the message in a given cache (data grid storage area), with a given key. For example, in the URL \u201chttp:\/\/someserver\/hr\/payroll\/3\u201d, the \u201chr\u201d is the cache name and \u201cpayroll\/3\u201d is the key. Using the PUT command, any existing data having this key in this cache will be replaced, and time-to-live and last-modified values, etc. will be updated. A POST command follows the same syntax as the PUT command, but will return an HTTP CONFLICT status if the object having the specified cache and key values already exists, and the content will not be updated.","To retrieve data, GET\/{cachename}\/{cachekey} syntax may be used. This will return the data found in the given cachename under the given key as the body of the response. A content-type header may be supplied that matches what the data was inserted as. In one embodiment, a unique ETag may be returned for an entry, as well as the last-modified header field indicating the state of the data in the given URL. Etags allow browsers (and other clients) to ask for data only in the case where it has changed. The HEAD command may be used with the same syntax as the GET command. However, only headers (no payload content) are returned with the HEAD command. Other REST commands may also be used.","The restrictions imposed on objects by the REST specification causes these objects to often be base 64 encoded binary data. In one embodiment, the REST proxy server wraps such base 64 encoded binary data into an internal java object (e.g., a JSON object). The REST proxy server may also translate the internal java object back into a base 64 encoded binary data.","In one embodiment, the proxy server  is a memcached proxy server. The memcached proxy server translates messages and data between a format compliant with the memcached text protocol and a format compliant with another protocol used by the data grid. This allows memcached clients to communicate with the data grid. Memcached clients communicate with the memcached proxy server through transmission control protocol (TCP) or user datagram protocol (UDP) connections. The memcached proxy server enables the distributed data grid to be used as a drop in replacement for conventional memcached servers. The memcached proxy server enables clients to use any of the numerous client libraries written for memcached. Any conventional memcached client can be used to connect to the memcached proxy server.","There are two types of data sent in the memcached protocol: text lines and unstructured data. Text lines are used for commands from clients and responses from the memcached proxy server. Unstructured data is sent when a client wants to store or retrieve data. The memcached proxy server will transmit back unstructured data in exactly the same way it received it, as a byte stream. Data stored using the memcached protocol is identified by a key, which is a text string that uniquely identifies the data.","Memcached includes six storage commands (set, add, replace, append, prepend and cas) and two retrieval commands (get and gets). Each storage command asks the memcached proxy server to store some data identified by a key. To store data, the client sends a command line, then a data block. The client then expects to receive one line of response, which indicates success or failure. The retrieval commands ask the server to retrieve data corresponding to a key or set of keys. The client sends a command line, which includes all of the requested keys. For each item, the server finds the data block and sends it to the client along with a single response line. The memcached proxy server wraps objects that are binary arrays (or other unstructured data) received from memcached clients using an internal java object (e.g., a JSON object). A binary array is an n-dimensional array, all of whose values are 1 or 0. The memcached proxy server may also translate internal java objects into binary arrays compliant with the memcached text protocol.","In one embodiment, the proxy server  is an OData proxy server. The OData proxy server translates messages and data between a format compliant with the OData protocol and a format compliant with another protocol used by the data grid. This allows OData clients to communicate with the data grid.","OData is a RESTful protocol that was designed to handle access to documents such as Word Documents. OData provides an HTTP based API for storing, retrieving and managing documents. The OData proxy server uses the OData protocol for an additional function that it was not designed for. Specifically, the OData proxy server uses the OData protocol to store data in key value pairs in the data grid (a NoSQL system). The OData proxy uses the OData protocol to write to and read from a key value based storage system (i.e., the data grid). When the OData proxy receives an OData request, it translates the request into the protocol supported by the data grid node. Therefore, the OData proxy uses the OData protocol for handling storage operations on arbitrary data rather than on the documents that OData was originally designed to operate on. The OData proxy provides an OData API, and translates it into a key value based NoSQL system format. The OData proxy allows developers to use any existing OData client library as a database driver, if it is backed by a NoSQL database rather than a traditional OData document store.","OData has functionality for querying. The built in querying function takes as an input a document name and uses this as a key to search for a specified document. The OData proxy server may instead use this same query function, but takes as an input a primary key (unique identifier for an object), and returns binary data rather than a document.","In one embodiment, the proxy server  is a websocket proxy server. The websocket proxy server translates messages and data between a format compliant with the websocket protocol and a format compliant with another protocol used by the data grid. A websocket proxy server thus enables the data grid to be exposed over a websocket interface via a javascript API. This allows websocket clients to communicate with the data grid.","Websocket defines a full-duplex communication channel to a web browser, operating over a single transmission control protocol (TCP) socket, and is exposed to the browser via a javascript interface. It is designed to be used with web browsers and servers, but can be used by any type of client or server application. The websocket proxy server may be designed for javascript clients, and may be particularly suited for developers wanting to enable access to the data grid from javascript code bases.","To establish a websocket connection, a client sends a websocket handshake request, and the server sends a websocket handshake response. Once established, websocket data frames can be sent back and forth between the client and the server in full-duplex mode. Text frames can be sent in full-duplex, in either direction at the same time. The data is minimally framed with just two bytes. Each frame starts with a 0x00 byte and ends with a 0xFF byte, and contains UTF-8 data in between. In one embodiment, the websocket proxy server translates objects between UTF-8 encoded data and Java objects or JSON objects.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 3","FIG. 1"],"b":["300","300","300","125"]},"Referring to , at block  processing logic receives an object along with a request to store the object. The object may be any type of data. For example, the object may be a database record, one or more fields of a database record, an in memory data structure, or any other data. In one embodiment, the request is received by a proxy server that is configured to operate on objects and\/or requests having a particular database format. Alternatively, the request may be received by a data grid node that is configured to operate on objects and requests having a particular format. In one embodiment, at block , processing logic determines whether the object and request have a format compliant with a protocol used by a data grid. If the request and\/or object are not compliant with the protocol used by the data grid, then the method continues to block . Otherwise, the method proceeds to block . In another embodiment, block  is skipped, and the method proceeds directly from block  to block .","At block , processing logic translates the request and\/or the object into the format that complies with the protocol used by the data grid. This may include wrapping the object in a Java object or a JSON object. The processing logic may comprise a proxy server that is configured to translate all incoming messages and\/or objects received from clients from a particular database protocol or other protocol into a protocol used by the data grid. The proxy server may additionally be configured to translate messages and\/or objects received from the data grid into the particular database protocol.","At block , processing logic performs object relational mapping for a data grid on the object. In one embodiment, at block  processing logic generates key value pairs for the fields of the object. If the object included any internal objects, then additional key value pairs may be generated for the fields of the internal objects. At block , processing logic links the key value pairs. One of the key value pairs may be a primary key value pair. Linking the key value pairs may include adding references to other key value pairs in the primary key value pair. Some of the referenced key value pairs may themselves be primary key value pairs. References may also be added to additional key value pairs within the additional primary key value pairs.","At block , processing logic stores the key value pairs in a data grid, which may be a distributed data grid. In one embodiment, processing logic stores the key value pairs in a distributed cache maintained by the data grid. In one embodiment, the processing logic stores the key value pairs in persistent storage (e.g., as files in a file system). The key value pairs may be stored on multiple different data grid nodes of the data grid.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 4A","FIG. 1"],"b":["400","400","125","400","318","300"]},"Referring to , at block  processing logic generates a primary key value pair for a received object. At block , processing logic assigns a unique identifier to the object and adds the unique identifier to the primary key value pair. In one embodiment, the unique identifier is selected by a client. Alternatively, the unique identifier is selected by the processing logic (e.g., based on one or more fields of the object). In one embodiment, the key for the primary key value pair is the unique identifier.","At block , processing logic identifies a field in the object. The field may be a primitive field having a type such as a Boolean, an integer, a string, etc. Alternatively, the field may be a complex field having a type that corresponds to an internal object or an array. At block , processing logic determines whether the identified field is a complex field (e.g., is an internal object). If the field is a complex field, the method continues to block . Otherwise, the method continues to block .","At block , processing logic generates a key value pair for the field and adds a reference to the key value pair in the value portion of the primary key value pair. Therefore, the generated key value pair may be retrieved by a data grid node possessing the primary key value pair. The method then proceeds to block .","At block , processing logic repeats method  for the internal object of the complex field. This includes generating a primary key value pair for the internal object, assigning a unique identifier to the internal object, generating additional key value pairs for the internal object, and so on. A reference to the additional primary key value pair of the internal object is added into the value portion of the primary key value pair of the parent object. Therefore, the key value pairs for the internal object can be retrieved by a data grid node possessing the primary key value pair for the parent object. The method then proceeds to block .","At block , processing logic determines whether there are any additional fields in the object. If there are additional fields, then the method returns to block . Otherwise, the method ends.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 4B","b":["450","475","450","450","452","454","456","458","452","454","456","458","460","462","460","464","468","462","470","472"]},"The collection of key value pairs  includes a primary key value pair . The primary key value pair  has a key of \u201cJohn,\u201d which a data grid node can use to retrieve the primary key value pair . The primary key value pair's values are pointers to key value pairs , , , . Key value pairs , ,  were generated from fields having primitive types. Therefore, the values of these key value pairs , ,  are the contents of those fields.","Key value pair  was generated for an internal object (complex field ). Therefore, key value pair  is a primary key value pair for the internal object. Key value pair  includes pointers to key value pairs , . Each of key value pairs ,  is a primary key value pair for an additional nested object. Key value pair  includes pointers to key value pairs , . Key value pair  includes pointers to key value pairs , . Due to the pointers linking the key value pairs, a data grid node can retrieve all of the key value pairs and use them to reconstruct the object based on the unique identifier \u201cJohn.\u201d",{"@attributes":{"id":"p-0094","num":"0093"},"figref":["FIG. 5","FIG. 1"],"b":["500","500","125"]},"Referring to , at block  processing logic receives a request for a stored object. At block , processing logic determines a unique identifier for the object. In one embodiment, the unique identifier is included in the request.","At block , processing logic retrieves a primary key value pair for the object based on the unique identifier. In one embodiment, the key for the primary key value pair is the unique identifier. The values in the primary key value pair may be references to other primary key value pairs. At block , processing logic retrieves an additional key value pair for the object based on the reference to that key value pair that is included in the primary key value pair.","At block , processing logic determines whether the additional retrieved key value pair is a primary key value pair for an internal object. If the additional key value pair is a primary key value pair for an internal object, the method returns to block  and processing logic retrieves an additional key value pair that is referenced by the primary key value pair of the internal object. If the additional key value pair is not for a primary key value pair of an internal object, the method continues to block .","At block , processing logic determines whether all key value pairs for the object (and all internal objects) have been retrieved. If all key value pairs have been retrieved, the method continues to block . Otherwise, the method returns to block .","At block , processing logic reconstructs the stored object from the key value pairs. At block , processing logic then returns the object to a client from which the request was received.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 6","FIG. 1"],"b":["600","600","125"]},"Referring to , at block  processing logic receives an object and a request to store the object from a client. In one embodiment, the request is received by a proxy server that is configured to operate using a predetermined protocol. At block , the proxy server identifies a first protocol associated with the request and the object as not being compatible with a data grid on which the object is stored. However, the identified first protocol is compatible with the proxy server.","At block , the proxy server translates the request and\/or the object from the first format compliant with the first protocol to a second format compliant with a second protocol that is used by the data grid. At block , the proxy server forwards the translated request and\/or object to a node of the data grid. The node may be collocated on a machine (e.g., a JVM) with the proxy server.","At block , the data grid node stores the object in the distributed data grid. In one embodiment, the data grid node divides the object into a collection of linked key value pairs, and these key value pairs are stored in the data grid. At block , the data grid node generates a response message having the second format compliant with the second protocol. At block , the data grid node forwards the response message to the proxy server.","At block , the proxy server translates the response message into the first format compliant with the first protocol. At block , the proxy server then sends the translated response message to the client. The method then ends.",{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIG. 7","FIG. 1"],"b":["700","700","125"]},"Referring to , at block  a proxy server receives a request for a stored object from a client. At block , the proxy server identifies that the request has a first format compliant with a first protocol. At block , the proxy server translates the request from the first format compliant with the first protocol to a second format compliant with a second protocol that is used by the data grid. At block , the proxy server forwards the request to a node of the data grid.","At block , the data grid node retrieves the object having the second format. This may include retrieving a collection of key value pairs and reconstructing the object from the key value pairs. At block , the data grid node generates a response message having the second format, the response message including the object. At block , the data grid node sends the response message and object to the proxy server.","At block , the proxy server translates the response message and the object into the first format compliant with the first protocol. At block , the proxy server sends the translated response message and object to the client. The method then ends.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 8","b":"800"},"The machine may be a personal computer (PC), a tablet PC, a set-top box (STB), a Personal Digital Assistant (PDA), a cellular telephone, a web appliance, a server, a network router, a switch or bridge, or any machine capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine. Further, while only a single machine is illustrated, the term \u201cmachine\u201d shall also be taken to include any collection of machines that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein.","The exemplary computer system  includes a processing device , a main memory  (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) such as synchronous DRAM (SDRAM) or Rambus DRAM (RDRAM), etc.), a static memory  (e.g., flash memory, static random access memory (SRAM), etc.), and a data storage device , which communicate with each other via a bus .","Processing device  represents one or more general-purpose processing devices such as a microprocessor, a central processing unit, or the like. More particularly, the processing device may be complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, or processor implementing other instruction sets, or processors implementing a combination of instruction sets. Processing device  may also be one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. The processing device  is configured to execute instructions  for performing the operations and steps discussed herein.","The computer system  may further include a network interface device . The computer system  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)), an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), and a signal generation device  (e.g., a speaker).","The data storage device  may include a machine-readable storage medium  (also known as a computer-readable medium) on which is stored one or more sets of instructions or software  embodying any one or more of the methodologies or functions described herein. The instructions  may also reside, completely or at least partially, within the main memory  and\/or within the processing device  during execution thereof by the computer system , the main memory  and the processing device  also constituting machine-readable storage media.","In one embodiment, the instructions  include instructions for a data grid node and\/or for a proxy server (e.g., data grid node  and proxy server  of ) and\/or a software library containing methods that call a data grid node and\/or a proxy server. While the machine-readable storage medium  is shown in an exemplary embodiment to be a single medium, the term \u201cmachine-readable storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201cmachine-readable storage medium\u201d shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term \u201cmachine-readable storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, optical media and magnetic media.","Thus, techniques for using a shared data store for peer discovery in a peer-to-peer system are described herein. Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201cacquiring\u201d or \u201cwriting\u201d or \u201creading\u201d or \u201cjoining\u201d or \u201cquerying\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage devices.","The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, each coupled to a computer system bus.","The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct a more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","The present invention may be provided as a computer program product, or software, that may include a machine-readable medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to the present invention. A machine-readable medium includes any mechanism for storing information in a form readable by a machine (e.g., a computer). For example, a machine-readable (e.g., computer-readable) medium includes a machine (e.g., a computer) readable storage medium such as a read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media, optical storage media, flash memory devices, etc.","In the foregoing specification, embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of embodiments of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which:",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
