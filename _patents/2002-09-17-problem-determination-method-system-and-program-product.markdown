---
title: Problem determination method, system and program product
abstract: A problem determination method, system and program product are provided. Specifically, the present invention identifies problems with software programs by inserting compiled problem determination probes into program classes while the computer system on which the program is loaded is running. Once the probes have been inserted, the classes will be run and trace data will be generated. The trace data can be retrieved and analyzed to identify and address the problem. When the probes are no longer needed, they can be removed while the computer system continues to run.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07039644&OS=07039644&RS=07039644
owner: International Business Machines Corporation
number: 07039644
owner_city: Armonk
owner_country: US
publication_date: 20020917
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","BRIEF DESCRIPTION OF THE DRAWINGS","DETAIL DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","The present invention generally relates to a problem determination method, system and program product. Specifically, the present invention allows problem determination probes to be inserted into program classes of a running object-oriented runtime environment under the direction of a dynamic work flow derived from a collection of on-line knowledge bases.","2. Background Art","In the production of software, problem determination is the process of identifying the cause of either a system failure or the cause of a system not behaving as expected. Typically, problem determination results in the finding of a configuration error, an improper use of an application programming interface, a product defect, or some other root cause. There have been numerous advances in problem determination for the situation where the software is still being run on a platform under the control of the software producer. In these environments there are many successful approaches for diagnosing failure, and the approaches typically rely on the use of test cases and debugging tools to isolate problems. This type of problem determination is commonly known as \u201cdebugging.\u201d","Unfortunately, very little progress has been made in problem determination when a shipped software product has been installed in a production environment at a customer's site. Problem determination in this situation (e.g., known as troubleshooting) becomes especially difficult when a failure occurs in a customer business process that involves multiple products. This difficulty exists even if several of the products come from the same software provider. In this environment, the customer's personnel (e.g., an administrator) with access to the failing production platform (which may be multiple computers in a network running various inter-working software products) generally attempt to address the failure. However, such administrators traditionally have a poor communications channel with the product support personnel as well as an ill-defined process for reaching a successful conclusion of eliminating the failure.","One relevant characteristic in \u201ctroubleshooting\u201d is the fact that a majority of product support requests from customers are resolved without identifying a product defect. In actuality, failures more often result from misleading documentation, improper configuration, improper installation, unidentified dependencies, or the flow of work between products. Another relevant characteristic is the disjointed flow of diagnostic information between the suspected failing component and the respective service personnel by way of the customer administrator. Specifically, \u201ctroubleshooting\u201d is often accompanied by several rounds of \u201ctelephone tag\u201d intermixed with overnight shipments of large traces and dumps of data. Moreover, the service personnel are typically limited in their response to using the problem determination capabilities built into the product by its development team. These capabilities consist of the product development support originally built into the product, which often are limited to trace levels of support with a few levels of generic controls. This can lead to generation of large volumes of output and consumption of so many resources that the customer must schedule capture of the requested information in non-prime time hours.","In the past, some attempts have been made, particularly at the hardware\/micro code level, to directly connect a failing machine with its manufacturer's service personnel. This arrangement has met with much resistance from customers who view this capability as a security problem. Specifically, many customers are concerned that they are unable to control the flow of information and fear that business information may be unnecessarily disclosed during the diagnostic process. To this extent, it is not unusual for today's product service personnel to receive dumps\/traces of data from a customer's administrator in printed format with certain contained business information blacked out, or to find that the information was generated on a non-production system using non-confidential test data. Such activities not only lengthen the resolution, but also often mask the problem.","In view of the foregoing, there exists a need for an improved problem determination method, system and program product. To this extent, a need exists for an automated \u201ctroubleshooting\u201d process that smooths the flow of diagnostic information and allows the knowledge accumulated by the product service group from previous support engagements to be used in the automation scheme. A further need exists for such a problem determination scheme to be implemented while the subject computer system(s) remains running.","In general, the present invention provides a problem determination method, system and program product. Specifically, the present invention allows a distributed set of knowledge bases at vendor support sites to drive a dynamic work flow on an administrative system at a customer's site. The administrative system will utilize the results of problem determination probes inserted, executed and removed from various object-oriented execution environments of a failing customer solution to identify and address solution problems.","The present invention provides a virtual machine that includes an injection system, a class loader and a log system. Problem determination probes and associated rules are received by the injection system. The injection system then generates class recognition logic based on the rules, compiles the probes and logic into bytecode, and then stores the compiled probes, rules and compiled logic in a fragment database. The class loader will then load and\/or reload the appropriate program classes with any activated probes. Once run, the classes with the inserted probes will generate trace data to a log database, which can be retrieved and analyzed via the log system.","According to a first aspect of the present invention, a problem determination method is provided. The method comprises: (1) receiving problem determination probes and associated instructions on a computerized system; (2) activating the problem determination probes in a fragment database; (3) identifying program classes into which the problem determination probes should be inserted based on the instructions; (4) inserting the activated problem determination probes into the identified program classes while the computerized system is running; and (5) executing the program classes with the inserted problem determination probes to generate trace data.","According to a second aspect of the present invention, a problem determination system is provided. The system comprises: (1) an injection system having a storage system for storing problem determination probes and associated instructions in a fragment database, and an activation system for activating the stored problem determination probes; (2) a class loader having a query system for querying the fragment database to identify unloaded program classes into which the problem determination probes should be injected, and an insertion system for inserting the activated problem determination probes into the identified unloaded classes; and (3) a log system for accessing trace data in a log database, wherein the trace data is produced when program classes having the inserted problem determination probes are loaded and executed.","According to a third aspect of the present invention, a virtual machine for problem determination is provided. The virtual machine comprises: (1) an injection system for receiving problem determination probes and associated instructions, for generating class recognition logic based on the associated instructions, for compiling the problem determination probes and the class recognition logic into virtual instructions, for storing compiled problem determination probes, the associated instructions and the compiled class recognition logic in a fragment database, and for activating predetermined compiled problem determination probes in the fragment database; (2) a class loader for querying the fragment database to identify unloaded program classes into which the compiled problem determination probes should be injected, and for and inserting the activated problem determination probes into the identified unloaded classes; and (3) a log system for accessing trace data in a log database, wherein the trace data is produced when the unloaded program classes having the inserted problem determination probes are loaded and executed.","According to a fourth aspect of the present invention, a program product stored on a recordable medium for problem determination is provided. When executed, the program product comprises: (1) an injection system having program code for storing problem determination probes and associated instructions in a fragment database, and program code for activating the stored problem determination probes; (2) a class loader having program code for querying the fragment database to identify unloaded program classes into which the problem determination probes should be injected, and program code for inserting the activated problem determination probes into the identified unloaded classes; and (3) a log system having program code for accessing trace data in a log database, wherein the trace data is produced when program classes having the inserted problem determination probes are loaded and executed.","According to a fifth aspect of the present invention, a problem determination method is provided. The method comprises: (1) receiving problem determination probes and associated rules from a computerized support system to a computerized administrator system; (2) providing the problem determination probes and associated rules to a computer customer system from the computerized administrator system; (3) activating the problem determination probes in a fragment database of the customer system; (4) inserting the activated problem determination probes into program classes based on the instructions while the computerized customer system is running; and (5) executing the program classes with the inserted problem determination probes to generate trace data.","Therefore, the present invention provides a problem determination method, system and program product.","These and other features of this invention will be more readily understood from the following detailed description of the various aspects of the invention taken in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},"The drawings are merely schematic representations, not intended to portray specific parameters of the invention. The drawings are intended to depict only typical embodiments of the invention, and therefore should not be considered as limiting the scope of the invention. In the drawings, like numbering represents like elements.","For clarity purposes, the Detailed Description of the Invention will have the following sections:","I. Background",{"@attributes":{"id":"p-0026","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["A. Aspect-Oriented Programming","B. Aspect-Oriented Debugging"]}}}},"II. Present Invention","I. Background","A. Aspect-Oriented Programming","When using standard procedural or Object-Oriented programming (OOP) languages it can be difficult to modularize design concerns such as error-checking, synchronization policies, resource sharing, etc. Not only do these types of concerns tend to affect multiple modules, but because of the way they cross module boundaries it could be stated that they crosscut the program structure. Aspect-Oriented programming (AOP) is a methodology developed for the modularization of crosscutting concerns","\u201cAspects\u201d are units of software modularity that cleanly encapsulate crosscutting concerns. That is, \u201caspects\u201d make the structure of the crosscutting concerns more clear and easy to reason. \u201cAspects\u201d also make the interaction between the crosscutting concerns and the primary modularity clear. One of the best know implementations of AOP for the JAVA environment is known as \u201cAspectJ.\u201d In it's current form, \u201cAspectJ\u201d allows fragments of JAVA code to be inserted into methods of JAVA classes at the source code level using a pattern specification.","One commonly used debug technique, especially in Object-Oriented systems where it is often not clear to a developer what the overall system flow looks like, is to insert print statements into the source code. In the International Business Machines Corp. Developer Works article entitled \u201cAspectJ brings AOP to the Java language\u201d (found on the web at www106.ibm.com\/developerworks\/JAVA\/library\/j-aspectj\/index.html), AOP and \u201cAspectJ\u201d are introduced by showing just such an example which is summarized in the following code:",{"@attributes":{"id":"p-0032","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ from package test"},{"entry":"Public Class Logging{"},{"entry":"\u2003public void foo( ){}"},{"entry":"public static void main(String[ ] args){"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Logging ap = new Logging( );"]},{"entry":[{},"Ap.foo( ); }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public aspect AutoLog{"},{"entry":"pointcut publicMethods( ) : execution(public * test..*(..));"},{"entry":"pointcut logObjectCalls( ) : execution(* Logger.*(..));"},{"entry":"pointcut loggableCalls( ) : publicMethods( ) && ! logObjectCalls( );"},{"entry":"\u2002before( ) : loggableCalls( ){"},{"entry":"\u2003Logger.entry(thisJoinPoint.getSignature( ).toString( ));"},{"entry":"\u2002}"},{"entry":"\u2002after( ) : loggableCalls( ){"},{"entry":"\u2003Logger.exit(thisJoinPoint.getSignature( ).toString( ));"},{"entry":"\u2002}"},{"entry":"}"},{"entry":"Class Logger{"},{"entry":"\u2003public static void entry(String message){"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"System.out.println(\u2033entering method: \u2033 + message);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003public static void exit(String message){"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"System.out.println(\u2033exiting method: \u2033 + message);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2009}"},{"entry":"entering method: void test.Logging.main(String[ ])"},{"entry":"entering method: void test.Logging.foo( )"},{"entry":"exiting method: void test.Logging.foo( )"},{"entry":"exiting method: void test.Logging.main(String[ ])"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"From the above code it can be seen that an AOP environment can significantly enhance debugging by providing an easy way of inserting and then removing probes (e.g., sets of print statements) into the objects of a system to generate a flow trace. Unfortunately, \u201cAspectJ\u201d relies on the availability of full source code and a build environment. As such, it can be used in only a small subset of problem determination situations.","B. Aspect-Oriented Debugging","Recently, an AOP instrumentation tool has been introduced that allow \u201caspects\u201d to be applied to test environments where neither the full source code of the product being debugged nor a full product build environment is available. Referring now to , such a tool is shown. In general, system  allows developer service personnel to take control of a customer's system to insert and remove probes (e.g., sets of print statements) into the code. Specifically, probes and rules  are received by injection tool . Once received, the probes are compiled by compiler  into bytecode, which are inserted into the binary files of product library . Specifically, the compiled probes are inserted into the appropriate classes A\u2013C by injection tool , as designated by the rules while Java Virtual Machine (JVM)  is shut down. As shown in , probes were inserted only into class A, which was saved as a new binary file  in probe library  of classpath . When JVM  is restarted, class loader  will instantiate the product using the modified class  and classes B\u2013C. When the test is complete, JVM  must be shut down to remove the probes and then restarted. As is apparent, both insertion and removal of the probes requires rebooting the JVM . Such a requirement is both inconvenient to the customer and inefficient for the service personnel.","II. Present Invention","The present invention addresses the issues with related art systems by providing a scheme for inserting problem determination probes into program classes while the subject system is running. Specifically, under the present invention, the problem determination probes are injected into the runtime of an object-oriented execution environment of a customer's system that interprets and\/or incrementally compiles an intermediate virtualized instruction representation of that environment's object logic. One example of such an environment is JAVA where the intermediate virtual instructions resulting from compilation of source instructions are known as \u201cbytecodes,\u201d which at run-time are loaded into a Java Virtual Machine (JVM) by a class loader. Once loaded, the bytecodes are directly interpreted and\/or incrementally compiled by a just-in-time (JIT) compiler into native code for execution. It should be understood, however, that although JAVA terminology will be used in the following description, the teachings described herein could be applied in any environment.","Referring to , computerized customer system  according to the present invention is shown. Customer system  is intended to be representative of a computer system running a program  that malfunctions or fails to perform as expected. As depicted, customer system  generally includes central processing unit (CPU) , memory , bus , input\/output (I\/O) interfaces , external devices\/resources , fragment database  and log database . CPU  may comprise a single processing unit, or be distributed across one or more processing units in one or more locations, e.g., on a client and server. Memory  may comprise any known type of data storage and\/or transmission media, including magnetic media, optical media, random access memory (RAM), read-only memory (ROM), a data cache, a data object, etc. Moreover, similar to CPU , memory  may reside at a single physical location, comprising one or more types of data storage, or be distributed across a plurality of physical systems in various forms. I\/O interfaces  may comprise any system for exchanging information to\/from an external source. External devices\/resources  may comprise any known type of external device, including speakers, a CRT, LED screen, hand-held device, keyboard, mouse, voice recognition system, speech output system, printer, monitor, facsimile, pager, etc. Bus  provides a communication link between each of the components in customer system  and likewise may comprise any known type of transmission link, including electrical, optical, wireless, etc. In addition, although not shown, additional components, such as cache memory, communication systems, system software, etc., may be incorporated into customer system .","Fragment database  and log database  may provide storage for information necessary to carry out the present invention. Such information could include, among other things, probes, class recognition logic and rules for fragment database , and trace data for log database . As such, databases  and  may include one or more storage devices, such as a magnetic disk drive or an optical disk drive. In another embodiment, databases  and  includes data distributed across, for example, a local area network (LAN), wide area network (WAN) or a storage area network (SAN) (not shown). Databases  and  may also be configured in such a way that one of ordinary skill in the art may interpret it to include one or more storage devices. It should be understood customer system  is intended to be representative of any type of computerized system. Examples include a server, a client, a workstation, a laptop, a personal digital assistant, etc.","Stored in memory  of customer system  is virtual machine  (i.e., a JAVA Virtual Machine) and product library . Virtual machine  will be further described below in conjunction with , but in general, virtual machine  includes systems for receiving and inserting probes into particular program classes and creating trace data for analysis while customer system  remains running. It should be understood that as known in the art, a virtual machine is software that acts as an interface between binary code and the microprocessor. It should be further understood that product library  is typically contained within a classpath (not shown in ). Moreover, product library  is shown loaded in memory  for illustrative purposes only and other variations exist. For example, product library  and the classpath could be stored external to customer system  and accessed as needed.","As further shown in , customer system  communicates with computerized administrator system , which communicates with computerized support system . Administrator system  is intended to be representative of a customer's administrator who is troubleshooting a problem with software program  loaded on customer system . Support system  is intended to be representative of the developer of the malfunctioning software program who can be consulted by administrator system . Typically, administrator system  will provide probes and rules to customer system . Such probes, rules and other information could be made available to administrator system  by support system  based on historical data and experiences. Although not shown, it should also be appreciated that administrator system  and support system  include computerized components similar to customer system . Such components have not been shown for brevity purposes only.","Communication among customer system , administrator system  and support system  occurs via communications links . Communications links  are intended to represent any possible method of communication. For example, communication could occur via a direct hardwired connection (e.g., serial port), or via an addressable connection (e.g., remotely) in a client-server (or server-server) environment. In the case of the latter, the server and client may be connected via the Internet, wide area networks (WAN), local area networks (LAN) or other private networks. The server and client may utilize conventional network connectivity, such as Token Ring, Ethernet, or other conventional communications standards. Where the client communicates with the server via the Internet, connectivity could be provided by conventional TCP\/IP sockets-based protocol. In this instance, the client would utilize an Internet service provider to establish connectivity to the server. Typically, customer system  and administrator system  are part of the same private network (LAN, WAN, VPN, etc.), while support system  is external to that network and is accessed via the Internet. Moreover, it should be appreciated that customer system , administrator system  and support system  could each include more than one computer system.","Referring now to , an exemplary embodiment of virtual machine  is shown. As depicted, virtual machine  includes Aspect-Oriented enabled class loader (module) , injection system\/module  and log system\/module . As will be further described below, injection system  and log system  generally include interfaces for issuing requests and retrieving trace data. Specifically, when a problem with program  is suspected (e.g., based on the knowledge base provided in the support system  augmentation of the dynamic problem determination work flow executing in the administration system ), a \u201cdefine\u201d request is issued via command system  of injection system  (e.g. by administrator system  or some other entity). Typically, the \u201cdefine\u201d request includes probes and associated instructions  that are received by command system  for processing. In general, each probe includes one or more probe points that are inserted into methods within one or more product classes , . A typical type of probe point is a print statement that will cause some form of trace data to be printed to log database . The associated rules indicate into which methods and classes the probes are to be inserted. For example, a rule could indicate that a probe is to be inserted into any class having \u201cABC\u201d in its name, and has a method that has the string \u201cset\u201d in its name, and takes a parameter of a \u201cwidget.\u201d Thus the rules associate the probes with specific classes. Once the rules and probes have been received, logic system  will generate class recognition logic based on the rules. The class recognition logic will aid in identifying classes that have already been loaded but need to have the probes inserted (as will be further described below). In general, the logic is generated by parsing the rules to create a list of patterns that match all of the specific classes that require the probes and converting this into source code that, when compiled, may be executed by class loader .","Once the class recognition logic has been generated, compilation system (compiler)  will compile the probes and logic into virtual instructions (i.e., bytecode). Because the probes are compiled prior to insertion, the source code does not need to be recompiled after insertion. Accordingly, the full source code is not needed under the present invention to test individual pieces of program . Once the probes and logic have been compiled into virtual instructions (bytecode), they will be stored in fragment database  along with the rules. The compiled probes (i.e., probe fragments) will then be inserted into the classes identified by the associated rules. Specifically, particular probes will be activated (e.g., by an administrator) in fragment database  via command system . As class loader  is preparing to load classes  and  from product library , query system  will query fragment database  to determine if any stored probes have been activated for insertion. If so, insertion system  will insert the probes into the corresponding classes (as determined by the logic and rules in fragment database ).","In addition to inserting probes into previously unloaded classes, the present invention provides the capability to insert probes into classes that have already been loaded. Specifically, logic system  will retrieve the class recognition logic from fragment database  and communicate the same to class loader . The class recognition logic typically includes a list of classes that need to have probes inserted. Class loader  will review the list and determine whether any classes that have already been loaded without probes match any of the classes on the list. If so, class loader  will unload and reload the classes while inserting the appropriate probes. For example, if class  has already been loaded when the probes are activated, class  will be unloaded and then reloaded with the activated probes.","Once the probes have been loaded in the appropriate classes, the classes\/program will be run\/executed. As indicated above, each probe typically includes one or more print statements dictating that some form of trace data to be printed to log database . However, it should be understood that many types of probes and\/or combinations of probes could be implemented hereunder, and the present invention is not limited to the use of print statement types of probes. For example, a probe could add context or identifying (e.g., troubleshooting) information (e.g., thread id., web request details, etc.) to a database connection when it is acquired\/created. The context information will be flowed across the connection when requests are made to the database (i.e., over the connection). This allows the probes on the database \u201cside\u201d to provide valuable context\/correlation information. To this extent, the present invention could insert probe combinations (e.g. a probe on the application server \u201cside\u201d and a probe on the database server \u201cside,\u201d that operate in conjunction with each other) and different types of probes (e.g., probes that consist of print statements as well as probes that consist of statements that add troubleshooting information) to provide effective problem determination of a system.","As further depicted in , when run, class  communicated trace data to log system , which in turn indexed the trace data in log database . The trace data  could then be retrieved for analysis from log database  via log system . Once the testing is complete, the probes could be deactivated via command system , and then removed along with the associated rules, class recognition logic and trace data. Removal generally occurs with a \u201cremoval\u201d request issued via command system . All of these steps, receipt, insertion and removal of probes as well as review\/removal of trace data are performed while virtual machine  and customer system  continue to run. That is, shutdown and reboot of either virtual machine  or customer system  is not necessary.","Under the present invention, all requests to the injection system  could contain a Globally Unique IDentifier (GUID), which is used to manage fragments (e.g., compiled probes and\/or compiled logic) and to identify messages\/trace data generated by the inserted probes and left in log database . The GUID is specified as a reserved substitution symbol in a preamble of the source aspect definition and, hence, like other substitution symbols (the use of which will be further describe below) can be used in the actual JAVA source code fragment (probes). Under the present invention, injection system  supports four basic requests\/operations (define, activate, deactivate, remove), which were generally described above. During the \u201cdefine\u201d operation, the probes and associated rules are provided containing a GUID. After logic generation, and compilation, the rules, probes and logic are indexed in fragment database  according to GUID. As indicated above, the rules allow the specification of a \u201cclass.method\u201d string with a match any single or multiple character place holders (our examples will use \u201c?\u201d for match single and \u201c*\u201d for match multiple for example \u201c*.zip.crc*.get*\u201d would match \u201cJAVA.util.zip.crc32.getValue\u201d) and indicate the relative placement of the fragment (e.g., \u201cafter=*.zip.crc*.get*\u201d). There are several existing database methods for efficiently indexing an entity by a pattern such that presentation of a string will retrieve the entities with a matching pattern, any of which may be implemented under the present invention here. One final step in the define stage paves the way for subsequent operation of the activate\/deactivate requests by compiling the class portion of the patterns into a recognizor method (class recognition logic) which is also stored in fragment database .","The \u201cactivate\u201d request accepts a GUID and moves the respective rules into the online index, it then passes the class recognition logic (last step of define) to class loader  which invalidates the code of any previously loaded classes that match the recognizor and reloads these. When reloading (or loading for the first time) class loader  performs a merge of the bytecodes found in the respective class from the respective product library  in the class path with all fragments found from a fragment database  query on the respective \u2018class.method\u2019 in the online index being operated on.","During activation, various issued could be addressed. For example, the previously loaded bytecode could be locked so that the code is clear of actively executing threads when the replacement of the bytecode occurs. Moreover, it should also be ensured that the invariants on inter-invocation object state don't change or become violated. It should also be verified that the inserted probe code does not add instance variables.","When issued, the \u201cdeactivate\u201d request accepts a GUID and moves the respective rules to the off-line index and passes the class recognition logic to the class loader  causing the respective fragments to be removed by way of a reload of matching in-memory class code. The \u201cremove\u201d request forces a \u201cdeactivate\u201d and then purges the fragment database  of all entries with the corresponding GUID.","There may be certain restrictions on the kind of code that can appear in the probes since it must be possible to activate\/deactivate the probes without impacting the data associated with instances of the respective class that may be active at the time of the respective request. When the present invention is used to patch problems (described in further detail below), the GUID of the respective aspect definition becomes the handle by which the patch is removed by the service pack installer. In this case the service pack contains a list of GUIDs corresponding to patches for which the distributed code contains a permanent fix.","As indicated above, log system  provides a standard way of retrieving and purging the results of probes inserted into a platform. When possible, log system  uses the underlying logging facilities which may be present in a given implementation such as that provided by the standard JAVA class libraries of recent JAVA versions. Under the present invention, a probe log method is provided, which exposes specific parameters that a probe (fragment) must supply, such that there is uniformity in the information flow. These include the GUID of the probe, and a short message identification to facilitate results checking. The method also captures the time\/date at which it is called as well as the \u201cclass.method\u201d of the fragment making the request. Log system  allows all messages created by the above method to be retrieved using the corresponding GUID in conjunction with an optional range of time stamps and\/or message identifications. It also allows all messages corresponding to a given GUID with an optional range of time stamps and or message identifications to be purged from the underlying log database .","Referring now to , a more detailed diagram of the interaction between customer system , administrator system  and support system  is shown. It should be noted that not all components of systems ,  and  have been shown for brevity purposes. For example, class loader  and databases  and  have not been shown for customer system , but should be recognized to exist. , among other things, demonstrates that a single administrator system  could communicate with one or more customer systems  and support systems . In general, when a program on customer system  malfunctions, a customer administrator (not shown) using an administrator system  will attempt to identify and solve the problem. As indicated above, this could involve injecting probes and reviewing trace data. However, administrator system  also has the option to consult with support system , which has one or more knowledge bases of work flows, problem determination probes, instructions and\/or patches for implementation on customer system . For example, if a particular problem is being experienced by customer system , consultation system  could be used to obtain a work flow from flow system  of support system . The work flow could designate a series of steps or actions that should be taken to identify and address the problem. To this extent, the work flow could identify a set of probes that should be inserted for testing the program. Once the work flow is established, probe macro system  could be used to provide the actual probes and rules to administrator system  for implementation on customer system . As described above, the probes and rules would be fed to injection system  by probe system  and then inserted into the appropriate classes as bytecode. Once the classes are run with the probes inserted, and trace data is generated, result system  would access log system  to retrieve and analyze the data. To this extent, consultation system  could be further used to share the retrieved data to seek advice from support system .","In the event a specific problem is identified, support system  may have a patch for temporarily correcting the problem. In this case, patch macro system  could communicate the patch to administrator system , which would implement the patch in the same manner that probes were inserted. Specifically, the patch and rules would be received by injection system . Class recognition logic could be generated based on the rules, and then the logic and patch would be compiled into bytecode. The patch bytecode would then be inserted into the appropriate classes identified by the rules\/logic.","Referring now to , a method flow diagram  according to the present invention is shown. As depicted, first step  is to receive problem determination probes and associated instructions on a computerized system for storage in a fragment database. Second step  is to activate the problem determination probes in the fragment database. Third step  is to identify program classes into which the problem determination probes should be inserted based on the instructions. Fourth step  is to insert the activated problem determination probes into the identified program classes while the computerized system is running. Fifth step  is to execute the program classes with the inserted problem determination probes to generate trace data.","It is understood that the present invention can be realized in hardware, software, or a combination of hardware and software. Any kind of computer\/server system(s)\u2014or other apparatus adapted for carrying out the methods described herein\u2014is suited. A typical combination of hardware and software could be a general purpose computer system with a computer program that, when loaded and executed, controls customer system  such that it carries out the methods described herein. Alternatively, a specific use computer, containing specialized hardware for carrying out one or more of the functional tasks of the invention could be utilized. The present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which\u2014when loaded in a computer system\u2014is able to carry out these methods. Computer program, software program, program, or software, in the present context mean any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following: (a) conversion to another language, code or notation; and\/or (b) reproduction in a different material form.","The foregoing description of the preferred embodiments of this invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed, and obviously, many modifications and variations are possible. Such modifications and variations that may be apparent to a person skilled in the art are intended to be included within the scope of this invention as defined by the accompanying claims."],"DETDESC":[{},{}]}
