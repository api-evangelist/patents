---
title: Distributed object storage system
abstract: The invention concerns a distributed object storage system () comprising a maintenance agent () instructing an encoding module () to disassemble a repair data object into a specific number of repair sub blocks, this specific number being equal to or greater than said number of missing sub blocks and less then the predetermined number of sub blocks during a regular storage operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08386840&OS=08386840&RS=08386840
owner: Amplidata NV
number: 08386840
owner_city: Lochristi
owner_country: BE
publication_date: 20111028
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENT(S)"],"p":["The present invention generally relates a distributed data storage systems. Typically, such distributed storage systems are targeted at storing large amounts of data, such as objects or files in a distributed and fault tolerant manner with a predetermined level of redundancy. The present invention relates more particularly to a distributed object storage system.","The advantages of object storage systems, which store data objects referenced by an object identifier versus file systems, such as for example US2002\/0078244, which store files referenced by an inode or block based systems which store data blocks referenced by a block address in terms of scalability and flexibility are well known. Object storage systems in this way are able to surpass the maximum limits for storage capacity of file systems in a flexible way such that for example storage capacity can be added or removed in function of the needs, without degrading its performance as the system grows. This makes such object storage systems excellent candidates for large scale storage systems.","Such large scale storage systems are required to distribute the stored data objects in the object storage system over multiple storage elements, such as for example hard disks, or multiple components such as storage nodes comprising a plurality of such storage elements. However as the number of storage elements in such a distributed object storage system increase, equally the probability of failure of one or more of these storage elements increases. To cope therewith it is required to introduce a level of redundancy into the distributed object storage system. This means that the distributed object storage system must be able to cope with a failure of one or more storage elements without data loss. In its simplest form redundancy is achieved by replication, this means storing multiple copies of a data object on multiple storage elements of the distributed object storage system. In this way when one of the storage elements storing a copy of the data object fails, this data object can still be recovered from another storage element holding a copy. Several schemes for replication are known in the art, in general replication is costly as the storage capacity is concerned. This means that in order to survive two concurrent failures of a storage element of a distributed object storage system, at least two replica copies for each data object are required, which results in storage capacity overhead of 200%, which means that for storing 1 GB of data objects a storage capacity of 3 GB is required. Another well-known scheme is referred to as RAID systems of which some implementations are more efficient than replication as storage capacity overhead is concerned. However, often RAID systems require a form of synchronisation of the different storage elements and require them to be of the same type and in the case of drive failure require immediate replacement, followed by a costly and time consuming rebuild process. Therefor known systems based on replication or known RAID systems are generally not configured to survive more than two concurrent storage element failures. Therefor it has been proposed to use distributed object storage systems that are based on erasure encoding, such as for example described in WO2009135630 or US2007\/0136525. Such a distributed object storage system stores the data object in encoded sub blocks that are spread amongst the storage elements in such a way that for example a concurrent failure of six storage elements can be tolerated with a corresponding storage overhead of 60%, that means that 1 GB of data objects only require a storage capacity of 1.6 GB.","Such an erasure encoding based districted object storage system for large scale data storage also requires a form a self-healing functionality in order to restore the required redundancy policy after for example the failure of a storage element. However most in known systems these self-healing methods lack efficiency and consume considerable amounts of processing power and\/or network bandwidth in order for example to cope with restoring the redundancy for the stored data objects on a failed storage element. One system that tries to improve efficiency is for example described in WO2010\/091101, however this system could result to data loss after subsequent generations of node failure. Furthermore this system is only able to handle the restore of a complete storage element and is not able to handle a more fine grained restore for example of a single data object.","Therefor there still exists a need for an efficient and reliable monitoring and repair process for a distributed object storage system, that does not result in data loss in the long term and is able to realize a large scale, self-healing distributed object storage system.","According to a first aspect of the invention, there is provided a distributed object storage system comprising:\n\n","characterized in that","the distributed object storage system further comprises a maintenance agent, operably connected to said controller node when repairing said repair data object, and operable to perform the following steps when executing said repair task:\n\n","This enables a distributed object storage system with a self-healing function that does not compromise consistency of the data objects stored, not even on a very large storage capacity scale and in a long term time scale. It does this in a way that requires less computing resources and less network bandwidth then any prior art system while not compromising efficiency in implementing a redundancy policy. The repair agent is in no way required to identify which sub blocks are missing. It is sufficient to determine how many of the sub blocks of a stored data object are missing. This assessment requires only minimal computing and memory resources. Furthermore although reuse can be made of the components of the erasure encoding system like the encoding module or the spreading module a tailored repair retrieval and repair storage operation is available and in this way allows for a specific configuration which is focussed on an efficient repair process without compromising the general retrieval and storage operations.","According to an advantageous embodiment of the invention, said specific number is equal to said number of missing sub blocks augmented by a safety margin.","In this way it is possible to preventively deal with the probability of future repair requirements, while still being more efficient then the regular retrieval and storage operations in the context of a repair operation.","According to an alternative embodiment of the invention, said safety margin is equal to zero.","Although sacrificing preventive action to deal with the probability of future repair requirements, this embodiment results in the most efficient repair operation possible.","According to an embodiment of the invention, said distributed storage system further comprises a metadata storage, said encoding module and\/or said spreading module adding to said metadata storage and wherein metadata for said data object stored comprises: said data object identifier; a list of identifiers of the storage elements on which sub blocks of said data object are stored; and an identifier for the type of encoding that was used to disassemble said data object.","This allows to further increase efficiency of the repair storage and repair retrieval operations.","According to an embodiment of the invention said controller node comprises a central metadata storage. The modules for the erasure encoding\/decoding functionality such as for example the encoding module, decoding module, clustering module or the spreading module also preferably residing in the controller node in this way are able to access the metadata in the most efficient manner.","According to a specific embodiment said spreading module is operable to add to said central metadata storage said metadata for each data object stored by said controller node, such that the metadata is conveniently update during as well regular storage operations as repair storage operations of a data object.","According to an advantageous embodiment of the invention said plurality of storage nodes, each comprise a local metadata storage, said spreading module adding to said respective local metadata storage, and said metadata for each data object being stored in said corresponding storage node.","In this way it is assured by means of very simple means that the metadata corresponding to a specific data object is stored in the distributed object storage system according to the requirements of the same redundancy policy as this data object is subject to. If for example the data object is required to be stored such that a concurrent failure of 5 storage nodes can be coped with, its associated metadata will also be stored such that this requirement is fulfilled. It is clear that it is not required to encode the metadata to achieve this, it results merely from replicating the metadata for a specific data object locally on as many storage nodes as this specific data object is being stored.","According to a preferred embodiment of the invention, said metadata further comprises a version number that is incremented every time said data object is stored by said spreading module. This allows, especially in the context of a plurality of redundant central and\/or local meta data storage facilities to check consistency of the metadata, for example in the case of conflicting metadata in two or more meta data storages.","Optionally, according to a preferred embodiment, said controller node retrieves said metadata from said local metadata storages and adds the metadata for each data object comprising the highest version number to said central metadata storage.","When the controller node is replaced or when the central metadata gets corrupt, the central metadata storage can be restored in this way. Alternatively this also allows for dynamically keeping the central metadata storage consistent with the real world state of the distributed object storage system as reported by the local metadata storage of the storage nodes, which greatly improves long term robustness of the distributes object storage system.","According to an embodiment of the invention, said controller node is operable to consult said metadata storage to determine on which storage elements said sub blocks of said data object can be retrieved. According to first alternative said consultation is a consultation of said central metadata storage, which allows for efficiency. According to a further alternative said consultation is a federated search of one or more of said local metadata storages, which allows for additional robustness as the distributed object storage system can remain operational even if the central metadata storage is not available. Optionally, during said federated search said controller node retrieves said metadata of said local metadata storages that are consulted and adds said metadata for each data object comprising the highest version number to said central metadata storage, which allows to dynamically rebuild or repair a central metadata storage during the federated search operation.","According to an embodiment of the invention, said monitoring agent is operable to monitor availability of said data object by:\n\n","In this way monitoring the health of the distributed object storage system is possible on every desired scale, down to the level of a single stored data object.","According to an alternative embodiment of the invention said monitoring agent is operable to monitor availability of said data object by:\n\n","This embodiment enables to efficiently handle such an event as a storage element or an entire storage node in need of repair.","According to still a further alternative embodiment of the invention said monitoring agent is operable to monitor availability of said data object by:\n\n","Preferably said maintenance agent, when instructing said clustering module to retrieve said predetermined number of sub blocks comprising said repair data object identifier, is operable to further instruct said clustering module to consult said central infrastructure database, said clustering module subsequently retrieving a number of stored sub blocks equal to or greater then said predetermined multiple of said minimal spreading requirement exclusively from said storage elements for which the status in said infrastructure metadata indicates availability.","Alternatively said monitoring agent is operable to provide said repair data object identifier if at least one of said redundant sub blocks is stored on a storage element of which the infrastructure metadata indicates it is unavailable by combining both the metadata of said data object and the infrastructure metadata of said storage elements.","The storage infrastructure metadata enables efficiency, specifically in large scale repair process involving for example at least one complete storage element or one or more storage nodes. As a further advantage this allows to further increase the efficiency of the repair retrieval operation and alternatively allows for a centrally managed monitoring process that only needs to process metadata and thus does not require any storage or retrieval operations with regards to the data objects.","According to a preferred embodiment of the distributed object storage system according to invention:\n\n","This provides the monitoring agent with an efficient and simple mechanism of additionally monitoring the health of a stored data object on the sub block level.","According to a further embodiment of the invention, said distributed storage system further comprises a garbage collection agent, operably connected to said storage nodes when performing a garbage collection operation, and operable to perform the following steps during a garbage collection operation:\n\n","According to a specific embodiment, said verification indicates that said corresponding data object is not stored in said distributed object storage system if said object identifier is not present in said metadata storage.","The garbage collection operation still further increases the level of long term robustness of the distributed object storage system of the invention as it enables such a large scale storage system to reclaim the storage capacity occupied by deprecated data.","According to a second aspect of the invention, there is provided a method for maintaining a distributed object storage system according to the first aspect of the invention,","characterized in that said method comprises the following steps when executing said repair task:\n\n",{"@attributes":{"id":"p-0050","num":"0093"},"figref":["FIG. 1","FIG. 1"],"b":["1","10","1","10","1","20","30","1","30","40","20","30","10"]},"According to alternative embodiments of the distributed object storage system could comprise any other suitable number of storage nodes  and for example two three or more controller nodes  also connected to these storage nodes . These controller nodes  and storage nodes  can be built as general purpose computers, however more frequently they are physically adapted for arrangement in large data centres, where they are arranged in modular racks  comprising standard dimensions. Particular controller nodes  and storage nodes , such as for example the Amplistor AS20 storage node as manufactured by Amplidata, are dimensioned to take up a single unit of such rack , which is generally referred to as 1U.","As shown in  several storage nodes  can be grouped together, for example because they are housed in a single rack . For example storage nodes .-.; .-.; . . . ; and .-. each are respectively grouped into racks ., ., . . . .. Controller node  could for example be located in rack .. These racks are not required to be located at the same location, they are often geographically dispersed across different data centres, such as for example rack .-. can be located at a data centre in Europe, .-. at a data centre in the USA and .-. at a data centre in China.",{"@attributes":{"id":"p-0053","num":"0096"},"figref":["FIG. 2","FIG. 2","FIG. 1"],"b":["30","30","1","310","320","330","340","350","360","370","300","1","300","10","310","30","1","320","330","320","320","340","30","1","350","360","30","1","30","20","370","310","300","300","30","1","300","1","300","10","30","1","1","30","2","30","40","30","1","1"]},"Taking into account  the distributed object storage system  comprises a plurality of redundant storage elements . The storage nodes  each comprise a share of these storage elements . As shown in  storage node . comprises ten storage elements .-.. Other storage nodes  could comprise a similar amount of storage elements, but this is however not essential. Storage node . could for example comprise eight storage elements .-.. As will be explained in further detail below with respect to , the distributed object storages system  is operable to store and retrieve a data object  comprising data , for example 64 MB of binary data and a data object identifier  for addressing this data object , for example a universally unique identifier such as a globally unique identifier (GUID). Storing the data offered for storage by the application  in the form of a data object, also referred to as object storage, has specific advantages over other storage schemes such as conventional block based storage or conventional file based storage, such as scalability and flexibility, which are of particular importance in a distributed object storage system  that is directed to large scale redundant storage applications, sometimes also referred to as cloud storage.","The storage elements  are redundant and operate independently of one another. This means that if one particular storage element  fails its function can easily be taken on by another storage element  in the distributed storage system. However as will be explained in more detail further below, there is no need for the storage elements  to work in synchronism, as is for example the case in many well-known RAID configurations, which sometimes even require disc spindle rotation to be synchronised. Furthermore the independent and redundant operation of the storage elements  allows to use any suitable mix of types storage elements  to be used in a particular distributed object storage system . It is possible to use for example storage elements with differing storage capacity, storage elements of differing manufacturers, using different hardware technology such as for example conventional hard disks and solid state storage elements, using different storage interfaces such as for example different revisions of SATA, PATA and so on. All this results in specific advantages for scalability and flexibility of the distributed object storage system  as it allows to add or remove storage elements  without imposing specific requirements to their design in correlation to other storage elements  already in use in that distributed object storage system .",{"@attributes":{"id":"p-0056","num":"0099"},"figref":"FIG. 3","b":["20","20","210","220","230","240","250","210","20","220","230","220","320","240","20","250","260","20","30","20"]},"According to an alternative embodiment the controller node  could have an identical design as a storage node , or according to still a further alternative embodiment one of the storage nodes  of the distributed object storage system could perform both the function of a controller node  and a storage node . According to still a further embodiment the device on which the application  runs is a controller node .","As schematically shown in , controller node  comprises four modules: an encoding module ; a spreading module ; a clustering module ; and a decoding module . These modules , , ,  can be implemented as programming instructions stored in local memory  of the controller node  for execution by its processor .","The functioning of these modules , , ,  will now be explained to . The distributed object storage system  stores a data object  offered by the application  in function of a reliability policy which guarantees a level of redundancy. That means that the distributed object storage system  must for example guarantee that it will be able to correctly retrieve  even if a number of storage elements  would be unavailable, for example because they are damaged or inaccessible. Such a reliability policy could for example require the distributed object storage system  to be able to retrieve the data object  in case of six concurrent failures of the storage elements  it comprises. In large scale data storage massive amounts of data are stored on storage elements  that are individually unreliable, as such redundancy must be introduced into the storage system to improve reliability. However the most commonly used form of redundancy, straightforward replication of the data on multiple storage elements  is only able to achieve acceptable levels of reliability at the cost of unacceptable levels of overhead. For example, in order to achieve sufficient redundancy to cope with six concurrent failures of storage elements , data objects  would need to be replicated six times and stored on redundant storage elements . This means that next to the master copy of a data object  stored on one storage element , six replica's must be stored on six other storage elements. As such storing 1 GB of data objects in this way would result in the need of 7 GB of storage capacity in a distributed object storage system, this means an increase in the storage cost by a factor of seven or an additional storage overhead of 600%. Therefor the distributed object storage system  according to the invention makes use of erasure coding techniques in order to achieve the requirements of the reliability policy with considerably less overhead. As will be explained in further detail below when using an erasure encoding with a rate of encoding r=10\/16 six concurrent failures of storage element  can be tolerated, which only require a storage overhead of 60% or a storage cost by a factor of 1.6. This means that storing 1 GB of data objects in this way only results in the need of 1.6 GB of storage capacity in the distributed object storage system . Some erasure encoding techniques make use of Reed-Solomon codes, but also fountain codes or rateless erasure codes such as online codes, LDPC codes, raptor codes and numerous other coding schemes are available.",{"@attributes":{"id":"p-0060","num":"0103"},"figref":"FIG. 5","b":["1","300","500","1","10","500","510","520","500","400","20","400","500","600","510","300","600","500","300","600","500","400","600","1","600","12800","600","600","1","500","600","1","600","1","1","500","600","400","400","500","600","1","600","12800","1","12800","600","600","1","600","12800","500","600","600","1","600","4000","600","8001","600","12000","1","500"]},"Subsequently, as shown in , the spreading module  will store the predetermined number x*n=800*16=12800 of encoded redundant sub blocks .-. on a number of storage elements  which corresponds to said desired spreading width n=16, such as for example storage elements .-.. The spreading module  will store on each of these storage elements .-. said predetermined multiple x=800 of these sub blocks . As shown in  sub blocks .-. are stored on storage element ., the next x=800 of these sub blocks are stored on storage element . and so on until the last x=800 of these sub blocks - are stored on storage element .. As shown in  storage elements .-. are arranged in storage node . and storage elements .-. are arranged in storage node ..","According to an alternative embodiment the sub blocks could be spread by the spreading module  on a number of storage elements  which is larger than said desired spreading width n=16, for example n+1=16+1=17 storage elements . This could be implemented by for example storing sub blocks .-. on storage element . and storing sub blocks .- on storage element .. It is clear that this would still allow for the storage system  to cope with f=6 concurrent failures of storage elements . Alternative methods for determining the share of sub blocks to be stored on specific storage elements  are well known to the person skilled in the art and are for example described in WO2009135630.","It is clear that according to alternative embodiments of the invention other values could have been chosen for the parameters x, f, k, n=k+f and r=k\/n mentioned in embodiment above, such as for example x=400, f=4, k=12; n=k+f=12+4=16 and r=12\/16; or any other possible combination that conforms to a desired reliability policy for redundancy and concurrent failure tolerance of storage elements  of the distributed object storage system .","According to still a further alternative there could be provided a safety margin to the number of concurrent failures f that a distributed object storage system  needs to be able to cope with. In such an embodiment some of the efficiency is traded in for some additional redundancy over what is theoretically required. This preventively increases the tolerance for failures and the time window that is available for a repair activity. However according to a preferred embodiment this safety margin will be rather limited such that it only accounts for an increase in sub blocks that must be generated and stored of for example approximately 10% to 30%, such as for example 20%.",{"@attributes":{"id":"p-0065","num":"0108"},"figref":["FIG. 6","FIG. 5","FIG. 6"],"b":["1","300","500","1","10","500","510","520","20","600","600","1","600","12800","300","1","300","16","420","600","300","1","300","16","20","30","2","600","1","600","8000"]},"The retrieved sub blocks .-. allow the decoding module  to assemble data object  and offer it to the application , It is clear that any number in any combination of the redundant sub blocks  corresponding to said data object , as long as their number is equal to or larger than the predetermined multiple of the minimal spreading requirement x*k=800*10=8000, would have enabled the decoding module  to assemble the data object .","As shown in , the distributed object storage system  further comprises a monitoring agent  which monitors whether the distributed object storage system  still correctly stores all data objects that were offered for storage by the application . The monitoring agent  could perform this monitoring activity on a periodic basis, for example it could check every storage element  every ten days, or it could be triggered by a specific event, such as for example a signal indicating that a particular storage element  is not available. The monitoring agent  can be implemented as programming instructions stored in local memory  of the controller node  for execution by its processor  or alternatively in local memory  of one or more of the storage nodes  for execution by their processor  or any other suitable combination. Multiple monitoring agent could be active concurrently within a distributed object storage system according to the invention. The only requirement is that the monitoring agent  is able to connect to the storage nodes  which need to be subject to the monitoring process for data objects  being stored in the distributed object storage system .","When during the monitoring process the monitoring agent  detects a data object  that is not correctly stored in the distributed object storage system , the monitoring agent  will treat the data object identifier  of this incorrectly stored data object  as a repair data object identifier  and will create a repair task  comprising this repair data object identifier . Repair task created by one or more monitoring agent can for example be aggregated in a suitable programmable storage structure, such as for example a repair task list, in the memory of the controller node  or one or more of the storage nodes  of the distributed object storage system . In this way, for each data object  stored in the distributed data storage system  in need of repair, a corresponding entry in the repair task list will be available.","As further shown in , the distributed object storage system  further comprises a maintenance agent  that are able to process a repair task, for example by checking the repair task list on a periodic basis and processing one of the repair tasks in it. Optionally the distributed object storage system  comprises a plurality of these maintenance agents . The maintenance agent  can be implemented as programming instructions stored in local memory  of the controller node  for execution by its processor  or alternatively in local memory  of one or more of the storage nodes  for execution by their processor  or any other suitable combination. The maintenance agent  must however be enabled to connect to the controller node  in order to process the repair task  and thereby repairing the corresponding repair data object stored in the distributed object storage system .","The maintenance agent  retrieves a repair task  that was created by the monitoring agent  and determines the corresponding repair data object identifier  comprised within this repair task . Subsequently the maintenance agent  will instruct the clustering module  to execute a repair retrieval operation for the repair data object which corresponds to the repair data object identifier. When executing this repair retrieval operation, the clustering module  will report back to maintenance agent  the number of missing sub blocks , which corresponds to the number of sub blocks said clustering module  is not able to collect. As such the maintenance agent  is able to determine the number of missing sub blocks  for this repair data object. For example, a repair task could have been created for the data object  as described in , for example because a signal was generated by the distributed object storages system  indicating to the monitoring agent that storage node . was no longer reachable and subsequently the monitoring agent  determined that this data object  was no longer correctly stored in the distributed object storage system . The clustering module , when now processing the corresponding repair retrieval operation will initiate an attempt to retrieve the predetermined number x*n=16*800=12800 sub blocks .-. relating to said repair object identifier. The clustering module  will be able to retrieve sub blocks .-. stored on storage elements .-. that are part of storage node ., while the clustering module  will not be able to retrieve sub blocks .-. that were stored on storage elements .-. that are part of storage node .. The clustering module  in this particular case will report to the maintenance agent  that there are 4800 missing sub blocks  for this repair object identifier . However, as the clustering module  was able to retrieve a number of collected sub blocks .-. equal to or greater then the predetermined multiple of said minimal spreading requirement x*k=800*10=8000, these sub blocks .-. will subsequently enable the decoding module , as instructed by the repair agent , to successfully assemble the repair data object , as shown in , thereby successfully completing the repair retrieval request.","Subsequently, as shown in , the maintenance agent  will initiate a repair storage operation by instructing the encoding module  to disassemble this repair data object  into a specific number of repair sub blocks .-., specific number of repair sub blocks being equal to said number of missing sub blocks .-.. In this particular example the number of missing sub blocks, as well as this specific number of repair sub blocks being equal to 4800.","It is not necessary to know exactly which sub blocks  are missing as the probability of generating repair sub blocks  which overlap with the already stored sub blocks  is sufficiently low, as the encoding technology, such as for example when based on online codes, makes use of randomly generated numbers, such as for example described in more detail in WO2009135630, which reduces the probability of overlap significantly as is well known to the man skilled in the art. In order to still further reduce the probability of overlap, in the case of online codes, as for example described in WO2009135630, the random number generator could be seeded during the repair storage operation with a seed that is known to be different from the seeds used during a normal storage operation. Alternative examples for generating sub block  without a realistic probability of overlap with erasure encoding technology are within the knowledge of the man skilled in the art.","The repair storage operation is finalised by the spreading module  which stores this specific number of repair sub blocks .-., such that these repair sub blocks and the collected sub blocks .-. are stored on a number of said storage elements  being larger or equal to said desired spreading width n=16. In the example shown in  this is accomplished by the spreading module storing repair sub blocks .-. on storage elements .-., the share of sub blocks to be stored on the respective storage elements  again being determined according to methods being well known to the person skilled in the art such as for example as shown in  repair sub blocks .-. on storage element ., . . . , repair sub blocks .-. on storage element .. Alternative methods for determining the share of sub blocks  to be stored on specific storage elements  are well known to the person skilled in the art and are for example described in WO 2009135630.","It is clear that the maintenance agent  is able to process a repair task  far more efficiently as compared to prior art systems which make use of the regular retrieval and\/or storage operation. There is no need for the maintenance agent of the distributed object storage system  according to the invention to determine and keep track of exactly what sub blocks  are missing, and as such the repair retrieval operation and repair storage operation can be executed more efficiently than prior art repair processes which focus on restoring the specific sub blocks which are missing or corrupt. Furthermore prior art systems don't provide a tailored retrieval or storage operation for the repair operation and as such a fall back on the regular retrieval and storage process, the latter of which will store said predetermined number x*n=800*16=12800 of sub blocks  and will thus consume more resources, such as processing power for the encoding module , network bandwidth for the spreading module and storage capacity of the storage elements  of the distributed object storage system.","It is clear that the maintenance agent  will still be able to process a repair task  more efficiently then prior art systems when the number of repair sub blocks generated is equal to the number of missing sub blocks augmented by a safety margin. In such an embodiment some of the efficiency is traded in for some additional redundancy in order to preventively cope with future repair needs. As long as the number of missing sub blocks augmented by the safety margin is less then said predetermined number the repair process will be more efficient then known systems, however according to a preferred embodiment this safety margin will be a rather limited amount, such as for example an integer value approximating a share of 10% to 20% of the number of missing sub blocks. It is clear however that the most efficient repair process can be achieved when the safety margin is equal to zero.","According to a preferred embodiment of the invention as shown in  the distributed storage system  comprises a metadata storage . During a storage operation the encoding module  and\/or the spreading module  add for every data object  they store a respective entry for its data object identifier; a list of identifiers of the storage elements  on which sub blocks  of this data object  are stored; and an identifier for the type of encoding policy that was used to disassemble this data object . Preferably the controller node  comprises such a metadata storage  which is for example implemented as a suitable programmable storage facility in its memory  as this allows the encoding module , spreading module , clustering module  and decoding module  optimal access to this centrally arranged metadata storage, which will be referred to as a central metadata storage, during storage, retrieval and repair operations. According to a particular embodiment of the invention, the spreading module  will add to this central metadata storage  the metadata for each data object  stored by the controller node  comprising this central metadata storage . As shown in  such a central metadata storage  comprises for example metadata for three data objects , schematically identified as A, B and C, this metadata comprising the data object identifier in the \u2018OBJ ID\u2019 column, a list of the identifiers of the storage elements storing where the sub blocks of the respective data objects  were stored by the spreading module  in the \u2018STOR EL\u2019 column, and the encoding policy used by the encoding module  in the \u2018ENC\u2019 column. Amongst other things, the central metadata storage  allows for efficient retrieval as the clustering module  is able to ascertain from the central metadata storage  which also resides centrally in the controller node  on which specific storage elements a specific data object  is stored. It also allows the decoding module  to efficiently ascertain which encoding policy was used. Alternatively such a central metadata storage  also allows for flexibility in the determination of encoding policies on a per data object basis, this means that the redundancy policy does not need to be fixed for all data objects stored in the distributed object storage systems, but can be set individually for each specific data object.","According to the embodiment of the distributed object storage system  shown in , comprises a controller node  connected to three storage nodes .-., each comprising ten storage elements respectively .-., .-., .-.. These three storage nodes .-., each comprise a local metadata storage .-. which is implemented as a similar storage facility as the central metadata storage , but resides in the memory  of the respective storage node . The spreading module  add to the respective local metadata storage , the metadata for each data object  stored in the corresponding storage node . In the schematic example of , the central metadata storage  comprises the metadata of data objects A, B and C, however the local metadata storage . of storage node . only comprises meta data for the data objects  for which the spreading module  has stored sub blocks  on any one of the storage elements .-., namely A and B. The local metadata storage . comprises metadata for the data objects for which the spreading module  has stored sub blocks  on any of the storage elements .-., namely A, B and C. comprises metadata for the data objects for which the spreading module  has stored sub blocks  on any of the storage elements .-., namely C. This embodiment allows the metadata to be spread amongst the controller node  and all storage nodes  of the distributed object storage system and in this way avoids the central metadata storage  from being a bottleneck and\/or a single point of failure. It is clear that the metadata in this way is stored in the distributed object storage system in such a way that it will fulfil the requirements of the same redundancy policy as for the corresponding data objects.","According to a preferred embodiment of the metadata storage  as shown in , the metadata further comprises a version number, as shown in the column \u2018VERSION\u2019 that is incremented every time the respective data object  is stored by said spreading module, this could be during a regular storage operation or during a repair storage operation. This version number adds further reliability to the metadata storage . For example in the case where controller node  needs to be replaced or where its central metadata storage  is inaccessible or corrupt for example as detected by a process running a verification check on the metadata storage , a new central metadata storage  can be constructed by aggregating all metadata available in the local metadata storage  of the storage nodes . However it could be that, for example as the result of a repair operation, some of the storage nodes  still comprise sub blocks  and associated metadata for a data object  that was subsequently updated. This outdated metadata could conflict with the correct metadata for these data objects  and there exists the risk that during a subsequent retrieval operation outdated sub blocks  would be retrieved. The version number allows an efficient mechanism for handling such a scenario, for example by instructing the controller node  in such a situation to retrieve the metadata from the local metadata storages  to only add the metadata to the central metadata storage  that comprises the highest version number. It is clear that alternative versioning number schemes are available, such as for example a lampert clock or other suitable versioning number scheme which allow distributed subsystems of the distributed object storage system  to update the version number without requiring an atomic operation and still allow the most recent version number to be identified.","As explained above, the metadata storage  allows the controller node  to determine on which storage elements  sub blocks  of a particular data object can be retrieved. This can be done with high efficiency when consulting the central metadata storage . However for additional robustness, for example at times when the central metadata store  is not available or during the process of rebuilding the central metadata store , a federated search of one or more of said local metadata storages  on the storage nodes . This federated search can use a set of rules and heuristics to quickly locate the metadata of specific data objects or it can us an exhaustive search. During such a federated search, according the embodiment of , when searching for metadata for data object C, the local metadata storage .- of the respective storage nodes .-. will be consulted. When consulting metadata storage . of storage node . no metadata will be found relating to data object C, however the metadata available for data objects A and B can for example be stored for rebuilding the central metadata storage  or cached for future federated searches. When consulting the local metadata storage . metadata for data object C will be retrieved, which will contain all storage elements  that store sub blocks  relating to data object C.","In order to still further enhance robustness for metadata availability there is made use of the version number as explained above. In this way the central metadata storage  can be verified and updated to the most recent state of the distributed object storage system . During the federated search the controller node  then retrieves metadata of the local metadata storages  and adds the metadata for each data object  that comprises the highest version number to the central metadata storage .","It is clear that according to still further embodiments of the metadata storage , the metadata stored for a data object  could comprise other suitable entries comprising properties of the data object , such as for example the state of the data object , which could for example comprise an indication whether the data object  was subject to a delete operation.","Several advantageous embodiments of the monitoring agent  for the distributed object storage system  according to the invention will now be described. Such a monitoring agent  identifies data objects  stored in the distributed object storage system  in need of repair and adds their data object identifier as a repair data object identifier to a repair task that then is available for processing by the maintenance agent. According to one embodiment the monitoring agent  is operable to monitor availability of a data object by instructing the clustering module  to retrieve all stored sub blocks  for this data object , this means an amount of sub blocks  for this data object  that corresponds to said predetermined number of x*n=800*16=12800. If at least one of these stored sub blocks cannot be retrieved, that means that only an amount of less than said predetermined number x*n=800*16=12800 can be retrieved, the monitoring agent  will provide the data object identifier of this data object as a repair data object identifier, a corresponding repair task is created. These repair tasks can then be aggregated in a repair task list for further processing by the maintenance agent . According to one embodiment such a repair task list could be implemented by marking a data object for repair in the metadata storage  as shown in more detail in . In the column \u2018REPAIR\u2019 it is schematically indicated when a data object is marked for repair if a \u20181\u2019 is present in this column, a \u20180\u2019 is present if no repair is needed. As such the repair task list can be created by filtering the metadata for all data object identifiers for which a \u20181\u2019 is present in the column \u2018REPAIR\u2019. Marking a data object for repair can be accomplished by setting the value in the \u2018REPAIR\u2019 column from \u20180\u2019 to \u20181\u2019. Checking all data objects stored in a distributed object storage system  could be performed by one or more monitoring agents  on a periodic basis. In one, there could be a monitoring agent  available in each storage node  which checks all data objects stored in this storage node  by checking all objects for which a data object identifier is available in its local metadata storage , for example every one to ten days. This could be combined with a monitoring agent  running on the controller node checking all data objects available in the central metadata storage  every ten to thirty days. According to another embodiment, it is possible to have available multiple namespaces, this is a defined collection of data objects sharing common properties in order to allow for sufficient scalability, a periodic check can be performed on all data objects contained in a specific namespace, for example once every thirty to sixty days.","According to an alternative embodiment, instead of checking whether all the sub blocks  for a specific data object are available, the monitoring agent  determines from the metadata storage on what storage elements  the data object  is stored and subsequently checks whether the status of these storage elements  for their availability. If one of these storage elements is not available, the data object is marked for repair as explained above.","According to a further embodiment of the monitoring agent , could be triggered during storage or retrieval operations, for example if the spreading module or clustering module determines that not all generated or stored sub blocks for a data object can be stored or retrieved correctly. The monitoring agent can then mark this data object for repair as explained above.","According to still a further embodiment of the monitoring agent , on a periodic basis checking the status of the storage elements  of the distributed object storage system . If a storage element  is detected of which the status indicates it is unavailable, repair data object identifiers can be provided for data objects of which sub blocks  are stored on this storage element . This can be done by marking all data objects mentioning this storage element in the central metadata storage  or local metadata storage  for repair.","In order to still further improve efficiency of the monitoring agent the monitoring agent  after checking the status of the storage elements  could store the status of these storage elements  in a central infrastructure database. This central infrastructure database could be implemented as any type of programmable storage structure for example in the memory  of the controller node . The central infrastructure database could store infrastructure metadata comprising an identifier of the storage elements and the status of these storage elements . Subsequently the monitoring agent  could mark all data objects  for repair of which sub blocks  are stored on a storage element of which the infrastructure metadata indicates it is unavailable. This can for example be implemented by combining both the metadata of the data objects and the infrastructure metadata of said storage elements.","This central infrastructure database could also be used to increase the efficiency of the repair retrieval operation. For example, when the maintenance agent  instructs the clustering module to retrieve said predetermined number of sub blocks comprising said repair data object identifier, is operable to further instruct said clustering module to consult said central infrastructure database. During the subsequent retrieval of number of stored sub blocks equal to or greater then said predetermined multiple of said minimal spreading requirement x*k=800*10=8000, the clustering module  will exclusively consult storage elements  of which the status in said infrastructure metadata indicates they are available. In this way no time and network traffic is lost on accessing unavailable storage elements  or on waiting for sub blocks  that are unavailable.","The infrastructure database allows the state of all storage elements  used in the distributed object storage system  to be centrally recorded. Possible states for such a storage element  are for example active, offline, abandoned, or some other state. The monitoring agent can for example on a periodic basis contact each of the storage nodes  to get current status of each of their storage elements , these storage elements being for example hard disk drive. Each storage node  can periodically assess the quality of its these hard disk drives by for example obtaining the SMART disk information, by doing explicit disk tests or by keeping its own log of read and write errors or by using some other methods. Once the state of these hard disk drives is determined the storage node  can report this to the central infrastructure database comprising a list of hard disk statuses. When the quality of a storage element  becomes suspicious the operator is alerted and is given a choice to either put the storage element back into service or mark it as abandoned. Alternatively the system can decide automatically, based on policies to abandon a storage element . Once a storage element  is marked abandoned it will not be used for further storage or retrieval operations and it can be powered down to conserve energy use.","Alternatively instead of monitoring the state of the storage elements  of the distributed object storage system , the monitoring agent could monitor the availability of all storage nodes  and record this centrally in the infrastructure database. A storage node  can be available or unavailable or some other state. According to one embodiment a monitoring agent  running on a storage node  can record the availability of this storage node  in the central infrastructure database. Whenever a storage node  becomes unavailable for a certain length of time, an operator could be alerted and can be requested to take action. The action could be to put the storage node  back online or to remove it from the distributed object storage system . Alternatively the distributed object storage system  could decide automatically, based on policies, to remove a storage node  that is unavailable. Once a storage node  is removed from the distributed object storage system , all the storage elements  it comprises can be marked as abandoned.","According to still a further embodiment of the distributed object storage system , as shown in , the encoding module  will calculate for every sub block  a corresponding checksum, such as for example a cyclic redundancy check or CRC, or alternative checksum implementations such as MD5, SHA1, SHA128, SHA256, etc during disassembly of the data object  during a storage operation. As such there will now be available a predetermined number of sub blocks  and a predetermined number of checksums of these sub blocks . The spreading module  subsequently stores this predetermined number of checksums together with their corresponding redundant sub blocks  on the storage elements . These checksums now allow for an embodiment of a monitoring agent  to assess data consistency of the distributed object storage system . This means that for example on a periodic basis, for example on a regular interval on a per name space basis, a monitoring agent  can determine the consistency of all the data objects  stored by checking per stored data object , whether the stored checksum of all of the stored sub blocks  of these data objects  corresponds with a recomputed checksum of each of the stored sub blocks . If at least one of the sub blocks  is stored on a storage element  together with an invalid checksum, the corresponding data object  can be marked for repair as explained above. In order to have a scalable approach, the distributed object storage system  could comprise a plurality of such monitoring agents  running locally on its storage nodes  in order to distribute the work load. The policy for periodic consistency checks can for example specify that all data objects  stored in the distributed object storage system  need to be checked every  days on a per name space basis. In such a case, each of the monitoring agents  running locally on a storage node, will check 1\/30of all sub blocks  stored on its storage node for consistency. If, for some reason, the sub blocks  that were scheduled for consistency checking could not be processed that day, these will be added to the schedule for the next day.","According to still a further embodiment the encoding module  will calculate for a group of consecutive sub blocks  a single checksum. Such a group could comprise for example 16 or 32 or any other suitable number of consecutive sub blocks , such as for example sub blocks .-.. This allows for a performance optimisation as less checksums need to be generated, verified and stored, while compromising the efficiency of repair only slightly, because when an invalid checksum is detected the number of missing sub blocks  will be equal to that of the number of sub blocks  in the corresponding group of sub blocks . So this will slightly increase the number of missing sub blocks in the case that only part of the sub blocks contained in this group would be really in need of repair. However the repair process would still not require to know which exact sub blocks  were in need of repair, it only needs to be informed of the number of missing sub blocks , which in this embodiment would always be a multiple of the number of sub blocks in such a group.","According to still a further embodiment according to the invention, the distributed object storage system  comprises a garbage collection agent in order to still further improve reliability and to optimize long term storage capacity. The garbage collection agent can be implemented as programming instructions stored in local memory  of the controller node  for execution by its processor  or alternatively in local memory  of one or more of the storage nodes  for execution by their processor  or any other suitable combination. During the life time of the distributed object storage system  there is a probability that a certain number of sub blocks  will come into existence that are no longer associated to a stored data object , for example as the result of an incomplete delete operation or an error during a storage operation. These stored sub blocks , for which there is for example no corresponding data object  available anymore in the metadata storage , are considered to be garbage and it is preferred to remove them from the storage elements  in order to make available the storage capacity they consume. During a garbage collection operation, the garbage collector agent must be connected to or active on the respective storage nodes . The garbage collection operation could be scheduled on a periodic basis and could generally comprise these steps:\n\n","According to one embodiment of the garbage collection agent, the verification can be accomplished by simply checking whether the retrieved object identifier is present in the central metadata storage  or the local metadata storage  of the storage node  storing the sub block  being checked. This allows for a distributed approach to garbage collection and enables to have a plurality of garbage collection agents running in parallel, for example one on each storage node  of the distributed object storage system . According to still further embodiments in order to achieve performance optimisations the garbage collection agent could be configured to only check sub blocks or data objects that are older than a certain date or that have not been updated or accessed for a predetermined amount of time. It is clear that numerous alternative scenarios are available to the person skilled in the art in order to increase the chance of checking a relevant subset of sub blocks or data objects, such as for example older or inactive sub blocks or data objects instead of newer or active ones.","According to an alternative embodiment of the garbage collection agent, on a regular basis form the central metadata storage a central list is generated, by a central garbage collection agent, of all data objects  stored in the distributed object storage system . Subsequently, based on this central list, for each storage node , a plurality of local lists is generated of all data objects  of which sub blocks are stored on a specific storage node . These local lists are then subsequently sent to the respective storage nodes  where they are processed by a local garbage collection agent. These local garbage collection agents, after receiving the local list, will create a check list comprising all data object identifiers mentioned by the sub blocks  stored on their storage node . The local garbage collection agents will subsequently compare their local list and check list and identify all sub blocks for which a data object is present in the check list but not in the local list. These sub blocks  can then be considered garbage as explained above and can be removed from the storage node  in order to make available the storage capacity they consume. During this comparison the garbage collection agent could optionally mark the data objects  which are available in the local list, but not in the check list for repair as explained above. In order to cope with the time lag that might occur during the creation of the local list and the check list, it might be preferential to implement a time marker functionality into the distributed object storage system, such as providing a time stamp for every data object  stored in the system, which could for example be implemented as an entry for a creation timestamp, a last modification timestamp, etc. in the metadata storage  for each data object  stored. In this way a synchronization point could be created for the garbage collection operation, such that the risk, that for example sub blocks corresponding to new data objects that were stored in the system during the creation of the local lists and\/or check list would be considered as garbage, can be mitigated.","Although the present invention has been illustrated by reference to specific embodiments, it will be apparent to those skilled in the art that the invention is not limited to the details of the foregoing illustrative embodiments, and that the present invention may be embodied with various changes and modifications without departing from the scope thereof. The present embodiments are therefore to be considered in all respects as illustrative and not restrictive, the scope of the invention being indicated by the appended claims rather than by the foregoing description, and all changes which come within the meaning and range of equivalency of the claims are therefore intended to be embraced therein. In other words, it is contemplated to cover any and all modifications, variations or equivalents that fall within the scope of the basic underlying principles and whose essential attributes are claimed in this patent application. It will furthermore be understood by the reader of this patent application that the words \u201ccomprising\u201d or \u201ccomprise\u201d do not exclude other elements or steps, that the words \u201ca\u201d or \u201can\u201d do not exclude a plurality, and that a single element, such as a computer system, a processor, or another integrated unit may fulfil the functions of several means recited in the claims. Any reference signs in the claims shall not be construed as limiting the respective claims concerned. The terms \u201cfirst\u201d, \u201csecond\u201d, \u201cthird\u201d, \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and the like, when used in the description or in the claims are introduced to distinguish between similar elements or steps and are not necessarily describing a sequential or chronological order. Similarly, the terms \u201ctop\u201d, \u201cbottom\u201d, \u201cover\u201d, \u201cunder\u201d, and the like are introduced for descriptive purposes and not necessarily to denote relative positions. It is to be understood that the terms so used are interchangeable under appropriate circumstances and embodiments of the invention are capable of operating according to the present invention in other sequences, or in orientations different from the one(s) described or illustrated above."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0040","num":"0083"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0041","num":"0084"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0042","num":"0085"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0043","num":"0086"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0044","num":"0087"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0045","num":"0088"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0046","num":"0089"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0047","num":"0090"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0048","num":"0091"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0049","num":"0092"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
