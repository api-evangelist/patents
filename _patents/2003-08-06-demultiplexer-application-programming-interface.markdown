---
title: Demultiplexer application programming interface
abstract: A set of interfaces and data structures (i.e., a demultiplexer API) represents a demultiplexer of multimedia data. The data structure utilizes a number of fields, each containing an element of a command. In one embodiment, at least seven commands are formed for proper operation of the demultiplexer, including Initialize, SetPresentationDescriptor, GetPresentationDescriptor, GetPendingPresentationDescriptor, ProcessInput, ProcessOutput, and Flush commands. The demultiplexer API allows the consumer to use muxed stream data such as DV in a uniform manner to generate elementary stream data such as audio and video (compressed or uncompressed) and allows demultiplexers to be used as an independent component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07882510&OS=07882510&RS=07882510
owner: Microsoft Corporation
number: 07882510
owner_city: Redmond
owner_country: US
publication_date: 20030806
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention relates generally to electronic data processing and, more particularly, relates to handling multimedia data in a computing environment.","Digitally based multimedia, the combination of video and audio in a digital format for viewing on a digital device is rapidly increasing in capacity and proliferation. Nearly every new personal computer manufactured today includes some form of multimedia. Sales of digital products such as cameras, video recorders, phones and televisions are steadily increasing. Multimedia is also becoming increasingly prevalent in the Internet realm as the growth of the Internet steadily and rapidly continues. Along with this growth have come increased performance expectations by the users of such computer equipment. These increased user expectations extend not only to hardware capability, but also to the processing capability of the data itself.","A technique known as streaming has been developed for multimedia applications to satisfy these increasing expectations. Streaming allows data to be transferred so that it can be processed as a steady and continuous stream. This has the benefit that data can be displayed or listened to before the entire file has been transmitted, a must for large multimedia files.","Initially, the streaming framework consisted of a chain of data processing modules (e.g., capturing filters, transformation filters, and rendering filters) with very little intelligence from the chain manager. The data processing modules, also called filters, make the decisions on how to get connected, what data formats to use, and how to control each other. During connection of filters in a chain, protocols define a predefined fixed sequence of data flow and control connection negotiations. A typical negotiation sequence is to negotiate the following in order: the interface, the medium, the data format, the allocators, and the master clock. The data processing chain provides an end-to-end solution within a computer system.","As the complexity of streaming increased, the industry recognized that it became necessary to optimize the processing chains that were processing data with real-time constraints such as video and audio processing chains. One solution is DirectShow\u00ae by Microsoft\u00ae Corporation, which provides playback of multimedia streams from local files or Internet servers, capture of multimedia streams from devices, and format conversion of multimedia streams. DirectShow\u00ae enables playback of video and audio content of file types such as Windows Media Audio, Windows Media Video, MPEG, Apple\u00ae QuickTime\u00ae, Audio-Video Interleaved (AVI), and WAV (Windows Wave). DirectShow\u00ae includes a system of pluggable filter components. Filters are objects that support DirectShow\u00ae interfaces and that are capable of operating on streams of data by reading, copying, modifying and writing data to a file. The basic types of filters include a source filter, which takes the data from some source, such as a file on disk, a satellite feed, an Internet server, or a VCR, and introduces it into the filter graph, which is a connection of filters. The filters in a filter graph include a transform filter, which converts the format of the data, a sync and source filter that receives data and transmits the data; and a rendering filter, which renders the data, such as rendering the data to a display device. The data can also be rendered to any location that accepts media. Other types of filters included in DirectShow\u00ae include effect filters, which add effects without changing the data type, and parser filters, which understand the format of the source data and know how to read the correct bytes, create times stamps, and perform seeks.","During operation, all data passes from filter to filter along with a great amount of control information. Each filter contains objects called \u201cpins\u201d that are used to connect to other filters. When filters are connected using the pins, a filter graph is created. Note there is a distinction between a \u201cfilter graph\u201d which is the concept of a group of connected filters, and a \u201cFilter Graph\u201d which is the object you create in DirectShow\u00ae that controls the group of connected filters, the \u201cfilter graph\u201d. The \u201cFilter Graph\u201d is more correctly called a filter graph manager. To control the data flow and connections in a filter graph, DirectShow\u00ae includes a filter graph manager. The filter graph manager assists in assuring that filters are connected in the proper order. However, the data and much of the control do not pass through the filter graph manager. Filters must be linked appropriately. For example, the filter graph manager must search for a rendering configuration, determine the types of filters available, link the filters in the appropriate order for a given data type and provide an appropriate rendering filter.","While filters allowed a great deal of reuse of programs, the use of these filters also created some unanticipated problems. One of the problems created by the filters is the large number of API's for the filters that came into being. Each filter essentially has a separate API. As a result, a given filter must be capable of interfacing to the API for every filter to which it might attach. Also, the use of filters creates the problem of shutting down a given filter problematic. When a given filter in a graph is shut down, any filter that interfaces with the shut down filter requires a different associated interface. In general, programming a filter to gracefully handle the loss of an interface is difficult, as the state of the filter can be unknown when the interface is lost. The loss of interfaces, therefore, tends to lead to unpredicted behavior in the filters and ultimately to ill behaved programs. Further, the overall control in DirectShow\u00ae is distributed between two blocks. The interface between the filters controls the data flow while the filter manager controls the instantiation and removal of filters. Distributing the control in this manner makes software design cumbersome, as there are inevitably some control functions that cross the boundary between the blocks. Another problem with DirectShow is that the filters shoulder the responsibility of media format negotiation and buffer management functionality. Filters communicate with other filters to accomplish this task. The dependency on filters causes applications building on DirectShow to be susceptible to bugs and inefficiencies that could be programmed into a filter. Thus, a badly written filter could easily bring down the filter graph and an application associated with the filter graph.","There is a need to improve the DirectShow\u00ae architecture. More particularly, there is a need to improve control of processing of multimedia data.","The invention includes a set of interfaces, data structures and events for representing a demultiplexer of multimedia data. The data structure utilizes a number of fields, each containing an element of a command. In one embodiment, at least seven commands are formed for proper operation of the demultipexer, including Initialize, SetPresentationDescriptor, GetPresentationDescriptor, GetPendingPresentationDescriptor, ProcessInput, ProcessOutput, and Flush commands. The interfaces are collectively known as the Demultiplexer Application Programming Interface (Demux API). The Demux API allows the consumer to use muxed stream data such as DV in a uniform manner to generate elementary stream data such as audio and video (compressed or uncompressed).","The Initialize method is used to initialize and configure the demultiplexer object and has parameters that are used to configure the demultiplexer. The parameters include a muxed stream descriptor object that describes the muxed stream, a selected media type for the muxed stream descriptor, an array of major types of elementary streams that the user is interested in retrieving as output from the demultiplexer, and a count of the major types in the array of major types.","The SetPresentationDescriptor method is used to dynamically set the active presentation descriptor on the demultiplexer object. The SetPresentationDescriptor method includes a pointer to a presentation descriptor object. The ProcessInput method is used to provide a new input muxed stream to the demultiplexer object and includes a pointer to a sample object. The ProcessInput method has a return value that has a new presentation flag. If the new presentation flag has a TRUE value, the presentation has changed based on the presentation descriptor in the muxed sample. The user must call GetPendingPresentationDescriptor method to retrieve the next pending presentation, select desired streams, and call the SetPresentationDescriptor method to enable processing of samples from the demultiplexer's input queue.","The ProcessOutput method is used to retrieve at least one elementary stream from an active presentation. The ProcessOutput method includes a stream identifier and a pointer to a pointer to a sample object. The ProcessOutput method further includes an output return value. The output return value includes an end of stream error code and a no more data error code.","The Flush method is used to flush currently queued input and output samples. No parameters are needed for the Flush method.","The GetPresentationDescriptor method is used to retrieve a clone of the currently active presentation descriptor on the demultiplexer object. The GetPresentationDescriptor method includes a presentation descriptor.","The GetPendingPresentationDescriptor method is used to retrieve the next pending presentation. The GetPendingPresentationDescriptor method includes a pending presentation descriptor.","Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments which proceeds with reference to the accompanying figures.","The invention provides a set of interfaces, data structures and events for representing a demultiplexer of multimedia data that are collectively called a demultiplexer API. The API allows the consumer to use muxed stream data such as DV, MPEG2, ASF, etc. in a uniform manner to generate elementary stream data such as audio and video (compressed or uncompressed). The demultiplexer API supports dynamic generation of new stream descriptors based on the muxed stream initialization data and supports dynamic generation of new stream descriptors based on the muxed stream samples. Additionally, the demultiplexer API supports either out of band initialization via metadata about the muxed stream or in band initialization via muxed stream samples and supports generation of demultiplexed samples which can span multiple buffers. In the context of the Media Foundation architecture by Microsoft\u00ae Corporation, the demultiplexer API is primarily controlled by, and output delivered to, a media processor as described herein below. The demultiplexer API is designed such that any multimedia architecture should be able to use a demultiplexer in a well-defined manner.","Turning to the drawings, wherein like reference numerals refer to like elements, the invention is illustrated as being implemented in a suitable computing environment. Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed by a personal computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to: personal computers, server computers, hand-held or laptop devices, tablet devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in local and\/or remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, and removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers hereto illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard , a pointing device , commonly referred to as a mouse, trackball or touch pad, a microphone , and a tablet or electronic digitizer . Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . The monitor  may also be integrated with a touch-screen panel or the like. Note that the monitor and\/or touch screen panel can be physically coupled to a housing in which the computing device  is incorporated, such as in a tablet-type personal computer. In addition, computers such as the computing device  may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface  or the like.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet. For example, the computer system  may comprise the source machine from which data is being migrated, and the remote computer  may comprise the destination machine. Note however that source and destination machines need not be connected by a network or any other means, but instead, data may be migrated via any media capable of being written by the source platform and read by the destination platform or platforms.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computers, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.","Turning now to , the demultiplexer of the present invention may operate in the Media Foundation architecture, which is an implementation of one of Microsoft's multimedia architectures. While  shows the demultiplexer in the Media Foundation architecture, it is recognized that the demultiplexer API of the invention is usable in other multimedia architectures. Prior to describing the demultiplexer, the Media Foundation shall be described. Media Foundation is a componentized architecture. As shown, Media Foundation includes core layer  components that are responsible for some basic unit of functionality in Media Foundation, and Control layer  components, responsible for performing more general tasks using the underlying Core component.","Core layer  components include media sources  and stream sources , which provide multimedia data through a generic, well-defined interface. The media sources  describe the presentation, including streams to be accessed. There are many implementations of media sources, for providing multimedia data from different multimedia file types or devices. Core layer  further includes transforms shown in block , which perform some sort of transformation operation on multimedia data through a generic, well-defined interface. Transform examples are codecs, video resizers, audio resamplers, statistical processors, color resamplers, and others. The demultiplexer of the present invention, which takes interleaved multimedia data as an input, and separates the data into individually useful media streams of multimedia data is a transform in the architecture of . Block  further includes multiplexers, which take individual media streams and combine them into interleaved multimedia data. Multiplexers share a common, well-defined interface, and there are many implementations for multiplexing into different types of multimedia data. Core layer  further includes stream sinks  and media sinks . Media Sinks  accept multimedia data as input through a generic, well-defined interface. There are many implementations of media sinks for performing different functions with multimedia data. For instance, writing the multimedia data to a given file type, or displaying the multimedia data on a monitor using a video card.","Control layer  components use the core layer  components to perform higher-level tasks in a simpler way. Typically a control layer component will use many different core layer components for a given task. For instance, playing back a multimedia file will involve a media source to read the file from disk and parse the data, one or more transforms to decompress the compressed multimedia data, and one or more media sinks to display the multimedia data. Control layer  includes media engine , which interacts with application  to receive and send media streams, media session , media processor  and topology loader , shown within media session . Topology loader  is a control layer component responsible for describing the data flow between the core layer components. A control layer components can be configured to avoid access to the more primitive core-level components used by the control layer. Data flows through system beginning with a media source  flowing through the media session  to media processor  and an output at media sink . Media processor  runs a pipeline of media sources and other components in the topology. Media session  guides when events in a topology occur, and the topology loader  ensures that events prescribed in a topology occur. The media session  also configures the media processor  and consumes the samples returned by the media processor . It does this in the context of the media engine  and sends the samples from the media processor  to the media sinks it has negotiated with the caller of the media engine  (e.g., application ). The Components in a topology include media source  components and media sink  components as well as other nodes. The media foundation system  provides interfaces and a layout for connecting streaming media objects. The system allows a user to specify connections between generic or specified sources, transforms, and sink objects via a symbolic abstraction using a topology concept.","Turning now to , an overview of the demultiplexer  shall now be described. In the description that follows, commands will be referenced in the description. These commands are described herein below. The demultiplexer API separates the format of the data from the source of the data. The demultiplexer API takes multiplexed data as an in-memory buffer of data, and performs the demultiplex operation. This has the desired effect that many different sources of data can use the same implementation of the demultiplexer to perform this operation. For example, DV data can come directly from a DV camera, but can also be stored as a file on a hard drive. In this case, there are two pieces of code for generating the multiplexed DV data (e.g., one that talks to the camera, another that talks to the file system), but the same demultiplexer implementation can be used. The demultiplexer  supports the IMFDemultiplexer interface and is responsible for splitting a muxed stream into its elementary stream parts. The demultiplexer  operates in a synchronous fashion (similar to a DMO), and can handle dynamic changes in the available elementary streams caused by changes in the muxed stream. It accepts and generates samples which are expressed via the IMFSample interface, and accommodates generating samples which span multiple buffers.","A muxed stream  is a single stream that contains more than one elementary stream. An elementary stream ,  is a stream of like elements (e.g., audio, video, etc.). There isn't necessarily any kind of one-to-one correspondence between muxed samples  and elementary samples , . For example, there may or may not be a complete elementary sample for every elementary stream in every muxed sample. Additionally, there is no particular requirement that the elementary samples be in the correct order in the muxed stream either. The elementary samples coming out of the stream may not share the same timestamps. One elementary stream may be at an offset from the other. Some muxed streams can contain only a single set of elementary streams for the duration of the stream. Some muxed streams may have different sets of elementary streams at different times.","Each set of coordinated elementary streams is called a presentation . Each set has a corresponding presentation descriptor . This presentation descriptor  has two main purposes. First, it describes the media types of each elementary stream. Second, it provides a mechanism to select which of the available streams are to be extracted by the demultiplexer . The Current Presentation  always describes the selected streams and data-types of the current output streams.","Before a sample can be processed by the demultiplexer , a splitting algorithm used to transform multiplexed samples to elementary samples needs to know what streams are to be extracted. This information is contained in the presentation descriptor . Before the streams are selected, the presentation descriptor is \u201cpending\u201d. Once the streams are selected the presentation descriptor is \u201cactive\u201d. To make a presentation active, it is retrieved from the pending presentation queue  by calling GetPendingPresentationDescriptor. The appropriate streams are selected and then the caller invokes the SetPresentationDescriptor method. At this point (if certain conditions are met), the presentation becomes the active presentation  and is removed from the pending presentation queue . A pending presentation can only become active if all output from the previous active presentation has been serviced.","The demultiplexer  contains at least two sets of queues. The queues are input queues  and output queues , . When ProcessInput( ) is called on the demultiplexer , the input may be immediately processed or put in the input queue . Once the data is processed, it is put into an output queue , . The data types and streams available in the output queues always correspond to the current active presentation .","Now that the overall description of the demultiplexer  has been described, the states and transitions of the demultiplexer  shall be described. In the description that follows, commands will be referenced in the description. These commands are described herein below. Turning now to , the demultiplexer  is in the uninitialized state  when the demultiplexer  has been created but Initialize has not yet been called. Initialize is the only valid operation on the demultiplexer object  in this state. Calling Initialize( ) will transition the demultiplexer  to the pending state .","The pending state  indicates that there is no valid active presentation. Calls to ProcessOutput will fail. To set the active presentation, the media processor  calls GetPendingPresentationDescriptor( ), selects the appropriate streams and calls SetPresentationDescriptor( ). If the call to GetPendingPresentationDescriptor( ) fails, then ProcessInput( ) is called. Then GetPendingPresentationDescriptor( ) is called again until a presentation descriptor  can be obtained. Once a PresentationDescriptor has been set on the demultiplexer , it will transition to the Neutral state . Calling Flush( ) will discard all queued input and output data and transition the demultiplexer  to the pending state .","In the neutral state , all function calls (except initialize) are valid. When there is a new presentation discovered on a ProcessInput Call and the last sample from the current presentation is serviced from the output queue, the demultiplexer  will transition to the pending state .","Some streams have fixed and finite durations that can be detected based on the stream content. When this condition is detected and all output has been serviced, the demultiplexer will transition to the end_of_stream state . All future calls will return an appropriate error code.","When an unrecoverable error occurs in the demultiplexer , it will transition to the error state . The error state  can be reached from any other state. When the demultiplexer  is to be removed, Release( ) is called and the demultiplexer  transitions to the end state  prior to the demultiplexer  being removed from the system. When the last reference to the demultiplexer  is released, then the demultiplexer  is removed from memory without respect to what state the demultiplexer  is in. Release( ) can be called from any state, including the uninitialized state.","Now that the states and transitions of the demultiplexer  have been described, the commands that have been referenced above will now be described. These commands include Initialize( ), SetPresentationDescriptor( ), GetPresentationDescriptor( ), GetPendingPresentationDescriptor( ), ProcessInput( ), ProcessOutput( ), and Flush( ).","Illustrated in  is an exemplary data structure diagram that illustrates the basic message data structure  used to construct the seven messages of the demultiplexer API of the present invention. As may be seen, the message data structure  comprises a number of fields . In a preferred embodiment, the first field is reserved for the Header. The remaining fields are parameters.","In accordance with the data structure of the present invention, the Initialize command is constructed. As may be seen from the data structure diagram of , the Initialize command  is constructed from a number of fields -. These fields are a header field , a stream descriptor object field , a media type field , a major type count field , and a major type array field . Each of the different commands are constructed in a similar fashion as illustrated in , and descriptions of each will be provided below.","The Initialize( ) method configures and initializes the demultiplexer object . The muxed stream descriptor may contain metadata appropriate to initialize the demultiplexer state (including any header data etc.). The syntax of the command is",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT Initialize("]},{"entry":[{},"\u2003IMFStreamDescriptor* pMuxedStreamDescriptor,"]},{"entry":[{},"\u2003IMFMediaType* pSelectedMediaType,"]},{"entry":[{},"\u2003DWORD cMajorTypes,"]},{"entry":[{},"\u2003GUID* aMajorTypes,"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["300","300","300"]},"The SetPresentationDescriptor method sets the active presentation descriptor on the demultiplexer  indicating the new stream selection that the caller is interested in. The presentation descriptor must be a descriptor generated via the GetPresentationDescriptor method or GetPendingPresentationDescriptor method. The syntax of the command is",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT SetPresentationDescriptor("]},{"entry":[{},"\u2003IMFPresentationDescriptor* pPresentationDescriptor"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The GetPresentationDescriptor method retrieves a clone of the currently active presentation descriptor on the demultiplexer . The syntax of the command is",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT GetPresentationDescriptor("]},{"entry":[{},"\u2003IMFPresentationDescriptor* ppPresentationDescriptor"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The GetPendingPresentationDescriptor method retrieves the next pending presentation. The syntax of the command is",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT GetPendingPresentationDescriptor("]},{"entry":[{},"\u2003IMFPresentationDescriptor* ppPendingPresentationDescriptor"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The ProcessInput method allows the caller to provide a new input muxed stream sample to the demultiplexer. If the demultiplexer detects the presence of new streams in the presentation then the *pfNewPresentationAvailable will be set to TRUE, and the caller can retrieve the pending presentation descriptor via ::GetPendingPresentationDescriptor. The syntax of the command is",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT ProcessInput("]},{"entry":[{},"\u2003IMFSample* pSample"]},{"entry":[{},"\u2003BOOL* pfNewPresentationAvailable"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The ProcessInput method allows the caller to retrieve an elementary stream or streams from the active presentation. The syntax of the command is",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT ProcessOutput("]},{"entry":[{},"\u2003DWORD dwStreamIdentifier,"]},{"entry":[{},"\u2002IMFSample* ppSample"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["300","300"]},"The Flush method allows the caller to flush all currently queued input and output samples in the demultiplexer . Flush also clears the ActivePresentationDescriptor. This can be done when the upstream data is seeked to a new location or the caller simply wants to discard all buffered data. The syntax of the command is\n\n","Now that the demultiplexer  commands have been described, a typical operation shall be described where the source (e.g., application ) does not negotiate a sink that accepts the muxed stream. Turning now to , the source exposes the muxed stream for selection by the application (e.g. a video capture source exposes DV or a TV source exposes an MPEG2 program stream) (step ). The control layer  determines if the application has negotiated a sink for the muxed stream (step ). If the application  does not negotiate a sink for the muxed stream, the media session  loads the appropriate demultiplexer and initializes it with a muxed stream descriptor (step ).","If a presentation is available from the demultiplexer (step ), the media session  tries to renegotiate using the elementary stream descriptors (step ). The rest of the topology is built (step ). The exposed elementary streams are processed by media processor  using DMOs (e.g., decoders).","If a presentation is not available, then the media session uses a NULL media sink to terminate the topology for the muxed stream until more information is available (step ). Whenever the session is started and samples are flowing, the demultiplexer  is given samples until a presentation descriptor becomes available (step ). This is done by calling the IMFMediaStream::ProcessSample is called on the media processor node that represents the muxed stream. The media processor  calls IMFMediaStream::ProcessSample on the underlying muxed stream e.g. AVI source exposing DV stream. When the muxed stream sample is retrieved, the Media Processor calls IMFDemultiplexer::ProcessInput on the demultiplexer . The ProcessSample and ProcessInput calls continue until the new presentation flag is TRUE on Return from IMFDemultiplexer::ProcessInput. The media processor  then signals the media session  via an event that the current topology needs to be updated due to the demultiplexer change. The media session  calls IMFDemultiplexer::GetCurrentPresentation to get access to the newly available elementary stream descriptors. When the presentation descriptor becomes available, the media session can renegotiate using the elementary stream descriptors (step ).","A demultiplexer API for multimedia data streams has been described. The demultiplexer API includes a set of interfaces, data structures and events for representing a demultiplexer of multimedia data. The API allows the consumer to use muxed stream data such as DV in a uniform manner to generate elementary stream darta such as audio and video (compressed or uncompressed). The API allows demultiplexers to be used as an independent component. This API reduces the need for the large number of API's for filters and a given filter no longer needs to be capable of interfacing to the API for every filter to which it might attach in systems where legacy filters are not supported. Also, the demultiplexer may be shut down gracefully as the media processor is controlling the demultiplexer and not filters in the filter graph.","All of the references cited herein, including patents, patent applications, and publications, are hereby incorporated in their entireties by reference.","In view of the many possible embodiments to which the principles of this invention may be applied, it should be recognized that the embodiment described herein with respect to the drawing figures is meant to be illustrative only and should not be taken as limiting the scope of invention. For example, those of skill in the art will recognize that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa or that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["While the appended claims set forth the features of the present invention with particularity, the invention, together with its objects and advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
