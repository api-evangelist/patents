---
title: Isolating assembly versions for binding to application programs
abstract: An infrastructure that allows applications to run with specified versions of dependent assemblies, wherein each assembly may exist and run side-by-side on the system with other versions of the same assembly being used by other applications. An application provides a manifest to specify any desired assembly versions on which it is dependent. Similarly, each assembly may have an assembly manifest that specifies the versions of assemblies on which it is dependent. During an initialization phase, an activation context is created for the application, based on the manifests, to map version independent names to a particular assembly version maintained on the system. While the application is in a running phase, for any globally named object that the application wants created, the activation context is accessed to locate the application's or assembly's manifest-specified version. The manifests and activation context constructed therefrom thus isolate an application from assembly version changes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07287259&OS=07287259&RS=07287259
owner: Microsoft Corporation
number: 07287259
owner_city: Redmond
owner_country: US
publication_date: 20010424
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present application claims priority to U.S. Provisional Patent Application Ser. No. 60\/199,374, filed Apr. 24, 2000, and is also related to U.S. patent application entitled \u201cConfigurations for Binding Software Assemblies to Applications,\u201d Ser. No. 09\/842,278, filed concurrently herewith.","The present invention is generally directed to computer systems, and more particularly to executable computer code such as application programs that utilize shared assemblies (components).","At one time, computer applications were monolithic blocks of executable code and data, although some of their data such as variable settings could be maintained in separate files. This made tasks like moving or replacing the application simple. In contrast, contemporary computer applications and other executable code (such as an operating system component) bind to and make use of shared components, wherein in general a component is a self-contained software entity, offering a set of functions that can be used by a variety of applications. Such components include dynamic link libraries (DLLs) and objects such as OLE (Object Linking and Embedding) components and COM (Component Object Model) components, including ActiveX\u00ae controls. In turn, some of these shared components depend on other shared components.","On any given machine, at present there is one version of each of these components shared by applications, such as the most-recently installed version, although some mechanisms are known that replace an installed component only when an available replacement component has a higher version number. The metadata maintained for using these components is generally maintained in the system registry, and the application has the names of the needed components compiled into its binary code. Because in general the application does not change as components change, to function properly, global component sharing requires that any shared component function exactly like previous other versions of that component with respect to what an application expects. In practice, however, perfect backwards compatibility is difficult if not impossible to achieve, among other reasons because it is impractical to test the many configurations in which the shared component may be used. For example, both newer and older applications end up sharing the same component, whereby over time, fixing and improving the component becomes increasingly difficult. Moreover, the practical functionality of a component is not easily defined. For example, some applications may utilize unintended side effects in a component that are not considered part of the core function of the component, e.g., an application may become dependent on a bug in a component, and when the component publisher chooses to fix that bug, the application fails. Of course, on the other side, application writers cannot test future versions of components.","As a result, problems occur when a component is updated to its newer version, such as when a new application or operating system service pack is installed with updated copies of components, as the newly installed component versions become the ones used by other applications and components on the system. The sheer volume of applications and components that rely on other components magnifies this problem, which is sometimes referred to as \u201cDLL Hell.\u201d","One mechanism that provided sharing for some applications while enhancing the stability of other applications was provided in Microsoft Corporation's Windows\u00ae 2000 and Windows\u00ae 98, Second Edition, operating systems. In general, this mechanism provided a way for an application to be bound to a local copy of a component instead of a shared copy. However, with this solution, a component needed to be isolated per application, which resulted in multiple copies of the same component version having to be maintained on the system. Additionally global non-code data, such as COM data, was not isolated, limiting this mechanism's usefulness with COM objects.","Briefly, the present invention provides a method, system and infrastructure that allow an application to run with specified versions of components bound thereto, wherein each component (also referred to herein as an assembly, wherein an assembly is set of one or more component files which are versioned and shipped as a unit) may exist and run side-by-side on the system with other versions of the same assembly being used by other applications. To this end, the application provides a manifest to specify any desired assembly versions. An activation context is created for the application based on the manifest to map global, version independent names to a particular version maintained in an assembly cache or in the application's respective directory. In order to specify a version for an assembly, applications need not have their code rewritten, but instead can provide the application manifest, (e.g., in an XML data structure). Similarly, each assembly has an assembly manifest that specifies the versions of dependent assemblies.","In the pre-application execution phase when creating a new process, the operating system checks for an application manifest in the same file system directory as the calling executable. When an application manifest exists, the operating system checks for an activation context for the application that was built from the manifest. If the activation context does not exist (for example this is the first time application has been executed), or it exists but is not coherent with current policy, an activation context is created via the application manifest and the assembly manifests of any dependent assemblies\/assemblies listed in the application manifest.","At runtime, when a program requests creation of a global object, the operating system automatically consults the activation context built from the application and assembly manifests, to locate and load the assembly version that the application wants to use. The operating system also maps any uses of this named object (such as object (e.g., Windows\u00ae) classes) to the appropriate version to allow for multiple versions of the code module to run simultaneously without interfering with each other. By its manifest and the activation context built therefrom, an application may be bound to specific assembly versions and thereby be isolated from changes made to assembly versions by other applications.","Other objects and advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environment",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, and so forth, that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","The computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and includes both volatile and nonvolatile media, and removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules  and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, discussed above and illustrated in , provide storage of computer-readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules  and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers herein to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet. When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface  or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Isolating and Binding Assembly Versions","The present invention is generally directed to isolating versions of components (including code and\/or data) per-application program or the like, in a manner that allows multiple versions of the same component to exist and operate side-by-side on a system. For practical purposes, components may be collected into an assembly, which, when referring to items such as a component, is the lowest unit of storage packaged for activation, distribution and versioning, and isolation, as described herein. Rather than deal with individual components, of which there may be a relatively large number, many of the actions regarding components that are grouped together can be handled by referring to their assembly. For example, rather than list in the manifest the dependencies on a large number of individual components that are packaged together in an assembly, the manifest may simply list a dependency on the assembly. As used herein, the term \u201cassembly\u201d will refer to one or more components, whether referring to a single component (e.g., one contiguous DLL) or to a plurality of components grouped together.","Assemblies can be shared, such as when more than one application or the like needs an instance of the assembly's code. To provide significant flexibility while being transparent to existing and newly-developed applications, the present invention has been implemented in an operating system, with applications being run via the operating system. As will be understood, however, the present invention is not limited to applications and\/or an operating system implementation, but rather is capable of being implemented by virtually any mechanism internal or external to executable code (e.g., an application) that needs or wants to use a specific version of an assembly. Note that as used herein, an application program is not limited to any particular type of software product, but includes any executable code such as operating system components, drivers and so on that in turn use other assemblies. Notwithstanding, the present invention will be primarily described with an application that uses assemblies including DLLs, resources and objects.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"sub":["1","m","1","m ","1 ","1 ","1","1","1","m "],"b":["200","200","141","100","200","202","204","206","202","202"]},"Although the application manifest lists its dependencies on assembly versions, it should be noted that technically, the application is only dependent on the manifest-specified assemblies themselves, not necessarily the exact versions that are specified. Instead, the specified versions are only those which have been tested with the application. In one implementation, another version of a needed assembly can replace the application-preferred version when additional information is available to the assembly loading mechanism (e.g., an operating system component). For example, as also described in copending U.S. patent application entitled \u201cConfigurations for Binding Software Assemblies to Applications\u201d Ser. No. 09\/842,278, assigned to the assignee of the present application, filed concurrently herewith, and hereby incorporated by reference, policy data (configurations) and\/or an assembly manifest associated with the specified assembly may override the version information set forth in the application manifest. Nevertheless, it is expected that such policies and assembly manifests will be used conservatively, e.g., only for important fixes and\/or after thorough testing, since they will cause replacement of the trusted assembly version.","Two types of assemblies are possible, those having strong names, e.g. including a public key signature or the like such that any two different assemblies can be unambiguously identified, and those having a simple name, which may be ambiguous in the context of an application and, for example, do not contain a public key. To provide isolation, any simply-named assemblies on which an application manifest specifies a dependency are treated as privatized. Privatized assemblies are those that the application does not intend to be shared with other applications. Privatized assemblies that have simple names are normally installed into the same folder as the executable application code, whereby the assembly is isolated and the application is given the effect of being monolithic, e.g., its assemblies are not influenced by different assemblies having the same simple name, and so forth. By not being shared, privatized assemblies with simple names thus have the benefit of virtually complete isolation, at the expense of the benefits obtained by sharing. Assemblies having strong names do not need to be placed into the application folder for isolation purposes, because assemblies with strong names are known to be the exact one the application needs. Thus, instead of being privatized by storing in a certain directory, such assemblies may be placed into a global assembly cache  to obtain the benefits of sharing, while effectively preserving isolation, because an application that asks for a strongly named assembly will get a copy that is exact.","Note that as represented in , the assembly cache  appears as a distinct container, however it may be a logical container, and does not have to correspond to a common folder or the like in the file system. For example, the assembly cache may comprise multiple folders to improve performance. Moreover, as long as the operating system maintains some map as to their actual location, the assemblies may be distributed among various folders of the file system, or even other file system volumes, on the same or other machines. For example, a given assembly may be maintained on a network file server. Indeed, it should be noted that any of the software files\/data structures described herein may be remotely maintained and downloaded. Notwithstanding, maintaining the assembly cache in a set of one or more folders has advantages, including that a dedicated set of folders can be accessed-controlled in an efficient manner, a scattered assembly cache would have to track folder movement and so on. In any event, the assembly cache will be considered herein as a single container (e.g., comprising one or more folders) accessible by the operating system when an assembly is needed.","As further represented in , the application executables, application manifest and assemblies -are maintained (e.g., as files) in non-volatile storage . More particularly, in one implementation, when the application is installed onto a computer system, the application manifest is copied to the application's folder (the same one that contains the application executable file), while the strongly-named assembly files (e.g., and ) are copied to the side-by-side assembly cache . Note that to provide side-by-side existence of assembly versions, any existing assembly versions are not overwritten in the assembly cache  when another version is installed, (although a version can be removed by other means, at the risk of breaking an application that depends on that version). The assembly cache can be hidden and\/or access controlled to prevent assemblies from being easily removed.","Privatized assemblies that are not strongly named are copied to the application folder, as described above. To this end, an installer or the like contacts the operating system, which then directs the installer as to where (e.g., what folder) to install any given application files or assembly files based on the manifest type, file name data (strong or simple), and\/or other installation information. In this manner, any privatized assemblies with simple names are installed into the same folder as the executable application code, as described above, while sharable assemblies are stored in the assembly cache .","The assembly manifest is preferably copied to the assembly cache  with its corresponding assembly at the time of installation. The assembly manifest describes the assembly and includes information about its individual assembly, including, for example, the name and version of the assembly, the items (program files, resources) that make up the assembly, and the binding path to items within the assembly (e.g., for Win32 DLLs this is the location of the DLL relative to the root of the assembly, whereas for COM Servers this is the CLSID (class identifier), ProgID (programmatic identifier) and other COM metadata). The assembly manifest may also include any dependencies on other assemblies, object classes and global names.","Example manifests in XML format are set forth in the tables below, wherein TABLE1 is an example of a simple application manifest where the application depends on a side-by-side version of COMCTL32:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d standalone=\u201cyes\u201d?>"]},{"entry":[{},"<assembly xmlns=\u201curn:schemas-microsoft-com:asm.v1\u201d"]},{"entry":[{},"manifestVersion=\u201c1.0\u201d>"]},{"entry":[{},"<assemblyIdentity"]},{"entry":[{},"\u2003version=\u201c1.0.0.0\u201d"]},{"entry":[{},"\u2003processorArchitecture=\u201cX86\u201d"]},{"entry":[{},"\u2003name=\u201cMicrosoft.Windows.mysampleApp\u201d"]},{"entry":[{},"\u2003type=\u201cwin32\u201d"]},{"entry":[{},"\/>"]},{"entry":[{},"<description>Your app description here<\/description>"]},{"entry":[{},"<dependency>"]},{"entry":[{},"\u2003<dependentAssembly>"]},{"entry":[{},"\u2003\u2003<assembly.Identity"]},{"entry":[{},"\u2003\u2003\u2003type=\u201cwin32\u201d"]},{"entry":[{},"\u2003\u2003\u2003name=\u201cMicrosoft.Windows.Common-Controls\u201d"]},{"entry":[{},"\u2003\u2003\u2003version=\u201c6.0.0.0\u201d"]},{"entry":[{},"\u2003\u2003\u2003processorArchitecture=\u201cX86\u201d"]},{"entry":[{},"\u2003\u2003\u2003publicKeyToken=\u201c6595b64144ccf1df\u201d"]},{"entry":[{},"\u2003\u2003\u2003language=\u201c*\u201d"]},{"entry":[{},"\u2003\u2003\/>"]},{"entry":[{},"\u2003<\/dependentAssembly>"]},{"entry":[{},"<\/dependency>"]},{"entry":[{},"<\/assembly>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"TABLE2 is an example of an application manifest where the application depends on a side-by-side version of COMCTL32 and an assembly is privatized to the application:",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d standalone=\u201cyes\u201d?>"},{"entry":"<assembly xmlns=\u201curn:schemas-microsoft-com:asm.v1\u201d"},{"entry":"manifestVersion=\u201c1.0\u201d>"},{"entry":"<assemblyIdentity"},{"entry":"\u2003version=\u201c1.0.0.0\u201d"},{"entry":"\u2003processorArchitecture=\u201cX86\u201d"},{"entry":"\u2003name=\u201cMicrosoft.Windows.mysampleApp\u201d"},{"entry":"\u2003type=\u201cwin32\u201d"},{"entry":"\/>"},{"entry":"<description>Your app description here<\/description>"},{"entry":"<dependency>"},{"entry":"\u2003<dependentAssembly>"},{"entry":"\u2003\u2003<assemblyIdentity"},{"entry":"\u2003\u2003\u2003type=\u201cwin32\u201d"},{"entry":"\u2003\u2003\u2003name=\u201cMicrosoft.Windows.Common-Controls\u201d"},{"entry":"\u2003\u2003\u2003version=\u201c6.0.0.0\u201d"},{"entry":"\u2003\u2003\u2003processorArchitecture=\u201cX86\u201d"},{"entry":"\u2003\u2003\u2003publicKeyToken=\u201c6595b64144ccf1df\u201d"},{"entry":"\u2003\u2003\u2003language=\u201c*\u201d"},{"entry":"\u2003\u2003\/>"},{"entry":"\u2003<\/dependentAssembly>"},{"entry":"<\/dependency>"},{"entry":"<!-- Privatized assembly -->"},{"entry":"<file name=\u201cmypaint.dll\u201d>"},{"entry":"\u2003\u2003<comClass description=\u201cFont Property Page\u201d"},{"entry":"clsid=\u201c{0BE35200-8F91-11CE-9DE3-00AA004BBB51}\u201d\/>"},{"entry":"\u2003\u2003<comClass description=\u201cColor Property Page\u201d"},{"entry":"clsid=\u201c{0BE35201-8F91-11CE-9DE3-00AA004BB851}\u201d\/>"},{"entry":"\u2003\u2003<comClass description=\u201cPicture Property Page\u201d"},{"entry":"clsid=\u201c{0BE35202-8F91-11CE-9DE3-00AA004BB851}\u201d\/>"},{"entry":"\u2003<\/file>"},{"entry":"\u2003<file name\u201cmydraw.dll\u201d\/>"},{"entry":"\u2003<file name=\u201ctestct132.dll\u201d>"},{"entry":"\u2003\u2003<windowClass>ToolbarWindow32<\/windowClass>"},{"entry":"\u2003\u2003<windowClass>ComboBoxEx32<\/windowClass>"},{"entry":"\u2003\u2003<windowClass>testctls_trackbar32<\/windowClass>"},{"entry":"\u2003\u2003<windowClass>testctls_updown32<\/windowClass>"},{"entry":"\u2003\u2003<windowClass>testctls_progress32<\/windowClass>"},{"entry":"\u2003<\/file>"},{"entry":"\u2003<file"},{"entry":"\u2003\u2003name=\u201cnew\\SxS_COM.dll\u201d>"},{"entry":"\u2003\u2003<comClass"},{"entry":"\u2003\u2003\u2003description=\u201cSxSTestObject Class\u201d"},{"entry":"\u2003\u2003\u2003clsid=\u201c{F3B09421-5A10-4756-98AF-7A447E07D3C2}\u201d"},{"entry":"\u2003\u2003\u2003threadingModel=\u201cApartment\u201d"},{"entry":"\u2003\u2003\u2003tlbid=\u201c{B21102B9-90DF-4841-BEAC-41F68CD94BDC}\u201d"},{"entry":"\u2003\u2003\u2003progid=\u201cSxS_COM.SxS_COMObject.1\u201d>"},{"entry":"\u2003\u2003\u2003<progid>\u201cSxS_COM.SxS_COMObject \u201d<\/progid>"},{"entry":"\u2003\u2003\u2003<\/comClass>"},{"entry":"\u2003\u2003<interface"},{"entry":"\u2003\u2003\u2003iid=\u201c{D8C178A3-F275-4EAB-B6F4-896B5B9A0FC0}\u201d"},{"entry":"\u2003\u2003\u2003name=\u201cISxSTestObject\u201d"},{"entry":"\u2003\u2003\u2003proxystubclsid=\u201c{00020424-0000-0000-C000-"},{"entry":"000000000046}\u201d"},{"entry":"\u2003\u2003\u2003proxystubclsid32=\u201c{00020424-0000-0000-C000-"},{"entry":"000000000046}\u201d"},{"entry":"\u2003\u2003\u2003tlbid=\u201c{B21101B9-90DF-4841-BEAC-41F68CD94BDC}\u201d\/>"},{"entry":"\u2003\u2003<typelib"},{"entry":"\u2003\u2003\u2003tlbid=\u201c{B21101B9-90DF-4841-BEAC-42F68CD94BDC}\u201d"},{"entry":"\u2003\u2003\u2003version=\u201c1.0\u201d"},{"entry":"\u2003\u2003\u2003description=\u201cSxS_COM 1.0 Type Library\u201d"},{"entry":"\u2003\u2003\u2003helpdir=\u201cnew\u201d\/>"},{"entry":"\u2003<\/file>"},{"entry":"<\/assembly>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Assemblies may be dependent on other assemblies, which in turn are dependent on other assemblies, and so on. To ensure the proper versions of dependent assemblies, one or more of the assemblies -(e.g., assembly ) may have an assembly manifest associated therewith that provides assembly dependency data . To this end, assembly authors that create side-by-side assemblies may also author an assembly manifest with each assembly, and have that assembly manifest evaluated for proper version dependencies. Note that although not separately shown in , it is understood that each other assembly in the assembly cache  may have an assembly manifest associated therewith.","A sample assembly manifest is set forth in TABLE3 below:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d standalone=\u201cyes\u201d?>"},{"entry":"<assembly xmlns=\u201curn:schemas-microsoft-com:asm.v1\u201d"},{"entry":"manifestVersion=\u201c1.0\u201d>"},{"entry":"\u2003<assemblyIdentity type=\u201cwin32\u201d"},{"entry":"name=\u201cMicrosoft.Tools.VisualCPlusPlus.Runtime-Libraries\u201d"},{"entry":"version\u201c6.0.0.0\u201d processorArchitecture=\u201cx86\u201d"},{"entry":"publicKeyToken=\u201c6595b64144ccf1df\u201d\/>"},{"entry":"\u2003<file name=\u201cmfc42u.dll\u201d"},{"entry":"hash=\u201c3eab067f82504bf271ed38112a4ccdf46094eb5a\u201d"},{"entry":"hashalg=\u201cSHA1\u201d>"},{"entry":"\u2003\u2003<comClass description=\u201cFont Property Page\u201d"},{"entry":"clsid=\u201c{0BE35200-8F91-11CE-9DE3-00AA004BB851}\u201d\/>"},{"entry":"\u2003\u2003<comClass description=\u201cColor Property Page\u201d"},{"entry":"clsid=\u201c{0BE35201-8F91-11CE-9DE3-00AA004BB851}\u201d\/>"},{"entry":"\u2003\u2003<comClass description=\u201cPicture Property Page\u201d"},{"entry":"clsid=\u201c{0BE35202-8F91-11CE-9DE3-00AA004BB851}\u201d\/>"},{"entry":"\u2003<\/file>"},{"entry":"\u2003<file name=\u201cmfc42.dll\u201d"},{"entry":"hash=\u201cac72753e5bb20446d88a48c8f0aaae769a962338\u201d"},{"entry":"hashalg=\u201cSHA1\u201d\/>"},{"entry":"\u2003<file name=\u201catl.dll\u201d"},{"entry":"hash=\u201ca7312a1f6cfb46433001e0540458de60adcd5ec5\u201d"},{"entry":"hashalg=\u201cSHA1\u201d>"},{"entry":"\u2003\u2003<comClass description=\u201cRegistrar Class\u201d"},{"entry":"clsid=\u201c{44EC053A-400F-11D0-9DCD-00A0C90391D3}\u201d"},{"entry":"progid=\u201cATL.Registrar\u201d\/>"},{"entry":"\u2003\u2003<interface iid=\u201c{B6EA2051-048A-11D1-82B9-"},{"entry":"00C04FB9942E}\u201d name=\u201cIAxWinAmbientDispatch\u201d"},{"entry":"proxyStubClsId32=\u201c{00020424-0000-0000-C000-000000000046}\u201d\/>"},{"entry":"\u2003\u2003<typelib tlbid=\u201c{44EC0535-400F-11D0-9DCD-"},{"entry":"00A0C90391D3}\u201d version=\u201c1.0\u201d helpdir=\u201c\u201d\/>"},{"entry":"\u2003<\/file>"},{"entry":"\u2003<file name=\u201cmsvcrt.dll\u201d"},{"entry":"hash=\u201cba62960ceb15073d2598379307aad84f3a73dfcb\u201d"},{"entry":"hashalg=\u201cSHA1\u201d\/>"},{"entry":"\u2003<file name=\u201cmsvcirt.dll\u201d"},{"entry":"hash=\u201c84eb92153ff379c67c2727cc7f6931e011ff8121\u201d"},{"entry":"hashalg=\u201cSHA1\u201d\/>"},{"entry":"\u2003<file name=\u201cmsvcp60.dll\u201d"},{"entry":"hash=\u201c96952787a1676e38107ab93c6a33b9bcda1c912e\u201d"},{"entry":"hashalg=\u201cSHA1\u201d\/>"},{"entry":"<\/assembly>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Among other things, an assembly manifest can specify (e.g., in an XML format) an assembly's dependency on a particular version of an assembly. For example, in , the assembly manifest includes metadata that will instruct the operating system that assemblyversion 4.2.2.1 has a dependency on assemblyversion x.x.x.x. In addition to dependency information, an assembly manifest can contain an instruction that overrides application manifest version information, such as to specify that one version of an assembly should be used instead of another. For example, in , the assembly manifest associated with the assembly includes metadata instructing the operating system to substitute version 6.0.0.4, i.e., the assembly , whenever there is a request to use version 6.0.0.3 (the assembly ). In this manner, an assembly author may override the version specified by an application manifest, or, like an application, may specify a dependency on a given assembly version.","Note that although not shown in , a later-installed application policy can also change an application manifest's requested assembly version such that the existing manifest does not have to be replaced or have its contents modified to allow an application to effectively change what is in its original (e.g., shipped and installed with the application code) manifest. In other words, via the application policy, the original manifest does not have to be reinstalled or modified to change a dependency. The application policy settings can also bypass an assembly manifest's version overrides, and a system policy can override any other versioning metadata. In this manner, a flexible architecture is provided in which application authors and assembly authors, as well as system administrators, may create safe, isolated applications by simply creating declarative manifests or policies that control the dependencies on shared assemblies, while enabling changes to dependencies to be made when necessary. These and additional aspects of the architecture, including methods for resolving which version will be loaded when the various manifests and policies provide different instructions, are further described in the aforementioned U.S. patent application Ser. No. 09\/842,278, entitled \u201cConfigurations for Binding Software Assemblies to Applications.\u201d","In accordance with one aspect of the present invention, the metadata in an application manifest and the metadata in appropriate assembly manifests is used during the creation of an activation context for the application to provide an efficient way to load the correct version of an assembly for the corresponding application. As a result, when an application uses the side-by-side assemblies, the application code does not have to change internally to reflect the version of the assembly being used, e.g., the application simply executes its code generally rather than perform different operations each tailored to a particular assembly version. For example, in , for application , the metadata of the application manifest and the metadata and in assembly manifests and , respectively, is analyzed and used to load the correct assembly versions. Note that manifest metadata need not specify an exact version, but may alternatively specify a range of acceptable versions.","As represented in , when one (or more) of a set of activation APIs (application programming interfaces)  are called in response to a request to run an application program, the activation APIs  cause a persistable activation context  for that program to be constructed if a valid one does not already exist for the application, (for example, when the application is being run for the first time or the activation context  exists but its information is invalid). To construct the activation context , the activation APIs call (or otherwise include) an initialization mechanism , wherein the call is generally represented in  by the arrow accompanied by the circled numeral one (1). If a new activation context  needs to be constructed, the initialization mechanism  reads and interprets the application manifest as represented in  by the arrows labeled with circled numerals two (2) and three (3). The initialization mechanism  also reads (circled numerals four (4) through seven (7)) and interprets the assembly manifests and to obtain any dependency\/override information therein. Although not separately shown in , if the assembly manifests specify dependencies on other assemblies, the assembly manifests of those other assemblies are read, and so on, until there are no remaining dependencies to handle. In general, the initialization mechanism  essentially constructs a dependency graph or other list that comprises a full set of assemblies that the application and its dependent assemblies, and their dependent assemblies, and so on, will need, and with the completed dependency graph, constructs the activation context  (the arrow labeled with circled numeral eight (8). In general, there is an activation context  for each application that has an expressed assembly dependency, and each activation context includes a mapping table preferably hashed for quick lookup.","It should be noted that not every assembly used by an application needs to be specified in the application manifest, nor does each assembly manifest have to specify all of its dependent assembly versions, only those versions wherein there is a particular version desired. This is because the architecture described herein allows a default assembly version to be used when a particular version of an assembly is not specified in a manifest. Normally, when more than one version of an assembly is available, the default assembly is the most-recent version, however it is possible for an administrator or user to set (e.g., via interaction with the operating system through a dialog box, property sheet or the like) any version as a default.","In keeping with the present invention, the activation context  for an application maps version-independent assemblies that are requested by an application to the versions that are specified in the application manifest and\/or assembly manifests. By way of example,  represents some of the information that may be maintained in an activation context, e.g., an activation context constructed for the application . In , the activation context includes a table of contents  (e.g., providing offsets to its recordsets) for rapid access to the data therein.","Once created, the activation context is maintained in a persistable binary form for caching. Preferably, a new activation context is recomputed each time the application is launched, and freed when the application is closed. However, in one alternative, the activation context may be preserved, e.g., to a non-volatile storage. If preserved, because policy or the like may change the dependency information therein, (e.g., a new assembly manifest has been installed), the activation context may include a cache coherency section  that is used to detect whether the saved activation context is valid, wherein when the activation context is not coherent with current policy, it is recomputed. A section per API that implements version-specific binding is maintained.","To map the application's requests to the proper assembly versions, the activation context includes a DLL redirector section  and an object class redirector section . The DLL redirector section  includes a record or the like for each DLL dependency that includes fields (e.g., and ) that relate the DLL name used by an application to the exact pathname of the version specified in the application manifest and\/or assembly manifest. The object class redirector section  includes a record or the like for each object class (e.g., Windows\u00ae object class) on which an application depends, wherein each record includes fields (e.g., , , and ) that relate the object class name used by an application to the DLL file it is in and a version specific name. Note that the fields are arranged in a manner that optimizes lookup, e.g., the application-provided request data corresponds to the search key, and the records may be arranged in any way (e.g., alphabetically, by frequency, linearly, binary or so on) to speed searches.","Via the activation context, during runtime, an application's requests for assemblies can be efficiently satisfied with the correct version of that assembly. If a given assembly is not found in the activation context data, the default assembly is used. To summarize, when an application first runs, the activation context built from the manifest data is cached, whereby the global, version-independent named objects requested by an application are mapped to version-dependent named objects as specified in the manifest. As the application executes and requests a named object via one of the activation APIs, the version-independent named objects are applied in a version specific fashion by accessing the application context, whereby the application gets the correct version.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 5","b":["202","300"],"sub":["1 ","1"]},"When the application API receives the request, the request data (e.g., the application provided name) is passed to a runtime version-matching mechanism  (the arrow labeled two (2)). The runtime version-matching mechanism  locates the correct activation context for the calling application , and accesses the records therein to determine the correct version of the requested assembly (the arrows labeled three (3) and four (4)). Via the tables in the activation context , the runtime version-matching mechanism  will either return (e.g., as a return parameter, with the arrow labeled five (5)) the path and filename of the version-specific assembly, or a not-found status or the like (and\/or the path and filename of the default file) to the activation API that called it, in which case the activation API will load the default assembly. As represented in  by the arrows labeled six (6) through eight (8), the activation API accesses the assembly cache  to load the correct version of the assembly. Note that alternatively, the runtime version-matching mechanism  may access the assembly cache  on behalf of the API to obtain and\/or load the correct version, which is either the one listed in the records or the default version if none was found. In any event, the correct assembly version  is loaded and the activation API returns from the call to the application , (the arrow labeled nine (9)), and the application can use the loaded assembly  (the arrow labeled ten (10)).","Turning to an explanation of the operation of the present invention with particular reference to the flow diagrams of ,  and , as described above, the mapping of an application to a specified version of an assembly or other data structure essentially comprises two phases, an initialization phase () and a runtime phase (). In general, the initialization phase constructs the activation context, if needed, that maps version-independent assemblies to version-specific assemblies based on the dependencies (and other instructions) in the various manifests. Then, during a runtime phase, (), the activation context is accessed as needed to rapidly locate and load the appropriate versions when an application requests an assembly that it needs. Note that although it is feasible to eliminate the initialization phase by walking the various manifest data to locate the correct version on each request, such requests are frequently made during an application's runtime, and it is thus more efficient to construct the context once and thereafter access it on each request.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 6","FIG. 6"],"b":["304","600","304","602"]},"When step  determines that an application manifest exists, the initialization mechanism  () preferably branches to step  to create the activation tables. Alternatively, if activation contexts may be preserved rather than recomputed each runtime, the initialization mechanism  may check for an existing activation context (e.g., ) for the application. If an existing activation context is found, step  branches to step  to validate it, otherwise step  branches to step . Step  checks the activation context to determine if it is coherent with current configuration, and if so, the existing activation context  can be used (step ) and the initialization process ends. If alternatively the activation context  is not coherent with current configuration at step , for example, because a more recent configuration has been provided to the system, the initialization process continues to step  to recompute a new activation context .","In the event that the initialization process continues to step  to create the activation context, step  represents obtaining the binding information from the application manifest. Steps , ,  and  of  are executed, along with the steps of , essentially to walk through the various manifests in order to build up a dependency graph, replacing assembly information (nodes) as necessary in the dependency graph and adding any new nodes to include the dependencies of any assembly manifests.","By way of example,  operates once the application manifest has it dependent assemblies added to the dependency graph (step  of ) and an assembly (node) therein has been selected (step , e.g., via a top-down, left-to-right or other suitable progression). At step  if a selected assembly in the graph has an assembly manifest, step  branches to step , otherwise there are no dependencies or replacements to deal with for this assembly, and the process returns to  to handle any assemblies that have not been handled. If there is an assembly manifest, step  tests whether the assembly manifest includes data specifying that the assembly should be replaced with another version. If so, the new version replaces it in the dependency graph, and the process returns to step  to evaluate that version's assembly manifest, (if any). For example, in , (wherein  shows a dependency graph  corresponding to the assemblies identified in ), the assemblyversion 6.0.0.2is replaced by the assembly manifest with version 6.0.0.3.This in turn may have an assembly manifest that causes its replacement, and so on, until an assembly manifest is found that does not specify a further replacement.","When the appropriate assembly is in the graph following any possible replacements, step  branches to step  wherein any dependencies listed in the current assembly's manifest are added to the dependency graph. For example, in , the assemblyhas a dependency on the assembly, whereby assembly's information is added to the graph . In this manner, the correct assembly versions of those specified in the manifests will wind up in the dependency graph. Note that although not shown in , only dependent assemblies not already listed in the graph will have new nodes added therefor, so that each assembly is only selected and handled once, e.g., a pointer can go in the graph to an existing dependency rather than add a new node, thereby eliminating circular dependencies. The process continues to step  to mark the selected assembly as having been handled, before returning to  to select another assembly for handling, until none remain. When the assemblies have been handled at step , the dependency graph is used to construct the activation context at step , essentially by filling in the fields with the correct version information for each assembly present in the graph. Note that a simple list can be used instead of a graph, however a graph provides information about the relationships between assemblies as well as which ones are used, which can be used to construct a more efficient activation context. When constructed, the activation context is copied to the child process in the operating system data structure's defined environment process, making it the process default.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 9","FIG. 9"]},"Beginning at step  the activation API receives the application request including the version-independent assembly name, not the version specific name, and passes it as a parameter or the like to the runtime version matching mechanism, where it is received at step . If an entry for the name is in the activation context at step , the runtime version matching mechanism returns the version specific information (e.g., including the path and filename of the correct version) based on the manifest at step . If an entry for the name is not found in the activation context at step , at step  the runtime version matching mechanism returns a not found status, (or alternatively can determine and return the path and filename of the default version). At step , the activation API loads appropriate version, and returns a loading status or the like. The operating system also maps any uses of this named object to the appropriate version to allow for multiple versions of the code module to run simultaneously without interfering with each other, whereby, for example COM object data is isolated per object. At this time, the correct version as specified in the manifests is loaded, even though the application's executable code did not specify any version. Indeed, by providing an associated manifest that can be stored into the application's directory, an already existing application (e.g., written and installed before the present invention) can benefit from the present invention.","By way of a further example, consider two versions of an object class container, COMCTL32 version six (v6), and COMCTL32 version seven (v7), both of which have a SysListView object class therein. When the application launches for the first time, the operating system reads the manifest and creates version-specific classes for items listed in the manifest, for example, the application manifest has listed v and this has not been overridden. The activation context is created and the object class created for SysListView, wherein the version number for the COMCTL32 object class container and the SysListView object class is v6, as specified in the application manifest.","When the application program is running and requests an object class, the application does so as it always has, that is, by specifying the object, SysListView, without specifying any version information. However, based on the activation context, the appropriate version name of SysListView (in this example corresponding to V6) will be automatically returned and version v6 of the object will be located. As is understood, the application developer need not modify the application in any way to get the appropriate version, but instead only needs to provide a suitable application manifest.","In this manner, instead of having a system default of a single control such as SysListView in COMCTL32 that the processes use, multiple side-by-side versions of SysListView can be available and running. Each process has the option to choose the specific version to use. Moreover, because more metadata is being maintained about the runtime, self-healing systems are possible. For example, if an application fails, the operating system may intelligently use this metadata to repair the problem.","As can be seen from the foregoing detailed description, there is provided a method, system and infrastructure to version globally named objects in the system. Application authors may create safe, isolated applications by simply creating a declarative manifest that describes dependencies on these shared objects, without needing to be concerned with coding the application to adjust to the version of the assembly being used. By the present invention, assemblies can be safely shared and applications can be more completely isolated.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 6 and 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
