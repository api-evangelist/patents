---
title: System and method for performing garbage collection based on unmanaged memory allocations
abstract: The techniques and mechanisms described herein are directed to a method for performing garbage collection based on the total memory consumed by managed objects on a heap. The total memory includes heap memory and unmanaged memory. The garbage collector accepts input that indicates the amount of unmanaged memory and associates this amount with the managed object. The garbage collector then adjusts a collection strategy for the managed object based on the input. The input is sent to the garbage collector if the allocated amount meets a certain criteria in comparison with the size of the managed object on the heap. The amount may be automatically disassociated with the managed object when the managed is destroyed or the garbage collector may receive another input that removes the amount from being associated with the managed object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07822938&OS=07822938&RS=07822938
owner: Microsoft Corporation
number: 07822938
owner_city: Redmond
owner_country: US
publication_date: 20041020
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This document generally relates to memory management in a computer system, and more particularly, to a garbage collection process that manages the memory in a computer system.","Garbage collection, also commonly referred to as automatic memory management, attempts to automatically recycle dynamically allocated memory. Dynamically allocated memory is memory that is created at runtime and that is stored in an area of memory commonly referred to as the heap. There are several techniques that have been developed to perform garbage collection.","Each technique uses a collection strategy for determining when an object on the heap should best be recycled. Hereinafter, objects within the heap are referred to as managed objects. One collection strategy collects the managed objects based on the size (e.g., amount of memory) of the managed object. For example, this collection strategy may decide to clean up resources associated with a larger managed object earlier than a smaller managed object because collecting the larger managed object will free up more memory. Thus, by implementing a collection strategy that collects larger managed objects earlier than the smaller managed objects, the collection strategy minimizes the number of times the garbage collection process needs to run. This is beneficial because running the garbage collection process consumes resources and causes other programs to experience execution delays.","However, one problem with this collection strategy is that small managed objects may actually reference large amounts of unmanaged memory. Then, because the garbage collector bases its strategy on the size of the managed object, the garbage collector may wait to recycle these small managed objects until later. This is undesirable because each process is allowed a predetermined amount of total memory. The predetermined amount of total memory includes managed memory and unmanaged memory. Therefore, in order to efficiently manage its memory, the garbage collector may initiate a collection process more frequently on its larger objects with less success than if it had initiated the collection process on the smaller objects referencing large amounts of unmanaged memory.","In order to overcome this limitation, modules can directly invoke the garbage collection process on their own objects. Thus, by directly invoking the garbage collection process on its own small objects that reference large amounts of unmanaged memory, the garbage collection process can force the de-allocation of the unmanaged memory when it destroys the small objects. While this successfully overcomes the problem and recycles the smaller objects that may not have been automatically chosen for recycling, it is potentially very inefficient. For example, a module may consider that the allocation of one mega-byte of memory is a large amount and may directly invoke the garbage collector to recycle the object right away. However, the garbage collector may view this one megabyte allocation as inconsequential given a heap size of 1 Gbytes. These inefficiencies multiply when multiple modules each directly invoke the garbage collector. When this occurs, the garbage collection process may consume a large percentage of the computing resources and cause undesirable delays to other executing processes.","Thus, until now, there has not been a satisfactory solution for performing garbage collection when large allocations of unmanaged memory exist.","The techniques and mechanisms described herein are directed to a method for performing garbage collection based on the total memory consumed by managed objects on a heap. The total memory includes heap memory and unmanaged memory. The garbage collector accepts input that indicates the amount of unmanaged memory and associates this amount with the managed object. The garbage collector then adjusts a collection strategy for the managed object based on the input. The input is sent to the garbage collector if the allocated amount meets a certain criteria in comparison with the size of the managed object on the heap. The amount may be automatically disassociated with the managed object when the managed object is destroyed or the garbage collector may receive another input that removes the amount from being associated with the managed object.","Briefly, the present system and method increases the efficiency of garbage collection when managed objects reference unmanaged memory. This is achieved by communicating information about the amount of unmanaged memory to the garbage collector. The garbage collector then uses this information when determining which managed objects to collect. These and other advantages will become clear after reading the following detailed description.","Exemplary Computing Environment","The various embodiments of the present garbage collection technique may be implemented in different computer environments. The computer environment shown in  is only one example of a computer environment and is not intended to suggest any limitation as to the scope of use or functionality of the computer and network architectures. Neither should the computer environment be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the example computer environment.","With reference to , one exemplary system for implementing the present garbage collection technique includes a computing device, such as computing device . In a very basic configuration, computing device  typically includes at least one processing unit  and system memory . Depending on the exact configuration and type of computing device, system memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. System memory  typically includes an operating system , one or more program modules , and may include program data . This basic configuration is illustrated in  by those components within dashed line .","Computing device  may have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Thus, computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. These devices are well know in the art and need not be discussed at length here.","Computing device  may also contain communication connections  that allow the device to communicate with other computing devices , such as over a network. Communication connection(s)  is one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.","Various modules and techniques may be described herein in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc. for performing particular tasks or implement particular abstract data types. These program modules and the like may be executed as native code or may be downloaded and executed, such as in a virtual machine or other just-in-time compilation execution environment. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.","An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example, and not limitation, computer readable media may comprise \u201ccomputer storage media\u201d and \u201ccommunications media.\u201d",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["104","104","105","106","107","105","222","222","210","206","106","206","208","210","208","210","206","208","210","105","210","210","220","220","107"]},"Program data  includes a predetermined amount of memory for each process (e.g., processes , , and ). Although each block for processes - are shown equal sized, the predetermined amount of memory associated with each process may be different. As mentioned above, operating system  allots a predetermined amount of memory for each process. If a process attempts to utilize memory over this predetermined amount of memory, the memory manager  implements page faults rather than using additional memory. The memory used by a process (e.g., process ) includes a managed memory heap  and one or more unmanaged memory allocations (e.g., unmanaged object  and ). The managed memory heap  stores managed objects -. Managed objects - include static objects, global objects, local variables, pointers, and such for one of the associated applications  that is executing or that has executed. One or more of the managed objects (e.g., managed objects  and ) may include a reference to one or more of the unmanaged memory allocations  and . In , managed object  references unmanaged memory allocation  and managed object  references unmanaged memory allocation .","The garbage collector  is responsible for reclaiming memory from managed memory heap . In general, garbage collector  may be any conventional garbage collector that implements some collection strategy in determining how to reclaim memory from managed memory heap . The collection strategy attempts to pace the rate of collection (memory reclamation) to keep memory consumption and overhead in good balance. For example, if the collection strategy attempts too many garbage collections, CPU usage becomes too much. In contrast, if the collection strategy does not attempt garbage collections regularly, memory consumption becomes too large. Therefore, in accordance with the present garbage collection mechanism, garbage collector (GC)  also includes one or more GC application programming interfaces (APIs) . Briefly, described in detail later, GC APIs  provide a mechanism for communicating information about the amount of unmanaged memory associated with each managed object on the managed memory heap . The garbage collector  then utilizes this information when implementing its collection strategy for reclaiming memory from managed memory heap  so that memory consumption and CPU overhead are in good balance.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":["300","300","302","302","304"]},"At block , the garbage collector is informed of each allocation of unmanaged memory that meets a certain criteria. One exemplary technique for informing the garbage collector is illustrated by an API shown in . As one skilled in the art will appreciate, the garbage collector may be informed each time unmanaged memory is allocated, one time with the total amount of allocated unmanaged memory, or the like. In addition, the garbage collector may be informed based on a certain criteria. For example, the criteria may be that the amount of unmanaged memory associated with the managed object is five times the amount of managed memory associated with the managed object. By setting some criteria, the garbage collector does not have to perform additional processing to determine the affect of the unmanaged memory on the collection strategy if the amount of unmanaged memory is unlikely to affect the collection strategy. Thus, informing the garbage collector of the unmanaged memory causes the garbage collector to \u201cadd pressure\u201d to the collection strategy associated with the managed object, thereby, causing the managed object to be collected more frequently than without \u201cthe pressure\u201d. Processing continues to end.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4","b":["400","400","402","402","404"]},"At block , the garbage collector is informed of each de-allocation of unmanaged memory that was previously reported to the garbage collector. One exemplary technique for informing the garbage collector is illustrated by an API shown in . As one skilled in the art will appreciate, the garbage collector may be informed each time unmanaged memory is de-allocated, one time with the total amount of de-allocated unmanaged memory, or the like. It is important to note, that the garbage collector is informed of de-allocated unmanaged memory only for previously reported allocations of unmanaged memory. Processing continues to end.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 5","FIG. 3","FIG. 4","FIG. 5","FIG. 3","FIG. 4"],"b":["220","512","514","516","512","514","220","512","512","512"]},"In the embodiment in which programmers are responsible for adding the calls to APIs  and  to their constructors and destructors, respectively, programmers are encouraged to call API  for any managed object that has a reference to unmanaged memory that is more than five times the amount of memory allocated for the managed object from the managed heap. For smaller ratios, the overhead in reclaiming the associated managed object in relation to the amount of memory reclaimed is not sufficient to make the API  worthwhile. In addition, programmers are encouraged to call API  for any managed object when an indeterminable amount of unmanaged memory is allocated (e.g., file referenced). The programmers are also encouraged to make the call to API  when the unmanaged memory is allocated, typically, during the construction of the managed object. Likewise, programmers are encouraged to make the call to API  when de-allocating memory for an unmanaged allocation for which the garbage collector was previously notified using a call to API .","The following is a portion of exemplary pseudo-code illustrating an embodiment with APIs  and :",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class Bitmap {"},{"entry":"\u2002private long _size"},{"entry":"\u2002Bitmap ( string path ) {"},{"entry":"\u2003_size = new FileInfo(path).Length;"},{"entry":"\u2003GC.AddMemoryPressure ( _size );"},{"entry":"\u2003\/\/ insert additional constructor logic as needed including unmanaged"},{"entry":"\u2003allocation"},{"entry":"\u2002}"},{"entry":"\u2002~ Bitmap( ) {"},{"entry":"\u2003GC.RemoveMemoryPressure ( _size );"},{"entry":"\u2003\/\/ insert finalization code including de-allocation of unmanaged memory"},{"entry":"\u2002}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The above exemplary pseudo-code illustrates one call to API  for one or more allocations of unmanaged memory. The pseudo-code also illustrates one sequence for calling API  in relation to the allocation of the unmanaged memory and for calling API  in relation to the de-allocation of the unmanaged memory.","In another embodiment (shown within dashed box), instead of two APIs  and , there may be a single API , such as \u201cSetMemoryPressure\u201d. The single API minimizes the likelihood of using the API incorrectly. The single API accepts a long word that stores the amount of allocated unmanaged memory and accepts a pointer to the object to which the amount is associated. When the garbage collector receives the amount, it will determine whether or not to re-adjust its weighting system to include the amount in its determination of when to collect the instance. In contrast with the embodiment with two APIs, in the single API embodiment, the \u201cpressure\u201d is automatically removed from the object when the object instance is finalized. By performing the removal of pressure on the user's behalf, the ability to misuse the present garbage collection technique is reduced because forgetting to remove pressure after adding pressure will not occur.","Similar to the API , a programmer calls the single API when an instance is created. Preferably, the single API is called when the unmanaged resource associated with the object is first allocated. Typically, this will occur in the constructor. In order to automatically remove the pressure, the object to which the pressure is added includes a finalizer. Then, for any object having a finalizer, the garbage collector automatically removes the pressure that had been added to the managed object. If the single API is invoked on an object without a finalizer, an exception is thrown that indicates an invalid operation. If the single API is called twice, the value specified in the second (i.e., later) call replaces the value specified in the first call. Therefore, unlike the embodiment with two APIs, the calls to the single API are not cumulative.","The following is a portion of pseudo-code illustrating the embodiment with a single API:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Bitmap {"]},{"entry":[{},"\u2002private long _size"]},{"entry":[{},"\u2002Bitmap ( string path ) {"]},{"entry":[{},"\u2003_size = new FileInfo(path).Length;"]},{"entry":[{},"\u2003\/\/ insert additional constructor logic as needed"]},{"entry":[{},"\u2003GC.SetMemoryPressure( this, _size);"]},{"entry":[{},"\u2002}"]},{"entry":[{},"\u2002~ Bitmap( ) {"]},{"entry":[{},"\u2003\/\/ insert finalization code"]},{"entry":[{},"\u2002}"]},{"entry":[{},"}."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The above exemplary pseudo-code illustrates one call to API  for all the allocations of unmanaged memory. The pseudo-code also illustrates having a finalizer for any managed object that calls API .","Reference has been made throughout this specification to \u201cone embodiment,\u201d \u201can embodiment,\u201d or \u201can example embodiment\u201d meaning that a particular described feature, structure, or characteristic is included in at least one embodiment of the present invention. Thus, usage of such phrases may refer to more than just one embodiment. Furthermore, the described features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","One skilled in the relevant art may recognize, however, that the invention may be practiced without one or more of the specific details, or with other methods, resources, materials, etc. In other instances, well known structures, resources, or operations have not been shown or described in detail merely to avoid obscuring aspects of the present garbage collection technique.","While example embodiments and applications have been illustrated and described, it is to be understood that the present garbage collection technique is not limited to the precise configuration and resources described above. Various modifications, changes, and variations apparent to those skilled in the art may be made in the arrangement, operation, and details of technique disclosed herein without departing from the scope of the claimed invention. Thus, as described, the present technique increases the effectiveness of collection strategies based on the memory consumption of the managed object."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments are described with reference to the following figures, wherein like reference numerals refer to like parts through-out the various views unless otherwise specified.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 5","FIG. 3","FIG. 4"]}]},"DETDESC":[{},{}]}
