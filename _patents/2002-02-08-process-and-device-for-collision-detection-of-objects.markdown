---
title: Process and device for collision detection of objects
abstract: The present invention relates to a process and a device for the collision detection of objects by traversal of hierarcichal binary bounding BoxTrees, in which each bounding box pair of a hierarchically lower level is derived from a bounding box from the immediately above level by means of cutting off two sub-volumes by means of two parallel cut-planes. For the collision detection of a first and a second object, for each second bounding box of the bounding BoxTree of the second object to be checked for overlapping with a first bounding box of the bounding BoxTree of the first object, an auxiliary bounding box is computed which is axis-aligned in the object coordinate system of the first object and encloses the second bounding box with minimal volume, and with which the overlap check is conducted instead of with the second bounding box, and the computation results from the level immediately above are utilized for computation of auxiliary bounding boxes of lower levels. The process makes quick collision detection possible with low memory requirements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06862026&OS=06862026&RS=06862026
owner: Fraunhofer-Gesellschaft zur Foerderung der angewandten Forschung e.V.
number: 06862026
owner_city: Munich
owner_country: DE
publication_date: 20020208
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","STATE OF THE ART","DESCRIPTION OF THE INVENTION","WAYS OF CARRYING OUT THE INVENTION","LIST OF REFERENCE NUMBERS"],"p":["The present invention relates to a process and a device for collision detection of objects, in which first for the objects hierarchical binary bounding BoxTrees with axis-aligned bounding boxes in the respective object coordinate system and data are provided from which a position of the objects in relation to each other can be derived, which is yielded by conducting a planned transformation step of at least one of the objects, following which a simultaneous traversal of the bounding BoxTrees is conducted, in which checking for overlapping of the bounding boxes and possibly of polygons contained therein determines whether the objects will collide when executing the transformation step.","The described process is used in many fields of technology in which multi-dimensional geometric descriptions of objects are depicted and moved on a computer. For example, in many fields, the movement of three-dimensional objects is simulated by means of computer graphics. An essential step of the simulation is checking whether a just calculated object position is valid, e.g. is collisionfree. An example of a field of application is the field of robotics or remote control of robots, for instance in repairing satellites. Avoiding collisions is essential both in robotics in general as well as in the special field of remote control of robots. Therefore, before each movement step, it is necessary to check whether a step will lead to a collision, which is ensured by quick collision detection for the controlled objects. In robotics, in particular, a further object is path planning. In this case too, collision detection is an elemental step of the process.","Another example of a field of application of the present invention is computer animation systems such as virtual reality systems in which physical objects respectively their movement in a virtual environment are examined.","Computer-based processes of detecting collisions have been the subject of scientific investigation for a number of years. One of the first disciplines was computational geometry. However, its processes are very complex and can partially only be utilized for special geometric classes so that they are not useful for practical application.","K. Chung's \u201cQuick Collision Detection of Polytopes in Virtual Environments\u201d, Proc. of the ACM Symposium on Virtual Reality Software and Technology (VRST 96), M. Green, ed., pp. 125-131, 1996, presents a quick method of collision detection, which however, can only be used for a special geometric class of convex objects. In practical applications, however, this special case is extremely rare so that this method cannot be utilized for the fields of application mentioned in the introduction.","The hitherto known quickest methods of general collision detection are predominantly based on so-called hierarchical bounding volume trees. These are trees whose nodes are bounding volumes which enclose part of the geometry of the object. These bounding volumes may be balls, hexahedra (so-called boxes), cylinders or any other suited volume.","For example, a method of collision detection of objects is known from G. Zachmann's \u201cThe BoxTree: Enabling Real-Time and Exact Collision Detection of Arbitrary Polyhedra\u201d, Informal Proc. First Workshop on Simulation and Interaction in Virtual Environments\u201d, SIVE 95, University of IOWA, IOWA City, July 1995, Pages 104-112, in which hierarchical bounding volume trees whose nodes are hexahedra are employed. For each object to be checked for collision, such a bounding BoxTree, in the present case a binary bounding BoxTree is provided or computed. The bounding boxes are axis-aligned in the object coordinate system of the object to which they are allocated, i.e. their boundary lines run parallel to the axes of this object coordinate system. The root of a bounding BoxTree represents a hexhedra, which completely encloses the respective object. From each hexahedra respectively from each box of a hierarchical level two new boxes are derived for the hierarchical level below, in that the box of the above level is divided into two part volumes which correspond to the new bounding boxes by means of an axis-aligned cut-plane. The bounding boxes of the bottom hierarchical level, the so-called leaves of the tree, just enclose one or several polygons of the geometry of the object.","In the collision check with such a type of method, the intended movement, i.e. the transformation step, of at least one of the objects, is first conducted on a computer. Then the bounding BoxTrees of both objects are traversed according to the given hierarchy. During traversal, the bounding boxes of the bounding BoxTree of the two objects are checked for any overlapping in order to determine whether the objects will collide when carrying out the transformation step. If any overlapping of the bounding boxes down to the leaves of the trees is determined, the polygons contained in the leaves are checked for overlapping. If overlapping does occur, the two objects will collide. If no overlapping of the checked bounding boxes or of the polygons contained in the leaves is determined, the planned transformation step will not lead to a collision of the objects.","In order to utilize such a type method in robotics or in virtual reality, collision detection has to occur in real time and should require as little memory capacity as possible.","The object of the present invention is to provide a process and a device for collision detection of objects, which permits very quick collision detection with little memory capacity requirements.","The object is solved with the process and the device according to the claims. Advantageous embodiments of the process and the device are the subject matter of the subclaims.","In the present method of collision detection of objects, first for the objects hierarchical binary bounding BoxTrees with axis-aligned bounding boxes in the respective object coordinate system are provided. Furthermore, data are provided from which a position of the objects in relation to each other can be derived, which is yielded by conducting a planned transformation step of at least one object. Following this, simultaneous traversal of the bounding BoxTrees is conducted, in which checking for overlapping of the bounding boxes and possibly of polygons contained therein determines whether the objects will collide when the transformation step is executed. The present process is distinguished by bounding BoxTrees being provided in which each bounding box pair of a hierarchical lower level is derived from a bounding box of the hierarchical level lying immediately above by cutting off two part volumes by means of two parallel cut-planes. For the collision detection of a first and second object, an auxiliary bounding box, which is axis-aligned in the object coordinate system of the first object and contains the second bounding box with minimal volume and with which the overlapping check is conducted instead of with the second bounding box, is computed for each second bounding box of the bounding BoxTree of the bounding BoxTree of the second object to be checked for overlapping with a first bounding box of the bounding BoxTree of the first object. The computation results of the immediately above level are used to compute the auxiliary bounding boxes of lower levels.","The process described here and the respective device are suited for quick collision detection of polygon geometric objects. For the mentioned fields of application, these are usually three-dimensional. However, the process and the device are also suited for geometry of any dimension. A condition of the process, however, is that the geometry of the object is not deformed during this transformation step.","Hierarchical collision detection always is composed of two parts: a pre-processing step and the actual collision detection. The pre-processing step has to be conducted only once for a given geometry of the object. The second part, the actual collision detection is conducted with each collision check.","The proposed process is primarily concerned with actual collision detection. The pre-processing step with which the auxiliary data structures, i.e. the bounding BoxTrees of the objects, are generated is not necessarily a component of the present process. This pre-processing step may occur any time prior to conducting the present process. Computation processes for construction of bounding BoxTrees are familiar to someone skilled in the art. An example of this, is found for instance in the previously mentioned publication by G. Zachmann. Of course, the speed of collision detection may also be influenced by the quality of the provided bounding BoxTree.","The present process respectively the present device receives as input two objects, their respective bounding BoxTrees and a transformation matrix for the object to-be-moved. If both objects are moved, two transformation matrixes or a transformation matrix derived therefrom are provided. The transformation itself can contain a translation, a rotation as well as a uniform scaling. The process generates as output a yes\/no reply as well optionally\u2014in the case of a determined collision\u2014all overlapping polygon pairs.","Hierarchical collision detection, as in the present process, is always based on a divide-and conquer-strategy. In the following, by way of example, a pattern of such a strategy is described in connection with FIG. . The figure shows, as an example, a two-dimensional representation of objects P and Q to be tested for collision after a transformation step. Each object is surrounded by a box a respectively b, which represents the root of the respective hierarchical bounding BoxTree. Further boxes, so-called children representing a sub-volume of the hierarchical box above are created from these roots in the next lower hierarchical level. Thus  shows that the box a of object P is divided into two sub-boxes aand aand box b of the object Q into the boxes band b. This continues in the same manner in the next lower level where for example the two boxes aand aare formed from box a. During traversal, the two bounding BoxTrees for object P and Q, the respective boxes are checked for overlapping in each level. If no overlapping of boxes is determined, traversal is ended with the result no overlapping. If overlapping is determined, traversal continues into the leaves of the trees and the polygons there are checked for overlapping. If overlapping of the polygons is determined, the objects collide. If no overlapping is determined there is no collision. This general divide-and-conquer strategy pattern can be summarized as follows for simultaneous traversal of two bounding volume (BV) trees:","a=BV from the tree of object P,","b=BV from the tree of object Q,","a[i], b[i]=children of a respectively b\n\n","if a is a leaf:\n\n","return","if a is no leaf:\n\n","if a is a leaf:\n\n","if a is no leaf:\n\n","In order to be able to process such a pattern very quickly, the individual overlapping check of a given pair of bounding boxes has to be very fast. Axis-aligned bounding boxes are the quickest overlapping check, because their overlapping can be easily checked by computing.","The process presented here employs bounding boxes that are axis-aligned in the object coordinate system as nodes of a binary bounding box hierarchy. The root encloses the entire object, whereas the leaves preferably each enclose exactly one polygon. Inner nodes usually have two children, however, in certain cases having only one child may be more favorable for performance.","In the present process, first a certain simple condition is set for the relationship between parent and children nodes. During simultaneous traversal, the boxes that are usually slanted in relation to the object coordinate system of the other object are enclosed in axis-aligned auxiliary boxes. Subsequently, these axis-aligned auxiliary boxes are checked for overlapping in a canonical manner.","The condition set for the bounding BoxTrees is that the cut-planes are axis-aligned; the children resulting from a node may overlap or be spaced. For this purpose two cut-planes, which are parallel to each other and parallel to one axis of the object coordinate system, are always employed. Due to this condition, there are sufficient degrees of freedom for selecting the box size for adaptation to the respective object.","The process gains its special speed from the cited condition in that all the computation results required for enclosing a box in an axis-aligned box are utilized again in the next lower recursion. A further advantage of this condition is that the bounding box hierarchy on which the present process is based requires very little memory capacity, which also leads to a speed advantage, because in this manner, the cache of the processor becomes much less often invalid.","The present process and the respective device require fewer floating-point operations per node than any other hitherto known collision detection process. Furthermore, the bounding box hierarchy on which the present process is based requires less memory capacity than any other hitherto known hierarchical process. This applies per node and therefore overall, because in a binary hierarchy, the number of nodes is independent of the bounding volume used. Based on these advantages and on the low complexity of the computations conducted with the process, the process is especially suited for implementation in hardware as realized with the present device.","The device comprises at least one input interface for the input of first data for object identification, object description and object transformation, an output interface for the output of the collision detection results, a memory unit to store the first data and the bounding BoxTrees for the objects, a calculating unit designed only for conducting the basic types of calculation and comparison, a control logic for simultaneous traversal of the bounding BoxTrees, which is designed in such a manner that it activates the calculating unit to conduct computation operations and comparisons for carrying out the process, as well as a polygon cutting unit for computing the overlapping of polygons. The device is preferably designed as an insert card for connection to a large computer system. It is especially advantageous to employ a stack, in which the intermediate results computed for the respective levels and pointers to the current nodes of the bounding BoxTrees are deposited.","Furthermore, a separate unit can be provided for conducting the transformation step of the object.","Of course, the polygon cutting unit and the transformation unit may also be combined in a correspondingly designed calculating unit.","In the following, essential features of the present process are briefly explained again using the two-dimensional example of .  shows the relationship between the bounding boxes of a lower hierarchical level and the bounding box of the above level.  illustrates the manner of forming auxiliary bounding boxes and the resulting relationship to the auxiliary bounding boxes of the above level.","Based on these relationships, it becomes possible to reuse computation results that are needed for inclusion of a box in an axis-aligned box in the next lower recursion.","If b is a node of the bounding BoxTree, b, and bare its children (one can also present them as \u201cleft\u201d and \u201cright\u201d subboxes) yielded by cutting off sub-volumes of box b using two cut-planes  that are parallel to each other and to two axes of the object coordinate system (cf. FIG. ). We denote the single coordinates of box b. with\n\nb=(b, b, b, b, b, b)\n\nThe axis-aligned enclosing box of b is denoted with\n\n()=((), (), (), (), (), ()).\n","As previously mentioned, there is a relationship between b, band b that nearly all the coordinates of bcoincide with the coordinates of b and nearly all the coordinates of bcoincide with the coordinates of b, except (b)\u2266b and (b), with \u03b1 c x, y, z. One can regard \u03b1 as the cut-plane  which divides b in the two children boxes b, and b. Octrees are a special case of the box hierarchy defined here. However, octrees are less flexible. Note that the two children boxes may overlap, but there may also be a \u201cgap\u201d between the two.","For simplicity, we will write c:=b\u2212(b) and c:=(b)\u2212b in the following.","Each node of the thus defined hierarchy must therefore store the following data:","1. the axis \u03b1;","2. cand c; and","3. if the node is a leaf, a pointer to the allocated polygon.","Let us assume that the simultaneous recursive traversal has reached the two nodes a and b, i.e. a and b overlap (in the sense of the process). Furthermore, let us assume, without limitation of the overall idea, that each has two children.","Now the process must determine if the 4 pairs (a, b), (a, b), (a, b) and (a, b) overlap. This occurs, for example, for the first pair, in that bis enclosed by a box bbox(b), which is axis-aligned in the coordinate system of a, and then is checked for overlapping with a. Following this, conversely ais enclosed by a box bbox(a), which is axis-aligned in the coordinate system of b and is checked for overlapping with b,. The other pairs are checked in an analogue manner.","For simplicity, in the following only the \u201cpath\u201d from the coordinate system of b to a is described, because the reverse path runs completely analogue.","The process is based on the observation that 3 of 6 coordinates of bbox (b) are identical to the coordinates of bbox(b). Generally, if there are n-dimensional boxes, of a total of 2n, n coordinates are the same, b, b, bare assumed the axes of coordinates of box b in the coordinate system of a (FIG. ). Let us assume the cut-plane \u03b1=x=b. Then the x-coordinates of bbox(b) are \n\n\nThe x-coordinates of bbox(b) are analogue \n\n","The other coordinates are computed in an analogue manner. For the other cases \u03b1=y, z, the formulae are also analogue. Although  is two-dimensional, one can readily see that generally the above formulae apply to a n-dimensional case.","The process does not only save half of the computations, but also half of all the required checks to determine the overlapping of two axis-aligned boxes, with one of them being determined by the above formulae. This is possible because half of the coordinates remain constant.","Let us assume that bbox(b) and a overlap. Now it should be determined if the bbox(b) and a overlap. Again let us assume \u03b1=x. Then the following comparison must be conducted on the x-axis: \n\n","Note that the check b<>0 was already run when bbox(b) or bbox(b) were computed.","Overall, the number of floating point operations for a box-box overlapping check comprises at most 3 multiplications, 4 additions and 5 comparisons. The number of operations of a recursion step comprises 12 multiplications, 16 additions and 20 comparisons: 2\u00d7(3\u00d72 mult.+3\u00d72 add.) to enclose the four children in axis-aligned boxes, and 2\u00d7(2 \u00d73+2\u00d72 comparisons) for the overlapping checks. This applies for the most unfavorable case. The average case requires less operations.","If one only conducts the check a \u2229 bbox (b) and leaves out the reverse check bbox (a) \u2229 b, only half the operations are required. Depending on the implementation and architecture, the one or the other variant may be faster.","One possibly way to translate the present variant into hardware is shown in FIG. .","In the figure bold arrows represent the essential data paths. Thin arrows stand for the essential pointers between the data. Blocks ,  and  represent the bounding box hierarchy, a polygon array and the point array. Polygons are represented here as three or more indices in the point array. The data lie in the common memory  of the collision detection hardware. Of course, the memory of the hardware holds, i.a. such data for many objects. All data remain in the hardware memory as long as they are valid. They may have to be swapped by a control logic in the main memory of the computer if too many objects have been registered for collision detection.","First the polygons and the points are loaded in memory  via the API  (pplication rogramming nterface) and the hardware interface . Preferably the API  also assumes the computation of the bounding box hierarchy in the software, because it is not time critical.","In the event of a collision, the interface supplies the indices . The calculating unit  is responsible for traversal of the hierarchies and the execution of the previously explained formulae and comparisons. This means that this calculating unit  is relatively simple, because it only has to implement four basic types of arithmetic and comparisons.","At the beginning of a collision check, the interface  receives from API  the IDs of the two objects to be checked and a matrix , which transforms one of the two objects into the coordinate system of the other object. In this way, the control logic  initializes stack  and the calculating unit . Then the control logic  enters the roots of the bounding box hierarchies into the calculating unit  and conducts the operations of the process. Then depending on the result of the comparisons, the pointers are placed on the current nodes in the hierarchies and the intermediate results from the calculations are placed on stack . Following this, a pair of children of the current nodes is entered in the calculating unit  and the process starts anew.","If the calculating unit  determines that the current pair of nodes do not overlap, an earlier pair is taken from stack . The intermediate results stored with this pair on stack  are loaded in calculating unit  and the calculating unit continues.","If the calculating unit  determines that a pair of nodes overlap and this pair are leaves in the hierarchy, the pointers are pursued from the leaves in the index array and from there in the point array. The resulting points form two triangles which are loaded in the polygon cutting unit . A random number of n corners can be treated in an analogue manner. One of the two polygons runs through the transformation matrix for the respective object. The polygon cutting unit  computes a point of intersection of the two triangles if there is one. This is relatively simple for triangles and can be carried out by a standard process, such as the one, for example, known from Held, M. ERIT: \u201cA Collection of Efficient and Reliable Intersection Tests\u201d, Journal of Graphics Tools, 2(4):25-44, 1997.","If there is a point of intersection, this is relayed to interface  and stored in the output FIFO. If the application wants to determine all the points of intersection, the calculating unit  and control logic  continue, i.e. take the two parent nodes from stack  and continue the process. Or control logic  can stop and inform the API that the results are available.","The API  should be designed in such a manner that collision detection is computed asychronously. This has the advantage that the application can continue with other tasks and get the results of the collision detection later. Furthermore, the API should be similar to OpenGL (raphics anguage), because this is widely used in computer graphics. The following functions should be available in this manner or a similar manner in an API for collision detection hardware.",{"@attributes":{"id":"P-d0e3081","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Function","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"colInit","provides a new \u201ccontext\u201d analogue to"]},{"entry":[{},{},"glXCreate Context"]},{"entry":[{},"colNewObject","reports a new object for collision"]},{"entry":[{},{},"detection; the function provides the ID,"]},{"entry":[{},{},"with aid of which the application can"]},{"entry":[{},{},"identify the object for the API; then the"]},{"entry":[{},{},"API expects to receive the list of"]},{"entry":[{},{},"polygons and points from the application,"]},{"entry":[{},{},"with the aid of the following functions;"]},{"entry":[{},"colIndex","provides a point index, which is attached"]},{"entry":[{},{},"to the list of indices"]},{"entry":[{},"colVertex","provides a point index, which is attached"]},{"entry":[{},{},"to the list of points"]},{"entry":[{},"colEndObject","ends the transmission of the actual"]},{"entry":[{},{},"object; this actuates the computation of"]},{"entry":[{},{},"the bounding box hierarchy; this function"]},{"entry":[{},{},"does not pass the control to the"]},{"entry":[{},{},"application until this computation is"]},{"entry":[{},{},"finished;"]},{"entry":[{},"colCheck","actuates a collision check; supplied are:"]},{"entry":[{},{},"two object IDs, a matrix, a memory"]},{"entry":[{},{},"address for indices, and a memory address"]},{"entry":[{},{},"for points; the collision hardware checks"]},{"entry":[{},{},"the collision in accordance with the"]},{"entry":[{},{},"above-mentioned process and stores"]},{"entry":[{},{},"possibly found polygons as index in the"]},{"entry":[{},{},"passed on memory section of one of the"]},{"entry":[{},{},"index arrays deposited by the"]},{"entry":[{},{},"application; possibly found points of"]},{"entry":[{},{},"intersection are also stored in the point"]},{"entry":[{},{},"array deposited by the application in the"]},{"entry":[{},{},"main memory."]},{"entry":[{},"colDeleteObject","deletes all data structures of an entered"]},{"entry":[{},{},"object ID from the memory of the"]},{"entry":[{},{},"hardware."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The above list is, of course, incomplete. For simplification, it was assumed that an object consists only of triangles, which is no restriction. If rectangles or even random polygons are to be treated, the API must be extended by a few functions.","Of course, data could also be transmitted via DMA (irect emory ccess). In this case, for example, transmission of the complete point list would occur at one time with the function colTriangles (const colVec * points). The principle, however, would be the same.\n\n","id[i]=colNewObject (context);","p=0 . . n\u22121:\n\n","v=0 . . nvertices\u22121:\n\n","colEndObject( );\n\n",{"@attributes":{"id":"P-00099","num":"none"},"ul":{"@attributes":{"id":"ul200008","list-style":"none"},"li":[{"@attributes":{"id":"ul200001-p00099","num":"00099"},"b":"1"},{"@attributes":{"id":"ul200001-p00100","num":"00100"},"b":"2"},{"@attributes":{"id":"ul200001-p00101","num":"00101"},"b":"3"},{"@attributes":{"id":"ul200001-p00102","num":"00102"},"b":"4"},{"@attributes":{"id":"ul200001-p00103","num":"00103"},"b":"5"},{"@attributes":{"id":"ul200001-p00104","num":"00104"},"b":"6"},{"@attributes":{"id":"ul200001-p00105","num":"00105"},"b":"7"},{"@attributes":{"id":"ul200001-p00106","num":"00106"},"b":"8"},{"@attributes":{"id":"ul200001-p00107","num":"00107"},"b":"9"},{"@attributes":{"id":"ul200001-p00108","num":"00108"},"b":"10"},{"@attributes":{"id":"ul200001-p00109","num":"00109"},"b":"11"},{"@attributes":{"id":"ul200001-p00110","num":"00110"},"b":"12"},{"@attributes":{"id":"ul200001-p00111","num":"00111"},"b":"13"},{"@attributes":{"id":"ul200001-p00112","num":"00112"},"b":"14"}]}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The process and the accompanying device are made more apparent in the following using preferred embodiments with reference to the drawings without the intention of limiting the overall inventive idea.",{"@attributes":{"id":"P-00051","num":"00051"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00052","num":"00052"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00053","num":"00053"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00054","num":"00054"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
