---
title: System and method for determining an object's lifetime in an object oriented environment
abstract: A system and method determines an object's lifetime. An object lifecycle engine may work with an object oriented environment. As objects are created, an object graph may be constructed having one or more roots. A root record graph may be constructed, and edges of the root record graph may point in an opposite direction than the edges of the object graph. As objects, entities, and references are added, removed, or deleted from within the environment, the object graph and the root record graph may be updated. A root finder may search the root record graph to determine whether a given root record is no longer rooted. If a root record is no longer rooted, then the object associated with that root record may be determined to be unreachable and at the end of its lifetime. If the root finder search is performed when references are removed, then objects may be destroyed in a deterministic manner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09600411&OS=09600411&RS=09600411
owner: The MathWorks, Inc.
number: 09600411
owner_city: Natick
owner_country: US
publication_date: 20110331
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BRIEF DESCRIPTION OF THE DRAWINGS","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT","EXAMPLES"],"p":["The present application claims the benefit of U.S. Provisional Patent Application Ser. No. 61\/438,019, which was filed on Jan. 31, 2011, by David A. Foti and Jianzhong Xue for a SYSTEM AND METHOD FOR DETERMINING AN OBJECT'S LIFETIME IN AN OBJECT ORIENTED ENVIRONMENT and is hereby incorporated by reference in its entirety.","The invention description below refers to the accompanying drawings, of which:",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIGS. 3A to 3C"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 14"},"In an object-oriented environment, such as a programming environment, objects are created, and these objects interact with other objects in the environment. Objects are specific instances of a class, which describes a set of common characteristics. Objects have behaviors that are common to all objects of a class, and these behaviors are implemented through methods. Each object typically encapsulates data and operations. Objects interact with each other and with other entities of the object oriented environment via object interfaces such as function calls and events.","Classes define those characteristics or elements that are common to all instances of the class. Classes may define many kinds of characteristics or elements. Some of these characteristics are defined by functions or interfaces to functions. A function is sometimes called a method, operation, or operator. A function may take inputs and produces outputs. A function that belongs to the class typically has unrestricted access to class elements while functions outside the class have more restricted access. This limitation of access is commonly referred to as encapsulation.","Other class characteristics are defined as fields or properties that hold data such as numeric values, arrays, tables, functions, delegates, other objects, and references to other objects.","Another example of a class characteristic is an event or message. An event allows a class or object to broadcast information about some special change or occurrence that may be of interest to other objects or code executing in the system. One example of an event is the press of a button. Another example is a zero-crossing in an object used for numerical simulation.","In object oriented systems, objects are typically created through a process called construction in which initial values may be assigned to any state variables associated with the objects, such as the values of object data elements (also known as fields or properties). Object construction frequently happens by calling a function often called a constructor. The constructor function may have the same name as the class or may have another name. The call to the constructor may be made using the same syntax as calling an ordinary function or method or may use special syntax or special operators that indicate that a new object is to be constructed. The constructor may take arguments that are used to create an instance having specific property values. This is one way that a program or system may create many objects that share the characteristics defined by their class, but also differ from other instances of the same class.","When objects are constructed and afterward, they may consume resources such as system memory, file handles, sockets, handles to devices, slots in tables, other objects, etc. The very existence of objects may also affect how systems behave. For example, an object may register one of its methods to be invoked in response to some event from the system or another object. Because objects impact their environment through interactions with the system and other objects and through the resources they consume, it is important for an object oriented system to also provide a means for objects to be destroyed. Object destruction typically involves the termination of object interactions and the release of system and other resources. Generally object oriented systems may require that programs be written to explicitly destroy objects, or they may automate the destruction process or they may automate the destruction process under certain circumstances.","When systems automate object destruction, there are different approaches that can be taken to achieve automation. Generally, the automated system provides some mechanism to detect that an object is no longer being used by the program, and should be destroyed. In some systems such as the MATLAB\u00ae programming language and application from The MathWorks, Inc. of Natick, Mass., objects are destroyed at the point where no program is capable of accessing the object. In other systems, such as the Java Virtual Machine from Oracle Corp. of Redwood City, Calif. or the Microsoft .NET Framework from Microsoft Corp. of Redmond, Wash., objects are destroyed through a process known as garbage collection. The garbage collection process destroys unreachable objects that are determined to be unreachable some time after they became unreachable.","All automated systems for object destruction remove some burdens on programmers that can improve the quality and efficiency of programs. However, garbage collections systems also introduce burdens on programmers, and possibilities for defects in programs. Because objects are not destroyed at a deterministic point in program execution and because objects typically remain after no longer being reachable, and because these objects can impact the system, these impacts are non-deterministic and can be a source of defects or bugs. Such defects can be difficult to reproduce and debug because garbage collection performance is not always repeatable. Programmers often want to be aware of how their objects use resources and rely on deterministic ordering of object destruction, a complicating factor in designing objects for garbage collection systems. A deterministic system for destroying objects is desirable to avoid such bugs, and to ease the task of designing and implementing objects. A deterministic system should also be efficient, e.g., by minimizing the cost of determining that an object is unreachable. Commonly owned U.S. Pat. No. 7,237,237 for Designating an Object for Destruction, which is hereby incorporated by reference in its entirety, describes a deterministic system employed in some versions of the MATLAB\u00ae product that may exhibit a relatively high runtime performance cost for performing cycle detection. In particular, creating and destroying certain data structures such as stacks, lists, and trees can have performance of order O(n) rather than the expected O(n) where n is the number of nodes in the data structure. The present invention significantly improves performance of these operations.","Overview","An embodiment of the invention relates to a system and method for determining an object's lifetime. The system may include an object lifecycle engine that works with an object oriented environment, such as an object oriented programming environment. The object lifecycle engine may include an object graph builder, a root record graph builder, a root finder, and a cache management engine. As objects are created in the object oriented environment, the object lifecycle engine may be notified, and the object graph builder may construct an object graph. In an embodiment, the object graph may be a directed graph in which a first type of node may represent the objects created in the environment and a second type of node may represent other entities, such as local or global variables, that may reference the objects. The object lifecycle engine also may be notified when a reference is established between an entity, such as a variable, and an object, and\/or when a reference is established between two objects. In response, the object graph builder may create edges in the object graph that represent these references among the objects and entities. The object graph thus may include a node for each object created in the environment, and a node for each variable or other entity that references one or more objects. The object graph also may include an edge for each reference between two objects or between an object and an entity. One or more nodes of the object graph may represent a root of the object graph. A root may be a node that only has edges leading away from it. The root may not have any edges leading to it.","The root record graph builder may construct a root record graph, which may be separate from the object graph. The root record graph also may be a directed graph, and its structure may largely mirror the structure of the object graph. However, the edges of the root record graph may point in an opposite direction than the edges of the object graph. That is, while the edges of the object graph may point away from the root and toward child or leaf nodes, the edges of the root record graph may point from the child or leaf nodes to the root node or nodes. The nodes of the root record graph may be root records created by the root record graph builder. In an embodiment, for each node of the object graph, the root record graph builder constructs a root record corresponding to that object graph node. Furthermore, for each edge constructed between two nodes of the object graph, the root record builder may create a corresponding edge between the two root records of the root record graph that correspond to those object graph nodes. As mentioned, however, the edges of the root record graph may point in the opposite direction as compared to the edges of the object graph. The lifecycle engine maintains an association between each object and its root record.","As objects, entities, and references are removed or deleted from within the object oriented environment, the object graph builder may update the object graph, and the root record graph builder may update the root record graph. More specifically, when an object or variable is deleted a corresponding node of the object graph, and a corresponding node of the root record graph may be removed. In addition, the references to and from the deleted node may be removed from the object and root record graphs. Furthermore, as references among objects and entities are deleted or removed, the edges of the object graph and the root record graph that correspond to those deleted or removed references may be removed. In an embodiment, changes to the object graph and root record graph may be made in the same order as the operations that trigger those changes. For example, the changes to the graphs may occur in lockstep order with the occurrence of the respective commands or actions in the object oriented environment.","As described herein, the object graph and the root record graph may provide an efficient, automatic, and deterministic way of determining when an object has reached its end of lifetime. A reference to an object that originates, not from another object, but from outside another object, such as from a local or global variable, may be referred to as an external reference. Furthermore, an object may be said to be externally reachable if it is possible to reach the object by following a path that begins with an external reference. An object that is no longer reachable from an entity, such as a variable, of the object oriented environment may be considered to have reached its end of lifetime, as it may no longer be possible to access or reach such an object. The object may then be destroyed, and the resources allocated to or reserved by that object may be released. This condition, by which an object becomes unreachable, may be detected by the root finder, which may search the root record graph.","In particular, after a reference, an object or an entity is deleted or removed from within the object oriented environment, and that change has been reflected in the object and root record graphs, the root finder may examine the root record graph to determine whether one or more objects have, as a result, become unreachable. In an embodiment, the root finder searches the root record graph to determine whether a given root record is no longer linked, e.g., by one or more edges, to a root of the root record graph. If a root record is no longer linked to a root, then the object associated with that root record may be determined to be unreachable and thus at the end of its lifetime. The object lifecycle engine may notify the object oriented environment of this condition, and the environment may take appropriate action, such as, for example, destroying the object, and releasing the resources allocated to and\/or reserved by the object.","The cache management engine of the object lifecycle engine may cache information about paths from the nodes of the root record graph to the one or more roots of the root record graph. By caching such information, the root finder may only need to calculate such a root path once for any given node of the root record graph. Thereafter, instead of re-calculating a root path for a given node, the root finder may perform a cache lookup. As edges in the root record graph are removed, the cache management engine also may invalidate cached path information that relied on the removed edges. In an embodiment, this may cause the root finder to calculate one or more new root paths, which in turn may be cached.","In an embodiment, certain kinds of objects may not be allowed to be referenced from multiple variables or other objects. In this case, root records for these objects may be simpler because they may have a single edge. There may be a family of root records that implement a common interface, but have different data structures optimized for the particular needs of the object associated with the root record.","A data processing or computer system may include multiple threads of execution and a thread may be allowed to access its own graph of objects. In an embodiment, several threads of execution may each have distinct sets of object and root record graphs where each thread is not allowed to interact with objects from another thread.","Data Processing System",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","112","100","114","106","116","118","120"]},"The main memory  may store a plurality of libraries or modules, such as an operating system , and one or more application programs or applications running on the operating system , including an object oriented system or environment . Furthermore, as described herein, an object lifecycle engine  may be loaded on the main memory . The object lifecycle engine  may be part of, or may be in communicating relationship with, the object oriented environment .","The removable medium drive  may accept and read a computer readable medium , such as a CD, DVD, floppy disk, solid state drive, tape, flash memory or other medium. The removable medium drive  may further write to the computer readable medium .","Suitable computer systems may include, for example, personal computers (PCs), workstations, laptops, tablets, palm computers, electronic readers, smartphones, and other portable computing devices. Suitable operating systems  may include the Windows series of operating systems from Microsoft Corp. of Redmond, Wash., the Linux operating system, the MAC OS\u00ae series of operating systems from Apple Inc. of Cupertino, Calif., and the UNIX\u00ae series of operating system, among others.","The computer system  of  is intended for illustrative purposes only, and the present invention may be used with other computer systems, data processing systems or computational devices. The present invention may also be used in a networked, e.g., client-server, computer architecture, or a public and\/or private cloud computing arrangement, among others.","As indicated above, a user or developer, such as an engineer, scientist, programmer, etc., may utilize the keyboard , the mouse  and the computer display  of the user I\/O  to operate the object oriented environment .","Suitable object oriented systems or environments include high-level technical computing environments, such as the MATLAB\u00ae and Simulink\u00ae technical computing environments from The MathWorks, Inc. of Natick, Mass., and in the system described U.S. Patent Publication No. 2008\/0127064 for a System and Method for Using Stream Objects to Perform Stream Processing in a Text-Based Computing Environment, which is hereby incorporated by reference in its entirety. Other object oriented systems or environments include the Java Virtual Machine from Oracle Corp., the Microsoft .NET Framework from Microsoft Corp., and the Smalltalk programming language, among others.","The MATLAB\u00ae technical computing environment is a math-oriented, textual programming environment for digital signal processing (DSP) design, among other uses. The SIMULINK\u00ae technical computing environment is a graphical, block-based environment for modeling and simulating dynamic systems, among other uses. A user may operate the MATLAB\u00ae and Simulink\u00ae technical computing environments to conduct algorithm exploration and development, data visualization, and dynamic system simulation. For example, a user may utilize the Simulink environment to create one or more block diagrams where the blocks may represent portions of the dynamic system.","Oftentimes, an engineer or developer may run an object oriented environment, such as the MATLAB\u00ae and Simulink\u00ae technical computing environments, continuously for many months at a time, or even longer, while conducting on-going algorithm exploration or development, among other tasks. For example, the engineer or developer may create multiple projects some or all of which may be kept up and running. During this time, numerous objects may be created, and each object may consume resources, such as system resources. At least some of the system resources may be of limited supply. If the resources allocated to or reserved by objects that are no longer in use are not released, system performance may suffer. Furthermore, the operations, functions or modeling actions performed by the user with the MATLAB\u00ae and Simulink\u00ae environments may be carried out over a long period of time.","Object Lifecycle Engine",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","200","202","204","206","208","200","124","210","200","124","212"]},"As discussed herein, the object graph builder  may construct one or more object graphs, such as object graph . The root record graph builder  may construct one or more root record graphs, such as root record graph . The root finder  may search graphs , , to locate one or more roots of graphs , . The cache management engine  may cache path information calculated by the root finder , and to manage that cache information.","The object lifecycle engine , including the object graph builder , the root record graph builder , the root finder , and the cache management engine , may each comprise registers and combinational logic configured and arranged as sequential logic circuits. In an embodiment, the object lifecycle engine  is implemented through one or more software modules or libraries containing program instructions pertaining to the methods described herein. The instructions may be stored in main memory  and\/or on a computer readable media, such as computer readable medium , and executable by one or more elements, such as CPU . For example, the object graph builder , the root record graph builder , the root finder , and the cache management engine  may each be implemented through one or more software modules or libraries. Other computer readable media may also be used to store and execute these program instructions. In alternative embodiments, various combinations of software and hardware, including firmware, may be utilized to implement the present invention.","As mentioned above, the object lifecycle engine  may be built into, and thus constitute a part of, the object oriented environment . In another embodiment, it may be built into the operating system . Alternatively, engine  may be a separate component from the environment  and operating system , as illustrated in . The environment  and the object lifecycle engine  may communicate with each other through a Local Procedure Call (LPC) messaging system, a Remote Procedure Call (RPC) messaging system, one or more Application Programming Interfaces (APIs), or one or more object interfaces, among other communication techniques.","Creating Object and Root Record Graphs",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 3","b":["124","302","124","304","124","200","306","124","200","124","200","308","200","600","310","700","312"]},"In an embodiment, graphs ,  are constructed by the object graph builder  and the root record graph builder , respectively. The object graph  and the root record graph  may each be implemented as a directed graph, such as a directed acyclic graph (DAG). The object graph  and the root record graph  may each include a plurality of nodes interconnected by edges. The object lifecycle engine  may store the object graph  and the root record graph  in memory, such as main memory . The graphs ,  may be implemented, for example, through linked lists.","It should be understood that objects as well as entities that are capable of referencing objects may be created in the object oriented environment  in a number of different ways. For example, a user may create an object in a graphical manner by utilizing a graphical modeling system. Here, the user may select a desired block type from a palette of available blocks, and add an instance of the selected block type to a block diagram window or canvas. Likewise, for example, a user may also create an object in a textual manner, e.g., by entering a command for constructing an object in a command line interface of the environment . In an embodiment, an entity, such as a variable, may represent a place to put an object, and provides a way to reach that object.","The object oriented environment  may support a text-based command, such as:\n\nx=myObject;\n","which may result in the creation of the variable \u2018x\u2019 that refers to a constructed instance of the class \u2018myObject\u2019. The object oriented environment  may further support a command, such as:\n\nx.prop_1=myOtherObject;\n","which may result in a property of the object \u2018myObject\u2019 being set to another object, i.e., an instance of \u2018myOtherObject\u2019 class. That is, the object \u2018myObject\u2019 now references the object \u2018myOtherObject\u2019.","Suitable objects for use with the present invention may comply with the MATLAB object system from The MathWorks, Inc. An entity, such as a variable, may be created by declaring the variable in accordance with the syntax and semantics of the environment . An example of a type of variable is a cell array, which may be an array of other arrays. A cell array may thus reference one or more objects.","In addition to being created in response to user input, an object or an entity may be created programmatically. For example, a script, routine, or function may be run by the object oriented environment , and a result may be the creation of one or more objects and the establishment of references among the objects. In addition, a block diagram that creates objects and references may be executed.","As discussed herein, the object graph builder  may construct a node of the object graph  for each object and for each entity created in the environment . A node may be represented through one or more data structures having one or more information storage elements, and may be stored in a memory, such as main memory . These elements may be implemented as fields of a data structure.  is a schematic illustration of an embodiment of an object graph node data structure . In particular, the node data structure  may have a name field  that stores a name or identifier of the object or entity to which the node corresponds. The name may be the same as the object's or variable's name as assigned in the object oriented environment . The node data structure  also may include a type field or flag  specifying whether the node corresponds to an object or to an entity, such as a variable.","In addition, the node data structure  may have one or more pointer fields, such as a Parents field , a Next field , and a Root Record field . The Parents and Next fields ,  may each store pointers that point to a node data structure  of another node of the object graph . The Root Record field  may point to a node of the root record graph  that corresponds to the same entity or object as the object graph node data structure . When a reference is established between a first object or entity and a second object or entity, the Next field  of the node data structure  for the first object or entity may be loaded with a pointer that points to the node data structure  for the second object or entity. Similarly, the Parents field  of the node data structure for the second object or entity may be loaded with a pointer to the node data structure  for the first object or entity.","In this way, as objects and entities are created in the object oriented environment , and as references among these objects and entities are established, the object graph builder  constructs and updates the object graph , which provides a representation of that information.","The root record graph builder  also may construct a node of the root record graph  for each object and entity created in the environment . A node of the root record graph  also may be represented as one or more data structures having one or more information storage elements, implemented as fields, and stored in a memory.  is a schematic illustration of a root record graph node data structure . The root record graph node data structure  may include a plurality of fields or flags. In particular, it may include a Parents field , a Next field , a Path_Cache field , a Reference count field , an is_Variable flag , an is_Root flag , an is_Valid flag , an is_Marked flag , and an is_Link_Dummy flag .","In an embodiment, nodes of the object graph  and root record graph  for objects and\/or non-object entities may only be created by the object lifecycle engine  after a reference from the respective object and\/or non-object entity to an object is established in the objected oriented environment . For example, if a user creates an object or an entity, such as a variable, in the object oriented environment , a node for that object or entity may not be created in either the object graph  or the root record graph  unless and until a reference to or from that object or that variable and an object is established.","As mentioned, the object oriented environment  may notify the object lifecycle engine  as references are established among objects and non-object entities in the environment . In response to a reference being established to or from an object, the object graph builder  may create an edge in the object graph  corresponding to that reference. Similarly, the root record graph builder  may create an edge in the root record graph  for that reference.","In an embodiment, assignment to variables may notify the object lifecycle engine  by invoking a method on the engine  that takes a reference to the variable and a reference to the value assigned to the variable. Similarly, when a property or array element is assigned, the assignment operation may invoke a method on the object lifecycle engine , and pass a reference to the object or array being assigned into and a reference to the value being assigned.","In an embodiment, the object lifecycle engine  may provide a method to create a new root record representing a root reference. The system or environment  may invoke this method to create a root record for each root in the system where a variable in an executing function is one example of a root.","In an embodiment, the object lifecycle engine  may only be notified when the value being assigned to a variable or a property may possibly contain references to other entities. If the value is known to be a leaf value, there may be no need to record its location in the object or root record graphs , , because a reference count may be sufficient to determine when such a value can be destroyed.","In an embodiment, a just-in-time (JIT) compiler may be employed to convert a program from source code into machine-executable code or virtual-machine executable code. The just-in-time compiler may remove invocation of the object lifecycle engine  to establish object graph nodes and root record nodes if the JIT compiler is able to determine the point where an object must be destroyed based on definition and use analysis of the program code being compiled. In other embodiments, the JIT compiler may be replaced by a more conventional compiler or a conventional interpreter.","To the extent the environment  supports different kinds of references, such as strong references and weak references, the root record graph builder  may only record strong references in the root record graph , because strong references, by definition, prevent objects from being destroyed, whereas weak references do not.","In an embodiment, a reference may be represented by a separate edge within the object graph  and the root record graph . That is, if a first object or entity, which already references a second object, references the second object or entity a second time, then a separate edge may be constructed in the object graph  and in the root record graph  for such a reference. In an embodiment, if a root record has multiple edges connected to the same other root record, these edges may be represented using a reference count.","References among objects and non-object entities may be created in a number of different ways within the object oriented environment . For example, a user may create a reference between two objects in a graphical manner by utilizing a graphical modeling system. For example, when the user adds a block to a subsystem, a reference may be created between the subsystem and the block. Also, when the user includes a first model in a second model, e.g., through a model reference block, a reference may be created from the second model to the first model, which may be called a referenced model or a submodel. With the object oriented graphical modeling system, a block, a subsystem, and a model may each correspond to an object. A user may also create a reference in a textual manner, e.g., by entering a command for assigning a variable to an object, or assigning a property of a first object to a second object. In addition, references, like objects and entities, may be created programmatically.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 6","b":["600","202","600"]},"The object graph  illustrated in  may be constructed in response to the following sequence of commands entered by a user in the object oriented environment :\n\nx=myObject;\u2003\u2003(1)\n\nx.prop_1=mySecondObject;\u2003\u2003(2)\n\ny=x.prop_1;\u2003\u2003(3)\n\ny.prop_1=myThirdObject;\u2003\u2003(4)\n\nx.prop_2=y.prop_1;\u2003\u2003(5)\n","Suppose that myObject, mySecondObject, and myThirdObject are handle classes available within the environment. Handle classes may be classes whose instances are referred to by reference rather than by value. Objects of handle classes may use a handle to reference objects of the class. A handle may be a pointer or some other value or object that identifies a particular instance of a class. Assignment of a handle from one variable to another is one example of an operation that may copy a handle. Passing a handle as a parameter to or from a function is another example of an operation that may copy a handle. When a handle is copied, the handle itself (e.g. the pointer or other identifier) may be copied, but not the data stored in the object's properties or data members. The object-oriented environment  may support non-handle classes, which may be called value classes and may also be known by a variety of names such as structure or struct depending on the environment. When a value object is copied, the object's data may also be copied, and the new object may be independent of changes to the original object. In an embodiment, the root record graph builder  may create root records for objects of handle classes, but not for objects of value classes. However, if a value object contains a handle class object, then the root record graph builder  may create a root record for this value object.","If a variable holds a handle class instance and a second variable is assigned the value of the first variable, then both variables refer to the same object. The first command creates the variable \u2018x\u2019, creates an instance of myObject, and establishes a reference from the variable \u2018x\u2019 to the object. Upon entry of this command, e.g., by the user entering the statement at a Command Line Interface (CLI) and selecting the return key, the object oriented environment  notifies the object lifecycle engine  of the creation of the variable \u2018x\u2019, the creation of the myObject instance, and the establishment of the reference from the variable \u2018x\u2019 to the myObject instance. In response, the object graph builder  constructs a first node , a second node , and an edge  extending from the first node  to the second node .","The second command establishes a reference from a property of the myObject instance to the mySecondObject instance. Again, the object oriented environment  notifies the object lifecycle engine  upon the entry of the second command, e.g., by the user. The object graph builder  responds by modifying or updating the object graph . In particular, the object graph builder  adds node , which represents the mySecondObject instance, and an edge  from node , which represents the myObject instance, to node , which represents the mySecondObject instance. The edge  shows the relationship between the property of the myObject instance to the mySecondObject instance.","The third command creates the variable \u2018y\u2019, and establishes a reference from the variable \u2018y\u2019 to an instance of mySecondObject. The object oriented environment  notifies the object lifecycle engine  upon entry of the third command, and, in response, the object graph builder  modifies the object graph . In particular, the object graph builder  adds node , which represents the variable \u2018y\u2019, and adds an edge  from node  to node , which represents the mySecondObject instance.","The fourth command causes the object graph builder  to create a new object, an instance of myThirdObject, and establishes a reference from a property of the mySecondObject instance to the myThirdObject instance. The environment  notifies the object lifecycle engine  upon the entry of the fourth command, and, in response, the object graph builder  modifies the object graph . In particular, the object graph builder  creates a node , which represents the myThirdObject instance, and a new edge , which represents the reference from node  to node .","The fifth command establishes a reference from a property of the myObject instance to the instance of \u2018myThirdObject. The environment  notifies engine  upon entry of the fifth command, and the object graph builder  adds a new edge  from node  to node .","As shown, the object graph  may be in the form of a DAG, having one or more roots. The roots of the object graph  correspond to nodes , . For purposes of illustration, the nodes , , which represent non-object entities, i.e., variables \u2018x\u2019 and \u2018y\u2019, are shown as triangles, whereas the nodes , , and , which represent objects, are shown as circles. This information may be stored in the Type field  of the node data structure .","As the system or environment  continues to process commands entered by the user, or commands are executed programmatically, additional objects and entities may be created, and additional references may be established among the objects and entities. The object graph builder  modifies the object graph  in response to these commands or actions. As the object graph  is updated, the object graph builder  may update information stored in the object graph node data structures . For example, as references are established, the Parents fields  and the Next fields  of the affected nodes may be updated with pointers to the referenced nodes.","In an embodiment, changes to the object graph  are made in lockstep order with the execution of the associated commands or operations in the object oriented environment . For example, as discussed above, upon entry of a command creating or referencing an object, or removing an object or a reference to an object, the object oriented environment  may notify the object lifecycle engine  of that event. The object lifecycle engine  may process that notification as described herein, and return an acknowledgment to the object oriented environment . The acknowledgment may signal that the object lifecycle engine  has completed its processing of the notification. The object oriented environment  may further suspend its processing of any subsequent commands until it receives the acknowledgment from the object lifecycle engine . In particular, if the acknowledgement from the object lifecycle engine  itself includes a notification that an object has reached the end of its lifetime, the object oriented environment  may respond to that notification, e.g., by destroying the object and releasing any allocated or reserved resources before processing any further commands or operations. Accordingly, the present invention may manage object lifetimes in a deterministic manner.","In an embodiment, the object graph builder  may construct a plurality of separate object graphs.","In addition to the construction of the object graph , the root record graph builder  may construct a root record graph, such as the root record graph , in response to the commands or actions occurring in the object oriented environment .  is a schematic illustration of the root record graph  that may be created by the root record graph builder . The root record graph  also includes a plurality of nodes interconnected by a plurality of edges. As with the object graph , a node of the root record graph , which may also be referred to as a root record, may represent an object or a non-object entity created in the object oriented environment . Likewise, an edge of graph  may represent a reference between two objects, between an object and an entity, or between two entities. A root record graph, such as graph , also may include one or more roots.","In an embodiment, the creation and modification of the root record graph  closely follows the creation and modification of the object graph . For example, referring back to the above sequence of commands, in response to the first command, the root record builder  constructs root record , which represents the variable \u2018x\u2019, root record , which represents the object \u2018myObjecet\u2019, and edge , which represents the reference from \u2018x\u2019 to \u2018myObjecet\u2019. While the direction of edge  of the object graph  is from node  to node , the edge  of the root record graph  points in the opposite direction, i.e., from node  to node . In response to the second command, the root record graph builder  modifies the root record graph  by adding new node  for \u2018mySecondObjecet\u2019, and new edge  from node  to node . In response to the third command, the root record graph builder  adds a new node  for \u2018y\u2019, and a new edge  from node  to node . In response to the fourth command, the root record graph builder  creates a new node  for \u2018myThirdObject\u2019, and a new edge , which represents the reference from \u2018myThirdObject\u2019 to \u2018my SecondObject\u2019. In response to the fifth command, the root record graph builder  adds a new edge  from node  to node .","As shown, the root record graph  may also be in the form of a DAG, having one or more roots. The roots of the root record graph  correspond to nodes , . As described herein, the root record graph  may also include one or more Path Caches, such as , .","It should be understood that graphs ,  are meant for illustrative purposes, and that other graphs, including graphs that may be more complex than graphs  and , may be constructed.","Root Path Caching","In an embodiment, the root finder  may cooperate with the cache management engine  to cache root path information for the root records of the root record graph . A root record may be considered to be rooted if the root record is a root of the root record graph , or if there is a path from the root record to at least one root of the root record graph . If the Parents field  of a candidate root record is empty, then the candidate root record may be considered a root of the root record graph . The root finder  may direct such a candidate root record to set its is_Root flag  to True, thereby storing root path information at the candidate root record itself. Furthermore, if the Parents field  of another root record includes a pointer to at least one other root record, then this other root record is not a root of the root record graph, and the root finder  may direct this other candidate root record to set its is_Root flag  to False. For example, as root records  and  are each roots of the root record graph , the is_Root flag  for these two root records ,  may be set to True. The Parents field  for the other root records , , and  each contain a pointer to at least one other root record. Accordingly, they are not roots of the root record graph , and the is_Root flag  of these root records , , and  may be set to False. Thereafter, if the root finder  were to query root record , it would determine that its is_Root flag  is True, and therefore root record  may respond to the root finder  that it is rooted.","For those root records that are not roots of the root record graph, the root finder  may perform a graph traversal of the root record graph  starting from a candidate root record looking for a path from the candidate root record to a root of the root record graph . The traversal of the root record graph  may be a depth first search (DFS). The root finder  may examine the Parents field  of the candidate node to locate one or more parent root records. The root finder  may choose one of these parent root records, and examine the Parents fields  of the selected parent root record, and so on until the root finder  reaches a root of the root record graph . In an embodiment, the root finder  may mark a root record that it has encountered during a search so that it visits each root record at most once. For example, the root finder  may set or assert the is_Marked flag  when it encounters a root record during a search. At the end of a search, the is_Marked flags for all of the root records may be cleared.","Considering root record , for example, the root finder  may determine that a path from root record  to root record , which is a root of the root record graph , exists. Accordingly, root record  is also rooted. In response, the cache management engine  may cache this root path information in the root record graph . More specifically, the cache management engine  may create a Path Cache node, such as Path Cache node , in the root record graph . The Path Cache node may be implemented as a data structure having information storage elements, and stored in memory.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 8","b":["800","800","802","804"]},"In addition to creating the Path Cache node , the cache management engine  may modify the data structure  for root record  by entering a pointer to the Path Cache node  into the Root Path Cache field . This pointer is illustrated by arrow  in the root record graph . Thereafter, if the root finder  queries root record  to see if it is rooted, the root record  may determine that its Root Path Cache field  includes a pointer to Path Cache . The root record  may respond that it is rooted, thereby freeing the root finder  from having to re-calculate a path from root record  to a root of the root record graph . Note that, by caching root path information, the number of times that a root path must be calculated for a candidate root record may be reduced.","The querying of root records may be performed for other root records of the root record graph . For example, for root record , it may be determined (by the root record itself or by the root finder) that the is_Root flag  of root record  is false, and that its Root Path Cache field  is empty. Accordingly, the root finder  begins calculating a root path from root record . When the root finder  reaches root record , the root finder  may check whether root record  caches a root path before proceeding further in the calculation of a root path. In this case, root record  includes a pointer to the Path Cache  in its Root Path Cache field . The root finder  may copy this pointer to the Root Path Cache field  for root record . In this way, root path information may also be cached at root record , as illustrated by arrow  in the root record graph .","For root record , the root finder  may determine that its parent, root record , caches a path to root . Accordingly, the root finder  may cache this root path information at root record . In particular, the root finder  may copy the pointer to Path Cache  from the data structure for root record  into the Root Path Cache  field for root record , as illustrated by arrow . When the root finder is asked to determine if a given root record (the starting record) is rooted, and a valid root is found, the root finder may update every root record along the path from the starting record to the found root such that each such record now points to the same Path Cache. By doing this, it is possible for the object lifecycle engine  to invalidate the Path Cache associated with all nodes along a given path whenever a change is made to any node along that path that might invalidate the cache for other nodes. For example, since the entire path of nodes refer to the same Path Cache, the Path Cache may be marked invalid by setting a flag in the Path Cache data structure. When a root record is found to have an invalid Path Cache, it may be treated as if the Path Cache reference were NULL, and cause the cache to be updated. Exemplary changes that may invalidate the cache include making the cached root record no longer represent a root, and removing a link from a node to its parent node where both the node and its parent node point to the same Path Cache.","The root finder can determine all of the objects between the starting record and the found root in a number of ways. One way is for the root finder to keep a stack of root records along the current path so that when a root is found the stack contains all the records between the starting record and the found root. Each record in that stack can then be assigned the same Path Cache pointer.","The object lifecycle engine  may use the Reference Count field  for a given root record to store a count of how many other root records are referring to the given root record. As a reference to the given root record is removed, the value of the Reference Count field  may be decremented. When the value of the Reference Count field  is zero, the root record graph builder  may destroy the given root record.","The is_Valid flag  of a given root record may be used to designate whether the given root record is valid or invalid. For example, if the is_Valid flag  is asserted, the given root record may be valid.","In an embodiment, the object graph node data structure  and\/or the root record graph node data structure  may have fewer, greater or other fields.","Determining an Object's End of Lifetime","As discussed herein, notifications may be issued by the object oriented environment  to the object lifecycle engine  when objects are created, when non-object entities that reference objects are created, and when references are established among the objects and entities. In an embodiment, the object oriented environment  also may issue notifications to the object lifecycle engine  when a reference to an object is deleted or removed from within the object oriented environment . More specifically, when an entity, such as a variable, that references an object is removed, cleared, goes out of scope, or is changed to reference something else, such as a value, a notification of the removal of the reference to the object may be issued by the environment  to the object lifecycle engine , as indicated at block . In response, the object graph builder  may update the object graph  to reflect the removal of the reference to the object, as indicated at block  (). In addition, the root record graph builder  may update the root record graph  to reflect the removal of the reference, as indicated at block .","Regarding the object graph , the object graph builder  locates the edge that corresponds to the removed or changed reference, and may delete that edge from the object graph . For example, suppose the following command is entered in the environment :\n\nx=5;\u2003\u2003(6)\n\nAt command (1) mentioned above, the variable \u2018x\u2019 had previously been set to reference the object \u2018myObject\u2019. With the entry of command (6), the reference from variable \u2018x\u2019 to \u2018myObject\u2019 is removed. The reference from variable \u2018x\u2019 to \u2018myObject\u2019 is represented in the object graph  by edge . The object graph builder  may remove edge  from the object graph . The object graph builder  may enter the object graph  at node , which represents the variable \u2018x\u2019, and remove edge  which leads from node  to node . An edge of the object graph  may be removed by marking the edge as invalid. If the variable \u2018x\u2019 had referenced other objects, the edges of the object graph  representing these other references would also be removed.\n","Regarding the root record graph , the root record graph builder  may similarly locate root record , which corresponds to the variable \u2018x\u2019, and remove edge , which leads to root record . If the root record graph  included other edges leading to node , they too would be removed.","In addition to removing edges that correspond to removed references, the cache management engine  may invalidate cached root path information that relies on the removed edge, as indicated at block . Here, the root path information represented by Path Cache  relies on edge  of the root record graph . Accordingly, the cache management engine  may invalidate the root path information by setting the Is_Path_Live flag  for the Path Cache  to False. The next time a root record that used Path Cache  to cache root path information is queried as to whether it is rooted, a search of the root record graph  may need to be performed, and the root record's cache refreshed.","In an embodiment, a Path Cache may only transition from a Live state to a not Live state. For example, if the reference represented by edge  of the root record graph  were to be subsequently re-established, the cache management engine  may create a new Path Cache, rather than transition Path Cache  from a not Live to a Live state.","In response to a reference to an object being removed or changed, and the corresponding edges of the object graph  and the root record graph  being removed, the root finder  may query one or more root records to determine whether those root records are still rooted, as indicated at block . For example, the root finder  may determine that edge , which has been removed, connected root record  to root record . The root finder  may thus query root record  to determine whether it is rooted following the removal of edge  from the root record graph . In an embodiment, the root finder  may only perform root searches for a root record in response to a reference being removed or going away.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 9","b":["206","902","206","904","906","506","700","908","910","506","912","914","804","804","916","906"]},"Returning to decision block , if the root record does not have a pointer to a Path Cache, the root finder  may, as discussed above, traverse the root record graph  to determine whether there is a valid path to a root for the root record, as indicated by No arrow  leading to block . Similarly, if the root record has a pointer to a Path Cache, but the Path Cache is not live, the root finder  may traverse the root record graph  to determine whether the root record is rooted, as indicated by No arrow  also leading to block .","For root record , its is_Root flag is False and while it has a pointer to Path Cache , this Path Cache is no longer live. Accordingly, the root finder  proceeds to calculate a root path for root record . Because edge  leading to root record  has been removed, there is no path from root record  to a root of the root record graph . In this case, the object lifecycle engine  determines that the object represented by root record , i.e., \u2018myObject\u2019, is no longer reachable. In response to determining that an object is no longer reachable, the object lifecycle engine  may mark the root record associated with the unreachable object as invalid, as indicated at block  (). For example, the root record builder  may set the is_Valid flag  for the root record to False. The object lifecycle engine  may also notify the object oriented environment  that the object \u2018myObject\u2019 has reached the end of its lifetime, as also indicated at block .","The environment  may take appropriate action in response to this notification from the object lifecycle engine . For example, if a destructor is defined for the object \u2018myObject\u2019, the destructor may be called by the object oriented environment , as indicated at block . In addition, all resources allocated to or reserved by the object \u2018myObject\u2019 may be released for use by other objects or entities of the environment , as indicated at block  ().","For root record , while it too has a pointer to Path Cache , this Path Cache is no longer live. Accordingly, the root finder  proceeds to calculate a root path for root record . In this case, a root path is found from root record  to root record , which is another root of the rood record graph . The cache management engine  may cache this new root path information, as indicated at block . For example, the cache management engine  may create a new Path Cache node  to cache this new root path for root record . Furthermore, the Root Path Cache field  for root record  may be updated to point to Path Cache , as illustrated by arrow . Similarly, the Root Path Cache field  for root record  is updated to point to the new Path Cache , as illustrated by arrow .","The root record graph builder  also may remove edges to and from a root record that has been invalidated, as indicated at block . This, in turn, may result in other root records becoming un-rooted, and their corresponding objects thus deemed unreachable. That is, the root record builder , root finder  and cache management engine  may repeat steps -, as the removal or change of a reference may result in the invalidation of more than one root record and the removal of additional edges.","In an embodiment, a reference to an object may be removed or changed in response to a number of different commands or operations in the object oriented environment . For example, in addition to setting a variable that previously referenced an object to a constant value, the variable may be set to a different value including null or an empty array, the element of a cell array that previously referenced an object may be set to a different value or to null, a variable may be set to another value, and a command that clears a variable may be called, among others. Similarly, a property of an object may be set to null or an empty array. When a function goes out of scope, its variables may be cleared or destroyed, and the system or environment  may notify the object lifecycle engine  that the root records representing those variables are no longer roots and that the values referenced by those variables may be considered ready for destruction.","In an embodiment, the determination of whether one or more objects have become unreachable and the actions taken if an object is determined to be unreachable, such as releasing resources, may be performed as part of the operation that led to the object becoming unreachable (the removal of a reference, a variable going out of scope, etc.). Doing so may enable the object lifecycle engine  to provide deterministic behavior. It is often desirable for a program make use of objects that define destructors or functions that perform actions when an object is destroyed. When such destructors are invoked as soon as an object becomes unreachable by the program, then it simpler to reason about when these destructors will be invoked and how the timing of their operations will effect program execution. In alternative systems that rely on periodic sweeping of objects that became unreachable previously, the order of destructor execution becomes much less regular in two important ways. One, the order of destructor execution of one unreachable object relative to others cannot be easily determined by understanding the program and system. Secondly, the order of execution of destructors relative to other operations within a program may depend on numerous internal and external factors including the size of memory available on the specific hardware. Thus, a programmer cannot easily reason about how destructors may interact with other parts of the program or be certain that the program will meet user requirements.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 10","b":["1002","1004","1002","1002","1006","1008","1011","1012","1006","1008","1014","1016","1002","1018","1020","1008"]},"The root record graph  includes a plurality of root records - interconnected by edges -. Specifically, the root record graph  includes a root record for each node of the object graph , and an edge for each edge of the object graph . For example, root record  corresponds to object node , edge  corresponds to edge , root record  corresponds to object node , edge  corresponds to edge , and so on.","Suppose one or more operations are entered at the object oriented environment, e.g., through user interaction or programmatically, that modify the reference from the second variable such that the second variable steps through each object instance of the linked list sequentially from the head, e.g., node , to the tail, e.g., node . That is, suppose a series of operations occur such that the second variable, instead of referencing the first object instance of the linked list, references the second object instance of the linked list, then references the third object instance of the list, and so on. The object lifecycle engine  may be notified when the second variable  is changed to reference the second object instance of the linked list, which corresponds to object node . In response, the object graph builder  may modify the object graph , and the root record graph builder  may in turn modify the root record graph .",{"@attributes":{"id":"p-0118","num":"0117"},"figref":["FIG. 11","FIG. 10","FIG. 10"],"b":["1002","1004","202","1020","202","1042","1018","1009","204","1040","1044","1032","1035","202","1018","1009"]},"Because an edge of the object graph  has been removed, and an edge of the root record graph  has consequently been removed, the root finder  determines whether the affected node, i.e., object node , which corresponds to the first object instance of the list, is still rooted. Specifically, the root finder  may analyze the modified root record graph \u2032. The root finder  may determine that root record , which corresponds to object node , has a path to root record , which is a root of the modified root record graph . Accordingly, the root finder  may determine that object node  is still rooted, and therefore that the object instance that corresponds to object node  has not reached the end of its lifecycle. In addition, the cache management engine  may cache this root path information for root record , which corresponds to object node , in the modified root record graph \u2032. Specifically, the cache management engine  may create a Path Cache node  in the modified root record graph \u2032, and update root record  to include a pointer to the Path Cache node .","Next, one or more operations may be performed such that the second variable changes its reference from the second object instance of the linked list to the third object instance of the linked list, which corresponds to object node . In this case, edge  from the modified object graph \u2032 is removed, and edge  from the modified root record graph \u2032 is removed. Likewise, new edges from object node  to object node , and from root record  to root record  are added. Furthermore, because a reference to the preceding object instance of the linked list has been removed, the object lifecycle engine  determines whether this object instance, which corresponds to object node , is still rooted. Specifically, the root finder  may analyze the new root record graph (not shown), to determine whether root record  is still rooted. The root finder  may determine that root record  leads to root record , and that root record  includes a pointer to a valid Path Cache node, i.e., node . The root finder  may thus determine that root records  and  are both rooted. The cache management engine  also may update the root record  to include a pointer to the Path Cache node .","This process may be repeated as further operations are performed causing the second variable to reference different object instances of the linked list. Furthermore, by updating the respective root records to point to the Path Cache node , a search of the entire root record graph may be avoided as second variable is stepped through the different object instances of the linked list. Instead, as described herein, the root finder  may only need to traverse one root record of the root record graph  to determine that a current root record is still rooted.",{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIG. 12","b":["1202","1204","1202","1202","1206","1208","1210","1212","1206","1208","1213","1208","1209","1214","1209","1210","1215","1210","1208"]},"The root record graph  includes a plurality of root records - interconnected by edges -. Specifically, the root record graph  includes a root record for each node of the object graph , and an edge for each edge of the object graph . For example, root record  corresponds to object node , edge  corresponds to edge , root record  corresponds to object node , edge  corresponds to edge , and so on.","Suppose one or more operations are entered at the object oriented environment , e.g., through user interaction or programmatically, that remove the reference from the variable to the first object instance. In response, the object graph builder  may modify the object graph , and the root record graph builder  may in turn modify the root record graph .",{"@attributes":{"id":"p-0125","num":"0124"},"figref":["FIG. 13","FIG. 12","FIG. 12"],"b":["1202","1204","202","1212","204","1224","1202","1204","206","1208","206","1204","1221","1208","1204"]},"The root finder  may first determine that root record  points to root record , as a parent of root record . The root finder  may thus proceed to examine root record . Here, the root finder  determines that root record  is not itself a root of the modified root record graph \u2032, and does not have a pointer to a valid Path Cache. Nonetheless, the root finder  determines that root record  points to root record  as a parent of root record . Accordingly, the root finder  may examine root record . The root finder  determines that root record  is not a root, and that root record  does not point to a valid Path Cache.","However, the root finder  determines that root record  points to root record , as a parent of root record . The root finder  may thus examine root record . Here, the root finder  determines that it has already visited root record  as part of its analysis of the modified root record graph \u2032. For example, as the root finder  examines root records of the graph, it may flag those root records that it has examined by asserting the isMarked flag  of the respective root record. When the root finder  examines root record  it determines that the is_Marked flag  for root record  is already set. In this case, the root finder  may determine that it has returned to the first analyzed root record without finding a root. The object lifecycle engine  may notify the object oriented environment  that the object instances of the entire cycle, e.g., the object instances corresponding to object nodes - have reached the end of their lifetimes.","In an alternative embodiment, the object graph builder  may remove or mark as invalid object node , and edges  and\/or . Similar changes may be reflected in the modified root record graph \u2032 by the root record graph builder . In response to the removal of edges  and\/or , the root finder  may determine whether root record  is rooted. The root finder  may determine that root record  is not rooted. This process may be continued, and the root finder  may determine that root record  also is not rooted. In response to these determinations, the object lifecycle engine  may notify the object oriented environment  that the object instances corresponding to object nodes  and  have reached the end of their lifetimes.","Shared Ring","In an embodiment, two or more variables, such as a cell arrays, may share data. Variables that share data may be linked in the object graph  and the root record graph  in a ring structure.  is a schematic illustration of a combination object\/root record graph  illustrating a ring structure. Suppose a user enters commands for creating two variables, such as cell arrays, that both reference two objects, i.e., the variables share the objects. In response, the object graph builder  may create object nodes for the two variables, such as object nodes , , and object nodes for the two objects, such as object nodes , . The object graph builder  may also creates edges from nodes ,  to nodes , , such as edges -. The root record builder  may similarly create two root records ,  that correspond to the two variables, and thus to the two object nodes , . Because the object nodes ,  are part of a shared ring, the root record builder  also may create a dummy root record . The root record builder  also may create two root records ,  for the objects represented by object graph nodes , . The Parents fields  of root records , , moreover, each may be loaded with pointers to the dummy root record  of the ring, rather than to the root records , , which represent the variables corresponding to object nodes , . In addition, the root record builder  may load the Next fields  for the root records ,  with pointers to the dummy root record , as opposed to loading these Next fields with pointers to root records , . The is_Link_Dummy flag  of root record  may be asserted to designate root record  as a dummy root record of a shared ring. The parents field  of the \u2018dummy\u2019 root record  may include pointers to the other root records ,  of the ring.","Embedded System","As mentioned, the invention may be used in other systems besides the data processing system illustrated in . For example, the object lifecycle engine  may be implemented within in an embedded system. Examples of embedded systems in which the object lifecycle engine  may be used include mobile phones, factory automation systems, communication appliances, such as access points and modems, car systems, such as audio, navigation, driver display, engine control, and networking, cable television set-top boxes, etc.","As described above, the object lifecycle engine  in cooperation with the object oriented environment  provides a deterministic procedure for destroying unreachable objects and releasing the resources allocated to or reserved by an object that has become unreachable. The releasing of resources, moreover, may occur immediately upon the object becoming unreachable. As a result, a user, such as a programmer, utilizing the object oriented environment  and the object lifecycle engine  will know that resources allocated to or reserved by an object will be released as soon as that object becomes unreachable. The programmer may thus create an application or program in which resources reserved by a first object may be made available to a second object immediately upon the first object becoming unreachable in the application or program. For example, the programmer may create a destructor for releasing resources and performing other clean-up tasks. With the object lifecycle engine , the programmer, moreover, will know that the destructor will be called immediately, e.g., as a next operation, when the associated object becomes unreachable. The releasing of resources, moreover, is performed automatically by the object lifecycle engine and the object oriented environment , thereby freeing the programmer from having to include explicit commands to perform such clean-up operations, other than possibly including a destructor. Such a feature provides a significant advantage when operating in an embedded system where resources, such as memory, file handles, sockets, etc., are often extremely limited.","Similarly, by releasing resources of unreachable objects in a deterministic manner, embedded systems that include the object lifecycle engine  may be run continuously for long periods of time, e.g., months or years, without having to be periodically shut down. In embedded systems it is frequently necessary to be able to determine an upper bound on the time to perform a given operation. Garbage collection systems can interfere with the ability to establish such an upper bound because if an operation may require the garbage collector to free up resources, then the time it takes for the garbage collector to run may not be sufficiently deterministic.","In an embodiment, the nodes of the object graph  and the nodes of the root record graph  may be implemented as objects defined from, for example, an object node class, and a root record node class. Furthermore, operations performed on the nodes of the graphs ,  may be implemented by performing methods supported by those objects.","Web Services","Web services are self-contained, modular applications that can be described, published, located and invoked over a network, such as the World Wide Web, using standard Internet technologies. Many web services operate in accordance with the Simple Object Access Protocol (SOAP), which defines messages for passing Remote Procedure Calls (RPCs) and data encoded by the eXtensible Mark-up Language (XML) to and from the web service. Typically, the Hyper Text Transport Protocol (HTTP) is used as the transport mechanism between the web service and the consumers of that service.","The .NET framework from Microsoft Corp. includes Visual Studio .NET, which facilitates the creation of web applications, including web services. For example, a program developer can define a class that is to be exposed as a web service. The developer then creates certain methods and declares them to be public making them available as a service. Using the Web Service Description Language (WSDL), the programmer can detail where the web service is located and how to interact with it, thereby allowing others to access and invoke the web service.","To use a web service, a proxy web service class is typically created at the consumer site based on the WSDL description of the web service. Program objects created from the proxy web service class may use SOAP over HTTP to communicate with the web service. More specifically, these objects handle the work of mapping parameters to XML elements and encapsulating the XML elements in SOAP messages for transmission to the web service. The proxy web service objects similarly recover parameters from the XML elements received in SOAP messages from the web service. A client application can then be created that interacts with the proxy web service object to specify the information to be sent to the web service and utilize the information returned from the web service. Other technologies may also be used to create and use web services.","In an embodiment, the object oriented environment  and\/or the object lifecycle engine  may be implemented as a web service. For example, the object lifecycle engine  may be accessed, e.g., by the object oriented environment , as a web service that determines when objects have reached the end of their lifetimes. The functionality of the object lifecycle engine  thus may be located remotely relative to the object oriented environment , and may manage objects created by different object oriented environments. Likewise, the object oriented environment  may be a web service that provides one or more services to consumers. The object lifecycle engine  could be a part of that same web service.","In an embodiment, the object lifecycle engine  may be used to manage the lifetimes of components other than objects. For example, to the extent a system, such as the MATLAB technical computing environment, assigns a separate workspace to each function, and limits the scope of variables used by the function to its workspace, the object lifecycle engine  may manage the lifetimes of such workspaces.","In an embodiment, the object and the root record graphs ,  may be combined into a single graph. For example, the object node data structures and the root record data structures may be combined into a single data structure.","In an embodiment, the object lifecycle engine  may run in parallel with the operation of the object oriented environment . For example, a multicore processor may be used such that a first processing core runs the object oriented environment , while a second processing core runs the object lifecycle engine . In another embodiment, the object lifecycle engine  or some part of it may run as a background process or thread relative to the object oriented environment . In yet another embodiment, updates to Path Cache nodes may be made on a background thread or process while changes to the rest of the graphs are only made on the same thread or threads that execute code using the objects.","The foregoing description of embodiments is intended to provide illustration and description, but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from a practice of the invention. For example, while a series of acts has been described above with respect to  and , the order of the acts may be modified in other implementations. Further, non-dependent acts may be performed in parallel. Also, the term \u201cuser\u201d, as used herein, is intended to be broadly interpreted to include, for example, a computer or data processing system (e.g., system ) or a user of a computer or data processing system, unless otherwise stated.","Further, certain embodiments of the invention may be implemented as logic that performs one or more functions. This logic may be hardware-based, software-based, or a combination of hardware-based and software-based. Some or all of the logic may be stored in one or more tangible non-transitory computer-readable storage media and may include computer-executable instructions that may be executed by a computer or data processing system, such as system . The computer-executable instructions may include instructions that implement one or more embodiments of the invention. The tangible non-transitory computer-readable storage media may be volatile or non-volatile and may include, for example, flash memories, dynamic memories, removable disks, and non-removable disks.","No element, act, or instruction used herein should be construed as critical or essential to the invention unless explicitly described as such. Also, as used herein, the article \u201ca\u201d is intended to include one or more items. Where only one item is intended, the term \u201cone\u201d or similar language is used. Further, the phrase \u201cbased on\u201d is intended to mean \u201cbased, at least in part, on\u201d unless explicitly stated otherwise.","The foregoing description has been directed to specific embodiments of the present invention. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. For example, the object oriented environment  may collect a set or group of object creations, and issue the set or group to the object lifecycle engine as a batch. Environment  may also collect a set or group of references, and send them to the object lifecycle engine  as a batch. The object lifecycle engine  may be combined with other mechanisms for determining the end of an object's lifecycle. For example, the object lifecycle engine may be combined with the mechanism described in U.S. Pat. No. 7,237,237. In an embodiment, a language interpreter, compiler, or just-in-time compiler may determine lifecycles of certain objects based on static or dynamic analysis of scripts or programs being executed while the object lifecycle engine may be used to determine object lifecycles for all other objects. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention."],"BRFSUM":[{},{}],"DETDESC":[{},{}]}
