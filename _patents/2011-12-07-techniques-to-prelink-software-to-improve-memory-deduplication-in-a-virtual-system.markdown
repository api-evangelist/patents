---
title: Techniques to prelink software to improve memory de-duplication in a virtual system
abstract: Techniques to prelink software to improve memory de-duplication in a virtual system are described. An apparatus may comprise a processor circuit, a memory unit coupled to the processor circuit to store private memory pages for multiple virtual machines, and a dynamic linker application operative on the processor circuit to link a binary version of a software program with associated program modules at run-time of the binary version on a virtual machine. The dynamic linker application may comprise a master prelink component operative on the processor circuit to relocate a first set of program modules for a first binary version of the software program for a first virtual machine using a first set of virtual memory addresses from a first private memory page allocated to the first virtual machine, and store relocation information for the first set of program modules in a global prelink layout map for use by a second virtual machine. Other embodiments are described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09170940&OS=09170940&RS=09170940
owner: INTEL CORPORATION
number: 09170940
owner_city: Santa Clara
owner_country: US
publication_date: 20111207
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["A virtual machine (VM) is a software implementation of a machine (e.g., a computer) that executes programs like a physical machine. Virtual machines are separated into two major categories, based on their use and degree of correspondence to any real machine. A system virtual machine provides a complete system platform which supports the execution of a complete operating system (OS). In contrast, a process virtual machine is designed to run a single program, which means that it supports a single process. An essential characteristic of a virtual machine is that the software running inside is limited to the resources and abstractions provided by the virtual machine.","With only a small percentage of a physical machine in use at a given time, virtualization allows a physical machine to be shared to increase its overall utilization. One design factor with virtualization is efficient sharing of hardware resources provided by a physical machine, such as processor, memory and networking bandwidth. Processor and networking resources are typically underutilized even in a virtual environment. However, memory resources are often in high demand. Therefore, memory management techniques directed to efficient memory sharing in a virtual environment potentially enables virtual machines to be more dynamic, power efficient and cost efficient. It is with respect to these and other considerations that the present improvements have been needed.","Various embodiments are generally directed to virtualized systems. Some embodiments are particularly directed to enhanced memory management techniques for virtualized systems supporting multiple virtual machines. In one embodiment, for example, prelinking operations for software programs may be performed in a manner to facilitate and support memory management operations for a virtual system.","As discussed in more detail below, a virtual system typically implements both prelinking techniques to improve program load times and memory management techniques to improve memory usage. In conventional virtual systems, prelinking and memory management are treated as distinct and separate procedures. However, prelinking operations may significantly impact memory management operations. Current optimizations for prelinking operations include a randomization component that randomizes memory addresses used by a software program and associated software libraries. Randomizing memory addresses makes it more difficult for memory management techniques to locate and merge duplicative content in memory. This creates a significant performance penalty for memory management techniques in a virtual system.","To solve these and other problems, various embodiments implement enhanced prelinking techniques for software programs specifically designed to improve memory management operations of a virtual system. A virtual system may implement multiple virtual machines, each allocated one or more private memory pages in a private memory segment of a memory unit. In those cases where multiple virtual machines utilize identical software programs and associated libraries, the enhanced prelinking techniques removes a randomization component for relocation operations of the associated libraries, thereby allowing the associated libraries to be stored using a known virtual address space in different private memory pages. A memory management technique, such as memory de-duplication, may locate multiple private memory pages storing the identical libraries using the known virtual address space, and transform the multiple private memory pages into a shared memory page for the virtual machines. This allows more efficient memory sharing in a virtual environment, and potentially enables virtual machines to be more dynamic, power efficient and cost efficient. As a result, the embodiments can improve affordability, scalability, modularity, extendibility, or interoperability for an operator, device or network.","With general reference to notations and nomenclature used herein, the detailed descriptions which follow may be presented in terms of program procedures executed on a computer or network of computers. These procedural descriptions and representations are used by those skilled in the art to most effectively convey the substance of their work to others skilled in the art.","A procedure is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. These operations are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical, magnetic or optical signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It proves convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like. It should be noted, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to those quantities.","Further, the manipulations performed are often referred to in terms, such as adding or comparing, which are commonly associated with mental operations performed by a human operator. No such capability of a human operator is necessary, or desirable in most cases, in any of the operations described herein which form part of one or more embodiments. Rather, the operations are machine operations. Useful machines for performing operations of various embodiments include general purpose digital computers or similar devices.","Various embodiments also relate to apparatus for performing these operations. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer as selectively activated or reconfigured by a computer program stored in the computer. The procedures presented herein are not inherently related to a particular computer or other apparatus. Various general purpose machines may be used with programs written in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these machines will appear from the description given.","Reference is now made to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding thereof. It may be evident, however, that the novel embodiments can be practiced without these specific details. In other instances, well known structures and devices are shown in block diagram form in order to facilitate a description thereof. The intention is to cover all modifications, equivalents, and alternatives consistent with the claimed subject matter.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","120","130","150","120","138","140","142","144","146","100","100"]},"In various embodiments, the memory management apparatus  may comprise an electronic device . Examples of an electronic device  may include without limitation an ultra-mobile device, a mobile device, a personal digital assistant (PDA), a mobile computing device, a smart phone, a telephone, a digital telephone, a cellular telephone, eBook readers, a handset, a one-way pager, a two-way pager, a messaging device, a computer, a personal computer (PC), a desktop computer, a laptop computer, a notebook computer, a netbook computer, a handheld computer, a tablet computer, a server, a server array or server farm, a web server, a network server, an Internet server, a work station, a mini-computer, a main frame computer, a supercomputer, a network appliance, a web appliance, a distributed computing system, multiprocessor systems, processor-based systems, consumer electronics, programmable consumer electronics, game devices, television, digital television, set top box, wireless access point, base station, subscriber station, mobile subscriber center, radio network controller, router, hub, gateway, bridge, switch, machine, or combination thereof. The embodiments are not limited in this context.","In various embodiments, the memory management apparatus  may comprise a processor circuit . The processor circuit  may comprise a general purpose processor circuit used for general purpose computing, such as a central processing (CPU) for a computing platform. The processor circuit  can be any of various commercially available general purpose processors, including without limitation an AMD\u00ae Athlon\u00ae, Duron\u00ae and Opteron\u00ae processors; ARM\u00ae application, embedded and secure processors; IBM\u00ae and Motorola\u00ae DragonBall\u00ae and PowerPC\u00ae processors; IBM and Sony\u00ae Cell processors; Intel\u00ae Celeron\u00ae, Core (2) Duo\u00ae, Itanium\u00ae, Pentium\u00ae, Xeon\u00ae, and XScale\u00ae processors; and similar processors. Dual microprocessors, multi-core processors, and other multi-processor architectures may also be employed as the processor circuit . The embodiments are not limited in this context.","In various embodiments, the memory management apparatus  may comprise a memory unit . The memory unit  may include various types of computer-readable storage media in the form of one or more higher speed memory units, such as read-only memory (ROM), random-access memory (RAM), dynamic RAM (DRAM), Double-Data-Rate DRAM (DDRAM), synchronous DRAM (SDRAM), static RAM (SRAM), programmable ROM (PROM), erasable programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), flash memory, polymer memory such as ferroelectric polymer memory, ovonic memory, phase change or ferroelectric memory, silicon-oxide-nitride-oxide-silicon (SONOS) memory, magnetic or optical cards, an array of devices such as Redundant Array of Independent Disks (RAID) drives, solid state memory devices (e.g., USB memory, solid state drives (SSD)), and any other type of storage media suitable for storing information. The embodiments are not limited in this context.","In the illustrated embodiment shown in , the processor circuit  may be arranged to execute specialized software programs including a virtualization application , a memory management application , a software program , a loader application , and a dynamic linker application . Although these software programs are illustrated and described as executed by the processor circuit , it may be appreciated that some portions or all of these software programs may be executed by other processor circuits implemented by the electronic device , such as a graphics processing unit (GPU), a baseband processor for a transceiver, and so forth. The embodiments are not limited in this context.","As shown in , the memory management apparatus  may include a virtualization application . The virtualization application  is generally arranged to install and manage multiple virtual machines -on the electronic device . In general, a virtual machine -is an abstract or simulated computer architecture that can be implemented in hardware or software. Either implementation is intended to be included in the following descriptions of a virtual machine -. In one embodiment, for example, a virtual machine -is a software implementation of a machine that executes programs like a physical machine, such as the electronic device . The virtualization application  may implement a virtual machine -as a system virtual machine that provides a complete system platform capable of supporting execution of a complete operating system (OS) and\/or application programs, represented as software program . Additionally or alternatively, the visualization application  may implement a virtual machine -as a process virtual machine designed to run a single program, which means that it supports a single process. The virtual machines -may use or share various hardware resources provided by the electronic device , such as the processor circuit  and the memory unit , among other computing and communications platform components implemented by the electronic device .","The virtualization application  may be implemented using any number of known virtualization software and\/or hardware platforms. Examples for the visualization application  may include without limitation virtualization applications such as Kernel-based Virtual Machine (KVM)\u00ae made by Red Hat\u00ae, Inc., Oracle\u00ae VM\u00ae made by Oracle Corporation, VMware\u00ae ESX\u00ae made by VMware, Inc., and VxWorks\u00ae made be Wind River Systems\u00ae, Inc., z\/VM\u00ae made by International Business Machines\u00ae Corporation, and similar virtualization platforms. The embodiments are not limited in this context.","Although various embodiments are described in the context of virtual machines -as created and managed by the virtualization application , it may be appreciated that some embodiments may be implemented for any electronic device  providing a hardware platform that is segmented into multiple, discrete, computing portions. For instance, various embodiments may be implemented using system partitions that separate a single hardware platform into multiple hardware sub-systems. For instance, a hardware platform having multiple processors and memory units may be partitioned into two hardware sub-systems, each having a processor and a memory unit. The embodiments are not limited in this context.","It is worthy to note that \u201ca\u201d and \u201cb\u201d and \u201cc\u201d and similar designators as used herein are intended to be variables representing any positive integer. Thus, for example, if an implementation sets a value for a=5, then a complete set of virtual machines -may include virtual machines -, -, -, - and -. The embodiments are not limited in this context.","The virtualization application  may implement any number of virtualization techniques to create the virtual machines -, including a virtual machine manager (VMM) or a hypervisor, among other virtualization techniques. In various embodiments, there are two general types of virtual machines -. A first type is a master virtual machine. A second type is a guest virtual machine. A master virtual machine is the main virtual machine and generally manages operations for one or more guest virtual machines. For instance, a VMM may execute in the master virtual machine to provide a virtual operating platform for guest virtual machines and manage execution of guest operating systems. A guest virtual machine follows control directives from the VMM executing in a master virtual machine. A typical implementation has a single master virtual machine, and multiple guest virtual machines. As shown in , for example, the virtualization application  may implement a VMM to create a master virtual machine -, and guest virtual machines -, -. It may be appreciated, however, that there may any number of master virtual machines and guest virtual machines in various combinations. For instance, a virtual system may have multiple master virtual machines, each controlling operations for different sets of guest virtual machines. The embodiments are not limited in this context.","The memory management apparatus  may include a memory management application . The memory management application  is generally arranged to perform memory management operations for a set of virtual machines -. Each virtual machine -may be allocated a discrete portion of memory, such as a private memory segment, from the memory unit . Each virtual machine -may then read and write a set of private memory pages -to its private memory segment. A private memory page -is a memory page which has restricted access. For example, the virtualization application  implements security measures to ensure a first virtual machine - may not access private memory pages -for a second virtual machine -, and vice-versa.","In general, a memory page (sometimes referred to as a virtual page or simply page) is a fixed-length contiguous block of virtual memory that is a smallest unit for memory allocation by an operating system for a program and transfer between main memory and an auxiliary store, such as a hard disk drive. Page size is usually determined by processor architecture. Traditionally, pages in a system had uniform size, for example 4096 bytes. However, modern processor designs often allow two or more, sometimes simultaneous, page sizes due to the benefits and penalties. There are several points that can factor into choosing a given page size, including factors such as page size versus page table size, page size versus translation lookaside buffer (TLB) usage, internal fragmentation of pages, page size versus disk access, and so forth.","In one embodiment, the virtual machines -may execute similar operating systems and application programs, such as different versions of a software program . When executing an identical software program  on each of multiple virtual machines -, many private memory pages -for those virtual machines -are identical as well. When private memory pages -are identical and therefore have duplicative content, they can be consolidated into a shared memory page -, thereby releasing memory for use in other applications. For example, a shared memory page - may be accessed by a set of multiple virtual machines -, - having the identical private memory pages -, -, respectively, used to create the shared memory page -. In this sense the shared memory page - is still private in that the shared memory page - may not be accessed by other virtual machines -outside of the virtual machines -, -.","The memory management application  may implement one or more background processing threads or daemons that periodically perform scans of private memory pages -to identify duplicate (or identical) memory pages, and merge duplicate memory pages together to form a shared memory page -. In one embodiment, a shared memory page -may be subsequently marked as a read-only file. In one embodiment, merge operations may be performed using a copy-on-write (CoW) technique. The memory de-duplication process releases memory resources from the memory unit  for use by other applications. When a virtual machine -changes a shared memory page -for any reason, then the memory management application  may provide a new private memory page -for the virtual machine -making the change.","The memory management apparatus  may include a software program . The software program  may comprise any independent software program suitable for execution by the processor circuit . Examples of software program  may include system programs and application programs. System programs generally may assist in the running of the electronic device  and may be directly responsible for controlling, integrating, and managing the individual software and hardware components of a computer system. Examples of system programs may include, without limitation, an operating system (OS), device drivers, programming tools, utility programs, software libraries, application programming interfaces (APIs), and so forth. Application programs generally may allow a user to accomplish one or more specific tasks. Examples of application programs may include, without limitation, one or more messaging applications (e.g., telephone, voicemail, facsimile, e-mail, instant messaging, short messaging service, multimedia messaging service, video conferencing), a web browser application, personal information management (PIM) applications (e.g., contacts, calendar, scheduling, tasks), word processing applications, spreadsheet applications, database applications, media applications (e.g., video player, audio player, multimedia player, digital camera, video camera, media management), gaming applications, productivity applications, enterprise applications, and so forth. In various implementations, the application programs may provide one or more graphical user interfaces (GUIs) to communicate information between the electronic device  and a user. The embodiments are not limited in this context.","The memory management apparatus  may include a loader application . The loader application  is a software program generally responsible for loading a software program  into the memory unit  and preparing it for execution by the processor circuit . The entire software program  may be loaded at once before execution, or loaded in stages when actually needed during execution (e.g., using a memory-mapped file technique). In many cases, a software program  may utilize one or more software libraries -to function. A software library -contains a collection of discrete sets of code and data, referred to herein as program modules, which provide services to independent software programs such as the software program . In such cases, the loader application  also needs to locate and load program modules from a software library -used by the software program  during load operations.","The memory management apparatus  may include a dynamic linker application . The dynamic linker application  is generally responsible for linking a software program  and one or more program modules from one or more software libraries -. Since a software program  and program modules from a software library -are independent programs, to facilitate modular programming, the software program  and the program modules typically refer to each other using symbols. In some cases, the symbols used by each program may be different or undefined. The dynamic linker application  resolves these symbols to allow the software program  and any associated program modules from a software library -to operate as a unified executable program. The dynamic linker application  performs dynamic linking operations during run-time of the software program . By way of contrast, a static linker is typically used at compile-time to produce a binary version of a software program (e.g., an executable file). For instance, the dynamic linker application  resolves symbols during run-time, while a static linker resolves symbols during compile-time.","The dynamic linker application  provides significant advantages in code size and management. However, dynamic linking increases complexity for the loader application . The loader application  needs to locate a software program  and associated program modules from a software library -every time the software program  is executed. For security reasons, a software library -is moved around in a process address space. For instance, address space layout randomization is a security technique that randomly arranges positions of key data areas in the memory unit , including the software libraries -, to make it more difficult for an attacker to predict target addresses. However, since a software library -can move, the loader application  incurs a performance penalty when locating the software library -in order to load with the software program . The more software libraries -to resolve, the larger the performance penalty.","To compensate for this performance penalty, the dynamic linker application  may implement prelinking operations (also called prebinding). Prelinking is a process of linking an executable file, such as a binary version of the software program , with program modules from a software library -after compile-time but before run-time of the executable file on the processor circuit . This reduces program load time (or boot time) for the software program . However, security techniques such as address space layout randomization cannot be used with prelinking since to do so would require relocating the software libraries -in the memory unit , thereby defeating any advantages of prelinking. In an attempt to restore some of the benefits of address space layout randomization, conventional prelinking operations randomly selects addresses used for prelinking. This makes it more difficult to perform certain attacks on a system, because the addresses used for prelinking are unique to that system.","While prelinking with random addresses seems a viable solution for physical machines using a single process space and address space, prelinking with random addresses causes a performance penalty for the memory management application  used by a virtual system, such as illustrated by the memory management apparatus . The memory management application  may implement memory de-duplication techniques to detect duplicate private memory pages -and share them among multiple virtual machines -. However, prelinking with random addresses causes software libraries -to be located at different virtual memory addresses in private memory pages -allocated to each virtual machine -. As such, memory management application  needs to search and locate identical libraries at different virtual memory addresses in each private memory page -to perform memory de-duplication, thereby increasing cost, complexity and performance of memory de-duplication techniques.","The dynamic linker application  solves these and other problems by implementing enhanced prelinking techniques for software programs  to improve performance of the memory management application  in a virtual system. In those cases where multiple virtual machines -utilize identical software programs  (e.g., a system program or an application program) and associated software libraries -, the dynamic linker application  implements enhanced prelinking techniques that removes a randomization component for relocation operations of the associated software libraries -, thereby allowing the associated libraries -to be stored using a known virtual address space in different private memory pages -. The memory management application  may use a memory management technique, such as memory de-duplication, to locate multiple private memory pages -storing the identical software libraries -using the known virtual address space, and transform the multiple private memory pages -into a shared memory page -for the virtual machines -. This allows more efficient memory sharing in a virtual environment, and potentially enables virtual machines -to be more dynamic, power efficient and cost efficient.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2","b":["200","100","200","146","130","200","160","1","202","1","146"]},"As previously described with reference to , the dynamic linker application  is operative on the processor circuit  to perform dynamically link a binary version  of the software program  with associated program modules -at run-time of the binary version  on the processor circuit .","A binary version  of the software program  may comprise a compiled version of source code. Examples for the binary version  of the software program  may include without limitation a binary object, a binary file, an executable file, and so forth. In general, a computer program such as software program  is written as source code statements in a high level language which is easy for a human being to understand. As the computer programs are actually executed, a computer responds to machine code, which consists of instructions comprised of binary signals that directly control the operation of a central processing unit (CPU), such as the processing circuit . A special program called a compiler is used to read the source code and to convert its statements into the machine code instructions of the specific CPU. The machine code instructions thus produced are platform dependent, that is, different computer devices have different CPUs with different instruction sets indicated by different machine codes.","The program modules -may comprise various program modules from one or more of the software libraries -, shown as software library - in . The dynamic linker application  may link the program modules -to the binary version  of the software program  during run-time of the binary version  on the processor circuit .","To perform dynamic linking, the master virtual machine - may implement one or more components -of the dynamic linker application . One or more of the components -may be arranged to perform various prelinking operations to prelink the binary version  of the software program  with associated program modules -from one or more software libraries -just before run-time of the binary version  on the processor circuit . Prelinking the software program  with associated program modules -reduces program load time for the loader application  when a user actually desires to initiate execution of the software program .","As shown in , for example, the master virtual machine - may implement a master prelink component - of the dynamic linker application . The master prelink component - may be generally arranged to perform prelinking operations for a software program  and associated software libraries -for the master virtual machine -, which is then used as a template for one or more guest virtual machines -, -.","In one embodiment, the master prelink component - may be arranged to relocate a first set of program modules -for a first binary version  of the software program  for the master virtual machine - using a first set of virtual memory addresses from a private memory segment allocated to the master virtual machine -, such as the first private memory page -.","In general, relocation is the process of assigning load addresses to various parts of a program and adjusting the code and data in the program to reflect the assigned addresses. The master prelink component - performs relocation in conjunction with symbol resolution, which is the process of searching program modules -to replace symbolic references or names of the program modules -with actual usable addresses in the memory unit  before running the software program . Relocation operations are typically done in two stages. In a first stage, each object file has various sections like code, data, bss segments, and so forth. To combine all the objects into a single executable, the master prelink component - merges all sections of similar type into a single section of that type. The master prelink component - then assigns run time addresses to each section and each symbol. At this point, the code (functions) and data (global variables) will have unique run time addresses. In a second stage, each section refers to one or more symbols which should be modified so that they point to the correct run time addresses based on information stored in a relocation table in the object file. The relocation table is a list of pointers created by a compiler or assembler and stored in the object or executable file. Each entry in the relocation table, sometimes referred to as a \u201cfixup,\u201d is a pointer to an address in the object code that must be changed when the master prelink component - relocates the program. Fixups are designed to support relocation of the program as a complete unit. In some cases, each fixup in the relocation table is itself relative to a base address of zero, so the fixups themselves must be changed as the master prelink component - moves through the relocation table.","Once the master prelink component - relocates the program modules -for the binary version  of the software program , the master prelink component - may store relocation information  for the program modules -in a global prelink layout map  for use by other virtual machines of the electronic device , such as the guest virtual machines -, -, for example.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 3","b":["300","100","300","202","1","146","206","1","206","1","206"],"i":"f. "},"Relocating a program module - involves iterating through each address in the program module - and replacing it with a real address as determined by a location of the program module - in a virtual address space of a private memory segment of the memory unit  allocated to the master virtual machine -. As shown in , the master prelink component - relocates the program module - from the first set of program modules -by changing each module address -referenced in the program module - to a virtual memory address -from the first set of virtual memory addresses of the first private memory page. For example, a module address - may be changed to a virtual memory address -, a module address - may be changed to a virtual memory address -, and so forth. Once relocation operations are completed for the program module -, the master prelink component - may store relocation information  in the global prelink layout map . The relocation information  may comprise a mapping between each module address -for the program module - from the first set of program modules -and each virtual memory address -from the first set of virtual memory addresses -of the first private memory page -. The master prelink component - may then begin relocation operations for a next program module -. This process continues until the master prelink component - relocates all program modules in the set of program modules -, and stores corresponding relocation information  in the global prelink layout map . The binary version  of the software program  is now prelinked with the associated program modules -, and is ready for the loader application  to load into the memory unit  when a user initiates execution of the binary version .",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4","b":["400","100","400","146","130","400","160","2","202","2","146"]},"As previously described with reference to , the dynamic linker application  is operative on the processor circuit  to link a binary version  of the software program  with associated program modules -at run-time of the binary version  on the processor circuit . Similarly, the dynamic linker application  is operative on the processor circuit  to link a binary version  of the software program  with associated program modules -at run-time of the binary version  on the processor circuit . The binary versions ,  are identical in that they are copies of the same software program , and not necessarily the same binary file.","As with the program modules -, the program modules -may comprise various program modules from one or more of the software libraries -, shown as software library - in . The dynamic linker application  may link the program modules -to the binary version  of the software program  during run-time of the binary version  on the processor circuit .","As shown in , the dynamic linker application  may comprise a client prelink component - operative on the processor circuit  to receive the global prelink layout map  generated by the master prelink component -, and retrieve the relocation information  from the global prelink layout map . The relocation information  may comprise a mapping between each module address -for the program module - from the first set of program modules -and each virtual memory address -from the first set of virtual memory addresses -of the first private memory page -. The client prelink component - may use the relocation information  as a template to relocate a second set of program modules -for a second binary version  of the software program  for the guest virtual machine - using a second set of virtual memory addresses from a second private memory page - allocated to the guest virtual machine -. The binary versions ,  and associated program modules -, -, respectively, are now prelinked with the same set of virtual memory addresses in the different private memory segments allocated to the virtual machines -, -, respectively.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 5","b":["500","100","500","202","2","146","406","1","406","1","406"],"i":"j. "},"As shown in , the client prelink component - relocates the program module - from the second set of program modules -by changing each module address -referenced in the program module - to a virtual memory address -from the second set of virtual memory addresses -of the second private memory page -. For example, a module memory address - may be changed to a virtual memory address -, a module memory address - may be changed to a virtual memory address -, and so forth. Once relocation operations are completed for the program module -, the client prelink component - may then begin relocation operations for a next program module -. This process continues until the client prelink component - relocates all program modules in the set of program modules -. The binary version  of the software program  is now prelinked with the associated program modules -, and is ready for the loader application  to load into the memory unit  when a user initiates execution of the binary version .","Since the client prelink component - used the relocation information  from the global prelink layout map  for its relocation operations, one or more relocated virtual memory addresses -of the first set of virtual memory addresses -of the first private memory page - now matches one or more relocated virtual memory addresses -of the second set of virtual memory addresses -of the second private memory page -. As such, the dynamic linker application  may pass the known virtual memory addresses -, -to the memory management application .","The memory management application  may use the known virtual memory addresses -, -as a starting point to look for candidates suitable for memory de-duplication operations. The memory management application  may retrieve the private memory pages -, - from the memory unit  using one of the known virtual memory addresses -, -, such as base virtual memory addresses -, -, for example. The memory management application  may compare the private memory pages -, - to determine whether there is a match of identical content. If there is a match, the memory management application  may merge the private memory pages -, - into a single shared memory page -. The shared memory page - may now be accessible by the virtual machines -, - that generated the private memory pages -, -. If one of the virtual machines -, - modifies the shared memory page -, the memory management application  may convert the shared memory page - back into the private memory pages -, - since they now have non-duplicative content. This process may continue for a shared memory page -, a shared memory page -, and so on, until all duplicate private memory pages -are merged into a shared memory page -",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 6","b":["600","100","600","602","202","1","160","1","202","2","202","3","202","4","160","2","160","3","160","4"]},"As shown in , the master prelink component may receive prelink information  prior to relocating the first set of program modules -, and use the prelink information  to relocate the first set of program modules -. The prelink information  may be used as input to a prelink mapping algorithm designed to generate an address layout for prelinking operations. In general, the prelink information  may comprise any information that may be used to optimize relocation operations performed by the master prelink component -, specific examples of which are given below.","In one embodiment, the prelink information  may originate from a single virtual machine, such as the master virtual machine -. The master prelink component - executing within the master virtual machine - may generate prelink information  for information known to the master virtual machine - alone. The master prelink component - may use the prelink information  to calculate an optimal layout of virtual memory addresses -for prelinking operations performed on the master virtual machine -.","By way of example, the prelink information  may comprise a graph of program modules -from the first set of program modules -that will be loaded at a same time on the master virtual machine -. The master prelink component - may then assign different sub-sets of virtual memory addresses -from the first set of virtual memory addresses -to the program modules -in the graph to avoid loading multiple program modules -using a same set of addresses. For instance, the master prelink component - may scan private memory pages -stored in a private memory segment allocated to the master virtual machine - for every executable to be prelinked, generate a graph of software libraries -that will be loaded at the same time, and then calculate or \u201clayout\u201d sets of virtual memory addresses -for each software library -such that two software libraries -(e.g., -, -) will never be loaded at the same or overlapping virtual memory address -. These offsets are then stored in the shared object files themselves, and symbol tables and segment addresses are all adjusted to reflect addresses based on a chosen base address.","Additionally or alternatively, the prelink information  may originate from multiple virtual machines, such as the master virtual machine - and one or more guest virtual machines -, - and\/or -. Each of the client prelink components -, - and - executing within the guest virtual machines -, - and -, respectively, may generate and send corresponding sets of prelink information  to the master prelink component -. The master prelink component - may receive prelink information  from the guest virtual machines -, - and -, and use the different sets of prelink information  to calculate an optimal layout of virtual memory addresses for prelinking operations.","By way of example, assume the prelink information  comprises a first graph of program modules -from the first set of program modules -that will be loaded at a same time on the master virtual machine -, and a second graph of program modules -from a second set of program modules -that will be loaded at a same time on the guest virtual machine -. The master prelink component - may then assign different sub-sets of virtual memory addresses -from the first set of virtual memory addresses -to the first set of program modules -in the first graph, and different sub-sets of virtual memory addresses -from the second set of virtual memory addresses -to the second set of program modules -in the second graph. Taking into account the prelink information  from the guest virtual machine - allows the master prelink component - to layout virtual memory addresses for the master virtual machine - in a template manner that does not negatively impact the guest virtual machine -, such as using virtual memory addresses not available or already in use by the guest virtual machine -, for example.","Referring again to , the electronic device  may be coupled to various computing and\/or communications platforms that include platform components typically found in such platforms. For example, the electronic device  may include a computing platform having various platform components, such as input\/output (I\/O) devices, I\/O controllers, GPUs, power supplies, thermal management components, and so forth. In one embodiment, the electronic device  may comprise a computing device such as a mobile computing device (e.g., a notebook, tablet computer, smart phone, etc.) or a fixed computing device (e.g., a personal computer, a desktop computer, a server, etc.) having a display operative to present information stored in the memory unit . The display may comprise any digital display device suitable for the electronic device . For instance, the display may be implemented by a liquid crystal display (LCD) such as a touch-sensitive, color, thin-film transistor (TFT) LCD, a plasma display, organic light emitting diode (OLED) displays, a cathode ray tube (CRT) display, or other type of suitable visual interface for displaying content to a user of the electronic device . The display may further include some form of a backlight or brightness emitter as desired for a given implementation.","Included herein is a set of flow charts representative of exemplary methodologies for performing novel aspects of the disclosed architecture. While, for purposes of simplicity of explanation, the one or more methodologies shown herein, for example, in the form of a flow chart or flow diagram, are shown and described as a series of acts, it is to be understood and appreciated that the methodologies are not limited by the order of acts, as some acts may, in accordance therewith, occur in a different order and\/or concurrently with other acts from that shown and described herein. For example, those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events, such as in a state diagram. Moreover, not all acts illustrated in a methodology may be required for a novel implementation.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 7","b":["700","700","100","700","202","1","202","2","146"]},"In the illustrated embodiment shown in , the logic flow  may relocate a first set of program modules for a first binary version of a software program for a first virtual machine using a first set of virtual memory addresses from a first private memory page allocated to the first virtual machine at block . For example, the master prelink component - of the dynamic linker application  executing in the master virtual machine - may relocate a first set of program modules -, - for a first binary version  of a software program  for the master virtual machine - using a first set of virtual memory addresses -from a first private memory page - allocated to the master virtual machine -.","The logic flow  may store relocation information for the first set of program modules in a global prelink layout map at block . For example, the master prelink component - may store relocation information  for the first set of program modules -, - in a global prelink layout map  in a shared memory page - of the memory unit  accessible by the master virtual machine - and a guest virtual machine -. The global prelink layout map  may be stored in shared memory segment accessible by all of the virtual machines -, -, - and -, such as a shared memory page -. Alternatively, the global prelink layout map  may be communicated as messages passed between the virtual machines -, -, - and -.","The logic flow  may retrieve the global prelink layout map at block . For example, the client prelink component - of the dynamic linker application  executing on the guest virtual machine - may retrieve the global prelink layout map  and the relocation information  from the shared memory page -.","The logic flow  may relocate a second set of program modules for a second binary version of the software program for a second virtual machine using a second set of virtual memory addresses from a second private memory page allocated to the second virtual machine based on the global prelink layout map. For example, the client prelink component - may analyze the relocation information , and use the relocation information  as a template to relocate a second set of program modules -, - for a second binary version  of the software program  for the guest virtual machine - using a second set of virtual memory addresses -from a second private memory page - allocated to the guest virtual machine -.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 8","b":["800","800","100","800","202","1","202","2","146"]},"In the illustrated embodiment shown in , the logic flow  may relocate a program module from the first set of program modules by changing each module address referenced in the program module to a virtual memory address from the first set of virtual memory addresses of the first private memory page at block . For example, the master prelink component - may relocate a program module - from the first set of program modules -, - by changing each module address -referenced in the program module - to a virtual memory address -from the first set of virtual memory addresses -of a private memory segment allocated to the master virtual machine -, such as the first private memory page -, for example.","The logic flow  may relocate a program module from the second set of program modules by changing each module address referenced in the program module to a virtual memory address from the second set of virtual memory addresses of the second private memory page, wherein the first set of virtual memory addresses of the first private memory page matches the second set of virtual memory addresses of the second private memory page at block . For example, the client prelink component - may relocate a program module - from the second set of program modules -, - by changing each module address -referenced in the program module to a virtual memory address -from the second set of virtual memory addresses -of a private memory segment allocated to the guest virtual machine -, such as the second private memory page -, for example. The first set of virtual memory addresses -of the first private memory page - matches the second set of virtual memory addresses -of the second private memory page - since both address layouts use the same relocation information .",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 9","b":["900","900","100","900","202","1","202","2","146","602"]},"In the illustrated embodiment shown in , the logic flow  may receive prelink information at block . In one embodiment, for example, the master prelink component - may receive a single set of prelink information  from the master virtual machine -. Additionally or alternatively, the master prelink component - may receive different sets of prelink information  from various guest virtual machines, such as guest virtual machines -, - and\/or -.","The logic flow  may relocate the first set of program modules based on the prelink information at block . In one embodiment, for example, the master prelink component - may relocate the first set of program modules -based on the prelink information  from only the master virtual machine -. In one embodiment, for example, the master prelink component - may relocate the first set of program modules -based on the different sets of prelink information  from guest virtual machines -, - and\/or -. In this embodiment, the master prelink component - may integrate the different sets of prelink information  into a superset, and use the superset of information as input to the prelink mapping algorithm.","The logic flow  may assign different sub-sets of virtual memory addresses from the first set of virtual memory addresses to different program modules from the first set of program modules based on prelink information at block . For example, the master prelink component - may perform relocation operations by assigning different sub-sets of virtual memory addresses -from the first set of virtual memory addresses -to different program modules -from the first set of program modules -based on the prelink information .",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 10","b":["1000","1000","100","1000","140","130","160","1"]},"In the illustrated embodiment shown in , the logic flow  may retrieve the first private memory page allocated to the first virtual machine and the second private memory page allocated to the second virtual machine at block . For example, the memory management application  may retrieve the first private memory page - allocated to the master virtual machine - and the second private memory page - allocated to the guest virtual machine -. The memory management application  may be programmed to retrieve the first and second private memory pages -, - based on a known set of virtual memory address -, -passed to the memory management application  from the dynamic linker application  after performing prelinking operations for the binary versions ,  of the software program  with one or more software libraries -in the memory unit .","The logic flow  may compare the first and second private memory pages for duplicative content at block . For example, the memory management application  may compare the first and second private memory pages -, - for duplicative content.","The logic flow  may merge the first and second private memory pages to form a shared memory page when the first and second private memory pages have duplicative content at block . For example, the memory management application  may merge the first and second private memory pages -, - into a single shared memory page - when the first and second private memory pages -, - are determined to have duplicative content.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 11","b":["1100","100","1100","120"]},"As used in this application, the terms \u201capparatus\u201d and \u201ccomponent\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution, examples of which are provided by the exemplary computing architecture . For example, a component can be, but is not limited to being, a process running on a processor, a processor, a hard disk drive, multiple storage drives (of optical and\/or magnetic storage medium), an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and\/or thread of execution, and a component can be localized on one computer and\/or distributed between two or more computers. Further, components may be communicatively coupled to each other by various types of communications media to coordinate operations. The coordination may involve the uni-directional or bi-directional exchange of information. For instance, the components may communicate information in the form of signals communicated over the communications media. The information can be implemented as signals allocated to various signal lines. In such allocations, each message is a signal. Further embodiments, however, may alternatively employ data messages. Such data messages may be sent across various connections. Exemplary connections include parallel interfaces, serial interfaces, and bus interfaces.","The computing architecture  includes various common computing elements, such as one or more processors, multi-core processors, co-processors, memory units, chipsets, controllers, peripherals, interfaces, oscillators, timing devices, video cards, audio cards, multimedia input\/output (I\/O) components, power supplies, and so forth. The embodiments, however, are not limited to implementation by the computing architecture .","As shown in , the computing architecture  comprises multiple processing units , a system memory  and a system bus . The processing units  may comprise, for example, the processor circuits , , the CPU , and\/or the GPU .","The system bus  provides an interface for system components including, but not limited to, the system memory  to the processing unit . The system bus  can be any of several types of bus structure that may further interconnect to a memory bus (with or without a memory controller), a peripheral bus, and a local bus using any of a variety of commercially available bus architectures. Interface adapters may connect to the system bus  via a slot architecture. Example slot architectures may include without limitation Accelerated Graphics Port (AGP), Card Bus, (Extended) Industry Standard Architecture ((E)ISA), Micro Channel Architecture (MCA), NuBus, Peripheral Component Interconnect (Extended) (PCI(X)), PCI Express, Personal Computer Memory Card International Association (PCMCIA), and the like.","The computing architecture  may comprise or implement various articles of manufacture. An article of manufacture may comprise a computer-readable storage medium to store logic. Examples of a computer-readable storage medium may include any tangible media capable of storing electronic data, including volatile memory or non-volatile memory, removable or non-removable memory, erasable or non-erasable memory, writeable or re-writeable memory, and so forth. Examples of logic may include executable computer program instructions implemented using any suitable type of code, such as source code, compiled code, interpreted code, executable code, static code, dynamic code, object-oriented code, visual code, and the like.","The system memory  may include various types of computer-readable storage media in the form of one or more higher speed memory units, such as read-only memory (ROM), random-access memory (RAM), dynamic RAM (DRAM), Double-Data-Rate DRAM (DDRAM), synchronous DRAM (SDRAM), static RAM (SRAM), programmable ROM (PROM), erasable programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), flash memory, polymer memory such as ferroelectric polymer memory, ovonic memory, phase change or ferroelectric memory, silicon-oxide-nitride-oxide-silicon (SONOS) memory, magnetic or optical cards, an array of devices such as Redundant Array of Independent Disks (RAID) drives, solid state memory devices (e.g., USB memory, solid state drives (SSD) and any other type of storage media suitable for storing information. In the illustrated embodiment shown in , the system memory  can include non-volatile memory  and\/or volatile memory . A basic input\/output system (BIOS) can be stored in the non-volatile memory .","The computer  may include various types of computer-readable storage media in the form of one or more lower speed memory units, including an internal (or external) hard disk drive (HDD) , a magnetic floppy disk drive (FDD)  to read from or write to a removable magnetic disk , and an optical disk drive  to read from or write to a removable optical disk  (e.g., a CD-ROM or DVD). The HDD , FDD  and optical disk drive  can be connected to the system bus  by a HDD interface , an FDD interface  and an optical drive interface , respectively. The HDD interface  for external drive implementations can include at least one or both of Universal Serial Bus (USB) and IEEE 13114 interface technologies.","The drives and associated computer-readable media provide volatile and\/or nonvolatile storage of data, data structures, computer-executable instructions, and so forth. For example, a number of program modules can be stored in the drives and memory units , , including an operating system , one or more application programs , other program modules , and program data . In one embodiment, the one or more application programs , other program modules , and program data  can include, for example, the various applications and\/or components of the memory management apparatus ,  and .","A user can enter commands and information into the computer  through one or more wire\/wireless input devices, for example, a keyboard  and a pointing device, such as a mouse . Other input devices may include microphones, infra-red (IR) remote controls, radio-frequency (RF) remote controls, game pads, stylus pens, card readers, dongles, finger print readers, gloves, graphics tablets, joysticks, keyboards, retina readers, touch screens (e.g., capacitive, resistive, etc.), trackballs, trackpads, sensors, styluses, and the like. These and other input devices are often connected to the processing unit  through an input device interface  that is coupled to the system bus , but can be connected by other interfaces such as a parallel port, IEEE 13114 serial port, a game port, a USB port, an IR interface, and so forth.","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adaptor . The monitor  may be internal or external to the computer . In addition to the monitor , a computer typically includes other peripheral output devices, such as speakers, printers, and so forth.","The computer  may operate in a networked environment using logical connections via wire and\/or wireless communications to one or more remote computers, such as a remote computer . The remote computer  can be a workstation, a server computer, a router, a personal computer, portable computer, microprocessor-based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory\/storage device  is illustrated. The logical connections depicted include wire\/wireless connectivity to a local area network (LAN)  and\/or larger networks, for example, a wide area network (WAN) . Such LAN and WAN networking environments are commonplace in offices and companies, and facilitate enterprise-wide computer networks, such as intranets, all of which may connect to a global communications network, for example, the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a wire and\/or wireless communication network interface or adaptor . The adaptor  can facilitate wire and\/or wireless communications to the LAN , which may also include a wireless access point disposed thereon for communicating with the wireless functionality of the adaptor .","When used in a WAN networking environment, the computer  can include a modem , or is connected to a communications server on the WAN , or has other means for establishing communications over the WAN , such as by way of the Internet. The modem , which can be internal or external and a wire and\/or wireless device, connects to the system bus  via the input device interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, can be stored in the remote memory\/storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.","The computer  is operable to communicate with wire and wireless devices or entities using the IEEE 802 family of standards, such as wireless devices operatively disposed in wireless communication (e.g., IEEE 802.11 over-the-air modulation techniques). This includes at least Wi-Fi (or Wireless Fidelity), WiMax, and Bluetooth\u2122 wireless technologies, among others. Thus, the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices. Wi-Fi networks use radio technologies called IEEE 802.11x (a, b, g, n, etc.) to provide secure, reliable, fast wireless connectivity. A Wi-Fi network can be used to connect computers to each other, to the Internet, and to wire networks (which use IEEE 802.3-related media and functions).","Elements of the various embodiments may be implemented as various hardware elements, software elements, or a combination of both. Examples of hardware elements may include devices, logic devices, components, processors, microprocessors, circuits, processor circuits, circuit elements (e.g., transistors, resistors, capacitors, inductors, and so forth), integrated circuits, application specific integrated circuits (ASIC), programmable logic devices (PLD), digital signal processors (DSP), field programmable gate array (FPGA), memory units, logic gates, registers, semiconductor device, chips, microchips, chip sets, and so forth. Examples of software elements may include software components, programs, applications, computer programs, application programs, system programs, software development programs, machine programs, operating system software, middleware, firmware, software modules, routines, subroutines, functions, methods, procedures, software interfaces, application program interfaces (API), instruction sets, computing code, computer code, code segments, computer code segments, words, values, symbols, or any combination thereof. Determining whether an embodiment is implemented using hardware elements and\/or software elements may vary in accordance with any number of factors, such as desired computational rate, power levels, heat tolerances, processing cycle budget, input data rates, output data rates, memory resources, data bus speeds and other design or performance constraints, as desired for a given implementation.","Some embodiments may be described using the expression \u201cone embodiment\u201d or \u201can embodiment\u201d along with their derivatives. These terms mean that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment. Further, some embodiments may be described using the expression \u201ccoupled\u201d and \u201cconnected\u201d along with their derivatives. These terms are not necessarily intended as synonyms for each other. For example, some embodiments may be described using the terms \u201cconnected\u201d and\/or \u201ccoupled\u201d to indicate that two or more elements are in direct physical or electrical contact with each other. The term \u201ccoupled,\u201d however, may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other.","It is emphasized that the Abstract of the Disclosure is provided to allow a reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition, in the foregoing Detailed Description, it can be seen that various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description, with each claim standing on its own as a separate embodiment. In the appended claims, the terms \u201cincluding\u201d and \u201cin which\u201d are used as the plain-English equivalents of the respective terms \u201ccomprising\u201d and \u201cwherein,\u201d respectively. Moreover, the terms \u201cfirst,\u201d \u201csecond,\u201d \u201cthird,\u201d and so forth, are used merely as labels, and are not intended to impose numerical requirements on their objects.","What has been described above includes examples of the disclosed architecture. It is, of course, not possible to describe every conceivable combination of components and\/or methodologies, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the novel architecture is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
