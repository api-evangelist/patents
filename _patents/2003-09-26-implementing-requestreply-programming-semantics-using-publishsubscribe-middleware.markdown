---
title: Implementing request/reply programming semantics using publish/subscribe middleware
abstract: A request/reply middleware wrapper that transposes an application's request/reply communications into publish/subscribe communications implemented by publish/subscribe middleware where every distributed application component of a distributed application is referenced by a component type and name. Each component type has associated with it a request publish/subscribe topic and a reply publish/subscribe topic. Each distributed application component subscribes to its request and reply topics and can publish to request and reply topics of other component types. By utilizing callback objects, the middleware wrapper facilitates the transmission of a request and replies between distributed application components by posting the requests or replies on an appropriate request or reply publish/subscribe topic.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07945896&OS=07945896&RS=07945896
owner: Inceptia LLC
number: 07945896
owner_city: Brooklyn
owner_country: US
publication_date: 20030926
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["This application claims the benefit of priority under 35 U.S.C. \u00a7119(e) from U.S. Provisional Application No. 60\/414,369, entitled \u201cImplementing Request\/Reply Programming Semantics Using Publish\/Subscribe Middleware,\u201d filed Sep. 30, 2002, which disclosure is incorporated herein by reference.","1. Field of Invention","The present invention relates to distributed computing, and particularly to software tools for architecting and implementing distributed computing systems.","2. Description of Related Art","Software that sits between two or more types of software and translates information between them is generally referred to as \u201cmiddleware.\u201d Middleware covers a vast range of software and is typically situated between an application and an operating system, a network operating system, or a database management system. Examples of middleware include object-oriented programming code based on a Common Object Request Broker Architecture (CORBA\u2122); software implemented according to a Distributed Computing Environment (DCE) industry-standard; JAVA\u2122 Remote Method Invocation (JAVA\u2122 RMI) programming code; and an application programming interface (API) based on ENTERPRISE JAVABEANS\u2122 (EJB\u2122). COBRA is a registered trademark of Object Management Group, Inc. JAVA\u2122, ENTERPRISE JAVABEANS\u2122 and EJB\u2122, are registered trademarks of Sun Microsystems, Inc.","Middleware can serve as a tool that is employed to build distributed computing systems. For example, distributed computing middleware facilitates application components, i.e., programs, on different computers to talk to one another. One widely used technique for allowing one program to call a second program on a remote system is to implement remote procedure call (RPC) middleware. RPC middleware facilitates instructing a second program to perform a task requested by the first program and returning any results of that task to the first program.","One common method of developing distributed systems is to employ operating system APIs, or sockets API, for facilitating communications among distributed application components. Sockets API is an application programming interface, i.e., set of routines, to create and use sockets implemented by the operating system for client\/server networking. A socket is an identifier for a particular service at a particular node on a network. Winsock, short for WINDOWS\u2122 Sockets, is an API that provides a Transmission Control Protocol\/Internet Protocol (TCP\/IP) interface under MICROSOFT WINDOWS\u2122, WINDOWS\u2122 and MICROSOFT WINDOWS\u2122 are registered trademarks of Microsoft Corporation.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1","b":["100","110","120","112","110","122","120","112","122","110","120","114","124","130","112","122","116","126"]},"If application component  at computing device  wants to talk to application component  at computing device  via network connection , it first calls its operating system  through its sockets API . Operating system  then communicates via a communication protocol, typically TCP\/IP, with operating system , which in turn calls application software  through its sockets API . If application component  wants to talk to application component , the reverse path\/process is employed.","Sockets API is used for a variety of applications ranging from, for example, email systems to real time on-line gaming. In order to support such varied applications, sockets API must include many options and parameters, and allow for many different communication semantics. For instance, sockets API must support both connection oriented TCP semantics and connectionless User Datagram Protocol (UDP) semantics. All these options and parameters make the API complex. Considerable training and expertise is required in order for a programmer to use sockets API to implement systems that use the architecture of .","Distributed computing middleware manages inter-machine communication for the components of a distributed application and presents its own API. In essence, each application component of the distributed application talks to the middleware via a middleware API and the middleware then talks to the operating system often via sockets API. Middleware translates the information it carries from its own programming semantics to the programming semantics used by sockets API. Typically, the distributed computing middleware semantics are easier to use than those of sockets API. By using a simpler, more focused API, distributed computing projects can be completed quicker with higher quality by a smaller and less highly skilled team.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2","b":["200","110","120","112","122","212","214","110","120","212","222","214","224","112","122","112","110","122","120","130","212","214","212","114","116","114","124","222","126","222","122","224","122","112"]},"JAVA\u2122 Message Service (JMS) is a standard API implemented by several distributed computing middleware vendors. JMS employs a publish\/subscribe API for coordinating the efficient delivery of information. Publish\/subscribe features topics, publishers, and subscribers. Conceptually, topics are pipes that carry messages. Publishers and subscribers are sets of instructions that put information into the pipe, i.e., topic, and take it out. Topics exist independently of publishers and subscribers, however all three are needed to make the communications information flow. In a distributed computing system, an application component can publish to a topic and\/or subscribe to a topic.","A message published to a topic is delivered asynchronously to all the subscribers of the topic. JMS has its own message format featuring a header and a payload. The header comprises a set of name\/value pairs, or header properties, some of which are defined by the publish\/subscribe API and some defined by the application. Two header properties of particular importance are \u201cmessage ID\u201d and \u201ccorrelation ID.\u201d The message ID is a unique identification that is assigned by the middleware to every message it processes. When one message is related in some way to another, the application can set the correlation ID header property to equal the message ID of the related message. The payload is never examined by the middleware.","When a JMS publish\/subscribe client subscribes to receive messages from a topic it specifies a message filter. The filter is a conditional expression that analyzes message header values. When a message is published on a topic it is delivered to every subscriber of the topic who's filter is satisfied by the messages header properties. For example, a chatroom application component might use a filter like this:\n\n","This filter would have the effect of allowing receipt of private messages directed to \u2018phil\u2019 or messages directed to the entire chatroom except when these messages were sent by the ignored users \u2018darrell\u2019 or \u2018jeff\u2019.","Request\/reply programming is a cross between publish\/subscribe and the very popular RPC model. With RPC as previously mentioned, a sender invokes a procedure on a remote application component and the remote component \u201creturns\u201d a response. Request\/reply has several advantages over RPC. For example, request\/reply supports the sending of messages to multiple receivers. Moreover, request\/reply is asynchronous and is therefore better suited to situations where replies may take a long time to arrive or where the network, sender, or receiver may fail. Like publish\/subscribe, but unlike RPC, request\/reply communications can be conveniently attempted in situations where the existence, location, or number of receivers is not known by the sender. No conventional middleware directly supports simple request\/reply semantics. Developers who wish to employ a request\/reply design pattern must either do all their own communications programming utilizing sockets API as in  or use unsuitable middleware APIs. Such an implementation is complex and time consuming to design even for a highly skilled developer.","The present invention overcomes these and other deficiencies of the related art by providing a request\/reply middleware wrapper that transposes an application's request\/reply communications into publish\/subscribe communications implemented by publish\/subscribe middleware.","The request\/reply programming semantics presented herein are simpler than publish\/subscribe programming semantics. By using a middleware wrapper that implements request\/reply programming semantics, an application component can send a message to all components of a particular type by specifying a target type or it can send a message to a single component by specifying a target component type and name. When a message is sent, the sender can indicate to the request\/reply middleware wrapper that it expects to receive replies. In order to receive replies, the sender supplies a callback object, which the middleware wrapper can call to process the reply. Any replies received after a timeout value has expired are not passed to the listener object, and hence to the sender.","In an embodiment of the invention, a method for facilitating communications between components of a distributed application comprises the steps of: receiving a request from a first distributed application component directed to a second distributed application component; and publishing the request on a publish\/subscribe request topic identified by a component type of the second distributed application component. If a reply is expected in response to the request, a subscription is created on a publish\/subscribe reply topic identified by the component type of the first application component. In order to receive requests from other distributed application components, a subscription is created on a publish\/subscribe request topic identified by the component type of the first application component. If a reply to the received request is necessitated, the reply is published on a second publish\/subscribe reply topic identified by the component type of requesting distributed application component.","In another embodiment of the invention, a system for facilitating request\/reply communications among components of a distributed application comprises: a publish\/subscribe request topic for every type of distributed application component; a publish\/subscribe reply topic for every type of distributed application component; and for every distributed application component, a publisher on each publish\/subscribe request topic within a portion of the publish\/subscribe request topics; a publisher on each publish\/subscribe request topic within a portion of the publish\/subscribe reply topics; a subscription on the publish\/subscribe request topic pertaining to the component type of the distributed application component; and a subscription on the publish\/subscribe reply topic pertaining to the component type of the distributed application component. The portion of the publish\/subscribe request topics includes all publish\/subscribe request topics associated with the types of distributed application components that receive requests from the distributed application component. Similarly, the portion of the publish\/subscribe reply topics includes all publish\/subscribe reply topics associated with the types of distributed application components that receive replies from the distributed application component. Callback objects are provided to facilitate delivery of requests and replies between the distributed application components and the publishers or subscriptions. Moreover, routing logic is employed to route a request or reply to a particular callback object.","An advantage of the invention is its relative ease of implementation. Particularly, ease of implementation arises from the fact that a request\/reply middleware wrapper is built around, i.e., utilizes or employs, aspects of existing publish\/subscribe middleware. Accordingly, a relatively simple distributed programming semantic is provided, which lets existing middleware perform the actual work of managing the communications across the network so that distributed computing projects are completed quickly with higher quality by a smaller and less highly skilled team.","Another advantage of the invention is the simplicity and utility of the request\/reply semantics. Other middleware, in order to justify it's cost of implementation, must provide a very rich API that can be used in many different applications. Request\/reply is less general, but much easier to use than other APIs. Because it is implemented using publish\/subscribe middleware, the cost of implementation, and therefore the number of users needed to justify the cost, is reduced.","The foregoing, and other features and advantages of the invention, will be apparent from the following, more particular description of the preferred embodiments of the invention, the accompanying drawings, and the claims.","Preferred embodiments of the present invention and their advantages may be understood by referring to , wherein like reference numerals refer to like elements, and are described in the context of a request\/reply middleware wrapper that transposes request\/reply communications into publish\/subscribe middleware semantics. The inventive concept provides a middleware wrapper software layer that allows application components implementing request\/reply semantics to communicate with each other through aspects of publish\/subscribe middleware.",{"@attributes":{"id":"p-0033","num":"0033"},"figref":"FIG. 3","b":["300","312","322","110","120","312","322","212","222","312","322","314","324","112","122","312","322","314","324"]},"In order to facilitate a way of describing a distributed computing system as a set of components where instances of various components run on different computers in the system, every application component is referenced according to a two-tuple naming scheme. In an embodiment of the invention, the two-tuple naming scheme references each application component by its component type and component name. The component type is a categorical identifier based on, for example, the kind or sort of component. In an exemplary information distribution embodiment, the component type can be identified as a console, database, network monitor, event correlator, etc. In another exemplary embodiment presented in the context of a bank, the component type can be identified as a teller terminal, automated teller machine (ATM), check clearing machine, etc. The component name is preferably an IP address or some other unique identifier of the computing device that the application component resides on.","If application component  running on computing device  wants to send a request to application component , which is a database for example, running on computing device  having the IP address 192.168.22.187, component  generates and sends a request with component type identified as \u201cDATABASE\u201d and component name identified as \u201c192.168.22.187\u201d to the middleware wrapper , and then waits for a reply. There are two exemplary ways that component  knows a database resides at 192.168.22.187. For instance, component  can send a \u201csend me your component name\u201d request to all components of type DATABASE in which an appropriate informative response is obtained, or component  can obtain the pertinent information from a lightweight directory access protocol (LDAP) registry. Nevertheless, the middleware wrapper  views the component types and component names as mere strings, i.e., middleware wrapper  performs simple string matching when analyzing the component types and names. This two-tuple naming scheme is particularly useful because it facilitates broadcasting to a group of components based on type, e.g., all databases, or sending to a single application component. Because the convention of using IP addresses as component names breaks down if two or more instances of one component type reside on a single computing device, a modified 1P address can be used as the component name. For example, two databases located on computing device are designated by the names \u201c192.168.22.187.PRIMARY\u201d and \u201c192.168.22.187.SECONDARY\u201d. The general point is that the distributed application must insure that, each component has a name that is unique among all instances of that component type. In an alternative embodiment, each application component is identified by two parameters other than component type and name.","Two publish\/subscribe topics are associated with each type of application component. One topic is for requests directed to that component type and another topic is for replies directed to that component type. In an embodiment of the invention, the title of each topic comprises the component type and the type of messages, e.g., request or reply, it will handle. For example, for the component type \u201cdatabase,\u201d the request topic is referred to as \u201cdatabase.request\u201d and the reply topic is referred to as \u201cdatabase.reply.\u201d In an alternative embodiment, the request topic is referenced by the component type only. As such, the request topic is referred to as \u201cdatabase\u201d and the reply topic is referred to as \u201cdatabase.reply.\u201d The important point is that two topics are associated with each component type and each of the two topics is delineated by the type of message, e.g., request or reply, that the topic handles. The semantics for creating topics may vary depending on the particulars of the publish\/subscribe middleware being used. For example, topics can be created by middleware wrappers  or  when they initialize or when components  or  register upon start-up. In an alternative embodiment of the invention, the publish\/subscribe topics are configured by a system administrator before the middleware wrappers are initialized.","In order to send and receive requests and replies, each application component must first register with its respective middleware wrapper.  illustrates an application component registration process  implemented by the middleware wrapper  or  for creating publishers, subscriptions, and topics according to an embodiment of the invention. When an application component first initializes, i.e., announces its presence to the network on start-up, its middleware wrapper receives (step ) from the application component the following information: component type, component name, all the component types it will be receiving requests or replies from, and all the component types it will be sending requests or replies to. For an application component to receive requests, the middleware wrapper creates (step ) a publish\/subscribe subscription on that application component's type request topic with an optional filter that only accepts incoming requests addressed to that application component or addressed to \u201call\u201d. For the application component to send replies in response to received requests, the middleware wrapper further creates (step ) a publish\/subscribe publisher on the reply topic of each application component type that this application component will receive requests from. For an application component to send requests, the middleware wrapper creates (step ) a publish\/subscribe publisher on the request topic of each application component type that this application component will send requests to. For an application component to receive replies, the middleware wrapper creates (step ) a publish\/subscribe subscription on that application component's type reply topic with an optional filter that only accepts incoming requests addressed to that application component. Once registered, the component can send or receive requests and replies. Moreover, the registration process  is transparent to the application component.","When a message, i.e., request or reply, is sent, the message sender's component type and component name are added to the header of the message along with the message receiver's component name. The receiver's component type is indicated by the topic the message is published on. The header of the message therefore comprises sender component type, sender component name, and receiver component name and does not contain receiver component type because that can be inferred from the topic the message is flowing on. If a request is meant for all instances of a particular component type than the receiver name is set to \u201call\u201d.","In an embodiment of the invention, an application component implements two middleware wrapper registration APIs. For example, the application component sends a \u201cregister sender\u201d command to the middleware wrapper and passes a target (receiving) component type and a target component name. If the target component name is omitted, then the middleware wrapper understands that the application component wishes to broadcast to all component names of that component type. For each \u201cregister sender\u201d command received from the application component, the middleware wrapper supplies a callback object to the application component it can utilize to send to a specified target. Callback objects are utilized to facilitate the transferring of replies and requests between application components  or  and respective middleware wrappers  or . A callback object comprises a memory address or some other reference, depending on the nomenclature of the programming language implemented, to enable the band off of messages to and from application components  or . For each component type that requests are received from, the application component sends a \u201cregister receiver\u201d command to the middleware wrapper. In addition, the application component passes a callback object where it wants the middleware wrapper to pass incoming requests coming from the given component type. When this is all done, the middleware wrapper has a set of callback objects to route incoming requests to and a set of callback objects routing outgoing requests from. When each callback object is registered, the middleware wrapper notes the specific publisher or subscriber it is associated with. Preferably, a single registration call is placed from the application component to register and pass a data structure with all the outgoing targets, incoming senders, and a callback object for each incoming sender. The middleware wrapper then returns the data structure with a callback object for each outgoing target added.",{"@attributes":{"id":"p-0040","num":"0040"},"figref":["FIG. 5","FIG. 3"],"b":["500","300","500","112","122","112","122"]},"Middleware wrapper system  comprises four topics: patient monitor request topic , patient monitor replies topic , nurse PDA requests topic , and nurse PDA replies topic . One of ordinary skill in the art recognizes that system  can be expanded to comprise more than two application components. For example in most typical real-world applications, several hundred application components can be present. As such, the total number of topics necessary to implement the inventive concept is double the number of component types.","During registration, application component  instructs middleware wrapper  that it wants to send requests and replies to Nurse PDA component types (e.g. \u201cNurse Ratchet\u201d or \u201call\u201d) and to receive requests and replies from Nurse PDA component types, and supplies middleware wrapper  with a callback where it will receive requests from the Nurse PDAs. With that information, middleware wrapper  creates incoming request subscription  on patient monitor request topic , incoming reply subscription  on patient monitor reply topic , outgoing request publisher  on nurse PDA request topic , and outgoing reply publisher  on nurse PDA reply topic . Incoming request subscriber Sills created with a filter that only accepts messages where the target component name is \u201cRoom 706\u201d or \u201call\u201d. Incoming reply subscription  is constructed with a filter that only accepts replies intended for \u201cRoom 706\u201d.","Application component  further supplies a callback object  to middleware wrapper  to hand off incoming requests to the application component . Middleware wrapper  notes the association between callback object  and subscription . Middleware wrapper  provides application component  with a callback object  associated with publisher  that the application component  can invoke to send requests. Each time the callback object  is employed to send a request, the application component  supplies a callback object  associated subscription  in order for middleware wrapper  to hand off any reply to that request back to the application component . Similarly, each time middleware wrapper  passes a request to application component  through callback object , middleware wrapper supplies a callback object  associated publisher  to application component  in order to return a reply in response to the received request. In other words, handing off a request in either direction entails supplying a callback object that can be invoked to handle the reply.","Similarly during the registration of application component , application component  instructs middleware wrapper  that it wants to send and receive requests and replies to and from patient monitor component types (e.g. \u201cRoom 706\u201d or \u201call\u201d), and supplies middleware wrapper  with a callback object where it will receive requests from the patient monitors. With that information, middleware wrapper  creates incoming request subscription  on nurse PDA request topic , incoming reply subscription  on nurse PDA reply topic , outgoing request publisher  on patient monitor request topic , and outgoing reply publisher  on patient monitor reply topic . Incoming request subscriber  is created with a filter that only accepts messages where the target component name is \u201cNurse Ratchet\u201d or \u201call\u201d. Incoming reply subscription  is constructed with a filter that only accepts replies intended for \u201cNurse Ratchet\u201d. Callback objects , , , and  associated with application component  and respective publishers  and , and subscriptions  and  are provided in an analogous manner to that implemented for application component .","For an application component to send requests and receive replies, the middleware wrappers  and  provide routing logic to route each reply to the correct callback object. One implementation employs a routing table, i.e., hash table, that is hashed by request message IDs. Each entry contains the callback object associated with the request. When a reply is received, the middleware wrapper  or  uses the reply's correlation ID to fetch the correct callback object from the table. The reply is then passed to the callback object and hence to the appropriate application component.","In operation, application component (patient monitor_room 706)  may send a request to application component  (nurse PDA_nurse Ratchet). To do so, a request message is formed by the middleware wrapper  with a header comprising \u201cPatient Monitor\u201d as the sender component type, \u201cRoom 706\u201d as the sender component name, and a receiver component name designated as \u201cNurse Ratchet.\u201d Alternatively, if the request was directed to all nurse PDAs, e.g., if more than one nurse PDA existed within system , the receiver component name would be set to \u201call\u201d. As noted above, the choice of whether an outgoing request is sent to a particular component instance or \u201call\u201d is made by the sending component when it registers. The header does not comprise a receiver component type as that is given by the particular topic the message is routed through. The payload of the request comprises the instructions or data for application component to execute or interpret. Once the request is formed, application component  sends the request and a callback object  to middleware wrapper  via the callback object . Middleware wrapper  sends the request to request publisher , which publishes the request on nurse PDA request topic . Request subscription  identifies that the recipient of the new request published at topic  is \u201cNurse Ratchet\u201d corresponding to application component , and accordingly forwards the request to middleware wrapper . When a request is received by middleware wrapper  by way of subscription , the request is handed off to application component  through callback object . As part of the hand off, middleware wrapper  provides the callback object .","Application component  generates a reply message if necessary, i.e., if the request instructions necessitated a reply. This reply message features a header comprising \u201cNurse PDA\u201d as the sender component type, \u201cNurse Ratchet\u201d as the sender component name, and a receiver component name designated as \u201cRoom 706.\u201d Once application component  provides a reply through callback object , middleware wrapper  sets the correlation ID in the reply's header to the message ID of the original request and publishes the reply through publisher , which publishes the reply on patient monitor reply topic . Reply subscription  identifies that the recipient of the new reply published at topic  is \u201cRoom 706\u201d corresponding to application component . When a reply arrives through subscription , middleware wrapper  uses the correlation ID in the message header to determine which request is being replied to and hands off the reply to application component  using the callback object .","In an embodiment of the invention, an application component can supply a timeout value to the middleware wrapper to indicate a duration that component will receive replies in response to a sent request. Replies received after the timeout value has expired are not to be delivered. The middleware wrapper's reply routing table is culled periodically to remove entries for requests that have timed out.","The present invention provides a very simple way to develop distributed application components. A very simple API is provided and it is believed that inexperienced programmers can begin developing distributed systems using the request\/reply semantics describe herein much faster than with any other conventional middleware API.","Other embodiments and uses of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. Although the invention has been particularly shown and described with reference to several preferred embodiments thereof, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined in the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention, the objects and advantages thereof, reference is now made to the following descriptions taken in connection with the accompanying drawings in which:",{"@attributes":{"id":"p-0027","num":"0027"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0028"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0029"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0030"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0031"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
