---
title: System and method for reliable packet data transport in a computer network
abstract: A system and method for reliably transmitting a request from a client application () running on a client system () to a server application () running on a server system () and receiving a reply to the request, in which functions that provide parameters governing the reliable transport mechanism and message forming and parsing services are provided by the application processes to and called from application-layer protocol stacks ().
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08713189&OS=08713189&RS=08713189
owner: Wi-Lan, Inc.
number: 08713189
owner_city: Ottawa
owner_country: CA
publication_date: 20030715
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This application is a National Stage of Application No. PCT\/CA2003\/001000, filed Jul. 15, 2003, which claims priority to CA 2,393,502, filed Jul. 15, 2002, the entire contents of which is incorporated by reference herein.","The present invention relates to systems and methods for providing for reliable transport of messages over computer networks. More specifically, the present invention relates to a system and method for providing reliable transport of messages over a computer network that includes an unreliable data link such as a wireless link in a wireless network.","To understand the context of the present invention it may be helpful to the reader to have a concrete, but very simple exemplary computer network, such as that shown in  and indicated generally by reference numeral , to which the reader can refer. The computer network  is shown as including two host computers that are referred to here as client host computer  and server host computer . Those skilled in the art will understand that the designation of a host computer as a client or as a server in this context depends upon which host computer sent a request to begin an exchange of messages between the host computers , . For the purposes of this discussion it is assumed that the client host computer  is running a client-side network application that needs to have some processing done by a server-side network application running on the server host computer . Generally, the client host computer  will include a central processing unit (\u201cCPU\u201d)  and memory . The CPU  runs the operating system  of the client host computer . In addition, the CPU  may run client-side network applications. The client host computer  interfaces with a communications network  through a communications interface . The communications network  may be a wired network or a wireless network or a partially wireless network and transports data between the host computers , . The communications interface  may be a modem or other means for interfacing between a computer and communications network .","Likewise, the server host computer  includes a CPU , memory  and an operating system . CPU  runs the operating system  of the server host computer  as well as server-side network applications. In addition, the server host computer  interfaces with the communications network  through a communications interface .","The elements of a simple computer network described above are known to those of ordinary skill in the art and will not be described further herein.","A client-side network application must rely on the computer network's transport system to communicate requests (sometimes referred to as \u201cremote procedure calls\u201d or \u201cRPCs\u201d) to a server-side network application. Typically, a software interface, usually referred to as a \u201csocket\u201d, is provided by an operating system ,  for a network application to gain access to the transport system. On the client side, a socket is provided into which a client application can send requests to be transported to the server application. Similarly, on the server side, a socket is provided from which the server application can receive requests sent by the client application and into which the server application can send replies that need to be transported to the client application. Typically, if the computer network's transportation system is based upon the Internet Protocol (\u201cIP\u201d), network applications that need reliable transport use either the Transmission Control Protocol (\u201cTCP\u201d) or include their own procedures to provide reliable transport using the User Datagram Protocol (\u201cUDP\u201d). In the latter case, this means that each time a network application is written for or ported to a new network configuration, significant effort is generally required to provide optimal reliable transport.","For example, a client application may need to send requests to a server application through a transport system that includes a wireless link. The transport system may have a high degree of error correction built in and may include a dedicated channel for some requests that the client applications may wish to send to some server applications. In such a situation, the reliable transport mechanisms built into TCP are not optimal for requests transmitted to all server applications over the wireless link. Because lost requests are very likely to be due to data loss in the wireless link rather than collisions or buffer overflow due to congestion, for urgent requests (e.g., for signaling that a user has picked up a telephone handset in an voice over Internet application) that will pass through the wireless link it may be preferable to retransmit an apparently lost request with a relatively long (in computer terms), but constant, delay between retransmissions and with a small hard limit on the number of retransmissions before an error is reported. However, for requests that do not pass through the wireless link or are less urgent, but which must be delivered, it may be preferable to have an initially shorter delay between retransmissions, a retransmission delay that increases linearly, and a very large number of retransmissions before an error is reported. In other cases, a protocol that handles retransmission in the manner in which TCP handles retransmissions may be desirable. Moreover, conditions in the network may change with interference in the wireless link or loading of the wire-line portion of the network, even if the network is dedicated to the network application (i.e., is not a public network like the Internet) and the radio spectrum used for the wireless is dedicated to the network.","Implementing a network application that can reliably handle remote procedure calls has in the past been done by either living with the limitations of TCP or building reliable transport into the network application and using UDP. For example, application-layer protocols such as Media Gateway Control Protocol (\u201cMGCP\u201d) or Session Initiation Protocol (\u201cSIP\u201d) include specifications for reliable transport that can be implemented in network applications that use remote procedure calls for signaling so that the network application itself provides reliable data transport. However, doing this adds additional complexity to the network application and means that the network application must be modified or at least tuned whenever changes occur in the network such that remote procedure calls are transported over paths having new characteristics or whenever remote procedure calls are to be made that have different requirements for timing and reliability. It would be preferable if characteristics of reliable transport mechanism provided for a specific client application that must make remote procedure calls to a specific server application could be changed without modifying the application.","For example, in Voice-Over-Internet-Protocol (\u201cVOIP\u201d) applications, TCP and UDP are not optimal if a wireless link is involved. Such applications, if they are to provide carrier-grade voice communication, need to reliably establish a communication channel as soon as possible after a subscriber picks up a telephone handset. While such applications can tolerate some degree of media data loss in the digitized voice signal once a connection is established, signaling messages must be highly reliable if subscriber expectations raised by past experience with the Public Switched Telephone Network (\u201cPSTN\u201d) are to be satisfied. Network applications such as VOIP applications are typically implemented in accordance with application-layer protocols such as MGCP and SIP in which reliable transport aspects are intermingled with the application-specific aspects of the protocol. Such applications directly use the services of a transport layer that implements the UDP or possibly the TCP over an IP network.","There is a need for a method and system that provides an application layer that can be adapted or adapt itself to network applications and transport conditions without revising the underlying code in either the network application or the transport layer.","The inventor, in considering how the task that a network applications programmer faces in writing or porting applications to a new network operating system could be simplified without sacrificing flexibility, concluded it would be preferable to separate as much as possible of the reliable transport mechanism from the network application while retaining UDP as an underlying transport layer. One way to accomplish simplification for the programmer is that typified by TCP; in TCP the reliable transport mechanism is built into the transport layer with little that the application programmer can do to change its characteristics to suit network conditions.","Although a new transport layer protocol to replace TCP might be an answer, the inventor realized that to make the reliable transport mechanism flexible (in way that TCP is not), it would be preferable to provide the programmer with a plurality of reliable transport \u201cpersonalities\u201d. While such personalities could be built into a transport layer protocol supplanting TCP, the inventor considered that it would be preferable to split the reliable transport mechanism into (1) a new application-layer protocol stack that would provide sockets to the application and use the services provided by UDP and (2) a set of personality functions that would be compiled and linked with the application, but called by the new protocol stack to perform reliable transport-related tasks. Each set of functions would constitute one discrete personality of the reliable transport mechanism.","An application programmer in writing a network application would make calls to the new protocol stack when opening a socket and sending and receiving data. The calls that the application would make would be the same regardless of the personality selected, so that the application programmer could change the desired personality by simply re-linking the application with a different set of personality functions. The application, when opening a socket, would simply provide the new protocol stack with a set of pointers to the functions for the desired personality. Alternatively, more than one set of compiled personality functions might be linked to the application and an application might then open sockets with sets of pointers to different sets of functions for communication with different server applications.","The new protocol stack, in providing reliable transport, calls the personality functions where necessary to determine parameters needed for providing reliable transport. The personality functions provide the reliable transport protocol with flexibility. For example, if no reply is received to a request, a personality function might be called and return the timeout interval that the new protocol stack should wait before retransmitting a message. The function could calculate a time based by various back-off strategies, it could return a predetermined timeout interval, or it could adaptively calculate a timeout interval based upon current conditions.","An application programmer would be provided with the new protocol stack, the specifications for making calls to the protocol stack, and a library of sets of personality functions. The application programmer could select one or more sets of personality functions to use or could, if necessary, write a custom set of personality functions for use with the network application.","As currently implemented, the personality functions are generally used by the new protocol stack to (1) parse messages received from the transport layer, (2) add headers or trailers to requests or replies to form messages for the protocol stack to send to the transport layer, and (3) provide retransmit and reply cache timer intervals for use by the new protocol stack. For example, the following are done by the personality functions in one embodiment of the invention:\n\n","Generally, personality functions could be used to determine any parameter of a reliable transport mechanism, handle creation and parsing of headers, and modify the data being transported. For transmissions sent between network applications that expect data to be encoded differently, personality functions could modify the payload or add additional data to the message.","Three examples of personalities are:\n\n",{"@attributes":{"id":"p-0026","num":"0033"},"figref":["FIG. 2","FIG. 1"],"b":["40","50","12","52","14","52","13","15","12","14","50","13","52","14"]},"Below the blocks in  representing the client application  and the server application  are two rectangular boxes each overlapping both boxes  and , but not each other, labeled with reference numerals  and . These boxes indicate two of the protocol layers into which the client-side processes  and server-side processes  may be conceptually divided. Each protocol layer may be considered to provide a service to the protocol layer (or application) above it such that data submitted by an upper protocol layer (or application) to a lower protocol layer in the client host computer , barring losses and data corruption, will be delivered by the same lower protocol layer in the server host computer  to the same upper protocol layer (or application) in the server host computer . Rectangular box  represents an application protocol layer and is shown above rectangular box , which represents a transport protocol layer. The protocol layers below the transport protocol layer  are shown in  as a third rectangular box . Those lower layers receive data in protocol units generally referred to as \u201csegments\u201d from the client-side transport protocol layer  and deliver those segments to the server-side transport protocol layer . Those readers skilled in the art will understand the nature and function of the protocol layers shown in .","In a preferred embodiment of the invention a new protocol referred to here as the \u201cART Protocol\u201d is implemented in the application layer . On the client side the ART protocol is represented by a client-side ART protocol stack  and on the server side the ART protocol is represented by a server-side ART protocol stack , both within the application layer . As is common is this art, software implementing a protocol is referred to as a \u201cstack\u201d and processes temporarily created by such software to handle communication with a particular remote host are referred to as \u201csockets\u201d. Typically stacks ,  would be identical; each would create sockets for handling transmission of requests or replies to requests when called by an application, such as client application  and server application , that wishes to send requests or replies to requests to an application elsewhere in the computer network .","The transport layer  and lower protocol layers  are conventional in the embodiment shown in . For the purposes of the following discussion, the transport layer  is assumed to provide unreliable transport of messages sent to it by the application layer . However, it is further assumed that the transport layer  (or the lower layers ; it does not matter to applications that are sending requests and replies over the computer network ) provides error correction such that a message delivered to the transport layer  by the application layer  on the client side  will either be delivered uncorrupted by the transport layer  to the application layer  on the server side  or not delivered at all. Further, it is assumed that between at least some client\/server pairs, messages may be lost due to the nature of the physical transmission method (e.g., wireless transmission), rather than due to collisions or buffer overflow due to congestion. Preferably, the transport layer  implements the User Datagram Protocol (\u201cUDP\u201d). In , the transport layer  is represented by a client-side protocol stack  and a server-side protocol stack , which are indicated by blocks in  in the area where block  overlaps block  and where block  overlaps block , respectively. While not preferred, Transmission Control Protocol (\u201cTCP\u201d) may be used instead of UDP as the transport layer protocol . The client-side and server-side protocol stacks for the lower protocol layers  are indicated by blocks  and  in .","Generally, as illustrated schematically in , the client-side ART protocol stack  handles a request  received from the client-side application  by wrapping the request  into a request message  by adding an ART header  to the request  and sending the resulting request message  to the client-side transport layer protocol stack . Similarly, the server-side ART protocol stack  receives the request message  from the server-side transport layer protocol stack , strips away the ART header  and delivers the request  to the server-side application .","As shown in , the ART header  comprises a type code  and a segment number . In one implementation, the type code  comprises (1) a two bit binary number providing a message type and (2) a sequence number  that is a 14-bit number that distinguishes the message from other recent messages sent to the server application . In that implementation, messages may also be sent that do not have a payload (e.g., a provisional reply) as well as messages that do have a payload, whose type is either \u201crequest\u201d or \u201creply\u201d.","The reliable transport provided by the ART protocol is illustrated generally by examples in  showing the exchange of messages in eleven cases. In each case time proceeds downward and messages between the client-side ART protocol stack  and the server-side ART protocol stack  are shown as downward slanting arrows indicating that each message takes a finite time to reach its destination. Each drawing also shows timer intervals: on the client side, for a retransmission timer interval ; and on the server side for a reply cache timer interval . In each diagram, the retransmission timer interval  is shown as running at most twice. If the client-side ART protocol stack  does not obtain a reply before the second expiry, an error message will be reported to the client application  and the socket will be closed. It should be noted that reporting an error after two expiries of the retransmission timer interval  would be unusual in practice, but is used here to eliminate unnecessary complexity in the drawings. The handling of error messages is outside the scope of the invention.",{"@attributes":{"id":"p-0033","num":"0040"},"figref":["FIG. 5","FIGS. 2","FIG. 5"],"b":["40","58","60","3","4","40","50","58"],"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":["(1) a request message  is formed having the request  as a payload and a header  that includes a type code  that indicates that the request message  contains the request  and a sequence number ;","(2) a retransmission timer interval  is started; and","(3) the request message  handed over to the transport layer protocol stack  for transmission to the server-side ART protocol stack ."]}},"The request message  then proceeds through the communications network  and is received from the server-side transport layer protocol stack  by the server-side ART protocol stack . An ART socket created by the server-side ART protocol stack  handles the request message  as follows:\n\n","When the reply message  is received by the client-side ART protocol stack , then:\n\n","When the acknowledgement message  is received by the server-side ART protocol stack , then the cached reply message  in the reply cache is deleted and a record of the sequence number  is stored. When the reply cache timer interval  expires, the stored record of the sequence number  of the request message  is also deleted.",{"@attributes":{"id":"p-0037","num":"0055"},"figref":["FIG. 6","FIG. 5"],"b":["40","58","60","40","52","52","40","76","60","84","80","43","46","48","40","58","84","70","86","84","58","60","52","60","70","70","76","42"]},"In the exchanges of messages illustrated in , no messages were lost or delayed beyond their expected arrival times.  illustrate how the ART protocol handles situations in which messages are lost or delayed.  illustrate the exchange of messages when the request message  is lost the first time it is sent (), the reply message  is lost the first time it is sent (), the acknowledgement message  is lost (), and the reply message  is delayed and received after the retransmission timer expires for the first time ().  illustrate situations in which reliable transport protocol ultimately fails and an error is reported upon the second expiry of the retransmission timer .  illustrate two situations in which provisional replies  are lost and a second request  is sent. In both cases, the request  and reply  are reliably transported. It should be noted that in no case illustrated in  has a request  been processed more than once by the server application . However, if an error is reported as in the cases illustrated in , an error recovery procedure might result in a retransmission of the same request  with a new sequence number, which may be processed again. However, the flexibility provided by the use of personalities as discussed below can be used to minimize the use of an error recovery procedure unless the wireless link is totally closed down.","As will be apparent from the above discussion of , the success and efficiency of a reliable transport mechanism depends upon an intelligent selection of the retransmission time-out intervals , the total number of retransmissions before an error is reported if no reply has been received, the delay interval  applied to the retransmission timer interval  if a provisional reply is received, and the reply cache timer interval . While each of these parameters could be fixed when an ART socket is created for a particular application using data passed to the ART protocol by the application, it is preferable for these parameters to be adjusted while an ART socket exists. For example, it may be best for some network applications to recalculate the retransmission timer interval  each time the retransmission timer interval  expires without a reply message  having been received. The recalculation may involve consideration of recent round-trip times between the client and the server. For other applications (or other processes of the same application), it may be best to keep the retransmission timer interval  constant. The inventor realized that the reliable transport mechanism could be made more flexible if the determination of these parameters were made by a set of functions called by the ART protocol stack, but which are supplied with the network application. An application programmer in writing or porting a network application could be provided with sets of functions suitable for a number of types of network application processes. The application programmer would not have to deal with the nuts and bolts of providing reliable transport, but would simply (1) link a network application with a selected set of functions when creating an executable of the application, (2) include code in the application to pass a structure containing pointers to the functions of the selected set to the ART protocol stack, and (3) include in the application calls to the ART protocol stack. Since each set of functions provides different behavior on the part of the reliable transport mechanism, a particular set of such functions is referred here as a \u201cpersonality\u201d and the functions of a personality as \u201cpersonality functions\u201d.","In addition to providing flexible and easy selection of timer parameters, the use of personalities can allow the structure of messages sent and received by an ART protocol stack to be changed by changing the personality. In particular, if a personality provides message creating and parsing functions for use by the ART protocol stack, then the structure of the ART header could be different for different personalities, without changing the application or the ART protocol stack. For example, a personality could provide a header that includes space for 32-bit sequence number. Further, by providing appropriate message creating and parsing personality functions a personality could re-encode or supplement data contained in request or reply so that the client-side of one network application could communicate with the server-side of a different network application even though the two network applications use incompatible data encoding and message structures.","More specifically, the following are the calls that a client application  can make to the client-side ART stack  in a present embodiment of the invention:\n\n","The following are the calls that a server application  can make to the server-side ART stack  in the present embodiment of the invention:\n\n","A call to open an ART socket (ART_open) must include a structure that contains the pointers to the personality functions. The following are the personality functions that are called by the client-side ART protocol stack :\n\n","The following are the personality functions that are called by the server-side ART protocol stack :\n\n","ART protocol stacks also include the following utility functions (\u201cpersonality utility functions\u201d) that may be called by the personality functions:\n\n","As well as being embodied in a method for providing reliable transport, the invention may be embodied in the host computers in a computer network such as computer network  illustrated in . In such an embodiment, the operating system  of the client host computer  includes a client-side ART protocol stack  for use by client applications and the operating system  of the server host computer  includes a server-side ART protocol stack  for use by server applications.","The following describes in more detail the actions taken by the client-side ART protocol stack  and the server-side ART protocol stack  in a current embodiment in reliably transporting a request from a client application to a server application.","Client-Side ART Protocol Stack","When a command is received from a client application to open a client socket:\n\n","When a command is received from the client application to connect the client socket to a server application:\n\n","When a command is received from the client application to transmit a request to the server application:\n\n","When a message is received from the transport layer:\n\n","When a command is received from the client application to return a reply that is received to the request and the reply has been received and stored:\n\n","After the reply is returned to the client application:\n\n","If no message having a header containing the sequence number and a type code indicating that the message contains a reply has been received before the retransmit timer has expired, then repeatedly:\n\n","but if the retransmit timer has expired the maximum number of times and no such message has been received, then:\n\n","When a command is received from the client application to close the client socket,\n\n","When a command is received from the server application to open a server socket:\n\n","When a message is received from the client application:\n\n","If, after delivery of the request to the server application, a command is received from the server application to send a provisional reply, then:\n\n","When a command is received from the server application to transmit a reply to the client application:\n\n","When a message is received from the client application subsequent to the first message containing the request:\n\n","When the reply cache timer interval expires:\n\n","When a command is received from the server application to close the server socket:\n\n","The above-described embodiments of the invention is intended to be examples of the present invention, and alterations and modifications may be effected thereto by those of skill in the art, without departing from the scope of the invention which is defined solely by the claims appended hereto."],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Preferred embodiments of the present invention will now be described, by way of example only, with reference to the attached Figures, wherein:",{"@attributes":{"id":"p-0021","num":"0028"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0029"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0030"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0024","num":"0031"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0032"},"figref":"FIGS. 5-15"}]},"DETDESC":[{},{}]}
