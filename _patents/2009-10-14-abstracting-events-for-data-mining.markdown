---
title: Abstracting events for data mining
abstract: An event is described herein as being representable by a quantified abstraction of the event. The event includes at least one predicate, and the at least one predicate has at least one constant symbol corresponding thereto. An instance of the constant symbol corresponding to the event is identified, and the instance of the constant symbol is replaced by a free variable to obtain an abstracted predicate. Thus, a quantified abstraction of the event is composed as a pair: the abstracted predicate and a mapping between the free variable and an instance of the constant symbol that corresponds to the predicate. A data mining algorithm is executed over abstracted, quantified events to ascertain a correlation between the event and another event.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08280899&OS=08280899&RS=08280899
owner: Microsoft Corporation
number: 08280899
owner_city: Redmond
owner_country: US
publication_date: 20091014
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["One of the major themes in data mining is the extraction of patterns existent in a data set. For example, data mining algorithms have been commissioned to recognize correlations in purchase patterns of consumers. For instance, a data mining algorithm can be employed to ascertain that an individual will generally purchase toothpaste if the individual also purchased a toothbrush. In another example, a data mining algorithm can be commissioned to infer sequential patterns in data. If an individual purchases a shirt, for instance, the data mining algorithm can infer that the individual will likely purchase trousers after purchasing the shirt. Such correlations in transactions can be useful in connection with product placement, marketing, etc.","Conventionally, however, data mining techniques have not been widely utilized in connection with software verification tools. For example, given a program and documented rules\/constraints imposed by developers on the program, software verification tools can be utilized to verify that the program satisfies the rules\/constraints imposed by the developers. For instance, software verification tools can be employed to ascertain that a program that uses a library\/application programming interface does so in accordance with rules\/constraints of the library\/application programming interface. The usefulness of such verification tools, however, is limited due to lack of machine-readable rules\/constraints for programs. For instance, with respect to legacy software, developer turnover can result in the loss of a substantial amount of knowledge about the internal workings of the software that is ingrained in the memory of developers but is not written in a specification pertaining to the software. While documentation may curb some of such losses, oftentimes internal details of software are conventionally not documented.","In another example, alteration to undocumented but observed behaviors of software can cause clients of the software to fail as such software evolves. These failures can be alleviated if rules\/constraints of the software are available to developers at the time they make modifications to such software.","The following is a brief summary of subject matter that is described in greater detail herein. This summary is not intended to be limiting as to the scope of the claims.","Described herein are various technologies pertaining to abstracting observed events to generated quantified abstractions of the observed events. In an example, an observed event may be a transaction that includes a plurality of purchases of various items. In another example, an event may pertain to execution of a particular portion of a software program (e.g., a portion of a trace). An observed event may include a plurality of what is referred to herein as predicates. In the case of a transactional event, a predicate may be an attribute\/value pair, which can be an indication that an attribute has a certain value, such as a color of a shirt is red, a manufacturer of the shirt is a particular manufacturer, etc. In the case of software, a predicate may be an indication that a return value is a particular number, an indication that an invoked function has a particular name, an indication that a parameter has a specific value, etc.","At least one of the predicates corresponding to the event may have a constant symbol corresponding thereto. In the example pertaining to the shirt, the constant symbol may be a particular color, such as red, green or blue. In the software example, the constant symbol may be a particular value of a parameter. While the examples above have described predicates as being atomic in nature, it is to be understood that the predicates may be conjunctive such that a predicate may be connected by an \u201cand\u201d or an \u201cor\u201d.","Once the plurality of predicates have been identified, a subset of such predicates can be selected from the plurality of predicates. Thereafter, a set of instances of constant symbols that correspond to the subset of predicates can be identified. Thus, for instance, if a predicate is indicative of a size of the shirt, the constant symbol may be a particular size (e.g., 40 long). Thereafter, for each instance of the constant symbols identified, a mapping can be generated from a free variable that is chosen to be used in a particular predicate (e.g., to represent the instance of the constant symbol) to the instance of the constant symbol in such predicate. Such mapping can be added to an overall mapping data set that includes all mappings from free variables chosen to be used in predicates to constant symbols corresponding to the subset of predicates.","As indicated above, free variables can be chosen to be used in predicates. For each of the predicates, an abstracted predicate can be constructed by replacing the instance of the constant symbol with a free variable, such that the mapping given the free variable points to the instance of the constant symbol. The predicates corresponding to the event may be rewritten as abstracted predicates by replacing each predicate in the subset of predicates with its corresponding abstracted predicate as described above. The abstracted predicate and the mapping between the subset of abstracted variables and the instances of the constant symbols can be composed as a pair to construct a quantified abstraction of the event. This process can be undertaken for a plurality of events.","Once a plurality of quantified abstracted events are generated, a data mining algorithm can be executed over such quantified abstracted events. To obtain different results, different predicates can be selected to be in the subset of predicates for various events. Executing a data mining algorithm over such abstracted events can allow for inference of rich patterns in a data set (e.g., complex\/rich rules\/constraints pertaining to a software program).","Other aspects will be appreciated upon reading and understanding the attached figures and description.","Various technologies pertaining to abstracting events in a data set will now be described with reference to the drawings, where like reference numerals represent like elements throughout. In addition, several functional block diagrams of example systems are illustrated and described herein for purposes of explanation; however, it is to be understood that functionality that is described as being carried out by certain system components may be performed by multiple components. Similarly, for instance, a component may be configured to perform functionality that is described as being carried out by multiple components.","With reference to , an example system  that facilitates abstracting events in a data set is illustrated. As used herein, an event can refer to a tuple of primitive values. Thus, for instance, an event may be transactional in nature, such as an individual purchasing a shirt, wherein the shirt has several attributes corresponding thereto (color, size, manufacturer) and each of such attributes can have a value corresponding thereto. In another example, an event may refer to execution of a particular portion of a software program, wherein such portion of the software program may include an input value, a return value, a function name, a function type, etc. Thus, a primitive value corresponding to an event may be a string, an integer, a floating point value, or other suitable value. Other types of events will be recognized by one of ordinary skill in the art.","The system  comprises a data repository . The data repository  can retain a first data record  that is in any suitable format. The first data record  can also be referred to herein as a raw data record, and may comprise a single event or multiple events. The first data record  can comprise a first event . The first event  comprises at least one predicate , which is a predicate over the event . In an example, where the first event  is transactional in nature, the predicate  can represent a particular attribute\/value pair corresponding to the first event . In a more detailed example, if the first event  is the purchase of a shirt, the predicate  may be an attribute\/value pair that is indicative of an identity of a manufacturer of the shirt. In another example, the predicate  may represent an attribute\/value pair that is indicative of a color of the shirt, a size of the shirt, or other suitable attribute\/value pairs (e.g., attribute is color or size, and value is red or large, respectively, and the predicates indicate that the color of the shirt is red or the size of the shirt is large).","In another example, as indicated above, the first event  can represent execution of a particular portion of a software program. In such a case, for instance, the predicate  may be a name of a specific procedure, wherein parameter values corresponding to the procedure may have particular constraints corresponding thereto. Thus, the predicate  can match calls to a procedure with a certain parameter value.","The first event  can further comprise a constant symbol  that corresponds to the predicate  (e.g., the predicate  may include a constant symbol). The constant symbol  is a symbol corresponding to the at least one predicate  that is not subject to alteration. Thus, the constant symbol  may be a particular value, may be a particular string, letter, etc. Returning to the transaction example, the predicate  can represent size of the shirt, and the constant symbol  can be the particular size (e.g., 40). In the example where the first event  corresponds to execution of the software program, the constant symbol  may be a particular return value, a particular parameter value, or other constant symbol.","The system  also includes an accessor component  that accesses the data repository  and retrieves the first data record  from the data repository . For instance, the data repository  may be included in a computer, such as a personal computer, a server computing device, or other suitable computing device. Additionally, as indicated above, the first data record  comprises the first event , which has the at least one predicate  corresponding thereto, and the at least one predicate  has the constant symbol  corresponding thereto.","A representor component  is in communication with the accessor component . The representor component  utilizes a free variable in the predicate  to abstract such predicate . Thus, for example, if the predicate  is representative of a manufacturer of the shirt, the representor component  can utilize a free variable to indicate that the manufacturer of the shirt is the variable \u201cx\u201d. In another example, if the predicate  represents a return value, the representor component  can use a free variable vto indicate that the return value is v.","An identifier component  can identify at least one instance of the constant symbol  included in the first event . For example, in connection with a software program, several instances of a constant symbol may be existent with respect to a particular portion of the software program. The identifier component  can identify such instances of the constant symbol  that corresponds to the first event .","The system  further includes a mapper component  that generates a mapping between the at least one free variable used in the predicate  and the at least one instance of the constant symbol  identified by the identifier component . Considering instances of constant symbols (instead of constant symbols) allows different instances of the constant symbol  to be mapped to different free variables in a same abstraction. Example mappings between free variables and instances of constant symbols  are provided below.","A generator component  can be in communication with the mapper component . The generator component  can be configured to generate a second data record  and cause such second data record  to be stored in the data repository . Contents of the second data record  include an abstraction  of the first event , wherein the abstraction  is a quantified abstraction of the first event . The abstraction  generated by the generator component  includes a free variable  used in the predicate  and a mapping  between the free variable  and the instance of the constant symbol  identified by the identifier component .","The description of the system  above describes construction of a single abstraction  of the first event . It is to be understood that multiple abstractions of the first event  can be generated if there are multiple predicates that correspond to the first event  and\/or if predicates comprise multiple instances of constant symbols. For instance, if the first event  has a plurality of predicates corresponding thereto, the abstraction  may include the free variable  that corresponds to one of such predicates and the mapping  that maps the free variable  to the instance of the constant symbol corresponding to the predicate . The remainder of the abstraction  may be another free variable that is used in a different predicate and instances of constant symbols that correspond to the different predicate. Thus, any suitable combination of predicates can be assigned free variables, and mappings can be generated between the free variables and instances of constant symbols corresponding thereto. Therefore, a single event may have multiple abstractions related thereto.","Referring now to , an example system  that facilitates executing a data mining algorithm over quantified abstractions of events is illustrated. The system  comprises the data repository  that includes the second data record , which comprises a representation of the first event  in the first data record  (). That is, the second data record  comprises the abstraction  of the first event , wherein the abstraction  includes the at least one free variable  that included in the predicate , and the mapping  between the free variable  and at least one instance of the constant symbol . The data repository  also includes an nth data record , which is a representation of another event included in the data repository . The nth data record  includes an abstraction  that is a quantified abstraction of at least one other event represented in the data repository . The abstraction  includes a free variable  that is included in a predicate that corresponds to the at least one other event and a mapping  between the free variable  and an instance of a constant symbol that corresponds to such free variable .","The system  further includes a data mining component  that is configured to execute a data mining algorithm  over the second data record  and the nth data record . The data mining algorithm  can be configured to output an indication of correlation between the second data record  and the nth data record . In an example, the indication of correlation can include an indication of a temporal correlation between the first event, represented by the abstraction , and the nth event represented by the abstraction . An example of a temporal correlation may be that if a person first buys a shirt, that person will thereafter buy pants. In another example, a temporal correlation may be that if a particular functional call has a certain input, such function call will later be followed by another function with a particular output. In yet another example, the indication of correlation output by the data mining algorithm  may be an indication of a transactional correlation between the first event, represented by the abstraction , and another event, represented by the abstraction . An example transactional correlation is that if a person buys a toothbrush, that person is also highly likely to purchase toothpaste. In a software program, a transactional correlation may be that if a function call exists with a certain parameter, then a return value for another function may be a particular value.","With reference now to , an example depiction  of various ways to perform an abstraction over an event is illustrated. The depiction  comprises an event . The event  may include the execution of the function fopen, with an input argument id.txt that returns the numerical value 23 as a file handle. This event is illustrated in the functional block . The event  can be represented through utilization of three predicates ,  and . The first predicate corresponds to the return value equaling 23 (returnValue=23). The second predicate corresponds to the function equaling fopen (function=fopen). The third predicate  corresponds to the first parameter of the event  being id.txt (Parameter1=id.txt). Therefore, the event  can be represented as predicates return value=23 and function=fopen; and return value=23 and function=fopen and parameter 1=id.txt, wherein the representation comprises constant symbols\/values, where x=y is a positional predicate that denotes that y occurs at position x.","From such representations of the event , the system  can be utilized to construct at least three different quantified abstractions. For example, with respect to a first abstraction , a free variable v can be included in the predicate , as shown in function block . The function block  is thus an abstracted version of the predicate . The second predicate  can remain unchanged in the first abstraction , as shown in function block . An instance of the constant symbol  can be identified and can be mapped to the free variable v, as shown in function block . It can be ascertained that in the first abstraction  the predicate  is not included therein.","In a second abstraction , a free variable v can be employed in connection with abstracting the first predicate  as shown in function block . The second predicate  and the third predicate  can remain unaltered, as shown in function blocks  and . As shown in function block , the instance of the constant symbol can be mapped to the free variable v.","In a third abstraction , the free variable v can again be chosen to be used to abstract the first predicate , as shown in function block . The second predicate  may remain unchanged, as shown in function block . A free variable v can be used to abstract the third predicate , as shown in function block . In function block  it can be ascertained that the free variable v is mapped to the value 23 while the free variable v is mapped to the parameter value id.txt. As will be shown by way of example below, the free variables and mappings may be utilized by a data mining algorithm to ascertain correlations between events.","As indicated above, such abstractions can be employed in connection with a data mining algorithm that can be configured to mine rules\/specifications of a software program. The implications of abstracting events in a manner such as that described above is that data mining algorithms can leverage known properties to incrementally consider richer abstractions of events to efficiently mine richer specifications\/rules pertaining to the software program. This can be undertaken by avoiding abstractions of events that are known to not contribute to a rule. Additionally, any data mining algorithm that operates on a sequence of events can operate on a sequence of events of abstractions resulting from executing of the system . Furthermore, the abstractions can be generated independent of the class of predicates, so long as terms involved in the predicates are comparable.","Moreover, the data mining algorithm can be utilized to mine temporal rules through utilization of trace abstractions. For instance, given a trace that encodes an execution path as a sequence of events, the trace can be viewed as a sequence of predicates satisfied by the events in the corresponding position in the original trace. Accordingly, specification mining algorithms can deal with one trace composed of a large number of sets of (repeated) predicates, as opposed to considering prohibitively numerous views of the same trace.","The data mining algorithm indicated above can be configured to execute over abstractions and ascertain temporal rules corresponding to the abstractions of the events. For instance, the temporal rule \u03be\u03berepresents the rule that any occurrence of \u03bemust be eventually followed by an occurrence of \u03be. Thus, a sequence \u03c0=e, e, . . . esatisfies the temporal formula \u03be\u03be(denoted \u03c0\u03be\u03be) if and only if for any e\u03bethere exists a j>i such that e\u03be.","In another example, the temporal rule \u03be\u03berepresents a rule that (i) any occurrence of \u03bemust eventually be followed by an occurrence of \u03be, and (ii) an occurrence of \u03becannot be followed by another occurrence of \u03bebefore an occurrence of \u03be. In such rules, \u03becan be referred to as antecedent, and \u03becan be referred to as a consequent of the rule.","When constraints are introduced, wherein the constraints involve parameter and return values of different events in a temporal rule, such rules can become quantified. An example may be \u201cevery call made to foo(x) can be preceded by a call to bar that returned x\u201d. As can be ascertained, this form of rule can be learned by executing the data mining algorithm over abstractions generated by way of the system . More formally, quantification is enabled through generalizing event predicates to allow event predicates that include free variables.","An example algorithm for performing data mining over abstracted events pertaining to a software program (e.g., a call to an API or library) is described in , by David Lo, et al., 16Working Conference on Reverse Engineering (WCRE09), Lille, France, Oct. 13-16, 2009, the entirety of which is incorporated herein by reference.","With reference now to , various example methodologies are illustrated and described. While the methodologies are described as being a series of acts that are performed in a sequence, it is to be understood that the methodologies are not limited by the order of the sequence. For instance, some acts may occur in a different order than what is described herein. In addition, an act may occur concurrently with another act. Furthermore, in some instances, not all acts may be required to implement a methodology described herein.","Moreover, the acts described herein may be computer-executable instructions that can be implemented by one or more processors and\/or stored on a computer-readable medium or media. The computer-executable instructions may include a routine, a sub-routine, programs, a thread of execution, and\/or the like. Still further, results of acts of the methodologies may be stored in a computer-readable medium, displayed on a display device, and\/or the like.","Referring now to , a methodology  that facilitates abstracting an event is illustrated. The methodology  begins at , and at  a first data record is accessed in a data repository. The first data record comprises a first event, wherein the first event comprises at least one predicate and at least one value that corresponds to the at least one predicate.","At , a quantified, abstracted event is generated that is representative of the first event. Generating the quantified, abstracted event can include using at least one free variable to abstract the at least one predicate. Generating the quantified abstracting event can further include generating a mapping between the at least one free variable and at least one instance of a constant symbol that corresponds to the at least one predicate. The free variable(s) and the mapping(s) can be stored in the data repository as a second data record.","At , the quantified abstracted event is caused to be stored as a second data record in the data repository. At , a data mining algorithm is executed via at least one computer processor over the second data record and at least one other data record to determine a correlation between the second data record and the at least one other data record. Such correlation may be in the form of a rule pertaining to accessing an application programming interface. In another example, such correlation may be temporal in nature and\/or transaction in nature.","At , an indication of the correlation is output. For instance, the indication of the correlation can be output to a display screen, to a memory device, a hard drive, etc.","It is to be understood that the first event can include a plurality of predicates, wherein at least a subset of such predicates has constant symbols corresponding thereto. In such a case, generating the quantified abstracted event can include selecting a subset of the plurality of predicates that correspond to the first event, using a corresponding set of free variables to abstract each of the subset of the plurality of predicates, and generating mappings between the set of free variables and instances of the constant symbols that correspond to the subset of predicates. Different quantified abstractions of the first event can be generated by selecting different subsets of predicates and mapping free variables that represent such predicates to constant symbols corresponding thereto.","The first event described above can pertain to, for instance, an application programming interface, a library, an execution path of a program executed by a computer processor, etc. Moreover, as described above, the quantified abstraction in the second data record can be composed as a pair, wherein the pair comprises free variables that represent predicates corresponding to the first event, and a mapping between the free variables and instances of constant symbols corresponding to the predicates. Further, the first event can be generated by encoding an execution path of an application (software program) executed by the computer processor. The methodology  completes at .","With reference to , an example methodology  that facilitates executing a data mining algorithm over a quantified abstraction of an event is illustrated. The methodology  begins at , and at  a first data record is accessed in a data repository. The first data record can include a first event that occurred during execution of a software program, wherein the first event has at least one predicate corresponding thereto, and the at least one predicate has a constant symbol corresponding thereto. Examples of predicates and constant symbols have been provided above.","At , at least one instance of the constant symbol corresponding to the predicate in the first event is identified in the first data record.","At , at least one free variable is used to abstract the predicate. At , for the at least one identified instance of the constant symbol, a mapping is generated between the free variable and the at least one instance of the constant symbol.","At , a second data record is generated in the data repository, wherein the second data record comprises at least one free variable and the mapping composed as a pair. As described above, this composed pair can represent a quantified abstraction of the first event.","At , a data mining algorithm is executed over the second data record and at least one other data record to determine a temporal correlation between the second data record and the at least one other data record (e.g., and thus the first event and another event). At , an indication of the correlation is output, and the methodology  completes at .","Now referring to , a high-level illustration of an example computing device  that can be used in accordance with the systems and methodologies disclosed herein is illustrated. For instance, the computing device  may be used in a system that supports abstracting events in a quantified manner. In another example, at least a portion of the computing device  may be used in a system that supports executing data mining algorithms over quantified abstracted events. The computing device  includes at least one processor  that executes instructions that are stored in a memory . The instructions may be, for instance, instructions for implementing functionality described as being carried out by one or more components discussed above or instructions for implementing one or more of the methods described above. The processor  may access the memory  by way of a system bus . In addition to storing executable instructions, the memory  may also store events, quantified abstractions of the events, etc.","The computing device  additionally includes a data store  that is accessible by the processor  by way of the system bus . The data store  may include executable instructions, events, quantified abstractions of the events, etc. The computing device  also includes an input interface  that allows external devices to communicate with the computing device . For instance, the input interface  may be used to receive instructions from an external computer device, from an individual, etc. The computing device  also includes an output interface  that interfaces the computing device  with one or more external devices. For example, the computing device  may display text, images, etc. by way of the output interface .","Additionally, while illustrated as a single system, it is to be understood that the computing device  may be a distributed system. Thus, for instance, several devices may be in communication by way of a network connection and may collectively perform tasks described as being performed by the computing device .","As used herein, the terms \u201ccomponent\u201d and \u201csystem\u201d are intended to encompass hardware, software, or a combination of hardware and software. Thus, for example, a system or component may be a process, a process executing on a processor, or a processor. Additionally, a component or system may be localized on a single device or distributed across several devices.","It is noted that several examples have been provided for purposes of explanation. These examples are not to be construed as limiting the hereto-appended claims. Additionally, it may be recognized that the examples provided herein may be permutated while still falling under the scope of the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
