---
title: Systems and methods for managing instantiation of interface objects
abstract: A system and method are described for managing instantiation of interface elements in a rich Internet application (RIA) that includes systematically creating a tree of descriptive nodes that describe the visual interface elements of the application. Only interface elements that are not stacked under other objects or not fully hidden on the screen are instantiated using the corresponding descriptive nodes. Detail objects corresponding to the descriptive nodes are then constructed and used by a rendering engine to render the visual interface elements of the declarative application. As the user moves to locations within the application that are stacked under other objects or are hidden, the descriptive nodes and detailed objects are created representing the interface elements of those locations for rendering by the rendering engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08938693&OS=08938693&RS=08938693
owner: Adobe Systems Incorporated
number: 08938693
owner_city: San Jose
owner_country: US
publication_date: 20110228
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION AND PRIORITY CLAIM","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present application is a continuation of U.S. patent application Ser. No. 10\/796,785, filed Mar. 8, 2004 and titled, \u201cA System and Method for Managing Instantiation of Interface Elements in Rich Internet Applications,\u201d which is incorporated by reference herein in its entirety.","The present invention relates, in general, to rich Internet applications (RIAs), and, more specifically, to the deferred instantiation of interface elements in RIAs.","Over the last ten years, computers and computing technology have grown in leaps and bounds due, in no small part, to the growth and reach of the Internet. Computer applications, once written in procedural programming languages and mostly self-contained on each computer desktop, now are increasingly being written to include non-procedural programming languages with regular interaction across a data network, such as the Internet, for retrieving, not only data, but application logic as well.","Procedural languages, such as C\/C++, FORTRAN, MICROSOFT CORPORATION'S VISUAL BASIC\u2122, and the like, implement application functionality through properly ordered steps and actions. In contrast, non-procedural languages, such as Hypertext Markup Language (HTML), MACROMEDIA, INC.'s MXML\u2122, which is a specialized, XML-based language for developing RIAs in MACROMEDIA, INC.'s FLEX\u2122 development environment, and the like, define the final appearance of an application's user interface without specifying a time-based sequence of steps for constructing that interface. These non-procedural languages, also known as declarative languages, are extensively used in Internet technology. Web pages are defined by the underlying HTML. When a browser requests a Web page, the entire page is defined. In typical RIA, procedural languages may be used to define the programming logic, while the non-procedural languages are used to define the visual interface elements.","RIAs are one area in which the growth of declarative applications has coupled with a growth in Internet or network interaction. RIAs combine the usability of a desktop application with the administrative advantages of the Internet. Formerly, the client-server framework powered many Internet related applications. In the client-server paradigm, the client computer acts mostly as a display unit. The majority of processing occurs remotely on the server, while the results are displayed on the client. While this functionality extends the powerful processing of large centralized servers to individual users, network latency leads to delays in the operation of client-server applications. Even with the large increases in available high speed bandwidth, network latency still exists.","RIAs, however, provide for much of the processing to be completed on the client computer. The RIAs are stored remotely on Internet-accessible servers. When the client requests access, the computer logic defining the RIA, or at least large portions thereof, is downloaded and run completely on the client computer. Desktop and handheld computers have become faster and more powerful, and with large amounts of storage space. Therefore, complex data and rich graphics may be processed and rendered quickly. Moreover, because of the prevalence and speed of today's Internet access, these RIAs may be continually updated with data in order to provide a rich graphical and informational experience in a real-time world.","Because RIAs typically rely on rich graphical presentation, graphically oriented containers are generally used on each client to run the rich application. For example, interactive information and graphical players, such as MACROMEDIA INC.'s MACROMEDIA FLASH\u2122 PLAYER, SUN MICROSYSTEMS' JAVA\u2122 VIRTUAL MACHINE\u2122 (JVM\u2122), and the like, are used to execute RIAs on the client. These interactive, information and graphical players typically run monolithic files, such as Small Web File (SWF) format for MACROMEDIA FLASH\u2122 PLAYER and JAVA\u2122 applets for the JVM\u2122. SWF files and JAVA\u2122 applets generally consist of bytecode that runs on the virtual machine of the player. The use of virtual machines increases the cross-platform compatibility of such applications. Software manufacturers, such as MACROMEDIA, INC., SUN MICROSYSTEMS, INC., MICROSOFT CORPORATION, and the like, create different virtual machines to play on various different computer platforms. However, the bytecode format remains constant and compatible with its designed player, while the player is customized to the particular computer platform.","When a user selects to access a RIA, the underlying bytecode is downloaded to the user's computer for execution on the graphical player. Merely downloading the bytecode file to the user's computer takes relatively little time, at least over a broadband Internet connection. Once there, each piece of bytecode directs the multimedia player to perform some single step or single function of the application, such as creating objects that may then be rendered onto the display by the players. While the execution of a few steps also does not typically take much time, the execution of all of the bytecode to instantiate and render each of the graphical interface elements in addition to the download time creates a substantial delay in the user's experience of the RIA. Once this process has completed, interaction with the RIA is extremely fast. However, the initial start-up delay may be long enough to cause many users to quit the RIA before even being able to access it. Thus, the current solutions for delivering high quality RIAs based on declarative languages provide a less than desirable experience for the user at start up.","Representative embodiments of the present invention are directed to a system and method for deferring the instantiation of selected interface elements of a declarative software application until a user navigates to a particular location. As a declarative software application is downloaded to a client computer, a descriptive hierarchical data structure or descriptor tree of the application is developed. This descriptive hierarchical data structure merely describes the presentation of the visual elements and, therefore, utilizes much less processing overhead than the actual instantiation of each of the application's interface elements in the presentation container. Certain visual elements, such as menu items, typically provide immediate access to user interactions, and therefore, are instantiated in advance. However, in certain stacked navigation elements, such as tabbed or accordion groups of panes or views, typically only the active pane or view is visible to the user at anyone time. Therefore, instantiation of the objects resident on the hidden panes or views is generally unnecessary until the user navigates to the hidden pane or view.","In operation, the initially visible elements of the application are fully rendered and displayed within the presentation container while the initially unseen elements in the descriptive hierarchical data structure or descriptor tree remain descriptive. The multimedia player rendering the visible display elements uses an object tree created from the descriptor tree to render the visual elements. The nodes of the hierarchical outline, as well as the object tree, that represent stacked visual elements are created according to a user's navigation. Therefore, the user experiences a limited delay at start up. For example, if each view takes half of a second to be instantiated, the user experiences the half-second delay as opposed to the much longer display should all of the views of the application be instantiated before execution begins. If there were 100 views in the application, a half-second per view delay would translate into a 50 second delay at start up.","Once interface elements are instantiated, they remain instantiated in memory. Therefore, as the user continues to navigate through the application, more of the hierarchical outlines becomes instantiated allowing the graphical player to re-render each interface element very quickly when the user returns to any previously viewed pane or view. Furthermore, each subsequent navigation to one of the previously viewed interface elements is delivered without the initial instantiation delay, thus, further improving the user's interaction experience with the application.","The foregoing has outlined rather broadly the features and technical advantages of the present invention in order that the detailed description of the invention that follows may be better understood. Additional features and advantages of the invention will be described hereinafter which form the subject of the claims of the invention. It should be appreciated that the conception and specific embodiment disclosed may be readily utilized as a basis for modifying or designing other structures for carrying out the same purposes of the present invention. It should also be realized that such equivalent constructions do not depart from the invention as set forth in the appended claims. The novel features which are believed to be characteristic of the invention, both as to its organization and method of operation, together with further objects and advantages will be better understood from the following description when considered in connection with the accompanying figures. It is to be expressly understood, however, that each of the figures is provided for the purpose of illustration and description only and is not intended as a definition of the limits of the present invention.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["10","102","104","100","102","104","101","10","102","104","102","100","101","100","102","101"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["103","103","200","200"]},"The SWF file and its bytecode in bytecode storage  initiate the creation of descriptor tree , which will eventually be constructed of application descriptor node  and descriptor nodes -. A descriptor node is a data structure that contains descriptions for a single object or single container of the RIA. The description comprises the properties of each object or the properties of each container that the node represents. This description may closely resembles the code structure written in the declarative language, such as MXML\u2122 which was used in developing the example depicted in . In normal application, a developer, using MXML\u2122 in the present example, will only define the object properties that vary or differ from default properties of the particular objects. Objects represent any type of screen items such as a pane container, buttons, fill-in fields, menus, navigators, and the like. For example, the developer may define the text of a button label in MXML\u2122. This defined text would then be included in the button object descriptor for that button. Similarly, the background color, width, and height for a container, and the like, may be included in the descriptor node representing the container object. The descriptor nodes for these objects would, therefore, include the descriptions of the properties defined in the MXML\u2122 code that vary from the default properties of those objects.","In contrast, the actual object, which the graphical player uses to render the graphical representation on its display, contains not only the custom properties of the object, but also each and every other property within the default definition of that object. Therefore, the object that is used by the graphical player contains much more data and information than its descriptor. The smaller amount of data and information in the intermediate descriptor node decreased the amount of time to transmit the bytecode for it across Internet .","The first node in descriptor tree  that is created by the SWF and the bytecode in bytecode storage  is application descriptor node . Application descriptor node  includes a description of the properties of the application plus child constructor methods for creating each of the child nodes of application descriptor node . These child constructor methods are code logic that contain pointers to specific bytecode in bytecode storage  that the graphical player engine uses to create each of the descriptor child nodes of application descriptor node , descriptor nodes  and . Similarly, descriptor nodes  and  each have described properties and their own child constructor methods with pointers to bytecode storage  for creating their children, descriptor nodes -. Thus, each descriptor node in descriptor tree  includes property descriptions for its representative object or container object and, possibly, a child constructor method that points to some bytecode in bytecode storage  for creating its children, if any such children exist.","In example operation, descriptor node  may represent a container that ultimately represents a pane displayed by the graphical player. Descriptor node  would, therefore, contain descriptions such as, among others, the pane height and width along with a background color and a child constructor method to create descriptor node . Descriptor node  may represent a button located on the pane described by descriptor node . Because descriptor node  represents a visible object within the pane represented by descriptor node , the child constructor method of descriptor node  is called and executed to create descriptor node . Descriptor node  may then include the button text, possibly a button color, or the like.","Descriptor node  may represent a tab navigation container (i.e., a tabbed pane). Descriptor node  would include its property descriptors such as height, width, background color, and the like, and the child constructor methods for constructing descriptor nodes  and , which may represent the containers for each of the tabs in the tabbed navigation container. Because descriptor nodes  and  represent the child views of the tabbed navigation container, it is known that only the contents of one of those views will be visible to the user at anyone time when it is rendered on the display by the graphical player. Thus, the views in the tabbed navigation container are stacked in relation to each other. As a result, the child constructor methods are called first only for descriptor node  to create descriptor nodes  and , which may represent a button and possibly a text box to be displayed on the first view of the tabbed pane that will be rendered and displayed by the graphical container. Therefore, any children that descriptor node  may have are not instantiated when the user is viewing the first view of the tabbed pane represented by descriptor nodes , ,  and . This delaying or deferring the instantiation of the hidden object descriptors in such stacked navigation objects saves processing time and increases the speed with which the application is rendered and displayed to the user. If a user were to navigate then to the tab view represented by descriptor node , the child descriptor methods of descriptor node  may be called to generate any child descriptor nodes that it may have. These child nodes would represent the contents of that view.","It should be noted that in various alternative and additional embodiments of the present invention, various methods may be used to note the information of whether a particular object is a stacked or unstacked object. For example, the information that a particular object or container object is stacked or unstacked may be contained in descriptor node , which may indicate itself as a stacked container. Similarly, the information may be contained in each of descriptor nodes  and , which may indicate that they are members of a stacked object. Various embodiments of the present invention may implement this information in a number of different ways.","In practice, in order to graphically render the RIA on the display, the descriptor nodes of descriptor tree  are converted into object nodes that contain every one of the object properties that the graphical player uses to render the visual elements onto the display. As each of the descriptor nodes of descriptor tree  is created, the descriptor node is processed by application programming interface (API) , which converts the description into the renderable object within object tree . Thus, descriptor tree  and object tree  are created and unfolded in parallel. The graphical player then uses each of object nodes O--O- to render the visual elements for the RIA onto the display of computer .","It should be noted that any order of converting the descriptor nodes of descriptor tree  into the object node of object tree  may be employed. For example, a descriptor node may be processed by API  immediately after its creation, or may be processed after completing the creation of each descriptor node of a particular tree level, or may be processed after completing the creation of each descriptor node in the deferred version of descriptor tree .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3A","b":["300","300","314","301","300","315","300","302","301","101","300","315","302","302","32","301","32"]},"Display  illustrates the view that the user first views on the start up of RIA  on computer device . RIA  is represented by the visual rendering of application pane V-. Application pane V- includes container V- that has two buttons, buttons V- and V-. Application pane V- also includes tabbed navigation container V- that has two tab views, tab view V-, which is shown with buttons V- and V-, and tab view V-, which is concealed under tab view V- in the navigation stack. However, in order to get to this point visually on display , multimedia player  first creates descriptor tree  and object tree .","When the executable file is received at computer device , multimedia player  begins execution by creating application descriptor node . Application descriptor node  represents RIA . API  then converts application descriptor node  into application object O- of object tree . Application object O- is then used by virtual machine  to render the background, color, size, shape, and various other properties of application pane V- on display . After calling the child constructor methods of application descriptor node , multimedia player  then causes the creation of descriptor nodes , representing tabbed navigation container V- and descriptor node , representing container V-. API  converts descriptor nodes  and  into object nodes O- and O-, which virtual machine  uses to render tabbed navigation container V- and container V-.","Descriptor node  and  are created from descriptor node , which represent tab views V- and V- of tabbed navigation container V-. Similarly, descriptor nodes  and  are created which represent buttons V- and V- of container V-. API  converts each of descriptor node  - into their corresponding object nodes O--O-, which virtual machine  uses to render tab views V- and V- of tabbed navigation container V- and buttons V- and V- of container V-, respectively.","In the embodiment shown in , descriptor node  contains information that tells multimedia player  that it represents a stacked object. Therefore, multimedia player  determines which of the tabbed views is on top of the stack. Because tab view V- is shown on display , multimedia player  causes descriptor nodes  and  to be created from descriptor node . Descriptor nodes  and  represent buttons V- and V- shown on tab view V-. API  converts each of descriptor nodes - into their corresponding object nodes O--O-, which virtual machine  uses to render buttons V- and V- on tab view V-. At this point, because each of the visual elements visual to the user have been rendered on display , instantiation of the interface elements of RIA  temporarily ceases while the user remains on the view shown in application pane V-.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 3B","FIG. 3A","FIG. 3B"],"b":["300","304","303","304","307","34","307","32","312","313","307","20","312","313","312","313","31","33","312","313","312","313","307","304","312","313","0","312","313","312","313","312","313","300"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3B","b":["310","311","310","311","32","34"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 4","FIG. 4"],"b":["40","42","41","40","40","41","40","40","41","20","42","20","42","33","40"]},"Because the Billing Address, Credit Card, and Confirmation views are each lower in the stack than the Name view, API  only creates objects O-FirstName, O-MI, and -LastName for object tree , which are then used by virtual machine  to render the interface elements on navigational element , FirstName, MI, and LastName. If the user moves to a subsequent accordion view, the objects corresponding to the descriptors of the interface elements contained in the view to which the user has navigated, are created by API , after which virtual machine  uses these objects to render the interface elements on those subsequent views. As the user selects to view Name from one of the subsequent views, virtual machine  renders the interface elements of view Name from the corresponding objects that are now in memory.","It should be noted that, in various additional and alternative embodiments of the present invention, selected stacked objects or views may be designated to be fully instantiated regardless of whether the stacked panes or views are visible in the current view.","In should be noted that, in various other additional and alternative embodiments of the present invention, the descriptor nodes and object nodes for interface elements may be pre-instantiated according to other relationships with the currently visible pane, such as a direct link (i.e., a link that typically traverses between two panes or views using only a single user action, such as a single mouse click), an ordinal relationship (i.e., the panes are ordered in a specific order, in which the interface elements of the next view or pane in the order would be pre-instantiated), a statistical relationship (i.e., statistical calculations are performed on users' interactions with the particular RIA or other application to \u201cpredict\u201d which of the next views the user is likely to navigate to, in which the interface elements for that likely next view would be pre-instantiated), a positional relationship (i.e., particular views are positioned in some kind of hierarchical or ordinal relationship with the currently visible pane, in which case the interface elements of those closely positioned views would be pre-instantiated), or the like. In such embodiments, the descriptor nodes and object nodes for the interface elements for those related views may be instantiated during \u201cprocessing\u201d or thinking time in the current view.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 5","b":["500","501","502"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 6","b":["600","601","602","603","604","605"]},"Although the present invention and its advantages have been described in detail, it should be understood that various changes, substitutions and alterations can be made herein without departing from the invention as defined by the appended claims. Moreover, the scope of the present application is not intended to be limited to the particular embodiments of the process, machine, manufacture, composition of matter, means, methods and steps described in the specification. As one will readily appreciate from the disclosure, processes, machines, manufacture, compositions of matter, means, methods, or steps, presently existing or later to be developed that perform substantially the same function or achieve substantially the same result as the corresponding embodiments described herein may be utilized. Accordingly, the appended claims are intended to include within their scope such processes, machines, manufacture, compositions of matter, means, methods, or steps."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention, reference is now made to the following descriptions taken in conjunction with the accompanying drawing, in which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
