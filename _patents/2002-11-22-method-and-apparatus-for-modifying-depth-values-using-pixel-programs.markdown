---
title: Method and apparatus for modifying depth values using pixel programs
abstract: A method and apparatus for generating depth values in a programmable graphics system. Depth values are calculated under control of a pixel program using a variety of sources as inputs to programmable computation units (PCUs) in the programmable graphics systems. The PCUs are used to compute traditional interpolated depth values and modified depth values. Th PCUs are also used to compute arbitrary depth values which, unlike traditional interpolated depth values and modified depth values, are not dependent on the coordinates of the geometry primitive with which the arbitrary depth values are associated. Several sources are available as inputs to the PCUs. Clipping with optional clamping is performed using either interpolated depth values or calculated depth values, where calculated depth values are arbitrary depth values or modified depth values. Final depth values, used for depth testing, are selected from interpolated depth values and arbitrary depth values after clipping is performed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06864893&OS=06864893&RS=06864893
owner: NVIDIA Corporation
number: 06864893
owner_city: Santa Clara
owner_country: US
publication_date: 20021122
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DESCRIPTION","EXAMPLE 1","EXAMPLE 2","EXAMPLE 3","EXAMPLE 4","EXAMPLE 5"],"p":["This application claims priority from commonly owned U.S. patent application No. 60\/397,468 entitled \u201cMethod and Apparatus for Modifying Depth Values Using Pixel Programs\u201d filed Jul. 19, 2002 that is incorporated herein by reference.","1. Field of the Invention","The invention is in the field of computer graphics, and more particularly to calculating depth values in a graphics pipeline.","2. Description of the Related Art","Recent advances in graphics processors permit users to program graphics pipeline units using fragment or pixel programs to implement a variety of user defined shading algorithms. Traditionally, a graphics processor calculated an interpolated depth value for each pixel dependent on x and y coordinates of a geometry primitive, e.g., triangle or polygon that the interpolated depth value was associated with. The interpolated depth value was passed through the graphics pipeline, pixels were clipped by discarding the pixels whose interpolated depth value was outside of the space between the near and far clipping planes, and the retained pixel depth values were used during the depth test.","A desire for greater flexibility in computations has resulted in modifications in the traditional graphics processor to permit the calculation not only of the traditional interpolated depth values, but also to perform further calculations based on the interpolated depth values to generate modified depth values. As illustrated in , a Graphics Subsystem  calculates traditional interpolated depth values in a Rasterizer . The interpolated depth values are pipelined through a Texturer  to a Pixel Unit . The interpolated depth values are used to compute modified depth values in Pixel Unit . The modified depth values are received by a Raster Operation Unit  that clips the pixels associated with the depth values and performs the depth test operation.","At least one application programming interface (API), OpenGL\u00ae API 1.3, prefers that clipping be performed using interpolated depth values rather than modified depth values, even when modified depth values are generated. However, when Pixel Unit  outputs modified depth values it is not possible for a unit downstream in the pipeline, such as the Raster Operation Unit , to clip pixels using the interpolated depth values. It is also not possible to recalculate the interpolated depth values because the inputs needed for the interpolation calculation are not available to Raster Operation Unit . However, some pixel programs do clip pixels using the modified depth values. Therefore it is still desirable to compute modified depth values and then clip using either modified depth values or interpolated depth values.","Further, the interpolated depth values and the modified depth values are both typically computed dependent on the coordinates of the geometry primitive. However, there is a desire to implement pixel programs that compute depth values that are independent of the coordinates of the geometry primitive, such as depth values read from memory using map indices u and v.","For the foregoing reasons, there is a need for a graphics system that can generate not only interpolated depth values and modified depth values, but also arbitrary depth values that are independent of the coordinates of a geometry primitive. Furthermore, there is a need for a graphics system that can clip pixels using either calculated depth values or interpolated depth values, where calculated depth values are either modified depth values or arbitrary values, and select between interpolated depth values and calculated depth values to determine the final depth values for depth testing.","The present invention is directed to an system and method that satisfies the need for a programmable graphics system that can generate the calculated depth values and the interpolated depth values, clip and optionally clamp pixel values using either the calculated pixel depth values or interpolated pixel depth values, and select between interpolated pixel depth values and calculated pixel depth values to generate final pixel depth values for depth testing.","Various embodiments of the invention include a programmable fragment processing pipeline comprising a local register file and a programmable computation unit. The programmable computation unit comprises one or more arithmetic units, under control of a pixel program, and a write interface. The programmable computation unit is configured to select, under the control of a pixel program, one or more inputs to the one or more arithmetic units from a plurality of sources. The one or more arithmetic units use the selected one or more inputs to compute the calculated pixel depth value that is associated with a geometry primitive pixel and independent of the coordinates of the geometry primitive. The calculated pixel depth value is optionally written to the local register file. Additionally, the invention can include a host processor, a host memory, and a system interface configured to interface with the host processor.","Furthermore, the one or more arithmetic units are configured to compute the interpolated pixel depth value associated with a geometry primitive pixel and dependent on the coordinates of the geometry primitive. Still further, an interpolated pixel depth value is computed using a programmable depth computation unit. A selector is configured, under the control of a pixel program, to select either the interpolated pixel depth value computed by the programmable depth computation unit or the calculated pixel depth value as the final pixel depth value. The plurality of sources includes a graphics memory, a host memory, and an other programmable computation unit in the programmable fragment processing pipeline.","An embodiment of the programmable fragment processing pipeline includes a first clipping unit configured to clip and optionally clamp a pixel associated with the interpolated pixel depth value. The programmable fragment processing pipeline also includes a second clipping unit configured to clip and optionally clamp a pixel associated with the final pixel depth value.","An embodiment of the present invention includes a method of calculating a pixel depth value comprising selecting inputs for a depth calculation from a plurality of sources, computing a calculated pixel depth value, and writing the calculated pixel depth value to a local register file, where the selecting, computing, and writing are performed under control of a pixel program. The calculated pixel depth value is associated with a geometry primitive pixel and independent of the coordinates of the geometry primitive. Additionally, the method can use a computing system including a programmable fragment processing pipeline to calculate the pixel depth value.","Furthermore, the method can include calculation of a first interpolated pixel depth value that is associated with a geometry primitive pixel and dependent on the coordinates of the geometry primitive. The method can include selection, under control of the pixel program, between the first interpolated pixel depth value and calculated pixel depth value, generating a final pixel depth value. The method can further include computing, under control of the pixel program, a second interpolated pixel depth value that is the same as the first interpolated pixel depth value. The plurality of sources includes a graphics memory, a host memory, and an other programmable computation unit in the programmable fragment processing pipeline.","Still further, the method can include clipping and optionally clamping a pixel associated with the interpolated pixel depth value. Yet further, the method can include clipping and optionally clamping a pixel associated with the final pixel depth value.","The current invention involves new systems and methods for processing and generating depth values in a programmable shader pipeline. These systems and methods satisfy the need for a graphics system that can generate the calculated depth values and the interpolated depth values, clip pixels using either the calculated depth values or interpolated depth values, and select between interpolated depth values and calculated depth values to determine final depth values for depth testing.",{"@attributes":{"id":"P-00025","num":"00025"},"figref":"FIG. 2","b":["200","110","210","200","110","114","112","112","115","115","112","110","210","115","217","217","230","240","220","220"]},"A Graphics Processing Pipeline  includes, among other components, Geometry Processor  and a Fragment Processing Pipeline  that each contain one or more programmable graphics processing units to perform a variety of specialized functions. Some of these functions are table lookup, scalar and vector addition, multiplication, division, coordinate-system mapping, calculation of vector normals, tessellation, calculation of derivatives, interpolation, and the like. Geometry Processor  and Fragment Processing Pipeline  are optionally configured such that data processing operations are performed in multiple passes through Graphics Processing Pipeline  or in multiple passes through Fragment Processing Pipeline . Shader programs and pixel programs are sequences of program instructions compiled for execution within Fragment Processing Pipeline . Data generated under control of a program in one pass and written to Local Memory  or Host Memory , e.g., a texture map, can be accessed in a subsequent pass. Alternatively, the data written to Local Memory  or Host Memory  can be optionally processed and used as indices to access map data, such as a texture map, stored in Local Memory  or Host Memory . Furthermore, a Shader , within Fragment Processing Pipeline , is optionally configured using the pixel programs such that data processing operations are performed in multiple passes within Shader . It should be understood that the program instructions and data can be read from or written to memory, e.g., any combination of Local Memory  and Host Memory .","Geometry Processor  receives a stream of program instructions and data and performs vector floating-point operations or other processing operations. Processed data is passed from Geometry Processor  to a Rasterizer . In a typical implementation Rasterizer  performs scan conversion and outputs fragment, pixel, or sample data and program instructions to Fragment Processing Pipeline . For simplicity, the remainder of this description will use the term pixels to refer to pixels, samples and\/or fragments.","Data processed by Shader  is passed to a Raster Analyzer , which performs operations similar to prior art Raster Operation Unit  and saves the results in Local Memory  or a Host Memory . Raster Analyzer  includes a read interface and a write interface to Memory Controller  through which Raster Analyzer  accesses data, including pixel depth values, stored in Local Memory  or Host Memory .","When processing is completed, an Output  of Graphics Subsystem  is provided using an Output Controller . Output Controller  is optionally configured to deliver data to a display device, network, electronic control system, other Computing System , other Graphics Subsystem , or the like.",{"@attributes":{"id":"P-00030","num":"00030"},"figref":"FIG. 3","b":["260","255","265","255","265","240","260"]},"A Shader Triangle Unit  calculates the plane equations for texture coordinates, depth, and other parameters. A Gate Keeper  performs a multiplexing function, selecting between the pipeline data from Rasterizer  and Shader Triangle Unit  and a Feedback Output  of a Combiners . Shader Core  initiates Local Memory  read requests via Texture  that are processed by Memory Controller  to read data, such as map data (e.g., height field, bump, texture, etc.) and program instructions. Shader Core  also performs floating point computations such as triangle parameter interpolation and reciprocals and is optionally programmed to compute the interpolated pixel depth values. Pixel data processed by Shader Core  is optionally input to a Core Back End FIFO (first in first out) . Even when interpolated pixel depth values are computed in Shader Core , interpolated pixel depth values are not necessarily output to Core Back End FIFO . Instead plane equation data needed to compute interpolated pixel depth values is output to Core Back End FIFO  and interpolated pixel depth values are recomputed by a Shader Back End , as described further herein, because plane equation data requires fewer pipeline storage resources than interpolated pixel depth values. Futhermore, in an alternate embodiment Core Back End FIFO  is implemented as a register file that is written by Shader Core  and read by Shader Back End .","Data read by Shader Core  via Memory Controller  is returned to a Texture . Texture  unpacks the read data and outputs unpacked data to a Remap . Remap  interprets any program instructions included in the unpacked data and generates codewords which control the processing completed by the graphics processing units in Fragment Processing Pipeline . When multi-pass operations are being performed within Shader , Remap  also reads the data fed back from Combiners  via a Quad Loop Back , synchronizing the fed back data with the unpacked data received from Texture , as explained more fully herein. Remap  formats the unpacked data and fed back data, outputting codewords and formatted data to Shader Back End .","Shader Back End  also receives pixel component data from Shader Core  via Core Back End FIFO  and triangle data, such as plane equations, from Gate Keeper . Shader Back End  synchronizes pixel component data and triangle data with formatted data from Remap . Shader Back End  performs computations using the input data (formatted data, pixel component data and triangle data) based on codewords received from Remap . Specifically, Shader Back End  computes interpolated pixel depth values using plane equation data from Shader Triangle Unit  via Gate Keeper  and pixel component data written to Core Back End FIFO  by Shader Core . Those computed interpolated pixel depth values computed in Shader Back End  are the same, pixel for pixel, as interpolated pixel depth values optionally computed in Shader Core . Therefore, pipeline storage resources required to pass interpolated pixel depth values from Shader Core  to Shader Back End  are not needed and the interpolated pixel depth values are as accurate as those computed in Shader Core . In Shader Back End , interpolated pixel depth values are used to clip the pixel values associated with each interpolated depth value. The clipped pixel values are optionally clamped to valid x and y coordinates to avoid discarding a partially clipped pixel that is slightly outside of the clip space due to the precision of the interpolation computation. Shader Back End  optionally computes calculated pixel depth values using formatted data containing read map data and\/or read fed back data. Finally, Shader Back End  uses a multiplexor to select between interpolated pixel depth values and calculated pixel depth values, choosing final pixel depth values for output as part of a stream also including codewords and shaded pixel data.","The output of Shader Back End  is input to Combiners  where codewords are executed by the programmable combiner computation units within Combiners . Combiners  are typically used to perform arithmetic computations using two or more inputs received from Shader Back End  to generate combined pixel data. Arithmetic computations include dot products, multiplication, and addition, among others. The codewords executing in the current pass control whether the combined pixel data will be fed back within Shader , using one or both of the paths, to be processed in a subsequent pass. Using a first path, Combiners  optionally output codewords, to be executed by Shader Core  and Texture  in a subsequent pass, to Gate Keeper  using feedback path . Using a second path, Combiners  also optionally output combined pixel data to local register file Quad Loop Back , to be read by Remap  in a subsequent pass. Finally, Combiners  optionally output combined pixel data, e.g., x, y, color, depth, other parameters, to Raster Analyzer . Raster Analyzer  performs near and far plane clipping and raster operations, such as stencil, z test, etc., using the combined pixel data and pixel data stored in Local Memory  or Host Memory  at the x,y location associated with the combined pixel data. The output data from Raster Analyzer  is written back to Local Memory  or Host Memory  via Memory Controller  at the x,y locations associated with the output data. The output data is represented in one or more formats as specified by the codewords. For example, color data is written as 16 or 32 bit per pixel ARGB to be scanned out for display or used as a texture map by a pixel program executed in a subsequent pass within Fragment Processing Pipeline  or through Graphics Processing Pipeline . Alternatively, color and depth data is written, and later read and processed by Raster Analyzer  to generate output data prior to being scanned out for display via Output Controller .",{"@attributes":{"id":"P-00035","num":"00035"},"figref":"FIG. 4","b":["255","265","255","265","5"]},{"@attributes":{"id":"P-00036","num":"00036"},"figref":"FIG. 5","b":["255","240","220"]},"In step , Gate Keeper  receives pixel data, triangle data, and codewords from Rasterizer  and Shader Triangle Unit . Gate Keeper  stores triangle data, including depth plane equation data, in Triangle Memory  and outputs pixel data and codewords to Shader Core  via Multiplexor . In step , Shader Core  configures the Programmable Computation Unit (PCU), PCU, according to the codewords, to generate pixel output data based on data received from Gate Keeper . Per pixel interpolated depth values are optionally computed using PCU to evaluate plane equations. In an alternate embodiment one or more additional PCUs are included in Shader Core  such that pixel texture coordinates, pixel parameter values, per pixel interpolated depth values, and the like, are computed in parallel. PCU includes arithmetic subunits, logic for selection of inputs to the arithmetic subunits, and interface logic to write register files or FIFOs. The interface logic generates the write address and write control signals based on the protocol required by a register file or FIFO.","In step , Shader Core  writes per pixel components to Core Back End FIFO . Data stored in Core Back End FIFO  is used as source data in the current pass through Shader  or alternatively, in a subsequent pass. Per pixel interpolated depth values computed by PCU are effectively discarded because per pixel interpolated depth values are not written to Core Back End FIFO . In step , Shader Core  uses the codewords to determine whether map data or program instructions to be executed at a later time are required to be read from Local Memory . The codewords are passed from Shader Core  through Texture  to Remap . If the program instructions are required to be read from Local Memory , in step , Shader Core  calculates the read addresses in Address Generator  and outputs a read request to Memory Controller . In step , read program instructions return to Texture  and are unpacked. In step , Remap  receives and processes the unpacked program instructions, generates codewords, and determines whether source data is required to be read from Quad Loop Back , and, if not, in step , Remap  outputs codewords to Shader Back End . In this example, in step , codewords received by Shader Back End  configure programmable computation unit, PCU, to be idle rather than perform a computation because there is no source input data for PCU to process. Then, in step  Shader Back End  uses the codewords to determine whether this is the last pass of the data through Shader  and, if so, in step , Shader Back End  reads per pixel components from Core Back End FIFO  and depth plane equation data from Triangle Memory  to compute interpolated pixel depth values using a Depth Processing Unit (DPU) . Interpolated pixel depth values are used by a Clip  to clip pixels using near and far clipping planes. Clipped pixel values are optionally clamped to valid x and y coordinates to avoid discarding a partially clipped pixel that is slightly outside of the clip space due to the precision of the interpolation computation. Similar to the PCU, DPU  functionality is not limited to interpolation computations.","In step , Shader Back End  determines if \u201cdepth replace\u201d is enabled according to the codewords and, if not, in step , Multiplexor  selects DPU  computed interpolated and clipped pixel depth values as final pixel depth values that are output from Shader Back End . In an alternate embodiment the selection function is performed using combinatorial logic, a lookup table, or the like. In step , Combiners  uses the codewords to determine whether this is the last pass of the data through Shader  and, if so, in step , Combiners  input final pixel depth values into a Depth FIFO  that are later output to Raster Analyzer . In step , Raster Analyzer  receives final pixel depth values from Combiners  and performs near and far plane clipping with optional clamping. Raster Analyzer  optionally reads, via Memory Controller , pixel depth values stored in Local Memory  corresponding to pixel (x, y) locations for final pixel depth values. Raster Analyzer  optionally performs a depth test function using read pixel depth values and final pixel depth values as specified by the codewords and generates a pass or fail result. If the depth test passes, final depth is written back to Local Memory  via Memory Controller . If the depth test fails the final depth is discarded. In this example, final depth is clipped interpolated pixel depth.","In Example 2, a calculated depth value is computed and used as final pixel depth in Shader  by following the sequence of steps described below. Source data used to calculate pixel depth values is stored in Local Memory  as a map and is accessed using u and v indices associated with specific geometric locations. In this example, the map data is an array of depth values that are processed in the same manner as texture map data is processed, e.g., trilinearly interpolated. The map data is independent of the vertex coordinates x, y, and z. Therefore, unlike final pixel depth values in Example 1, final pixel depth values in Example 2 are independent of the coordinates of the geometry primitive.","In step , Gate Keeper  receives pixel data, triangle data, and codewords from Rasterizer  and Shader Triangle Unit . Gate Keeper  stores triangle data, including depth plane equation data, in Triangle Memory  and outputs pixel data and codewords to Shader Core  via Multiplexor . In step , Shader Core  configures PCU according to the codewords to generate pixel output data based on data received from Gate Keeper . Per pixel interpolated depth values are optionally computed using PCU to evaluate plane equations. In step , Shader Core  writes per pixel components to Core Back End FIFO .","In step , Shader Core  uses the codewords to determine whether map data or program instructions to be executed at a later time are required to be read from local memory. The codewords are passed from Shader Core  through Texture  to Remap . If map data or program instructions to be executed at a later time are required to be read from Local Memory , in step , Shader Core  calculates read addresses in Address Generator  and outputs read requests to Memory Controller  via Texture . In step , read depth map data values and read program instructions return to Texture  and are unpacked. In step , Remap  receives and processes the unpacked program instructions, generates codewords, and determines whether source data is required to be read from Quad Loop Back . If the source data stored in Quad Loop Back  is not required to be read, in step  Remap  format converts unpacked depth map data received from Texture  and outputs format converted depth data and codewords to Shader Back End . In step , codewords received by Shader Back End  configure PCU to perform trilinear interpolation using the format converted depth data. In step , Shader Back End  uses the codewords to determine whether this is the last pass of the data through Shader , and, if so, in Step  Shader Back End  reads per pixel components from Core Back End FIFO  and triangle data from Triangle Memory  and computes interpolated pixel depth values using DPU . Interpolated pixel depth values are used by Clip  to clip pixels using near and far clipping planes and optionally clamp clipped pixel values to avoid discarding a partially clipped pixel.","In step , Shader Back End  determines if \u201cdepth replace\u201d is enabled according to the codewords and, if so, in step  Multiplexor  selects PCU trilinearly interpolated pixel depth values as final pixel depth values to be output from Shader Back End  to Combiners . In step , Combiners  uses the codewords to determine whether this is the last pass of the data through Shader  and, if so, in step  Combiners  input final pixel depth values into a Depth FIFO  that are later output to Raster Analyzer . In step , Raster Analyzer  receives final pixel depth values from Combiners  and performs near and far plane clipping with optional clamping. Raster Analyzer  optionally reads pixel depth values stored in Local Memory  corresponding to pixel (x, y) locations for final pixel depth values. Raster Analyzer  optionally performs a depth test function using read pixel depth values and final pixel depth values as specified by the codewords and generates a pass or fail result. If the depth test passes, final depth is written back to Local Memory  via Memory Controller . If the depth test fails the final depth is discarded. In this example, final depth is PCU calculated pixel depth that was generated independent from the corresponding interpolated depth value computed using the coordinates of the geometry primitive.","In Example 3, two calculated pixel depth values are computed and combined to output a new depth value in Shader  by following the sequence of steps described below. As a result of the independent paths and programmable configuration of Shader , programming Shader  in the configuration in this combination permits displacements read from a map stored in Local Memory  to be applied to interpolated pixel depth values calculated in Shader Core .","In step , Gate Keeper  receives pixel data, triangle data, and codewords from Rasterizer  and Shader Triangle Unit . Gate Keeper  stores triangle data, including depth plane equation data, in Triangle Memory  and outputs pixel data and codewords to Shader Core . In step , Shader Core  configures PCU according to the codewords to generate pixel output data based on data received from Gate Keeper . Per pixel interpolated depth values are optionally computed using PCU to evaluate plane equations. In step , Shader Core  writes per pixel interpolated depth values to Core Back End FIFO  to be used as source data in the current pass through Shader .","In step , Shader Core  uses codewords to determine whether map data or program instructions to be executed at a later time are required to be read from Local Memory . The codewords are passed from Shader Core  through Texture  to Remap . If the map data or program instructions to be executed at a later time are required to be read from Local Memory , in step  Shader Core  calculates the read addresses in Address Generator  and outputs read requests to Memory Controller . In step , read depth map data values and read program instructions return to Texture  and are unpacked. In step , Remap  receives and processes the unpacked program instructions, generates codewords, and determines whether source data is required to be read from Quad Loop Back . If the source data stored in Quad Loop Back  is not required to be read, in step  Remap  format converts unpacked depth map data received from Texture . The format converted depth data and codewords are output by Remap  to Shader Back End . In step , Shader Back End  configures PCU according to the codewords to perform a computation. Interpolated pixel depth values calculated using PCU in Shader Core  and stored in Core Back End FIFO  are also input to Shader Back End  and both depth values are processed by PCU. In this example, PCU is configured to use format converted depth values as displacements and modify interpolated pixel depth values to compute displaced pixel depth values. Alternatively, PCU computed interpolated pixel depth values are combined with format converted depth values using PCU.","In step , Shader Back End  uses the codewords to determine whether this is the last pass of the data through Shader , and, if so, in Step  Shader Back End  reads per pixel components from Core Back End FIFO  and triangle data from Triangle Memory  and computes interpolated pixel depth values using DPU . Interpolated pixel depth values are used by Clip  to clip pixels using near and far clipping planes and optionally clamp clipped pixel values to avoid discarding a partially clipped pixel.","In step , Shader Back End  determines if \u201cdepth replace\u201d is enabled according to the codewords and, if so, in step  Multiplexor  selects PCU calculated displaced pixel depth values as final pixel depth values to be output from Shader Back End  to Combiners . In step , Combiners  uses the codewords to determine whether this is the last pass of the data through Shader  and, if so, in step  Combiners  input final pixel depth values into Depth FIFO  that are later output to Raster Analyzer . In step , Raster Analyzer  receives final pixel depth values from Combiners  and performs near and far plane clipping with optional clamping. Raster Analyzer  optionally reads pixel depth values stored in Local Memory  corresponding to the pixel (x, y) locations for final pixel depth values. Raster Analyzer  optionally performs a depth test function using read pixel depth values and final pixel depth values as specified by the codewords and generates a pass or fail result. If the depth test passes, final depth is written back to Local Memory via Memory Controller. If the depth test fails the final depth is discarded. In this example, final depth is displaced depth that was generated using interpolated pixel depth values computed from the coordinates of the geometry primitive and map data representing depth displacements.","In Example 4 pixel depth values are computed in two passes through Shader  to output a new pixel depth value following the sequence of steps described below. Programming Shader  in the configuration in this combination permits values computed during a first pass to be used to calculate depth values in Shader Back End  during a second pass. In this example, depth displacements are computed during the first pass and the displacements are applied to interpolated pixel depth values during the second pass.","In step , Gate Keeper  receives pixel data, triangle data, and codewords from Rasterizer  and Shader Triangle Unit . Gate Keeper  stores triangle data, including depth plane equation data, in Triangle Memory  and outputs pixel data and codewords to Shader Core . In step , Shader Core  configures PCU according to codewords and computes depth displacements based on data received from Gate Keeper . In step , Shader Core  writes per pixel depth displacements to Core Back End FIFO  to be used as source data in the second pass through Shader .","In step , Shader Core  uses codewords to determine whether map data or program instructions to be executed at a later time are required to be read from Local Memory . The codewords are passed from Shader Core  through Texture  to Remap . If the map data or program instructions to be executed at a later time are not required to be read from Local Memory , in step  Remap  determines whether source data is required to be read from Quad Loop Back . If the map source data is not required to be read from Quad Loop Back  Remap  outputs codewords to Shader Back End . In step , Shader Back End  configures PCU according to codewords to pass the data input to PCU through to the output of PCU. In this example per pixel depth displacements calculated using PCU in Shader Core  and stored in Core Back End FIFO  are passed through PCU. Alternatively, PCU is configured to compute modified pixel depth displacements using source inputs such as read map data or pixel components read from Core Back End FIFO .","In step , Shader Back End  uses the codewords to determine whether this is the last pass of the data through Shader  and, if not, in step  Shader Back End  determines if \u201cdepth replace\u201d is enabled according to the codewords. If \u201cdepth replace\u201d is enabled, in step  Multiplexor  selects PCU calculated data and outputs it to Combiners . In step , Combiners  uses the codewords to determine whether this is the last pass of the data through Shader , and, if not, in step  Combiners input PCU processed data output from Shader Back End  into combiner computation unit, CCU , and feeds the output of CCU  into Gate Keeper . Codewords generated from program instructions and data that were each optionally read from Local Memory  are output by Combiners  to Gatekeeper .","Example 4 continues with step , where Gate Keeper  receives CCU  processed data and synchronizes it with pixel data from Rasterizer  and triangle data from Shader Triangle Unit  using Multiplexor  to output data received from each source as directed by codewords. In step , Shader Core  configures PCU according to codewords and computes interpolated pixel depth values based on data received from Gate Keeper . In step , Shader Core  writes per pixel interpolated depth values to Core Back End FIFO  to be used as source data in the current pass through Shader .","In step , Shader Core  uses codewords to determine whether map data or program instructions to be executed at a later time are required to be read from Local Memory . The codewords are passed from Shader Core  through Texture  to Remap . If the map data or program instructions to be executed at a later time are not required to be read from Local Memory , in step  Remap  determines whether source data is required to be read from Quad Loop Back . If the source data stored in Quad Loop Back  is required to be read, in step  Remap  generates a read request for Quad Loop Back . In step , depth displacements calculated during the first pass are received from Quad Loop Back  by Remap  and in step  Remap  format converts depth displacements. The format converted depth displacements and codewords are output by Remap  to Shader Back End . In step , Shader Back End  configures PCU according to codewords to perform a computation. Interpolated pixel depth values calculated using PCU in Shader Core  and stored in Core Back End FIFO  are also input to Shader Back End  and depth displacements are applied to interpolated pixel depth values using PCU.","In step , Shader Back End  uses the codewords to determine whether this is the last pass of the data through Shader  and, if so, in Step  Shader Back End  reads per pixel components from Core Back End FIFO  and triangle data from Triangle Memory  and computes interpolated pixel depth values using DPU . Interpolated pixel depth values are used by Clip  to clip pixels using near and far clipping planes and optionally clamp clipped pixel values to avoid discarding a partially clipped pixel. In step , Shader Back End  determines if \u201cdepth replace\u201d is enabled according to the codewords and, if so, in step  Multiplexor  selects PCU calculated displaced pixel depth values as final pixel depth values to be output from Shader Back End  to Combiners . In step , Combiners  uses the codewords to determine whether this is the last pass of the data through Shader  and, if so, in step  Combiners  input final pixel depth values into Depth FIFO  that are later output to Raster Analyzer . In step , Raster Analyzer  receives final pixel depth values from Combiners  and performs near and far plane clipping with optional clamping. Raster Analyzer  optionally reads pixel depth values stored in Local Memory  corresponding the pixel (x, y) locations for final pixel depth values. Raster Analyzer  optionally performs a depth test function using read pixel depth values and final pixel depth values as specified by the codewords and generates a pass or fail result. If the depth test passes, final depth is written back to Local Memory via Memory Controller. If the depth test fails the final depth is discarded. In this example, final depth is displaced pixel depth values calculated in two passes where pixel depth displacements are computed during a first pass and interpolated pixel depth values are computed in a second pass from the coordinates of the geometry primitive and combined with pixel depth displacements.","In Example 5, depth values are computed in three passes to output a new depth value in Shader by following the sequence of steps described below. Programming Shader  in the configuration detailed in this example results in Shader  first calculating normal vectors for each pixel that are used in a second pass to displace interpolated pixel depth values. In the third pass u, v coordinates are interpolated and used to read data stored in Local Memory , e.g., depth displacements. The read map depth displacements are combined with calculated normal vector displaced depth during the third and final pass.","In step , Gate Keeper  receives pixel data, triangle data, and codewords from Rasterizer  and Shader Triangle Unit . Gate Keeper  stores triangle data in Triangle Memory  and outputs pixel data and codewords to Shader Core . In step , Shader Core  configures PCU according to the codewords and computes interpolated normal vectors based on data received from Gate Keeper . In step , Shader Core  writes per pixel normal vectors to Core Back End FIFO  to be used as source data in the second pass through Shader .","In step , Shader Core  uses the codewords to determine whether map data or program instructions to be executed at a later time are required to be read from Local Memory . The codewords are passed from Shader Core  through Texture  to Remap . If the program instructions are required to be read from Local Memory , in step  Shader Core  calculates the read addresses in Address Generator  and outputs a read request to Memory Controller . In step , read program instructions return to Texture  and are unpacked. In step , Remap  receives and processes the unpacked program instructions, generates codewords, and determines whether source data is required to be read from Quad Loop Back  and, if not, in step  Remap  outputs codewords to Shader Back End . In step , Shader Back End  configures PCU according to codewords to pass the data input to PCU through to the output of PCU. In this example, per pixel normal vectors computed using PCU in Shader Core  and stored in Core Back End FIFO  are passed through PCU. Alternatively, PCU is configured to compute modified normal vectors using source inputs such as read map data or pixel components read from Core Back End FIFO .","In step , Shader Back End  uses the codewords to determine whether this is the last pass of the data through Shader  and, if not, in step  Shader Back End  determines if \u201cdepth replace\u201d is enabled according to the codewords. If \u201cdepth replace\u201d is enabled, in step  Multiplexor  selects PCU calculated data and outputs it to Combiners . In step , Combiners  uses the codewords to determine whether this is the last pass of the data through Shader  and, if not, in step  Combiners inputs PCU processed data output from Shader Back End  into CCU  and feeds the output of CCU  into Gate Keeper . Codewords generated from program instructions are output by Combiners  to Gatekeeper . CCU  processed data, e.g., per pixel normal vectors, are written to Quad Loop Back  to be used during the second pass.","Example 5 continues with step  for a second pass, when Gate Keeper  receives and synchronizes the codewords received from Combiners  with pixel data from Rasterizer  and triangle data from Shader Triangle Unit  using Multiplexor  to output data received from each source as directed by codewords. In step , Shader Core  configures PCU according to the codewords and computes interpolated pixel depth values based on data received by Gate Keeper  from Rasterizer  and Shader Triangle Unit . In step , Shader Core  writes per pixel interpolated depth values to Core Back End FIFO  to be used as source data in the current pass through Shader .","In step , Shader Core  uses codewords to determine whether map data or program instructions to be executed at a later time are required to be read from Local Memory . The codewords are passed from Shader Core  through Texture  to Remap . If the map data or program instructions to be executed at a later time are not required to be read from Local Memory , in step  Remap  determines whether source data is required to be read from Quad Loop Back . If the source data stored in Quad Loop Back  is required to be read, in step  Remap  generates a read request for Quad Loop Back . In step , pixel normal vectors calculated during the first pass are received from Quad Loop Back  by Remap  and in step  Remap  format converts pixel normal vectors. The format converted pixel normal vectors are output by Remap  to Shader Back End . In step , Shader Back End  configures PCU according to the codewords to perform a computation. Interpolated pixel depth values calculated using PCU in Shader Core  and stored in Core Back End FIFO  are also input to Shader Back End  and PCU is configured to use format converted pixel normal vectors to displace interpolated pixel depth values.","In step , Shader Back End  uses the codewords to determine whether this is the last pass of the data through Shader  and, if not, in step  Shader Back End  determines if \u201cdepth replace\u201d is enabled according to the codewords. If \u201cdepth replace\u201d is enabled, in step  Multiplexor  selects PCU calculated normal vector displace interpolated pixel depth values to be output to Combiners  before proceeding to step . In step , Combiners  uses the codewords to determine whether this is the last pass of the data through Shader  and, if not, in step  Combiners inputs PCU calculated normal vector displaced interpolated pixel depth values output from Shader Back End  into CCU  and feeds the output of CCU  into Gate Keeper . Codewords generated from program instructions are output by Combiners  to Gatekeeper . CCU  processed data, e.g., calculated normal vector displace interpolated pixel depth values, are written to Quad Loop Back  to be used during the third pass.","Example 5 continues with step  for a third pass, when Gate Keeper  receives and synchronizes the codewords received from Combiners  with pixel data from Rasterizer  and triangle data from Shader Triangle Unit  using Multiplexor  to output data received from each source as directed by codewords. In step , Shader Core  configures PCU according to the codewords and computes interpolated map indices based on data received by Gate Keeper  from Rasterizer  and Shader Triangle Unit . In step , Shader Core  writes per pixel component data to Core Back End FIFO  to be used as source data in the current pass through Shader .","In step , Shader Core  uses the codewords to determine whether map data or program instructions to be executed at a later time are required to be read from local memory. The codewords are passed from Shader Core  through Texture  to Remap . If the map data or program instructions to be executed at a later time are required to be read from Local Memory , in step  Shader Core  calculates the read addresses in Address Generator  and outputs read requests to Memory Controller . In step , read depth map data values and read program instructions return to Texture  and are unpacked. In step , Remap  receives and processes the unpacked program instructions and in step  determines whether source data are required to be read from Quad Loop Back . If the source data stored in Quad Loop Back  is required to be read, in step  Remap  generates a read request for Quad Loop Back . In step , normal vector displaced interpolated pixel depth values, calculated during the second pass, are received from Quad Loop Back  by Remap . In step , Remap  format converts read depth displacements and displaced interpolated pixel depth values that were calculated during the second pass. Remap  outputs codewords, format converted read depth displacements, and format converted displaced interpolated pixel depth values. In step , PCU is configured to use format converted read depth displacements to further displace format converted displaced interpolated pixel depth values and generate displaced pixel depth values.","In step , Shader Back End  uses the codewords to determine whether this is the last pass of the data through Shader  and, if so, in Step  Shader Back End  reads per pixel components from Core Back End FIFO  and triangle data from Triangle Memory  and computes interpolated pixel depth values using DPU . Interpolated pixel depth values are used by Clip  to clip pixels using near and far clipping planes and optionally clamp clipped pixel values to avoid discarding a partially clipped pixel.","In step , Shader Back End  determines if \u201cdepth replace\u201d is enabled according to the codewords and, if so, in step  Multiplexor  selects PCU calculated displaced pixel depth values as final pixel depth values to be output from Shader Back End  to Combiners . In step , Combiners  uses the codewords to determine whether this is the last pass of the data through Shader  and, if so, in step  Combiners  input final pixel depth values into Depth FIFO  that are later output to Raster Analyzer . In step , Raster Analyzer  receives final pixel depth values from Combiners  and performs near and far plane clipping with optional clamping. Raster Analyzer  optionally reads pixel depth values stored in Local Memory  corresponding the pixel (x, y) locations for final pixel depth values. Raster Analyzer  optionally performs a depth test function using read pixel depth values and final pixel depth values as specified by the codewords and generates a pass or fail result. If the depth test passes, final depth is written back to Local Memory via Memory Controller. If the depth test fails the final depth is discarded. In this example, final depth is displaced pixel depth that was generated using interpolated pixel depth values computed from the coordinates of the geometry primitive displaced by normal vectors and map data representing depth displacements.","In an alternate embodiment, final pixel depth values are calculated using pixel programs that instruct Shader  to process the data in more than three passes. In the preceeding examples several sources are input to PCU and PCU to generate final pixel depth, including, but not limited to interpolated pixel depth, data processed by the Programmable Computation Units in the pipeline (such as pixel normal vectors), data read from Local Memory , data read from or Host Memory , data processed by DPU  in the pipeline, data stored in Core Back End FIFO , and data stored in Quad Loop Back . Furthermore, depth values include interpolated pixel depth, indices used to read pixel depth, indices used to read vertex depth, and depth components, e.g., derivatives, differences, normal vectors, etc.","The invention has been described above with reference to specific embodiments. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The listing of steps in method claims do not imply performing the steps in any particular order, unless explicitly stated in the claim. Within the claims, element lettering (e.g., \u201ca)\u201d, \u201cb)\u201d, \u201ci)\u201d, \u201cii)\u201d, etc.) does not indicate my specific order for carrying out steps or other operations; the lettering is included to simplify referring to those elements."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE VARIOUS VIEWS OF THE DRAWINGS","p":["Accompanying drawing(s) show exemplary embodiment(s) in accordance with one or more aspects of the present invention; however, the accompanying drawing(s) should not be taken to limit the present invention to the embodiment(s) shown, but are for explanation and understanding only.",{"@attributes":{"id":"P-00019","num":"00019"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00020","num":"00020"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00021","num":"00021"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"P-00022","num":"00022"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"P-00023","num":"00023"},"figref":"FIG. 5","b":"4"}]},"DETDESC":[{},{}]}
