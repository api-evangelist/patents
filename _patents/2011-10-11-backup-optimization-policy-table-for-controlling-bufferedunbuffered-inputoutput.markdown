---
title: Backup optimization policy table for controlling buffered/un-buffered input/output
abstract: A device includes a data collector module, a policy module, and an optimizer module. The data collector module is to collect values for a plurality of device parameters. The policy module is to receive the values for the plurality of device parameters and update a policy table. The optimizer module is to receive the policy table from the policy module, determine, based on the policy table, whether to proceed with buffered input/output or un-buffered input/output for a read call, and instruct a read module of a backup application to proceed with either buffered input/output or un-buffered input/output for the read call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08578111&OS=08578111&RS=08578111
owner: Hewlett-Packard Development Company, L.P.
number: 08578111
owner_city: Houston
owner_country: US
publication_date: 20111011
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Modern computer systems are used to store, process, and communicate vast amounts of valuable information. The information is stored either locally or in a distributed manner, and is often backed up periodically or continuously to provide protection in the event of, e.g., a power outage, a virus, a natural disaster, or another event that temporarily or permanently disrupts the computer system and\/or the associated network.","Backup processes are typically conducted by a backup application. The backup application makes periodic copies of data which may be used to restore original data in the event of a data loss. The amount of time to conduct a backup process is generally dependent on a number of factors, including the type of backup process (e.g., online backup, raw data backup, file system backup, snapshot backup, etc.), the type of input\/output (I\/O) (e.g., buffered I\/O or un-buffered I\/O), system properties (e.g., speed, memory size, etc.) and\/or the amount of data to be processed.","Disclosed are embodiments for optimizing a backup process. More specifically, disclosed are embodiments for dynamically deciding between buffered I\/O and un-buffered I\/O based on detected system conditions. These embodiments allow for optimum I\/O performance by overcoming inefficiencies caused by system designers making static decisions between buffered I\/O and un-buffered I\/O at the system design phase. That is, the present techniques may reduce poor performance caused by fixed decisions to use buffered I\/O in all instances, even though un-buffered I\/O may provide better performance under some conditions. Similarly, the present techniques may reduce poor performance caused by fixed decisions to use un-buffered I\/O in all instances, even though buffered I\/O may provide better performance under certain conditions. Embodiments implement a real-time or on-the-fly decision making ability to take advantage of buffered I\/O or un-buffered I\/O when such an I\/O technique would be optimum for a given instance based on detected system conditions. As described in further detail below, embodiments may utilize a novel and unforeseen performance optimization tool comprising a data collector module, a policy module, and an optimizer module to collaborate with a reader module of a backup application to effectuate this optimization.","In one embodiment, a method for backup optimization is provided. The method may comprise collecting, by a data collector module of a host device, values for a plurality of device parameters. A policy module may receive these values from the data collector module and update a policy table with the values for the plurality of device parameters. An optimizer module may then receive the policy table and determine whether to proceed with buffered input\/output or un-buffered input\/output for a read call based at least in part on the policy table. The optimizer module may then instruct a read module of a backup application to proceed with either buffered input\/output or un-buffered input\/output for the read call.","In another embodiment, a system is provided. The system may comprise one or more memories and one or more processors communicatively coupled to the one or more memories. The one or more memories may store instructions that when executed by the one or more processors implement operations comprising collecting values for a plurality of device parameters; receiving the values for the plurality of device parameters and updating a policy table; determining, based on the policy table, whether to proceed with buffered input\/output or un-buffered input\/output for a read call; and providing instructions to proceed with either buffered input\/output or un-buffered input\/output for the read call.","In a further embodiment, a processor-readable storage medium having processor-executable instructions stored thereon is provided. The processor-executable instructions, when executed, may cause a processor conduct to: collect values for a plurality of device parameters; update a policy table with the values for the plurality of device parameters; determine, based at least in part on the policy table, whether to proceed with buffered input\/output or un-buffered input\/output for a read call; and send an instruction to proceed with either buffered input\/output or un-buffered input\/output for the read call.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":["100","100","110","120","130"]},"The client device  may be, for example, a file server (e.g., a dedicated file server, a non-dedicated file server, a file transfer protocol (FTP) server, a hypertext transfer protocol (HTTP) server, etc.), a database server (e.g., an Oracle database, an IBM DB2 server, an IBM Informix database, an Ingres database, a SQL server, etc.), a virtual server\/environment (e.g., VMware, Windows 2008 Hyper-V, Microsoft Virtual Server 2005, Citrix XenServer, HP Integrity Virtual Machines, etc.), a secondary memory, or another type of device (e.g., notebook, desktop, tablet, storage device, etc.). Information stored on client device  may be periodically or continuously backed up to storage device  via a backup application  and a performance optimization application  stored\/running on the host device .","The host device  may be a server. For example, the host device  may be a media server, an administration server, a cell manager, and\/or an application server. In embodiments, the host device  may comprise a performance optimization application  which includes a data collector module , a policy module , and an optimizer module . The host device  may further comprise a backup application  which includes, among other things, a reader module . The backup application may be an application or manager running\/stored, at least in part, on the host device , and may protect the data and\/or system state of a device (e.g., client device ) by periodically or continuously storing the data on another device (e.g., storage device ). The reader module  of the backup application  may be the portion of the backup application responsible for reading data from the client device  as part of the backup process. In some embodiments, functionality of the host device  may be distributed across a plurality of devices.","The host device  may comprise an interface for interfacing with the client device  and for interfacing with storage device  via, e.g., a storage area network (SAN) interface, a network-attached storage (NAS) interface, a small computer system interface (SCSI), a serial advanced technology attachment interface (SATA) and\/or an integrated drive electronics (IDE) interface. The host device  may also communicate with the client device  and the storage device  via wired and\/or wireless communication mechanisms including, but not limited to, Ethernet, local area network (LAN), wide area network (WAN), coaxial network, and\/or fiber network.","The storage device  may include one or more of any type of storage device including, but not limited to, tape devices, disk arrays, optical storage, redundant array of independent disks (RAID) systems, and\/or just a bunch of disks (JBOD).","By way of example, the host device  may be configured to cause a snapshot image of the client device  to be taken. The host device  may then read the snapshot image from the client device  using operating system (OS) read calls. This reading process may involve a buffered I\/O process and\/or an un-buffered I\/O process. The data that is read via buffered I\/O and\/or un-buffered I\/O may be subsequently written to the storage device , and therefore a backup of the client device  at a particular point in time may be formed. In the event the client device  fails, recovery may be effectuated via this backup.","More particularly, in embodiments, the data collector module , the policy module , the optimizer module , and the reader module  of the host device  may cooperate to dynamically select between buffered I\/O and un-buffered I\/O based on detected system conditions (e.g., file system type, memory utilization, CPU utilization, number of cache misses, I\/O frequency, and I\/O buffer size). This may result in enhanced read performance when compared to conventional systems that have static I\/O settings (i.e., either buffered I\/O or un-buffered I\/O based on decisions at the system design phase of likely\/potential customer scenarios).","In the buffered I\/O process (also referred to as an asynchronous I\/O process), data from the client device  is buffered in a file system buffer cache (not shown) during the read process. Use of a file system buffer cache minimizes the frequency of client device  access by the host device . In particular, when the host device  attempts to read the snapshot image from the client device , the host device  first attempts to read the requested data from the file system buffer cache. If the requested data is not already present in the file buffer cache, the host device  then proceeds read the data from the client device  and cache it to the file system buffer cache. The buffered I\/O process can therefore be broken down into two categories: a file buffer cache hit and a file buffer cache miss.","In a file buffer cache hit, the host device  issues a read request. The requested data is found in the file buffer cache and the requested data is copied over to an application buffer on host device . In contrast, in a file buffer cache miss, the host device  issues a read request. The host device  looks for the requested data in the file buffer cache and determines that the requested data is not present in the file buffer cache. The host device  then proceeds to read the data from client device . The data from client device  is then cached in the file buffer cache and subsequently copied from the file buffer cache to the application buffer. File buffer cache misses, therefore, require more processes than file buffer cache hits in the buffered I\/O process.","By contrast, in the un-buffered I\/O process (also referred to as a synchronous I\/O or direct I\/O) a file buffer cache is not utilized, and data is transferred directly from the client device  to the application buffer. That is, the host device  issues a read request, the host device  initiates a client device  read, and the requested data is transferred from client device  to the application buffer.","Both buffered I\/O and un-buffered I\/O have advantages and disadvantages. For example, buffered I\/O may benefit applications by minimizing the frequency of disk accesses because of the file buffer cache. This may improve response time and throughput. However, the use of a file buffer cache in buffered I\/O results in overhead since data is first moved from the disk to the file buffer cache and from there to the application buffer. This \u201cdouble-copying\u201d of data results in additional CPU consumption. Also, large amounts of application data in the file buffer cache makes less memory available for the other applications. This results in additional system overhead (e.g., a large amount of page swaps) due to memory management. Moreover, some applications may manage data caching at the application level, so the application may not need the file system to implement this service.","Un-buffered I\/O may benefit applications by reducing CPU consumption and eliminating overhead of copying data twice\u2014first between the disk and the file buffer cache, and then from the file buffer cache to the application buffer. However, un-buffered I\/O read causes synchronous reads from disk, unlike the buffered I\/O policy where the reads may be satisfied from the file buffer cache. This may result in poor performance if the data is likely to be in the file buffer cache under the buffered I\/O policy. Un-buffered I\/O also bypasses file system read-ahead, which may provide significant performance boost for sequentially accessed files. When read-ahead is employed, the operating system may try to anticipate future need for pages of a sequential file by observing the pattern in which an application accesses the file. When the application accesses two successive pages of the file, the operating system may assume that the program will continue to access the file sequentially, and schedule additional sequential reads of the file. These reads are overlapped with application processing, and may make the data available to the application sooner than if the operating system waits for the program to access the next page before initiating the I\/O.","Below is a table summarizing example potential advantages, example potential disadvantages, and an example potential favorable environments for both buffered I\/O and un-buffered I\/O:",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Buffered I\/O","Un-Buffered I\/O"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["I\/O Process","Data from client device is","Data from client device"]},{"entry":[{},"buffered in the file buffer","is transferred directly"]},{"entry":[{},"cache before being","from client device to the"]},{"entry":[{},"transferred to the","application buffer."]},{"entry":[{},"application buffer."]},{"entry":["Potential","The operating system may","Data is transferred"]},{"entry":["Advantages","minimize the frequency of","directly from the client"]},{"entry":[{},"client device accesses by","device to the application"]},{"entry":[{},"buffering data in main","buffer, without the use"]},{"entry":[{},"memory, within a structure","of the file buffer cache."]},{"entry":[{},"called the file buffer cache.","This may reduce one"]},{"entry":[{},{},"extra read and write in"]},{"entry":[{},{},"the file system cache"]},{"entry":[{},{},"and result in less CPU"]},{"entry":[{},{},"consumption."]},{"entry":["Potential","Buffered I\/O has additional","Applications have to wait"]},{"entry":["Disadvantages","overhead because data is","for the read or write to"]},{"entry":[{},"first moved from the client","complete. Response time"]},{"entry":[{},"to the file buffer cache,","and throughput may be"]},{"entry":[{},"and from file buffer cache","poor due to slow disk"]},{"entry":[{},"to the application buffer.","access times."]},{"entry":[{},"This \u201cdouble copying\u201d of"]},{"entry":[{},"data may result in more"]},{"entry":[{},"CPU consumption and add"]},{"entry":[{},"overhead to the memory."]},{"entry":["Example","HFS file system type;","VxFS File system type;"]},{"entry":["Potential","low memory utilization;","high memory utilization;"]},{"entry":["Favorable","low CPU utilization;","high CPU utilization;"]},{"entry":["Environment","low cache misses; and\/or","high cache misses; and\/or"]},{"entry":[{},"small I\/O buffer size.","large I\/O buffer size."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"As discussed, in some instances, using a buffered I\/O may result in optimized performance. In other instances, however, using an un-buffered I\/O may result in optimized performance. The performance result is generally a function of a number of current system conditions\/parameters including, but not limited to, the file system type, the memory utilization, the CPU utilization, the number of cache misses over a time period, the I\/O buffer size, etc. Embodiments disclosed herein optimize system performance by dynamically deciding between buffered I\/O and un-buffered I\/O based on these conditions\/parameters. More specifically, and as discussed in greater detail below, the data collector module , the policy module , the optimizer module , and the reader module  of a host device  or host system collaborate to enable dynamic selection between buffered I\/O and un-buffered I\/O for one or more read calls based on detected system conditions\/parameters. In addition, and as discussed in greater detail below, the data collector module , the policy module , the optimizer module , and the reader module  may further cooperate to optimize other conditions related to the I\/O selection such as read alignment, dynamic threading, and\/or buffer tuning.","In embodiments, the data collector module  is configured to collect\/detect conditions, parameters, and\/or status information related to the host device . For example, the data collector module  may determine the host device  file system type(s). This may be the file system type(s) where the backup application  is working. Examples include a hierarchical file system (HFS), a Veritas file system (V\u00d7FS), a journaled file system (JFS), and an online JFS. The data collector module  may further determine the used\/unused host file system capacity (e.g., 4 GB used in 6 GB V\u00d7FS), the host database volume size (e.g., database volume of 2 GB), the host memory utilization (e.g., 70% memory utilization), the host CPU utilization (e.g., 80% CPU utilization), the number or percentage of cache misses of a period of time (e.g., 55% cache misses), the frequency of host I\/O or read\/writes for a period of time, and\/or I\/O buffer size of the file system.","The data collector module  may determine these values once. Alternatively or in addition, the data collector module  may determine the values periodically or randomly (e.g., based on the number of read operations for that instance of probing). For example, the data collector module  may determine the file system type once, and determine memory and CPU utilization randomly or periodically. Furthermore, the determined values may be current values, recent values, prior values, values over a period of time, and\/or initialized values.","In embodiments, the data collector module  may run a memory analyzer, profiler, and\/or other dynamic system analysis tool (e.g., GProf, ATOM, etc.) to determine, collect, interpret, and\/or measure the above-mentioned parameters. For example, the data collector module  may run a dynamic program analysis tool to determine the memory utilization and CPU utilization. Alternatively or in addition, the data collector module  may run an application or subroutine to determine, collect, interpret, and\/or measure the above-mentioned parameters.","After the data collector module  collects the above-mentioned information, the data collector module  may send the information to the policy module . In embodiments, the data collector module  may send the information continuously, periodically, after a value is determined for each parameter, and\/or whenever backup is triggered. The policy module  may receive this information via various mechanisms, such as, for example, via an inter-process communication (IPC) mechanism. The policy module  may then update a policy table based on the received information. As used herein, the policy table may refer to a data structure generated by the policy module whose schema may be generally designed as per the parameter\/value pair set forth in the table in .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 2"],"b":["200","200","150"]},"In addition to parameters and values, the policy table may include administrative data. For example, the policy table may include reference information such as the date and time of the most recent update. Further, the policy table may include information indicating which values have changed since a previous iteration of the policy table.","The optimizer module  may continuously or periodically receive a policy table feed from the policy module . This policy feed may comprise all or a portion of the policy table . The optimizer module  may then determine a preferred buffered I\/O technique (i.e., buffered I\/O or un-buffered I\/O) for a given instance based on analysis of the policy table. More specifically, the optimizer module  may analyze the previous and\/or current detected status of the host device  as described in the policy table and determine if buffered I\/O or un-buffered I\/O would result in optimum read performance. The optimizer module  may then, based on this analysis, store a recommended I\/O technique within the policy table. Of course, the optimizer module  may determine that one particular I\/O technique is better for a particular point in time, and then change to the other I\/O technique based on changed circumstances at a later point in time. Such flexibility enables the host device  to react to changing circumstances and implement the I\/O policy that appears most efficient for a particular set of conditions.","In order to decide between buffered I\/O and un-buffered I\/O, the optimizer module  may analyze current and\/or prior values in the policy table and compare the values with a rule-set to determine a preferred I\/O policy. In embodiments, this rule set may have a rule that leads to an immediate conclusion. For example, only certain types of file systems may support un-buffered I\/O (e.g., V\u00d7FS). In the event that the policy table lists a file system that does not support un-buffered I\/O, the type of I\/O technique cannot be changed, and therefore the optimizer module  determines based on the rule set that only the buffered I\/O technique is possible and analysis of the other parameters is not necessary. For example, the rule set may state: If HFS, then buffered I\/O. Therefore, if the policy table lists HFS, then the optimizer module  concludes buffered I\/O. The optimizer module  then instructs the reader module  to use that particular I\/O technique for one or more read calls. That is, the optimizer module  may intercept the reader module  (i.e., the reader module of backup application ) and set the type of I\/O (buffered or un-buffered) for that instance. Based on this setting, the reader module  may proceed the conduct the read based on the specified policy.","In the event that the file system type is compatible with buffered I\/O and un-buffered I\/O, the optimizer modules  may make an I\/O technique decision based on consideration of multiple parameters in the policy table and multiple rules in the rule-set. For example, the rule set may lead the optimizer module  to select buffered I\/O in situations where I\/O on the database volume is not buffered by a database application, memory utilization is less than 60%, CPU utilization is less than 50%, cache misses is less than 15%, host I\/O frequency is less than 40%, and\/or maximum I\/O size is less than 256 KB. In contrast, the rule set may lead the optimizer module  to select un-buffered I\/O in situations where, e.g., I\/O on database volume is buffered by the database application, memory utilization is more than 80%, CPU utilization is more than 70%, cache misses is more than 50%, and\/or I\/O buffer size is more than 512 KB.","The tables provided below show examples of situations that may lead to the optimizer module , based on the rule set, to conclude buffered I\/O or un-buffered I\/O. Of course, these are merely examples and should not be seen as limiting because rule sets may vary depending on preferences, environments, and\/or situations. Further, parameters\/values may be weighted differently in various embodiments.",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Parameter","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"File System Type","VxFS"]},{"entry":[{},"Memory Utilization","40%"]},{"entry":[{},"CPU Utilization","30%"]},{"entry":[{},"Cache Misses","10%"]},{"entry":[{},"Host I\/O Frequency","60%"]},{"entry":[{},"I\/O Buffer Size","256 KB"]},{"entry":[{},"Recommended I\/O Policy","Buffered I\/O"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Parameter","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"File System Type","VxFS"]},{"entry":[{},"Memory Utilization","85%"]},{"entry":[{},"CPU Utilization","80%"]},{"entry":[{},"Cache Misses","50%"]},{"entry":[{},"Host I\/O Frequency","25%"]},{"entry":[{},"I\/O Buffer Size","1 MB"]},{"entry":[{},"Recommended I\/O Policy","Un-Buffered I\/O"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In addition to determining an I\/O policy, in embodiments, the optimizer module  in cooperation with the reader module  may go a step further and execute various optimization processes for a given policy. Such optimization processes may include read alignment of data as per file system block size (for un-buffered I\/O selections), dynamic threading of I\/O calls (for un-buffered and buffered I\/O selections), and\/or buffer tuning (for buffered I\/O selections).","As described above, the data collector module , the policy module , and the optimizer module  may be part of a performance optimization application . This performance optimization application  may be plug-in software to the backup application  comprising the reader module . As a plug-in, the data collector module , the policy module , and\/or the optimizer module  may add specific abilities to the backup application .","Alternatively, the data collector module , the policy module , and the optimizer module  may be part of a software development kit (SDK) to the backup application . This SDK may be a set of development tools that allows for creation of application for the backup application . The SDK may be, e.g., an application programming interface (API) in the form of files to interface to a particular programming language and\/or include hardware to communicate with embedded systems. In embodiments, the SDK may be downloadable via the Internet.","Still further, the data collector module , the policy module , and the optimizer module  may form part of the backup application , along with the reader module , or be part of an independent application. In some embodiments, the data collector module , the policy module , the optimizer module , the backup application , and\/or the reader module  may be distributed across a plurality of devices.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 3","FIG. 1"],"b":["300","120"]},"The method may begin at block , wherein the data collector module  collects values for various parameters. The types of parameters (e.g., file system type, used file system capacity, overall file system capacity, database volume, memory utilization, CPU utilization, number of cache misses, host I\/O frequency, and\/or host I\/O buffer size) may be set by the optimizer module . The data collector module  may determine these values once, periodically, randomly, or based on a trigger (e.g., the start of a backup process). Further, the data collector module  may determine these values by running a memory analyzer, profiler, and\/or other dynamic program analysis tool, or by running a custom subroutine or tool.","At block , the policy module  receives the collected values from the data collector module  and inserts the values in a policy table. The policy table may refer to a data structure generated by the policy module whose schema may be generally designed as per the parameter\/value pair set forth in the table in .","At block , the optimizer module  may receive all or a portion of the policy table from the policy module . At block , the policy module analyzes the contents of the policy table and selects an I\/O technique. As mentioned above, in embodiments, this process may comprise evaluating the current and\/or prior values in the policy table against a predetermined or predeterminable rule-set. The rule set may comprise a plurality of rules that lead to a selection of either buffered I\/O or un-buffered I\/O based on different input parameters.","If un-buffered I\/O is selected, at block , the optimizer module  determines whether or not to proceed with multithread for I\/O calls. The multithread process may involve multiplexing data streams into parallel kernel threads using, e.g., Pthread Portable Operating System Interface for Unix (POSIX) standard system calls. Furthermore, the decision of whether or not to proceed with multithreading may be based on the amount of free CPU cycles. For example, multithreading may be used if the amount of free CPU cycles is more than 40%.","Furthermore, if un-buffered I\/O is selected, at block , the optimizer module  conducts read alignment of data as per file system block size. This process may involve determining the read size as a multiple of the file system block size.","If buffered I\/O is selected, at block , the optimizer module  similarly determines whether or not to proceed with multithread for I\/O calls. As described above with reference to block , the multithread process may involve multiplexing data streams into parallel kernel threads using, e.g., Pthread POSIX standard system calls. Furthermore, the decision of whether or not to proceed with multithreading may be based on the amount of free CPU cycles. For example, multithreading may be used if the amount of free CPU cycles is more than 40%.","The optimizer further conducts buffer tuning at block . This process may comprise calculating an optimum buffer size for a read depending on the amount of data to be read. If the data to be read is a small number of large files, the buffer size may be set larger. Conversely, if the data to be read is a large number of small size files, the buffer size may be set smaller.","At block , the reader module  of the backup application  executes the read call based on the decisions made in the above-mentioned processes.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 4","FIG. 1"],"b":["410","120","410","410","420","410","420","410","410","420","420","120","410"]},"The processor  generally retrieves and executes the instructions stored in the processor-readable medium  to conduct dynamic I\/O performance optimization in accordance with embodiments. In an embodiment, the processor-readable medium  can be accessed by the processor  over a bus .","A first region  of the processor-readable medium  may include data collector module functionality as described herein. Below is example pseudo-code for operations of the data collector module  in accordance with embodiments:\n\n","A second region  of the processor-readable medium  may include policy module functionality as described herein. Below is example pseudo-code for operations of the policy module  in accordance with embodiments:\n\n","A third region  of the processor-readable medium  may include optimizer module functionality as described herein. Below is example pseudo-code for operations of the optimizer module  in accordance with embodiments:\n\n","A fourth region  of the processor-readable medium  may include reader module functionality as described herein.","Although shown as contiguous blocks, the software components can be stored in any order or configuration. For example, if the processor-readable medium  is a hard drive, the software components can be stored in non-contiguous, or even overlapping, sectors."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Certain exemplary embodiments are described in the following detailed description and in reference to the drawings, in which:",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
