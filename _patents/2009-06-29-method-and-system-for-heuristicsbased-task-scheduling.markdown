---
title: Method and system for heuristics-based task scheduling
abstract: A computer readable storage medium including executable instructions for heuristics-based task scheduling. Instructions include receiving a first event notification associated with a first event, where the first event is determined from the first event notification. Instructions further include determining whether a predicate for an action is satisfied by the first event, where the action predicate, the action, and an action parameter are associated with a task object in a task pool. Instructions further include obtaining the action parameter when the action predicate is satisfied by the first event, where a priority is assigned using a heuristics policy to the task object based on the action parameter. Instructions further include inserting the task object into a task queue using the assigned priority. The action associated with the task object is performed by an execution thread. The performance of the action is a second event associated with a second event notification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08261275&OS=08261275&RS=08261275
owner: Oracle America, Inc.
number: 08261275
owner_city: Redwood City
owner_country: US
publication_date: 20090629
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","User Application","Operating System (OS)","Application Programming Interfaces (API)","Hardware Resources","Example"],"p":["A modern computer system may be conceptually divided into hardware, operating system, and application programs. The hardware, (i.e., central processing unit (CPU), memory, persistent storage devices, and input\/output (I\/O) devices) provides the basic computing resources. The application programs (i.e., compilers, database systems, software, and business programs) define the ways in which these resources are used to solve the computing problems of the users. The users may include people, machines, and other computers that use the application programs, which in turn employ the hardware to solve numerous types of problems.","An operating system is a program that acts as an intermediary between the application program layer and the computer hardware. To this end, the operating system is involved in coordinating the efficient and fair use of a finite resource base to enable a broad range of computative tasks (i.e., memory management, hardware resource management, maintaining a file system, processing user-level requests, administrative tasks, networking tasks, etc.). In some instances, when the operating system dispatches an execution thread to perform a particular computative task, the execution thread may execute until the task has completed. Alternatively, in other instances, the operating system may employ a polling scheme which allows for the computative task to periodically \u201cawaken\u201d, execute, and then \u201csleep\u201d based upon use a pre-determined time interval.","In general, in one aspect, the invention relates to a computer readable storage medium including executable instructions for heuristics-based task scheduling, where executable instructions include instructions to receive a first event notification at a task engine, wherein the first event notification is associated with a first event. Executable instructions further include instructions to determine a first event using the first event notification. Executable instructions further include instructions to determine whether a predicate for an action is satisfied by the first event, where the predicate for the action, the action, an action parameter for the action are associated with a task object in a task pool. Executable instructions further include instructions to obtain the action parameter using the task object when the predicate for the action is satisfied by the first event. Executable instructions further include instructions to assign the task object a priority using a heuristics policy based on the action parameter. Executable instructions further include instructions to insert the task object into a task queue using the assigned priority, where the task queue comprises a plurality of task objects ordered according to priority. The action associated with the task object is performed by an execution thread when the task object is obtained from the task queue. The performance of the action is a second event associated with a second event notification sent to the task engine.","In general, in one aspect, the invention relates to a system for heuristics-based task scheduling. The system includes a processor and an operating system executing on the processor. The operating system includes a task engine. The task engine is configured to receive a request. The task engine is further configured to determine a task corresponding with the request using a request-to-task mapping. The task engine is further configured to obtain a task entry corresponding with the task from a task store, where the task entry associates the task with an action, a predicate for performing the action, and an action parameter for the action. The task engine is further configured to create a task object in a task pool using the task entry, where the task object is associated with the action, the predicate, and the action parameter. The task engine is further configured to receive a first event notification, where the first event notification is associated with a first event. The task engine is further configured to determine the first event using the first event notification. The task engine is further configured to determine whether the predicate for performing the action is satisfied by the first event. The task engine is further configured to send the task object to a task scheduler when the predicate for performing the action is satisfied by the first event. The operating system further includes a task store configured to store a task entry. The operating system further includes a task pool configured to store a task object when a predicate for an action associated with the task object has not yet been satisfied. The operating system further includes a heuristics policy store configured to store a heuristics policy for assigning a priority to a task object. The operating system further includes a task scheduler configured to obtain an action parameter using a task object when a predicate for an action associated with the task object is satisfied by an event. The task scheduler is further configured to assign the task object a priority using the heuristics policy based on the action parameter. The task scheduler is further configured to insert the task object into a task queue using the priority, where the task queue includes a plurality of task objects ordered according to priority. The operating system further includes a task queue configured to store a task object when a predicate for an action associated with the task object has been satisfied and the task object has been assigned a priority by the task scheduler. The operating system further includes a dispatcher configured to obtain a task object from a task queue, determine an action using the task object, determine an execution thread for performing the action, and dispatching the executing thread for performing the action. The operating system is further configured to create a second event notification for sending to the task engine when the execution thread has completed performing the action, where the completion of the action is a second event associated with the second event notification.","Other aspects of the invention will be apparent from the following description and the appended claims.","Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.","In the following detailed description of embodiments of the invention, numerous specific details are set forth in order to provide a more thorough understanding of the invention. However, it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. In other instances, well-known features have not been described in detail to avoid unnecessarily complicating the description.","In general, embodiments of the invention provide a system and method for heuristics-based task scheduling in an event-driven system. More specifically, embodiments of the invention are directed to scheduling a task using a user-provided (or pre-defined) description for the task and a heuristics policy. Accordingly, a task is scheduled using descriptions accounting for a desired quality of service (QoS) associated with the task. In one or more embodiments of the invention, a task is a unit of computation performed by an executing thread. Further, a description for a task may provide a discrete action to be performed when the task is executed. In addition, a description for a task may specify a predicate for performing the action. As such, satisfaction of the predicate may serve as a precondition for performance of the action or, said another way, performance of the action depends upon satisfaction of the predicate. In one or more embodiments of the invention, a predicate is an event which may occur. Examples of an event may include, but are not limited to, an action by a user, the completion of a task, the reaching of an operation threshold (e.g., the temperature of processor, the amount of time within a given time interval that a processor is active, the amount of space remaining on a computer readable storage medium, etc.), or any other discrete event that can be described either quantitatively or qualitatively by a user in relation to a system.","In one embodiment of the invention, the QoS for a task specifies a level of performance for the action in the task, where the level of performance may include a guaranteed minimum number of computing resources to perform the task, a guaranteed minimum amount of network bandwidth allocated to perform the action, a minimum guaranteed amount of memory to perform the action, etc. Further, the quality of service may indicate a deadline for completing an action specified in the task (e.g., within 5 ms of another task, within a certain time period once the task object is created, etc.) and whether the action in the task is deferrable (e.g., whether execution of the task object may deferred if another higher priority task object is placed on the task queue and how long the task object may be deferred). Those skilled in the art will appreciate that the quality of service defined for a given task is not limited to the above examples.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 1","FIG. 1"],"b":["100","106","102","104","100","106","108"]},"In one or more embodiments of the invention, a user application () exists in the software layer of the system with which a user interacts. The user application () may be, for example, any application that provides a benefit or attempts to solve a problem and, in doing so, makes use of the system. Examples of user applications may include, for example, a compiler, a database system, a web browser, a web server, a spreadsheet program, a multimedia program, a business program, or any other software. In one or more embodiments of the invention, the user application () uses one or more application programming interfaces (i.e., APIs: , ) to issue requests to and receive responses from the OS ().","In one or more embodiments of the invention, an operating system () is configured to receive requests and event notifications (, , ). A request may be issued to the OS () by a user application () using an API (, ). Alternatively, a request may be issued by the OS () itself. An event notification (, , ) is associated with an event that has occurred in relation to the system. An event notification may signal an action by a user, the completion of a task, the reaching of an operation threshold, a specified time period elapsing, or any other discrete event that may be described either quantitatively or qualitatively. Upon receipt by the OS (), a request or event notification is processed using various OS components and defined data structures as shown in : a task engine (), a task store (), request-to-task mappings (), event-to-task mappings (), a task pool (), a task queue (), a task scheduler (), a heuristics policy store (), and a dispatcher ().","In one or more embodiments of the invention, a task engine () is configured to receive and subsequently process a request or event notification. Further, after having processed a request, the task engine () is configured to send a response to the request in accordance with one or more embodiments of the invention. More detail as to the processing of a received request or a received event notification is provided in relation to , respectively.","In one or more embodiments of the invention, a task store () is configured to store a task entry. A task entry specifies an action to be performed and a predicate for performing the action. An example of a task entry defined in accordance with one or more embodiments of the invention is provided in . In one or more embodiments of the invention, a task entry may be stored in, modified in, or deleted from the task store () in accordance with a request issued to the task store by the task engine ().","In one or more embodiments of the invention, a request-to-task mapping () is maintained by the OS (). Specifically, the request-to-task mapping () associates one or more tasks with a request. In one or more embodiments of the invention, the request-to-task mapping () is created, maintained, and deleted in accordance with a request received by the task engine (). For example, a user may issue a request to establish a network connection. As such, tasks related to this request may include: (a) enumeration of one or more network interfacing devices in the system; (b) initializing and associating each network interface device with an appropriate device driver; (c) request by a network configuration utility to configure the network interface parameters (i.e., IP address, subnet mask, default route, wireless network name, etc.); (d) detection by the driver of the network media (i.e., cable, available wireless network, etc.); (e) configuration of the device by the driver of the network interface parameters; (f) request by an application for a communication socket; (g) request by an application to configure the socket for communication with a given remote system; and (h) request by an application to read or write data to or from the remote system using the communication socket.","Further, in one or more embodiments of the invention, the one or more tasks mapped to by a request may have interrelated dependencies. In furtherance of the example provided above, for example, task (h) may depend from task (g), task (g) may depend from task (f), task (f) may depend from task (e), and task (e) may depend from both tasks (b) and (c). In addition, tasks (d) and (c) may both depend from task (b) where task (b) may itself depend from task (a). In addition, in one or more embodiments of the invention, tasks may themselves be broken into further subtasks.","In one embodiment of the invention, the task engine () includes functionality to decompose a request at runtime into a series of tasks. The request may be decomposed by determine which of the task (as defined by task entries in the task store) may be used to satisfy the request. Further, the task engine may use both the request-to-task mapping and the functionality to decompose a request at runtime into a series of tasks of the task engine to determine which tasks are required to satisfy the request. Further, in one embodiment of the invention, the task engine may first determine whether there is a request-to-task mapping for the request. If not, the task engine may use functionality to decompose a request at runtime into a series of tasks.","In one or more embodiments of the invention, an event-to-task mapping () is maintained by the OS (). Specifically, the event-to-task mapping () associates a task with an event (or type of event). In one or more embodiments of the invention, the event-to-task mapping () is created, maintained, and deleted in accordance with a request received by the task engine (). For example, an event notification may signal that a core of a multi-core processor has reached a specified temperature threshold. As such, tasks related to this event may include: (a) creating a fault management data record to note the temperature violation of the core; (b) consumption of the created fault management data record by a diagnosis and treatment engine and subsequent determination as to whether corrective action is needed; (c) logging of diagnostic information about the temperature violation; and (d) configuring of the core to operate in a thermal throttling mode such that operating temperature is brought into compliance. Similarly, these tasks may be interrelated. For example, (d) may depend from (b) and (b) may depend from (a). Further, (c) may also depend from (a).","In one or more embodiments of the invention, a task pool () is configured to store a task object. The task object specifies an action, a predicate for performing the action, and an transaction identifier. In one or more embodiments of the invention, the task object is created and stored in the task pool () by the task engine () using the corresponding task entry.","In one or more embodiments of the invention, a task queue () is configured to store a task object (as described above). In one or more embodiments of the invention, the task object is removed from the task pool (), where it is created, and placed in the task queue () when the predicate for performing the action associated with the task is satisfied and the task object has been assigned a priority by a task scheduler. In one or more embodiments of the invention, there may be a set of virtualized task queues that can be used to filter task objects according to a task characteristic or any other criteria. For example, task objects in a task queue may be filtered into virtual queues according to transaction identifier. In one embodiment of the invention, the system may include multiple task queues, where each task queue may be associated with request, task objects having an particular priority level, or any other type of classification\/group which may be applied to task objects. Further, in one embodiment of the invention, if there are multiple task queues, each task queue (or sub-sets of the task queues) may be associated with a separate processor or processor group.","In one or more embodiments of the invention, a task scheduler () is configured to receive a task object. In one or more embodiments of the invention, the task object is received from a task pool () when the predicate for the action associated with the task object has been satisfied. Subsequently, the task scheduler () uses a heuristics policy to determine how to schedule the task object relative to other task objects in the task queue. In one of the invention, the heuristics policy may determine how to schedule the task object based on an action parameter (described below with respect ) associated with the task object. Embodiments of heuristics policies are provided below.","In one or more embodiments of the invention, the dispatcher () is configured to obtain a task object. In one or more embodiments of the invention, the dispatcher () obtains the task object when a predicate for an action associated with the task object has been satisfied and a task scheduler () has assigned a priority for the task object. In addition, the dispatcher is also configured in accordance with one or more embodiments of the invention to assign an execution thread to perform the action associated with the task object. In one embodiment of the invention, the task queue is implemented as a first-in-first-out (FIFO) queue. In one embodiment of the invention, the task objects in the task queue are ordered based on priority. Further, as new task objects are added to the task queue, the ordering of the existing task objects in the queue may be modified such that once the new task object is added to the task queue, all task objects in the task queue (including the newly added task object) are ordered based on priority. Alternatively, in one or more other embodiments of the invention, a task queue may be implemented using some other ordering scheme.","In one or more embodiments of the invention, a heuristics policy store () is configured to store a plurality of heuristics policies. Specifically, a heuristics policy may be user-defined or per-defined by a third-party. Further, a user (or another third-party) may express a selection for a heuristics policy from the heuristics policy store () using an application programming interface (API).","Heuristics policies may allow for any number of scheduling criteria. For example, a dependent event clustering policy may consider task interdependencies in determining a task schedule. As such, a set of tasks that are dependent upon each other may all be scheduled to serially utilize the same resource. Alternatively, a set of tasks that are independent of each other may instead be scheduled for parallel utilization on different resources.","In another example of a heuristics policy, the frequency for performing computative actions may vary as a function of system utilization and performance. For example, a task may be scheduled to poll a device or perform periodically at a given rate if a particular condition is met (e.g., the processor is busy, mouse has moved, a universal serial bus (USB) port has detected the presence of an attached USB device, the system load is above a certain threshold, etc.). Alternatively, if that particular condition is not met, then the frequency for computative action may be either elevated or depressed accordingly to some action parameter. Further, the performance of computative actions in some cases may be filtered out (i.e., not allowed to execute\/perform\/utilize) based upon whether a heuristics policy deems a predicate to be transient (i.e., for example, a spike in activity or inactivity that is historically not predicated to persist). Further, the predicate for the task object may be adjusted accordingly if the satisfaction of the predicate for the action is merely transient.","In another example of a heuristics policy, actions are given priorities explicitly by a user. As such, an action with a high priority takes precedence over an action that has a lower relative priority. Further, actions with a low relative priority are considered more easily deferrable, for example, during periods of sustained high priority activity. Further, a heuristics policy may define an aging policy for actions with respect to their priority. For example, a priority for an action may increase or decrease with respect to time or some other system-quantifiably measure.","In another example of a heuristics policy, actions are deferred until system resources are available. Specifically, this may be a directive purposed to minimize power state transitions and therefore lessen overhead costs associated with system management.","In another example of a heuristics policy, the task objects for execution on a particular resource may be deferred until a certain number of task objects are accumulated. At that time, the task objects are dispatched to the resource of execution. Such a heuristics policy may be used in scenarios in which a decrease in performance may be allowed in order to decrease power consumption of the resource.","The afore-mentioned heuristics policy serve merely as examples of system management directives that may be used in the strategic scheduling of computative tasks. Those skilled in the art will recognize that these are just a few of the heuristics policies that may be implemented to that end and therefore should not be construed as limiting the scope of the invention.","In one or more embodiments of the invention, an application programming interface (, ) is used to facilitate the sending of requests from the user application () to the OS (). Further, in one or more embodiments of the invention, the OS () may provide an API-compliant response to the user application ().","In one or more embodiments of the invention, a first API () is configured to manage (i.e., create, modify, delete, etc.) a task entry maintained by the OS. As such, the first API () may be thought of as a Task Management API. For example, requests issued through the Task Management API () may manage a task entry in the task store (), a request-to-task mapping (), or an event-to-task mapping (). Further, a request may be issued through the Task Management API () for purposes of managing (creating, modifying, deleting, selecting, etc.) a heuristics policy.","In one or more embodiments of the invention, a second API () is configured to allow a user of a user-level application () to issue requests to the OS () resulting in the creation of one or more pending task objects. As such, the second API () may be thought of as a Task Request API. For example, requests issued through the Task Request API () may be translated into one or more discrete task objects defined by a request-to-task mapping ().","In one or more embodiments of the invention, a hardware resource (, ) is utilized according to a request issued by an OS (). Specifically, a request issued by the OS () may require the utilization of the hardware resource (, ) pursuant to an action executed by a dispatched execution thread. The hardware resource (, ) may be, for example, a memory device (e.g., non-volatile memory, volatile memory, etc.), a processor (e.g., single core, multi-core), an I\/O device (e.g., a network interface card), a cooling device (e.g., a cooling fan, etc.) or any other hardware device capable of receiving a request from the OS ().",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIGS. 2","i":["a ","b "],"b":"2"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 1"],"i":["a ","a ","a "],"b":["208","206","210","200","208","200","206","210"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 1"],"i":["b ","b ","b "],"b":["202","200","204","200"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIGS. 3","b":["4","5"]},"Turning to , the process shown therein may be used, for example, to process a request received by a task engine. In Step , a request is received. In one or more embodiments of the invention, the task engine assigns a unique transaction identifier to the request (i.e., not shown in ).","In Step , a set of tasks corresponding with the request is determined using a request-to-task mapping. In one or more embodiments of the invention, the task engine uses the received request to select the appropriate request-to-task mapping. In one or more embodiments of the invention, this mapping is defined in accordance with the first data structure shown in . Having selected the appropriate mapping, the task engine may then determine which tasks properly correspond with the request that was received. In one or more embodiments of the invention, Steps - (i.e., described below) may function as an iterative loop to process each one of the tasks in the set of tasks.","In Step , a task is selected from the set of tasks. In Step , the selected task is then used to obtain a corresponding task entry from the task store. In one or more embodiments of the invention, the task entry is defined as shown in . Accordingly, obtaining a task entry allows the task engine to determine an action associated with the task and a predicate for performing the action.","In Step , the obtained task entry is used to create a task object, which is subsequently stored in a task pool. In one or more embodiments of the invention, the task object is associated with the same action and predicate as defined by the obtained task entry. Further, in one or more embodiments of the invention, the task object is further associated with an transaction identifier unique to the request (if assigned by the task engine in or after Step ).","In Step , a determination is made as to whether another task from the set of tasks (i.e., from Step ) requires processing (i.e., Steps -). If another task from the set of tasks requires processing, then Step  is executed next with regards to a newly-selected task. Otherwise, if all tasks from the set of tasks have been processed, the process shown in  is completed for the received request.","Turning to , the process shown therein may be used, for example, to process an event notification received by a task engine. In Step , an event notification is received. In one or more embodiments of the invention, the task engine assigns a unique transaction identifier to the event notification (i.e., step not shown in ).","In Step , a set of tasks corresponding with the event notification is determined using an event-to-task mapping. In one or more embodiments of the invention, the task engine uses the event from the event notification to select the appropriate event-to-task mapping. In one or more embodiments of the invention, this mapping is defined in accordance with the second data structure shown in . Having selected the appropriate mapping, the task engine may then determine which tasks properly correspond with the received event notification. In one or more embodiments of the invention, Steps - (i.e., described below) may function as an iterative loop to process each one of the tasks in the set of tasks.","In Step , a task is selected from the set of tasks. In Step , the selected task is then used to obtain a corresponding task entry from the task store. In one or more embodiments of the invention, the task entry is defined as shown in . Accordingly, obtaining a task entry allows the task engine to determine an action associated with the task and a predicate for performing the action.","In Step , the obtained task entry is used to create and store a task object in a task pool. In one or more embodiments of the invention, the task object is associated with the same action and predicate as defined by the obtained task entry. Further, in one or more embodiments of the invention, the task object is further associated with a transaction identifier unique to the event (if assigned by the task engine in or after Step ).","In Step , a determination is made as to whether another task from the set of tasks (i.e., from Step ) requires processing (i.e., Steps -). If another task from the set of tasks requires processing, then Step  is executed next with regards to a newly-selected task. Otherwise, if all tasks from the set of tasks have been processed, the process shown in  is completed for the received event.","Turning to , the process shown therein may be used, for example, to process a pending task in a task pool using a heuristics policy when the predicate for an action associated with the pending task has been satisfied.","In Step , a heuristics policy is determined. In one or more embodiments of the invention, the heuristics policy may be determined based on a user selection from the heuristics policy store. For example, this selection by the user may be accomplished when the users issues a request using an API (i.e., the Task Management API). Alternatively, in one or more other embodiments of the invention, a heuristics policy may be determined based on another parameter such as time of day. In another embodiment of the invention, the heuristics policy may be determined based on an operational setting (e.g., the system is configured for real-time) and\/or hardware configuration of the system (e.g., number of processors, amount of memory, etc.). Those skilled in the art will appreciate that any number (or combination) of factors may be used to determine the heuristics policy. In addition, the task engine may concurrent use of multiple heuristics policies at any given time.","Turning to , in Step , an event notification is received. In one or more embodiments of the invention, the task engine assigns a unique transaction identifier to the event notification (i.e., step not shown in ). In one or more embodiments of the invention, Steps - (i.e., described below) may function as an iterative loop to process each one of the task objects in the task pool. In Step , a task object is selected from the task pool. In one or more embodiments of the invention, the task object is associated with an action and a predicate for performing the action. In Step , a determination is made as to whether the predicate for the action associated with the selected task object is satisfied by the event (i.e., from the event notification received in Step ). If the predicate for the action is satisfied by the event, then Step  is executed next. Otherwise, if the predicate for the action is not satisfied by the event, Step  is executed next.","In one or more embodiments of the invention, the determination of Step  is contextual in that operational context of the event (i.e., received in Step ) and the operational context of the selected task object (i.e., selected in Step ) must match for the task object predicate to be satisfied. More specifically, transaction identifiers, as stored in each task object and as assigned by the task engine for each received request or event notification, are used to determine whether there is a match. In one embodiment of the invention, the use of transaction identifiers enables multiple task objects derived from the same task entry to contemporaneously exist in the storage pool and allow the appropriate events to satisfy the appropriate predicates.","In Step , the selected task object is removed from the task pool. In Step , an action parameter for the task is obtained from the selected task object. In Step , the task object is assigned a priority based on the action parameter (obtained in Step ) using the heuristics policy.","In Step , the task object is inserted into a task queue based on the assigned priority. In one or more embodiments of the invention, the task object entries in the task queue are ordered with respect to priority. For example, a task queue may be ordered such that the first task object entry is assigned the highest priority relative to the other task objects in the task queue. As such, the task object entry that is positioned last in the task queue is assigned the lowest priority relative to the other task objects in the task queue.","In Step , a determination is made as to whether another task object from the task pool requires processing (i.e., Steps -). If another task object from the task pool requires processing, then Step  is executed next with regards to a newly-selected task object. Otherwise, if all the task objects in the task pool have been processed, the process shown in  is complete. The task objects are subsequently processed, in priority order, from the task queue using execution threads dispatched from the dispatcher.","Those skilled in the art will appreciate that while  describes an embodiment in which the task scheduler assigns each task a priority based on the action parameter and heuristics policy, that the invention may be applied to scenarios in which the task scheduler does not use priority as the sole indicator of when a task object is scheduled for execution. For example, a task object may be associated with a given priority but also be designated as deferrable. In such cases, depending on the heuristics policy and the other task objects in the task queue, the task object may be deferred from executing even though the priority of the task object is higher than other task objects currently in the task queue.","In one embodiment of the invention, the predicates for the task objects are analyzed prior to the task objects being stored in the task pool or at some initial point after the task objects are in the task pool. During the aforementioned analysis, if the predicates are satisfied, e.g., because the predicate indicates that the task is to be automatically transferred to the task queue, then the task object is sent to task queue. In such cases, the task object may be forwarded to the task queue even though an event notification was not received.","The following scenario presents an example in accordance with one or more embodiments of the invention. The example is not intended to limit the scope of the invention. For purposes of the example, assume a user is sitting in a wireless Internet caf\u00e9 with a laptop computer that is equipped with a wireless network card. Further assume that the user wishes to spend some time browsing web pages on the Internet. As such, the user's laptop computer must first connect to the Internet. To this end, the user runs a user-level software application on the laptop computer which allows the user to issue a request for connecting to the Internet (or more specifically, a wireless network in the Internet caf\u00e9). Accordingly, the aforementioned software application receives a first request for connecting to the Internet from the user. In processing the first request from the user, the software application invokes a specific function in the Task Request API for connecting to the Internet.","As a result of the user-level software application invoking the Task Request API function, the task engine in the OS of the laptop computer receives a request. Accordingly, the task engine assigns a unique transaction identifier for the request. Further, the task engine determines a set of tasks using a request-to-task mapping maintained by the OS. In particular, the request-to-task mapping corresponds with the request for connecting to the Internet received by the task engine and, as such, specifies a set of mapped-to tasks that are necessary for Internet connectivity.","For example, a first task may be the detection of a wireless network card. As such, the first task may be said to depend upon, for example, the selection and loading of the OS. In addition, a second task may be the enabling of the radio on the wireless network card and, as such, may be said to depend upon the detection of a wireless network card (i.e., completion of the first task). Further, a third task may be the detection of one or more wireless networks. Accordingly, the third task may be said to depend upon the enabling of the radio on the wireless network card (i.e., completion of the second task). A fourth task may be the selection of and connection to a wireless network, which would depend upon the detection of a wireless network (i.e., completion of the third task).","In view of this, a request by a user may be mapped to a number of discrete tasks in accordance with one or more embodiments of the invention. Further, there may be an implied dependency among the mapped-to tasks as described above. A symbolic description of actions for the aforementioned tasks and their corresponding necessary predicates is provided below.",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"\u201cConnect to Internet\u201d Tasks"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Task #1: if (OS is initialized)\u2003\u2003\u2192 action: detect a wireless network card"},{"entry":"Task #2: if (completion of Task #1) \u2192 action: enable a radio for the"},{"entry":"wireless network card"},{"entry":"Task #3: if (completion of Task#2) \u2192 action: detect a wireless network"},{"entry":"Task #4: if (completion of Task #3) \u2192 action: connect to wireless network"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Returning to the example, a task object is created in the task pool in correspondence to each of the mapped-to tasks determined by the task engine. Specifically, each task object is be associated with an action to be performed, a predicate for performing the action, and the transaction identifier. Accordingly, with the receipt of an event notification, the task engine iterates through each of the task objects in the task pool to determine whether a task predicate for a task object has been satisfied by the event. When a predicate is found to be satisfied, the task object with which the predicate is associated is then sent to a task scheduler. In this particular example, the operating system for the laptop computer has already been initialized. As such, because the predicate for the first task is already satisfied, the first task object is sent to the task scheduler.","The task scheduler uses the task object to obtain an action parameter. Further, a heuristics policy is used to determine a priority for the task object based on the action parameter. Accordingly, the task object is then inserted into a position in the task queue based on the task's assigned priority. Once tasks are placed in the task queue, a dispatcher in the operating system obtains the highest-priority task object and subsequently dispatch an execution thread to perform the action associated with the task object.","For purposes of this example, let us assume that connecting to the internet correlates to a set of tasks with a moderate priority level. As such, the aforementioned first through fourth tasks are placed in the queue accordingly. In extending our example, let us assume that the laptop computer user is simultaneously engaging in a computing activity that qualifies for a higher priority level (i.e., playing a video from a media file stored on disk). As such, tasks related to this other activity are be positioned closer to the front of the task queue. Accordingly, the dispatcher execute actions in task objects associated with the higher priority tasks before the action in the task object for wireless network card detection is performed (i.e., the first task).","Later, when the dispatcher does perform the action of wireless network card detection, an event notification may be received by the task engine memorializing that specific event. The event notification may also include the transaction identifier associated with the executed task. Once created, the event notification is sent to the task engine for purposes of providing a notification that a wireless network card has been detected. The task engine, having then received the event notification, will again search the task objects in the task pool to determine whether any of the action predicates embodied in the task objects are now satisfied in light of the received event (i.e., detection of a wireless network card). In the context of this particular example, the task engine will determine that the detection of a wireless network card satisfies the predicate for enabling the radio on the wireless network card.","The example above is but a specific example of how task objects in a task pool may be processed in light of an event notification (i.e., the completion of an action in the example but, more generally, any event suffices) to result in the performance of an action. Further, the performance of that particular action may itself satisfy the predicate for a next action as described above.","In addition, the assignment of a transaction identifier may be used by the task engine to provide not only an operational context within the system for tasks and events. For instance, in the example above, a unique transaction identifier was issued when the task engine received the \u2018connect to the internet\u2019 request from the user-level software application. Accordingly, all mapped-to tasks determined by the task engine to be associated with the request are instantiated as task objects with the like transaction identifier. Further, when a task object is executed, an event notification is created using the same transaction identifier for sending to the task engine. As such, the task engine, when it receives the event notification, is able to use the transaction identifier to determine whether a task object in the task pool belongs to the same operational context within the system as the just-completed event of the event notification.","Embodiments of the invention may allow for more efficient use of resources in a system. Specifically, embodiments of the invention allows developers and users of a system to more precisely relate a task or set of tasks to an action, operation, or circumstance elsewhere in the system (i.e., predicates). Embodiments of the invention allow for tasks to be related to events such that a task may be, for example, performed or performed more\/less frequently based on the occurrence of a specified event. Accordingly, costs associated with polling are reduced because polling may be executed at a bare minimum until a specified predicate is satisfied. Alternatively, a predicate for a task may be specified as a function of elapsed time rather than the occurrence of a discrete event. Accordingly, in enabling the expression of task predicates as described, features of the invention allow for greater flexibility and latitude with regards to the scheduling of tasks. For example, tasks may be scheduled in accordance with any number of pre-defined or user-defined heuristics policies as discussed.","Embodiments of the invention may be implemented on virtually any type of computer regardless of the platform being used. For example, as shown in , a computer system () includes one or more processors (), associated memory () (e.g., random access memory (RAM), cache memory, flash memory, etc.), a storage device () (e.g., a hard disk, an optical drive such as a compact disk drive or digital video disk (DVD) drive, a flash memory stick, etc.), and numerous other elements and functionalities typical of today's computers (not shown). The computer () may also include input means, such as a keyboard (), a mouse (), or a microphone (not shown). Further, the computer () may include output means, such as a monitor () (e.g., a liquid crystal display (LCD), a plasma display, or cathode ray tube (CRT) monitor). The computer system () may be connected to a network () (e.g., a local area network (LAN), a wide area network (WAN) such as the Internet, or any other similar type of network) via a network interface connection (not shown). Those skilled in the art will appreciate that many different types of computer systems exist, and the aforementioned input and output means may take other forms. Generally speaking, the computer system () includes at least the minimal processing, input, and\/or output means necessary to practice embodiments of the invention.","Further, those skilled in the art will appreciate that one or more elements of the aforementioned computer system () may be located at a remote location and connected to the other elements over a network. Further, embodiments of the invention may be implemented on a distributed system having a plurality of nodes, where each portion of the invention may be located on a different node within the distributed system. In one embodiment of the invention, the node corresponds to a computer system. Alternatively, the node may correspond to a processor with associated physical memory. The node may alternatively correspond to a processor with shared memory and\/or resources. Further, software instructions to perform embodiments of the invention may be stored on a computer readable medium such as a compact disc (CD), a diskette, a tape, or any other computer readable storage device.","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIGS. 2","i":["a ","b "],"b":"2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIGS. 3","b":["4","5"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
