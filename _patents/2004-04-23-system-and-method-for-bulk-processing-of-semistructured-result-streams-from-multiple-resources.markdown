---
title: System and method for bulk processing of semi-structured result streams from multiple resources
abstract: A system and associated method for bulk processing of semi-structured results streams from many different resources ingest bytes, parse as many bytes as practical, and return to process additional bytes. The system processes network packets as they arrive from a computing resource, creating intermediate results. The intermediate results are held in a stack until sufficient information is accumulated. The system then merges the intermediate results to form a single document model. As network packets at one connection are consumed by the system, the system can select another connection at which packets are waiting for processing. The processing of a result at a connection can be interrupted while the system processes the results at another connection. In this manner, the system is able to utilize one thread to process many incoming results in parallel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07877484&OS=07877484&RS=07877484
owner: International Business Machines Corporation
number: 07877484
owner_city: Armonk
owner_country: US
publication_date: 20040423
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["The present invention generally relates to a system and a method for processing incoming or outgoing streams of data from a variety of resources and particularly to computing resources such as databases, servers, and like resources. More specifically, the present invention pertains to the use of a small number of threads to process several parallel incoming streams of semi-structured data in an interleaved fashion.","A client program or user utilizing a large distributed computing system typically issues queries, search requests, data selection requests, and so forth, and collects results from a large number of servers in the distributed computing system. The large distributed computing system may be any environment that comprises data that is horizontally partitioned across many servers. A continuing effort has been made to make the process of collecting the information from the servers as efficient as possible with regards to both time and resources. The need for efficient collection of information from large distributed computing systems has become more critical as more systems adopt a web services approach to interfacing with clients.","One conventional approach to issuing queries and collecting results is a sequential processing approach , illustrated by the diagram of . A client  sequentially issues a query to and receives a result from server , , server , , server , , and server ,  (collectively referenced as servers ). For example, client  issues a query  to server , , and receives a result . Client  then issues a query  to server , , and receives a result , etc. This sequential process is repeated until all the queries have been issued and all the results returned. Although this technology has proven to be useful, it would be desirable to present additional improvements.","The sequential processing approach  has the advantage of requiring a single thread to process the results. Utilizing a single thread is efficient with respect to resources, but not time. The sequential processing approach  is relatively slow; a delay by one of the servers  delays the overall response to the query. Each of the servers  may take a reasonable amount of time such as, for example, 10 ms to respond to the query. However, for a large number of servers , the overall response time to the query becomes unacceptably slow. The time required to respond to the query becomes the sum of the time required for each of the remote procedure calls.","Another conventional approach for issuing queries and collecting results is a parallel processing approach , illustrated by . A client  comprises a thread , , a thread , , a thread , , and a thread ,  (collectively referenced as threads ). Client  issues in parallel a query to and receives results from server , , server , , server , , and server ,  (collectively referenced as servers ). The parallel processing approach  utilizes one of the threads  for each of the servers  to manage input\/output communication with each of the servers . For example, thread , , is dedicated to input\/output communication with server , . Thread , , is dedicated to input\/output communication with server , , etc. Although this technology has proven to be useful, it would be desirable to present additional improvements.","The parallel processing approach  has the advantage of quickly processing the results. Utilizing one of the threads  for each of the servers  is efficient with respect to time, but not resources. Each of the threads  consumes a substantial amount of computing resources. Further, network packets are typically 1.5 Kbytes. If the result of the query is much larger than 1.5 Kbytes, each of the threads  become active when data is ready to be read, resulting in a large number of context switches. As the number of servers  increases, the parallel processing approach  becomes even less efficient.","With both the sequential processing approach  and the parallel processing approach , the client  and client  are required to wait until sufficient information is accumulated to provide results. Several useful techniques have been developed for managing the collection of results provided in structured formats from a large distributed computing system.","However, the use of semi-structure formats such as XML is proliferating on the Internet and on other networks that are based on a web service model, requiring new approaches for managing bulk XML querying and semi-structured results streams. Structured data informs the client in advance how much data to expect so that the client can know when all the information has arrived and then process the information. Semi-structured data simply arrives at the client as a byte stream. The client then has to interpret the byte stream as it arrives by parsing the byte stream. Consequently, it is difficult to use one thread to process parallel streams of semi-structured data.","What is therefore needed is a system, a computer program product, and an associated method for bulk processing of semi-structured results streams from many different resources. The need for such a solution has heretofore remained unsatisfied.","The present invention satisfies this need, and presents a system, a computer program product, and an associated method (collectively referred to herein as \u201cthe system\u201d or \u201cthe present system\u201d) for bulk processing of semi-structured results streams from many different resources such as, for example, databases, servers, and the like. The semi-structured results streams are referenced herein as results; results comprise many packets of information.","The present system can ingest an arbitrary number of bytes, parse as many bytes as practical, and return. Unlike conventional approaches, the present system processes packets as they arrive from a resource, creating intermediate results. The intermediate results are held in a register or stack until sufficient information is accumulated. The present system then merges the intermediate results to form a document model.","As network packets at one connection are consumed by the present system, the present system can select another connection at which packets are waiting for processing. The processing of results at a connection can be interrupted while the present system processes the results at another connection. In this manner, the present system is able to utilize one thread to process many incoming results in parallel. Because the present system functions much faster than the results arrive, the present system is able to provide the document model in a time frame comparable to that of a conventional system that utilizes dedicated threads for each of the incoming results. If data arrives more quickly, this can be easily addressed by using a small number of threads to handle the various connections.","The present system utilizes a pushdown deterministic automata and a finite state model. Because the incoming results are streaming, the present system requires very little state for each parse of the incoming results. Consequently, the present system is able to use a single thread to select from a bank of connections and transmit a query to each of the selected connections. The present system then waits for results to the query, parsing data from the results as it becomes available.","Instead of utilizing a multi-threaded parallel model as in conventional approaches, the present system utilizes a single thread that queries a network of resources in parallel. The query is typically small (on the order of 1 or 2 Kbytes or less). The results of the query are typically very large, hundreds of Kbytes or larger. The present system issues the query sequentially and receives the results from the resources in parallel. To process the results, the present system utilizes a single result thread that maintains state for each one of the resources that the present system has queried.","In one embodiment, system  may be used to process XML utilizing stream-based processors. Rather than generating a document model, the stream-based processor generates callbacks. One common callback interface is SAX (simple API for XML). In this embodiment, system  generates the appropriate SAX callbacks and SAX events from the XML streams. Users that base their event application programming interfaces (APIs) on SAX events can utilize system  to generate those SAX events with one thread rather than many threads in parallel. Further, system  can process the XML stream incrementally, providing a faster access to the SAX events by the event API.","The following definitions and explanations provide background information pertaining to the technical field of the present invention, and are intended to facilitate the understanding of the present invention without limiting its scope:","API: (Application Program Interface) A language and message format used by an application program to communicate with the operating system or some other system or control program such as a database management system (DBMS) or communications protocol. APIs are implemented by writing function calls in the program, which provide the linkage to the required subroutine for execution. Thus, an API implies that some program module is available in the computer to perform the operation or that it must be linked into the existing program to perform the tasks.","Automata: A machine, system, or subsystem that follows a preset sequence of instructions automatically.","Document Model: A representation of semi-structured data such as an XML data that a program can examine and query.","Internet: A collection of interconnected public and private computer networks that are linked together with routers by a set of standards protocols to form a global, distributed network.","Pushdown Deterministic Automata (PDA): a simple machine, system, or subsystem that manages a stack.","SAX (Simple API for XML): an event-based API that allows programming access to the contents of an XML document.","Semi-structured: Data, such as XML, that has a more loosely defined format than traditional columnar databases.","XML: extensible Markup Language. A standard, semi-structured language used for Web documents. During a document authoring stage, XML \u201ctags\u201d are embedded within the informational content of the document. When the web server subsequently transmits the web document (or \u201cXML document\u201d) to a web browser, the tags are interpreted by the browser and used to parse and display the document. In addition to specifying how the web browser is to display the document, XML tags can be used to create hyperlinks to other web documents.","Xtalk: a binary encoding of XML. Used in high speed XML-RPC systems to reduce the complexity and computational load of the serialization\/deserialization step without constraining the format of the query\/response.","World Wide Web (WWW, also Web): An Internet client\u2014server hypertext distributed information retrieval system.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1","b":["10","15","15","10"]},"A distributed computing system  comprises computing resources such as a resource , , a resource , , a resource , , through a resource N,  (collectively referenced herein as resources ). Client  can access the distributed computing system  through a network . Client  is connected to network  via a communications link  such as a telephone, cable, or satellite link. Resource , , resource , , resource , , through resource N,  can be connected to network  via communications link , , ,  respectively. While system  is described in terms of network , client  may also access resources  locally rather than remotely.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2","b":["10","10","205","205","205","15"]},"System  further comprises a single result thread . The single result thread  manages the operation of system , retrieves results (semi-structured results streams) from resources , and processes the results in conjunction with parse states . Communications from resource , , resource , , resource , , through resource N, , to system  occur via a connection , , a connection , , a connection , , through a connection N,  (collectively referenced as connections ), respectively. It should be clear that the result thread  represents a single thread or a small number of threads.","Parse states  comprises a parse state for each of the resources  with which client  is communicating. Parse states  comprise a parse state , , a parse state , , a parse state , , through a parse state N, . In the example of , system  uses parse state , , to process information received from resource , , parse state , , to process information received from resource , , etc.","System  comprises state subroutines . State subroutines  are called by the single result thread  to process results received from resources  as the results arrive. The specific subroutine in state subroutines  called by the single result thread  depends on a state of the results. The single result thread  retrieves results from each of the connections  much faster than the results can arrive. Consequently, system  is able to process the results as they arrive, rather than waiting for all the results to arrive before processing the results and creating a document model.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":["1","245","1","220","1","305","2","310","3","315","320","325","1","245","330","335","340","330","305","330","305","210","305","210","1","245","325","325","45"]},"In one embodiment, the processing stack  comprises a string stack, an integer stack, and a frame stack. The processing stack  temporarily stores intermediate data, i.e., data that has been processed but is not yet ready to be combined into a document model. For example, as system  pulls a string off connector , the string is stored in the string stack until it is processed. The frame stack holds the intermediate results, i.e., partially completed results. A state encountered toward the end of processing of the results from one of the resources  consumes all the intermediate results stored in the frame stack to create the final result, i.e., a document model. The integer stack controls the processing stack  by saving the contents of the number of sub-elements remaining of the packet .","The parse state , , is a pushdown deterministic automata. The parse state , , is pushing the work required for processing packet  onto the state stack ; whatever state is on top of the state stack  defines the work required by packet . As packet  is retrieved from connection , , by kernel , the single result thread  determines the state of packet , selects a corresponding subroutine from the state subroutines  that corresponds to the determined state of packet , and instructs the corresponding subroutine to process packet .","The results of processing packet  are stored in the string stack; the current state of packet  is stored in the state stack . As the single result thread  processes packet , any additional states representing future processing required by packet  are \u201cqueued\u201d by pushing the additional states onto the state stack . As each corresponding subroutine from the state subroutines  is completed, the single result thread  examines the state stack  to determine if any additional processing remains for packet . If so, the single result thread  pops the top state off the state stack  (removes the top state from the state stack ), performs the corresponding subroutine from the state subroutines , and discards the top state.","In addition to popping the top state in the state stack , the corresponding subroutine in the state subroutines  may remove additional states from the state stack  or add states to the state stack , depending on the processing performed on packet . A specific state may appear many times in the state stack . Any of the state subroutines  may be performed any number of times, as required, to transform packets  into a document model.","The single result thread  continues processing packet  until the state stack  is empty. System  then retrieves packet , , packet , , through packet N, , until all packets  have been processed in like fashion. Packets  represent a portion of the results returned by one of the resources . When no packets  are found at connection , , system  proceeds to any other of the connections  that have packets such as packet  waiting for processing. In this manner, system  utilizes the single result thread  to process results that arrive at client  in parallel.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 4","FIGS. 4A"],"b":["4","400","10","15","45","20","405","15","45","45","410","15","45","415","45","45","45","15","325","420","45","20"]},"Results from resources  are returned to client  in pieces; each piece is a packet such as packet . Typically, packets such as packet  are approximately 1.5 Kbytes on a typical Ethernet. In one embodiment, the results from resources  are returned as a stream of bytes encoded in XML. In another embodiment, the results from resources  are returned in a stream of bytes encoded in binary encoding such as Xtalk. The method  of system  converts the stream of bytes into a document model.","System  processes each of the packets  as packets  arrive at client  (step ) by executing the pseudo code below, which is provided for example purpose only. The single result thread  checks with kernel  to determine which of the connections  have data available for processing (step ) using a \u201cselect\u201d method as is currently available and known in the art. If no packets are on any of the connections  (decision step ), system  waits at step  for packets arrive at any of the connections . If a packet such as packet  is found at any of the connections  (decision step ) such as, for example, connection , , the single result thread  utilizes the dispatch loop  to performs a dispatch loop procedure. The dispatch loop procedure examines the related state for the packet and executes the corresponding subroutine of the state subroutines , creating intermediate results (step ).","If accumulated intermediate results are not sufficient to form a document model (decision step ), system  returns to step  and continues processing packets . Otherwise, a document model can be formed and system  then merges the intermediate results into a document model (step ). Method  is performed recursively, continually converting into document models semi-structured results that are transmitted in parallel to client .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 5","b":["445","445","10","325","505","340","305","1","220","510","340","330","305","505","330","510","330","515","340","265","520","525","530"]},"System  repeats steps  through  recursively until all packets  at connections  have been processed. System  processes packets  faster than packets  arrive at client , allowing one thread, the single result thread , to handle many parallel streams of results. Results are returned to client  from resources  in a random fashion. Each of the resources  simply sends results to client  when the results are available and not in any particular order. The single result thread  jumps from connection to connection, processing packets as they arrive and merging intermediate results at each of the connections  until all the packets from resources  are retrieved, processed, and formatted as a document model.","In the illustrative pseudo code below, there are shown seventeen states or subprograms that are selectively executed by system . The following are four exemplary stacks that are used in a preferred embodiment of the present invention; it being understood that other stacks could be used:","the state stack","the integer stack","the frame stack","the string stack","parse begins with the INIT state",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"INIT:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"make sure there are 2 bytes"]},{"entry":[{},"consume them"]},{"entry":[{},"check if the first is \u2018X\u2019"]},{"entry":[{},"push PINIT"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"PINIT:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"make sure there are 4 bytes"]},{"entry":[{},"these are the # of processing instructions"]},{"entry":[{},"push PI this number of times"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"PI:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"make sure there is 1 byte"]},{"entry":[{},"if it is a p get rid of the processing instruction by"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"push DROPSTRING"]},{"entry":[{},"push GETSTRING"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if it is an E this is the element we want so"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"push MAKERETURN"]},{"entry":[{},"push GETFRAME"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else CORRUPT"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"DROPSTRING:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"pop the top element off the string stack"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"GETSTRING:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"make sure we have 4 bytes"]},{"entry":[{},"this is the size of the string"]},{"entry":[{},"allocate it and set the position pointer to 0"]},{"entry":[{},"push GS1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"GS1:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"need at least 1 byte"]},{"entry":[{},"do we have enough bytes to finish the string?"]},{"entry":[{},"if so,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"finish the string (copying it into the string buffer)"]},{"entry":[{},"set the pointer forward that many bytes"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"take as much as we can (copying it into the string buffer)"]},{"entry":[{},"set the pointer forward that many bytes"]},{"entry":[{},"push GS1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"GETFRAME:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"We need the key, then to go on w\/ the frame, so"]},{"entry":[{},"push F1"]},{"entry":[{},"push PUSHSTRING"]},{"entry":[{},"push GETSTRING"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"PUSHSTRING:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"take the string out of the string buffer and push it on the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"string stack"},{"entry":"F1:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"make sure we have 4 bytes"]},{"entry":[{},"this is the number of attributes"]},{"entry":[{},"we need to get them, then go on with the frame"]},{"entry":[{},"each attribute has a key and value, so"]},{"entry":[{},"push F2"]},{"entry":[{},"pushint count (this pushes to the int stack)"]},{"entry":[{},"and then for each attributes"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"push PUSHSTRING"]},{"entry":[{},"push GETSTRING"]},{"entry":[{},"push PUSHSTRING"]},{"entry":[{},"push GETSTRING"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"F2:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"make sure we have 4 bytes"]},{"entry":[{},"this is the number of children"]},{"entry":[{},"pushint count"]},{"entry":[{},"pushint F3"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"F3:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"we need 1 byte"]},{"entry":[{},"this is the type of the child"]},{"entry":[{},"get the number of children by popint"]},{"entry":[{},"if it is \u2018s\u2019 then this whole frame is a leaf"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"push MAKELEAF"]},{"entry":[{},"push PUSHSTRING"]},{"entry":[{},"push GETSTRING"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else, it is an \u2018E\u2019 and there are subframes"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pushint count"]},{"entry":[{},"push MAKENODE"]},{"entry":[{},"push PUSHFRAME"]},{"entry":[{},"push GETFRAME"]},{"entry":[{},"for each child"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"push EATE"]},{"entry":[{},"push PUSHFRAME"]},{"entry":[{},"push GETFRAME"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"MAKELEAF:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gather the value of the leaf (via popstring)"]},{"entry":[{},"the number of attributes (via popint)"]},{"entry":[{},"all of those attributes (via multiple popstring)"]},{"entry":[{},"the key (via popstring)"]},{"entry":[{},"create a leaf and assign it to the frame buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"PUSHFRAME:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"take the value of the frame buffer and push it on the frame"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"stack"},{"entry":"EATE:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"make sure we have at least one byte, then check that is an \u2018E\u2019"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"and"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"consume it"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"MAKENODE:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"gather the number of children (via popint)"]},{"entry":[{},"the number of attributes (via popint)"]},{"entry":[{},"the children (via multiple popframe)"]},{"entry":[{},"the attributes (via multiple popstring)"]},{"entry":[{},"the key (via popstring)"]},{"entry":[{},"create a node and assign it to the frame buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"MAKERETURN:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"take the value of the frame buffer, move it to the return"]},{"entry":[{},"value and exit the parse"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"It is to be understood that the specific embodiments of the invention that have been described are merely illustrative of certain applications of the principle of the present invention. Numerous modifications may be made to a system and method for bulk processing of semi-structured results streams from many different resources described herein without departing from the spirit and scope of the present invention. Moreover, while the present invention is described for illustration purpose only in relation to XML web services, the present invention may be applied to any network in which computers are interconnected and can communicate with one another. The present system can further be applied to one computer with many databases. Further, the application of the present invention toward query results or requests is presented for illustration purposes only. The present invention may be applied to any parallel processing of semi-structured streams of data."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The various features of the present invention and the manner of attaining them will be described in greater detail with reference to the following description, claims, and drawings, wherein reference numerals are reused, where appropriate, to indicate a correspondence between the referenced items, and wherein:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 3","FIGS. 1 and 2"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 4","FIGS. 4A and 4B","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 5","FIGS. 1 and 2"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
