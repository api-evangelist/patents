---
title: Notification protocol based endpoint caching of host memory
abstract: An endpoint device () is registered in association with a host memory address in response to receipt of a request for a notification of a change in content state of the host memory address from the endpoint device (). In response to a change in content state of the host memory address, a notification that the host memory address has changed content state is sent to the endpoint device (). In response to receipt of the notification by the endpoint device (), semantics associated with a change of content state of the host memory address by a data schema () is determined and an action is performed by the endpoint device () in accordance with the determined semantics.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08838907&OS=08838907&RS=08838907
owner: Hewlett-Packard Development Company, L.P.
number: 08838907
owner_city: Houston
owner_country: US
publication_date: 20091007
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","I. DEFINITION OF TERMS","II. OVERVIEW","III. EXEMPLARY NOTIFICATION PROTOCOL","IV. EXEMPLARY NOTIFICATION PROTOCOL BASED ENDPOINT CACHING OF HOST CACHE MEMORY USAGE MODELS","V. CONCLUSION"],"p":["Computer systems typically include a central processing unit (CPU), high-speed devices (e.g., host cache memory and graphics controllers), and peripheral buses (e.g., peripheral component interconnect (PCI) or PCI Express (PCIe) bus) and on-chip integrated peripheral components (e.g., network interface controller, universal serial bus ports, flash memory, and audio devices). Some computer systems have a host interface that includes a memory controller hub and an input\/output (I\/O) controller hub. The memory controller hub connects the CPU to the high-speed components of the computer system via a coherent interconnect, which may be implemented by a front side bus or a serial interface, such as QPI (Intel\u00ae QuickPath Interconnect) or cHT (coherent HyperTransport). The I\/O controller hub connects the memory controller hub to the peripheral buses and the integrated peripheral components via a hub interconnect. The peripheral components communicate with the I\/O controller hub in accordance with a peripheral bus protocol. For example, in modern Intel\u00ae hub architectures, peripheral components typically communicate with the CPU via the PCI communication protocol or the PCIe communication protocol.","The host cache memory (also referred to as a \u201ccache\u201d) is a local, high-speed memory that increases system performance by fetching and storing data that is located adjacent to the requested piece of data from a lower-level cache or a main memory. The host cache memory typically includes status bits that indicate the status of each cache line in order to maintain data coherency throughout the computer system. For example, in accordance with the \u201cMOESI\u201d cache coherency protocol, the status bits indicate the state of the associated cache line (e.g., owned (O), modified (M), exclusive (E), shared (S), or invalid (I)).","In many computer systems, data is transferred from the CPU to peripheral components using an I\/O operation that typically involves moving the data to the main memory, and then reading the data from the main memory by the CPU or the peripheral components. For example, in transferring output data from the CPU to an I\/O device, the CPU typically creates the output data, transfers the output data to the main memory, and stores pointers (also referred to as descriptors) to the output data in a known location. The CPU then issues a \u201cdoor bell\u201d event that notifies the I\/O device that the output data is ready to be transmitted. In response to the doorbell event, the I\/O device uses the pointers to transfer the output data from the main memory to the I\/O device. New processor and I\/O hub architectures allow transfers to occur directly from caches in addition main memory.","What are needed are apparatus and methods that provide improved I\/O communications with reduced CPU involvement.","In one aspect, the invention features a method in accordance with which an endpoint device is registered in association with a host memory address in response to receipt of a request for a notification of a change in content state of the host memory address from the endpoint device. In response to a change in content state of the host memory address, a notification that the host memory address has changed content state is sent to the endpoint device. In response to receipt of the notification by the endpoint device, semantics associated with a change of content state of the host memory address by a data schema is determined and an action is performed by the endpoint device in accordance with the determined semantics.","The invention also features apparatus operable to implement the method described above and computer-readable media storing computer-readable instructions causing a computer to implement the method described above.","In the following description, like reference numbers are used to identify like elements. Furthermore, the drawings are intended to illustrate major features of exemplary embodiments in a diagrammatic manner. The drawings are not intended to depict every feature of actual embodiments nor relative dimensions of the depicted elements, and are not drawn to scale.","A \u201ccomputer\u201d is any machine, device, or apparatus that processes data according to computer-readable instructions that are stored on a computer-readable medium either temporarily or permanently. An \u201coperating system\u201d is a software component of a computer system that manages and coordinates the performance of tasks and the sharing of computing and hardware resources. A \u201csoftware application\u201d (also referred to as software, an application, computer software, a computer application, a program, and a computer program) is a set of instructions that a computer can interpret and execute to perform one or more specific tasks. A \u201cdata file\u201d is a block of information that durably stores data for use by a software application.","A central processing unit (CPU) is an electronic circuit that can execute a software application. A CPU can include one or more processors (or processing cores). A \u201chost CPU\u201d is a CPU that controls or provides services for other devices, including I\/O devices and other peripheral devices.","The term \u201cprocessor\u201d refers to an electronic circuit, usually on a single chip, which performs operations including but not limited to data processing operations, control operations, or both data processing operations and control operations.","The term \u201cmachine-readable medium\u201d refers to any physical medium capable carrying information that is readable by a machine (e.g., a computer). Storage devices suitable for tangibly embodying these instructions and data include, but are not limited to, all forms of non-volatile computer-readable memory, including, for example, semiconductor memory devices, such as EPROM, EEPROM, and Flash memory devices, magnetic disks such as internal hard disks and removable hard disks, magneto-optical disks, DVD-ROM\/RAM, and CD-ROM\/RAM.","The \u201ccontent state\u201d of a memory address refers to the state of the contents stored at the memory address in a computer-readable medium.","\u201cHost cache memory\u201d refers to high-speed memory that stores copies of data from the main memory for reduced latency access by the CPU. The host cache memory may be a single memory or a distributed memory. For example, a host cache memory may exist in one or more of the following places: on the CPU chip; in front of the memory controller; and within an I\/O hub. All of these caches may be coherently maintained and used as sources\/destinations of DMA operations.","An \u201cendpoint\u201d is an interface that is exposed by a communicating entity on one end of a communication link.","An \u201cendpoint device\u201d is a physical hardware entity on one end of a communication link.","An \u201cI\/O device\u201d is a physical hardware entity that is connected to a host CPU, but is separate and discrete from the host CPU. An I\/O device may or may not be located on the same circuit board as the host CPU. An I\/O device may or may not be located on the same hardware die or package as the host CPU.","A \u201cPCIe Caching Agent\u201d (PCA) is a client subsystem that manages the caching of memory over PCIe using Rcoh protocol.","A \u201cPCIe Memory Agent\u201d (PMA) is a service subsystem that manages the exportation of cacheable memory over PCIe using Rcoh protocol.","Restricted Coherency (Rcoh) is a PCIe protocol that supports the caching of host cache memory across PCIe.","As used herein, the term \u201cincludes\u201d means includes but not limited to, and the term \u201cincluding\u201d means including but not limited to. The term \u201cbased on\u201d means based at least in part on.","The embodiments that are described herein provide improved I\/O communications with reduced CPU involvement. These embodiments leverage notification protocol based endpoint caching of host cache memory in order to reduce CPU involvement in I\/O communications. The cache-based notification protocol enables I\/O latency and consumed I\/O bandwidth to be reduced significantly. In addition, this protocol also enables direct signaling between host software and endpoint devices.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","b":["10","12","14","12","16","18","20","22"]},"The host interconnect  interconnects the processing core(s)  and the host cache memory . The host interconnect  may be implemented by any of a variety interconnection technologies. For example, in some embodiments, the host interconnect  may be implemented by a cross-bar switch fabric.","The host interface  connects the host CPU  to the endpoint device . The host interface  may be implemented by a variety of different interconnection mechanisms. For example, in accordance with an Intel\u00ae hub architecture, the host interface  is implemented by a memory controller hub and an I\/O controller hub that are linked by a hub interconnect. The memory controller hub connects the host CPU  to the higher-speed components of the computer system via a coherent interconnect (e.g., a front side bus or a serial interconnect) that is used to exchange information via a coherency protocol. The I\/O controller hub connects the memory controller hub to lower speed devices, including peripheral devices such as the endpoint device .","In general, the peripheral devices communicate with the I\/O controller hub in accordance with a peripheral bus protocol. Some of the peripheral devices may communicate with the I\/O controller hub in accordance with a standard peripheral communication protocol, such as the PCI communication protocol or the PCIe communication protocol. The peripheral bus protocols typically are multilayer communication protocols that include transaction, routing, link and physical layers. The transaction layer typically includes various protocol engines that form, order, and process packets having system interconnect headers. Exemplary types of transaction layer protocol engines include a coherence engine, an interrupt engine, and an I\/O engine. The packets are provided to a routing layer that routes the packets from a source to a destination using, for example, destination-based routing based on routing tables within the routing layer. The routing layer passes the packets to a link layer. The link layer reliably transfers data and provides flow control between two directly connected agents. The link layer also enables a physical channel between the devices to be virtualized (e.g., into multiple message classes and virtual networks), which allows the physical channel to be multiplexed among multiple virtual channels. The physical layer transfers information between the two directly connected agents via, for example, a point-to-point interconnect.","Other peripheral devices (including the endpoint device ) are configured to communicate with the I\/O hub controller in accordance with a notification protocol that enables these peripheral components to cache lines of the host cache memory  and be notified of any subsequent changes in the content state of the cached lines. The notification protocol enables the endpoint device  to cache data instead of transferring it over the peripheral bus for each access, thereby reducing I\/O latency and consumed bandwidth for some use models. Reducing I\/O bandwidth consumption also reduces host memory bandwidth consumption. The notification protocol also enables host software to signal the endpoint device  by updating a cacheline instead of performing programmed I\/O (PIO) operations, thereby avoiding high software overhead and synchronization and flow-control issues.","The entities that communicate in accordance with the notification protocol typically include respective agents that implement a modified version of a standard peripheral bus protocol (e.g., PCIe). In addition to implementing the functions of the standard peripheral bus protocol, these agents also are configured to manage the data that is cached by the endpoints. For example, in some embodiments, the endpoint  includes a caching agent that manages the cached data within the endpoint , and routing components and\/or the host CPU  include memory agents that track which lines of the host cache memory  have been cached. These agents typically may be located in any of a variety of different components of the endpoint device , the routing components, and the host CPU . In some embodiments, the host CPU  includes the memory agent in the host interface .","In some embodiments, the agents carry out PCIe transactions that include mechanisms for the endpoints to register an interest in particular cachelines (host memory addresses) and for the host CPU to notify the endpoints that the content states of the particular cachelines have changed. In some of these embodiments, the notification mechanism is implemented by a minor modification to the wire protocol that allows the caching agent in the endpoint  to inform the memory agent in the host CPU  that the device is interested in a particular cacheline. In some of these embodiments, the caching agent sets a bit in the transaction on the link connection with the memory agent. The memory agent interprets the set bit as a request to notify the caching agent in the endpoint device  of any change in the content state (e.g., change in contents) of a particular host memory address that is identified in an associated DMA access request (e.g., a read or write) that is described in the transaction. In response, the memory agent registers the endpoint device for notification in association with a change in content state of the host memory address. When the memory agent determines that the particular cacheline has been updated (e.g., a new value has been written to it), the memory agent identifies all the entities that have registered an interest in that cacheline and generates a respective notification message for each of the endpoints that are interested in the cacheline whose content state changed. The message typically simply indicates that the state of the contents of the particular cacheline has changed.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["14","24","14","26","14","14","28"]},"As explained in detail below, a wide variety of usage models may be implemented based on the lightweight notification enabled by the notification protocol. For example, one or more entities that are configured to communicate in accordance with the notification protocol may coordinate their actions through a shared data schema that associates a set of addresses in the host cache memory with semantics that give meaning to notifications of changes in the content states of the host memory addresses. For example, a change of content state notification for a particular host memory address may trigger any of the following actions by the receiving entity: advance to next work request, obtain the next block of memory for data movement, advance to the next round of calculation, and return a result of a calculation. Individual usage models may adopt one or more possible semantics being allowed for a given data schema; for example, updates to one portion of a data schema translate into semantic A, while updates to a different portion translate into semantic B. Usage models can take advantage of a wide range of semantics to either accelerate calculations, reduce the processor\/memory bus utilization, and so forth, which can lead to more efficient operation and potential power savings, among other benefits.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3","FIG. 1"],"b":["30","10","32","38","34","36","38","40","42","42","42","42"]},"The application  implements a particular usage model by calling functions or services through application programming interfaces (APIs) provided by the library . In response, the library generates a series of API calls that are read by the device driver . In this process, the device driver  programs the endpoint device  with the base address of the data schema . The endpoint device  reads the data schema  in order to determine the semantics that respectively are associated with notifications that the content states particular host memory addresses have changed. For example, in some embodiments, the data schema  may indicate that: a content state change notification associated with the offset address X from the base address means that the data schema  should be read at that address and the action A should be taken; a content state change notification associated with the offset address Y from the base address means that the data schema  has been updated and the action A should be taken; and a content state change notification associated with the offset address Z from the base address means that the results of a calculation should be written back to offset address Z from the base address and to inform another endpoint device that the results are ready for processing.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4","FIG. 4"],"b":["43","40","14","40","44","45","46","47","48","49"]},"A. Overview","As explained above, the notification protocol enables peripheral endpoint devices to cache lines of the host cache memory  and be notified of any subsequent changes in the content state of the cache lines. This section describes an exemplary notification protocol (referred to herein as the \u201cRestricted Coherency\u201d or \u201cRcoh\u201d protocol) that corresponds to an augmented version of the PCIe protocol (see, e.g., PCI-Express\u2122 Base Specification version 2.0, Dec. 20, 2006, the entirety of which is incorporated herein by reference).","The Rcoh protocol enables the caching of memory across a PCIe interconnect. Specifically, endpoints are enabled to cache host memory cachelines (also referred to herein as \u201clines\u201d), and be notified if some entity (e.g., a CPU or a device) writes to a line that the endpoint has cached. While the protocol permits multiple endpoints to cache any given line concurrently, the protocol is restricted in the sense that an endpoint is never given exclusive ownership of a line, so the protocol alone can't coordinate concurrent updates by multiple writers.","The Rcoh protocol is implemented by a PCIe Caching Agent (PCA) in an endpoint and a PCIe Memory Agent (PMA) in the host system. A PCA is a client subsystem in an endpoint that manages the caching of memory over PCIe. A PMA is a service subsystem in the host that exports cacheable memory over PCIe. The Rcoh protocol provides a notification service for when a cacheline is modified. For reads, a PCA sends an Rcoh Read to a Memory Space range that has an associated PMA, requesting a copy of a cacheline or \u201cline\u201d. The PMA returns the requested line to the PCA and records that the PCA has a cached copy of the line. Later, the PMA notifies the PCA via an Rcoh Invalidation Message if another entity updates the line, so the PCA can invalidate its copy of the line. A similar notification service exists for writes, where a PCA writing a line can request to be notified later if the line is updated.","Rcoh is a restricted coherency protocol in that PCAs are never given exclusive ownership of a line. Rcoh protocol permits multiple PCAs each to have a shared copy of any given line concurrently, but Rcoh protocol doesn't coordinate updates performed by multiple writers. An endpoint with PCA is permitted to write to a line at any time, regardless of whether the PCA has a pending notification for that line. If coordination between multiple writers is required, it must be accomplished by other protocols, which are outside the scope of this specification.","The Rcoh notification protocol defines Rcoh Reads and Rcoh Writes, which are similar in most respects to PCIe Memory Reads and PCIe Memory Writes, respectively. The most notable difference is that Rcoh Reads\/Writes result in the endpoint being notified via the host sending an Rcoh Invalidate Message if a cached line is updated in the future. In some embodiments, the protocol supports two cacheline sizes (CLSs), 64 bytes and 128 bytes. Support for each CLS is optional, both for hosts and for endpoints.","Rcoh protocol support is optional normative, and is applicable to root complexes (RCs), Switches, and components with Endpoint Functions. Rcoh routing support is not applicable to PCIe to PCI\/PCI-X Bridges. Rcoh protocol is architected for device-to-host Memory Requests, and should be enabled by software only if the Endpoint, RC, and all intermediate routing elements support the necessary Rcoh capabilities.","Endpoints with Rcoh Requester capability must support generating Rcoh Read Requests, Rcoh Write Requests, or both. Such endpoints must also support receiving Rcoh Invalidation Messages, and invalidate any cached lines accordingly. The PCA manages the cached data within the endpoint.","Routing elements (Switches and RCs) with Rcoh routing capability must support the proper forwarding of Rcoh Read and Rcoh Write Requests. Such routing elements must also forward Rcoh Invalidate Messages properly, including a directed version that targets a single endpoint plus a broadcast version that targets all components below a given Root Port. Downstream Ports must block any Rcoh Read or Rcoh Write Requests that attempt to go Downstream, reporting a new Rcoh Egress Blocked error in AER (Advanced Error Reporting; see below).","Root complexes (RCs) with Rcoh Completer capability must support receiving Rcoh Read and Rcoh Write Requests, and generating Rcoh Invalidate Messages as appropriate. One or more PMAs in the RC or the host track which lines have been cached by endpoints.","Software that supports Rcoh protocol discovers which components support Rcoh protocol and which CLSs they support. If the host, endpoints, and routing elements support the necessary Rcoh capabilities, software enables the endpoints to use Rcoh protocol, specifying which CLS to use.","B. Basic Rcoh Protocol",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 5","FIG. 5"],"b":"50"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 6B"},"A PMA will send an Rcoh Invalidate Message either if a cached line is written by some entity (e.g., a CPU or a device) or if the PMA is simply no longer going to track the content state of that line.  shows an exemplary embodiment of a Rcoh invalidate message . An EV bit in the Rcoh Invalidate message  indicates whether the Message was sent due to an eviction (EV is Set) or due to the line being written (EV is Clear). Once the PMA sends an Rcoh Invalidate for a line, it will not send an additional Rcoh Invalidate for that line unless it receives a new Rcoh Read or Rcoh Write Request.","If a Requester with a pending notification for a line sends a new Rcoh Read or Rcoh Write Request for that same line, the Requester generally cannot determine if a subsequent Rcoh Invalidation it receives for that line was for the most recent Rcoh Read\/Write Request or for a previous one. Rcoh protocol by itself is not sufficient for a PCA to implement a coherent write-through cache, due to the response-less nature of Rcoh Invalidates.","C. Rcoh Protocol Summary","The following describes the rules and requirements for the Rcoh protocol plus some unique requirements.\n\n","D. Rcoh Protocol Ordering Considerations","Rcoh Read Requests have the same ordering requirements as PCIe Memory Read Requests, and Rcoh Write Requests have the same ordering requirements as PCIe Memory Write Requests. Completions for Rcoh Reads have the same ordering requirements as Completions for PCIe Memory Reads.","Transaction ordering rules permit an Rcoh Invalidate Message to pass a Read Completion. Logically, an Rcoh Requester might assume that the Completion for an Rcoh Read Request will always arrive before an Rcoh Invalidate associated with the same Rcoh Read Request arrives. However, since the Rcoh Invalidate might pass the Completion, the Requester must not make this assumption.","Since Requesters must not assume that a Completion always arrives before an associated Rcoh Invalidate, the Completer for an Rcoh Read Request is permitted to send the Completion and its associated Rcoh Invalidate in either order.","Rcoh protocol by itself is sufficient for a PCA to implement a coherent read-only cache. For the case where a PMA has an outstanding Rcoh Read, and an Rcoh Invalidate for that Read arrives before the associated Completion, the PMA should not cache the data when it arrives. However, for some use models, it still may make sense to use the returned data immediately when it arrives.","E. Rcoh Software Configuration","In some embodiments, the Rcoh protocol supports two cacheline sizes (CLSs)\u201464 bytes and 128 bytes. Support for each CLS is optional, both for Root Complexes and endpoints. The CLS in use by the system is determined by the host, and is indicated by the Rcoh System CLS field in applicable Root Ports and RCRBs. All Root Ports and RCRBs that indicate Rcoh Completer support should indicate the same CLS, else the results are undefined. The host should not change the Rcoh System CLS while any operating system is running, else the results are undefined.","Endpoints supporting the Rcoh protocol can support either or both CLSs, and indicate which they support via the Rcoh-64 Requester Supported and Rcoh-128 Requester Supported capability bits. Before enabling each Rcoh Requester, software should ensure that the associated Rcoh Requester CLS control bit is configured to match the Rcoh System CLS, else the results are undefined. An Rcoh Requester that supports only one CLS is permitted to hardwire its Rcoh Requester CLS control bit to the corresponding value.","Software should not change the value of the Rcoh Requester CLS control bit in a Requester unless its Rcoh Requester Enable control bit is Clear, and it has no lines cached; otherwise, the results are undefined.","Software should not enable a given Rcoh Requester unless all routing elements between it and the host support Rcoh routing capability. Otherwise, any routing elements without Rcoh routing capability will handle any received Rcoh Requests as Malformed TLPs.","F. Capabilities and Controls","Four new bits in the PCIe Device Capabilities  register permit software to discover Rcoh Requester capabilities in endpoints, Rcoh routing capability in routing elements, and Rcoh Completer capabilities in the host.",{"@attributes":{"id":"p-0081","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DEVICE CAPABILITIES 2 REGISTER"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"AT-"]},{"entry":["BIT",{},"TRIB-"]},{"entry":["LOCATION","REGISTER DESCRIPTION","UTES"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[". . .",". . .",". . ."]},{"entry":["24","Rcoh-64 Requester Supported - Applicable only","RO"]},{"entry":[{},"to endpoints; must be 0b for all other Function"]},{"entry":[{},"types. This bit must be set to 1b if the endpoint"]},{"entry":[{},"supports Rcoh protocol for 64-byte cachelines as"]},{"entry":[{},"a Requester. See Section 6.x.3 for additional"]},{"entry":[{},"details."]},{"entry":["25","Rcoh-128 Requester Supported - Applicable only","RO"]},{"entry":[{},"to endpoints; must be 0b for all other Function"]},{"entry":[{},"types. This bit must be set to 1b if the endpoint"]},{"entry":[{},"supports Rcoh protocol for 128-byte cachelines"]},{"entry":[{},"as a Requester."]},{"entry":["26","Rcoh Routing Supported - Applicable only to","RO\/"]},{"entry":[{},"Switch Upstream Ports, Switch Downstream","HwInit"]},{"entry":[{},"Ports, and Root Ports; must be 0b for other"]},{"entry":[{},"Function types. This bit must be set to 1b if the"]},{"entry":[{},"routing element supports Rcoh protocol."]},{"entry":[{},"This bit is HwInit for Root Ports and RO for all"]},{"entry":[{},"other Function types."]},{"entry":[{},"All Ports of a Switch must have the same value"]},{"entry":[{},"for this bit."]},{"entry":["28-27","Rcoh System CLS - Applicable only to Root","HwInit"]},{"entry":[{},"Ports and RCRBs; must be 00b for all other"]},{"entry":[{},"Function types. This field indicates if the Root"]},{"entry":[{},"Port or RCRB supports Rcoh protocol as a"]},{"entry":[{},"Completer, and if so, what cacheline size is used."]},{"entry":[{},"Encodings are:"]},{"entry":[{},"00b Rcoh Completer capability is not"]},{"entry":[{},"supported"]},{"entry":[{},"01b Rcoh Completer with 64-byte cachelines"]},{"entry":[{},"in use"]},{"entry":[{},"10b Rcoh Completer with 128-byte cachelines"]},{"entry":[{},"in use"]},{"entry":[{},"11b Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Two new bits in the Device Control  register permit software to enable Requesters to use Rcoh protocol, specifying which CLS to use. Downstream Ports block any Rcoh Read or Rcoh Write Requests that attempt to go Downstream, reporting a new Rcoh Egress Blocked error in AER.",{"@attributes":{"id":"p-0083","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DEVICE CONTROL 2 REGISTER"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"AT-"]},{"entry":["BIT",{},"TRIB-"]},{"entry":["LOCATION","REGISTER DESCRIPTION","UTES"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[". . .",". . .",". . ."]},{"entry":["11","Rcoh Requester Enable - Applicable only to","RW"]},{"entry":[{},"endpoints that indicate support for Rcoh protocol"]},{"entry":[{},"as a Requester; otherwise must be hardwired to"]},{"entry":[{},"0b. See Section 6.xx."]},{"entry":[{},"When this bit is Set, the endpoint is enabled to"]},{"entry":[{},"operate as an Rcoh protocol Requester."]},{"entry":[{},"Default value of this bit is 0b."]},{"entry":["12","Rcoh Requester CLS - Applicable only to","RW"]},{"entry":[{},"endpoints that indicate support for Rcoh protocol"]},{"entry":[{},"as a Requester; otherwise must be hardwired to"]},{"entry":[{},"0b. This bit controls or indicates the cacheline"]},{"entry":[{},"size used with Rcoh protocol by this Requester."]},{"entry":[{},"See Section 6.x.3 for restrictions on modifying"]},{"entry":[{},"this bit."]},{"entry":[{},"If this bit is Clear, the cacheline size is 64 bytes."]},{"entry":[{},"If this bit is Set, the cacheline size is 128 bytes."]},{"entry":[{},"If this Rcoh Requester supports only one"]},{"entry":[{},"cacheline size, this bit is permitted to be"]},{"entry":[{},"hardwired to indicate that size. Otherwise, the"]},{"entry":[{},"default value of this bit is 0b."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"A. Introduction","The embodiments of the notification protocol described herein provide a wide variety of different opportunities to eliminate software overhead, enable new communication paradigms (e.g., parallel, lock-free communications), and enable new solution approaches (e.g., use of canonical device definitions (e.g., USB\/class driver styles) that leverage the more direct hardware access that is possible using the notification protocol, thereby eliminating the traditional device driver in the main data path. This section describes several exemplary usage models that are enabled by the embodiments of the notification protocol that are described herein.","B. Usage Model\u2014Graphics",{"@attributes":{"id":"p-0087","num":"0107"},"figref":["FIG. 8","FIG. 1"],"b":["54","56","12","58","22","12","60","62","62","58"]},"In operation, the graphics processing unit  registers interest in a set of memory cachelines that a user mode application makes available to the graphics processing unit  in accordance with a data schema. The application program issues work requests to the graphics processing unit . Instead of transferring data to and from memory via programmed I\/O through the host CPU I\/O ports (which entails ringing doorbells), the application directly accesses the graphics processing unit  via Rcoh protocol notification messages. This allows the application to constantly generate work requests and constantly check the specified cachelines to see if work was completed by the graphics processing unit , as if the graphic processing unit  were completely available to the application. In this mode of operation, however, the resources of the graphics processing unit  are never exposed to the user mode application, eliminating the risk of failures that otherwise might be caused by application writes to incorrect memory addresses. Instead, the user mode application writes to a cacheline to indicate that it has finished a work request or that it has finished consuming the results data written by the graphics processing unit  to the specified host memory address. For example, in some embodiments, the data schema specifies that the semantics associated with the cacheline written to by the PMA in the I\/O hub  is associated with a semantic that means that the host memory address is free. Whenever the PMA writes to the host memory address, the PMA generates a Rcoh notification that indicates that cacheline buffer has been freed, and the graphics processing unit  is free to use it or repurpose it in accordance with the data schema. In this way, the graphics processing unit  can act as if it were completely available to the user mode application without having to expose its resources.","In another exemplary embodiment, the data schema may specify that the notification means that the application has finished consuming the cacheline and that the graphics processing unit  should write new data to the cacheline. In response to receipt of the notification by the graphics processing unit , the graphics processing unit  sends a request to write data to the host memory address. In response to receipt of the request to write the data by the PMA, the PMA writes the data to the host memory address and, in response, sends a notification to the application that the content state of the host memory address has changed. In response to receipt of the notification by the application, the application sends a request to read the data written to the host memory address.","Other data schemas can be defined to achieve a variety of other interactions and behaviors between the host CPU  and the graphics processing unit .","C. Usage Model\u2014High-Speed I\/O",{"@attributes":{"id":"p-0092","num":"0112"},"figref":["FIG. 9","FIG. 1"],"b":["64","66","12","68","22","12","70","72","72","68"]},"In operation, the network interface controller  registers interest in a set of memory cachelines that a user mode application makes available to the network interface controller  in accordance with a data schema. The application program issues work requests to the network interface controller . Instead of having to move lots of context (a set of memory cache lines that store network state information) to understand state of the connection and how to update it, the application directly accesses the network interface controller  via Rcoh protocol notification messages. This allows the application to only move cache lines that have changed instead of having to pull down the entire context. For example, in this mode of operation, the application provides the network interface controller the work  request pointer to the context element currently being worked on and the sequence number that indicates where the application is in the stream of bytes being transferred. The application stores the pointer and the sequence number values in a particular cacheline that is specified by the data schema, and the network interface controller  only needs to pull down the particular cacheline that contains these two data values. In this way, memory bandwidth consumed for each I\/O is reduced because the application only needs to tell the network interface controller  where the data has been placed. The network interface controller  does not have to request a DMA read in order to retrieve the work request for completion nor does it have to request subsequent DMA reads in order to retrieve the actual data. Instead, the network interface controller  is able to DMA read the data stream directly, allowing the network interface controller  to transfer the data more efficiently and quickly.","In this mode of operation, the network interface controller  receives a Rcoh notification that the pertinent data has been updated and interprets the notification as a work request to read the pointer and sequence number values from the cacheline designated by the schema. Based on these values, the network interface controller  can determine the data block to move.","For example, in some embodiments, the data schema specifies that the semantics associated with the particular host memory address means that the host cache memory contains a pointer to a data storage location and that a fixed-sized chunk (e.g., 1 kilobyte chunk) of data offset from the pointer is to be moved. The network interface controller  tracks pointers and every time it sees a new pointer value the network interface controller  automatically reads a fixed-size chunk of data offset from the pointer and transmits that chunk. In one exemplary embodiment, the PMA receives from the application a request to write the pointer to the host memory address and, in response, the PMA writing the pointer to the host memory address and sends a notification to the network interface controller  that the content state of the host memory address has changed. In response to receipt of the notification by the PCA, the network interface controller  sends a request to read the host memory address to the PMA. In response to receipt of the request to read, the PMA sends a copy of the pointer from the host memory address to the network interface controller  and sends a notification that the host memory address has changed to the application. In response to receipt of the copy of the pointer by the PCA, the network interface controller  moves the fixed-sized chunk of data offset from the pointer.","Other data schemas can be defined to achieve a variety of other interactions and behaviors between the host CPU  and the network interface controller unit .","D. Usage Model\u2014Embedded Devices",{"@attributes":{"id":"p-0098","num":"0118"},"figref":["FIG. 10","FIG. 1"],"b":["74","76","12","78","80","82","84","22","12","86","88","78","80","72","82","84","88","90","72","90","78","84","78","84","88"]},"In operation, each of the embedded devices - registers interest in a set of memory cachelines in accordance with a data schema. The Rcoh notification protocol together with the data schema can enable a wide variety of interactions between the embedded devices without having to support peer-to-peer interactions and without having to manage vendor relationships. In particular, all the embedded devices - simply use the data structures defined in the data schema and use the Rcoh protocol to communicate with each other in accordance with the semantics specified in the data schema via updates to the host memory addresses. This allows the devices to interact with one another without having to display confidential information.","In one exemplary embodiment, the data schema specifies that the semantics associated with a particular host memory address means that the host memory address contains a pointer to data to be processed and that the processed data is to be written back to another host memory address. A first one of the endpoint devices - may register an interest in the particular host memory address. The PMA may receive from a second one of the endpoint devices - a request to write the pointer to the particular host memory address. In response, the PMA writes the pointer to the host memory address, registers the second endpoint device in association with the host memory address, and sends a notification to the first endpoint device that the content state of the host memory address has changed. In response to receipt of the notification by the first endpoint device, the PCA on the first endpoint device sends a request to read the host memory address. In response to receipt of the request to read the host memory address, the PMA sends a copy of the pointer from the host memory address to the first endpoint device and sends a respective notification that the host memory address has changed to each entity that is registered in association with the host memory address. In response to receipt of the copy of the pointer by the first endpoint device, the first endpoint device processes the data referenced by the pointer to produce processed data and sends a request to write the processed data to the other host memory address. The PMA receives the request to write the processed data to the other host memory address. In response, the PMA writes the processed data to the other host memory address and sends a respective notification that the other host memory address has changed to each entity that is registered in association with the other host memory address.","The interactions described in the preceding paragraph can be used and optionally extended to coordinate a variety of different interactions between the embedded endpoint devices -. For example, in one exemplary embodiment, an embedded Ethernet device receives a frame. The Ethernet device determines that the frame is encrypted and, based on the data schema, writes a pointer to the frame to an appropriate host memory address that is registered in associated with an embedded encryption device. In response to the resulting content state change notification, the encryption device reads the pointer, retrieves the frame, decrypts the frame, and writes the decrypted frame to a host memory address designed by the data schema. The Ethernet device is notified via a Rcoh notification message that the decrypted frame has been written to the designated host memory address. At this point, the Ethernet device may hand off the decrypted frame to another embedded device, hand it up to a user mode application, or send it out over a network.","Other data schemas can be defined to achieve a variety of other interactions and behaviors between the host CPU  and the embedded endpoint devices -.","E. Usage Model\u2014Far-Memory Attach",{"@attributes":{"id":"p-0104","num":"0124"},"figref":["FIG. 11","FIG. 1"],"b":["92","94","12","96","96","22","98","100","96","102","100","104","72","96","96","106"]},"In one exemplary embodiment, the memory device  registers interest in a set of memory cachelines (including a particular host memory address) in accordance with a data schema that establishes a shared memory segment whereby multiple discrete coherency domains or multiple processes are using the shared memory as a communication medium. As with the other usage models, the data schema associates semantics with a given update. The CPU  may update the particular host memory address. In response to the notification that the particular host memory address has been updated, the memory device  may read data from the host memory address and transmit the read data to another CPU in accordance with the semantics associated with the notification.","In one exemplary embodiment of the computer system arrangement , multiple host CPUs (e.g., in the form of blade servers) are attached to the PCIe switch-based topology and the far memory is exported up to each server as memory mapped I\/O space such that a processor can access this memory via a load-store paradigm. The processor uses data mover technology such that data is copied into\/out of the far memory either by a data mover or a DMA Master engine (e.g. an I\/O device), which is programmed to perform the actual data transfer. As with the embedded devices usage model described above, when one server updates memory, notifications are automatically generated down to the device that runs the far memory. When the device receives a content state change notification, one exemplary semantic associated with the notification is to read data from the server generating the notification and then transmit that data to another server. In this way, the far memory acts not only like a shared memory segment but also as a message-passing interface without processor involvement.","F. Usage Model\u2014Distributed Applications",{"@attributes":{"id":"p-0108","num":"0128"},"figref":"FIG. 12","b":["110","112","114","116","118","120","122","124","126","112","114","116","126","112","114","116","126","128","116","126","114","116"]},"The computer system arrangement  corresponds to another example of using the far memory attach usage model described above. In this case, there is no longer a need to have to have high-speed cluster interconnect between the CPUs , . Instead, the CPUs ,  can all use the Rcoh notification mechanism to communicate with one another, and when memory changes a respective one of the storage devices can proxy between the CPUs ,  in order to implement an interaction specified by the controlling data schema.","The Rcoh notification mechanism avoids message passing overhead and eliminates complex communication paradigm. This approach allows high-speed solid state device or memristor based storage to be accessible by multiple nodes. In operation, an application touches memory location in order to cause Rcoh notifications to be sent out and the storage devices pull application memory without further software involvement. The storage devices determine which CPU should be informed of change in content state and issues notifications to the appropriate nodes. This approach also allows for optional direct placement into node memory or waits for subsequent storage read.","The Rcoh notification approach eliminates complex communication channel configuration and management. It also eliminates scaling bottlenecks (e.g., process\/thread scheduling) that defeat the purpose of a low-latency message exchange, eliminates software overhead and maintenance, and simplifies communication while enabling data persistence so less chances for faults or hardware failures (e.g., through lower CAPEX\/OPEX)","G. Usage Model\u2014Virtualization",{"@attributes":{"id":"p-0113","num":"0133"},"figref":"FIG. 13","b":["130","132","134","136","132","134","136"]},"In this embodiment, the virtualized device driver  exposes guest memory to endpoint device  (assuming IOMMU available for isolation\/translation). In particular, the virtualized device driver  exposes a canonical virtualized device representation. This representation may be a de facto\/industry standard memory layout of the main data path elements such that the focus is on work request definition. The non-main data path is maintained within the hypervisor , which handles resource management, error handling, and hardware access control, among other standard hypervisor tasks. The virtualized device driver  prevents direct exposure of device-specific functionality within the guest and prevents direct exposure of device-specific resources within the guest. The Rcoh notification approach enables the endpoint device  to read and process work request translating to device-specific as needed. The Rcoh notification approach avoids the need for the guest OS to execute a device-driver. In addition, there is no software to manage or integrate.","In operation, the virtualized device driver  creates canonical virtual work requests\/posts to a Rcoh accessible exposed work queue. The posting to the work queue triggers memory content state change in accordance with the data schema and triggers the corresponding Rcoh protocol notifications. The endpoint device  refreshes memory to acquire the virtualized work queue entry  (VWQE). The endpoint device transforms the VWQE into a device-specific work queue entry  (WQE). The endpoint device  executes the WQE DMAr\/DMAw to guest memory. The VDD management channel  is used to interact with hypervisor . The hypervisor includes an independent hardware vendor (IHV) specific management device driver  (IHVM), which is used to access device-specific hardware structures and services.","During guest migration, the virtualized device driver  keeps the guest I\/O resources in canonical form. All memory and control is migrated to the new target. At the target, the virtualized device driver management channel  is used to bind the target's guest information including I\/O guest memory to the target hardware. The IHVM  works in conjunction with the hypervisor  and the VDD  to provide all device-specific configurations.","As described above, the Rcoh notification approach allows the endpoint device to export its resources to the guest OS through Rcoh notifications that have the semantics defined in a data schema (e.g., an Ethernet schema). An application executing on the guest OS communicates with the endpoint device  in accordance with the data schema in order to manipulate data or control the endpoint device  (e.g., to cause an Ethernet frame to be moved or a storage buffer to be moved). The Rcoh notification protocol abstracts away the underlying hardware of the endpoint device . The endpoint device  simply registers interest in the pertinent host memory addresses specified in the data schema without having to export all its hardware resources. This allows an application executing on the guest OS to have direct access to the endpoint device  (as if a device driver were operating on the guest OS) without having to put device driver in guest. Instead, the application communicates with a canonical representation of the endpoint device . When the application updates a particular host memory address defined in the data schema, the endpoint device  has been configured to know that in canonical form when that address has been manipulated, the endpoint device  performs a particular task (e.g., generate a particular transaction out the Ethernet).","H. Usage Model\u2014Checkpoint Restart",{"@attributes":{"id":"p-0119","num":"0139"},"figref":"FIG. 14","b":["150","152","154","156","158","160","162","164","166","168","156","162","164","166","156","166","152","154"]},"In operation, the CPUs ,  operate in parallel on a particular application. Periodically, a snapshot is taken of the execution state of the application in each of the CPUs , . Each snapshot is stored in a respective one of the non-coherent solid state memory devices -. The solid state memory view of each CPU ,  is made available to other CPUs as needed by reconfiguring the solid state storage devices to be an I\/O device under another core. This allows the other CPU to repopulate its application state by replaying events to re-synchronize the other CPU back into a full application core set. This enables the application to proceed with only moderate degradation for a limited period of time rather than requiring a complete restart of all the cores and then, as the state restored, enable all application cores to operate at full speed.","As soon as all the CPUs ,  have backed-up the respective application execution state data to the local solid state storage devices , , the CPUs ,  can resume execution of the application. The execution states stored on the solid state storage devices - are asynchronously backed-up to the secure long-term data storage devices , . If a failure occurs, the CPUs can read back (restart) the data corresponding to the last snapshot from the long-term storage devices , . The Rcoh notification protocol is used to transfer the application execution state data from the solid state memory devices - to the long-term storage devices , . In particular, each of the solid state","The storage devices - communicate using the Rcoh notification protocol in order to transfer the storage application state data from the solid state storage devices - to the long-term storage devices -. In operation, each of the storage devices - registers interest in respective sets of host memory addresses in accordance with a data schema. The Rcoh notification protocol together with the data schema enable the storage application state data to be transferred from the solid state storage devices - to the long-term storage devices - without having to support peer-to-peer interactions and without having to manage vendor relationships. Instead, all the storage devices - simply use the data structures defined in the data schema and use the Rcoh protocol to communicate with each other in accordance with the semantics specified in the data schema via updates to the host memory addresses. In this process, the solid state storage devices - use host cache memory to push the data to the long-term storage devices -, where long-term storage device drivers on the host systems write the data out to the interface controller of the long-term storage devices , .","I. Usage Model\u2014Power Management","In some embodiments, the Rcoh notification protocol is used to implement a power management process in which a host CPU can communicate its power state to one or more endpoint devices. In these embodiments, a data schema specifies that the semantics associated with one or more host memory addresses means that the host CPU is operating in one or more power states. In operation, the endpoint devices register an interest in the host memory addresses designated by the data schema. Whenever the host CPU determines that it is time to enter a particular one of the power states, the host CPU updates the host memory address associated with the particular power state. The PMA operating on the host CPU sends a notification to each of the endpoint devices registered in association with the updated host memory address. In response to the receipt of the notification, each endpoint device translates the notification into an action in accordance with the power state of operation of the host processor and the endpoint performs the action.","In some embodiments, each of the host memory addresses specified in the data schema corresponds to a different functional area or represents a host or device resource set (creates a more scalable solution). Each address also may indicate what degree of endpoint device wake-up is implied. For example, if the addresses represented work queue depth, the device could perform a partial wake up for a shallow depth or a full wake up if the depth is deep. The power management schema could also be tied into the power savings associated with an external link. For example, if the device is only partially waking up, the external link may operate at a lower bandwidth rate while if it is fully awake, the device may want to bring the link up to full bandwidth. In some embodiments, the endpoint device optionally writes to a memory location indicating it is entering a low-power state.","In some embodiments, user mode applications or the operating system executing on the host system check the memory locations specified in the data schema before determining whether to signal a wake up or just to validate device status. When the application\/OS become active, they update the a priori memory address, which causes a Rcoh notification to be generated waking up the device","Among the advantages of this usage model are the following. User mode applications and the operating system can unaware of device-specific control structures; they only need to comprehend memory addresses and update accordingly. This is also ideal for a virtualized environment since the hardware-specifics are not exposed to the guest OS. This approach does not stall the processor, which otherwise would have to wait for the endpoint device to power up, etc. in order to complete an operation, such as a PIO write. This usage model is scalable in that multiple devices could be notified from a single update or selectively updated. This would allow a complex system to tailor its power consumption saving power and money for customers. Rcoh memory addresses can also be used to comprehend what system memory is powered up and being accessed by I\/O devices.","The embodiments that are described herein provide improved I\/O communications with reduced CPU involvement. These embodiments leverage notification protocol based endpoint caching of host cache memory in order to reduce CPU involvement in I\/O communications. The cache-based notification protocol enables I\/O latency and consumed I\/O bandwidth to be reduced significantly. In addition, this protocol also enables direct signaling between host software and endpoint devices.","Other embodiments are within the scope of the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
