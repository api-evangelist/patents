---
title: Method and system for implementing programmable texture lookups from texture coordinate sets
abstract: A method and system for implementing programmable texture lookups from texture coordinate sets. The method includes the step of generating a plurality of texture coordinates using a shader module. The shader module executes floating point calculations on received pixel data to generate the texture coordinates. A plurality of texture values are fetched using the texture coordinates. The fetching is performed by a texture unit coupled to receive the texture coordinates from the shader module. The fetching of the texture values is programmable with respect to the texture coordinates such that the number of texture coordinates are decoupled from the number of textures.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07109999&OS=07109999&RS=07109999
owner: nVidia Corporation
number: 07109999
owner_city: Santa Clara
owner_country: US
publication_date: 20030529
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The field of the present invention relates to computer graphics. More particularly, the present invention relates to texture operations in a computer graphics processing pipeline.","Recent advances in computer performance have enabled graphic systems to provide more realistic graphical images using personal computers and home video game computers. In such graphic systems, some procedure must be implemented to \u201crender\u201d or draw graphic primitives to the screen of the system. A \u201cgraphic primitive\u201d is a basic component of a graphic picture, such as a polygon, e.g., a triangle, or a vector. All graphic pictures are formed with combinations of these graphic primitives. Many procedures may be utilized to perform graphic primitive rendering.","Early graphic systems displayed images representing objects having extremely smooth surfaces. That is, textures, bumps, scratches, or other surface features were not modeled. In order to improve the quality of the image, texture mapping was developed to model the complexity of real world surface images. In general, texture mapping is the mapping of an image or a function onto a surface in three dimensions. Texture mapping is a relatively efficient technique for creating the appearance of a complex image without the tedium and the high computational cost of rendering the actual three dimensional detail that might be found on a surface of an object.","Prior Art  illustrates a graphics pipeline with which texture mapping may be performed. As shown, included is a transform engine , a set-up module , a rasterizer , a texture math module , a level of detail (LOD) calculator , a texture fetch module , a texture filter  and a texture combination engine . It should be noted that the transform engine  and set-up module  need not necessarily be required in the graphics pipeline of a graphics integrated circuit.","During operation, the transform engine  may be used to perform scaling, rotation, and projection of a set of three dimensional vertices from their local or model coordinates to the two dimensional window that will be used to display the rendered object. The setup module  utilizes the world space coordinates provided for each triangle to determine the two dimensional coordinates at which those vertices are to appear on the two dimensional window. Prior Art  illustrates the coordinates  of the vertices  which define a triangle . If the vertices  of the triangle  are known in screen space, the pixel positions vary along scan lines within the triangle  in screen space and may be determined.","The setup module  and the rasterizer module  together use the three dimensional world coordinates to determine the position of each pixel contained inside each of the triangles. Prior Art  illustrates a plurality of pixels  identified within the triangle  in such a manner. The color values of the pixels in the triangle  vary from pixel to pixel in world space. During use, the setup module  and the rasterizer module  generate interpolated colors, depth and texture coordinates. The setup module  and the rasterizer module  then feed the pixel texture coordinates to the texture math module  to determine the appropriate texture map colors. In particular, texture coordinates are generated that reference a texture map using texture coordinate interpolation which is commonly known to those of ordinary skill in the art. This is done for each of the pixels  identified in the triangle . Prior Art  illustrates texture coordinates  for the pixels  identified within the triangle .","Next, a LOD calculation is performed by the LOD calculator . Generally, a level of detail (LOD) calculation is used to determine whether a displayed image will be a magnified or minified representation of the texture map. For example, in some occasions, one texel, or texture element, will correspond directly to a single pixel that is displayed on a monitor, where the texel is neither magnified nor minified. In other occasions, the texture map is magnified, where multiple pixels will represent a single texel, or minified, where a single pixel represents multiple texels.","After the LOD calculation, the texture coordinates generated by the texture math module  are used to fetch the appropriate texture map colors using the texture fetch module . These texture map colors are then filtered by the texture filter module . The combiner engine  combines together the various colors and textures fetched by the texture fetch module  and filtered by the texture filter module .","A problem exists with the prior art rendering pipeline described above, with respect to the fact that the hardware of the pipeline is optimized to support an essentially linear topology. Prior art type linear pipelines, and other simplistic non-linear pipelines, tightly couple texture fetch operations with the texture calculation operations. For example, in a given rendering pass, one texture calculation (e.g., texture coordinate calculation) is used to fetch one corresponding texture. Even with parallel texture calculation and fetches, the texture calculations are tightly coupled with their corresponding texture fetches (e.g., 4 texture calculations are directly tied to their corresponding 4 texture fetches. This is a limited design that is static in nature. Since a large amount of state data is associated with the texture calculations, such limited static designs do not scale efficiently.","Thus, there exists a need for a pipeline that allows for more dynamic texture fetches and shading calculations, and in particular, the ability for increasing the number of texture fetch operations that can be performed without an expensive, redundant build up in the amount of texture calculation state data that must be maintained. The present invention provides a novel solution to the above needs.","Embodiments of the present invention provided a method and system for implementing programmable texture lookups from texture coordinate sets. Embodiments of the present invention implement a graphics rendering pipeline that allows for more dynamic texture fetches and shading calculations, including the ability for increasing the number of texture fetch operations that can be performed without an expensive, redundant build up in the amount of texture calculation state data that must be maintained.","In one embodiment, the present invention is implemented as a method for generating a plurality of texture coordinates using a shader module of a graphics rendering pipeline. The shader module executes floating point calculations on received pixel data to generate the texture coordinates. The texture coordinates are passed to a texture unit coupled to the shader module. A plurality of texture values are fetched using the texture coordinates. The fetching of the texture values is programmable with respect to the texture coordinates, thereby decoupling the actual fetching of the texture values from the manner and order in which the texture coordinates are received from the shader module.","In one embodiment, the shader module and the texture unit are implemented within a programmable pixel shader. The decoupling of the actual fetching of the texture values from the received texture coordinates enables programmable flexibility in the manner in which the texture values are fetched from memory. Texture coordinate sets can be reused to fetch from different textures. For example, two different textures could be looked up with the same interpolated texture coordinate set. The number of textures looked up and texture coordinate sets provided become independent of each other.","In this manner, the programmable texture lookups enable more dynamic texture fetches and shading calculations. By increasing the number of texture fetch operations that can be performed from a given number of texture coordinate sets, the texture operations of a graphics rendering pipeline can be increased without an expensive, redundant build up in the amount of texture calculation state data (e.g., multiple copies of texture coordinate set data, and the like) that must be maintained.","Reference will now be made in detail to the preferred embodiments of the present invention, examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with the preferred embodiments, it will be understood that they are not intended to limit the invention to these embodiments. On the contrary, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the spirit and scope of the invention as defined by the appended claims. Furthermore, in the following detailed description of embodiments of the present invention, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be recognized by one of ordinary skill in the art that the present invention may be practiced without these specific details. In other instances, well-known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the embodiments of the present invention.","Embodiments of the present invention provided a method and system for implementing programmable texture lookups from texture coordinate sets. Embodiments of the present invention implement a graphics rendering pipeline that allows for more dynamic texture fetches and shading calculations, including the ability for increasing the number of texture fetch operations that can be performed without an expensive, redundant build up in the amount of texture calculation state data that must be maintained. Embodiments of the present invention and their benefits are further described below.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3","b":["350","352","354","356","357","358"]},"As an option, each of the foregoing modules may be situated on a single semiconductor platform. As used herein, the single semiconductor platform may refer to a sole unitary semiconductor-based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi-chip modules with increased connectivity that simulate on-chip operation, and make substantial improvements over utilizing a conventional CPU and bus implementation. The single semiconductor platform can be, for example, a desktop computer system or server computer system, having a powerful general-purpose CPU coupled to a dedicated GPU (graphics processor unit). Similarly, the single semiconductor platform can be implemented as a video game console device such as, for example, as the Xbox\u00ae, available from Microsoft Corporation of Redmond, Wash. Additionally, it should be noted that embodiments of present invention may also be implemented on multiple semiconductor platforms and\/or utilizing a conventional CPU and bus implementation.","During operation, the buffer  is included for gathering and maintaining a plurality of attributes. Completed vertices are processed by the transform module  and then sent to the lighting module . The transform module  generates vectors for the lighting module  to light. The output of the lighting module  is screen space data suitable for the set-up module that, in turn, sets up primitives. Thereafter, rasterization module  carries out rasterization of the primitives. In particular, the rasterization module  passes on pixel data including, but not limited to a position, a pixel diffuse color, a specular color, a fog distance, a plurality of texture coordinates, and\/or any other information relating to the pixels involved with the processing in the graphics pipeline.","A pixel processing module  is coupled to the rasterization module  for processing the pixel data. The pixel processing module  begins by reading the pixel data generated by the rasterization module . In operation, the pixel processing module  outputs a color and a depth value, e.g., a \u201cz\u201d value.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 4","FIG. 3","FIG. 3"],"b":["400","358","402","356","356"]},"In use, the triangle unit  calculates plane equations at different levels of precision using the pixel data, and further identifies a point of origin of the plane equations. The plane equations are each adapted for describing a value of various pixel data parameters associated with a particular polygon.","Also provided is a shader module, shader core module , coupled to the triangle unit  and the rasterizer  for receiving the plane equations and origin from the triangle unit  and the pixel data from the rasterizer . In use, the shader core module  outputs interpolated values while performing shading operations using the pixel data and the plane equations, executes floating point calculations, and generates texture coordinates.","In the present embodiment, a loopback triangle buffer  is coupled between an input and an output of the shader core module  for feeding back the interpolated values for further use in the calculations.","Referring still to , a texture unit  is provided to implement programmable texture lookups from texture coordinates received from the shader core module . The programmable texture lookups as performed by the texture unit  implement a graphics rendering pipeline that allows for more dynamic texture fetches and shading calculations, including the ability for increasing the number of texture fetch operations that can be performed without an expensive, redundant build up in the amount of texture calculation state data (e.g., multiple copies of texture coordinate set data, and the like) that must be maintained.","As depicted in , the texture unit  is coupled to an output of the shader core module  as shown. In the present embodiment, a shader core FIFO buffer  is also coupled to the output of the shader core module . In use, the shader core FIFO buffer  stores the output of the floating point calculations generated by the shader core module  for later use while the texture coordinates are being processed by the texture unit . In operation, the texture unit  uses the texture coordinates generated by the shader core module  for performing the programmable texture value fetching.","Next included is a shader back end module  with an input coupled to an output of the shader core FIFO buffer  and the texture unit , and a shader back end FIFO . The shader back end FIFO  is further coupled to an output of the triangle unit  for temporarily storing the plane equations for use by the shader back end module . In use, the shader back end module  serves to convert the texture values to an appropriate floating point representation, and perform color interpolation to generate color values.","A combiner module  is coupled to the shader back end module  for receiving the color and texture values and combining the same in any desired proportion. The combiner module  may be configured in any manner well known to those of ordinary skill.","More information regarding the exemplary operation of a graphics pipeline compatible with embodiments of the present invention can be found in commonly assigned U.S. patent applications \u201cPROGRAMMABLE PIXEL SHADING ARCHITECTURE\u201d Ser. No. 09\/885,242, filed on Jun. 19, 2001, and \u201cSYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR A PROGRAMMABLE PIXEL PROCESSING MODEL WITH INSTRUCTION SET\u201d Ser. No. 09\/885,382, filed on Jun. 19, 2001, which are incorporated herein by reference in their entirety.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 5","b":["408","502","501"]},"In the present embodiment, as described above, a plurality of texture coordinates are generated using the shader core . The shader core  executes the floating point calculations on received pixel data in order to generate the texture coordinates  depicted in . The texture coordinates  are passed to the texture unit  coupled to the shader core . The texture unit  then functions by determining the texture values  using the texture coordinates. However, in accordance with present embodiment, the fetching of the texture values  is programmable with respect to the received texture coordinates . The fetching of the texture values  is, in effect, decoupled from the manner and order in which the texture coordinates  are received from the shader core . This relationship is shown in greater detail in  below.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 6","FIG. 6","FIG. 6","FIG. 5"],"b":["408","502","501","404","502","502","1","2","501","1","2","502","501"]},"The programmable texture lookups as depicted in  enable more dynamic texture fetches. For example, a 16-way texture fetch can be implemented using 8 texture coordinate sets using the texture unit . Similarly, a 16-way texture fetch can be implemented using 4 texture coordinates. The decoupled relationship allows one texture coordinate to be used for multiple texture value fetches, and thus, multiple texture values output from the texture unit . Instead of sending redundant texture coordinates 2, 3, 10 times, or the like, the specific operand can be specified for each texture fetch for the resulting texture value output as described above. This enables the texture operations of a graphics rendering pipeline to be increased without an expensive, redundant build up in the amount of texture calculation state data that must be maintained. In one embodiment, a 16-way texture fetch is implemented using from 1 to 8 coordinates. Accordingly, it should be noted that embodiments of the present invention are not limited to any specific number of texture coordinates or texture maps. The \u201cmany-to-many\u201d relationship between texture coordinates and texture maps of embodiments of the present invention is shown in greater detail in  below.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 7","b":"408"},"As depicted in , a set of texture coordinates  and a set of texture maps  are shown. The set of texture coordinates  comprises a plurality of texture coordinates, numbered sequentially Coord  through Coord X, as shown. The set of texture maps  comprises a plurality of texture maps, numbered sequentially TexMap  through TexMap X, as shown. Embodiments of the present invention are not limited to any particular number of texture coordinates or any particular number of texture maps. Accordingly, \u201cCoord X\u201d can be Coord , Coord , Coord , Coord , or the like (e.g., where X is a variable that can be increased or decreased depending upon the desired scale of the implementation). Similarly, \u201cTexMap X\u201d can be TexMap , TexMap , TexMap , or the like.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["701","702","501","404","501","702","408","701","408","702","0","0","0","2","0","0","720","2","0","730","701"]},"In one embodiment, texture fetches are implemented using texture coordinates that are generated by an arbitrary shader program as opposed to, for example, texture coordinates interpolated across the area of a polygon. Additionally, in one embodiment, interpolated texture coordinates can be mixed with arbitrary texture coordinates (e.g., generated by a shader program) for the texture fetch operations. This capability provides an added degree of flexibility for the graphics programmer. Additional descriptions of the use of arbitrary texture coordinates and the generation of arbitrary texture coordinates by shader programs can be found in commonly assigned U.S. patent application \u201cSYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR USING AN ARBITRARY QUANTITY AS TEXTURE ADDRESS\u201d filed May 23, 2003, Ser. No. 10\/444,418, which is incorporated herein in its entirety.","An example syntax of a programmable texture fetch operation in accordance with one embodiment of the present invention is now described. It should be noted that the instruction syntax described below is exemplary. As such, any specific syntax form can change in accordance with, for example, system architecture changes, application programming interface version updates, and the like. In one embodiment, the texture fetch operation has the general syntax \u201cTexture Fetch (TEX, TXP, TXD)\u201d and the format is as shown below.","Format:","TEX[c] D[.xyzw][(RC[.xyzw])],[\u2212]S0[.xyzw],#tid","TXP[c] D[.xyzw][(RC[.xyzw])],[\u2212]S0[.xyzw],#tid","TXD[c] D[.xyzw] [(RC[.xyzw])],[\u2212]S0[.xyzw],[\u2212]S 1[.xyzw], [\u2212]S2[.xyzw],#tid","The contents of the source vector are used as a texture coordinate indexing into the specified (via tid: 0\u201315) texture map. The filtered vector resulting is placed into the destination as a quad-float. TEX generates a texture fetch of (x,y,z) while TXP generates a texture fetch of (x\/w,y\/w,z\/w). TXD allows specification of the derivative in x (S1) and y (S2). These may be used for LOD\/anisotropic calculations. TXD generates a texture fetch of (x,y,z).","The following table sets forth an example of operation associated with the TEX, TXP, and TXD instructions.",{"@attributes":{"id":"p-0050","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["t.x=source0.c***; \/*c is x yro y or z or w*\/","t.y=source0.c**;","t.z=source0.***c;","t.w=source0***c;","if(-source0)","t=-t;","q=TextureFetch (t, texid);","if(destination.x)R.x=q.x;","if(destination.y)R.y=q.y;","if(destination.z)R.z=q.z;","if(destination.w)R.w=q.w;\n\nExample:\n","TEX R2, R3, #3 \/\/Fetch from texture 3 using R3 as coords."]}},"Thus, embodiments of the present invention provided a method and system for implementing programmable texture lookups from texture coordinate sets. Embodiments of the present invention implement a graphics rendering pipeline that allows for more dynamic texture fetches and shading calculations, including the ability for increasing the number of texture fetch operations that can be performed without an expensive, redundant build up in the amount of texture calculation state data that must be maintained."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements.","Prior Art  shows a typical prior art graphics pipeline for performing texture mapping operations.","Prior Art  shows the coordinates of the vertices, which define a triangle.","Prior Art  shows a plurality of pixels identified within the triangle of .",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
