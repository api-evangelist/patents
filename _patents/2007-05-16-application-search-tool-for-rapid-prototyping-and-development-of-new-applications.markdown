---
title: Application search tool for rapid prototyping and development of new applications
abstract: A code search tool greatly reduces time, cost, and other resource expenditures associated with implementing a new application. The tool is a search, navigation and visualization tool that accepts high-level processing concepts as inputs to identify, rank, and return the code of relevant existing applications. A software developer may use the relevant applications to rapidly build prototypes, identify requirements, and develop new applications. The tool provides an efficient way to improve the reuse of application logic to realize the high-level processing concepts, and more efficiently deliver proof of concept.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009649&OS=09009649&RS=09009649
owner: Accenture Global Services Limited
number: 09009649
owner_city: Dublin
owner_country: IE
publication_date: 20070516
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Technical Field","This disclosure concerns finding existing program logic and reusing it to rapidly build prototypes and develop new applications. In particular, this disclosure relates to a search, navigation and visualization tool that accepts high-level processing concepts as inputs that drive a multi-layered search to identify applications and application programming interface (API) calls for reuse.","2. Background Information","Software professionals widely recognize logic (e.g., source code) reuse as a technique that reduces the time, money, and other costs associated with creating a new application. Software professionals recognize API calls as forms of abstraction for high-level processing concepts, which drives the wide acceptance of API calls as reusable logic. For example, implementing an existing API call that produces a pull-down menu eliminates the need to write all the underlining logic necessary to deliver the functionality of a pull-down menu. However, current logic mining techniques and mining tools fail to retrieve highly relevant software components from application repositories that developers can use to prototype requirements in support of high-level processing concepts. Modern search engines do not ensure that applications identified by the search engines can serve as highly relevant application prototypes (HRAPs). Software professionals consider the mismatch between the high-level processing concepts (e.g., the intent reflected in the descriptions of applications) and low-level implementation details (e.g., API calls and actual run-time behaviour) found in application logic a fundamental technical challenge to identifying highly relevant applications (HRAs). Software professionals intend to author meaningful descriptions of applications, in the course of depositing applications into software repositories. The mismatch between the description of an application and the actual behaviour of the application represents one example of the \u201cvocabulary problem\u201d, which states that no single word or phrase best describes a programming concept.","In the spiral model of software development, stakeholders describe high-level processing concepts to development teams, and together the stakeholders and development teams identify requirements in support of the high-level processing concepts. In addition, a development team builds a prototype based on the requirements, and the development team demonstrates the prototype to the stakeholders to receive feedback. Prototypes attempt to approximate the desired high-level processing concepts (e.g., features and capabilities) of the new application stakeholders desire development teams to build. The feedback from stakeholders often leads to changes to the prototype and the original requirements, as stakeholders iteratively refine their vision. In the event the stakeholders make a substantial number of changes to the requirements, the development team often discards the prototype and builds a new prototype, and another iteration of refinements repeats. Building prototypes repeatedly without reusing existing application logic costs organizations a great deal in the form of wasted project resources and time.","Development teams find it cost-effective to identify existing applications that approximate the high-level processing concepts and requirements of new software projects as the basis for prototypes. In the context of prototyping, software development professionals consider such existing applications as HRAs. Many application repositories (e.g., open source repositories and source control management systems maintained by stakeholders internally) contain hundreds of thousands of different existing applications (e.g., potential HRAs). Unfortunately, developers find it difficult to identify applications (e.g., HRAs) ideal for prototyping because of the time and expense involved in searching (e.g., querying) application repositories and source control management systems.","The amount of intellectual effort that a developer must expend to move a software system from one stage of development to another may be considered the \u201ccognitive distance.\u201d For example, using current search tools developers expend significant intellectual effort to identify potentially relevant applications and confirm HRAs from potentially relevant applications. Many developers employ search engines that identify exact matches between keywords and the words found in application repositories. The application repositories may include descriptions, application logic comments, program variables names, and variable types of existing applications. Such search engines actually increase the difficulty of identifying HRAs, because of the poor quality of information contained in application repositories, and the inability to reduce the cognitive distance required to identify HRAs, as well as other factors. Additionally, many application repositories include incomplete, misleading and inaccurate descriptions of applications identified in the application repositories. Consequently, even matching keywords with words in the application descriptions found in application repositories does not guarantee that the search engine will identify HRAs.","Effective software reuse techniques (e.g., prototyping using existing applications) reduce the cognitive distance between the initial concept of a system (e.g., high-level processing concepts that expressly and implicitly describe the features and capabilities of a new application), establishing discrete requirements, and the production implementation of the new system. Unfortunately, current search engines lack the ability to reduce the cognitive distance related to identifying HRAs.","For example, an application description may indicate that an application includes an encryption feature when in fact the application uses compression as a crude form of encryption. A developer entering \u201cencryption\u201d (e.g., as a high-level processing concept and specific requirement) as a keyword may waste precious time to review a search engine result containing the incorrectly described application, and ultimately discard the result, because the application fails to meet the encryption requirement. The developer must download the application identified in the search result, locate and examine fragments of the application logic that allegedly implements encryption before determining that the application fails to meet the requirement. The developer may spend scarce project development budget resources and significant amount of time to analyze the application before determining that an application is not relevant. The developer may even observe the runtime behavior of the application to ensure that the behavior matches the high-level processing concepts desired by the stakeholders, and meets the requirements in support of the high-level processing concepts before establishing that the application qualifies as a HRA. Current search engines also lack the ability to assist developers to rapidly identify requirements in support of high-level processing concepts described by stakeholders.","Some search tools return code snippets (e.g., segments of application logic), however, code snippets do not give enough background or context to assist developers to create rapid prototypes, and such search tools require developers to invest significant intellectual effort (e.g., cognitive distance) to understand how to use the code snippets in broader scopes. Other existing approaches and tools retrieve snippets of code based on the context of the application logic that developers work on, but while these approaches and tools improve the productivity of developers, they do not return relevant applications from high-level processing concepts as inputs.","A need has long existed for a system and method that efficiently identifies HRAs usable to rapidly build prototypes and develop new applications.","The EXEcutable exaMPLes ARchive system (Exemplar) rapidly and efficiently identifies highly relevant applications (HRAs) from large application repositories. Using Exemplar, a developer enters high-level processing concepts (e.g., toolbar, download, smart card) as input (e.g., initial query keywords), and Exemplar uses information retrieval and program analysis techniques to retrieve HRAs that implement the high-level processing concepts. Exemplar may also accept various types of inputs that describe high-level processing concepts (e.g. concept text identifiers, concept visual identifiers, concept audio identifiers, and any other sensory identifier usable to identify high-level processing concepts). Exemplar uses the help pages and help documentation of third-party libraries, software development kits, and other middleware to produce a list of names of API calls that Exemplar in turn uses to expand an initial query (\u201cquery expansion\u201d) to identify the application logic of HRAs and the API calls included in the HRAs. Exemplar determines the behavior of the application logic and API call logic, and ranks the HRAs and API calls included in the HRAs.","Exemplar uses help documentation or other trusted sources that describe API calls to expand queries. An application provider typically provides the help pages and help documentation for their applications, which developers consider reliable and a trusted source. In particular, developers consider application providers trusted sources for help pages and help documentation of popular and widely used applications written by large development teams, produced under rigorous testing and development best practices, and used by other developers who provide feedback regarding documentation using different forums (e.g., user groups). Developers trust help documentation over the descriptions of applications included in application repositories, because application providers generally produce more verbose and accurate help documentation than the descriptions of applications included in application repositories. Developers also trust help documentation because many different people and review procedures are typically used to produce help documentation.","Exemplar query expansion increases the probability of identifying logic matches usable to build highly relevant application prototypes (HRAPs) and new applications, and addresses the vocabulary problem mentioned above by expanding an initial query to include new keywords, metadata, and semantics information found in help pages and other help documentation determined to have similar meanings to the keywords originally used by a developer in the initial query. Exemplar expands an initial query to include the names of API calls with semantics that reflect (in many cases unequivocally) specific behaviour of the matched applications. Exemplar locates application logic containing the API calls that exhibit desired semantics by identifying API calls through help pages and help documentation. Exemplar provides a user interface that developers can use to navigate directly to the various locations to determine how an HRA implements high-level processing concepts.","Exemplar may rank HRAs according to the number of high-level processing concepts implemented by each API call found in the HRAs, or based on other ranking metrics. In other words, since API calls implement high-level processing concepts, the more high-level processing concepts implemented by an HRA the more relevant the HRA and the higher the rank assigned to the HRA. Exemplar considers keywords included in queries to represent logically connected concepts. Often a question structured as a sentence forms the basis for a query, from which a developer extracts keywords to form the query. For example, consider the query \u201csend receive secure XML.\u201d Where a query presents a relation between multiple concepts (e.g., send secure XML), then a relation should exists between API calls that implement the concepts in the corresponding application logic (e.g., API calls that encrypt, process or handle XML formatted content, and transmit content). Application logic often preserves the relations between concepts (e.g., control flow and data flow links), an instance of the software reflection model concept and known as connectivity heuristics. Exemplar calculates HRAs rankings based on analyzing the connectivity heuristics of API calls that implement the concepts included in the queries. Exemplar uses program analysis algorithms, and computes control flow graphs (CFG), and data flow graphs (DFG) to analyze the connectivity heuristics of API calls.","Other systems, methods, and features of the invention will be, or will become, apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems, methods, features and advantages be included within this description, be within the scope of the invention, and be protected by the following claims.","The EXEcutable exaMPLes ARchive system (Exemplar) solves the technical problem of providing a tool that accepts high-level processing concepts as queries to identify, determine the behavior, rank and return the application logic of HRAs. Exemplar solves an instance of the difficult vocabulary problem that exists when users and developers describe processing concept with different words. Exemplar is not limited to basic keyword matching used in queries against application descriptions and comments included with application logic. Accordingly, when an application is highly relevant, and where a query contains keywords different from the words used by the developer to describe application logic and API call logic, Exemplar nevertheless returns the application as a highly relevant application.","Exemplar matches high-level processing concepts (e.g., expressed using keywords) with the descriptions of various API calls found in help documents or other trusted descriptive sources. Because a typical application invokes API calls from several different libraries, several different people who use different vocabularies often author help documents associated with API calls. The richness of different vocabularies increases the probability of finding matches and producing a long list of potentially relevant applications and API calls. Searching help documents or other trusted descriptive sources produces additional benefits. For example, help documents including an API call often indicate where the application logic implements the API call. Consequently, Exemplar may direct a developer to the location in application logic where an API call implements a high-level processing concept. The developer may then determine the relevance of the application logic and API call logic. In other words, the developer may determine whether the application logic and API call logic actually support the high-level processing concept.","Although specific components of Exemplar will be described, methods, systems, and articles of manufacture consistent with Exemplar may include additional or different components. For example, a processor may be implemented as a microprocessor, microcontroller, application specific integrated circuit (ASIC), discrete logic, or a combination of other type of circuits or logic. Similarly, memories may be DRAM, SRAM, Flash or any other type of memory. Logic that implements the processing and programs described below may be stored (e.g., as computer executable instructions) on a computer readable medium such as an optical or magnetic disk or other memory. Alternatively or additionally, the logic may be realized in an electromagnetic or optical signal that may be transmitted between entities. An example of such a signal is a physical layer Ethernet signal bearing TCP\/IP packets that include program source code or executable programs. Flags, data, databases, tables, and other data structures may be separately stored and managed, may be incorporated into a single memory or database, may be distributed, or may be logically and physically organized in many different ways. Programs may be parts of a single program, separate programs, or distributed across several memories and processors. Furthermore, the programs, or any portion of the programs, may instead be implemented in hardware.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","100","102","104","106","100","108","110","112","114","116","118"]},"In one implementation, the EPAD user interface , expanded search engine , heuristic relevance ranking engine  and logic analyzer  form an Exemplar system  within the Exemplar environment . The Exemplar system  may include additional or different components. The Exemplar system  may communicate with the help content processor , help content , API calls dictionary , and logic repository , as well as other systems, through the networks  (e.g., Internet) as external systems.","The logic repository  may include application logic  and API call logic . The Exemplar system  accepts high-level processing concepts (e.g., \u201csend secure XML\u201d) as input and produces output identifying which application logic  and API call logic  developers may use to prototype and develop new applications implementing the high-level processing concepts. In one implementation, the Exemplar environment  implements the help content  and the logic repository  with multiple storage devices (e.g., multiple databases on different disk drives), and interfaces to help content , application logic  and API call logic  from various available source (e.g., local or remote help databases, websites, knowledge exchanges, document repositories, or other sources).","In one implementation, the help content processor  may be implemented as a web crawler that traverses available application repositories, and downloads help content  (e.g., application descriptions), and logic repository  content (e.g., application logic , and API logic ). The help content processor  may also perform full text indexing on the help content  and the logic repository  content. The help content processor  may further produce an API calls dictionary  that includes sets of tuples (a form of ordered list) that link selected words from the descriptions of the API calls to the names of the API calls.","The description above used the examples of application logic  and API call logic . These types of logic may be program source code (e.g., C or C++ code), for example. However, the Exemplar environment  may search, analyze, and determine relevance for many other types of logic. As examples, the logic repository  may include programs or program components expressed in a visual programming language using graphical program elements and spatial arrangements of text and graphic symbols. The visual programming logic may include icon-based logic, form-based logic, diagram-based logic or other types of visual expression. The visual expression may be consistent with dataflow languages, flow-based programming, domain-specific modelling, or other programming paradigms.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["200","124","202","124","104","104","204","108","202","106"]},"The expanded search engine  may combine the original query  and the basis API call list  to form an expanded query . The expanded search engine  may execute an expanded search using the expanded query  to search through the logic repository  to obtain an expanded search result . In one implementation, the logic repository  may return the expanded search results  to the heuristic relevance ranking engine . The expanded search result  may contain a list of potentially relevant applications  and potentially relevant API calls  that the heuristic relevance ranking engine  analyzes using the logic analyzer . In one implementation, the heuristic relevance ranking engine  may include the logic analyzer . The logic analyzer  may include a parser generator such as ANTLR (\u201cANother Tool for Language Recognition\u201d) available from www.antlr.org that provides support for generating data flow graphs and control flow graphs.","The logic analyzer  may return connectivity rankings , discussed in detail below, to further determine an application heuristic relevance ranking  and an API call heuristic relevance ranking . The heuristic relevance ranking engine  may return the application heuristic relevance ranking  and an API call heuristic relevance ranking  to the EPAD user interface . The expanded search engine  may also return a relevant applications list  and a relevant API calls list  to the EPAD user interface . The Exemplar system  may assign an application heuristic relevance ranking  to one or more relevant applications found in the relevant applications list  to indicate how closely each relevant application supports the high-level processing concept represented by the original query . Similarly, Exemplar system  may assign an API call heuristic relevance ranking  to one or more relevant API calls found in the relevant API call list  to indicate how closely each relevant API call supports the high-level processing concept represented by the original query .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3","b":["300","202","202","302","302","106","108","112","304","304","300","306","202"]},"Table 1 shows an example of an original query  in the form of a structured query language statement (SQL) that represents the high-level processing concept \u201ccompress uncompress ZIP file\u201d . Table 1 shows that the original query  will search the help content  (e.g., Java Help Documents) to identify a basis API calls list .",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"original query 202"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT basis API Calls"]},{"entry":[{},"\u2002FROM Java Help Documents"]},{"entry":[{},"\u2002WHERE Words in these Documents ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003compress or uncompress or ZIP or file."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Table 2 shows one example of the help content  represented by a fragment of Java Help Documentation released by Sun Microsystems, Inc. that describes the functionality of classes exported from the Java.util package. The Java.util package defines a number of classes, primarily collections classes that a developer may use when working with groups of objects. Referring to Table 2, the help content processor  may identify partial matches for the class ZipEntry to the original query . The help content processor  may search the help content  and identify a fragment of the help documentation for the ZipEntry class shown in Table 3.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"help content 106 (e.g. a fragment of Java Help Document)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Class","Summary"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Adler32","A class that can be used to compute the Adler-32"]},{"entry":[{},"checksum of a data stream."]},{"entry":["CheckedInputStream","An input stream that also maintains a checksum"]},{"entry":[{},"of the data being read."]},{"entry":["CheckedOutputStream","An output stream that also maintains a checksum"]},{"entry":[{},"of the data being written."]},{"entry":["CRC32","A class that can be used to compute the CRC-32"]},{"entry":[{},"of a data stream."]},{"entry":["Deflater","This class provides support for general purpose"]},{"entry":[{},"compression using the popular ZLIB compression"]},{"entry":[{},"library."]},{"entry":["DeflaterInputStream","Implements an input stream filter for compressing"]},{"entry":[{},"data in the \u201cdeflate\u201d compression format."]},{"entry":["DeflaterOutputStream","This class implements an output stream filter for"]},{"entry":[{},"compressing data in the \u201cdeflate\u201d compression"]},{"entry":[{},"format."]},{"entry":["GZIPInputStream","This class implements a stream filter for reading"]},{"entry":[{},"compressed data in the GZIP file format."]},{"entry":["GZIPOutputStream","This class implements a stream filter for writing"]},{"entry":[{},"compressed data in the GZIP file format."]},{"entry":["Inflater","This class provides support for general purpose"]},{"entry":[{},"decompression using the popular ZLIB"]},{"entry":[{},"compression library."]},{"entry":["InflaterInputStream","This class implements a stream filter for"]},{"entry":[{},"uncompressing data in the \u201cdeflate\u201d compression"]},{"entry":[{},"format."]},{"entry":["InflaterOutputStream","Implements an output stream filter for"]},{"entry":[{},"uncompressing data stored in the \u201cdeflate\u201d"]},{"entry":[{},"compression format."]},{"entry":["ZipEntry","This class is used to represent a ZIP file entry."]},{"entry":["ZipFile","This class is used to read entries from a zip file."]},{"entry":["ZipInputStream","This class implements an input stream filter for"]},{"entry":[{},"reading files in the ZIP file format."]},{"entry":["ZipOutputStream","This class implements an output stream filter for"]},{"entry":[{},"writing files in the ZIP file format."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 3 shows the descriptions of two different methods (e.g., getCompressedSize, and setMethod) for the ZipEntry class that include the terms compress and uncompress found in the high-level processing concept \u201ccompress uncompress ZIP file\u201d . The basis API call list  may include the getCompressedSize and setMethod methods.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"help content 106 (e.g., fragment of help documentation for ZipEntry class)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method","Summary"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Object","clone( )"]},{"entry":[{},"Returns a copy of this entry."]},{"entry":["String","getComment( )"]},{"entry":[{},"Returns the comment string for the entry, or null if none."]},{"entry":["long","getCompressedSize( )"]},{"entry":[{},"Returns the size of the compressed entry data, or \u22121 if"]},{"entry":[{},"not known."]},{"entry":["long","getCrc( )"]},{"entry":[{},"Returns the CRC-32 checksum of the uncompressed"]},{"entry":[{},"entry data, or \u22121 if not known."]},{"entry":["byte[ ]","getExtra( )"]},{"entry":[{},"Returns the extra field data for the entry, or null if none."]},{"entry":["int","getMethod( )"]},{"entry":[{},"Returns the compression method of the entry, or \u22121 if not"]},{"entry":[{},"specified."]},{"entry":["String","getName( )"]},{"entry":[{},"Returns the name of the entry."]},{"entry":["long","getSize( )"]},{"entry":[{},"Returns the uncompressed size of the entry data, or \u22121"]},{"entry":[{},"if not known."]},{"entry":["long","getTime( )"]},{"entry":[{},"Returns the modification time of the entry, or \u22121 if not"]},{"entry":[{},"specified."]},{"entry":["int","hashCode( )"]},{"entry":[{},"Returns the hash code value for this entry."]},{"entry":["boolean","isDirectory( )"]},{"entry":[{},"Returns true if this is a directory entry."]},{"entry":["void","setComment(String comment)"]},{"entry":[{},"Sets the optional comment string for the entry."]},{"entry":["void","setCompressedSize(long csize)"]},{"entry":[{},"Sets the size of the compressed entry data."]},{"entry":["void","setCrc(long crc)"]},{"entry":[{},"Sets the CRC-32 checksum of the uncompressed entry data."]},{"entry":["void","setExtra(byte[ ] extra)"]},{"entry":[{},"Sets the optional extra field data for the entry."]},{"entry":["void","setMethod(int method)"]},{"entry":[{},"Sets the compression method for the entry."]},{"entry":["void","setSize(long size)"]},{"entry":[{},"Sets the uncompressed size of the entry data."]},{"entry":["void","setTime(long time)"]},{"entry":[{},"Sets the modification time of the entry."]},{"entry":["String","toString( )"]},{"entry":[{},"Returns a string representation of the ZIP entry."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 4 shows an example of two equivalent forms of an expanded query  that expand the original search from the help content  (e.g., Java Help Documents) to the logic repository  using the basis API call list  from the original query . Table 4 statement A shows the getCompressedSize and setMethod that may be included in the basis API call list . Table 4 statement B shows the expanded query  as a nested query, where the original query  and the basis API call list  (e.g., getCompressedSize and setMethod) drive the outer query that searches the logic repository  for potentially relevant applications  to obtain the expanded query result  including potentially relevant applications  and potentially relevant API calls . The expanded query  may improve upon the original query  by targeting the search performed against the logic repository  to obtain application logic  with a high probability of including potentially relevant applications  and potentially relevant API calls .",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"expanded query 206"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A.","\u2003SELECT Potentially Relevant Applications"]},{"entry":[{},"\u2002FROM Logic Repository"]},{"entry":[{},"\u2002WHERE API Calls in"]},{"entry":[{},"\u2003\u2003\u2003Source Code Files of these Application"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003= getCompressedSize or setMethod."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\/******* The SQL statement above also expressed below. **********\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["B.","SELECT Potentially Relevant Applications"]},{"entry":[{},"\u2002FROM Logic Repository"]},{"entry":[{},"\u2002WHERE API Calls in"]},{"entry":[{},"\u2003\u2003\u2003Source Code Files of these Application"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003= {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2009SELECT basis API Calls"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2009FROM Java Help Documents"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2009WHERE Words in these Documents ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2009compress or uncompress or ZIP or file"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 5 shows another example of two equivalent forms of an expanded query  that expand the original search from the help content  (e.g., Java Help Documents) to the logic repository  by combining the original query  and the basis API call list  to form the expanded query . Table 5 statement A shows the getCompressedSize and setMethod (e.g., the basis API call list ) combined with the original query . Table 5 statement B shows the expanded query  as a nested query, where the original query  and the basis API call list  (e.g., getCompressedSize and setMethod) drive the outer query that searches the logic repository  for potentially relevant applications  to obtain the expanded query result  including potentially relevant applications  and potentially relevant API calls . The expanded query  may improve upon the original query  by targeting the search performed against the logic repository  to obtain application logic  with a high probability of including potentially relevant applications  and potentially relevant API calls .",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"expanded query 206"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A.","\u2003SELECT Potentially Relevant Applications"]},{"entry":[{},"\u2002FROM Logic Repository"]},{"entry":[{},"\u2002WHERE API Calls in"]},{"entry":[{},"\u2003\u2003\u2003Source Code Files of these Application"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003= getCompressedSize or setMethod or"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2002 compress or uncompress or ZIP or file."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\/******** The SQL statement above also expressed below. *********\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["B.","SELECT Potentially Relevant Applications"]},{"entry":[{},"\u2002FROM Logic Repository"]},{"entry":[{},"\u2002WHERE API Calls in"]},{"entry":[{},"\u2003\u2003\u2003Source Code Files of these Application"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003= {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2002SELECT basis API Calls"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2002FROM Java Help Documents"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2002WHERE Words in these Documents ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2002compress or uncompress or ZIP or file"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003} or compress or uncompress or ZIP or file."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 6 shows an example of a fragment of logic extracted from the logic repository  (e.g., potentially relevant application ) that includes a potentially relevant API call  (e.g., getCompressedSize).",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"potentially relevant application 210 (e.g., extracted logic fragment)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public static void addFilesToExistingZip(File zipFile, File[ ] files)"},{"entry":"\u2003\u2003\u2003\u2002\u2009throws IOException {"},{"entry":"\u2003\u2003\u2003\/\/ get a temp file"},{"entry":"\u2003\u2003\u2003\u2003\u2003File tempFile = File.createTempFile(zipFile.getName( ), null);"},{"entry":"\u2003\u2003\u2003\/\/ delete it, otherwise you cannot rename your existing zip to it."},{"entry":"\u2003\u2003\u2003\u2003\u2003tempFile.delete( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003int sz = zipFile.getCompressedSize( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003boolean renameOk=zipFile.renameTo(tempFile);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (!renameOk && sz == \u22121)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003throw new RuntimeException(\u201ccould not rename the file"},{"entry":"\u201d+zipFile.getAbsolutePath( )+\u201cto \u201d+tempFile.getAbsolutePath( ));"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003byte[ ] buf = new byte[1024];"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 4","b":["124","400","400","402","404","406","408","410","402","220","124","206","220","1","412","414","416","414","408","102","400"]},"The relevant API list display area  may include the relevant API call list  returned by Exemplar system  based on the original query . The relevant API call list  may include a relevant API call identifier-  (e.g., a function call name) and a relevant API call identifier-  of the relevant API call logic-  (e.g., source code for the function call) and relevant API call logic- , respectively. The EPAD project area  may present the relevant API call identifier-  and the relevant API call identifier-  as user selectable, indicated by the arrow , to display and highlight the relevant API call logic-  and the relevant API call logic-  in the logic display area . In one implementation, the logic display area  may highlight the relevant application logic , and relevant API call logic-  and relevant API call logic-  so that the user can further determine the relevance of the logic to the high-level processing concept represented in the original query .","The heuristic relevance ranking results display area , shown in , may include an application relevance threshold , an API call relevance threshold , data flow graph , control flow graph , and an API call graph . The heuristic relevance ranking results display area  may display heuristic relevance ranking engine  information to assist the user to determine the relevance of user selected logic. As will be described in more detail below, the heuristic relevance ranking engine  may determine the application heuristic relevance ranking  for the relevant application logic  based on the number of relevant API calls (e.g., relevant API call logic-  and relevant API call logic- ) found in the relevant application logic  in comparison to other relevant application logic  identified by Exemplar system . For example, the high-level processing concept example \u201ccompress uncompress ZIP file\u201d  may be entirely implemented in relevant application logic , but only partially implemented in the other relevant application logic . As a result, the heuristic relevance ranking engine  may assign the relevant application logic  a higher application heuristic relevance ranking  than the other relevant application logic . In another implementation, the heuristic relevance ranking engine  may determine the API call heuristic relevance rankings  of the relevant API call logic-  and the relevant API call logic- , based on analyzing semantics derived from the expanded query  and the expanded search result , which establish the behaviour of the relevant API call logic- , the relevant API call logic- , and the relevant applications logic- .","The application relevance threshold  and API call relevance threshold , shown in , may be user selectable and\/or pre-configured with system default values. In another implementation, Exemplar system  may determine the application relevance threshold  and the relevance threshold  based a number of factors (e.g., the complexity of the high-level processing concept represented by the original query , and the number of potentially relevant applications  and potentially relevant API calls  identified by the expanded search result ). Exemplar system  may use the application relevance threshold  and the relevance threshold  to further refine the relevant applications list  and the relevant API calls list , respectively. In one implementation, the application relevance threshold  and the relevance threshold  may determine an application heuristic relevance ranking  value that the potentially relevant applications  must meet to be included on the relevant applications list . The API call relevance threshold  may also determine the API call heuristic relevance ranking  value that the potentially relevant API calls  must meet to be included on the relevant API calls list . For example, an application relevance threshold  of 1 may indicate a low relevance requirement (e.g., requiring loosely relevant applications, and low application heuristic relevance rankings ) and allow a large number of potentially relevant applications  to qualify as relevant applications (e.g., relevant application logic- ). In another example, an application relevance threshold  of 10 may indicate a high relevance requirement (e.g., requiring highly relevant applications, and high application heuristic relevance rankings ) and allow only a fewer number of potentially relevant applications  to qualify as relevant applications. The heuristic relevance ranking engine  may also use the data flow graph  and control flow graph  to determine the application heuristic relevance ranking  and API call heuristic relevance ranking , and visually describe the relationships between the relevant application logic , the relevant API call logic- , and the relevant API call logic- , discussed in further detail below.","The relevant API call logic-  and the relevant API call logic-  may be user selectable (indicated by the arrow ), and provide the user the ability to generate a new application  with the selected logic. To that end, the EPAD project area  may implement point-and-click, drag-and-drop functionality for a user to select relevant API call logic-  and relevant API call logic-  to generate the new application . The EPAD project area  may also build the new application  by combining user selectable other relevant application logic , relevant API call logic-, and relevant API call logic-. The application creation display area  may also identify requirements  for the high-level processing concept represented by the original query . For example, a developer may desire to identify and confirm the requirements  for implementing a high-level processing concept (e.g., \u201csend secure XML\u201d). In one implementation, Exemplar may generate requirements documentation and end user documentation based on the help content  related to the other relevant application logic , the relevant API call logic-, and the relevant API call logic- used to build the new application , and identify the requirements  in support of the new application .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 5","b":["124","124","504","124","506","508","508","506","102","510","300","400","510","124"]},"The memory  may also include expanded search logic . Table 5, above, shows an expanded query  where the search logic  forms the expanded query by combining the original query  and the basis API call list  to form the expanded query . More generally, the expanded search logic  combines the original query  and the basis logic results  to form the expanded query , and executes an expanded search using the expanded query . The basis logic results  may include the basis API call list , including zero or more basis API call identifiers (e.g., the basis API call identifier- ), and a basis application list , including zero or more basis application identifiers (e.g., the basis application identifier- ). The expanded search logic  thereby obtains the expanded search results . The expanded search result  may include potentially relevant applications , and potentially relevant API calls  that include zero or more potentially relevant application identifiers-  and zero or more potentially relevant API call identifiers (e.g., potentially relevant API call identifier-  and potentially relevant API call identifier- ).",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 6","b":["124","506","114","602","216","218","604","428","430","216","218","210","212","220","222","604"]},"The memory  may also include analyzer logic  that the processor  executes to identify application metadata  and API metadata  of the potentially relevant applications , and the potentially relevant API calls , respectively. Examples of application metadata  include application descriptions, application logic comments, application parameter names, and application parameter types of existing applications. Similarly, examples of API metadata  include API descriptions, API logic comments, API parameter names, and API parameter types.","The analyzer logic  may generate the data flow graph  and control flow graph  to obtain the API call graph . The API call graph  may include nodes (e.g., node-  and node- ) that represent potentially relevant API calls  and data flow edges (e.g., data flow edge ) between the potentially relevant API calls  to indicate data flow.  provides additional examples. The analyzer logic  may determine the data flow edge count  corresponding to the number of connections between potentially relevant API calls  within the potentially relevant application . A graph with \u2018n\u2019 nodes has as many as n(n\u22121) edges between nodes. The data flow edge count  provides insight into the degree of connectedness for the data flow graph . The analyzer logic  may also assign link values  to the edges between nodes, discussed in detail below. In one implementation, the analyzer logic  may determine the connectivity rankings  (e.g., strong connectivity ranking  and weak connectivity ranking ) for each connection between the potentially relevant API calls  based on common API parameters , discussed in detail below.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 6","b":["506","628","630","508","628","414","1","422","2","424","440","628","436","1","422","2","424","440","508","630","444","202","106","516","436","414","1","422","2","424","436","414","1","422","2","424","106","444","630","106","436","414","1","422","2","424"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 7","b":["434","114","216","212","214","620","212"]},"In one implementation, the logic analyzer  produces the API call graphs . The logic analyzer  may identify the application metadata  and API metadata  of the potentially relevant applications , and the potentially relevant API calls , respectively, to analyze the data flow paths and connectivity between the potentially relevant API calls . The logic analyzer  may provide the application metadata  and API metadata  to the heuristic relevance ranking engine . In an alternative implementation, the heuristic relevance ranking engine  may identify application metadata  and API metadata , and produce the data flow graph  and control flow graph  using logic analysis formulas, rules and equations to obtain the API call graphs . The data flow graphs , control flow graphs  and API call graphs  may be represented as mathematical structures. The logic analyzer  may obtain the API call graphs  as a result of comparing data flow and control flow between potentially relevant API calls .","In one implementation, the logic analyzer  may perform control flow analysis on the potentially relevant application  to obtain control flow graphs , and perform data flow analysis on the control flow graphs  to obtain data flow graphs. The data flow graphs , control flow graphs , and API call graphs may similarly include nodes and edges. The logic analyzer  may obtain a control flow graph  by logically partitioning a potentially relevant application  as a result of parsing the logic of the potentially relevant application  into nodes that represent logic that includes API calls. The logic analyzer  may assign parsed logic of the potentially relevant application  to an assigned node until the logic analyzer  identifies a potentially relevant API call or branching logic (e.g., if-then, switch-case, and do-while), and add the assigned node to the control flow graph . Where a program includes multiple potentially relevant applications , the logic analyzer  may merge the control flow graphs  produced for each potentially relevant application into a single control flow graph . The logic analyzer  may obtain the API call graph  by comparing the edges in the control flow graphs  with the edges in the data flow graph . For example, where a control flow graph  includes an edge that a data flow graph  does not include, the logic analyzer  may not include the edge in the corresponding API call graph . However, where a control flow graph  includes an edge that the data flow graph  also includes, the logic analyzer  may include the edge in the API call graph .","In one implementation, the logic analyzer  may receive user input to determine particular dependencies between API calls. For example, where a potentially relevant application  uses a function pointer (e.g., a type of pointer used in C, and C++ languages) to reference a potentially relevant API call  and a hash table (e.g., a data structure that associates keys with values) to store an object that represents a data element passed between API calls, the logic analyzer  may receive user input to determine dependencies between API calls because the logic analyzer  may otherwise interpret multiple possible dependencies between API calls when in fact only one or a finite set of valid dependencies exists.","In another implementation, the logic analyzer  may analyze the data flow paths (e.g., edges between nodes discussed below) (e.g., link heuristics) of the potentially relevant applications , and potentially relevant API call logic  to determine the connectivity rankings  of each connection between potentially relevant API calls . In one implementation, the heuristic relevance ranking engine  may determine the application heuristic relevance ranking  for the potentially relevant application , shown in  as potentially relevant application A, based on the total number of API calls \u2018n\u2019 represented by nodes - that represent different potentially relevant API calls  found in the potentially relevant application , the total number of connections between the potentially relevant API calls  (e.g., edges -) equal to n(n\u22121) (e.g., data flow edge count ), the quality of the connections (e.g., strong connectivity or weak connectivity), and the type of link (e.g., loop link, single link, or no link) between the potentially relevant API calls .","The applications metadata  and API metadata  may describe the data flow paths between the different potentially relevant API calls  (e.g., nodes -) within the potentially relevant application . For example, the logic analyzer  may determine common API parameters  and logic branches (e.g., if-then-else) found within the potentially relevant application  and potentially relevant API calls  to generate the data flow graphs , control flow graphs  and API call graphs . The logic analyzer  may, as  also illustrates, identify the function (e.g., K(x), J(x), S(y), P(y), F(x), and G(z)) of each potentially relevant API call  (e.g., -, and ) to determine the connectivity rankings .","In one implementation, the logic analyzer  may assign a weight W(e.g., connectivity ranking ) to each connection between the potentially relevant API calls  (e.g., nodes -). The logic analyzer  may assign weak connections a weight of 0.5 and strong connections a weight of 1.0 depending on multiple factors. For example, edge , edge  and edge  may represent weak connections between potentially relevant API calls  represented by node pairs  and ,  and , and  and  (e.g., function pairs K(x) and F(x), K(x) and J(x), and S(y) and P(y), respectively). Following the above example, where functions K(x) and F(x) share a common API parameter , but neither function generates the value of the common API parameter  then the logic analyzer  may assign the connectivity ranking  between node pair  and , represented by edge , a weak connection weight of 0.5. A weak connection assigned to a node pair (e.g.,  and ) may indicate a low relative probability (e.g., in comparison to the connectivity rankings of other node pairs) that the node pair implements the high-level processing concept represented by the original query . The logic analyzer  may use other heuristic analysis methods and tools to determine whether to assign a weak connection to a connectivity ranking .","Alternatively, edge , and edge  may represent strong connections between potentially relevant API calls , represented by node pairs  and , and  and  (e.g., function pairs K(x) and P(y), and J(x) and S(y), respectively). The logic analyzer  may determine that where function J(x) produces variable y, which both J(x) and S(y) share then the node pair  and , represented by edge , may be assigned a strong connectivity ranking . A strong connection assigned to a node pair (e.g.,  and ) may indicate a high relative probability (e.g., in comparison to the connectivity rankings of other node pairs) that the node pair implements the high-level processing concept represented by the original query . The logic analyzer  may use other heuristic analysis methods and tools to determine whether to assign a strong connection to a connectivity ranking .","The logic analyzer  may also assign a link value L (e.g. link value ) to each connection between potentially relevant API calls . For example, Exemplar system  may assign a link value L equal to 1 where a loop link (e.g., edges - form a loop) exists between potentially relevant API calls  (e.g., nodes -). Exemplar system  may assign a link value L equal to 0.5 where a single link (e.g., edge ) exists between potentially relevant API calls  (e.g., nodes -). In another implementation, Exemplar system  may assign a link value L equal to 0 where no link exists between potentially relevant API calls  (e.g., node  represents a potentially relevant API call  that does not have a connection with other potentially relevant API calls in a potentially relevant application ). Additional, different, or fewer weights may be used. The heuristic relevance ranking engine  may use the connectivity rankings  and link values  assigned to each connection between potentially relevant API calls  to determine the application heuristic relevance ranking  according to:",{"@attributes":{"id":"p-0073","num":"0072"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"1"},{"mi":"n","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}]},"mo":"\u2062","mrow":{"mfrac":{"mrow":[{"msub":[{"mi":["W","i"]},{"mi":["L","i"]}],"mo":"\u2062"},{"mi":"n","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["where","i","ranges","from","to"],"mn":"1","mrow":{"mrow":{"mi":"n","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}},"mo":"."}}}},{"mrow":{"mo":["(",")"],"mrow":{"mi":"Equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mn":"1"}}}]}}}}},"The logic analyzer  may determine an API call heuristic relevance ranking  for a potentially relevant API call  based on the connectivity ranking  and link value  assigned to each edge that includes the potentially relevant API call . For example, where m represents the number of node pair including a particular node (e.g.,  and ,  and , and  and ) and the number of edges (e.g., ,  and ) that include the node equals m(m\u22121), and the assigned value for each connectivity ranking  and link value  for each edge that includes the node represent W and L, respectively, the API call heuristic relevance ranking  for the node may be determined according to Equation 1 above where m substitutes for n:",{"@attributes":{"id":"p-0075","num":"0074"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"j","mo":"=","mn":"1"},{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":"-","mn":"1"}}}]},"mo":"\u2062","mrow":{"mfrac":{"mrow":[{"msub":[{"mi":["W","j"]},{"mi":["L","j"]}],"mo":"\u2062"},{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":"-","mn":"1"}}}]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["where","j","ranges","from","to"],"mn":"1","mrow":{"mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":"-","mn":"1"}}},"mo":"."}}}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]}}}}},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 8","b":["124","210","124","510","202","802","104","202","804","516","204","520","516","806","124","202","808","514","206","208","210","212","810","606","112","812","602","214","620","216","218","210","212","814","602","428","430","604","210","428","430","816","602","210","220","210","428","818","602","216","218","210","212","208","820"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 9","b":["124","114","216","210","602","210","212","904","602","432","433","906","43","908","602","432","433","650","210","214","212","910","602","216","210","912","216","218","602","216","218","210","212","208","914"]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 10","b":["440","400","624","426","1","418","2","420","1","422","2","424","222","1002","400","1","422","2","424","1004","624","1","422","2","424","436","440","1006","440","626","1","422","2","424","436","440","1008","124","444","202","124","106","436","1","422","2","424","440","444"]},"The Exemplar system  greatly reduces the time, cost, and other resource expenditures associated with implementing a new application. The Exemplar system  produces relevant results starting with high-level processing concepts. A software developer may use the relevant applications to rapidly build new application prototypes.","A number of implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and cope of the invention. Accordingly, other implementations are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The disclosure can be better understood with reference to the following drawings and description. The components in the figures are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the invention. Moreover, in the figures, like referenced numerals designate corresponding parts or elements throughout the different views.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
