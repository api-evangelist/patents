---
title: Data flow scheduling environment with formalized pin-base interface and input pin triggering by data collections
abstract: A system and method for implementing a data-flow based system includes three basic components: a data-flow based scheduling environment that balances the needs of data initiated program execution as a result of flows with other practical considerations such as user responsiveness, event driven invocation, user interface considerations, and the need to also support control-flow based paradigms where required; a visual programming language, based on the flow of strongly-typed run-time accessible data and data collections between small control-flow based locally and network distributed functional building-blocks, known as widgets; and a formalized pin-based interface to allow access to data-flow contents from the executing code within the widgets. The pins on the widgets include both pins used to control execution of a widget as well as pins used to receive data input from a data flow. The system and method further include a debugging environment that enables visual debugging of one or more widgets (or collections of widgets). Data control techniques include the concepts of “OR” and “AND” consumption thereby permitting either consumption immediately or only after all widget inputs have received the token. Additional extensions to this framework will also be described that relate to the environment, the programming language and the interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07308674&OS=07308674&RS=07308674
owner: 
number: 07308674
owner_city: 
owner_country: 
publication_date: 20030203
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","ENCORPORATION-BY-REFERENCE OF MATERIAL SUBMITTED ON A COMPACT DISC","BACKGROUND OF THE INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT","Widget Pin Access API"],"p":["This application claims the benefit of U.S. Provisional Application Ser. No. 60\/353,487 filed on Feb. 1, 2002 and titled \u201cINTEGRATED MULTIMEDIA INTELLIGENCE ARCHITECTURE\u201d which is incorporated herein by reference in its entirety for all that is taught and disclosed therein.","Computer Program Listing\u2014A computer program listing appendix is submitted on two compact discs (Copy 1 and Copy 2). These discs are identical to each other. Each disc includes four ASCII files comprising two computer program listing appendices and two reference appendices. All material therein is hereby incorporated by reference in its entirety in this application. The names and indicated sizes of the files on the compact discs are: Appendix A (8.8 Kbytes), a program listing for SC-Schedule View, SC-Schedule Node; SC-Schedule A Node, and SC-Start Widget; Appendix B (4.3 Kbytes), a program listing for Widget Pin Access API; Appendix 1 (28.8 Kbytes), a patent application titled \u201cSystem and Method for Managing Memory\u201d (the \u201cMemory Patent Application\u201d); and Appendix 2 (58.8 Kbytes), a patent application titled \u201cA System for Exchanging Binary Data\u201d (the \u201cTypes Patent Application\u201d). These files include example source code illustrating specific implementations of specific embodiments of the invention along with explanatory text. These compact discs were created on Oct. 19, 2006 and are in IBM PC format and MS-Windows\u00ae operating system compatible.","For complex systems, such as those designed for multimedia intelligence and knowledge management applications, the current \u2018control flow\u2019 based design methods are totally unsuitable. Once a system is broadened to include acquisition of unstructured, non-tagged, time-variant, multimedia information (much of which is designed specifically to prevent easy capture and normalization by non-recipient systems), a totally different approach is required. In this arena, many entrenched notions of information science and database methodology must be discarded to permit the problem to be addressed. We shall call systems that attempt to address this level of problem, \u2018Unconstrained Systems\u2019 (UCS). An unconstrained system is one in which the source(s) of data have no explicit or implicit knowledge of, or interest in, facilitating the capture and subsequent processing of that data by the system. The most significant challenges that must be resolved with the UCS is based on the following realities:\n\n","This loss of control over data is one of the most difficult challenges in the prior art. The prior art clearly suggests that software consists of a \u2018controlling\u2019 program that takes in inputs, performs certain predefined computations, and produces outputs. Nearly every installed system in the prior art complies with this approach. Yet it is obvious from the discussion above that this model can only hold true on a very localized level in a UCS. The flow of data through the system is really in control. It is illustrative to note that the only example of a truly massive software environment is the Internet itself. This success was achieved by defining a rigid set of protocols (IP, HTML etc.) and then allowing Darwinian-like and unplanned development of autonomous but compliant systems to develop on top of the substrate. A similar approach is required in the design of unconstrained systems.","In the traditional programming world, a programmer would begin by defining certain key algorithms and then identify all of the key inputs into the system. As such, the person or entity supplying the data is often asked to comply with very specific data input requirements impacting the format, length, field definitions, etc. The problem with this approach, however, is that predicting needed algorithms or approaches that are appropriate to solving the problem of \u2018understanding the world\u2019 is simply too complex. Once again, the conventional approach of defining processing and interface requirements, and then breaking down the problem into successively smaller and smaller sub-problems becomes unworkable. The most basic change that must be made, then, is to create an environment that operates according to data-flow rules, not those of a classic control-flow based system.","In spite of the prevalence of control based programming frameworks, various data-flow based software design and documentation techniques have been in usage for many years. In these techniques, the system design is broken into a number of distinct processes and the data that flows between them. This breakdown closely matches the perceptions of the actual system users\/customers and thus is effective in communicating the architecture and requirements. Unfortunately, due to the lack of any suitable data-flow based substrate, even software designs created in this manner are invariably translated back into control-flow methods, or at best to message passing schemes, at implementation time. This translation begins a slippery slope that results in such software being of limited scope and largely inflexible to changes in the nature of the flow. This problem is at the root of why software systems are so expensive to create and maintain.","At the most fundamental operating system scheduling level, we need an environment where the presence of suitable data initiates program execution, not the other way round. More specifically, what is needed is a substrate through which data can flow and within which localized areas of control flow can be triggered by the presence of certain data. Additionally, such a system would ideally facilitate easy incorporation of new plug-in control flow based functions or routines and their interface to data flowing through the data-flow based substrate so that it will be possible for the system to \u2018evolve\u2019. In essence, the users, knowingly or otherwise, must teach the system how they do what they do as a side effect of expressing their needs to it. No two analysts will agree completely on the meaning of a set of data, nor will they concur on the correct approach to extracting meaning from data in the first place. Because all such perspectives and techniques may have merit, the system must allow all to co-exist side by side, and to contribute, through a formalized substrate and protocol, to the meta-analysis that is the eventual system output.","The present system and method provide such a system. To implement a data-flow based system, three basic components must be created and integrated:\n\n","The pins on the widgets include both pins used to control execution of a widget as well as pins used to receive data input from a data flow. The system and method further include a debugging environment that enables visual debugging of one or more widgets (or collections of widgets). Data control techniques include the concepts of \u201cOR\u201d and \u201cAND\u201d consumption thereby permitting either consumption immediately or only after all widget inputs have received the token. Additional extensions to this framework will also be described that relate to the environment, the programming language and the interface.","The system described herein may be used in conjunction with a number of other key technologies and concepts that represent the preferred embodiments of the present invention. These various building-block technologies have been previously described in the following patent applications attached hereto as Appendix 1, hereinafter referred to as \u201cMemory Patent Application\u201d now U.S. Patent Application Publication 2003\/0182529 A1 and Appendix 2, hereinafter referred to as \u201cTypes Patent Application, now U.S. Patent Application Publication 2004\/0073913 A1, both of which are incorporated herein by reference.","As set forth above, the system is preferably comprised of the following components:\n\n","The requirements for and implementation of each of these required components will be addressed in the sections that follow. All of the structures defined and used below (widgets, pins, flows, constants, etc.) are preferably implemented within the flat memory model described in the Memory Patent and are contained within a loadable and executable memory allocation known as a \u2018view\u2019. Only complete and correct views can be \u2018run\u2019 by the data-flow scheduler. There may be any number of different views in the system, and any number of instances of a given view.","As an initial matter, it is helpful to describe the \u201cbuilding blocks\u201d involved in the present invention. A \u2018widget\u2019 is the fundamental building block of the system. A widget contains certain functionality encapsulated along with a definition of the inputs and outputs necessary to interface to that functionality. An atomic widget contains compiled code that generally cannot be either examined or altered within the framework of the environment. A compound widget contains an inner structure that defines any subordinate widgets that are required to implement the required functionality, together with the data flows between these contained widgets. In general compound widgets can be opened, examined, and altered by system users. Compound widgets may themselves be combined with other widgets (both atomic and compound) to yield higher-level compound widgets, to any arbitrary level of nesting. At the uppermost level, widgets are combined into \u2018views\u2019 that may be thought of as complete mini-applications that preferably include all necessary UI functionality.","It is the views, and the widgets that they contain, that are loaded into the environment at execution time. Thereafter, the widgets are scheduled and executed according to the control and data flows defined in the widgets themselves. Atomic widgets can be grouped into functionally related sets known as widget packs.","In the preferred embodiment, widget packs appear and are manipulated in the Widget Editing Mode (WEM) diagram as a single unit, but each of the members of the unit can be executed independently of the other members. The principal functional member of a widget pack (i.e., the \u2018do it\u2019 function) is known as the formal widget, and all other widgets in the pack are degenerate (known as degenerate widgets). The pack metaphor is necessary to support asynchronous access to elements or attributes of the internal state of a logical functionality implemented by the pack. Without packs, data-flow is essentially a synchronous metaphor where widgets do not run until all necessary inputs have arrived. The support of \u2018exclusive\u2019 pins (described later) is another exception to this rule.","Compound and atomic widget inputs and outputs as displayed during WEM, are collectively referred to as pins. A formal pin is one that must be connected in order for the widget to operate correctly, a degenerate pin need only be connected if required in the particular use of the widget and may otherwise be left unconnected. Degenerate pins come in two varieties; those that assume a default value within the widget when unconnected (defaulted degenerate pins), and those that do not (un-defaulted degenerate pins).","A View has associated with it a specialized compound widget known as a view widget which contains a collection of atomic or compound widgets, each of which may have at most one user interface region known as a pane. These regions range from buttons, windows, controls, etc. to arbitrarily complex closed shapes. In addition to the view widget, a view contains the layout information that specifies the arrangement of display panes within the enclosing window. The entire view is enclosed in a view window. The system is capable of accessing and transferring between large numbers of different views both under menu control, and by use of suitable view change widgets. Like widgets, views may be shared between users or may be unique to a particular user. Like other widgets, view widgets may have data flow inputs and outputs, but in the case of views, these are physically mediated by network events\/messages that are sent to or received from other views, either in the same workstation or another node on the network. A data-flow environment built on this metaphor is thus transparently distributed.","It is possible to execute a widget without making connections to any degenerate inputs or outputs that a widget contains; in this case the default values (if specified) will be used for the inputs, and the output(s) will be discarded. If no default is defined for a degenerate input, then within that widget, no tokens will appear from that input pin and hence any widgets connected to that input cannot become eligible for scheduling. Degenerate widgets I\/O pins and the defaults associated with them can be explicitly overridden by connecting the inputs to an appropriate source\/sink of the type required. Default values can be read and edited as part of the widget editing process. The interface provides a semi-automated and convenient method of resolving type conflicts and inserting the appropriate type conversion widgets. Type conversion widgets generally have many degenerate inputs and outputs, each of which will interface to a particular type. The interface is able to recognize type conversion widgets for what they are (via a dedicated flag), and when a type conflict occurs, searches all available type converters for those that meet the necessary input and output criteria. When all suitable type converters have been identified, the user is able to select the most appropriate from a list of all converters that meet the criteria.","Widget data-flow inputs and outputs can be connected to other data-flow inputs and outputs (of a compatible type) in widget editing mode (WEM) in order to define the required widget functionality. For example, a single widget data output can be connected to multiple data-flow inputs. When a multiple input connection is made to a single output, the interface allows the user to choose whether the output is consumed by the first widget that has all inputs available including the input in question (OR consumption logic), or whether it is only consumed when all connected widgets have run (AND consumption logic). Conversely, multiple widget outputs can be connected to a single widget input, in which case the input accepts and consume each widget output as it becomes available. This situation occurs commonly in user control panels where a number of buttons effect the state of a single widget\/display. It is possible (though uncommon) for multiple widget outputs or sources to be connected to multiple widget inputs or sinks. This capability may be important for widget mediated load sharing across multiple server processes, for example.","Every widget has the potential to accept a single control flow input and to generate a single control flow output; these pins are degenerate (i.e., are ignored unless actually connected). In the preferred embodiment, control pins cannot have defaults associated with them. Like data-flow inputs and outputs, control-flow pins can be wired up to other control flow pins, but not to data flow pins (unless of Boolean type). Control flow wiring carries an implicit Boolean value indicating that the control flow criteria concerned has or has not been met. If the control flow condition has not been met, then control flow wiring carries the value false, and does not trigger any connected control flow inputs. If the condition has been met, the wiring carries a true value and triggers any connected control flow inputs. Unless explicitly altered within a widget definition, a widget's control flow output goes true immediately upon completion of execution of that widget, it goes false immediately after execution of the widget begins. If a widget's control flow input is connected, then execution of that widget cannot begin until the control flow signal to which it is connected is asserted. Normally, it is likely that compound widgets can be constructed entirely based on data flow programming and without the explicit use of control flow pins. However, there are a number of situations, especially those involving the synchronization of multiple server processes, which may require use of the control flow pins. The system also permits a tie between multiple control flow outputs and a given control flow input in which case the associated widget cannot begin execution until all data flow inputs are satisfied and, either the AND or the OR of all control inputs is asserted (depending on the type of control input used). Selection of either a control flow OR\/AND for a widget control input is generally performed when connecting control flow signals. The system also supports connections between a single widget control flow output to multiple different control flow inputs. In this case, all widgets whose inputs are so connected cannot execute until the control flow output is asserted. Unlike data-flow connections, control flow signals are not \u2018consumed\u2019 by the receiving input pin, but remain asserted until source widget activity drives them false. This means that, in general, control flow signals can be multiply sourced and synced without the potential for confusion as to what will happen. In the preferred embodiment, all logical operations on the control flow signals are the responsibility of the engine\/interface; this knowledge does not propagate into the widget itself. It is possible to connect a control flow signal or pin to any data flow signal of the system defined type Boolean; connection to any other data flow type is generally forbidden.","The degenerate widgets of a widget pack are capable of accepting and producing both formal and degenerate data flow I\/O pins as well as the standard control flow pins. Individual members of a widget pack can be invoked independently of other members of the pack but all members of the pack share the same storage area; this storage area is allocated at the time the widget pack is instantiated (generally via the initialize entry point of the formal widget), and is passed by reference to each member of the pack as it is invoked by the engine. As with all other widget types, a degenerate widget of a widget pack only executes when all of its inputs become available. Degenerate widgets need not provide any entry points other than the \u2018execute\u2019 entry point, the engine invokes the entry points associated with the formal widget of the pack when using entry points other than execute. All widgets of a widget pack are stored together in a single file and for the purposes of copying and other activities using the WEM menus are treated as a single unit. It is generally not possible to treat a degenerate widget of a pack as if it were a fully defined atomic widget within the normal WEM environment.","Within a pack, the various members can communicate with each other via the data area and can also directly invoke other members of the pack. As a result, it is valid for degenerate widgets of a pack to contain nothing but outputs which are presumably produced when the internal state of the pack meets certain criteria.","A View can be thought of as a mini application, whose functionality is defined by the widgets it contains and the data flows between them. A view's appearance is most easily defined by superimposing the display components of all widgets in the view on a background that is an image. Views provide the framework within which it becomes possible to instantiate and execute the various atomic and compound widgets. No widget can execute unless it is either explicitly or implicitly contained in a view. Views are preferably stored in view definition files which may be accessed and initiated via the environment's view menu. Each view definition file contains as a minimum the following components:\n\n","Views may be in one of two states: active or inactive. An active view is one that is currently executing and has therefore loaded all contained widgets into the engine where they are currently executing. An inactive view contains no executing widgets and is not currently loaded into the widget engine. Every view has associated with it a window which may or may not be visible at any given time. For the purposes of this description, the view that is associated with the front window on the user's screen is known as the front view and only one view can be the front view at any given time. This would not necessarily be the case in alterative display environments that permit 2+ dimensional views, however. Unlike widgets, views are generally not nested within (in a visual sense) other views. A view is always the outermost component or container for a given user defined functionality and usually has no relation to the current screen position of any other view. Views also can be combined into groups called view packs and these views packs share a logical context much in the manner of widget packs.","As set forth above, a view has associated with it a compound widget defining the data and control flows between the display and functional widgets that go to make up the view. This compound widget is known as a view widget and is similar to any other compound widget. Because it is part of a view, however, its data flow I\/O pins are connected to other views by means of network events. The majority of view widgets will have zero inputs and outputs. Certain specialized views, however, may be controlled from other views and in such cases the controlling view will have data flow outputs while the controlled view will have corresponding data flow inputs. View outputs may also optionally include a target view and network node in order to route the event to the intended destination. If no such qualifiers are included, the event will be sent to any views in the local environment that contain inputs whose name and type exactly match that of the view output. If no such inputs exist, the data flow output is discarded. Unlike other widget types, a view widget is scheduled (or rescheduled) whenever any of its inputs becomes available. Internal scheduling of the view, however, may be suspended should other required inputs still be undefined.","Any component of a view widget may also have (one or more) panes associated with it. In such cases, the view causes a marquee or image of that pane to appear in the view layout window where it may be re-sized (within limits) and relocated as part of the view layout process. Panes are normally rectangular but it is possible to create and interact with panes that occupy any arbitrary closed region. A view may be comprised of many panes, each of which represents the display region of the widget responsible for interpreting or displaying the control\/display that the pane relates to. For widgets whose appearance is fully determinable at layout time (e.g., named buttons), the final widget appearance is shown in the pane during view layout.","As described above, the WEM window provides the interface in which views and widgets may be edited, modified or displayed. For example, within the WEM window, the subordinate widgets and the data flow between them is displayed. In the preferred embodiment, colored lines that join the pins of widget icons\/symbols to other pins in the diagram represent data flow. The color of the line can be used to convey type information. Wherever one or more lines in a WEM window is joined in terms of data or control flow, this is represented by a standard line junction symbol. By default, data-flow outputs are consumed when the widget associated with every connected input has been triggered. The user has the option to select that the output be consumed when the first widget that has a connected input is triggered. These two forms of signal consumption logic are referred to in this document as \u201cOR consumption\u201d (first triggered widget input consumes output) and \u201cAND consumption\u201d (output is only consumed when all widgets with triggered inputs have been run). Different forms of data flow output consumption logic may also be implemented by the scheduling engine. Control flow signals are never \u2018consumed\u2019. They remain asserted until renewed widget activity causes them to go false. There is an implicit latch on every widget data input so that regardless of the consumption logic operating outside the widget, within the widget, the input may operate using either OR\/AND Consumption, the default is AND Consumption. When multiple data-flow outputs are connected together to one or more data flow inputs, the same consumption logic applies to all connected widgets. During execution, a second output value will not be applied to the interconnect signal by the engine until any previous output has been consumed, thus forming an automatic queuing mechanism.","The representation of various standard programming constructs (such as the loop, switch, and conditional statement) are also supported within a WEM window. For example, the conditional statement (i.e., if then) is provided by an atomic widget that accepts a string defining an arbitrary expression in terms of the widget inputs that resolves to a Boolean value either directly (because all inputs are Boolean), or as a result of use of a comparison operator within the expression. This atomic widget has two degenerate outputs which are automatically displayed when the widget is placed. The first corresponds to the YES condition, the second to the NO condition. The conditional widget only generates one or other degenerate outputs when it runs. As a result, any data flow connected to the un-generated output will not be executed. The conditional widget has a single formal input that accepts the Boolean expression, and a large number (up to 26) of degenerate inputs each of which will accept any scalar numeric value or a derived type. Each connected degenerate input can be referred to in the expression by its lower case letter or signal name.","Referring now to , an example of a conditional statement is shown. In this example, a compound conditional statement of the form: \u201cif (a=b) && (c*d<e) then . . . else [if (a>0.3) then . . . else . . . ]\u201d is provided. Because the outputs , , ,  of the conditional widgets are both degenerate, either the \u2018then\u2019 clause or the \u2018else\u2019 clause may be omitted simply by not connecting the corresponding output , . This gives the user the freedom to create any conditional statement that he wishes simply by combining simple \u2018if\u2019 blocks as desired. Note also that if the user simply wanted to connect a widget that did not expect a Boolean parameter as input to either the then or the else clause of a conditional widget, he can do so simply by connecting the Boolean output from the conditional widget to the control flow input of the widget required. This is because, in the preferred embodiment, control flow pins may be connected directly to data-flow signals of the system supplied type Boolean. Since control flow inputs are only triggered when a Boolean true value exists, any widget thus connected will only run when the appropriate clause is satisfied. In example illustrated in , the else clause of the first conditional widget  will produce no output unless the first condition is met when it will output a true value. This means that the expression \u201ca && (b>0.3)\u201d  is not required in the negative case since the widget  will not even run unless condition  is true.","The case or switch construct is provided by an atomic widget that takes as input two values. The first value is a comma-separated list of constant integer expressions (includes characters) or ranges, the second is an integer value to be evaluated against the list. The output of the case widget is a variable number of degenerate Boolean outputs (each of which preferably represents one of the case conditions being satisfied) and the first of which is always the default case (i.e., no other condition satisfied). Only one case widget output will be generated on any given execution of the widget, and as for the conditional widget, it outputs the Boolean value true. If no specified condition is met then an output will be produced on the default pin.","Referring now to , an example case statement using an atomic widget is shown. In this example, the case statement within the widget  evaluates the integer input  against 5 different values or ranges. Only one of the outputs , , , ,  will be generated as a result of widget  execution. This is true even if more than one condition is met due to overlapping ranges. When ranges for a case widget overlap, only the first condition in the list to be satisfied will cause an output. First, in this case, would be represented by going from top to bottom among the outputs , , , , . Because case widget outputs behave identically to conditional widget outputs, they can be used to trigger other widgets via their control input pins in the same manner described above for the conditional widget. The interface preferably prevents the user from connecting different inputs of a downstream widget to signals that are directly or indirectly connected to different output pins of either a conditional or a case widget within the WEM window. This is because, since only one such pin can be triggered by definition, any downstream widget that relies on more than one such widget output, will by definition never execute. This condition is normally enforced by the block structure of standard programming languages but since, in a visual environment, this structure may not be so apparent, block structuring is preferably enforced by the WEM environment. In the visual environment, the outputs of a case widget may be automatically labeled with the case value. This feature is depicted in the diagram above with respect to outputs , , , , . The WEM interface is also capable of highlighting all widgets and connections that are \u2018downstream\u2019 of a given selection in the WEM diagram by special UI actions.","The WEM interface would also preferably prevent the user from connecting a data flow output of any widget (A) to any data flow input of a second widget (B) that either directly or indirectly is required to run in order for the widget (A) itself to become eligible to run. This requirement is made in order to prevent the user from accidentally setting up data flow diagrams that have hidden loops in them that mean they will not execute (or will always execute). Note that this requirement by itself makes it impossible to construct the \u2018loop\u2019 programming construct using pure data flow connections and widgets not expressly designed to implement loops. Loop constructs generally require the use of a variable to pass values from one loop iteration to the next. Once initialized, the variable value is always available and hence removes the possibility of creating a data flow input condition that cannot be satisfied. When a user attempts to create a data flow dependency loop in WEM mode, he is preferably warned of this fact and given the opportunity to create a variable that removes the disallowed dependency. In the event that a data or control flow input pin is multiply sourced, and one source is not dependent on execution of the widget concerned, then it is permissible to connect a downstream widget output to this widget input pin. There are a number of problems associated with loops that make them difficult, if not impossible to implement in a data flow design without enforcing block structuring (i.e., putting the loop body within a compound widget), these are:\n\n","For the reasons described above, loops are implemented by one or more system supplied compound widgets that provide a number of degenerate universal input and output pins for passing data of any type into and out of the loop body and which allow specification of the loop behavior.","A suggested set of widget scheduling rules to be enforced by the engine is given in the table below. Many of these rules appear throughout the text above but they,are summarized and augmented here in order to make the full rule set more apparent. The term widget is used below to imply both atomic widgets and compound (or view) widgets. When a distinction is required, the particular widget type is explicitly stated. The term signal is used below to refer to either a control flow or a data flow. Where a distinction is required, the type of signal (control or data) is explicitly stated. The term token is used below to refer to a data flow signal to which a value has been written, but has not yet been consumed. A linear compound widget is defined as a one that does not include any explicit connection to the control flow output. A cyclic compound widget is defined as a one that includes an explicit connection to the control flow output and which therefore may include explicit loops. A descendant widget Z of an ancestral widget Y within an enclosing compound widget X is defined as any widget within the WEM diagram for X that either directly or indirectly depends on data or control flow outputs from Y in order to become eligible for scheduling. Z is a formal descendant widget of Y if the dependency between Y and Z is mediated by signals connected only to formal widget outputs. Z is a degenerate descendant widget of Y if the dependency between Y and Z is mediated by at least one signal connected to any intervening degenerate widget output. The various descendancy terms described above may also be applied to the data or control flow signals attached to the widget Y. A pure data flow signal is defined as one that is not attached to a variable or constant symbol. A pure descendant data flow is one that can be traced back to a given ancestor through pure data flow or control flow signals alone.",{"@attributes":{"id":"p-0052","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Scheduling Rule"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"A widget is eligible for scheduling only when all of its connected data"},{"entry":"flow inputs have a token associated with them. A view may be scheduled"},{"entry":"whenever any of its data flow inputs have a token associated with them"},{"entry":"but may subsequently \u2018hang up\u2019 should other inputs be required and"},{"entry":"still be undefined."},{"entry":"If a widget has an explicit connection to its control flow input pin, then"},{"entry":"that widget (and any widgets it contains) is only eligible for scheduling"},{"entry":"when the value of the control flow pin is set to TRUE. This applies even if"},{"entry":"the widget is compound and has already started execution. (i.e., you can"},{"entry":"single-step a compound widget to any nesting level simply by explicit"},{"entry":"control of the highest level control pin)."},{"entry":"Execution of a linear compound widget (and all widgets called by it)"},{"entry":"completes when all of its connected output pins have data tokens"},{"entry":"associated with them (i.e., have been assigned a value)."},{"entry":"Execution of a cyclic compound widget (and all widgets called by it)"},{"entry":"completes when the control output pin is driven TRUE by the control or"},{"entry":"data flows within the widget. The implementation may encapsulate this"},{"entry":"functionality so that for standard loops, the user is unaware of the"},{"entry":"control pin connection."},{"entry":"Once a widget has been scheduled for execution, it cannot again become"},{"entry":"eligible for scheduling until execution completes."},{"entry":"If a widget input is specified as \u2018only on update\u2019 then that widget"},{"entry":"only becomes eligible for scheduling each time a value is written to the"},{"entry":"data flow signal connected to that input. This applies even if that signal"},{"entry":"has an un-consumable token associated with it (see below). If multiple"},{"entry":"values are written to the input signal before the connected widget is"},{"entry":"scheduled, it is scheduled only once in response to the series"},{"entry":"of updates."},{"entry":"The following signals have tokens associated with them that cannot be"},{"entry":"consumed:"},{"entry":"1) Any signal that is connected to a variable symbol once that variable"},{"entry":"becomes valued. If that signal is also attached (within the compound"},{"entry":"widget) to a variable symbol, then the input value may be overwritten"},{"entry":"by subsequent widget action. Variable values once written, persist across"},{"entry":"multiple executions of the same widget in the same context"},{"entry":"2) Any signal that is connected to a constant symbol."},{"entry":"3) Any signal that is directly connected to a widget control flow output."},{"entry":"4) Any signal that is directly attached to a connected or defaulted data"},{"entry":"flow input of a compound widget."},{"entry":"A pure data flow that is specified as AND consumption logic (the default"},{"entry":"during construction), causes any tokens associated with that flow to be"},{"entry":"consumed only after all widgets that have input pins connected to that"},{"entry":"data flow have been scheduled . If multiple widgets have"},{"entry":"input pins connected to the pure data flow signal in question, then each"},{"entry":"may be scheduled only once as a result of any given token appearing on"},{"entry":"the signal even if that token remains unconsumed."},{"entry":"A data flow that is specified as OR consumption logic (during"},{"entry":"construction), causes any tokens associated with that flow to be consumed"},{"entry":"by the first widget that has an input pin connected to that data flow, and"},{"entry":"which is scheduled and completes."},{"entry":"For a linear compound widget, the engine drives the control output pin"},{"entry":"FALSE at the time the widget is first scheduled, and TRUE when widget"},{"entry":"execution completes."},{"entry":"A trash can symbol will immediately consume any tokens associated with"},{"entry":"the data flow to which the trash can is attached (even if other widget"},{"entry":"input pins are also attached). Trash cans may not be attached to any"},{"entry":"signal which by definition cannot be consumed."},{"entry":"Within any compound widget X, once a widget Y has been scheduled and"},{"entry":"executed, it cannot become eligible for scheduling again while any"},{"entry":"unconsumed token remains on a pure descendant data flow signal."},{"entry":"Any widget whose output is attached to a multiply sourced pure data"},{"entry":"flow signal that currently has a token associated with it, can be"},{"entry":"scheduled and executed (but not completed); the engine will not write"},{"entry":"any new token(s) produced by that widget until the pre-existing token"},{"entry":"on the backed-up output data flow signal has been consumed, nor will"},{"entry":"the engine permit the control flow output to go TRUE until this is the"},{"entry":"case. Furthermore, the widget (and any widgets it contains) is no longer"},{"entry":"eligible for scheduling and execution regardless of tokens appearing on"},{"entry":"its inputs, until the engine has transferred its previous output tokens"},{"entry":"onto the relevant data flow signals."},{"entry":"If a widget Y within a compound widget X is identified as an \u2018as needed\u2019"},{"entry":"widget (for example a dialog widget) then in addition to any other rules"},{"entry":"that might apply, that widget will not be scheduled or executed until its"},{"entry":"output is required in order to cause another widget within X to become"},{"entry":"eligible for scheduling."},{"entry":"Any widget Y within a compound widget X whose outputs are exclusively"},{"entry":"connected directly or indirectly to unconnected degenerate outputs of X"},{"entry":"(or to a trash can), will not be scheduled or executed regardless of"},{"entry":"tokens appearing on its inputs. Furthermore, the widget Y is not"},{"entry":"considered in any consumption logic applicable to signals connected to"},{"entry":"its input pins. To all intents and purposes Y is completely ignored in"},{"entry":"all scheduling activities related to X. This rule can be enforced at"},{"entry":"load time, it is not dynamic."},{"entry":"Any widget Y within a compound or view widget X, and which has zero"},{"entry":"connected inputs, never becomes eligible for scheduling or execution."},{"entry":"To cause such a widget to execute, its control input pin must be driven"},{"entry":"true by connecting it either directly to the control input of X or to"},{"entry":"another Boolean signal within X."},{"entry":"Once any widget Y has been scheduled and executed within an enclosing"},{"entry":"widget X, it is automatically moved to the last position in the scheduling"},{"entry":"check sequence so that in addition to all scheduling rules outlined above,"},{"entry":"the widget Y is not even checked again for scheduling eligibility until"},{"entry":"every other widget with in X has been checked on a subsequent pass."},{"entry":"All rules described above apply equally and simultaneously to every"},{"entry":"level of a view and the various subordinate compound widgets that it"},{"entry":"calls to any arbitrary level of nesting. Scheduling of the various"},{"entry":"components of each nested WEM diagram occurs independently of other"},{"entry":"levels except that each nested compound or atomic widget must complete"},{"entry":"before its output signals become available at the next higher (calling)"},{"entry":"level and thereby potentially cause one of the rules described above to"},{"entry":"be triggered at the higher-level."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"While the illustrated widgets give the appearance of passing widget inputs by value, for efficiency reasons the implementation (wherever possible) passes widget inputs and outputs by reference, not by value. Pass by value is only required in cases where the widget input is overwritten within the widget itself (by use of a variable symbol), and the signal is not simultaneously attached to a formal widget output within the WEM diagram. Because of the scheduling rules described in the table above, the internal values of any inputs to a widget that are supplied by pure data flow connections cannot change during the period of execution of that widget. Preferably, inputs that are externally attached to a variable symbol may potentially change during widget execution.","While the table given above describes the rules that relate to scheduling and execution within a particular context, it is important to understand that simultaneously there may be many active views, all of which are being scheduled and executed. This gives rise to a number of considerations with regards to prioritization between the various views that are illustrated in the scheduling algorithm.","The scheduling algorithm forms the core of the system architecture in that all system functionality, at some level or another, is initiated as part of a view launched within the scheduling environment (referred to as the \u2018widget engine\u2019). The WEM user interface, including widget building and view editing, can be thought of as a separate application from the scheduling process itself, and could be replaced with other user interfaces without changing the widget engine itself. The widget engine is a strongly-typed data flow interpreter which can read in and subsequently execute atomic and compound widgets together with the data structures that define their I\/O needs and characteristics.","Referring now to , a sample embodiment of a Widget Editing Mode (WEM) window  is shown. In the illustrated example, the window  is a standard, titled, resizable window with scroll bars . The window  is used to define and edit data-flow functionality by connecting and configuring widgets . The two blocks ,  connected by arrows to the edge of the window are the input and output bar of the compound widget being viewed. In this example, a single degenerate input  and single degenerate output pin  have been defined for this compound and connected to an embedded compound . In the preferred embodiment, this example could be created simply by clicking on the pin , dragging to the destination pin  it is to be connected to, and setting the type. The specialized pins ,  at the top of the input  and output bars  are the control input pin  and control output pin  respectively. In the preferred embodiment, their type is always equivalent to \u2018Boolean\u2019. As this diagram illustrates, the control output pin is wired to the constant , in this case true, which will enable the contents of the compound widget to run. The background widget  is a pre-supplied atomic widget serving the specialized purpose of defining the background visual appearance of the associated window. In this embodiment, the tool bar  provides (starting from the top):\n\n","Referring now to , a full-featured icon-editor that allows alteration of the widget icon is shown. In this example, the result of double-clicking on the icon  in the  is shown.","In the illustrated embodiment, a menu bar  is provided which provides an interface to a set of unique tools. Working across the menu bar at the top of the window (from left to right):\n\n","The file menu  allows standard save\/load type actions to\/from disk. A sample embodiment of a file menu  of the WEM is provided in .\n\n","The Debug menu  is used primarily during run-time debugging of widget execution and allows examination of the state of all flows, widgets and pins and the tokens and data on them. A sample embodiment of the debug menu  of the WEM is provided in .","Referring now to , a sample Pin information dialog  is shown. In the preferred embodiment, this dialog  is generated in response to either double-clicking on a pin in the diagram or using the menu . Various aspects of the pin, including it's type (as preferably determined by the run-time type system) and any other logic associated with the pin and it's data-flow behavior can be set from this dialog.","Referring now to , a user in the process of choosing the type  of a constant symbol in the WEM diagram within the type pop-up menu  of the constant information window  is shown. This further illustrates the connection between the types system provided by the substrate and the types of data on flows and pins.","Referring now to , a dialog window  generated in connection with selection of the view or widget information window in the setup menu  is shown. As can be seen, the dialog window  allows adjustment of a wide variety of different aspects that apply to the view or widget including file path, security settings, operation behavior, visual dimensions, behaviors, and limits, and a variety of configuration and documentation descriptors.","It is clear, then, that the illustrated WEM and visual language described above allow users of the system to express and specify analytical processes in terms of data flowing between a set of computational blocks. The visual language of the present invention preferably provides the following basic features:\n\n","At the same time the data-flow wiring for a new view or widget is defined, the visual appearance is created. The interface that allows this is called View Editing Mode (VEM). Referring now to , a simple calculator widget\/view  is shown. The figure displays the structure of the view  of the calculator. Each section of this figure (such as the buttons, title bar, calculator display window) can be created separately, and the individual sections of the view result in the final view, which also may be created and edited in the View Editing Mode window.","Referring now to , an illustration of the structural components of the calculator widget\/view  is shown. In this case, the broken-down structure comprises:","Background \u2014The plain background of the calculator where the number keypad will be added;","View Layout \u2014The view layout (the keypad itself);","View \u2014The final view, including the background  and view layout , complete with 0.0 shown as the initial output on the display is shown.","Logically, something would need to be attached to the keys on the keypad to allow for performing calculations. Clicking the visually displayed numbers of the photograph of a calculator does not perform a function. These numbers would need to be attached to something that could actually read and manipulate them. In other words, a mere picture does nothing. Hence, once the drawing is done, the keys must be connected to an electronic device representing each individual key and its underlying meaning. This electronic equivalent, in our case, is known as a widget. Widgets are connected to the keys and act as valves that regulate the flow of electronic information. On the calculator, for instance, the widget for the 9 key would act as a valve for the constant valve ; the plus sign (+) widget would act as the valve for the add operation. In the preferred embodiment, the VEM process allows the appearance of the calculator to be created. Once the physical appearance is complete, the internal connections must be made to enable arithmetic functions. Widgets, electronically connected to the numeric keypad of our calculator, display a different diagram, but are identical in performance to the calculator.","Referring now to , an internal diagram of the calculator as it would appear in the preferred Widget Editing Mode window is shown. This figure illustrates a view known as a view widget, which contains a collection of atomic or compound widgets, each of which may have at most one user interface region, or pane. It is in this window that users can make modifications using the WEM capabilities described above.","For explanation purposes, each individual column in the diagram is described and numbered as a single item. It is described in this fashion because each element within the column performs the same general function.\n\n","The data-flow scheduling algorithm is the next important part of the system. The data-flow scheduling algorithm is described below by listing the algorithms for a series of recursively invoked functions. The global value \u201cEG\u201d is a complex structure containing various context and state information used by the environment and including the values utilized by the scheduling process.","The top level of the data-flow based scheduling algorithm is the routine SC_Scheduler( ) which is called in a continuous loop from the main thread of the environment. This routine arbitrates the scheduling of the various active views currently loaded into the environment. The principal task performed by this routine is to enforce the levels of scheduling priorities associated with the active views. To do this SC_Scheduler( ) makes use of a global active views scheduling structure which contains a set of list headers each of which points to the first element in a singularly linked list of active views having the same priority level. Because this routine locks the view being scheduled, any code operating in the main application thread that is called via this routine can be sure that pointers to structures within the current view will not become invalid during procedure execution. Code running in other threads must either lock the view, or save\/restore pointers in a relative form to ensure correct pointer values across scheduling boundaries or heap movements. SC_Scheduler( ) (and everything it calls) assumes that the application thread is in a critical section (i.e., can't be preemptively disturbed). While there are outstanding events to be processed in any view, this routine alternates between scheduling the view at the top of the pending events list (and then rotating the list) and scheduling a view according to the normal view priority scheme. In this manner the system ensures that events are processed as rapidly as possible without allowing event intensive views to suppress all other scheduling. The same mechanism is repeated in SC_ScheduleView( ) to the normal tree walking algorithm.",{"@attributes":{"id":"p-0075","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["void SC_Scheduler","(","\/\/ data-flow scheduler"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},")","\/\/ R:void"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"bump the scheduler cycle count"]},{"entry":[{},"handle any pent-up interrupt level stuff after any slot"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"j = rand ( );","\/\/ breaks certain deadly"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"cycles!"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"j = j | (1 < < (kLowestEpriority+1) ) ;","\/\/ set backstop bit"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EG->Priority = find the first bit set in cycle count word j"]},{"entry":[{},"if ( EG->Priority > kLowestEPriority )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{","\/\/ run any background"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"tasks"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"do whatever regular monitoring etc. environment wants to do"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return;","\/\/ at lowest priority"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"possible."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"tmp = NULL;"]},{"entry":[{},"pnd = NULL;"]},{"entry":[{},"if ( ! (EG->MitopiaFlags & kVeventBasedSlot) && EG->"]},{"entry":[{},"PendEvtHdr )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{","\/\/ do views with events"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"first"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"pnd = tmp = EG->PendEvtHdr;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"EG->Priority = (*tmp)->dPriority;","\/\/ set priority to match"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"view"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EG->MitopiaFlags | =","\/\/ remember we did an"]},{"entry":[{},"kVeventBasedSlot;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"event slot"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else","\/\/ alternate between"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"event and"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{","\/\/ normal slots on each"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"pass"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EG->MitopiaFlags &= -","\/\/ just a plain kind of"]},{"entry":[{},"kVeventBasedSlot;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"slot"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tmp = EG->ActiveViews [EG->","\/\/ front active view at"]},{"entry":[{},"Priority] [0] ;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"priority"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"pnd = 0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SC_SetCurrentWidget(tmp,view widget","\/\/ set the chosen view"]},{"entry":[{},"(*tmp) );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"widget"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"lock down the view (tmp) while we cruise around it and schedule"]},{"entry":[{},"below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"tmp = SC_ScheduleView(tmp,...) ;","\/\/ schedule a single view"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"unlock the view (tmp) till the next time..."]},{"entry":[{},"rotate EG->ActiveView [EG->Priority] [0] to tail of list at priority"]},{"entry":[{},"if ( (EG->MitopiaFlags & kVeventBasedSlot) && EG->"]},{"entry":[{},"PendEvtHdr == pnd && pnd)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{","\/\/ rotate pending list"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"also"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"move pnd to tail of EG->PendEvtHdr","\/\/ avoids greedy event"]},{"entry":[{},"list"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"problems"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As can be seen from the algorithm above, scheduling within any given view is handled entirely by the routine SC_ScheduleView( ) once the view itself has been selected based on pending event lists and priority. This routine is called by SC_Scheduler( ) to give a scheduling slot to a particular view. In most cases this amounts simply to a call to SC_ScheduleNode( ) for the view widget, but in addition this routine must deal with the special rules associated with starting and stopping views and the propagation of their tokens. Note that an exception to the fair handling of scheduling slots is made for any widgets that are waiting for non-timer related events which have occurred, these are scheduled immediately in order to ensure that events get eaten ASAP. An example of the logic that could be used to perform this routine is provided in Appendix A.","The two main routines that are called by SC_ScheduleView( ) above are SC_ScheduleNode( ) and SC_ScheduleANode( ). SC_ScheduleNode( ) is the primary function that is responsible for enforcing the rules of data-flow in the system. This routine is recursive and is responsible for implementing the depth first tree walking scheduler algorithm. In order to facilitate navigation around the various levels of the compound widgets that make up the hierarchy associated with a given view, SC_ScheduleNode( ) makes use of three basic structures: the widget descriptor record (type ET_Widget), the flow descriptor record (type ET_Flow), and the pin descriptor record (type ET_Pin). The following are the scheduler uses of the relevant fields in an ET_Widget record:\n\n","The following are the scheduler uses of the relevant fields in an ET_Flow record:\n\n","The following are the scheduler uses of the relevant fields in an ET_Pin record:\n\n","During normal processing, the scheduler algorithm attempts to walk any given tree (view) in the environment's active views list and when it finds an active token that can potentially be consumed by running or resuming an atomic widget, it does so. The algorithm is predicated on the following facts:\n\n","The scheduler tree traversal algorithm is recursive, i.e., it calls itself repeatedly as it walks down the tree, starting at the view widget until it finds a leaf node (atomic widget) that can be scheduled. It then either starts or resumes that widget and when the widget completes, it returns back up the calling chain. As the algorithm climbs back up the path it rotates the token list for every level in the tree by moving the token that was at the front of the list (i.e., the one that determined which attached widget it chose in the downward path), to the back. The effect of this repeated descent and ascent algorithm is to allocate sequential time slices, at any given level of the tree, to widgets that are as far apart as possible in the tree. This is designed to prevent undesirable bunching of time allocations to a given compound widget. Atomic widgets that are higher up in the tree will get more time slices than those that are further down. This is as it should be since higher up atomic widgets generally correspond to UI related displays and controls which must be as responsive as possible, and which will not actually be eligible to run unless the UI event on which they are waiting has occurred. One possible side effect of the algorithm is that at any given level, the smaller branches of an unbalanced tree get more scheduling slots than larger ones. A tree-balancing algorithm, if desired, could correct this behavior. This algorithm returns to the caller (SC_Scheduler) after a single descent and ascent. SC_Scheduler( ) itself then selects another view and priority group and repeats the process. Thus available CPU time slots are distributed over all views in the system according to priority. Widgets in many other views may be scheduled before SC_Scheduler( ) again returns to this view and performs another descent and ascent of this tree. Sample code for one embodiment of SC_ScheduleNode is provided in Appendix A.","The logic for SC_ScheduleANode (schedule atomic node) is broken out separately from SC_ScheduleNode( ) so that nodes that are atomic can be forcefully scheduled based on non-data-flow related events. Sample code for SC_ScheduleANode( ) is provided in Appendix A.","The routine SC_StartWidget( ) is responsible for checking that all the necessary conditions have been met for starting a particular widget. This routine is therefore responsible for enforcing the rules of data flow as well as the modifications to these rules described above. Once SC_StartWidget( ) has determined that a widget is eligible to run, it actually launches it using either SC_StartAWidget( ) or SC_StartCwidget( ) (depending on whether the widget is atomic or compound). If the widget concerned is ineligible to run for any reason, this routine returns FALSE otherwise it returns TRUE. This routine can also be called with the parameter \u2018JustCheckin\u2019 set to TRUE in which case it makes all necessary checks for eligibility (other than those for input availability) but does not actually cause the widget to be started. That is, it calls itself under certain circumstances in order to find out if widgets that are descendant from the current widgets (in terms of data flow, not hierarchy) have started or are ready to start. Sample code for this Algorithm is provided in Appendix A. This routine is recursive.","The function SC_StartAwidget( ) is called by SC_StartWidget( ) once it determines that all the necessary conditions have been met to actually initiate execution of an atomic widget. Initiating execution of an atomic widget involves creating a seperate execution thread for that widget to run in. In order to maintain this seperate thread, the thread manager software requires a seperate stack area which the atomic widget will use once launched. Every atomic widget contains a stackSize field which gives the maximum size of stack that the widget anticipates will be required in order to execute. Because the atomic widget retains control of the CPU once the thread has been launched, the scheduler has no way of preventing erroneous widgets from stepping outside their stated stack allocation and thus corrupting the heap. It is therefore very important that widgets ensure that this does not occur. This routine can however detect that such an error has occured after the fact and when widget execution completes, SC_StartAwidget( ) will report an appropriate error if stack debugging is enabled. The mechanism used is to place test patterns at various points within the allocated stack area, especially at the end point. When widget execution completes, these patterns will have been erased up to the deepest point that the widgets stack reached. If the test pattern at the end of the allocation has been overwritten then the widget is erroneous, otherwise the other test patterns may be used to determine actual stack requirements. Filling an area of heap with these test patterns consumes time and stack debugging should preferably be enabled only when developing new atomic widgets. Because a widgets initialization code may contain suspends, this routine may be re-entered a number of times for the same widget before initialization is complete. By returning a false for inclomplete initialization and not setting the \u201ckIsRunning\u201d flag, we can be sure that SC_ScheduleNode( ) will keep calling us until done. Sample code for one embodiment of SC_StartAWidget is provided below:",{"@attributes":{"id":"p-0085","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Boolean SC_StartAwidget","(","\/\/ Start atomic widget"]},{"entry":[{},"execution"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ET_ViewHdl","aView,","\/\/ I:View handle"]},{"entry":[{},"ET_WidgetPtr","aWidP,","\/\/ I:widget record"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"pointer"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Boolean","InitializeOnly","\/\/ I:if TRUE, just"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"initialization"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},")","\/\/ R:TRUE if started"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if ( aWidP->wThreadID )","\/\/ thread was already"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"running"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if ( !(FLAGS(aWidp) & kHasBeenInitialized) )","\/\/ resume\/start"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"initialize"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SC_ResumeWidget (aView,aWidP,NO);","\/\/ Resume the widget"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if ( !((FLAGS(aWidP) & kHasgeenInitialized) | | aWidP->wThreadID) )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{","\/\/ make a widget thread"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"aWidp->wThreadID = create new thread"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"err = yield to thread(aView,&aWidp,kInitializeEntryPt...);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if ( !InitializeOnly && !(FLAGS(*aView) & kKillThisView) )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if ( !err && (FLAGS(aWidP) & kHasBeenInitialized) )"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"err = yield to thread (aview,&aWidp,kExecuteEntryPt...);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"return (err == 0 && (FLAGS(aWidP) & kHasBeenInitialized) );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The routine SC_StartCwidget( ) starts execution of a compound widget once all the necessary preconditions have been satisfied. Since there is no code associated with a compound widget, the process of starting one essentially consists of copying the tokens on the external input pins into the internal flows of the compound widget so that these may in turn stimulate contained widgets into execution. Sample code for one embodiment of SC_StartCWidget is provided below:",{"@attributes":{"id":"p-0087","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Boolean SC_StartCwidget","(","\/\/ Start compound widget"]},{"entry":"execution"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ET_ViewHdl","aView,","\/\/ I:View handle"]},{"entry":[{},"ET_WidgetPtr","aWidP","\/\/ I:widget record"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"pointer"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},")","\/\/ R:TRUE if widget was"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"started"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"oldFlags = FLAGS(aWidP);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"FLAGS(aWidp) | = kIsRunning + kHasBeenInitialized;","\/\/ set widget's init &"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"run flags"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for (all formal and degenerate inputs)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mask = get the masks for available inputs"]},{"entry":[{},"i = get count of number of pins of that type"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"while ( i )","\/\/ for all pins of this"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"type"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i--;"]},{"entry":[{},"pinName = i + \u2018A\u2019 or \u2018a\u2019;"]},{"entry":[{},"pin = get the pin concerned"]},{"entry":[{},"iflow = get the flow connected to it within the compound widg."]},{"entry":[{},"xflow = get the flow connected to it outside the compound widg."]},{"entry":[{},"if ( iflow )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SC_AddAToken(iflow);","\/\/ add a token to"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"internal flow"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if ( iflow->value )","\/\/ dispose of old data"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(if any)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"TM_DisposeHandle (0, (anonHdl) iflow->value,...);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if ( !xflow )","\/\/ if pin input !"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"available"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{","\/\/ pin must have been"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"defaulted"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"iflow->value = pin->pDefault;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else iflow->value = xflow->value;","\/\/ external to internal"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"copy"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if ( ret ) SC_SpontaneousTokens (aWidP);","\/\/ generate spontaneous"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"tokens"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if ( aWidP == view widget(*EG->CurrentView) && ! (oldFlags &"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"kHasBeenInitialized)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{","\/\/ routine to mit."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"everything"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SC_InitializeCompoundAtomics (EQ->CurrentView,aWidP);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"return ret;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In the preferred embodiment, the routine SC_ResumeWidget( ) resumes execution of an atomic widget that has previously suspended by calling SC_Suspend( ) either directly or indirectly. This function assumes that all necessary conditions for execution have been checked at the time the widget was started and thus it does not need to repeat such checks. Resumption of an executing widget essentially consists of an explicit yield to the relevant thread. The only subtelty in SC_ResumeWidget( ) is its use to generate certain time based events (idle, tick, second) prior to resuming the thread if the specified time interval has elapsed and the widget is waiting for the time based event specified.","In the preferred embodiment, the routines SC_CheckCtrlStop( ) and SC_CheckCtrlStart( ) may be used to check a flow connected to a control pin to determine if it implies that a widget should be stopped\/started. In the preferred embodiment, the routine SC_TimeToGobbleInputs( ) may be used by the scheduler to determine if it should schedule a given widget based on the state of it's input pins. The logic is complicated by the fact that \u2018exclusive\u2019 pins can cause widgets to fire even when only a subset of the inputs is available.","In the preferred embodiment, the routine SC_Trace2Inputs( ) can be used to check all the outputs of a given widget \u2018aWidP\u2019 to see if they directly or indirectly lead to completing the required inputs of a second widget \u2018cwidg\u2019. The purpose of this is to implement the \u2018as needed\u2019 function whereby widgets that are marked as \u2018as needed\u2019 will only be scheduled by the environment when by running, their outputs might potentially cause another normal widget to become eligible to run. This is the behavior required of many UT type widgets such as dialogs. See SC_StartWidget( ) for usage.","In the preferred embodiment, the routine SC_StopCWidget( ) is called to complete execution of a compound widget. As for atomic widgets, completing compound widget execution involves propagating tokens onto the output flows. Since the output flows of the compound widget may be busy, there is a possibility that the token propagation routine (SC_PropagateTokens( )) may hang up. To simplify this problem, a seperate temporary thread is created to perform the compound widget completion action thus allowing for the possibility of backup. Unlike conventional widget threads referenced from the wThreadID field of the widget record, the threads associated with completing compound widgets are torn down and re-cycled as soon as the token propagation is complete, also these threads only execute internal environment code, not widget code. Note that because the thread may back up, it may be resumed in SC_ScheduleNode( ) many times before completing.","In the preferred embodiment, the routine SC_SpontaneousTokens( ) is called whenever a compound widget is started by the scheduler, and is responsible for generating any spontaneously produced tokens contained within the WEM diagram for that widget. Spontaneously produced tokens are generally associated with constant symbols. Note that although flows with variable symbols attached have unconsumable tokens on them, these tokens are not generated until the flow is first written to, i.e., they are not spontaneous. This routine does not check for whether the output flow is busy and hang up waiting for it to be clear. This is because this is not possible given the fact that this routine is called during widget starting at which time all internal flows are by definition free. Anyway to do so would be fatal to the main thread. In the preferred embodiment, the routine SC_AddAToken( ) adds a token to an existing flow.","In the preferred embodiment, the routine SC_InitializeCompoundAtomics( ) is recursive and initializes all atomic widgets within the specified compound widget and any compound widgets it contains either by calling SC_StartAWidget( ) or by recursively calling itself as required.","The API definition below gives the basic public calls available to widgets\/threads when accessing data on input pins and writing data to output pins. The API is intended to be illustrative only and is by no means complete. The header files for a sample API implementation is provided in Appendix B.","In the preferred embodiment, the function PC_NumDataInputs( ) examines the Widget Input List contained in the specified (or defaulted) widget and returns the counts of the number of formal and degenerate input pins. In the preferred embodiment, the function PC_NumDataOutputs( ) examines the Widget Output List contained in the specified (or defaulted) widget and returns the counts of the number formal and degenerate output pins.","In the preferred embodiment, the function PC_GetDataInput( ) takes an input specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and returns a handle to the storage value for that input or NULL if not found, or if the value of the connected flow is invalid. The handle returned by PC_GetDataInput( ) would preferably NEVER be de-allocated by widget code. The handle returned may be subject to relocation or resizing by the scheduler across any scheduling boundary.","In the preferred embodiment, the function PC_GetDataInputType( ) takes an input specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and returns the type ID for that type. In the preferred embodiment, the function returns zero if the input was not found. The widget may use the returned type ID to obtain further information about the type using the routines provided by the type manager package. In the preferred embodiment, the function PC_GetDataOutputType( ) performs a similar function for output pins. In the preferred embodiment, the function PC_SetDataInputType( ) takes an input specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and a type ID, and sets the type field of the corresponding pin to match the type ID. PC_SetDataOutputType( ) may be used to do the same for output pins.","In the preferred embodiment, the function PC_GetDataInputName( ) takes an input specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and returns a handle to the name string for that input or NULL if not found or unnamed. The caller should dispose of the handle returned by this routine when the string is no longer required. In the preferred embodiment, the function PC_GetDataOutputName( ) is used for output pins.","In-the preferred embodiment, the function PC_IsDataInputConnected( ) takes an input specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and returns a Boolean indicating whether the input is connected or not. If the input does not exist, a FALSE is returned. Note that if the input is degenerate and PC_IsDataInputConnected( ) returns FALSE, the input may still have a default value assigned to it which can be retrieved using PC_GetDataInput( ). Thus the combination of a FALSE from PC_IsDataInputConnected( ) with a non-NULL result from PC_GetDataInput( ) uniquely defines a defaulted degenerate input. A TRUE from PC_IsDataInputConnected( ) together with a null result from PC_GetDataInput( ) indicates an invalid data flow connected to the input. This routine is provided in order to allow atomic widgets to implement the logic associated with degenerate input pins. Because formal inputs are by definition connected (enforced by WEM), this routine simply returns TRUE when called for formal inputs.","In the preferred embodiment, the function PC_IsDataOutputConnected( ) takes an output specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and returns a Boolean indicating whether the output is connected or not. If the output does not exist, a FALSE is returned. This routine is provided in order to allow atomic widgets to implement the logic associated with degenerate output pins. Because formal outputs are by definition connected (enforced by WEM), this routine simply returns TRUE when called for formal outputs. In the preferred embodiment, the function PC_DoesOutputHaveToken( ) can be used to determine if a particular output exists for a widget and has an unconsumed token value already assigned, TRUE is returned in this case, otherwise FALSE.","In the preferred embodiment, the function PC_SetDataOutput( ) takes an output specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and assigns a new value to it. The function preferably returns a Boolean indicating whether the assignment was completed successfully or not. The value is passed to PC_SetDataOutput( ) as a void pointer reference, together with an integer parameter specifying the size of the output object to be created. This routine copies the value into the output value handle in the heap, creating or resizing the handle as necessary. If the output flow already has a token associated with it, this function creates a temporary storage allocation to hold the value. The scheduler will copy any temporary storage values into the connected output data flow when widget execution is complete and the connected output flow becomes free to accept new tokens. Once the value has been copied, the original passed in via the \u2018data\u2019 parameter may be discarded. The only output of this function is the updated value in the heap and flag settings in the widget record.","In the preferred embodiment, the function PC_SetControlOutput( ) sets the value of the control output pin to either true or false. Most normal atomic widgets will not need to use this function since the environment will by default set the control output to false when the widget begins execution and true on completion. Only those widgets that are performing loops or synchronizing functions and whose control output is intended for modifying the normal scheduling sequence of the WEM diagram within which the widget resides will explicitly control this pin using PC_SetControlOutput( ). The effect of these values on the external WEM are:","TRUE\u2014This will cause any externally connected widget to be eligible to run","FALSE\u2014Any externally connected widget will be ineligible to run","Note that because control flow values change in the external WEM diagram immediately they are written (as opposed to data flows which change when the writing widget terminates), this routine must also perform the necessary logic to maintain the environment flow and token lists as a result of any value change. For data flows, the Scheduler performs this logic when an atomic widget completes.","In the preferred embodiment, the function PC_GetInputFlowName( ) takes an input specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and returns a handle to the name of the flow in the surrounding WEM diagram that is connected to that input or NULL if not found. The caller should dispose of the handle returned by this routine when the string is no longer required. In the preferred embodiment, the function PC_GetInputFlowType( ) takes an input specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<char<=\u2018z\u2019) and returns the type ID for the flow connected to that pin. In the preferred embodiment, the function returns zero if the input was not found. The widget may use the returned type ID to obtain further information about the type using the routines provided by the type manager package. Note that the type of the flow and the type of the input pin are normally the same and hence a call to PC_GetDataInputType( ) would suffice, however certain widgets that accept a given parent type (e.g., scalar) may wish to examine the type of the flow actually connected in order to determine which descendant type was actually connected (e.g., double, int32 etc.).","In the preferred embodiment, the function PC_GetOutputFlowName( ) takes an output specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and returns a handle to the name of the flow in the surrounding WEM diagram that is connected to that output or NULL if not found. The caller should dispose of the handle returned by this routine when the string is no longer required. In the preferred embodiment, the function PC_GetOutputFlowType( ) takes an output specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and returns the type ID for the flow connected to that pin. In the preferred embodiment, the function returns zero if the output was not found. The widget may use the returned type ID to obtain further information about the type using the routines provided by the type manager package. Note that the type of the flow and the type of the output pin are normally the same and hence a call to PC_GetOutputType( ) would suffice.","In the preferred embodiment, the function PC_DoesInputExist( ) can be used to determine if a particular input exists for a widget, TRUE is returned if the input exists, otherwise FALSE. In the preferred embodiment, the function PC_DoesOutputExist( ) is similar for outputs.","In the preferred embodiment, the function PC_GetStaticDataInput( ) takes an input specifier (\u2018A\u2019<=char<=\u2018Z\u2019 or \u2018a\u2019<=char<=\u2018z\u2019) and returns a handle to the storage value for that input or NULL if not found. Unlike the routine PC_GetDataInput( ), this routine will also search on flows that have no associated token for an attached constant object or defaulted output and return any value found. This means that this routine will operate at initialize time as well as execute time. This routine also has the ability to monitor changes on an input flow at run time that do not necessarily have a token associated with them. This often occurs when a widget has written a value onto a flow but has not yet completed and thus has posted no tokens. Use of this \u201ctokenless\u201d communication path is strongly discouraged except in exceptional circumstances. The handle returned by PC_GetDataInput( ) should NEVER be deallocated by widget code. The handle returned may be subject to relocation or resizing by the scheduler across any scheduling boundary, widgets should be careful not to de-reference the handle and use the de-reference value across such a boundary. Widgets should avoid \u201cLocking\u201d data handles where possible since this will reduce the schedulers ability to resize the handle in response to new data.","The foregoing description of the preferred embodiments of the invention has been presented for the purposes of illustration and description. For example, although described with respect to the C programming language, any language could be used to implement this system. The descriptions of the header structures should also not be limited to the embodiments described. While the sample pseudo code provides examples of the code that may be used, the plurality of implementations that could in fact be developed is nearly limitless. For these reasons, this description is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0011","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0018"},"figref":"FIG. 3","b":"300"},{"@attributes":{"id":"p-0014","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0020"},"figref":"FIG. 5","b":"415"},{"@attributes":{"id":"p-0016","num":"0021"},"figref":"FIG. 6","b":"417"},{"@attributes":{"id":"p-0017","num":"0022"},"figref":"FIG. 7","b":"418"},{"@attributes":{"id":"p-0018","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0024"},"figref":"FIG. 9","b":"421"},{"@attributes":{"id":"p-0020","num":"0025"},"figref":"FIG. 10","b":"422"},{"@attributes":{"id":"p-0021","num":"0026"},"figref":"FIG. 11","b":"1100"},{"@attributes":{"id":"p-0022","num":"0027"},"figref":"FIG. 12","b":["1210","1210","1200"]},{"@attributes":{"id":"p-0023","num":"0028"},"figref":"FIG. 13","b":["1300","421"]},{"@attributes":{"id":"p-0024","num":"0029"},"figref":"FIG. 14","b":"1400"},{"@attributes":{"id":"p-0025","num":"0030"},"figref":"FIG. 15","b":"1400"},{"@attributes":{"id":"p-0026","num":"0031"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
