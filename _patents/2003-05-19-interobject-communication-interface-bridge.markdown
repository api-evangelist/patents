---
title: Inter-object communication interface bridge
abstract: System and method for bridging between inter-object communication interfaces, such as RMI and IIOP, may include in one embodiment a bridge mechanism that maintains a cache of reference objects. The key used for hashing in the cache may be based on the object identifier (OID) of the reference objects. In one embodiment, the integer value of the OID is generated and then converted to a string for use in caching the object. In one embodiment, objects are not marked for deletion from the cache until a client calls a remove method. In one embodiment, object references in the cache include a reference to an exported object. In one embodiment, unexport of the exported object is performed by a post-invoke mechanism of the bridge mechanism after the remove method has completed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07424721&OS=07424721&RS=07424721
owner: Sun Microsystems, Inc.
number: 07424721
owner_city: Santa Clara
owner_country: US
publication_date: 20030519
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS","CONCLUSION"],"p":["1. Field of the Invention","This invention relates to network computing, and more particularly to bridge processes between inter-object communication interfaces, such as CORBA and RMI.","2. Description of the Related Art","RMI (Remote Method Invocation) is a way that a programmer, using the Java programming language and development environment, can write object-oriented programming in which objects on different computers can interact in a distributed network. RMI is the Java version of what is generally known as a remote procedure call (RPC), but with the ability to pass one or more objects along with the request. The object can include information that will change the service that is performed in the remote computer. The object parameter-passing mechanism may be referred to as object serialization. An RMI request is a request to invoke the method of a remote object. The request has the same syntax as a request to invoke an object method in the same (local) computer. In general, RMI is designed to preserve the object model and its advantages across a network.","RMI is implemented as three layers:\n\n","A single request travels down through the layers on one computer and up through the layers at the other end.","IIOP (Internet Inter-ORB Protocol) is a protocol that makes it possible for distributed programs written in different programming languages to communicate over the Internet. IIOP is a critical part of a strategic industry standard, the Common Object Request Broker Architecture (CORBA). CORBA is an architecture and specification for creating, distributing, and managing distributed program objects in a network. It allows programs at different locations and developed by different vendors to communicate in a network through an \u201cinterface broker.\u201d","An essential concept in CORBA is the Object Request Broker (ORB). An Object Request Broker (ORB) is the programming that acts as a \u201cbroker\u201d between a client request for a service from a distributed object or component and the completion of that request. Having ORB support in a network means that a client program can request a service without having to understand where the server is in a distributed network or exactly what the interface to the server program looks like. Components can find out about each other and exchange interface information as they are running.","ORB support in a network of clients and servers on different computers means that a client program (which may itself be an object) can request services from a server program or object without having to understand where the server is in a distributed network or what the interface to the server program looks like. To make requests or return replies between the ORBs, programs use the General Inter-ORB Protocol (GIOP) and, for the Internet, Internet Inter-ORB Protocol (IIOP). IIOP maps GIOP requests and replies to the Internet's Transmission Control Protocol (TCP) layer in each computer.","Using CORBA's IIOP and related protocols, a company can write programs that will be able to communicate with their own or other company's existing or future programs wherever they are located and without having to understand anything about the program other than its service and a name.","CORBA and IIOP assume the client\/server model of computing in which a client program always makes requests and a server program waits to receive requests from clients. When writing a program, an interface is used called the General Inter-ORB Protocol (GIOP). The GIOP is implemented in specialized mappings for one or more network transport layers. An important specialized mapping of GIOP is IIOP, which passes requests or receives replies through the Internet's transport layer using the Transmission Control Protocol (TCP). Other possible transport layers include IBM's Systems Network Architecture (SNA) and Novell's IPX.","An object adapter is a sub component in ORB that connects a request using an object reference with the proper code to service that request. The Portable Object Adapter, or POA, is a particular type of object adapter that is defined by the CORBA specification. The POA is designed to meet the following goals:\n\n","A POA object manages the implementation of a collection of objects. The POA supports a name space for the objects, which are identified by Object IDs. A POA also provides a name space for POAs. A POA is created as a child of an existing POA, which forms a hierarchy starting with the root POA.","Enterprise JavaBeans (EJB) is an architecture for setting up program components, written in the Java programming language, that run in the server parts of a computer network that uses the client\/server model. Enterprise JavaBeans is built on the JavaBeans technology for distributing program components (which are called Beans) to clients in a network. Enterprise JavaBeans offers enterprises the advantage of being able to control change at the server rather than having to update each individual computer with a client whenever a new program component is changed or added. EJB components have the advantage of being reusable in multiple applications. To deploy an EJB Bean or component, it must be part of a specific application, which is called a container.","EJB's program components are generally known as servlets (little server programs). The application or container that runs the servlets is sometimes called an application server. A typical use of servlets is to replace Web programs that use the common gateway interface (CGI) and a Practical Extraction and Reporting Language script. Another general use is to provide an interface between Web users and a legacy application mainframe application and its database. In Enterprise JavaBeans, there are two types of beans: session beans and entity beans. An entity bean is described as one that, unlike a session bean, has persistence and can retain its original behavior or state.","Embodiments of a system and method for a bridge process between inter-object communication interfaces such as RMI and CORBA are described. In one embodiment, a bridge mechanism may be implemented in an application server to provide support for RMI over IIOP communication for deployed beans. One or more rich clients may connect to the bridge mechanism when looking up and invoking operations over the deployed beans. The application server may provide one or more Java server engines that provide container implementations for beans (e.g. EJB beans). In one embodiment, the bridge mechanism uses the Tie CORBA object implementation mechanism to provide RMI over IIOP support. In one embodiment, the Tie CORBA object(s) delegate calls to intermediate bridge object implementation(s), which in turn delegate the calls to delegate objects to communicate with the bean objects on the container(s). In one embodiment, the delegate objects may use a proprietary communication protocol.","The servant locator maintains an internal cache of objects previously requested by rich clients and stored in accordance with hashes of the OIDs of the objects. If an object is being located, or if a new object is being created, the object is added to the cache.","In one embodiment, a bridge mechanism maintains a cache of CORBA references. If a CORBA object is being located, or if a new CORBA object is being created, the CORBA object may be added to the cache. The key used for hashing in the cache is the object identifier (OID) of the CORBA reference objects. OID representation is in the form of a byte array. The bridge mechanism first generates the integer value of the OID, and then converts the obtained integer value to its string representation, thereby maintaining the uniqueness of the ODs in the internal cache and preventing overwriting of cached CORBA references.","In one embodiment, the bridge mechanism includes a servant locator that provides a pre-invoke and a post-invoke operation. RMI\/IIOP calls from rich clients to the bridge mechanism go to a Portable Object Adapter (POA) object of the bridge. The POA object sends the calls to the servant locator to get CORBA objects (delegates) to call the target objects (beans). The calls sent to the servant locator go to the pre-invoke mechanism, and, after pre-invoke finishes, the actual remote objects on containers are called. Once the call to the final target object completes, and before the call is returned to the client, the post-invoke mechanism of the servant locator is invoked by the POA.","In one embodiment, objects are not marked for deletion from the cache until the rich client has actually called the remove method. In one embodiment, the rich clients are required to call the remove method when done with an object. Requiring the rich clients to call the remove method when done with an object may help prevent the cache from potentially growing beyond boundary conditions. When post-invoke is called, it checks to see if the call is a remove method. If it a remove call, post-invoke marks the object for deletion from the cache. If the call is not a remove call, the object is not marked for deletion from the cache.","In one embodiment, CORBA references stored in the cache include a target object that is an RMI portable remote object. This RMI portable remote object is exported when instantiated. In one embodiment, to insure that the target of the CORBA reference is available to the post-invoke mechanism, unexport is not performed as part of the remove method implementation of the bridge mechanism. Upon invocation of post-invoke method, after the remove method returns, the servant locator removes the cached CORBA reference. During removal from the cache, the target of the CORBA reference is unexported and set to null, thus ensuring that all the associated object references (related to the invocation object) held by the bridge mechanism, CORBA objects and their targets, are removed.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","Embodiments of a system and method for a bridge process between inter-object communication interfaces are described. An inter-object communication interface may be defined as an interface through which objects can interact in a distributed system. Exemplary inter-object communication interfaces may include, but are not limited to, Remote Method Invocation (RMI), Common Object Request Broker Architecture (CORBA), Distributed Computing Environment (DCE), Component Object Model (COM), Distributed Component Object Model (DCOM), System Object Model (SOM), Distributed System Object Model (DSOM), Remote Procedure Call (RPC), and Microsoft's Component Object Model (COM) and Distributed Component Object Model (DCOM). In this document, embodiments of the bridge process or mechanism are generally described as bridges between CORBA clients and RMI objects, but it is to be understood that other embodiments may provide bridge mechanisms between either RMI or CORBA and other inter-object communication interfaces or alternatively between two other inter-object communication interfaces. Thus, in this description and in the drawings, where CORBA and\/or RMI is used, it is to be understood that other inter-object communication interfaces may be substituted for one or both of CORBA and RMI.","In one embodiment, CORBA client support in an application server including RMI objects may be provided through a bridge process or mechanism that may be referred to as the CORBA Executive Server. The CORBA Executive Server acts as a bridge between Java and\/or C++ clients using IIOP and EJBs deployed to one or more Java Engines acting as EJB containers. For every EJB accessed by CORBA clients, the IIOP bridge process handles the incoming IIOP-based requests and maps these requests to internal calls to EJBs housed within the EJB containers.",{"@attributes":{"id":"p-0035","num":"0041"},"figref":"FIG. 1","b":["100","102","104","106","108","102","110"]},"Multiple Java server  processes may be added to handle Java applications. This may be done, for example, when a Java Server is overloaded. The Executive Server process  may automatically load-balance requests when there are multiple processes handling the same types of requests.","In one embodiment, an application server may support access to EJBs via the IIOP protocol, for example as specified in the Enterprise JavaBeans Specification and the Enterprise JavaBeans to CORBA Mapping specification. These clients may use JNDI to locate EJBs and use Java RMI\/IIOP to access business methods of remote EJBs, or alternatively may use C++ with IIOP to access business methods of remote EJBs. Scenarios in which CORBA clients are employed may include when either a stand-alone program or another application server acts as a client to EJBs deployed to an application server.",{"@attributes":{"id":"p-0038","num":"0044"},"figref":"FIG. 2A","b":["140","142","164","162","160"]},{"@attributes":{"id":"p-0039","num":"0045"},"figref":"FIG. 2B","b":["150","156","158","154","152","164","160"]},"In one embodiment, an application server may be unable to work directly with CORBA applications such as rich clients because the application server does not directly support CORBA objects. Objects created on containers of the application server are not CORBA objects but RMI objects. In one embodiment, to enable rich client access to the containers and RMI objects, the application server may provide an interface in line with CORBA standards, thus providing CORBA interfaces to rich clients. In one embodiment, this interface may be implemented as an intermediate or bridge process, which may be referred to as a bridge mechanism. The bridge mechanism may provide the CORBA interfaces that enable CORBA rich clients to communicate with the RMI objects of the container.",{"@attributes":{"id":"p-0041","num":"0047"},"figref":"FIG. 3","b":["400","400","402","402","404","404","400","412"]},"System  may include, in memory , an application server  including a bridge mechanism  and one or more containers . bridge mechanism  may allow CORBA-based clients such as rich client  to communicate with beans (e.g. EJBs) on one or more containers . In one embodiment, containers  may be implemented in one or more Java Engines or Java Virtual Machines (JVMs). In one embodiment, rich client  may be a CORBA-enabled client, and communications between rich client  and application server  may be according to the Internet Inter-ORB Protocol (IIOP). In one embodiment, interprocess communication within the application server  may be according to the KIVA Communication Protocol (KCP).",{"@attributes":{"id":"p-0043","num":"0049"},"figref":"FIG. 4","b":["208","200","210","212","206","204","202","208","200","210","212","206"]},"In one embodiment, CORBA clients may use a CORBA Common Object Services (COS) Naming Service to resolve EJBHome objects. The CORBA COS Naming Service stores relationships between names and Objects, is itself a CORBA object, and allows hierarchical name spaces. As EJBs are deployed to the application server, the EJBs may be automatically and dynamically registered in the naming service.","As new IIOP requests arrive at an instance of an application server, the application server load balances these requests against one or more JVMs acting as EJB containers. Load balancing may be implemented in a round-robin scheme. Upon startup, the application server obtains a list of the available EJB container processes, also referred to as Java Engines. As home lookup requests arrive from CORBA clients, the application server uses a list of engines to select the target engine on which an EJB home is hosted. Subsequent lookups for that EJB home, bean creations on that home, and business method invocations on the created beans go to the same target engine.",{"@attributes":{"id":"p-0046","num":"0052"},"figref":"FIG. 5","b":["302","300","304","300","310","314","316","304","316"]},"In one embodiment, as per the CORBA standard, the bridge mechanism  may include an object request broker (ORB) . In this embodiment, CORBA objects created in bridge mechanism  may be created using ORB support. ORB holds references that are CORBA objects. In rich client  access, unlike web-based access, a rich client  has standalone code (e.g. Java, C++, etc) that accesses containers  through the bridge mechanism . In one embodiment, an interface may be provided by the bridge mechanism  that looks up beans for rich clients  on the containers  using a naming service to try to obtain an EJB object deployed in a container on the application server. During this process, a call from a rich client  goes to the bridge mechanism , and the call then is directed or delegated to a container in the application server. The rich client  call is translated into a CORBA object based on RMI\/IIOP.","In one embodiment, bridge mechanism  may include a POA (Portable Object Adapter)  which is supported by a servant manager (e.g. servant locator ). In one embodiment, a lookup service is a naming service provided by the operating system. In one embodiment, servant locator  is a subcomponent of the POA . In one embodiment, when the bridge mechanism  receives a call, it looks up a POA  which includes CORBA objects (Ties ) that were previously looked up and that represent or reference beans on containers. In one embodiment, Ties  may be stored in a cache . In one embodiment, Ties  may be stored in cache  according to hashes of object identifiers (OIDs). When a naming service lookup is performed, objects that are looked up from the containers  and routed through the bridge are cached into the POA subsystem. Whenever an Internet access provider (IAP) call comes in to the bridge  from a rich client, the call includes an Input\/Output reference that includes a key indicating the target POA . There may be one or more POAs  in ORB . The POA  is called, and in response the POA  invokes the CORBA servant manager (servant locator ).","The first time a call is received, for example when a lookup is performed, the call is routed to a POA , which invokes the servant locator  to instantiate the reference indicated by a call (bean). The servant manager creates intermediate objects (bridge objects ), which uses a KIVA Communication Protocol (KCP) delegate object . A KCP delegate object  is a transport-defined protocol object that may be proprietary to the application server. Protocols of calls to the bridge object  are based on the IAP (Internet access provider) protocol. A call is dedicated to a KCP object  by the bridge object . The KCP object  is a task-specific delegate object, which forwards the call to the appropriate container . In the container , a bean object (e.g. an EJB bean object) will be created and the call will be invoked into its remote interface.","In one embodiment, an application server that is not CORBA-enabled may support CORBA-enabled applications (e.g. rich clients) through a bridge mechanism that creates wrapper (CORBA) objects. In one embodiment, interprocess communication on the application server is based on the KIVA Communication Protocol (KCP). This bridge mechanism communicates with a container process that supports RMI objects. When a CORBA client (e.g. rich client) communicates with the bridge mechanism using the IIOP protocol to access RMI objects on a container, the communication process may be referred to as RMI\/IIOP because calls from the rich client target RMI objects on the container, and access to the RMI objects on the container is enabled through an IIOP mechanism provided by the bridge mechanism.","A call from a rich client to the bridge mechanism may be referred to as an RMI\/IIOP call. The call from the rich client is translated by the bridge mechanism to a container that includes target RMI objects (e.g. beans) through a delegate object. In one embodiment, the delegate objects are KCP objects.","The RMI objects provide RMI remote interfaces. The bridge mechanism creates delegates for the RMI objects referred to as CORBA bridge objects (delegates). These objects are exposed to CORBA (rich) clients using the CORBA Tie objects. In one embodiment, the bridge objects are wrapped around the CORBA objects using Tie objects. A Tie object is a CORBA object or servant that is managed by a servant locator. CORBA objects in a bridge mechanism may be designed on a pure CORBA interface or alternatively may be designed as a Tie-based interface.","When using the Tie-based interface, calls from a rich client to the bridge mechanism may go to a Tie object that uses a delegate to pass on the call to an intermediate delegate object (bridge object). In one embodiment, when a call comes in, the bridge mechanism passes the call to a servant locator. The servant locator creates a hash of the CORBA object ID and uses the hash to look up the Tie object in a cache. The servant locator creates a bridge object and sets the bridge object as a target (delegate) object in the Tie object. The Tie object references the bridge object, and the bridge object accesses the actual bean (e.g. EJB bean) on a container through a delegate (e.g. KCP) object.","Scalability is an important aspect of an application server supporting rich clients using a bridge mechanism to support RMI over IIOP invocations for deployed beans. Embodiments of a bridge mechanism may include one or more mechanisms for, among other purposes, increasing scalability of bridge mechanisms. These mechanisms may include one or more of mechanisms for managing Portable Object Adapter (POA)-generated object identifiers (OIDs), post-invoke mechanisms, mechanisms for unexporting portable remote objects used as delegates in a Tie-based CORBA object implementation, and mechanisms for bridge mechanism management of internal cache used for housekeeping rich clients.","Management of POA-Generated OIDs","In one embodiment, a bridge mechanism maintains a cache of CORBA references (Tie objects). The key used for hashing in the cache is the object identifier (OID) provided by the ORB. OID representation is in the form of a byte array. In one embodiment, the bridge mechanism converts these byte array representations to another form for use in hashing. In one embodiment, the bridge mechanism may include a servant locator that performs the conversion. One way to do the conversion is to convert the byte array to string form, e.g. using String(byte[ ]), and use this string value to cache the elements. A problem associated with this approach is that, as the OIDs generated by ORB become greater than 128 integer value (4 byte array), the string representation does not map to a valid character in the ASCII encoding set, since there are only 128 distinct ASCII values. Thus, associated CORBA references in the cache may be overwritten for these OIDs. This may result in CORBA references to different bean types being overwritten. In this case, a rich client call to CORBA reference may be dispatched to an object exposing a different interface, resulting in an error condition. This limits scalability of rich client support.","In one embodiment, to provide increased scalability, the bridge mechanism first obtains the integer value of the 4 byte OID, and then converts the obtained integer value to its string representation, thereby maintaining the uniqueness of the OIDs in the internal cache and preventing overwriting of cached CORBA references. In one embodiment, this conversion uses the left shift mechanism to generate a composite integer value (e.g. a 4 byte value). In one embodiment, the most significant byte (MSB) is the fourth byte of the 4-byte OID, and the least significant byte (LSB) is the first byte of the OID, and left shift is used to generate a 32-bit integer value equivalent of the 4-byte array. The integer value may then be converted into a string object. In one embodiment, the conversion may be performed by a servant locator subprocess of the bridge mechanism. By converting the OID to an integer value and then a string, a unique hash value for every OID may be generated.",{"@attributes":{"id":"p-0057","num":"0063"},"figref":"FIG. 6","b":"500"},"As indicated at , the bridge mechanism may generate a reference object configured to provide the call to an object configured for inter-object communication according to a second inter-object communication interface. In one embodiment, the reference object is a CORBA object. In one embodiment, the reference object is a CORBA wrapper object. In one embodiment, the bridge mechanism is a component of an application server configured to host a plurality of objects configured for inter-object communication according to the second inter-object communication interface. In one embodiment, the plurality of objects is stored on one or more containers of the application server. In one embodiment, the plurality of objects are Java beans. In one embodiment, the beans are EJB beans. In one embodiment, the first inter-object communication interface is Internet Inter-ORB Protocol (IIOP), and the second inter-object communication interface is Remote Method Interface (RMI).","As indicated at , the bridge mechanism may generate an integer value from an object identifier (OID) of the reference object. In one embodiment, the object identifier is a 4-byte array. In one embodiment, the bridge mechanism may use a left-shift mechanism to generate the integer value from the OID.","As indicated at , the bridge mechanism may store the reference object in a location of an internal cache determined from the integer value. In one embodiment, the bridge mechanism may generate a string representing the integer value and store the reference object in the location of the cache indicated by the generated string.","Post-Invoke Implementation","The servant locator maintains an internal cache of objects previously requested by rich clients and stored in accordance with hashes of the OIDs of the objects. If an object is being located, or if a new object is being created, the object is added to the cache. For example, when a lookup is performed on behalf of a rich client through the name service, the call goes to the servant locator. The servant locator maintains an internal cache. The object that is returned by the servant locator is also stored in the cache using a hash generated from its OID. If another lookup call is received for the object, the servant locator checks to see if the requested object is in the cache. If the servant locator finds the object in the cache, it does not have to create the object, but instead returns the OID reference (the CORBA reference) of the object from the cache to the requesting rich client.","As an example of using the cache, the first time a rich client tries to look an object (e.g. bean, the servant locator may not find the object in the cache. If the object is not fin the cache, the servant locator creates an instance of the object and caches the object. If another rich client tries to access the same object, the servant locator checks to see if the object is in the cache. If it is in the cache, the servant locator returns the object from the cache. The cache is maintained at the bridge mechanism; if any client looks up the same object that is still in the cache, the call is returned referencing the object in the cache. Thus, the call does not need to propagate to the EJB container.","The cache may be limited in size. In one embodiment, to maintain boundary conditions of the cache, objects may be marked for delete and, if the cache becomes full or overflows, all objects marked for deletion may be purged. In one embodiment, whenever the boundary condition of the cache is reached, there is a cleanup mechanism that checks for entries marked for deletion. If an entry is marked for deletion, the object is purged from the cache.","In the bridge mechanism, the servant locator interface provides a pre-invoke and a post-invoke operation. RMI\/IIOP calls from rich clients to the bridge mechanism go to a POA object of the bridge. The POA object sends the calls to a servant locator to get CORBA objects (delegates) to call the target objects (beans). The calls sent to the servant locator go to the pre-invoke mechanism, and, after pre-invoke finishes, the actual remote objects on containers are called. For example, if the POA receives a remove call from a rich client, the POA gives it to the servant locator. The servant locator calls the pre-invoke, and then, after completion of the pre-invoke, it forwards the call to the target object, i.e. the call is propagated to the container. Once the call to the final target object completes, and before the call is returned to the client, the post-invoke mechanism of the servant locator is invoked by the POA. The post-invoke marks the completion of the call to the target object in the container.","In one embodiment of the post-invoke method of the servant locator, all invocations of CORBA references of objects (e.g. EJBHome and EJBObject objects) would result in the reference being marked for deletion from the cache by the post-invoke. If cache overflow occurs, all marked for delete entries are removed from the cache. This would result in the CORBA references for the objects marked for deletion being purged from the cache. If a client is not done with an object, and thus does not invoke the remove method for the object, the object may still be removed from the cache by the post-invoke method. In this embodiment, if a rich client holding a reference to an object that has been purged from the cache later invokes a method, for example create, that references the purged object, the servant locator is not able to find the reference in the cache, potentially resulting in failure of the RMI\/IIOP call.","In another embodiment, to avoid failures of RMI\/IIOP calls due to objects being removed from the cache, rich clients invoke the remove method when done using an object to mark the objects for deletion from the cache. The post-invoke mechanism does not mark objects for deletion at the completion of any invocation; objects are only marked for deletion in response to remove calls from the rich clients. The post-invoke method determines if an operation invoked on a CORBA reference is a remove operation and, if so, marks the object for deletion from the cache. When an invocation is performed on a CORBA object as per a call from a rich client, the OID and the method being invoked on that OID are provided in the call. The post-invoke mechanism uses that information to determine if the call is a remove call. If the call is a remove call, the rich client has called for deletion of the target object from the container, and the object is also marked for deletion from the servant locator cache.","Thus, in this embodiment, objects are not marked for deletion from the cache until the rich client has actually called the remove method. In one embodiment, the rich clients are required to call the remove method when done with an object. Requiring the rich clients to call the remove method when done with an object may help prevent the cache from potentially growing beyond boundary conditions. When post-invoke is called, it checks to see if the call is a remove method. If it a remove call, post-invoke marks the object for deletion from the cache. If the call is not a remove call, the object is not marked for deletion from the cache.",{"@attributes":{"id":"p-0068","num":"0074"},"figref":"FIG. 7","b":"510"},"As indicated at , the bridge mechanism may receive a call formatted according to the first inter-object communication interface and indicating one of the reference objects stored in the cache. In one embodiment, the call may be received from an application configured for inter-object communication according to the first inter-object communication interface. In one embodiment, the application may be a Common Object Request Broker Architecture (CORBA) rich client.","As indicated at , the bridge mechanism may determine if the call is a remove call. As indicated at , if the call is a remove call, the reference object indicated by the call may be marked for removal from the cache as indicated at . As indicated at , if the call is not a remove call, the reference object indicated by the IIOP call is not marked for removal from the cache.","Note that, in one embodiment, rich clients may be required to call the remove method when done with an object to help prevent memory problems on the application server. This method of only marking objects for removal from the cache when receiving a remove call from a rich client may preferably help prevent the failure of IIOP calls received from rich clients due to objects being purged from the cache prematurely due to the objects being marked for deletion on every invocation of CORBA references of objects by post-invoke.","Unexporting of Portable Remote Objects","The containers host RMI objects. These RMI objects are RMI remote portable objects. The bridge objects generated on the bridge mechanism extend from RMI portable remote objects. The bridge objects are RMI-enabled objects that implement the RMI portable remote object class. When a call (e.g. lookup or create) is being done for an object (e.g. EJBHome or EJBObject objects), on the bridge mechanism, the TIE instantiates an RMI portable remote object as a bridge object. When an RMI portable remote object is created, it is exported to be available for clients to lookup. To insure that an RMI portable remote objects is garbage collected, unexport must be called on these objects to indicate to the JVM that the client is done with the object and thus it should be garbage collected. If unexport is not done on RMI portable remote objects, memory may be wasted.","The servant locator of the bridge mechanism performs pre-invoke, call to object, and post-invoke when it receives a call. When the post-invoke mechanism is called, one of the parameters is a CORBA reference (e.g. Tie object). This CORBA reference object internally has a reference to the bridge object. Whenever a remove takes place, it may be desirable to insure that whenever a CORBA reference object (Tie) is deleted, the bridge object also is garbage collected by the JVM.","In one embodiment, when a rich client invokes the remove method on a CORBA reference to an object (e.g. an EJBObject), unexport is called on the target of the CORBA reference (in one embodiment, a Tie object). In one embodiment, the target of the CORBA reference is set to null by the unexport mechanism. In this embodiment, upon completion of a remove invocation and before the post-invoke method is invoked, the target of the CORBA reference is already set to null. The CORBA reference is one of the passed parameters to the post-invoke mechanism of the servant locator, and the post-invoke mechanism may need to access the target of the CORBA reference. This could potentially result in errors being generated and reported to the rich clients.","In another embodiment, to insure that the target of the CORBA reference is available to the post-invoke mechanism, unexport is not performed as part of the remove method implementation of the bridge mechanism. Upon invocation of post-invoke method by the ORB, after the remove method returns, the servant locator removes the cached reference by marking it for deletion. In one embodiment, the post invoke implementation ensures removal of the CORBA reference by marking it for deletion from cache and carries out unexporting of the bridge object, which is the portable remote object. During removal from the cache, the target of the CORBA reference (e.g. Tie) is set to null, thus ensuring that all the associated object references (related to the invocation object) held by the bridge mechanism, CORBA objects and their targets, are removed. In one embodiment, during removal, only the Tie's target is set to null to dereference that bridge object and cause the chain of delegate objects in the bridge process to be removed from memory. In one embodiment, unexport is performed as part of post invoke implementation.","In this embodiment, the post-invoke mechanism checks objects it receives upon invocation and, if it determines an object is an RMI portable remote object (e.g. a bridge object), performs unexport on the object.","In this embodiment, the remove method does not unexport RMI portable remote objects. Instead, the RMI portable remote objects are unexported by the post-invoke mechanism. This ensures that the targets of CORBA references are available to the post-invoke mechanism. In one embodiment, this may only be performed for bridge objects that are targets of CORBA references (e.g. Tie objects). During post-invoke, the CORBA reference object is nullified and the bridge object referenced by the CORBA reference object is unexported. In one embodiment, nullification of the CORBA reference object may be accomplished by ensuring that the objects are marked for deletion so that the cache management mechanism can detect the marked objects and remove them from the cache. When the unexport is performed by the post invoke, it ensures that the RMI portable remote object is dereferenced and will be garbage collected. If unexport is not called, the JVM is not able to release the object which may result in memory problems.","In one embodiment, as part of the cache management of the servant locator, the target of the CORBA reference (e.g. Tie) being removed is set to null. This ensures that the target object (an RMI portable remote object) is dereferenced, thereby making it eligible for garbage collection by the JVM. Cache clearance takes place during life cycle management of the cache. When the cache gets cleared (i.e. objects marked for delete are purged), a check is performed to determine if each object being deleted has a target that is an RMI portable remote object. If it is an RMI portable remote object, the target (previously unexported by post invoke) is set to NULL.","Instead of unexporting RMI portable remote objects as part of the remove, unexport is performed later after the remove has returned by post-invoke. The servant locator keeps track of objects that have been removed and marks them for deletion. In one embodiment, this applies to removing bridge objects, which are RMI portable remote objects. In one embodiment, Tie objects in the cache are removed as part of cache management when the cache reaches its maximum size.",{"@attributes":{"id":"p-0080","num":"0086"},"figref":"FIG. 8","b":"530"},"In one embodiment, the reference object includes a reference to an exported object. As indicated at , the bridge mechanism may receive a call (e.g. from a rich client) formatted according to the first inter-object communication interface and indicating the reference object is to be removed. In one embodiment, the call may be received from an application configured for inter-object communication according to the first inter-object communication interface. In one embodiment, the application may be a Common Object Request Broker Architecture (CORBA) rich client. As indicated at , the bridge mechanism may invoke a remove method for the reference object in response to the call. In one embodiment, the remove method does not unexport the referenced exported object. Instead, after completion of the remove method, the bridge mechanism may unexport the referenced exported object as indicated at .","In one embodiment, the bridge mechanism may invoke a post-invoke mechanism after completion of the remove method, and the post-invoke mechanism may perform the unexport of the referenced exported object. In one embodiment, the post-invoke mechanism may be provided as an interface to the servant locator. Performing the unexport during post-invoke rather than during the remove method preferably helps prevent errors generated by nulling references to exported objects in the reference objects when the references are needed by the post-invoke mechanism. In one embodiment, the bridge mechanism may set the reference to the exported object in the reference object to null and also may remove the reference object from the cache or alternatively mark the reference object for removal from the cache by a cache management process.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Generally speaking, a carrier medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc. As well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The various methods as illustrated in the Figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0023","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0030"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0025","num":"0031"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0026","num":"0032"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0033"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0034"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0035"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0036"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0037"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
