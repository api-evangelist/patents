---
title: Method and apparatus for system testing using multiple instruction types
abstract: An apparatus for use in testing at least a portion of a system under test via a Test Access Port (TAP) is provided. The apparatus includes a memory for storing a set of instructions of a test instruction set architecture and a processor executing the set of instructions of the test instruction set architecture for testing at least a portion of the system under test via the TAP. The set of instructions of the test instruction set architecture includes a first set of instructions including a plurality of instructions of an Instruction Set Architecture (ISA) supported by the processor and a second set of instructions including a plurality of test instructions associated with the TAP. The instructions of the first set of instructions and the instructions of the second set of instructions are integrated to form the set of instructions of the test instruction set architecture.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08533545&OS=08533545&RS=08533545
owner: Alcatel Lucent
number: 08533545
owner_city: Paris
owner_country: FR
publication_date: 20090630
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional Patent Application Ser. No. 61\/157,412, filed on Mar. 4, 2009, entitled TEST INSTRUCTION SET ARCHITECTURE, which application is incorporated herein by reference in its entirety.","This application is related to U.S. patent application Ser. No. 12\/495,295, entitled \u201cMETHOD AND APPARATUS FOR SYSTEM TESTING USING MULTIPLE PROCESSORS,\u201d and is related to U.S. patent application Ser. No. 12\/495,336, entitled \u201cMETHOD AND APPARATUS FOR SYSTEM TESTING USING SCAN CHAIN DECOMPOSITION,\u201d each of which is filed concurrently with this application and is incorporated herein by reference in its entirety.","The invention relates to the field of system testing and, more specifically but not exclusively, to generation and control of instructions for system testing.","Electronic circuits are typically constructed in the form of a printed circuit board (PCB) that includes a plurality of electronic components soldered to a circuit board substrate having conductive traces interconnecting various device terminals to form an electrical circuit. As PCBs and the implemented electrical circuits thereof are often complex, board testing at manufacture has become increasingly automated. In this respect, board testing apparatuses have evolved from simple I\/O functional testers that connect to I\/O connectors of a populated PCB for high level automated functional testing, to test fixtures that include probe pins for making electrical contact with all or some of the circuit nodes of a tested board for performance of high level and lower level testing, to integrated testing devices that provide for automated testing of a PCB without the need to externally probe individual circuit nodes of the tested board.","The testing of electronic circuits in boards and devices is typically controlled by Testing Automation Tools, which support the steps needed to proceed from a definition of the test algorithm to the actual testing operation. In order to facilitate testing automation, testing resources often are embedded inside the boards and devices, and can be accessed using a standardised interface, usually called a Test Access Port (TAP). This has the effect of limiting the pin count and rationalising resource access and management. In general, most of the existing standards offer one or more languages that can be used to describe the resources inside the system under test (SUT), and which can be used as inputs to Testing Automation Tools. These Testing Automation Tools can apply their own algorithms in order to generate testing sequences exploiting the TAP. These testing sequences can then be used by a Test Control Unit (TCU) to command the TAP and execute the testing operations. The features and performance of the testing operations depend on each of these elements, namely, the access standard, the data format, and the TCU implementation.","The Joint Test Action Group (JTAG) has developed a circuit board testing standard, denoted as IEEE 1149.1. IEEE 1149.1 specifies a Test Access Port (TAP) for testing circuit boards. IEEE 1149.1 supports Boundary Scan (BS) testing of hardware via test devices included on the tested circuit boards. Boundary Scan testing involves controlling and monitoring boundary pins of a JTAG-compatible device under the control of software to provide test coverage beyond that which might otherwise be available. Further, Instruction JTAG (IJTAG) is being standardized (denoted as P1687) to overcome existing JTAG limitations associated with moving from board-level JTAG to chip-level JTAG.","JTAG and IJTAG may be used by Automated Test Generation (ATG) tools to test chips and electronic devices. JTAG presents a simple 5-wire TAP that allows serially access, with minimal overhead, to resources implemented inside a chip. The access infrastructure can then be described into a specific language such as the Boundary Scan Description Language (BSDL), which can be used by many commercial TGTs to generate testing vectors. These testing vectors are typically saved in a format called Serial Vector Format (SVF), which enables a high-level description of the basic operations of the 1149.1 TAP. A more complex alternative to SVF is STAPL, which extends the vector operations of SVF to allow for basic flow control (if-then-else) and arithmetic operations on the test vectors. A JTAG-compliant TAP receives commands from a SVF or STAPL player, and generates simple Go\/NoGo results which can later be interpreted offline.","Disadvantageously, these existing approaches have many limitations. A first limitation is in the data format, because the test player does not have any knowledge of the system under test and, therefore, can perform only very basic operations. A second limitation is that interactive testing (local or remote) cannot be supported; rather, any testing results must be examined offline. Further, these existing approaches are implementation-dependent and are typically proprietary.","Various deficiencies in the prior art are addressed through methods and apparatuses for generating test instructions for use in performing system testing.","In one embodiment, an apparatus for use in testing at least a portion of a system under test via a Test Access Port (TAP) includes a memory for storing a set of instructions of a test instruction set architecture and a processor executing the set of instructions of the test instruction set architecture for testing at least a portion of the system under test via the TAP. The set of instructions of the test instruction set architecture includes a first set of instructions including a plurality of instructions of an Instruction Set Architecture (ISA) supported by the processor and a second set of instructions including a plurality of test instructions associated with the TAP. The instructions of the first set of instructions and the instructions of the second set of instructions are integrated to form the set of instructions of the test instruction set architecture.","In one embodiment, a computer processor for testing a system under test via a Test Access Port (TAP) includes circuitry configured to process instructions according to a test instruction set architecture having semantics that enable interaction with the system under test via the TAP, The test instruction set architecture includes a plurality of instructions of a first type and a plurality of instructions of a second type. The first type instructions include instructions of an instruction set architecture (ISA) supported by the computer processor. The second type instructions include test instructions for testing the system under test via the TAP.","In one embodiment, a method is provided for adapting an Instruction Set Architecture (ISA) flow of a processor to support testing of at least a portion of a system under test by the processor via a Test Access Port (TAP). The method includes generating a first set of instructions including ISA instructions supported by the processor, generating a second set of instructions including test instructions associated with the TAP, integrating the first set of instructions and the second set of instructions to form thereby a set of TISA instructions, and performing at least one of storing, executing, or propagating the TISA instructions.","To facilitate understanding, identical reference numerals have been used, where possible, to designate identical elements that are common to the figures.","Various system testing capabilities are provided for use in performing testing of a system under test (SUT).","In one embodiment, a test instruction set architecture (TISA) is provided. The TISA is provided for use in performing system testing. The TISA combines computer science capabilities with system testing capabilities to provide improved system testing capabilities, including interactive testing capabilities, remote testing capabilities, and various other capabilities described herein. The TISA is formed by adapting a software-based instruction set architecture (ISA) using system testing capabilities. The software-based ISA may utilize any suitable software programming language (e.g., C++, Java, and the like, as well as various combinations thereof) and may be implemented using any suitable processor. The system testing capabilities may utilize any suitable TAP, such as IEEE 1149.1 (also known as JTAG) TAPs or any other suitable TAPs. In general, the TISA is formed by combining the atomic operations of a software process with atomic testing operations of a test procedure. In the TISA, the algorithmic portions of the test procedure are handled by the software flow, such that the algorithmic portions of the test procedure are translated into the atomic testing operations. The TISA is formed by combining the atomic operations of the software process with the atomic testing operations of the test procedure, such that the atomic testing operations are treated in the same manner as the atomic operations of the software process that is handling the algorithmic portions of the test procedure. This enables finer-grain control of embedded test execution, remote test execution, and various other improved system testing capabilities as depicted and described herein.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1"},"As depicted in , system testing environment  includes a testing system (TS)  and a system under test (SUT) .","The TS  may be any system suitable for testing SUT . The TS  is configured for testing SUT . The TS  may perform any testing of SUT , e.g., testing one or more individual components of SUT , one or more combinations of components of SUT , one or more interconnections between components of SUT , one or more system level functions of SUT , and the like, as well as various combinations thereof. The TS  may perform any of the functions typically associated with testing a system under test, such as executing test procedures, providing input data to the system under test, receiving output data from the system under test, processing output data received from the system under test for determining system testing results, and like functions, as well as various combinations thereof. The design and use of TS  for testing a system under test is described in additional detail hereinbelow.","The SUT  may be any system which may be tested using TS . The SUT  may include any component(s), at least a portion of which may be tested, individually and\/or in combination, by TS . The SUT  may include one or more scan chains, having one or more sets of associated input and output access pins, providing access to the component(s) to be tested by TS . The manner in which a scan chain(s) may be utilized in SUT  for testing SUT  will be appreciated by one skilled in the art. For example, SUT  may include one or more boards, testing of which may be performed using one or more scan chains having associated input and output access pins which may be used for applying input testing signals to SUT  and collecting output testing signals from SUT .","As depicted in , TS  accesses SUT  via a test access interface (TAI) . The test access interface may be implemented using any suitable test access interface, which may depend on one or more of the TS , the SUT , the type of testing to be performed, and the like, as well as various combinations thereof.","For example, TAI  may include a Joint Test Action Group (JTAG) Test Access Port (TAP) as standardized in IEEE 1149.1 standard, which is incorporated by reference herein in its entirety. The IEEE 1149.1 standard defines a TAP that supports the following set of signals: Test Data In (TDI), Test Data Out (TDO), Test Mode Select (TMS), Test Clock (TCK), and, optionally, Test Reset Signal (TRST). The TDI and TDO pins of SUT  are interconnected in a boundary scan chain by which TS  may access SUT  for testing at least a portion of SUT .","The TAI  may include any other suitable test access interface.","It will be appreciated by one skilled in the art that TS , TAI , and SUT  may be implemented in any manner suitable for providing features of the embodiments covered herein.","As described herein, the TISA is able to leverage computer science capabilities in combination with system testing capabilities to provide a significant improvement in system testing. A general description of system testing capabilities and computer science capabilities follows, followed by a description of the manner in which computer science capabilities and system testing capabilities may be utilized together to provide the TISA.","The TISA improves upon system testing capabilities by leveraging computer science capabilities. The system testing capabilities may include the capabilities generally supported in all stages of the \u201cautomated test\u201d flow (which generally includes all of the steps and resources that may be needed to get from a definition of the test algorithm(s) to actual testing operations).","In order to help test automation, test resources often are embedded inside the boards and devices, and can be accessed using a standardised interface, usually called the Test Access Port (TAP). This has the effect of limiting the pin count and rationalising resource access and management. A number of languages are available for describing resources inside a system under test, and, thus, which may be used as inputs to Test Generation Tools (TGTs). TGTs can apply algorithms to generate testing sequences which may be used by a Test Control Unit (TCU) to command the TAP and execute the associated testing operations. The features and performances of the testing operations depend on these three elements: the access standard, the data format, and the TCU implementation.","The TISA is able to leverage computer science capabilities to provide improved system testing capabilities. This may include use of computer science capabilities that are available in all stages of the \u201csoftware development flow\u201d (which generally includes any or all of the steps and resources that may be needed to get from a software algorithm coded in a software language(s) of choice to the final debugging and execution on a target processor, such as compilation, an Instruction Set Architecture (ISA), interactive debugging, and the like, as well as various combinations thereof).","The use of compilation in computer science reduces an algorithm defined in a programmer-friendly high level abstraction to a series of machine-executable instructions. This process can vary greatly, depending on the input programming language and project complexity; however, most, if not all, of the approaches share the same basic assumption: any algorithm can be decomposed into basic instructions, regardless of its complexity. This applies to classic languages, as well as to more modern high-level and object oriented languages such as, for example, C++, Java, Python, and the like.","The Instruction Set Architecture (ISA) is the core of any processor, and the reason for which compilation is so effective. In general, each processor offers a set of instructions which define the manner in which the processor can be operated. The instructions form at least part of the ISA of the processor. It will be appreciated that the ISA may be considered to include various constructs associated with the instructions, such as registers, addressing modes, opcodes, memory structures, and the like, as well as various combinations thereof. The ISA enables the processor to execute simple instructions, such as reading\/writing values from\/to memory, perform logical or arithmetical operations on registers, handle interruption, and the like. This basic behaviour has remained essentially unchanged over time, and modern processors achieve exceptional performances because they can efficiently exploit great numbers of resources, and, thus, are able to complete a much larger number of such basic instructions in approximately the same amount of time. Furthermore, even higher performances may be reached from the use of co-processors (e.g., floating-point co-processors, graphical co-processors, and the like), which can help the main processor by hard-coding complex operations.","The use of debugging in computer science allows monitoring and verification of the software development and execution process. In general, software development is a long and difficult process, which is strictly monitored and verified to assure that the final product is free of defaults, or \u201cbugs\u201d are they are usually called. In order to help test software programs, the software development flow provides many powerful debug features. For example, common software development flow debug features include step-by-step execution; observability\/controllability of all registers and memory locations, use of breakpoints and watchpoints, and the like. These debug features, as well as various other debug features, are more often enabled by algorithms and structures embedded into the final code by the software compiler, but may also be assisted by hardware resources available inside of the processor. From this information the debugger can reconstruct the original code and correlate all the ISA-level operations to the programming abstraction layer.","The use of automated test execution capabilities and computer science software capabilities together to enable improved system testing capabilities may be better understood by way of reference to  and .",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 2","FIG. 1"]},"As depicted in , the TS  includes a test generation tool (TGT)  and a software compiler (SC) .","The TGT  includes a TGT composer  and TGT algorithms .","The TGT composer  accepts system description files  as input. The system description files  include any suitable description files which may be used by a TGT to produce testing instructions\/vectors for testing a system under test. For example, system description files  may include circuit description files, board\/fixture netlist files, other description files, and the like, as well as various combinations thereof. The system description files  may be available on TGT  and\/or may be obtained from one or more remote components and\/or systems.","The system description files  may include one or more circuit description files, The circuit description files may be specified using any suitable description language(s), such as the Boundary Scan Description Language (BSDL, which was developed as part of the IEEE 1149.1 standard for board-level JTAG), the Hierarchical Scan Description Language (HSDL, which was developed as an extension of BSDL), New Scan Description Language (NSDL), and the like, as well as various combinations thereof.","The system description files  may include one or more board\/fixture netlist files, The board\/fixture netlist files may include files related to the physical description of the device(s), describing the netlist, connections, and like information. The board\/fixture netlist files may be specified in any suitable format, such as PCB, Gerber, and\/or any other format suitable for board\/fixture netlist files.","The system description files  may include one or more other description files. The other description files may include any other suitable description files which may be used as input for producing a circuit model. For example, other description files may include any suitable application-specific and\/or tool-specific description language files, such as Asset's Macro Language, Goepel's CASLAN Language, and\/or any other suitable description language files.","The TGT composer  processes the system description files  to produce a circuit model . The processing of system description files  by TGT composer  to produce circuit model  may be performed in any suitable manner. The circuit model  specifies a model of the system under test or portion of the system under test for which TGT  is being run. The TGT composer  provides circuit model  to TGT algorithms .","The TGT algorithms  accept circuit model . The TGT algorithms  process the circuit model  to produce TGT atomic test operations . The processing of circuit model  by TGT algorithms  to produce the TGT atomic test operations  may be performed in any suitable manner.","The SC  includes SC front-end algorithms  and SC back-end algorithms .","The SC front-end algorithms  accept computer science source files  as input. The computer science source files  include any suitable computer science source files which may be compiled by a compiler. For example, computer science source files  may include computer science source files for any suitable computer programming language(s), such as C++, Java, Python, and the like, as well as various combinations thereof. For example, computer science source files  may include one or more of one or more C files, one or more C++ files, and\/or any other suitable computer science source files.","The SC front-end algorithms  process the computer science source files  to produce a program model . The program model  specifies an intermediate representation of the computer science source files . The SC front-end algorithms  provide the program model  to the SC back-end algorithms .","The SC back-end algorithms  accept program model  as input. The SC back-end algorithms  process the program model  to produce one or more ISA Binary Files  including ISA atomic operations . The processing of program model  by the SC back-end algorithms  to form the ISA Binary Files  including the ISA atomic operations  may be performed in any suitable manner. The ISA atomic operations  are assembly-level instructions supported by the processor for which the TISA is implemented.","As depicted in , in addition to the respective processing flows of TGT  and SC , additional interaction between TGT  and SC  may be utilized for controlling generation of the TISA atomic operations . In one embodiment, SC back-end algorithms  may initiate one or more vector computation requests  to TGT algorithms . The SC back-end algorithms  may initiate a vector computation request  when the SC back-end algorithms need to access the TAP. The TGT algorithms , upon receiving a vector computation request  from SC back-end algorithms , generate one or more TGT atomic test operations  for the TAP based on the received vector computation request . The one or more TGT atomic test operations  may then be applied to the TAP in a manner controlled by SC back-end algorithms , because the TGT atomic test operations  are combined with the ISA atomic operations  to enable algorithmic control over TGT atomic test operations  using ISA atomic operations . In this manner, the SC  provides algorithmic control of access to the TAP.","As depicted in , in addition to TGT  and SC , TS  further includes a TISA composer . The TISA composer  accepts the TGT atomic test operations  and the ISA atomic operations . The TISA composer  converts the TGT atomic test operations  into TISA instructions and inserts the TISA instructions into the ISA Binary File(s)  (i.e., combining the TISA instructions with the ISA atomic operations  to form thereby TISA Binary files  including TISA atomic operations . The TISA composer  may be part of TGT , part of SC , split across TGT  and SC , implemented separate from TGT  and SC , and the like.","It will be appreciated that the various inputs and outputs depicted and described with respect to  may be stored, displayed, executed, propagated, and\/or handled in any other suitable manner, as well as various combinations thereof.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 3","FIG. 1"]},"As depicted in , TS  of  operates in a manner similar to TS  of , in that TISA Binary files including TISA atomic operations are generated using interaction between the test generation tool and the software compiler; however, interaction between the test generation tool and the software compiler in TS  of  is different than interaction between the test generation tool and the software compiler in TS  of .","As depicted in , the TS  includes a test generation tool (TGT)  and a software compiler (SC) .","The TGT  includes a TGT composer  and TGT algorithms .","The TGT composer  accepts system description files  as input. The system description files  include any suitable description files which may be used by a TGT to produce testing instructions\/vectors for testing a system under test. For example, system description files  may include circuit description files, board\/fixture netlist files, other description files, and the like, as well as various combinations thereof. The system description files  of  may include system description files similar to system description files  depicted and described with respect to  (e.g., one or more circuit description files, one or more board\/fixture netlist files, one or more other description files, and the like, as well as various combinations thereof). The system description files  may be available on TGT  and\/or obtained from one or more remote components and\/or systems.","The TGT composer  accepts one or more test operation description files -(collectively, test operation description files ) as input. The test operation description files  are generated by SC . The generation of test operation description files  by SC  is described in detail hereinbelow.","The TGT composer  processes the system description files  and the test operation description files  to produce a circuit model . The processing of system description files  by TGT composer  to produce circuit model  may be performed in any suitable manner. The circuit model  specifies a model of the system under test or portion of the system under test for which TGT  is being run. The processing of system description files  in conjunction with test operation description files  enables the TGT composer  to produce circuit model  in a manner for enabling TGT  to produce appropriate TAP atomic operations. The TGT composer  provides circuit model  to TGT algorithms .","The TGT algorithms  accept circuit model . The TGT algorithms  process the circuit model  to produce TGT atomic test operations . The processing of circuit model  by TGT algorithms  to produce the TGT atomic test operations  may be performed in any suitable manner.","As depicted in , in addition to TGT  and SC , TS  includes a TISA translator . The TISA translator  receives the TGT atomic test operations . The TISA translator  translates TGT atomic test operations  to form TISA atomic test operations . The TISA translator  provides TISA atomic test operations  to SC  for inclusion in the software compilation process. The use of TISA atomic test operations  by SC  is described in detail hereinbelow. The TISA translator  may be part of TGT , part of SC , split across TGT  and SC , implemented separate from TGT  and SC , and the like.","The SC  includes a SC pre-compiler , SC front-end algorithms , and SC back-end algorithms .","The SC pre-compiler  accepts computer science source files .","The computer science source files  include any suitable computer programming source files which may be compiled by a compiler. For example, computer science source files  may include computer programming source files for any suitable computer programming language(s), such as C++, Java, Python, and the like, as well as various combinations thereof. For example, computer science source files  may include one or more of one or more C files, one or more C++ files, and\/or any other suitable computer science source files.","The SC pre-compiler  processes the computer science source files .","The SC pre-compiler  processes the computer science source files , producing therefrom pre-processed computer science source files . The computer science source files  may be pre-processed by SC pre-compiler  to form pre-processed computer science source files in any suitable manner. The SC pre-compiler  provides the pre-processed computer science source files to front-end algorithms .","The SC pre-compiler  detects test operations during processing of the computer science source files , and generates the test operation description files . The test operation description files  may be specified using any suitable test description language (e.g., using one or more standard test description languages, using a test description language specific to the TGT , and the like, as well as various combinations thereof). The SC pre-compiler  provides the test operation description files  to TGT  (illustratively, to the TGT composer  of TGT , which processes the test operation description files  in conjunction with the system description files  to produce circuit model ).","The SC front-end algorithms  accept pre-processed computer science source files . The SC front-end algorithms  also accept the TISA atomic test operations , which are produced by TISA translator  using TGT atomic test operations  produced by TGT  from the test operation description files . The SC front-end algorithms  compile the pre-processed computer science source files and TISA atomic test operations  to produce a program model . The program model  specifies an intermediate representation of the pre-processed computer science source files , which includes TISA atomic test operations  such that TISA atomic test operations  may be integrated within the ISA atomic operations to form TISA atomic operations. The SC front-end algorithms  provide the program model  to the SC back-end algorithms .","The SC back-end algorithms  accept program model . The SC back-end algorithms  process program model  to produce one or more TISA Binary Files  including TISA atomic operations . The processing of program model  by the SC back-end algorithms  to form the TISA Binary Files  including the TISA atomic operations  may be performed in any suitable manner.","The TISA atomic operations  include ISA atomic operations (i.e., assembly-level instructions supported by the processor for which the TISA is implemented) and TISA atomic test operations .","The TISA atomic operations  provide algorithmic control (using ISA atomic operations) over TGT atomic test operations  (i.e., in the form of the TISA atomic test operations ), thereby enabling improved system testing of the system under test to which the TISA atomic operations  are to be applied. Thus, the TGT atomic test operations  (i.e., in the form of the TISA atomic test operations ) may be applied to the TAP in a manner controlled by SC back-end algorithms , because the TGT atomic test operations  are combined with the ISA atomic operations to enable algorithmic control over TGT atomic test operations  using the ISA atomic operations. In this manner, the SC  provides algorithmic control of access to the TAP.","It will be appreciated that the various inputs and outputs depicted and described with respect to  may be stored, displayed, executed, propagated, and\/or handled in any other suitable manner, as well as various combinations thereof.","With respect to  and , although primarily depicted and described with respect to specific numbers of input files, intermediate files, models, output files, and the like, it will be appreciated that the embodiments of  and , as well as various associated teachings provided herein, may be implemented using any suitable numbers of input files, intermediate files, models, output files, and the like.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 2","FIG. 3","FIG. 2","FIG. 3"]},"Referring to , it will be appreciated that the capabilities and features of the TISA are defined by its abstraction level, i.e., the finer the definition of the TISA atomic operations, the better performance the TISA will provide.","In one embodiment, in which TISA is implemented in a JTAG architecture, three abstraction levels may be supported for scan operations.","The first abstraction level is the Vector Level. The Vector Level is the coarsest grain of the three abstraction levels, where the atomic operations are inputs and outputs of scan vectors. The Vector Level is best represented in a vector format, such as Serial Vector format (SVF) or any other suitable vector format, and gives the highest-level control.","The second abstraction level is the TAP Level. In the TAP Level, the atomic operations are enhanced to allow full control over the TAP state machine. This enables more refined control over scan operations, support of non-standard sequences (e.g., like the ones required, for instance, in the Addressable Shadow Protocol or other similar protocols).","The third abstraction level is the Scan Segments Level. The Scan Segments Level is the finest grain of the three abstraction levels. The Vector Level and TAP Level abstraction levels use the scan vector as the atomic data format, which is sufficient for traditional continuity tests where the entire scan chain is involved, but is cumbersome for instrument-based testing where there is a need for fine-grain control over the tens or hundreds of instruments that compose the scan chain. The Scan Segments Level allows the definition of \u201cscan segments\u201d inside the overall scan path, which can be handled separately, thereby providing a flexible and powerful set of primitives that can be used to define scan operations directly in the problem space and resolve the scan operations at implementation time. This approach is advantageous in embedded applications, where the available computational resources may be quite limited. The use of Scan Segments Level is depicted and described in additional detail hereinbelow.","As depicted in  and , regardless of the abstraction level of the scan operations, the resulting TAP atomic operations (illustratively, TGT atomic test operations  and TGT atomic test operations ) computed by the TGT are converted into corresponding TISA atomic test operations and inserted into the binary executable (i.e., into the ISA atomic operations generated by the SC).","Referring to , TGT atomic test operations  and ISA atomic operations  can be processed to form the TISA atomic operations  in the TISA binary executables (illustratively, TISA binary files ). The TISA atomic operations  include TISA atomic test operations and ISA atomic operations.","Referring to , TISA atomic test operations (generated by TISA translator  from TGT atomic test operations  produced by TGT ) can be input into the SC front end  as pre-compiled assembly instructions, without any need to modify the SC front end  of SC . It will be appreciated that almost all programming languages allow for such operations. In C, for example, this operation is obtained using the \u201casm\u201d command. In one embodiment, minor modifications to SC back-end algorithms  may be required (e.g., to handle binary conversion of the TISA assembler instructions). An example of such a process is depicted and described herein with respect to .","Although primarily depicted and described with respect to levels of granularity of TISA atomic operations in a JTAG architecture, it will be appreciated by one skilled in the art that the same levels of granularity of TISA atomic operations may be utilized in other architectures, that different levels of granularity of TISA atomic operations may be utilized in a JTAG architecture and\/or other architectures, and the like, as well as various combinations thereof.","As described hereinabove, the TISA may be implemented using any suitable instruction set architecture (ISA). For example, the TISA may be implemented using the SPARC V8 ISA, an INTEL ISA, and the like.","For purposes of clarity in describing implementation of the TISA, an exemplary implementation of the TISA using a SPARC V8 ISA is depicted and described herein with respect to . In this exemplary implementation, the TISA is implemented as a Vector Level TISA, which allows direct coding of the instructions that compose the SVF format; however, as described hereinabove, it will be appreciated that implementation of the TISA using the SPARC V8 ISA also may be performed where the TISA is implemented as a TAP Level TISA or a Scan Segment Level TISA.","The SPARC V8 ISA is implemented in many products, such as the open-source soft processor family Leon 2 and Leon 3.","A review of \u201cThe SPARC Architecture Manual Version 8,\u201d published by SPARC International, Inc, 1992 (hereinafter \u201cSPARC Architecture Manual\u201d), reveals that there are many code words not exploited by the SPARC V8 ISA. This is evident at least from a review of the \u201copcodes and condition codes\u201d of Appendix F.",{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIG. 4A","FIG. 4A"]},{"@attributes":{"id":"p-0106","num":"0105"},"figref":["FIG. 4B","FIG. 4B"],"b":["30","25","21","18","17","14"]},{"@attributes":{"id":"p-0107","num":"0106"},"figref":["FIG. 4C","FIG. 4B"],"b":["21","18"]},"The SVF instructions allow for multiple parameters, which need to be coded inside the final code. In order to represent the parameters, and in the interest of the usual architectural best practice of keeping instruction and data separated, register-based parameter passing is defined for this exemplary implementation of a Vector Level TISA. Thus, the Vector Level TISA presents six dedicated 32-bit registers: GENERIC1, GENERIC2, TDI, TDO, MASK and SMASK. The six dedicated 32-bit registers are depicted in . The usage of the six dedicated 32-bit registers is described in detail hereinbelow, but, as a general rule, these registers are used either to store a parameter or to point to the memory location in which a parameter is stored. Thus, at compilation time, normal ISA instructions can be used to load these registers before the TISA instruction is invoked. More specifically, in this SPARC V8 ISA implementation of the TISA, coprocessor registers may be used directly as parameters for the usual load\/store instructions.","The SVF instructions which may be utilized in this SPARC V8 ISA implementation of the TISA include ENDDR, ENDIR, STATE, FREQUENCY, PIO, PIOMAP, HDR, HIR, TDR, TIR, SDR, SIR, and RUNTEST. These SVF instructions may be better understood by way of reference to the \u201cSerial Vector Format Specification,\u201d by ASSET InterTech, Inc., 1997 (hereinafter referred to as the SVF Manual), which is herein incorporated by reference in its entirety. The use of these SVF instructions in this SPARC V8 ISA implementation of the TISA is described in more detail hereinbelow.","ENDDR, ENDIR, STATE","The ENDDR and ENDIR instructions indicate the TAP state at which the TAP interface ends its operation. The STATE instruction forces the TAP interface to a specified state. In this exemplary implementation of the TISA, the SVF codings for the ENDDR, ENDIR, and STATE instructions are \u201c000000\u201d, \u201c000001\u201d, and \u201c000010\u201d, respectively, as depicted in . The SVF coding of these SVF instructions may be performed using the \u201cTAP STATE\u201d file (i.e., the exemplary bit coding of the TAP states as depicted in ) as needed. It will be appreciated, at least from a review of the SVF Manual, that the STATE instruction can optionally take the explicit sequence of states as parameters. In this exemplary implementation of the TISA, taking the explicit sequence of states as parameters would be coded by a series of instructions, one for each state in the sequence.","FREQUENCY","The FREQUENCY instruction is used to specify the working frequency of the TAP interface. The FREQUENCY instruction is expressed as a 32-bit integer of Hz cycles. In this exemplary implementation of the TISA, the SVF coding for the FREQUENCY instruction is \u201c000011\u201d, as depicted in . The value for the FREQUENCY instruction is stored in the GENERIC1 register.","PIO, PIOMAP","The PIO instruction can be used to handle parallel vectors, in a format previously set by a call to PIOMAP. In this exemplary implementation of the RISA, PIOMAP is seen as a pre-processor directive that generates the appropriate commands to set up the TAP interface. Thus, the PIO instruction merely needs to express the parallel vector, which can be expressed by indicating (in the GENERIC1 register) the address in which the parallel vector is stored. The number of words \u201cn\u201d that compose the vector is specified in bits - of the instruction, and, thus, the vector has an upper size limit of 2=8K words=32 Kbytes. If the vector size is not an exact multiple of a word, padding and re-alignment may be provided in memory, as needed. In this exemplary implementation of the TISA, the SVF coding for the PIO instruction is \u201c000100\u201d.","HDR, HIR, TDR, TIR","The roles of the HDR, HIR, TDR, and TIR instructions are different. Here, these SVF instructions are considered together because (1) these SVF instructions are functionally similar (i.e., they all command shift operations, even if they are of a different nature), and (2) these SVF instructions accept the same parameters:","(1) length: a 32-bit number expressing the number of bits to shift;","(2) TDI (optional): the input shift vector;","(3) TDO (optional): the expected output shift vector;","(4) MASK (optional): a mask to be used when comparing actual values with TDO. A \u20181\u2019 indicated a care, a \u20180\u2019 a don't care; and","(5) SMASK (optional): a mask to mark which bits are to be considered in TDI. \u20181\u2019 indicates a care, \u20180\u2019 a don't care.","In this exemplary implementation of the TISA, the SVF codings for the HDR, HIR, TDR, and TIR instructions are \u201c000110\u201d, \u201c000111\u201d, \u201c001010\u201d, and \u201c001011\u201d, respectively, as depicted in .","In this exemplary implementation of the TISA, the following additional codings may be used:","(1) length is stored in the GENERIC1 register;","(2) O1 is \u20181\u2019 when TDI is present, \u20180\u2019 otherwise. If set, the TDI register contains the address at which the input vector is stored;","(3) O2 is \u20181\u2019 when TDO is present, \u20180\u2019 otherwise. If set, the TDO register contains the address at which the expected output is stored;","(4) O3 is \u20181\u2019 when MASK is present, \u20180\u2019 otherwise. If set, the MASK register contains the address at which the output mask is stored; and","(5) O4 is \u20181\u2019 when SMASK is present, \u20180\u2019 otherwise. If set, the SMASK register contains the address at which the output mask is stored.","SDR, SIR","The SDR and SIR instructions have the same syntax as the HDR, HIR, TDR, and TIR instructions, but have a functional difference: SDR and SIR trigger the actual scan operation on the TAP. In interactive testing the actual output vector read from the system is fundamental for the algorithm, so the TISA offers the possibility of storing the actual output vector in memory. When the \u201cTAP STATE\u201d field (bits -, as depicted in ) is different than zero, the GENERIC2 register indicates the storage location of the actual output vector. Thus, SDR and SIR can support a maximum of seven parameters. If TDO is specified and the actual output vector is different from the expected output vector, an overflow flag is set in the Processor State Register (PSR), as described in Section 4.2 of the SPARC Architecture Manual.","RUNTEST","The RUNTEST instruction forces the TAP interface to run a test at a specified state for a specified amount of time, and is used mainly to control RUNBIST operations (e.g., as defined in IEEE 1149.1). The RUNTEST instruction accepts one or more of the following parameters (all of which are optional):","(1) run_state: the state the interface must maintain during test execution;","(2) run_: the number of clock cycles the test must take;","(3) run_clk: which clock run_count refers to (TCK: TAP clock, SCK: system clock);","(4) min_time: minimum run time in seconds, expressed as a real number;","(5) max_time: maximum run time in seconds, expressed as a real number; and","(6) endstate: the state the interface must reach at the end of the command.","In this exemplary implementation of the TISA, the SVF coding for the RUNTEST instruction may be \u201c000101\u201d or \u201c100101\u201d.","In this exemplary implementation of the TISA, the following additional codings may be used:","(1) TAP_STATE: it contains run_state of which it is defined;","(2) O1: \u20181\u2019 if TAP_STATE is defined, \u20180\u2019 otherwise;","(3) O2: \u20181\u2019 if min_count is specified, \u20180\u2019 otherwise. If set, the GENERIC1 register contains the 32-bit unsigned representation of min_count;","(4) O3: \u20181\u2019 if max_time is set, \u20180\u2019 otherwise. If set, the GENERIC2 register contains the 32-bit unsigned representation of max_count;","(5) O4: \u20181\u2019 if endstate is set, \u20180\u2019 otherwise. If set, Bits - contain the end state.","(6) Bits -: if run_count is specified, expressed as an unsigned integer (max run_count=2=1024). If this field is not \u201c0\u201d, then Bit  indicates run_clock (\u20181\u2019=TCK, \u20180\u2019=SCK).","Although primarily depicted and described herein with respect to use of specific SVF instructions in this SPARC V8 ISA implementation of the TISA (i.e., namely, ENDDR, ENDIR, STATE, FREQUENCY, PIO, PIOMAP, HDR, HIR, TDR, TIR, SDR, SIR, and RUNTEST), it will be appreciated that fewer or more SVF instructions may be used.","Although primarily depicted and described herein with respect to an implementation of the TISA using the SPARC V8 ISA, it will be appreciated that various other ISAs may be utilized to implement a TISA in accordance with the TISA teachings depicted and described herein.","In interactive testing approaches, the data handoff point is quite important. As described hereinabove, a test program is composed of two main portions: the algorithmic portion (as represented by the software compiler) and the test access portion (as represented by the test generation tool). During a test operation using a testing program, there will be moments when the test program is accessing the system under test, and moments when the test program is examining the testing results and deciding the next step(s) required. The hand-off between these two operations is important for obtaining efficient interactive testing.","In existing script-based approaches, such as SVF and STAPL, a script takes care of all TAP operations at the Vector Level. At this level, the interface (or \u201cplayer\u201d) is able to communicate with the TAP protocol, and send\/receive vectors to\/from the system under test. Furthermore, STAPL also allows some basic flow control (if-then-else) and algorithmic operations on the bit vectors. If there is need for more sophisticated processing (e.g., identifying a register inside a received vector, or computing the vector to access a specific device), the player hands control over to the algorithmic portion. In STAPL, this is done through the \u201cexport\u201d command. Disadvantageously, however, neither SVF nor STAPL has a standardized format for this (e.g., in the case of STAPL, the handoff process is usually proprietary to a given vendor).","In existing embedded approaches, like Master Test Controller (MTC) from Ericsson and the System BIST Processor, the same partitioning between the algorithmic portion and the test access portion is used. In such embedded approaches, the algorithmic portion and the test access portion are executed by different coprocessors that must be programmed separately. Furthermore, the memory spaces of the algorithmic portion and the test access portion are physically different, such that the resulting handoff mechanisms are similar to the handoff mechanisms of STAPL. The result is that the coprocessor for the test access portion is forced to store a lot of scan operations before handoff to the algorithmic portion, which, given the increasing size of scan chains, may require a huge amount of resources.","In contrast with existing approaches to integrated testing (e.g., script-based approaches such as SVF and STAPL, and embedded approaches such as MTC and System BIST Processor), the TISA integrates the test access portion (i.e. the test operations) inside the algorithmic portion (i.e., the classical ISA), such that the test access portion and the algorithmic portion share the same physical memory space, thereby making handoff (and, thus, data passing) between the test access portion and the algorithmic portion automatic. In TISA, handoff between the test access portion and the algorithmic portion is made at the instruction level, such that the processor can freely mix scan and algorithm (i.e., freely mix test operations and algorithmic operations) as required according to the associated scheduling strategy.","In this exemplary implementation of the TISA, using the SPARC V8 ISA, all operations handling vectors use absolute addressing (as described hereinabove with respect to the SVF instructions). As a result, testing vectors may be used like normal variables inside the ISA program, thereby making the interface between the test access portion and the algorithmic portion automatic. As an example, based on the exemplary implementation of the TISA using the SPARC V8 ISA as described hereinabove, the following steps exemplify an archetypical testing sequence:","(1) An SDR instruction is used to obtain testing output data from the system under test. The resulting output data is placed in a specific memory location (e.g., the \u201cactual\u201d parameter in the GENERIC2 register);","(2) A classical LOAD instruction can transfer this output data to be loaded into a register;","(3) Once the output data is loaded in the register, arithmetic operations and\/or logical operations may be used to process the output data (note that since the SPARC V8 ISA is a load\/store architecture, all data must be loaded into a register before being handled);","(4) A classical STORE instruction is used to transfer the result of the algorithm into memory; and","(5) An SDR instruction can send new testing input data to the TAP (e.g., using the \u201cTDI\u201d parameter in the TDI register).","Note that the classical algorithmic operations (2) through (4) are standard for any ISA algorithm implementation, and are not modified in any way by the TISA.","Thus, from this simple example, it is clear that TISA can be supported using any given algorithm or computer program, with a natural and efficient hand-off between the algorithmic portion and the test access portion.","In this exemplary implementation of the TISA, using the SPARC V8 ISA, absolute addressing is used (for purposes of clarity in describing the TISA); however, one skilled in the art and informed by the teachings herein would be able to modify this exemplary implementation of the TISA to support all legal SPARC V8 addressing modes described in the SPARC Architecture Manual.","Although primarily depicted and described herein with respect to an exemplary implementation of the TISA in which SVF is used, SVF was used in the exemplary implementation because it is a well-known format proven to provide a complete, even if basic, handling of 1149.1 TAPs. It will be appreciated, by one skilled in the art and informed by the teachings herein, that the TISA may be implemented using any other suitable control formats, many of which may allow finer grain control of the TAP state machine and support more sophisticated testing operations.","Although primarily depicted and described herein with respect to an exemplary implementation of the TISA in which the abstraction level is the Vector Level, it will be appreciated, by one skilled in the art and informed by the teachings herein, that the exemplary TISA implementation depicted and described herein may be modified such that the abstraction level of the TISA is the TAP Level or the Scan Segment Level.","For purposes of clarity in describing the TISA, an exemplary use of the TISA to perform testing on an exemplary system under test is depicted and described herein with respect to . In this exemplary use of the TISA, the TISA is implemented as a Vector Level TISA using a SPARC V8 ISA and SVF (i.e., in continuation of the exemplary implementation depicted and described with respect to ).",{"@attributes":{"id":"p-0166","num":"0165"},"figref":["FIG. 5A","FIG. 5B"]},{"@attributes":{"id":"p-0167","num":"0166"},"figref":"FIG. 5A","b":["500","510","520"]},"The JTAG TAP  provides test access to a system under test . The JTAG TAP  provides test access to the system under test , for sending input data to system under test  and receiving output data from system under test . The JTAG TAP  includes an instruction register (IR) , which is an 8-bit instruction register.","The JTAG TAP  is controlled by a testing system (e.g., such as testing system  depicted and described with respect to , which is omitted for purposes of clarity).","The system under test  includes a first board  (denoted as B) and a second board  (denoted as B). The first board  includes a transmitter  (denoted as T). The second board  includes a receiver  (denoted as R). The transmitter  sends data, on a connection , to receiver . In this example, the connection  is an 8-bit connection.","As depicted in , each board is accessible from JTAG TAP  via its own scan chain. Namely, first board  is accessible via a first scan chain  and second board  is accessible via a second scan chain . The first scan chain  and second scan chain  are selectable by the IR  of JTAG TAP  (e.g., IR=0 selects first board B, IR=1 selects second board B). The transmitter  and the receiver  are not alone on their boards; rather, they are part of wider scan chains (e.g., for purposes of this example, 24 bits and 16 bits, respectively).","In a test program, input data is sent to transmitter  via the first scan chain , and the resulting output data is collected from the receiver  by exploiting the second scan chain . In order to perform an exhaustive test, all possible values are sent through the connection , such that 2=256 vectors are sent through the connection . Using C, an exemplary program could be the following:",{"@attributes":{"id":"p-0173","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1\u2002 include <stdio.h>"]},{"entry":[{},"2\u2002 include <jtag.h>"]},{"entry":[{},"3"]},{"entry":[{},"4\u2002 char sent_value, received value;"]},{"entry":[{},"5"]},{"entry":[{},"6\u2002 define MAX_COUNT 256;"]},{"entry":[{},"7"]},{"entry":[{},"8\u2002 void main(void)"]},{"entry":[{},"9\u2002 {"]},{"entry":[{},"10\u2003\u2002\u2009for (sent_value=0;sent_value<MAX_COUNT;sent_value++)"]},{"entry":[{},"11\u2003\u2003\u2002{"]},{"entry":[{},"12\u2003\u2003\u2003\u2002apply_JTAG(sent_value,B1.T);"]},{"entry":[{},"13\u2003\u2003\u2003\u2002read_JTAG (received_value,B2.R);"]},{"entry":[{},"14\u2003\u2003\u2003\u2003if (sent_value != received value) exit (0);"]},{"entry":[{},"15\u2003\u2003\u2002}"]},{"entry":[{},"16\u2003\u2002exit(1);"]},{"entry":[{},"17 }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this program, line  includes the C module that is handling JTAG operations, where the functions \u201capply_JTAG\u201d and \u201cRead_JTAG\u201d, used in lines  and , respectively, are defined. The pre-compiler  of SC  recognizes these functions, and generates test operation description files  for TGT . The format of the test operation description files  may vary, depending on the actual implementation of first board  and second board . For example, if first board  and second board  both are IJTAG compliant, test operation description files  could be specified, for example, using New Scan Description Language (NSDL) code. The TGT , using test operation description files , generates TGT atomic test operations , which are translated, by TISA translator , into TISA atomic test operations . The TISA atomic test operations  are provided to front-end  of SC . The TGT atomic test operations , the associated TISA atomic test operations , and the resulting TISA binary code are depicted in .",{"@attributes":{"id":"p-0175","num":"0174"},"figref":["FIG. 5B","FIG. 5A"],"b":"500"},"As depicted in , the mapping from C commands to TISA coding is represented using a table  having four columns: a \u201cC command\u201d column , an \u201cSVF instructions\u201d column , a \u201cTISA assembler\u201d column , and a \u201cTISA coding\u201d column . The table , from left to right, illustrates the manner in which a C command can be translated into an SVF instruction, which can be translated into TISA assembler, which can be coded into TISA binary coding.","The Apply_JTAG(value,B1.T) command is translated into two SVF instructions: SIR 8 TDI(00) and SDR 24 TDI(value).","The SIR 8 TDI(00) SVF instruction is translated into TISA assembler as three operations:\n\n","The SDR 24 TDI(value) SVF instruction is translated into TISA assembler as three operations:\n\n","The Read_JTAG(value,B2.R) command is translated into two SVF instructions: SIR 8 TDI(01) and SDR 16 ACTUAL(value).","The SIR 8 TDI(01) SVF instruction is translated into TISA assembler as three operations:\n\n","The SDR 16 ACTUAL(value) SVF instruction is translated into TISA assembler as three operations:\n\n","The TISA coding of the SET operations is not specified because the SPARC V8 Manual identifies them as \u201cpseudo-instructions\u201d which can have a different coding following the implementation of the processor.","Using the determined TISA codings, the pre-compiler  may now substitute the high-level JTAG accesses with their associated TISA assembler instructions. The result is the following code, specified using C, in which the calls to the JTAG TAP have been replaced by the associated TISA assembler coding:",{"@attributes":{"id":"p-0185","num":"0196"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"1\u2002 include <stdio.h>"},{"entry":"2\u2002 include <jtag.h>"},{"entry":"3"},{"entry":"4\u2002 char sent_value, received value;"},{"entry":"5"},{"entry":"6\u2002 define MAX_COUNT 256;"},{"entry":"7"},{"entry":"8\u2002 void main(void)"},{"entry":"9\u2002 {"},{"entry":"10\u2003\u2003\u2002\u2009for (sent_value=0;sent_value<MAX_COUNT;sent_value++)"},{"entry":"11\u2003\u2003\u2003\u2002{"},{"entry":"12\u2003\u2003\u2003\u2003\u2002asm volatile (\u201cSET 8, %cGENERIC1;"},{"entry":"13\u2003\u2003\u2003\u2003\u2003\u2003SET 00, %cTDI;"},{"entry":"14\u2003\u2003\u2003\u2003\u2003\u2003SIR TDI;"},{"entry":"15\u2003\u2003\u2003\u2003\u2003\u2003SET 24, %cGENERIC1;"},{"entry":"16\u2003\u2003\u2003\u2003\u2003\u2003SET &sent_value, %cTDI;"},{"entry":"17\u2003\u2003\u2003\u2003\u2003\u2003SDR TDI;\u201d);"},{"entry":"18\u2003\u2003\u2003\u2003\u2002asm volatile (\u201cSET 8, %cGENERIC1;"},{"entry":"19\u2003\u2003\u2003\u2003\u2003\u2003SET 01, %cTDI;"},{"entry":"20\u2003\u2003\u2003\u2003\u2003\u2003SIR TDI;"},{"entry":"21\u2003\u2003\u2003\u2003\u2003\u2003SET 16, %cGENERIC1;"},{"entry":"22\u2003\u2003\u2003\u2003\u2003\u2003SET &received_value, %cGENERIC2;"},{"entry":"23\u2003\u2003\u2003\u2003\u2003\u2003SDR ACTUAL\u201c);"},{"entry":"24\u2003\u2003\u2003\u2003\u2003if (sent_value != received value) exit (0);"},{"entry":"25\u2003\u2003\u2003\u2002}"},{"entry":"26\u2003\u2003\u2002exit(1);"},{"entry":"27 }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"This code can be input into the front-end algorithms , which will generate the program model . The program model  can be input into the back-end algorithms , which will generate the executable TISA binary file(s)  including the TISA atomic operations .","The \u201cTISA coding\u201d column  of table  depicts the binary coding of the TISA assembler instructions (e.g., using the various rules defined with respect to the exemplary implementation of the TISA using a SPARC V8 ISA, as depicted and described with respect to ).","As described herein, the TISA provides complete freedom regarding test granularity in performing testing of a system under test (i.e., from TAP Level through Scan Segment Level). As depicted in  and , and further explained using the exemplary TISA implementation of  and , test patterns may be computed using explicit queries by the Software Compiler to the Test Generation Tool, such that the only limit for the software algorithm is the resolution of the queries themselves.","As an example, at a coarse level, queries from the SC to the TGT may involve the entire scan chain of the system under test (e.g., such as in classical BSDL-based Boundary Scan testing).","As an example, at a fine level, queries from the SC to the TGT may involve registers or even bits. For example, dedicated Scan Segment primitives could significantly accelerate instrument access and TAP reconfiguration, boost code reuse, and provide various other advantages.","As an example, at a middle level somewhere between the coarse and fine levels, queries from the SC to the TGT may be done functionally (e.g., using standards such as IJTAG and other suitable standards, and using description languages such as NSDL and other suitable object-oriented description languages).","In this manner, the TISA does not force device\/register access to be resolved at the model space (i.e., in the TGT), but, rather, allows developers to handle device\/register access at the problem space (i.e., in the SC), thereby enabling developers to adapt the analysis grain to their needs and to the available resources.","Furthermore, in embodiments in which the TISA processor has sufficient resources, e.g., such as in the case of Automated Test Equipment (ATE), at least a portion of the circuit model may be implemented within the program model, thereby enabling the TISA machine to directly compute the vector patterns.","Furthermore, the TISA enables support for various other system test capabilities not previously possible without TISA, such as interactive testing including interactive debugging (locally and\/or remotely), concurrency, portability, and the like, as well as various combinations thereof. These additional capabilities are now addressed in additional detail.",{"@attributes":{"id":"p-0195","num":"0206"},"figref":"FIG. 6"},"As depicted in , TISA-based testing environment  includes a host computer (HC) , a testing system (TS) , and a system under test (SUT) .","The HC  is configured to control TS  for controlling testing of SUT . The HC  includes a processor  coupled to a memory . The processor  and memory  may be any suitable processor and memory.","The memory  stores one or more debugger control programs . The debugger control program(s) enable HC  to trace and, where desired or necessary, alter, the execution of computer program(s) running on TS . For example, debugger control program(s)  may include one or more of the GNU Debugger (GDB), the dbx debugger, the Perl debugger, the Bash debugger, the Python debugger, and like suitable debugger programs, as well as various combinations thereof.","The memory  also may store one or more debugger display programs . The debugger display program(s) enable HC  to display information associated with the debugger control program(s) . The information associated with debugger control program(s)  may be displayed by debugger display program(s)  in any suitable manner (e.g., using one or more display devices). For example, debugger display program(s)  may include one or more of Insight (which is a graphical user interface to GDB), the Data Display Debugger (DDD, which provides a graphical user interface for various command-line debuggers, such as GDB and others), and like suitable debugger display programs, as well as various combinations thereof.","The TS  is controlled by HC  for purposes of testing SUT . The TS  is configured to function in a manner consistent with the TISA (e.g., such as depicted and described with respect to TS  of . ) and, further, is configured to support interactive testing (e.g., by enabling access by debuggers running on HC ).","The TS  includes a TISA processor  coupled to a memory . The TISA processor  may be implemented using any suitable processor, such as SPARC V8 (as depicted and described hereinabove with respect to  and ), INTEL, and the like. The memory  may be any suitable memory.","The memory  stores one or more debugger program stubs . The debugger program stubs  understand the debugger protocol of the corresponding debugger control program(s)  running on HC , thereby enabling HC  to communicate with TS . For example, debugger stub(s)  may include one or more of GDB stub, a DBX stub, a Perl stub, a Bash stub, a Python stub, and like suitable debugger program stubs, as well as various combinations thereof.","The memory  stores TISA Binary Files . The TISA Binary Files  are generated by TS  in a manner as depicted and described herein with respect to  and . The TISA Binary Files  are executed by TISA processor  to perform testing on SUT .","The TS  also includes a Test Access Port (TAP)  coupled to TISA processor . The TAP  provides a test interface between TISA processor  and SUT  for enabling TISA processor  to perform testing of SUT  while being controlled by HC . The TAP  may be any suitable TAP (e.g., an 1149.1 TAP).","The TISA processor  interfaces with TAP  using an interface . The interface  may be any suitable interface between a TAP and a system under test (e.g., such as an interface that supports TCK, TMS, TDI, TDO, and, optionally, TRST, where TAP  is implemented as an 1149.1 TAP).","As depicted in , there is an interface  between HC  and TS . The interface  may support local communications and\/or remote communications between HC  and TS . Thus, HC  may control interactive testing of SUT  via TS  locally and\/or remotely.","For example, for local testing, interface  may be implemented as one or more of a Universal Asynchronous Receiver-Transmitter (UART) interface, serial interface, and the like, as well as various combinations thereof.","For example, for remote testing, interface  may be implemented using any suitable communications capabilities, such as Transmission Control Protocol (TCP)\/Internet Protocol (IP) or any other suitable communications protocols. This enables remote testing in which the HC  and TS  may be separated by large geographical distances, and HC  will still be able to control TS  for purposes of performing testing of SUT .","In the TISA-based testing environment , the HC  is able to control, step-by-step, test execution on SUT , by controlling operation of TS  via a standard connection (e.g., UART, TCP\/IP, and the like), thereby enabling interactive testing and debugging capabilities.","Although omitted for purposes of clarity, it will be appreciated that HC  and TS  may include various other components, such as additional processors, additional memories, internal communications buses, input\/output modules, additional support circuits (e.g., power supplies), and the like, as well as various combinations thereof.","Although omitted for purposes of clarity, it will be appreciated that SUT  may be any system under test which may be tested using the TISA.","Although primarily depicted and described with respect to specific types of debugger control programs, debugger display programs, interfaces, and the like, it will be appreciated that TISA-based testing environment  may be implemented in a manner enabling fully-interactive testing capabilities using various other debugger control programs, debugger display programs, interfaces, and the like, as well as various combinations thereof.",{"@attributes":{"id":"p-0213","num":"0224"},"figref":["FIG. 7","FIG. 6"]},"As depicted in , exemplary TISA-based testing environment  of  is an implementation of the TISA-based testing environment  of  in which the GNU Tool Suite is used to support interactive testing of the exemplary system testing environment  of .","As depicted in , exemplary TISA-based testing environment  includes a host computer (HC) , a testing system (TS) , and a system under test (SUT) .","The HC  includes a processor  and a memory . The HC  of  is an implementation of HC  of , in which debugger control program(s)  is implemented using GDB (GDB ) and debugger display program(s)  is implemented using DDD (DDD ).","The TS  includes a TISA processor  and a memory . The TS  of  is an implementation of TS  of , in which the TISA processor  is implemented using a SPARC V8 ISA (denoted as SPARC V8 TISA processor ), debugger program stub(s)  is implemented using a GDB stub (GDB stub ), and the TISA Binary Files  are generated based on the SPARC V8 ISA associated with SPARC V8 TISA processor  (TISA Binary Files ).","The TS  also includes a Test Access Port (TAP)  coupled to SPARC V8 TISA processor . The TS  of  is an implementation of TS  of , in which the TAP  is implemented using a 1149.1 TAP (1149.1 TAP ).","The SPARC V8 TISA processor  interfaces with 1149.1 TAP  using an interface . The interface  is a standard 1149.1 interface that supports TCK, TMS, TDI, TDO, and, optionally, TRST.","The SUT  is the SUT  of . The SUT  includes a transmitter and receiver on different boards, as in SUT  of .","The 1149.1 TAP  provides a test interface between SPARC V8 TISA processor  and SUT  for enabling SPARC V8 TISA processor  to perform testing of SUT  while being controlled by HC .","As depicted in , there is an interface  between HC  and TS . The interface  may support local communications and\/or remote communications (e.g., via a network) between HC  and TS . Thus, HC  may control interactive testing of SUT  via TS  locally and\/or remotely.","In the exemplary TISA-based testing environment , the HC  is able to control, step-by-step, test execution on SUT , by controlling the operation of TS  via interface , thereby enabling interactive testing and debugging capabilities.","It will be appreciated that most of the left-hand side of  reuses existing Computer Science elements: namely, the entire HC , as well as the GDB stub  on TS . It is the same for the central part of , where analogies between HC  and TS  (as well as their associated sub-elements) are evident. The TISA allows this entire infrastructure to be leveraged to provide system testing.","As an example, in reference to the system test environment  of  (including the associated exemplary C programs, SVF instructions, TISA assembler instructions, and TISA codings), there are many interactive test operations that the TISA can enable by leveraging on GDB (or any other suitable debuggers), such as: (a) step-by-step execution while monitoring the variables \u201csent_value\u201d and \u201creceived_value\u201d; (b) on-the-fly modification of the value to be sent to the tap (variable \u201csent_value\u201d); (c) modification of the looping end condition; (d) monitoring of all variables; and the like, as well as various combinations thereof. These interactive test operations are standard operations for GDB, and the TISA can directly use them, due to the ability of the TISA to automatically hand off control between the algorithmic and test access portions, as described hereinabove. In the absence of the TISA, special tooling would need to be developed and adapted to each hand-off implementation.","Although exemplary TISA-based testing environment  of  is primarily depicted and described herein with respect to using the GNU Tool Suite to support interactive testing of a specific system under test, it will be appreciated, by those skilled in the art and informed by the teachings herein, that interactive testing capabilities in a TISA-based test environment may be realized using any suitable tool suites for testing any type of system under test.","Although TISA-based testing environment  of  and exemplary TISA-based testing environment  of  are primarily depicted and described herein with respect to linear test procedures where testing is done step-by-step following a pre-determined algorithm (for purposes of clarity in describing the interactive testing capabilities that are enabled by TISA), it will be appreciated that other more complicated interactive testing scenarios are possible due to the leverage of Computer Science experience and techniques enabled by TISA. An example of a more complicated interactive testing scenario enabled by TISA is depicted and described herein with respect to . It will be appreciated that this is merely one example, and that one skilled in the art and informed by the teachings herein may use TISA in many other interactive testing scenarios and applications.","As described herein, in addition to supporting both granularity and interaction, the TISA also supports concurrency.","The TISA naturally and fully merges the system testing flow with the computer science software flow and, therefore, can leverage the best aspects of both flows. As an example, approaches such as STAPL have difficulty in handling concurrent control of instruments, because such approaches are, by definition, fully sequential. Furthermore, approaches such as the MTC and SystemBIST are intrinsically sequential and single-task and, thus, it would be difficult and awkward to program such approaches to support concurrency. By contrast, concurrent execution is a well-known problem in Computer Science and is now, for instance, at the base of all operating systems. A large number of libraries supporting concurrent execution are available (e.g., the POSIX suite, the BOOST suite, and the like), and most modern processors are designed to efficiently support multi-tasking and context-switching (e.g., the SPARC V8, for instance, implements a rotating register window). The natural interaction between the system testing flow and the computer science software flow that is enabled by the TISA allows the TISA to completely leverage such computer science approaches to concurrency.","The support of concurrency capabilities by the TISA may be better understood by way of an example. As an example, consider the problem of optimizing the data transfer rate of the T-R channel between the transmitter  and the receiver  of the system under test  of  and . This would involve transmitting a stream of data patterns from transmitter  on first board , receiving a corresponding stream of data patterns at receiver  on second board , and comparing the transmitted and received streams of data patterns to compute bit\/error rates and to tune parameters of transmitter  and\/or receiver  accordingly. This optimization may be performed efficiently using three programs operating concurrently.",{"@attributes":{"id":"p-0231","num":"0242"},"figref":["FIG. 8","FIG. 5A","FIG. 7"]},"As depicted in , exemplary program architecture includes a pattern generator , a pattern receiver , and a comparator . The pattern generator , pattern receiver , and comparator  cooperate to optimize the data transfer rate of the T-R channel between the transmitter  and the receiver  of the system under test  of  and .","The pattern generator  sends the appropriate input data patterns to the transmitter  (T) on first board . The pattern generator  can access the TAP (illustratively, TAP  in , TAP  in ) in order to provide the input data patterns to transmitter  via the scan chain  of first board  (B). The pattern generator  may provide the input data patterns to the transmitter  in any suitable manner (e.g., as specified in lines - of the code described herein with respect to ). The input data patterns may be any data patterns suitable for optimizing the T-R channel between transmitter  and receiver . For example, the input data patterns may be pre-computed patterns, random patterns, and the like, as well as various combinations thereof.","The pattern receiver  collects the appropriate output data patterns from the receiver  (R) on second board . The pattern receiver  can access the TAP (illustratively, TAP  in , TAP  in ) in order to collect the output data patterns from receiver  via the scan chain  of second board  (B). The pattern receiver  may collect the output data patterns from the receiver  in any suitable manner (e.g., as specified in lines - of the code described herein with respect to ).","The comparator  communicates with pattern generator  and pattern receiver . The comparator compares the input data patterns and the output data patterns. The comparator  evaluates the bit transmission rate and the bit error rate of the T-R channel and, based on the results of the comparison, can access the control registers of both the transmitter  and the receiver  (omitted from  and , for purposes of clarity) to optimize the parameters of the T-R channel.","In order to perform such an optimization testing procedure, pattern generator , pattern receiver , and comparator  need to work in parallel, and each must be able to access the TAP independently of the others. This type of control structure is very difficult to code in traditional environments, which are developed only to support one-point serial handoff control over the TAP. This type of control structure also is very difficult to code in environments employing MTC or other such approaches which also share the same serial TAP access paradigm. By contrast, the TISA is not designed with any such assumption regarding test access; rather, in the TISA, test access is handled in a manner similar to other processor resources, and test access instructions are mixed directly with classical ISA instructions. Using the TISA, the optimization testing procedure of  may be executed by any multitasking Operating System using standard constructs like processes, threads, inter-process communications (IPC), and the like, as well as various combinations thereof. In this manner, pattern generator , pattern receiver , and comparator  can share access to the TAP, and can resolve any eventual TAP sharing issues as is done for all processor resources, e.g., using well-known constructs and algorithms such as, for example, Dijkstra's semaphores. Thus, whereas existing system testing capabilities do not support concurrency, it is clear that the TISA easily and fully supports concurrency.","As described hereinabove, the TISA does not make any assumptions regarding the test access method or the associated test program partitioning; rather, test instructions are treated in the same manner, or substantially the same manner, as classical ISA instructions, without any a priori separation between the two. This enables the TISA to be completely compatible with all existing (and, most likely, future) computer science algorithms and constructs, something that no existing test processor approaches can support.","Thus, it will be appreciated that any existing software libraries can be ported into the TISA architecture. For example, it would be easy to obtain multitasking and concurrency (e.g., as depicted and described herein with respect to ) by exploiting the POSIX and BOOST suites. Further, it will be appreciated that where the TISA is obtained as a generalization of an existing ISA (e.g., as depicted and described with respect to the exemplary SPARC V8 TISA implementation depicted and described with respect to the  and ), porting may not even be necessary since the ISA that the TISA has been developed from will already include such software libraries.","Furthermore, it will be appreciated that various other computer science techniques may be utilized for providing improved system testing using the TISA. For example, some examples of such computer science techniques which may be leveraged for the TISA include: (a) use of platform-independent coding styles, (b) use of ISA-to-ISA converters; (c) use of a Virtual Machine approach, e.g., like for Java, to obtain platform-independent bytecode, or even extension of the Java Virtual Machine itself to become a TISA; and (d) use of an Application Programming Interface (API) to standardize some TISA software interfaces, which would then be translated into primitives by the appropriate drivers. It will be appreciated that these examples are merely a few examples of computer science techniques which may be leveraged for the TISA.",{"@attributes":{"id":"p-0240","num":"0251"},"figref":"FIG. 9"},"Although primarily depicted and described herein as being performed serially, at least a portion of the steps of method  may be performed contemporaneously, or in a different order than depicted and described with respect to .","At step , method  begins.","At step , a first set of instructions is generated. The first set of instructions includes ISA instructions supported by the processor (i.e., ISA instructions being leveraged to provide the TISA for the processor).","At step , a second set of instructions is generated. The second set of instructions includes test instructions associated with the system under test. The second set of instructions may be generated in any suitable manner, e.g., as depicted and described with respect to TGT  of , as depicted and described with respect to TGT  of , and\/or using any other suitable method of generating test instructions.","At step , the first set of instructions and the second set of instructions are integrated to form thereby TISA instructions. The TISA instructions provide the TISA for the processor.","At step , the TISA instructions are stored, displayed, propagated, and\/or executed, or any combination thereof. The TISA instructions may be handled in any other suitable manner.","At step , method  ends.","The TISA may be formed in any suitable manner, e.g., as depicted and described with respect to method  of , as depicted and described with respect to the test system of  and associated method  of , as depicted and described with respect to the test system of  and associated method  of , and\/or using any other suitable method of forming a TISA.",{"@attributes":{"id":"p-0249","num":"0260"},"figref":["FIG. 10","FIG. 10"],"b":["1000","1002","1000"]},"At step , a first set of instructions is generated. The first set of instructions includes instructions generated by compiling at least one computer science software file (e.g., ISA instructions of an ISA supported by a processor).","At step , a second set of instructions is generated. The second set of instructions includes test instructions generated by compiling at least one description file associated with the system under test.","At step , the first and second sets of instructions are combined to form a combined set of instructions. In the combined set of instructions, the instructions of the first set of instructions are adapted for use in controlling execution of the test instructions of the second set of instructions.","At step , the combined set of instructions is stored, displayed, propagated, and\/or executed, or any combination thereof. The combined set of instructions may be handled in any other suitable manner.","At step , method  ends.",{"@attributes":{"id":"p-0255","num":"0266"},"figref":["FIG. 11A","FIG. 11B","FIG. 9","FIG. 10"],"b":["900","1000"]},{"@attributes":{"id":"p-0256","num":"0267"},"figref":["FIG. 11A","FIG. 11A","FIG. 11A","FIG. 11A","FIG. 2","FIG. 2"],"b":"1110"},"At step , method  begins.","At step , a program model is generated. The program model is generated by compiling at least one computer science software file (e.g., ISA instructions of an ISA supported by a processor), where the at least one computer science software file includes at least one call.","At step , a first set of instructions is generated. The first set of instructions is generated using the program model. At least one computation request also is generated using the at least one call included in the at least one computer science software file.","At step , a circuit model is generated. The circuit model is generated by compiling at least one system description file associated with the system under test.","At step , a second set of instructions is generated. The second set of instruction is generated using the circuit model and the at least one computation request.","At step , the first and second sets of instructions are combined to form a combined set of instructions. In the combined set of instructions, the instructions of the first set of instructions are adapted for use in controlling execution of the test instructions of the second set of instructions.","At step , the combined set of instructions is stored, displayed, propagated, and\/or executed, or any combination thereof. The combined set of instructions may be handled in any other suitable manner.","At step , method  ends.  depicts one embodiment of a method for generating instructions adapted for use in testing at least a portion of a system under test. Although primarily depicted and described herein as being performed serially, at least a portion of the steps of method  of  may be performed contemporaneously, or in a different order than depicted and described with respect to .  may be better understood by viewing it in conjunction with  and the associated description of .","At step , method  begins.","At step , at least one pre-processed computer science software file and at least one test operation description file are generated by pre-processing at least one computer science software file.","At step , a circuit model is generated. The circuit model is generated by compiling at least one system description file associated with the system under test and the at least one test operation description file.","At step , a set of test operations is generated. The set of test operations is generated using the circuit model. The test operations from the set of test operations are described using a set of test primitives (e.g., test primitives defined by a test generation tool which generates the circuit model). The set of test primitives includes test operations adapted for use in testing the system under test.","At step , the set of test operations is translated into a set of test instructions by translating the test primitives of the set of test operations into test instructions adapted for use in combination with software instructions of an instruction set architecture.","At step , a program model is generated. The program model is generated by compiling the at least one pre-processed computer science software file and the set of test instructions.","At step , a combined set of instructions is generated. The combined set of instructions is generated using the program model. The combined set of instructions includes (a) software instructions determined from the at least one pre-processed computer science software file and (b) test instructions from the set of test instructions.","At step , the combined set of instructions is stored, displayed, propagated, and\/or executed, or any combination thereof. The combined set of instructions may be handled in any other suitable manner.","At step , method  ends.",{"@attributes":{"id":"p-0274","num":"0285"},"figref":"FIG. 12"},"As depicted in , TISA processor architecture  includes a TISA processor  and a memory .","The TISA processor  may be any processor that is suitable for performing system testing using a TISA, such as a SPARC V8 processor, an INTEL processor, or any other suitable processor.","The memory  may include any memory suitable for use by TISA processor  to support system testing using a TISA, including one or more of random access memory, persistent memory, and the like, as well as various combinations thereof. The memory  may store any information required for performing system testing using a TISA, such as test programs, TISA instructions, testing data, and the like, as well as various combinations thereof.","In one embodiment, for example, TISA processor architecture  of  may support the TISA flows depicted and described with respect to  and .","In one embodiment, for example, TISA processor architecture  of  may operate in a manner similar to TISA processor  and memory  of testing system  depicted and described with respect to . For example, TISA processor architecture  of  may be implemented using a SPARC V8 TISA processor and associated memory, such as in the testing system  depicted and described with respect to . In such an embodiment, the TISA processor  itself interprets and executes both the ISA and TISA instructions.","In one embodiment, an apparatus for use in testing at least a portion of a system under test via a Test Access Port (TAP) includes a memory for storing a set of instructions of a test instruction set architecture and a processor executing the set of instructions of the test instruction set architecture for testing at least a portion of the system under test via the TAP. The set of instructions of the test instruction set architecture includes a first set of instructions comprising a plurality of instructions of an Instruction Set Architecture (ISA) supported by the processor and a second set of instructions comprising a plurality of test instructions associated with the TAP, where the instructions of the first class of instructions and the instructions of the second class of instructions are integrated to form thereby the set of instructions of the test instruction set architecture.","In one embodiment, a TISA processor for use in testing at least a portion of a system under test via a Test Access Port (TAP) includes a first class of instructions including instructions of an Instruction Set Architecture (ISA) supported by the processor and a second class of instructions including test instructions associated with the TAP, wherein the ISA instructions of the first set of instructions and the test instructions of the second set of instructions are integrated to form a TISA adapted for testing at least a portion of the system under test.","In one embodiment, a computer processor, for testing a system under test (SUT) via a Test Access Port (TAP), includes circuitry configured to process instructions according to a test instruction set architecture (TISA) having semantics that enable interaction with the system under test via the TAP. The TISA includes a plurality of instructions of a first type and a plurality of instructions of a second type, where the first type of instructions include instructions of an instruction set architecture (ISA) supported by the computer processor and the second type of instructions include test instructions for testing the system under test via the TAP.","Although primarily depicted and described hereinabove with respect to embodiments in which the TISA processor is defined in a particular manner (e.g., using particular language to describe different classes and\/or types of instructions), it will be appreciated that a TISA may be defined in other ways that are fully supported by the depiction and description of various TISAs as provided herein.","Although primarily depicted and described herein with respect to embodiments in which the TISA processor architecture is implemented using a single processor to support the TISA, in other embodiments the TISA processor architecture may be implemented using multiple processors.",{"@attributes":{"id":"p-0285","num":"0296"},"figref":"FIG. 13"},"As depicted in , test processor architecture  includes a primary processor  and a secondary processor  in communication via a communication path .","The primary processor  may be any processor suitable for supporting system testing, such as a SPARC V8 processor, an INTEL processor, or any other suitable processor. The primary processor  executes instructions for testing a system under test. In one embodiment, for example, primary processor  may support testing functions similar to the functions supported by CPU  of TISA processor architecture  of  (e.g., where test processor architecture  utilizes a TISA). In one embodiment, for example, primary processor  may support testing functions supported by testing processors in test processor architectures that do not utilize a TISA. The primary processor  may support various other testing capabilities.","The secondary processor  may be any processor suitable for supporting system testing, such as a SPARC V8 processor, an INTEL processor, or any other suitable processor. The secondary processor  supports a Test Access Port (TAP) interface to the system under test (which is omitted for purposes of clarity). The TAP interface may interface with any suitable TAP. For example, the TAP interface may provide an interface to an IEEE 1149.1 TAP or any other suitable TAP which may be used for testing a system under test.","The primary processor  and secondary processor  cooperate to perform testing of at least a portion of a system under test.","The primary processor  executes test instructions for testing a system under test. The test instructions may be test instructions of a TISA (where test processor architecture  utilizes a TISA) or test instructions not associated with a TISA (where test processor architecture  does not utilize a TISA). The primary processor , during execution of the test instructions, detects instructions related to control of the TAP of the system under test (e.g., such as instructions for loading input data to a TAP controller of the system under test, instructions for reading output data from a TAP controller of the system under test, and like instructions, as well as various combinations thereof). The primary processor  provides the TAP-related instructions to secondary processor . The secondary processor  receives the TAP-related instructions from primary processor . The secondary processor  executes the TAP-related instructions. The primary processor  continues executing test instructions while secondary processor  executes the TAP-related instructions received from primary processor . In this manner, primary processor  may perform a context switch and continue operating while secondary processor  controls scan operations via the TAP of the system under test. This is difficult using a single-processor approach, because while the single processor is controlling the TAP, the single processor is prevented from performing other operations. Therefore, the use of multiple processors, as in the test processor architecture , provides a significant improvement in testing efficiency without a need to use high-end processors, especially considering that operations over the TAP typically take a long time compared to the time required for a processor to perform a single operation.","The cooperation between primary processor  and secondary processor  to perform testing of at least a portion of a system under test is facilitated by communication path . The communication path  may be implemented using any suitable means of communication between primary processor  and secondary processor , which may depend on the type of multi-processor architecture with which the test processor architecture  is implemented. For example, communication path  may include one or more of a main processor interface bus, an auxiliary processor interface, a communication interface (e.g., such as a serializer-deserializer (SERDES) interface or other suitable communication interface), and the like, as well as various combinations thereof.","Although omitted for purposes of clarity, it will be appreciated that the test processor architecture  will include memory (e.g., random access memory, persistent memory, cache memory, and the like, as well as various combinations thereof). The memory of test processor architecture  may include one or more of memory shared by primary processor  and secondary processor , memory dedicated to primary processor , memory dedicated to secondary processor , and the like, as well as various combinations thereof.","Although omitted for purposes of clarity, it will be appreciated that the test processor architecture  may include various other support circuits, such as buses, I\/O circuits, and the like, as well as various combinations thereof.","The test processor architecture  of  may be implemented in a number of ways.","In one embodiment, for example, the test processor architecture may use a test co-processor unit architecture in which a central processor unit (CPU) cooperates with a test co-processor unit (TCPU) in order to support system testing. An exemplary embodiment is depicted and described with respect to .","In one embodiment, for example, the test processor architecture may use a test adjunct processor unit architecture in which a central processor unit (CPU) cooperates with a test adjunct processor unit (TAPU) in order to support system testing. An exemplary embodiment is depicted and described with respect to .",{"@attributes":{"id":"p-0297","num":"0308"},"figref":"FIG. 14","b":["1400","1400"]},"The test co-processor architecture  includes a central processor unit (CPU) , a test co-processor unit (TCPU) , a main memory , and a flash memory .","The test co-processor architecture  includes a main processor interface bus . The CPU , TCPU , main memory , and flash memory  each are coupled to (or otherwise configured to be able to communicate with) the main processor interface bus .","The test co-processor architecture  also may include an auxiliary processor interface  which directly couples CPU  and TCPU , thereby enabling direct communications between CPU  and TCPU .","The CPU  may be any CPU suitable for performing system testing of a system under test. The CPU  supports testing capabilities supported by primary processor  depicted and described with respect to .","The TCPU  may be any CPU suitable for facilitating system testing of a system under test. The TCPU  supports a Test Access Port (TAP) interface , which may interface with any suitable TAP (e.g., such as an IEEE 1149.1 TAP or any other suitable TAP used for testing a system under test). The TCPU  supports testing capabilities supported by secondary processor  depicted and described with respect to .","The CPU  and TCPU  cooperate to perform testing of at least a portion of a system under test in a manner similar to primary processor  and secondary processor  depicted and described with respect to . The CPU  and TCPU  utilize instruction exception handling in order to enable CPU  to continue operating to process test instructions while TCPU  executes TAP-related instructions for controlling the TAP of the system under test during testing.","The CPU  executes test instructions for testing a system under test. The CPU , during execution of the test instructions, detects instruction exceptions (i.e., instructions related to control of the TAP of the system under test) and provides the instruction exceptions to TCPU . The TCPU  receives the instruction exceptions from CPU  and processes the instruction exceptions such that the TCPU  may handle the instruction exceptions while CPU  continues to operate to perform other tasks (e.g., executing other testing instructions). In other words, CPU  and TCPU  cooperate during system testing such that CPU  may switch context and continue to operate to perform other tasks while TCPU  handles instruction exceptions detected by CPU , thereby improving system testing efficiency.","In one embodiment, the CPU  includes a cache , e.g., for improving the performance of CPU .","In one embodiment, the TCPU  includes a direct memory access (DMA) unit , which may be any type of DMA unit suitable for use in support system testing. In one embodiment, for example, DMA unit  is a scatter\/gather (S\/G) DMA unit. The TCPU  may utilize DMA unit  for purposes of handling instruction exceptions received from CPU , and for efficiently accessing sensible data stored in memory. In one embodiment, CPU  may configure S\/G DMA tables prior to encountering an instruction exception.","In one embodiment, the TCPU  supports a set of specialized TCPU instructions. The set of specialized TCPU instructions may support TAP access and control. The set of specialized TCPU instructions may be used by TCPU  to perform specific TAP operations on the TAP State Machine.","The CPU  and TCPU  utilize main memory  and\/or flash memory  for performing various testing functions, such as execution of test instructions by CPU , instruction exception handling by TCPU , execution of TCPU instruction by TCPU , and the like, as well as various combinations thereof. The main memory  may be any suitable processor memory. The flash memory  may be any suitable flash memory or any other suitable form of persistent memory. The CPU  and TCPU  share the memory with arbitrated access. The CPU  and TCPU  also may share the memory for purposes of exchanging information. Although primarily depicted and described with respect to specific numbers and types of memory, it will be appreciated that various other memory schemes may be used for supporting the functions performed by CPU  and TCPU .","The CPU  and TCPU  perform testing of the system under test using communication between CPU  and TCPU  and communication between CPU  and\/or TCPU  and other components of test co-processor architecture  (e.g., main memory , flash memory , and other components), and the like, as well as various combinations thereof. The communications may be supported using one or both of the main processor interface bus  and the auxiliary processor interface . The communications between CPU  and TCPU  may include communications associated with instruction exception notification, interrupt access, DMA arbitration, and the like, as well as various combinations thereof. The communications between CPU  and TCPU  and other components of the test co-processor architecture  may include communications associated with reading from memory, writing to memory, and\/or any other tasks which may be performed in support of testing the system under test.",{"@attributes":{"id":"p-0310","num":"0321"},"figref":"FIG. 15","b":["1500","1500"]},"The test adjunct processor architecture  includes a central processor unit (CPU)  and a test adjunct processor unit (TAPU) . The CPU  and TAPU  may reside on the same board or may reside on different boards.","The CPU  may be any CPU suitable for performing system testing of a system under test. The CPU  supports testing capabilities supported by primary processor  depicted and described with respect to .","The CPU  has a main memory , a flash memory , and an input\/output module  associated therewith. The CPU  has a main processor interface bus  associated therewith. The CPU , main memory , flash memory , and input\/output module  each are coupled to (or otherwise configured to be able to communicate with) the main processor interface bus .","In one embodiment, the CPU  includes a cache , e.g., for improving the performance of CPU .","The TAPU  may be any CPU suitable for facilitating system testing of a system under test. The TAPU  includes an input\/output module . The TAPU  supports a Test Access Port (TAP) interface , which may interface with any suitable TAP (e.g., such as an IEEE 1149.1 TAP or any other suitable TAP used for testing a system under test). The TAPU  supports testing capabilities supported by secondary processor  depicted and described with respect to .","The TAPU  has a local test memory  associated therewith. The TAPU  has an internal interface bus  associated therewith. The TAPU  and local test memory  each are coupled to (or otherwise configured to be able to communicate with) the internal interface bus .","The input\/output module  associated with CPU  and the input\/output module  of TAPU  support a communication interface  enabling communications between CPU  and TAPU . The communication interface  supports streaming of TAP-related commands from CPU  to TAPU .","In one embodiment, the input\/output module  associated with CPU  and the input\/output module  of TAPU  support Serializer-Deserializer (SERDES) communications capabilities and, therefore, the communications interface  is a SERDES-based communications interface. In this embodiment, the SERDES-based communications interface  may be implemented using any suitable SERDES communications protocol (e.g., such as Gigabit Ethernet (GigE), Serial Rapid IO (SRIO), Peripheral Component Interconnect Express (PCIe), and the like). Although primarily depicted and described herein with respect to using SERDES-based communications between the CPU  and the TAPU , other suitable communications capabilities may be used in order to support communications between CPU  and TAPU .","The CPU  and TAPU  cooperate to perform testing of at least a portion of a system under test in a manner similar to primary processor  and secondary processor  depicted and described with respect to . The CPU  and TAPU  utilize command streaming via the communication interface  in order to enable CPU  to continue operating to process test instructions while TAPU  executes TAP-related instructions for controlling the TAP of the system under test during testing.","The CPU  executes test instructions for testing a system under test. The CPU , during execution of the test instructions, detects instructions related to control of the TAP of the system under test. The CPU  propagates the TAP-related instructions to the TAPU  via the communication interface  (i.e., from CPU  to input\/output module  via the main processor interface bus , for propagation via communication interface ). The TAPU  receives the TAP-related instructions from CPU  and processes the TAP-related instructions such that the TAPU  may handle control of the TAP while CPU  continues to operate to perform other tasks (e.g., executing other testing instructions). In other words, CPU  and TAPU  cooperate during system testing such that CPU  may switch context and continue to operate to perform other tasks while TAPU  handles TAP-related instructions detected by CPU , thereby improving system testing efficiency.","In one embodiment, the TAP-related instructions detected by CPU  and processed by TAPU  are packetized by the CPU  for propagation to TAPU .","In one embodiment, the TAP-related instructions detected by CPU  and processed by TAPU  include opcodes supported by TAPU . In one such embodiment, the TAP-related instructions also may include one or more extension commands adapted for use in performing block memory copies between memory associated with the CPU  and memory associated with the TAPU  (e.g., between main memory and local test memory ).","The CPU  utilizes main memory and\/or flash memory for performing various testing functions, such as execution of test instructions, detection of TAP-related instructions, packetization of TAP-related instructions, and the like, as well as various combinations thereof. The main memory may be any suitable processor memory. The flash memory may be any suitable flash memory or any other suitable persistent memory.","The TAPU  utilizes local test memory  for performing various testing functions, such as storage of TAP-related instructions received from CPU , processing of TAP-related instructions received from CPU , and the like, as well as various combinations thereof. The local test memory  may be any suitable processor memory. In one embodiment, the local test memory  may be relatively small since it handles processing of scan chain segments of the scan chain of the system under test, rather than the entire scan chain (as may be required in an on-chip memory).","Although primarily depicted and described with respect to specific numbers and types of memory, it will be appreciated that various other memory schemes may be used for supporting the functions performed by CPU  and TCPU .","Although primarily depicted and described herein with respect to use of a co-processor architecture or an adjunct processor architecture to implement the TISA, it will be appreciated that the TISA may be implemented using any suitable processor architecture, which may include processor architectures other than the co-processor architecture or the adjunct processor architecture. Thus, the TISA processor architecture may be implemented using multiple processors in various other ways, at least some of which may include use of more than two processors for supporting the TISA.","Although primarily depicted and described herein with respect to use of the co-processor architecture or the adjunct processor architecture in order to implement the TISA architecture, it will be appreciated by one skilled in the art and informed by the teachings herein that the co-processor architecture and the adjunct processor architecture each may be used to implement other types of testing architectures (i.e., other testing architectures that do not employ TISA).","It will be appreciated that the test co-processor architecture and the test adjunct processor architecture are functionally similar in that each enables a TISA to be executed by two communicating processors. In a given application, the choice between the two architecture may be made by the designer on the basis of implementation-dependent parameters, such as available resources, costs, performances, physical constraints (integration in the same chip, in different chips and\/or boards or any combination thereof), as well as any other implementation parameter. Although primarily depicted and described herein with respect to test co-processor and test adjunct processor architectures, it will be appreciated by one skilled in the art and informed by the teachings herein that these implementation considerations will apply to any other types of testing architectures\/infrastructure.","The TISA processor architectures depicted and described herein may employ any suitable TISA for use in performing system testing.","A description of one exemplary embodiment of a TISA adapted for use with the TISA processor architectures follows. This exemplary embodiment of a TISA is an implementation of Scan Segment Level primitives depicted and described herein. In a Scan Segment Level abstraction level, the overall scan chain of the system-under-test is divided into segments, which are then used as the data atom of the algorithm. It will be appreciated that the system-under-test may be partitioned into the scan segments by the algorithm developer, which may be a human and\/or an automated tool. A more general description of the use of TISA to enable scan operations to be performed at the Scan Segment Level, i.e., a description that is independent of this exemplary TISA implementation, is provided detail hereinbelow.","The following embodiment of a TISA proposes a set of registers and instructions able to define and handle those scan segments. The following embodiment is based on a 32-bit sized TISA, but it could be adapted to any other word size (e.g., 16-bit, 64-bit, or any other suitable word size).",{"@attributes":{"id":"p-0332","num":"0343"},"figref":["FIG. 16","FIGS. 16A-16D"],"b":["1","4"]},"As depicted in , the first register set R includes the following User Accessible Data Registers:\n\n","As depicted in , the second register set R includes the following Internal Scratch Registers:\n\n","As depicted in , the third register set R includes the following Scatter\/Gather Segment Descriptions registers:\n\n","As depicted in , the fourth register set R includes the following MultiBlock Scatter\/Gather Segment Descriptions registers:\n\n","It will be appreciated that the exemplary TISA register sets may be modified in any suitable manner. For example, each of the exemplary register sets may be modified to include fewer, more, and\/or different registers. For example, the exemplary registers may be regrouped into fewer, more, and\/or different sets. For example, fewer, more, and\/or different register sets may be used. In other words, the exemplary TISA register sets may be replaced with any other TISA register set(s) suitable for use with TISA instructions sets to implement a TISA processor architecture.","The exemplary TISA may employ any suitable TISA instruction set (i.e., command dictionary) for use in performing system testing.","The exemplary TISA instruction set includes the following opcodes, which may be utilized to manipulate register sets R through R depicted and described with respect to , as well as the original ISA register sets depicted and described herein:\n\n","The exemplary TISA instruction set includes the following register modification instructions that use explicit values:\n\n","The exemplary TISA instruction set includes the following register modification instruction that use implicit values:\n\n","The exemplary TISA instruction set includes the following register preservation instructions:\n\n","The exemplary TISA instruction set includes the following logical operations on registers:\n\n","The exemplary TISA instruction set includes the following miscellaneous operation on registers:\n\n","The exemplary TISA instruction set includes the following instructions for extending support for streaming for an embodiment using the adjunct processor architecture:\n\n","The exemplary TISA instruction set includes the following values for scan state:\n\n","It will be appreciated, by one skilled in the art and informed by the teachings herein, that various other TISA implementations may be used with the TISA processor architectures depicted and described herein. For example, other TISA implementations may use fewer, more, and\/or different registers, may use fewer, more, and\/or different instruction sets, and the like, as well as various combinations thereof. In one embodiment, other TISA implementations may be utilized where different processor architectures are used, in order to provide TISA implementations better-suited to specific applications, and\/or for any other suitable reasons.","As described hereinabove, use of TISA in a JTAG architecture enables scan operations to be performed at the Scan Segments Level, which allows the definition of independently controllable \u201cscan segments\u201d inside the overall scan path, thereby providing a flexible and powerful set of primitives that can be used to define scan operations directly in the problem space and resolve the scan operations at implementation time.","In general, JTAG operations are based on the scan operation in which all bits are scanned in serially one-by-one while at the same time bits are being scanned out serially one-by-one. This means that, in order to be able to perform a scan operation, knowledge of which value is needed for each bit in the scan chain (i.e., the input and output vectors) is required. TGTs typically provide this capability for traditional structural testing by computing the required vectors from a system model obtained through description languages such as BSDL. Additionally, formats like SVF and STAPL mirror this, as they allow the user to manipulate those vectors. While testing in this manner is sufficient for structural (and other types) of testing, testing in this manner is highly inefficient for interactive setups in which there is no real need to access the whole scan chain. The inefficiency may be seen by considering an example.","For example, consider a scan chain composed of 100 instruments, each one having 16 bits. If the user needed to write 0x1234 in the registers of the 76instrument in the scan chain, the TGT would need to generate the vector for the whole scan chain (100*16=1600 bits) and send it to the TAP interface to be input into the scan chain. Similarly, if the user wanted to read the associated output, the TGT would need to receive the entire 1600 bit vector before being able to extract the desired output information. In this example, the fact that a majority of the scan bits are useless is not important, as scan efficiency is not one of the goals (rather, in this example, the goal is primarily to be able to efficiently access one particular entity of the scan chain).","This type of approach is a problem at least for the following reasons: (a) there is the computational need of handling long vectors (e.g., lots of memory transfers have a high impact on performances); (b) there is a need to store the entire vector(s) in memory (which may be a problem for long chains); (c) memory storage is not limited to data inputs and data outputs, but also includes expected data, input and output mask, and the like (thereby multiplying memory requirements which are already potentially strained just from the input and output data); and (d) the transformation from instrument-vector-instrument must be made each time (which demands computational power and time).","The Scan Segments Level abstraction level is a powerful tool for providing efficient access to individual entities, or groups of entities, of the scan chain of a system under test, without any special emphasis on scan efficiency (even if, of course, still enabling it if needed).","In one embodiment, Scan Segments Level abstraction is implemented by decomposing a scan chain into a succession of segments and defining one or more scan operations on each of the segments. The scan chain is composed of a plurality of elements, and each segment includes at least one of the elements of the scan chain. The elements may be defined at many levels of the system under test (e.g., elements may be devices, instruments, registers, segments of a register, and the like, as well as various combinations thereof), and, thus, that the segments into which the scan chain is decomposed may be defined at many levels of the system under test (e.g., segments may include one or more devices, a portion of a device(s), one or more instruments, a portion of an instrument(s), one or more registers, a portion of a register(s), one or more register segments, and the like, as well as various combinations thereof). In this manner, a segment may represent the smallest control unit of the scan chain.","In one embodiment, decomposition of a scan chain into segments may be hierarchical. For example, the scan chain may be decomposed into segments, at least some of which may be composed by sub-segments, at least some of which may be composed by sub-segments, and so forth. In this manner, the hierarchical decomposition of the scan chain may be viewed as having a tree-based structure in which a segment may be composed of other segments. In one such embodiment, the segments at the leaves of the tree may be referred to as segments (in that they represent the smallest control unit of the scan chain), which the segments located above the leaves of the tree may be referred to as super-segments. It will be appreciated that, in one embodiment, one or more of the segments of the scan chain may be composed of virtual sub-segments which are controllable, but only in a manner that is transparent to the user\/system. The hierarchical decomposition of a scan chain may be defined in any other suitable manner.","The use of segmentation enables definition of entities for types of segments and\/or types of segment combinations. An entity is a generic description of a type of target, which is valid for and may be reused for each physical instance of that type of target. For example, an entity may define a description of a device, a group of devices, a portion of a device, an instrument, a group of instruments, a portion of an instrument, and the like, as well as various combinations thereof. Thus, since a scan chain may be decomposed such that segments of the scan chain include specific elements or combinations of elements, entities may be defined for respective segments and\/or respective combinations of segments, of a scan chain. For example, where a scan chain is decomposed such that a segment includes an instrument, an entity may be defined for that type of segment (i.e., each segment including that type of instrument), such that the entity may be reused for each physical instance of that type of segment in the scan chain. Similarly, for example, where a scan chain is decomposed such that a segment includes multiple instruments, an entity may be defined for that type of segment (i.e., each segment including that type combination of instruments), such that the entity may be reused for each physical instance of that type of segment in the scan chain. This enables additional features and functions to be supported, as described below.","The use of segmentation allows an entity (i.e., a description of a type of segment under control) to be correlated with a physical protocol that is used to communicate with the entity. As a result, description languages (e.g., such as NSDL, P1687 IJTAG PDL, and the like) could be written specifically for the entity, and the connectivity description portion (e.g., the structure of the NSDL or the IJTAG HDL) would describe the ordering of the segmentation instructions.","TISA provides a reusable modularity that can be defined once for all occurrences of a particular entity type, as the TISA instructions are segment-based operations rather than model-based operations. Thus, since TISA is both modular and autonomous for the entity under test in a particular segment, TISA provides significant advantages over existing architectures.","TISA enables a direct mapping of the Test Data Register definition into a reusable and portable module that may be plugged into the execution flow at any point in the scan process, in any order that is necessary, without needing to define the entire connectivity as a static model up front as existing tools require. TISA enables integration of the port\/signal interfaces that are non-scan with the scan operations as a single solution space architecture based on a unified control flow and standard computer science techniques (providing significant advantages over solutions in which native language constructs are used to provide access to non-scan operations).","TISA enables reuse of instruction sequences for multiple instances of the same entity, thereby enabling a reduction in code storage requirements in the system. For example, a generalized function, which maps to description language functions which are called by a managing program, may be written. In this example, each of the functions are methods of native language objects that represent the entity, and there may be separate instances of these objects for each entity defined in the system, but there could be a single copy of code used to communicate with each of these instances. In this manner, the native language implementation models directly control the description language used to specify the connectivity and functionality of the circuit.","In reference to the example given above, use of Scan Segments Level abstraction would enable definition of three segments as follows: segment S including instruments  through , segment S including the instrument , and segment S including instruments  through . In this manner, access to instrument  is greatly simplified. For example, access to instrument  could be obtained by making a \u201cdummy shift\u201d (e.g., ScanBlockZero) for segment S, executing the instruction(s) for segment S (i.e., instrument ), making another dummy shift for segment S, and then terminating with an update. In such a sequence, access to segment S (i.e., to a specific instrument in the scan chain) is provided without a need of any knowledge of segment S or segment S apart from their length. It will be appreciated that this is merely one example, and, thus, that other decompositions of the 100 instrument-long chains are possible to enable access to other instruments or instrument groups.",{"@attributes":{"id":"p-0361","num":"0446"},"figref":"FIG. 17"},"The exemplary SUT  includes four devices -(collectively, devices ; and denoted in  as Device , Device , Device , and Device , respectively). The devices  are arranged serially within SUT  to form a scan chain . The scan chain  is as follows: the TDI of the TAP is connected to the input port of device , the output port of device is connected to the input port of device , the output port of device is connected to the input port of device , the output port of device is connected to the input port of device , and the output port of device is connected to the TDO of the TAP.","In the exemplary SUT , each of the devices  includes (1) an input de-multiplexer providing inputs to a test instruction register (TIR) and a test data register (TDR), and (2) an output multiplexer for collecting outputs from the TIR and the TDR. The TIR and TDR of each device  are parallel registers. The device includes one additional TDR, such that the input de-multiplexer provides inputs to one TIR and two TDRs and collects outputs from the one TIR and the two TDRs, where the one TIR and two TDRs are all in parallel. The TIRs and TDRs each are depicted as serial shift registers, each including nine associated elements (e.g., flip-flops). In this manner, (a) the TIRs form one scan chain (denoted as an test instruction scan chain) that includes thirty-six serial elements and (b) the TDRs form another scan chain (denoted as a test data scan chain) that includes forty-five total elements and thirty-six serial elements (i.e., because the two TDRs of device are in parallel).","In the exemplary SUT , the test instruction scan chain has been decomposed into four segments follows: a first segment SI which includes the nine elements of the TIR of device , a second segment SI which includes the nine elements of the TIR of device , a third segment SI which includes the nine elements of the TIR of device , and a fourth segment SI which includes the nine elements of the TIR of device . In this manner, the testing system may access any of the TIRs of SUT , individually or in combination, with minimal knowledge of the other TIRs of SUT  (other than the number of elements of which they are composed).","In the exemplary SUT , the test data scan chain has been decomposed into six serial segments (seven total segments) as follows: a first segment SD that includes the nine elements of the TDR of device ; a second segment SD that includes the nine elements of the TDR of device ; a third segment SD that includes either the nine elements of the first TDR of device (denoted as sub-segment SD.) or the nine elements of the second TDR of device (denoted as sub-segment SD.), where these are counted as separate segments for purposes of counting the total number of segments; and a fourth segment which is further decomposed into three serial sub-segments as follows: a first sub-segment that includes the first three elements of the TDR of device (denoted as sub-segment SD.), a second sub-segment that includes the next four elements of the TDR of device (denoted as sub-segment SD.), and a third sub-segment that includes the last two elements of the TDR of device (denoted as sub-segment SD.). In this manner, the testing system may access any of the TDRs of SUT  (or even sub-portions of the TDR of device ), individually or in combination, with minimal knowledge of the other TDRs of SUT  (other than the number of elements of which they are composed).","It will be appreciated that SUT  of  is merely one example of the manner in which the scan chain(s) of a system under test may be decomposed for use in providing Scan Segments Level abstraction. Although depicted and described herein with respect to specific types, numbers, and arrangements of elements, components, and the like, it will be appreciated that a system under test for which a scan chain(s) is decomposed may be include various other types, numbers, and\/or arrangements of elements, components, and the like.","As described herein, decomposition of the scan chain of a system under test enables scan operations to be defined on the segments, thereby improving testing efficiency. A method, according to one embodiment, for generating a set of instructions including scan operations for segments of a decomposed scan chain is depicted and described herein with respect to .","A more detailed example of scan decomposition and generation of scan segment operations is provided follows.","As a general example, consider a scan chain that includes three boards where each board includes a segment (denoted as segments A, B, and C associated with a first board, a second board, and a third board, respectively). In this example, where the scan segments are hierarchical, the segment A on the first board may be composed of a plurality of sub-segments (e.g., sub-segments Athrough A), the segment B on the second board may be composed of a plurality of sub-segments (e.g., sub-segments Bthrough B), and\/or the segment C on the third board may be composed of a plurality of sub-segments (e.g., sub-segments Cthrough C).","As a more specific example, following the application and the SUT, a segment could be: one or more registers inside an instrument, an instrument, a cluster of registers, one or more boards, and the like, as well as various combinations thereof.","The overall scan operation is therefore decomposed in a series of segment scan operations. As a result, all that is required in order to obtain the final scan chain operation is a series of simple atomic operations. Thus, the embodiments of Scan Segments Level abstraction, while not exclusively limited to, are especially effective in implementations in which the atomic test operations are treated like processor operations (e.g., such as in the various TISA implementations depicted and described herein, or in any other similar implementations in which atomic test operations are treated like processor operations).","In such embodiments of Scan Segments Level abstraction, the actual implementation of the Scan Segments Level scan operations may require that one or more technological constraints linked to JTAG be addressed. For example, constraints such as the need to define the state of the TAP machine and the risk of using the Pause-DR state (not always implemented), among others, may need to be addressed.","In order to identify instrument\/segment outputs in the output bitstream received via the scan chain, based on the position of the instrument\/segment in the scan chain, the scan chain may be treated as a first-in-first-out (FIFO) system (given its serial nature) such that the first segment that is scanned in is also the first segment that is scanned out (as it is closest to the end of the scan chain).","In order to make the SUT \u201cexperience\u201d the sequence of scan segment operations like a single scan operation, the TCK may be frozen between segment operations. As all elements inside the scan chain are synchronous, the effect of freezing TCK in this manner is that the scan chain is frozen together with TCK.","The use of Scan Segments Level in a TISA-based testing system may be better understood by way of a few examples, In the examples that follow, assume that a system under test (SUT) is composed of three segments (denoted as A, B, and C, in that order), and that a user needs to write a value V inside of segment B.","As a first example, assume that the three segments of the system (A, B, and C) are implemented inside the same JTAG device. In this first example, once the three segments are defined in memory, the TISA operations would become:\n\n","With respect to the first example, keeping the TAP Finite State Machine (FSM) in the ShiftDR state ensures that there is no update on the scan chain. This may be seen from the first example, in which keeping the TAP FSM in the ShiftDR state from step (i) to step (ix) ensures that there is no update on the scan chain, given that the UpdateDR State will be reached only once leaving ShiftDR.","Further with respect to the first example, the scan clock TCK is active only during the scan operations (i.e., steps (iii), (vi), and (ix)), and is frozen in the remaining states. The effect is that the SUT, from the point of view of the SUT based on operations synchronous with TCK, will see steps (iii), (vi), and (ix) as a continuous bitstream.","Further with respect to the first example, the \u201cbypass sequence\u201d is a property of the scan segment, and can be, for instance, a given sequence (all zeros, all ones, or any other suitable sequence), or \u201cdon't care\u201d, where it is up to the TGT to decide such sequence.","As a second example, assume that the three segments of the system (A, B, and C) are implemented on different JTAG devices (in one or more cards). In this second example, once the three segments are defined in memory, the TISA operations would become:\n\n","In comparing the first example and the second example, it will be understood that the additional complexity associated with the second example comes from the need to use the Instruction Register (IR) of each JTAG device to select\/deselect the segments. In that case, unused segments are directly taken out of the chain by putting the related JTAG device in the BYPASS mode of the 1149.1 standard (as indicated in steps (iii) and (xvii) of the second example).","It will be appreciated that all compositions of the above two examples are possible, with any number of segments defined on one or more JTAG devices. It will be further appreciated that the above-two examples are merely examples provided for the purpose of illustrating use of the Scan Segments Level for testing a system under test, and, thus, that embodiments in which the Scan Segments Level is used for testing a system under test are not intended to be limited by these examples.","In such embodiments, the actual sequence of TISA instructions can have multiple origins, including one or more of the following: (1) the TISA instructions may be statically computed by the TGT, in which case, each time the user wants to access a segment, the entire chain must be scanned (it will be appreciated that, while this solution is not optimized for scan time, it can be useful for embedded systems with limited computational resources and little or no time constraints); (2) the TISA instructions may be issued by a software scheduler, which receives access requests and composes them into scan operations; and\/or (3) the TISA instructions may be issued by a hardware scheduler (e.g., such as, but not limited to, what is done for instruction reordering and bypass in some high-performance processors). It will be appreciated that TISA instructions associated with Scan Segments Level control may be issued in any other suitable way, which may include a combination of the methods described above and\/or one or more other suitable methods which may be used in place of or in addition to one or more of the methods described above.","The Scan Segments Level abstraction level is a powerful tool for handling dynamic topologies, such as the ones proposed by the IEEE P1687 standard and other dynamic topologies. If a section of the scan chain can be taken in and out the active scan path (e.g., using an SIB cell proposed by the IEEE P1687 standard or any other suitable hierarchy-enabling component(s)), that section can be marked as one (or more) segments. The testing scheduler then has knowledge, from the system state, as to whether or not this segment(s) is active, and, therefore, if the segment should be included in the TISA instruction scheduling. It will be appreciated by those skilled in the art and informed by the teachings herein that this principle also may be used for other dynamic elements, such as hot-swap boards (e.g., by detecting their presence from a status register) or any other suitable dynamic elements.",{"@attributes":{"id":"p-0385","num":"0497"},"figref":"FIG. 18"},"Although primarily depicted and described herein as being performed serially, at least a portion of the steps of method  may be performed contemporaneously, or in a different order than depicted and described with respect to .","At step , method  begins.","At step , the scan chain is decomposed into a plurality of segments. The scan chain is composed of a plurality of elements, and each segment includes at least one of the elements of the scan chain. The scan chain may be decomposed into segments in any suitable manner, as described hereinabove. As described herein, decomposition of the scan chain into segments may be applied anywhere in the development flow (e.g., by the test developer, by the test generation tool, by an embedded circuit model, and the like).","At step , a set of instructions is generated. The set of instructions includes processor instructions associated with an ISA and test instructions for testing the portion of the system under test. The test instructions include, for each of the segments of the scan chain, at least one scan operation to be performed on the segment. The test instructions may be any type of test instructions, such as conventional test instructions, test instructions of a TISA, and the like, and, thus, may be generated in any suitable manner. The set of instructions may be generated in any suitable manner (e.g., in a manner the same as or similar to as depicted and described hereinabove respect to","At step , the set of instructions is executed for testing the portion of the system under test. The set of instructions may be executed in any suitable manner, which may depend on the type of instructions of the set of instructions.","At step , method  ends.","Although primarily depicted and described herein with respect to embodiments in which embodiments of TISA are used to enable scan operations to be performed at the Scan Segments Level, it will be appreciated that one or more of the Scan Segments Level embodiments depicted and described herein also may be provided in environments using TISA-like instructions architectures, non-TISA instruction architectures and\/or non-TISA testing environment implementations, and the like.","Although references are made herein to \u201cthe TISA\u201d for purposes of describing the enhanced system testing capabilities enabled by exemplary embodiments of TISAs which may be formed and utilized as depicted and described herein, it will be appreciated that many different TISAs may be formed depending on various factors, such as one or more of the ISA of the processor for which the TISA is formed, characteristics of the SUT for which the TISA is formed, characteristics of the test algorithm the TISA is supposed to execute, and the like, as well as various combinations thereof. Thus, references made herein to \u201cthe TISA\u201d also may be read more generally as \u201ca TISA\u201d in that many different types of TISAs may be formed.",{"@attributes":{"id":"p-0394","num":"0506"},"figref":["FIG. 19","FIG. 19"],"b":["1900","1902","1904","1905","1906"]},"It should be noted that system testing functions depicted and described herein may be implemented in software and\/or in a combination of software and hardware, e.g., using a general purpose computer, one or more application specific integrated circuits (ASIC), and\/or any other hardware equivalents. In one embodiment, system testing process  can be loaded into memory  and executed by processor  to implement and\/or support implementation of at least a portion of the system testing functions described hereinabove. Thus, system testing process  (including associated data structures) can be stored on a computer readable storage medium or carrier, e.g., RAM memory, magnetic or optical drive or diskette, and the like.","It is contemplated that some of the steps discussed herein as software methods may be implemented within hardware, for example, as circuitry that cooperates with the processor to perform various method steps. Portions of the functions\/elements described herein may be implemented as a computer program product wherein computer instructions, when processed by a computer, adapt the operation of the computer such that the methods and\/or techniques described herein are invoked or otherwise provided. Instructions for invoking the inventive methods may be stored in fixed or removable media, transmitted via a data stream in a broadcast or other signal bearing medium, and\/or stored within a memory within a computing device operating according to the instructions.","Although various embodiments which incorporate the teachings of the present invention have been shown and described in detail herein, those skilled in the art can readily devise many other varied embodiments that still incorporate these teachings."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The teachings presented herein can be readily understood by considering the following detailed description in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 4A-4E"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 8","FIG. 5A"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
