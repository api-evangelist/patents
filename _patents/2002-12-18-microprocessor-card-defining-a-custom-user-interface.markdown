---
title: Microprocessor card defining a custom user interface
abstract: An electronic card () configured to be read by a reading device () is disclosed. The card () comprising a card portion () having a surface () onto which are formed a plurality of user interface elements () and electronic apparatus () attached to the card portion (). The apparatus () comprising a memory () in which are retained a plurality of data strings. At least one of the data strings is associated with a corresponding one of the user interface elements (). The apparatus () also comprises a processor means () coupled to the memory means () and communication means () for coupling the processor means () to the reading device (). The processor means () is configured to relate reading signals generated from a selection of at least one of the elements () and received via the communication means () with at least one of the retained data strings. The retained data strings are inaccessible to the reading device ().
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07802728&OS=07802728&RS=07802728
owner: Canon Information Systems Research Australia Pty Ltd
number: 07802728
owner_city: 
owner_country: AU
publication_date: 20021218
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD OF THE INVENTION","BACKGROUND ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION INCLUDING BEST MODE","1.0 Smart Card Interface System Overview","1.1 Smart Cards","1.2 Smart Card Reader","1.3 Hardware Architecture","1.4 Programming the Smart Card","1.5 Software Architecture Layout","1.6 Smart Card Data Format","1.6.1 Card Header","1.6.2 Card Flags","1.6.3 Objects","1.6.3.1 User Interface Element Objects","1.6.3.2 Card Data","1.6.3.4 Fixed Length Data","1.6.3.5 Reader Insert","1.6.3.6 No Operation","1.6.3.7 No Operation","One Byte","1.7 Reader Protocol","1.7.1 Message Types","1.7.2 Data Formats","1.7.3 Message Header","1.7.3.1 Simple Messages","1.7.3.2 MOVE Messages","1.7.3.3 PRESS and RELEASE Messages","1.7.7 INSERT Messages","1.8 Example","2.0 CPU Card Operation","2.1 Communications","2.2 Operating System","2.3 Operating Procedure","2.3.1 CPU Card Operating Modes","2.3.1.1 Standard Input Mode","2.3.1.2 Buffered Input Mode","2.3.1.3 Output Buffers","2.3.1.4 Pass-Code Buffers","2.4 Additional Software Interfaces","2.4.1 International Standards Organisation (ISO) File System","2.4.1.1 File Control Information","2.4.1.2 Select File","2.4.1.3 Read Binary","2.4.1.4 Write Binary and Update Binary","2.4.1.5 Erase Binary","2.4.2 Security Architecture","2.4.2.1 Get Challenge","2.4.2.2 External Authenticate","2.4.2.3 Example","2.5 Instruction Invocation","2.5.1 Main Process","2.5.2 Initialisation Process","2.5.3 Proprietary Instruction Process","2.5.4 ISO Instruction Process","2.6 Process Coordinate Process","2.6.1 User Interface Element Handler Process","2.6.2 Buffered Input User Interface Element Handler","2.6.3 Buffer OK Process","2.6.4 Pass-Code Checker Process","2.6.5 Buffer Cancel Process","2.6.6 Buffer Backspace Process","2.6.7 Buffer Append Process","2.6.8 Text User Interface Element Process","2.6.9 Buffered User Interface Element Process","2.6.10 Delegator User Interface Element Process","2.6.11 Output Object Data Process","2.6.12 Save State Process","2.6.12 Restore State Process","2.6.13 Select File Process","2.6.14 Read Binary Process","2.6.15 Write Binary Process","2.6.16 Erase Binary Process","2.6.17 Get Challenge Instruction","2.6.17.1 Get Challenge","2.6.17.2 External Authenticate"],"p":["The present invention relates generally to a control card or smart card for use with a reader device and, in particular, to a microprocessor or central processing unit (CPU) smart card defining a custom user interface. The invention also relates to a computer program product including a computer readable medium having recorded thereon a computer program for a microprocessor card or CPU smart card defining a custom user interface.","Control cards, such as smart cards, as known in the relevant art are often used for security purposes such as user authentication. Most conventional control cards include some form of readable storage means such as a magnetic strip, an optical code (e.g. a bar code) or an on-board memory chip, for storing data (e.g. a personal identification number) associated with the card. Such control cards can be generically referred to as memory cards. However, control cards including a storage means in the form of an on-board memory chip are generally referred to as \u2018smart cards\u2019. The data stored in the storage means is generally read by some form of terminal device, which includes a magnetic read head, for example.","One known method for authenticating a user and allowing the user access to amenities and\/or services is by requesting that the user present a memory card at a point of access and then enter a personal identification number into an input device. The input device compares the entered personal identification number with data stored in the memory of the memory card to determine the validity of the entered personal identification number. Such a method suffers from the disadvantage that the input device is made aware of the configuration of the personal identification number and may be used to copy and\/or reuse the personal identification number. Since users often utilise the same personal identification number to gain access to a variety of unrelated amenities and\/or services, the security of these amenities and\/or services can be compromised in one action through the use of an insecure input device. Thus, the input device used for reading a smart card must be secure so as not to allow a user's personal identification number to be exposed or otherwise used without the consent of the user.","Some smart cards include a microprocessor integrally formed within the smart card. These smart cards are generally referred to as microprocessor or central processing unit (CPU) cards and some of these CPU cards are configured to address the problem of non-secure input and terminal devices by incorporating an input device onto the smart card in the form of a touch sensitive keypad on at least one surface of the card.","There are several existing smart card systems, which utilise CPU smart cards including a keypad. One of these existing smart card systems utilises a self-contained smart card including a keypad, a display, a memory and means to enter and verify a personal identification number. In order to gain access to amenities and\/or services, a user presents the CPU card at a point of entry and then enters a personal identification number using the built-in keypad. The personal identification number is verified by a verification means associated with the point of access and the user is allowed or denied access to the amenity and\/or service depending on the result of the verification process.","Another of these existing smart card systems includes a self-contained smart card having a power source, a keypad, a display, a memory and a means to enter identification information. Still another existing smart card system utilises a self-contained CPU card including a multi-functional and programmable keypad and display, which are used to enter information. These other smart card systems work in a similar manner to the smart card system described above.","Still another existing CPU smart card system allows a personal identification number to be entered into a CPU card, which includes a touch sensitive keypad, when the card is inserted into a smart card reader. The reader includes an overlay which can be positioned over the surface of the smart card to provide user interface elements related to the keypad. The overlay is configured to allow a user to transfer pressure onto the surface of the CPU card, adjacent to one or more of the user interface elements, in order to select a function.","However, the above mentioned keypad CPU cards require specialised integrated circuit hardware in order to detect pressure on certain points which rules out the use of most conventional CPU smart cards with systems using these keypad CPU cards. Further, CPU cards including an integrally formed keypad generally require discrete user interface elements in discrete positions on the card which limits the function of such cards. Still further, the manufacture of such an integrated circuit card, and in particular the integrated circuit hardware associated with the card, is relatively difficult and involves a very high cost relative to most conventional smart cards. These limitations of keypad CPU cards generally render the cards unsuitable for wide spread usage.","One existing CPU card with a user interface printed on at least one surface of the card includes a data structure describing the interface, where the data structure is stored in a memory integrally formed within the CPU card. The reader device used with this existing CPU card, includes a transparent touch panel positioned above the CPU card so that user interface elements printed on a surface of the smart card are visible underneath the transparent touch panel. The reader device is configured to determine the position of a touch on the transparent panel and then read data structure information stored within a memory of the card to determine which user interface elements have been pressed. The reader device then sends a data string associated with the selected user interface elements to a remote application. However, this reader device suffers from similar disadvantages to those discussed above, in that data stored in the memory of the card is read by the reader and so is not kept confidential. Therefore, the card cannot be used with an untrusted reader.","It is an object of the present invention to substantially overcome, or at least ameliorate, one or more disadvantages of existing arrangements.","According to one aspect of the present invention there is provided an electronic card configured to be read by a reading device, said card comprising:","a card portion having a surface onto which are formed a plurality of user interface elements; and","electronic apparatus attached to said card portion, said apparatus comprising:\n\n","According to another aspect of the present invention there is provided a method of mapping one of a plurality of data strings retained within a memory of an electronic card with reading signals generated by a reading device configured to read said card, said card comprising a card portion having a surface onto which are formed a plurality of user interface elements, at least one of said data strings of said memory being associated with a corresponding one of said user interface elements, said memory being coupled to a processor means, said processor means being coupled to a communication means for coupling said processor means to said reading device, said method comprising the steps of:","transmitting said reading signals, generated from a selection of at least one of said elements, from said reading device to said processor means via said communication means; and","mapping said reading signals to at least one of said retained data strings, wherein said processor means performs the mapping of said reading signals such that said at least one retained data stream is inaccessible to said reading device.","According to still another aspect of the present invention there is provided a computer program for mapping one of a plurality of data strings retained within a memory of an electronic card with reading signals generated by a reading device configured to read said card, said card comprising a card portion having a surface onto which are formed a plurality of user interface elements, at least one of said data strings of said memory being associated with a corresponding one of said user interface elements, said memory being coupled to a processor means, said processor means being coupled to a communication means for coupling said processor means to said reading device, said program comprising:","code for transmitting said reading signals, generated from a selection of at least one of said elements, from said reading device to said processor means via said communication means; and","code for mapping said reading signals to at least one of said retained data strings, wherein said processor means performs the mapping of said reading signals such that said at least one retained data stream is inaccessible to said reading device.","Other aspects of the invention are also disclosed.","Where reference is made in any one or more of the accompanying drawings to sub-steps and\/or features, which have the same reference numerals, those sub-steps and\/or features have for the purposes of this description the same function(s) or operation(s), unless the contrary intention appears.","Excepting where explicitly distinguished, in the following description, the term \u201cdata string\u201d means \u2018a sequence of bits (i.e. \u20181\u2019 or \u20180\u2019)\u2019 and can include American Standard Code for Information Interchange (ASCII) data, floating point data, and binary representations of integer values, for example.","The embodiments disclosed herein have been developed primarily for use with automatic tellers, remote control and network access systems, and will be described hereinafter with reference to these and other applications. The embodiments disclosed herein can be used to access services such as home shopping, home-banking, video-on-demand, interactive applications such as games and interactive trading cards, and information access such as city guides, television program guides and educational material. However, it will be appreciated that the invention is not limited to these fields of use.","For ease of explanation the following description has been divided into Sections 1.0 to 2.6, each section having associated subsections.",{"@attributes":{"id":"p-0082","num":"0084"},"figref":"FIG. 1(","i":"a","b":["100","112","114","116","100","114","120","122","124","128","130","116","114","126","116","100","100","100","219","100"]},"As seen in ), the front face  of the smart card A may be formed by an adhesive label  upon which is printed the user interface in the form of the user interface elements , in this case corresponding to the \u201cEnd Button\u201d and the Right arrow \u201cbutton\u201d of the directional controller . The label  is affixed to the planar substrate . A home user can print a suitable label for use with a particular smart card A by using a printer. Alternatively, the user interface elements  can be printed directly onto the planar substrate  or separate adhesive labels can be used for each of the user interface elements .","As also seen in ), the smart card A includes storage means in the form of an on-board memory chip  for storing data associated with the user interface elements . The smart card A having a memory chip  as described above is generally referred to as a \u201cmemory card\u201d. Thus, the smart card A will hereinafter be referred to as the memory card A. The memory card A also includes electrical data contacts  connected to the memory chip  and via which reading of the memory chip  and writing to the memory chip  may be performed.","Alternatively, in other forms of the memory card A, the memory chip  can be replaced by storage means in the form of machine-readable indicia such as an optical code (e.g. a barcode) printed on a reverse face (not shown) of the memory card. A.","Memory cards such as the memory card A can be utilised in applications where strong security of the smart card A and data stored in the chip  of the smart card A, is not required. The memory card A can also be used in applications where it is desired to maintain the cost of manufacturing the smart card A to a minimum. Such smart cards can be used for example, where the memory card A is given away to promote a service and\/or to provide access to the service. The memory card A can also be used as a membership card, which provides access to a specific service.",{"@attributes":{"id":"p-0087","num":"0089"},"figref":"FIG. 1(","i":"b","b":["100","152","154","156","100","154","160","162","164","166","168","156","154","158"]},"As seen in ), the front face  of the smart card B is formed by an adhesive label  affixed to the planar substrate  in a similar manner to the memory card A. Again, a user interface in the form of user interface elements , in this case corresponding to the \u201cnumber 3\u201d, \u201cnumber 6\u201d and \u201cnumber 9\u201d buttons of the numerical keypad  and the \u201cbackspace button\u201d , is printed on the adhesive label .","As also seen in ), the smart card B includes a microprocessor  having an integrally formed central processing unit (CPU)  and storage means . The storage means  generally includes volatile random access memory (RAM) (not shown) and non-volatile flash (ROM) memory (not shown), and can be used to store data associated with the user interface elements , application software code associated with the smart card B and\/or information (e.g. a personal identification number) associated with the user and\/or manufacturer of the smart card B. The smart card B will hereinafter be referred to as the CPU card B. The CPU card B also includes electrical data contacts  connected to the microprocessor  and which perform a similar role to the contacts  of ). In particular, the electrical data contacts  can be used to send instructions to the microprocessor  and to receive data resulting from the execution of those instructions on the microprocessor .","CPU cards such as the CPU card B can be utilised in applications where enhanced user authentication and\/or higher levels of security of the CPU card B and data stored in the storage means , is required.","It will be appreciated by a person skilled in the relevant art, that the user interfaces in the form of the user interface elements  and  can be interchanged for the smart cards A and B. Further, the user interfaces able to be printed by a user and\/or manufacturer for the smart cards A and B can take many forms. Memory cards such as the memory card A and CPU cards such as the CPU card B, having a user interface formed on one surface of the card can be referred to as \u2018User Interface Cards. However, excepting where explicitly distinguished, in the following description, the memory card A and the CPU card B will be generically referred to as the smart card .",{"@attributes":{"id":"p-0092","num":"0094"},"figref":["FIG. 3","FIG. 3"],"b":["300","100","100","218","278","100","100","307","300","300","301","304","100","306","310","100","306","308","307","304","308","308"]},"In use, a smart card  is inserted by a user into the smart card receptacle , through the access opening , as shown in . When the smart card  is fully inserted into the reader , the touch panel  fully covers the upper face ,  of the smart card . The viewing area  preferably has substantially the same dimensions as the upper face ,  of the smart card  such that the upper face ,  is, for all intents and purposes, fully visible within the viewing area  through the touch panel . In this position, the data contacts ,  of the card  engage the exposed contacts  so that circuitry (not shown) within the reader  can communicate with the memory chip  or microprocessor  of the card .","When the card  is fully inserted into the reader , a user can press areas of the touch panel , as shown in , overlying the user interface elements , . For the memory card A, the reader  deduces which of the user interface elements  the user has selected by sensing the pressure on the touch panel  and referring to the data stored in the memory chip . For example, if the user places pressure on the touch panel  adjacent the \u201ckick button\u201d , the reader  is configured to assess the position at which the pressure was applied, refer to the stored data, and determine that the \u201ckick button\u201d  was selected.","In contrast, for the CPU card B, the CPU  determines which of the user interface elements  the user has selected by processing coordinates received from the reader  upon the reader  sensing pressure on the touch panel , and then the CPU  referring to the data stored in the storage means  of the microprocessor . In this case, it is not necessary for the reader  to be able to read and to be made aware of the data stored in the storage means  of the microprocessor . The operation of the CPU card B in relation to the reader  will be explained in more detail in Sections 2.0 to 2.6 below.","Information resulting from a user selecting one of the user interface elements ,  can be used to control an external device, for example, an associated automatic teller machine (of conventional construction and not shown). It will be appreciated from above that the user interface elements ,  are not, in fact buttons. Rather, the user interface elements  are user selectable features which, by virtue of their corresponding association with the data stored in the memory chip  or storage means , and the function of the touch panel , operate to emulate buttons traditionally associated with remote control devices.","In one advantageous implementation, the reader  includes a transmitter (of conventional type and not shown), such as an infra-red (IR) transmitter or radio frequency (RF) transmitter, for transmitting information in relation to user interface elements ,  selected by the user. In this case, upon selection of one of the user interface elements , , the reader  causes information related to the selection to be transmitted to a remote console (not shown in ) where a corresponding infra-red or radio frequency remote module can detect and decode the information for use in controlling some function, such as a banking application executing on the automatic teller machine discussed above.","Any suitable transmission method can be used to communicate information from the reader  to a remote module, including direct hard wiring. Moreover, the remote module itself can incorporate a transmitter, and the reader  a receiver for communication in an opposite direction to that already described. The communication from the remote module to the reader  can include, for example, handshaking data, setup information, or any other form of information desired to be transferred from the remote module to the reader .",{"@attributes":{"id":"p-0099","num":"0101"},"figref":"FIG. 10","b":["300","300","1044","300","300","1044","1047","1046","1044","1045","1044","1048","1043","1044","1045","1053","1050","1045","1044","1051"]},"Infra-red (IR) communications, as discussed above, can be implemented using two circuits connected to the microcontroller , an infra-red transmitter (TX)  for infra-red transmission and an infra-red remote module (RX)  for infra-red reception. The touch panel  of the reader  communicates with the microcontroller  via a touch panel interface  and the electrical contacts .","An in-system-programming interface  can also be connected to the microcontroller , to enable programming of the microcontroller  with firmware by way of the microprocessor flash memory .",{"@attributes":{"id":"p-0102","num":"0104"},"figref":["FIG. 6(","FIG. 7"],"i":"a","b":["600","600","300","700","603","654","700","300","700","701","702","704","703"]},"The system A includes the smart card  which is programmable and can be created or customised by a third party, who may be a party other than the manufacturer of the smart card  and\/or the card reader . The third party can be the ultimate user of the smart card  itself, or may be an intermediary between the manufacturer and user. In the system A of ), the smart card  can be programmed and customised for one touch operation to communicate with the computer  and obtain a service over a computer network , such as the Internet, coupled to the computer . The computer  operates to interpret signals sent via the communications cable  from the reader , according to a specific protocol, which will be described below. The computer  performs the selected function according to touched user interface elements ,  and can be configured to communicate data over the network . In this manner, the computer  can permit access to applications and\/or data stored on: remote server computers ,  and appropriate reproduction on the display device , by way of user manipulation of the reader  and card .",{"@attributes":{"id":"p-0104","num":"0106"},"figref":["FIG. 6(","FIG. 8"],"i":"b","b":["600","600","300","601","616","601","612","300","601","114","154","616","601","612","700","720","700","114","154","601","616","601"]},"In one application of the system B, the smart card  can be programmed for obtaining a service either remotely or locally. For instance, the smart card  can be programmed to retrieve an application and\/or data stored on remote server computers , , via the network , and to load the application or data on to the set top box . The latter smart card can be alternatively programmed to obtain a service from the loaded application on the set top box .","Excepting where explicitly distinguished, the systems A and B of ) and () will be hereinafter generically referred to as the system .",{"@attributes":{"id":"p-0107","num":"0109"},"figref":"FIG. 7","b":["700","600","100","700","702","704","703","701","716","702","720","721","716"]},"The computer module  typically includes at least one central processing unit (CPU) , a memory unit , for example formed from semiconductor random access memory (RAM) and read only memory (ROM), input\/output (I\/O) interfaces including a video interface , and an I\/O interface  for the keyboard  and mouse , a write device , and an interface  for the modem . The I\/O interface  also includes the IR transceiver  connected to the I\/O interface  for communicating directly with the reader . A storage device  is provided and typically includes a hard disk drive  and a floppy disk drive . A magnetic tape drive (not illustrated) is also able to be used. A CD-ROM drive  is typically provided as a non-volatile source of data. The components  to  of the computer module , typically communicate via an interconnected bus  and in a manner, which results in a conventional mode of operation of the computer system  known to those in the relevant art. Examples of computers on which the arrangement described herein can be practised include IBM-computers and compatibles, Sun Sparcstations or alike computer system evolved therefrom.","Typically, the software programs such as applications of the system  are resident on the hard disk drive  and read and controlled in their execution by the CPU . Intermediate storage of the software application programs and any data fetched from the network  may be accomplished using the semiconductor memory , possibly in concert with the hard disk drive . In some instances, the application programs can be supplied to the user encoded on a CD-ROM or floppy disk and read via the corresponding drive  or , or alternatively may be read by the user from the network  via the modem device . Still further, the software can also be loaded into the computer system  from other computer readable medium including magnetic tape, ROM or integrated circuits, a magneto-optical disk, a radio or infra-red transmission channel between the computer module  and another device, a computer readable card such as a smart card, a computer PCMCIA card, and the Internet and Intranets including email transmissions and information recorded on Websites and the like. The foregoing is merely exemplary of relevant computer readable media. Other computer readable media are able to be practised without departing from the scope of the invention defined by the appended claims.",{"@attributes":{"id":"p-0110","num":"0112"},"figref":"FIG. 8","b":["601","600","612","300","601","702","601","805","806","813","616","815","808","612","817","720","805","806","813","815","817","601","804","300","720","806","709"]},"As described above, the smart card  is programmable and can be created or customised by a third party. For example, with the system , the smart card  can be programmed and customised for one touch operation to communicate with the set-top box  and\/or computer  and obtain a service over the network . The smart card  can be programmed by means of the write device  coupled to the I\/O interface  of the computer module . The write device  has the capability of writing data to the memory chip  on the memory card A or the storage means  of the microprocessor  for the CPU card B. Preferably, data is not able to be written to the storage means  unless a value, calculated in accordance with a predetermined electronic key, is first presented to the microprocessor . Depending upon the specific implementation the write device  may also be configured to print graphics on to the front surface ,  of the smart card  using image production software application programs. The write device  may also have a function for reading data from the smart card .","The write device can be configured such that the user can insert the smart card  into the write device  and then enter the required data. A software application can then write the data entered by the user to the memory of the smart card  via the write device . If the stored data is encoded for optical decoding such as in the case of a barcode memory card, the write device  can print the encoded data onto the memory card A.","For the CPU card B, the microprocessor  can be constructed so that once programmed in the manner described, the contents cannot thereafter be casually read.",{"@attributes":{"id":"p-0114","num":"0116"},"figref":["FIG. 9","FIG. 9"],"b":["900","600","900","920","920","901","906","903","911","904","900","920","901","906","903","601","700","650","652","601","908","908","901","903","601","908","900","911","911","903","904"]},"In this form, the architecture  can be physically separated into six distinct parts , , , ,  and  as shown by the dashed lines in , each of which can be run on physically separate computing devices. Alternatively, the display  can be a device with little or no computing capacity. Communication between each of the parts of the system  can be executed using Transport Control Protocol\/Internet Protocol (TCP\/IP) streams. Alternatively, each of the parts , , , ,  and  can be run on the same machine.","In the system A of ), all of the process components , , ,  and  can be run on the computer . The event manager , the launcher  and display manager  are preferably integrated into one executable program which is stored in the hard disk  of the computer  and can be read and controlled in its execution by the CPU . The directory service  may run on the same computer  or on a different computer (e.g. server ) connected to the computer  via the network .","In the system B of ), all of components , , ,  and  can run from the set-top-box . In this instance, the components , , ,  and  can be stored in the memory  of the set top box  and can be read and controlled in their execution by the CPU . The directory service  can run on one of the computers ,  or  and can be stored in the hard disk drive  of the computer , for example, and be read and controlled in its execution by the CPU . Alternatively, the directory service  can be run on the set top box  or its function executed by the launcher .","In a further alternative arrangement, if the set-top-box  is not powerful enough to run the system  locally, only the I\/O daemon  need run on the set-top-box  and the remainder of the architecture  (i.e. process components , , ,  and ) can be run remotely on the other servers (, ) which can be accessed via the network . In this instance, the I\/O daemon  can be stored in the memory  of the set top box  and can be read and controlled in its execution by the CPU . Again, the functional parts of such a system can be divided as shown in . In this instance, the display  corresponds to an audio-visual output device (e.g. a television set).","The I\/O daemon  is a process component that converts datagrams received from the reader  into a TCP\/IP stream that can be sent to the event manager  and vice versa (e.g. when using a two-way protocol). The event manager  is configured to gather all events that are generated by the reader  and relayed by the I\/O daemon . These events are then redistributed to the various process components , ,  and  and running applications. The event manager  is also configured to check that an event has a valid header and correct data length. An \u201cevent\u201d in this regard represents a single data transaction from the I\/O daemon  or the launcher  or applications . The master launcher  can be used to start the launcher  corresponding to each of the event managers  if more than one event manager is running on the system . The launcher  is an application that starts other applications for a specific event manager . The launcher  starts and ends applications and can also start and end sessions. The launcher  also informs the event manager  when applications are starting and ending, and informs the applications  when they are gaining or losing focus, or when they need to exit. The display manager  selects which smart card application  is currently able to display output on the display device  (i.e. the \u201cfront\u201d application).","The directory service  is configured to translate service identifiers that are stored on smart cards , into resource locators (e.g. a URL) that indicate the location of the services or the location of an application associated with a service. The directory service  is also configured to translate optional service data. The directory service  allows the launcher  associated with a particular card  to decide what to do with a resource locator, for example, download and run the associated application  or load the resource locator into a browser application.","The applications  associated with a particular smart card  can be started by the launcher  associated with that smart card  in response to a selection of one of the user interface elements ,  of a corresponding smart card . Each application  can be a member of one or more application service groups. An application service group is comprised of a number of smart card applications  that act co-operatively, as opposed to merely simultaneously, to provide a particular set of functions. An application  can be specified to not be part of any service group in which case the application will never be run with other applications. An application can become part of a service group once the application is running and can remove itself from a service group when the application is the currently front application.","In a still further alternative arrangement, the process components  to  and  described above can be implemented in dedicated hardware (e.g. the set top box ) as one or more integrated circuits performing the described functions or sub-functions. Such dedicated hardware may include graphic CPUs, digital signal CPUs, or one or more micro-CPUs and associated memories.","Typically, applications  are resident on the hard disk drive  and read and controlled in their execution by the CPU . Intermediate storage of programs and any data fetched from the network  can be accomplished using the semiconductor memory , possibly in concert with the hard disk drive . In some instances, the applications  will be supplied to the user encoded on a CD-ROM or floppy disk and read via the corresponding drive  or , or alternatively may be read from the network  via the modem device . Other mechanisms for loading the applications  into the computer system  from other computer readable medium include magnetic tape, a ROM or integrated circuit, a magneto-optical disk, a radio or infra-red transmission channel between the computer module  and another device, a computer readable card such as a smart card (not shown), a computer \u2018Personal Computer Memory Card International Association (PCMCIA) card\u2019 (not shown), and the Internet and\/or Intranets including email transmissions and information recorded on Websites and the like. The foregoing is merely exemplary of relevant computer readable media. Other computer readable media are also possible including combinations of those described above.","The smart card  generally stores a data structure in memory ,  that describes various card properties and any user interface elements ,  printed on the smart card . The smart card  can also include global properties that specify attributes such as information about the smart card , vendor and a service. Further, user-interface objects, as will be explained in detail below, can specify data to be associated with the user interface elements ,  printed on the surface of a corresponding smart card .","For the memory card A, data conforming to the format to be described can be copied directly into the memory chip  of the smart card . For the CPU card B, data conforming to the format to be described can be stored in the storage means  as a file being one file of a file system implemented on the CPU card B. Such a file system will be described in detail below. In either case, to ensure that the cost of the smart card  can be kept to a minimum, the amount of data stored on the smart card  is kept to a minimum. For example, where the smart card  is being used as a music sampler and associated on-line service, the memory ,  of the smart card  does not contain the music itself. The smart card  only contains data associated with the user interface in the form of the user interface elements ,  and certain identifiers, which will be described in detail below. If the smart card  has limited storage capacity (e.g. in the case where the smart card  utilises a barcode), the smart code  may only include a card identifier as will be explained in detail below.","The user-interface objects referred to above can represent mapping data, which relate the user interface elements ,  imprinted directly on a surface of the smart card , to commands or addresses (eg: Uniform Resource Locators (URLs)). The mapping data includes MY) coordinates that typically define the size and location of user interface elements ,  on the smart card . The user-interface objects are preferably stored in the memory ,  of the smart card . Alternatively, the user-interface objects can be stored not on the smart card  itself, but in the system . For example, the smart card  can store, via the memory ,  a barcode or a magnetic strip, a unique identifier, which is unique to smart cards  having substantially similar user interface elements ,  and layout. The unique identifier together with the coordinates determined from the touch panel , as a result of a user press, can be transmitted by the reader  to the computer  or to the set top box , of the system .","The system  can have the user-interface objects stored on the computer , set top box  or server , which may thus be arranged to perform the mapping from the determined coordinates to a corresponding command, address or data relevant to a service associated with the smart card  and a user selection of one of the user interface elements , , in order to provide a desired function represented by the selected user interface elements. In this instance, the data related to the user selected user interface elements ,  as described above takes the form of coordinates determined by the microcontroller  of the reader  as a result of a user applying pressure to a portion of the touch panel  which overlays the desired user interface elements , .","Data stored in the smart card  includes a card header followed by zero or more objects as described in the following sections.",{"@attributes":{"id":"p-0129","num":"0131"},"figref":"FIG. 11","b":["1100","100","1100","1101"],"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["(i) magic number field , which includes a constant specifying a smart card as being a valid memory card A or CPU card B. For example, the magic number field  can be used to check or verify that a propriety card belonging to a particular manufacture is being used;","(ii) versions field , which includes each version increment that specifies a change in the smart card layout that cannot be read by a reader  which is compatible with lower versions of the layout;","(iii) reserved field , this field is reserved for future use;","(iv) flags field , which includes flags for a smart card (see Table 2 below);","(v) card identifier field , which includes two fields\u2014a service  and a service specific field . The service field  identifies the service of a corresponding smart card  and the service specific field  optionally contains a service-specific value;","(vi) a number of objects field , which includes a number value representing how many objects follow the header . This field can be set to zero; and","(vii) a checksum field , which includes a card checksum of all data on a corresponding smart card  excluding the checksum itself."]}},"Table 1 below provides a description of the content of the various (number) fields described with reference to .",{"@attributes":{"id":"p-0131","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Field Number","Description (Card Header)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Magic Number","Two byte magic number. A constant that specifies this as being"]},{"entry":[{},"a valid card. Currently defined as the ASCII value for \u2018i\u2019 followed"]},{"entry":[{},"by the ASCII value for \u2018C\u2019."]},{"entry":["Version","One byte version number. Each version increment specifies a"]},{"entry":[{},"change in the card layout that can not be read by a reader that is"]},{"entry":[{},"compatible with lower versions of the layout. This document"]},{"entry":[{},"describes version 1(0x01) of the card format."]},{"entry":["Reserved","This data is reserved for future use. Its value must be set to zero."]},{"entry":["Flags","Four bytes of flags for this card. (See Table 2). All non-"]},{"entry":[{},"assigned bits must be zero."]},{"entry":["Card Identifier","Eight byte card identifier. Card identifiers include two fields -"]},{"entry":[{},"service identifier and service-specific identifier. The service"]},{"entry":[{},"identifier is five bytes and identifies the service associated with"]},{"entry":[{},"the card. The service-specific identifier is three bytes of service"]},{"entry":[{},"specific value."]},{"entry":["Number of Objects","One byte. The number of objects following this header. Can be"]},{"entry":[{},"zero."]},{"entry":["Checksum","Card checksum, 2 bytes. The card checksum is sixteen bit,"]},{"entry":[{},"unsigned integer sum of all data bytes on the card excluding the"]},{"entry":[{},"checksum."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The card identifier field  comprises an eight-byte card identifier. The card identifier includes two portions (i.e. unit pieces of data), namely, a service identifier and a service-specific identifier. Preferably, the card identifier is arranged so that the service identifier occupies five bytes and the service-specific identifier occupies three bytes of the total card identifier value.","The service identifier contained in the field  may be used to distinguish one service from another or distinguishes one vendor from another. That is, for example, a service can be associated with an application that provides the service to the user of a smart card  as distinct from a vendor who can provide multiple services to the user by providing multiple applications. The service identifier can be an identifier to identify the application to be used or application location (e.g. URL).","The card identifier can be used to configure generic smart cards for the system . Generic smart cards are smart cards  having a special service identifier that can be used to provide input to a current application already running. The special value for the service identifier, referred to as \u201cthe generic service identifier\u201d, is 0x0000000001, where \u20180x\u2019 represents hexadecimal notation (i.e. every two characters of the generic service identifier represent the value of a single byte). A generic smart card can be used to send data to a front application already running on the system . For example, a smart card  having a keypad user interface that can be used to send text input to an application which has focus or a smart card  with personal details that can also be used to submit the personal information stored on the smart card  to any application.","A smart card  identification authority can assign service identifiers to a vendor when the vendor registers a particular service.","The service-specific identifier contained in the field , as described above, can be optionally used by the vendor of a particular service to provide predetermined functions associated with that particular service. The use of the service-specific identifier is substantially dependent upon an application  being executed on the system . For example, the service identifier together with the service-specific identifier can be used as a unique identifier for a card . This unique identifier can be used by an application  to gain or deny access to a specific feature associated with a particular service, to reproduce a specific-service identifier in a log file in order to confirm or verify that a particular smart card  having that value was used to access a service, and to provide a unique identifier that can be matched up with a corresponding value in a database in order to retrieve information about the user of the service (eg: name, address, credit card number etc).","Another example of a use for the service-specific identifier can include providing information about a mechanism or mode of distribution of the smart cards  (e.g. by mail, bus terminal kiosks, handed out on a train etc). Further, the service-specific identifier, can identify what data is to be loaded into the system  when a service is accessed.","The foregoing is not intended to be an exhaustive list of possible uses or applications of the service-specific identifier but a small sample of possible applications and there are many other applications of the service-specific identifier of field .","The flags field  of the header  of  can include three flags.","For the memory card A and the CPU card B, the flags of the flags field  are as follows:","(i) Background beep;","(ii) Move; and","(iii) Don't Report Background Coordinates.","Table 2 below provides a description of each of the above flags (i) to (iii). The above flags (i) to (iii) affect the functions that the smart card  can perform in a reader , as is defined by the description of each flag.",{"@attributes":{"id":"p-0144","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Description","Value (hex)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Background","Causes the reader to provide audio feedback","0x0000 0001"]},{"entry":["Beep","whenever the background is touched."]},{"entry":["Move","Causes the reader to send all move events","0x0000 0002"]},{"entry":[{},"from when the touch panel was pressed until"]},{"entry":[{},"the touch panel is released."]},{"entry":["Don't Report","Causes the reader to suppress reporting of","0x0000 0004"]},{"entry":["Background","the co-ordinates of all presses and releases"]},{"entry":["Co-ordinates","of the touch panel, when they correspond"]},{"entry":[{},"to the background, reporting them instead as"]},{"entry":[{},"(0xFF, 0xFF)."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"As shown in , immediately following the card header  of  can be zero or more object structures  defining the objects of a particular smart card  and forming part of the data stored on the smart card . Each object structure  comprises four fields as follows:","(i) a type field ;","(ii) an object flags field ;","(iii) a length field ; and","(iv) a data field .","The structure of the data field  depends on the object type as will be described below.","Table 3 below shows a description of each of the fields , ,  and  of the object structure .",{"@attributes":{"id":"p-0152","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Description (Object Structure)","Length"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","The type of object (see Table 5).","1 byte"]},{"entry":["Object Flags","The general object flags that are associated","1 byte"]},{"entry":[{},"with this object (see Table 4). Note: Additional"]},{"entry":[{},"flags specific to an object type are specified"]},{"entry":[{},"within the data field of the object."]},{"entry":["Length","The length of the data following this object.","2 bytes"]},{"entry":[{},"This value can be zero."]},{"entry":["Data","The data associated with this object. The","Variable"]},{"entry":[{},"structure of this data is dependent on the type"]},{"entry":[{},"of object."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The flags field  of the object structure , preferably includes an inactive flag. Table 4 below shows a description of the inactive flag.",{"@attributes":{"id":"p-0154","num":"0163"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Description (Pre-Object Flag Values)","Value (hex)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Inactive","Indicates to the reader that the object is valid","0x01"]},{"entry":[{},"but is to be ignored regardless of it's type."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"For the smart card , there are preferably eight object types provided, as follows:","(i) User Interface Element: Text;","(ii) User Interface Element: Delegator;","(iii) User Interface Element: Buffer","(iv) Card Data;","(v) Fixed Length Data;","(vi) Reader Insert;","(vii) No operation; and","(viii) No operation (single byte).","Table 5 shows a description of each of the above object types (i) to (viii).",{"@attributes":{"id":"p-0164","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Description)","Value (hex)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["No operation","A single byte object that doesn't have a","0x00"]},{"entry":["(single byte)","standard object header. Used to fill spaces on"]},{"entry":[{},"the card that are too small for a normal object header."]},{"entry":["No Operation","An object that is used to fill blocks of empty space","0x01"]},{"entry":[{},"on the card."]},{"entry":["User Interface","A user interface element with raw data.","(inline) 0x10"]},{"entry":["Element: Text",{},"(file) 0x11"]},{"entry":["User Interface","A user interface element which initiates","(inline) 0x12"]},{"entry":["Element: Buffer","buffered input mode. (CPU card only).","(file) 0x13"]},{"entry":["User Interface","A user interface element containing a command","(inline 0x14"]},{"entry":["Element:","to be invoked on another card resident","(file) 0x15"]},{"entry":["Delegator","application (CPU card only)."]},{"entry":["Card Data","Contains data that relates specifically to this","0x20"]},{"entry":[{},"card. Card data would normally be read by the"]},{"entry":[{},"reader and sent as part of the INSERT message on card"]},{"entry":[{},"insertion."]},{"entry":["Fixed length Data","An object that can be used to store fixed length","0x30"]},{"entry":[{},"blocks of data on the card."]},{"entry":["Reader Insert","An object that can be used to give instructions","0x40"]},{"entry":[{},"to the reader when the card is inserted."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Each of the user interface element objects of Table 5 define a rectangular area on a smart card  and some quantity of associated data that is used to generate an output when the user touches an area of the touch panel  over the corresponding rectangular area of the smart card . The origin for the coordinate mapping system is the top left of the smart card  in accordance with an International Standards Organisation standard smart card held in a portrait view with the chip contacts ,  facing away from the viewer and towards the bottom of the smart card . For any reader  that does not use this card orientation, the values of corner points on the smart card  must be adjusted by the reader  for the memory card A or by the CPU  for the CPU card B, so as to report a correct \u201cbutton\u201d press.","The user interface element objects structure preferably has six fields as follows:\n\n","Table 6 shows a description of each of the above fields for the described user interface element object structure. A press on the touch panel  is defined to be inside an area defined by a particular user interface element corresponding to a user interface element object structure if:","(i) the X value of the press location is greater than or equal to the X1 value of the associated user interface element object and is strictly less than the X2 value for that particular user interface element object; and","(ii) the Y value for the press location is greater than or equal to the Y1 value of the particular user interface element object and strictly less than the Y2 value.",{"@attributes":{"id":"p-0170","num":"0185"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field","Description (User Interface Object Structure)","Size"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Flags","Flags specific to this user interface element on the","1 byte"]},{"entry":[{},"card."]},{"entry":["X1","X value of the top-left hand corner co-ordinate of this","1 byte"]},{"entry":[{},"object's rectangle."]},{"entry":["Y1","Y value of the top-left hand corner co-ordinate of this","1 byte"]},{"entry":[{},"object's rectangle."]},{"entry":["X2","X value of the bottom-right hand corner co-ordinates","1 byte"]},{"entry":[{},"of this object's rectangle."]},{"entry":["Y2","Y value of the bottom-right hand corner co-ordinate of","1 byte"]},{"entry":[{},"this object's rectangle."]},{"entry":["Data","Zero or more bytes of data associated with this object.","Variable"]},{"entry":[{},"In memory cards, the actual data is always stored"]},{"entry":[{},"within this field. For CPU cards, this field may"]},{"entry":[{},"contain a file identifier which points to a file where the"]},{"entry":[{},"data is actually stored. The size of this field is"]},{"entry":[{},"determined by the object data size minus the combined"]},{"entry":[{},"size of the above fields."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Overlapping user interface elements are allowed. In this case, if a press is within the bounds of more than one user interface element then the object resulting from the press is determined by a Z order. The order of the user interface elements ,  on the smart card  defines the Z ordering for all of the user interface elements on that particular smart card . The top user interface element is the first user interface element for a particular smart card . The bottom user interface element is the last user interface element for that particular smart card . This allows for non-rectangular areas to be defined. For example, to define an \u201cL\u201d shaped user interface element, a first user interface element object would be defined with zero bytes in the data field, and a second user interface element object would be defined to the left and below the first user interface element object but overlapping the first user interface element object. The second user interface element would contain the data that is to be associated with the \u201cL\u201d shaped user interface element.","The location of a press is reported in \u201cfingels\u201d, which represent finger elements (analogous to \u201cpixels\u201d which represent picture elements). The height of a fingel is defined to be 1\/256th of the length of an International Standards Organisation memory smart card and the width is defined to be 1\/128th of the width of an International Standards Organisation memory smart card.","The behaviour associated with each user interface element ,  may be modified using one or more flags. For both the memory card A and the CPU card B, each user interface element  preferably has seven associated flags as follows:","(i) Beep;","(ii) Move;","(iii) Don't report coordinates;","(iv) Auto repeat;","(v) Do Not Send Data on Press;","(vi) Do Not Send Data on Release; and","(vii) Encrypt Out-going data.","Table 7 shows a description for each of the user interface element flags (i) to (vii).",{"@attributes":{"id":"p-0181","num":"0196"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Description","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Beep","This flag causes the reader to beep when the user","0x01"]},{"entry":[{},"interface element is pressed."]},{"entry":["Don't Report","This flag instructs the reader to suppress reporting","0x04"]},{"entry":["Co-ordinates","of the co-ordinates of the associated press or"]},{"entry":[{},"release, reporting them instead as (0xFF, 0xFF)."]},{"entry":["Auto-repeat","This element automatically repeats when the press","0x08"]},{"entry":[{},"is held on the element."]},{"entry":["Don't Send","This causes the associated user interface element","0x10"]},{"entry":["Data on","not to send the data associated with this user"]},{"entry":["Press","interface element in the press event. The default"]},{"entry":[{},"is to send the data associated with the user"]},{"entry":[{},"interface element in the press event."]},{"entry":["Don't Send","This causes this user interface element not to send","0x20"]},{"entry":["Data on","the data associated with this user interface element"]},{"entry":["Release","in the release event. The default is to send the"]},{"entry":[{},"data associated with the user interface element in"]},{"entry":[{},"the release event."]},{"entry":["Encrypt","This causes the data associated with the user","0x40"]},{"entry":["Outgoing ","interface element to be encrypted using a"]},{"entry":["Data","previously agreed upon session key. If no session"]},{"entry":[{},"key is present, no data is sent. (CPU cards only)."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Data associated with a user interface element ,  on the smart card  can be referenced as \u2018line Data\u2019 which is stored directly in the data field of a user interface element. However, for the CPU card B, data associated with a user interface element can also be referenced as \u2018File Data\u2019. File data is stored in a separate elementary file in the storage means  of the microprocessor  and the structure of data field associated with such an elementary file is shown in Table 8.",{"@attributes":{"id":"p-0183","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Length","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["File_id","2 bytes","The 16-bit ISO identifier corresponding"]},{"entry":[{},{},"to the required file"]},{"entry":["Header","variable","A variable length header, which is prepended to the"]},{"entry":[{},{},"file contents in order to identify the user interface"]},{"entry":[{},{},"element. This may be empty."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The card data object is used to store data which is specific to a particular card . The data layout for this object has no fixed form. The contents of the card data object are sent from the reader  as part of an INSERT message when the smart card  is inserted into the reader .","The fixed length data object is used to define a fixed length block on the smart card  that can be written to by the computer , for example.","The reader insert object is used to store instructions for the reader  when a particular smart card  is inserted. This can be used, for example, to instruct the reader  to use a specific configuration of infra-red commands to allow communication with a specific set top box (e.g. ) or TV.","The No Operation object is used to fill in unused sections between other objects on a particular smart card . Any data stored in the no operation object is ignored by the reader . Any unused space at the end of the smart card  does not need to be filled in with a no operation object.","The No Operation (One Byte) object is used to fill gaps between objects that are too small for a full object structure. These objects are only one byte long in total.","The reader  uses a datagram protocol that supports both unidirectional and bi-directional communication between the reader  and the set top box  or computer , for example. The format used for messages from the reader  as a result of user interactions with the smart card  are of a different format than those that are sent to the reader .","There are at least seven message event types that can be sent by the reader . These message events are as follows:","(i) INSERT: When a smart card  is inserted into the reader , and the smart card  is validated, an INSERT event is generated by the reader  and an associated message is transmitted. This message announces the smart card  to a remote module (e.g. the set top box ). The INSERT message preferably can include the particular card identifier and allow applications to be started or fetched immediately upon the smart card  insertion rather than waiting until the first interaction takes place. The INSERT message preferably includes the contents of the card data object from the smart card  inserted into the reader  if an object of this type is present on the smart card .","(ii) REMOVE: When a smart card  is removed from the reader , a corresponding REMOVE event is generated and a REMOVE message is sent to the particular remote module associated with the reader . Like the INSERT message, the associated card identifier can be transmitted along with the message. As the card identifier cannot be read from the now removed smart card , the card identifier is stored in the memory  of the reader . This is a useful optimisation as the card identifier is required for all other messages and reading the card identifier from the smart card  each time the card identifier is required can be too slow. INSERT and REMOVE messages are not relied upon by the system  to control processing. The system  is configured to infer missing messages if a message is received and is not immediately expected. For example, if an application detects two INSERT messages in a row, then an application can assume that it has missed the REMOVE message associated with the smart card  of the first INSERT message, as typically two smart cards  are not inserted into the reader  at one time. The application can then take whatever action is required prior to processing the second INSERT message.","Another example of where a missing message can occur is where a hand-held, infrared connected reader  as shown in ), as compared with a wired reader  as shown in ), is being used. Often a user does not point the reader  directly at a remote module when inserting or removing cards. This problem can be corrected by the system  inferring the INSERT or REMOVE operations based on differing card identifiers in consecutive PRESS and RELEASE pairs.","(iii) BAD CARD: If an invalid smart card  is inserted, then the reader  is preferably configured to generate a BAD CARD event and to send a BAD CARD message. This message allows an associated remote module to take some action to alert the user to the invalid smart card .","(iv) PRESS: When a touch is detected by the reader , a PRESS event is generated and a PRESS message is sent to an associated remote module. The PRESS message can contain details of an associated memory card, the position of the press and the data associated with the user-interface element at that particular position. If there is no user interface element defined for that position (including if there is no user interface element defined on the smart card  at all) a PRESS message is sent containing details of the associated smart card  and the position of the press. If there is no card present in the reader  when a PRESS event is generated then a PRESS message is sent containing the special \u201cNO_CARD\u201d identifier (i.e. eight bytes of zero\u20140x00) and the position of the press.","(v) RELEASE: A RELEASE event complements the PRESS event and a RELEASE message can be sent in order to inform an application program of the system  that a PRESS has been lifted. Every PRESS event preferably has a corresponding RELEASE event. Readers can allow multiple presses to be registered or provide other events that may occur between PRESS and RELEASE messages.","(vi) MOVE: If, after processing a PRESS event, the touch position changes by a certain amount then the finger (or whatever is being used to touch the smart card ) is assumed to be moving. MOVE EVENTS are generated and MOVE messages are sent until the touch is lifted. MOVE events auto-repeat by resending the last MOVE messages when the touch position remains stationary. The repeated sending finishes when the touch is lifted and a corresponding RELEASE message is sent. Unlike PRESS and RELEASE events there is no user-interface object involved with MOVE events.","(vii) LOW BATT: A LOW BATT event is generated and a LOW BATT message is sent when the battery  in the reader  is getting low. This message is sent after user interactions to increase the chance that the message will be received by the rest of the system . The sending of the LOW BATT message does not prevent the reader  from entering a low power state.","As described above, the card identifier is included in every INSERT, REMOVE, PRESS, RELEASE and MOVE message sent from the reader  to the computer  or set-top box . As an alternative, the card identifier can be sent in connection with an INSERT message only. In this instance, upon insertion of a new smart card , the reader  generates a session identifier. The session identifier is configured to identify a current session of a card insertion. The session identifier, for example, can be a pseudo-random number represented with two bytes of data or the session identifier can be a number that is incremented each time a smart card  is inserted and reset to zero when a predetermined value is reached. In this case, the reader  sends an INSERT message to the computer  or the set-top box , which includes a card identifier as previously described above and a session identifier which is generated for each new smart card  insertion. All subsequent PRESS, RELEASE and MOVE messages need not include the card identifier but will include the session identifier and user interface element object data or press coordinates previously described.","When using a session identifier, the system  operates as described above with reference to ) and (), except that the event manager , upon receiving an INSERT message from the reader , stores the session identifier as the current session identifier and a card identifier as the current card identifier. When the event manager  receives a PRESS, RELEASE or MOVE message, the event manager  checks that the session identifier is equal to the current session identifier. If so, the event manager  sets a card identifier used in all messages to the current card identifier. Otherwise, if the session identifier is not equal to the current session identifier, the event manager  informs the user, via the display manager , and the display device , that a message has been received without a corresponding INSERT message. The user, for example, is then requested to remove and reinsert the card .","The data format of the reader  protocol used in the system  is a fixed size header followed by a variable length data field which can be zero bytes or more in length, followed by an eight bit check-sum and complement.","The message header is preferably of a fixed length and is prepended to (i.e. appended to, but in front of) all messages sent from the reader  to a set top box  for example. It is necessary to keep the message header as small as possible due to any bandwidth restrictions that may be imposed. Table 9 below shows the format of the message header that is sent from a reader  to a remote module such as the set top-box  for example. The service and service-specific identifier are the same for a given smart card . A service specific identifier is preferably set by a vendor for use with their application. The reader identifier (ID) of Table 9 is also in the header of each message. The reader identifier can be used by an application  to distinguish different users, for example, in a multi-player game application.",{"@attributes":{"id":"p-0203","num":"0218"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field","Description (Message Header Format)","Bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Preamble","Preamble to the message. Value is always 0xAA","2"]},{"entry":[{},"0x55 (bit sequence 10101010 01010101). This is to"]},{"entry":[{},"make it easier for the event manager 901 to find the"]},{"entry":[{},"beginning of a message."]},{"entry":["Version","The version of the user interface card infrared","1"]},{"entry":[{},"message protocol this messages uses. This version"]},{"entry":[{},"of the protocol is version 1(0x01 in the version"]},{"entry":[{},"field)"]},{"entry":["Type","Type of message. This is one of the values given in","1"]},{"entry":[{},"Table 10."]},{"entry":["Reader ID","The 16 bit id of the reader that sent the message.","2"]},{"entry":[{},"This number is a pseudorandom generated number"]},{"entry":[{},"that is changed when the battery is replaced in the"]},{"entry":[{},"reader. This is needed to distinguish readers when"]},{"entry":[{},"multiple readers are being used with applications."]},{"entry":["Service","Service identifier as stored on the card.","5"]},{"entry":["Service-","Service-specific identifier as stored on the card.","3"]},{"entry":"specific"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table 10 shows a table listing the message event types that have been described above.",{"@attributes":{"id":"p-0205","num":"0220"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Description (Message Type Codes)","Code"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["INSERT","A card has been inserted into the reader.","\u2018I\u2019"]},{"entry":["REMOVE","The card has been removed from the reader.","\u2018E\u2019"]},{"entry":["PRESS","The touch panel has been pressed.","\u2018P\u2019"]},{"entry":["RELEASE","The press on the touch panel has been released.","\u2018R\u2019"]},{"entry":["MOVE","The press position has moved but the press has","\u2018M\u2019"]},{"entry":[{},"not been released."]},{"entry":["BADCARD","A card has been inserted however it has not","\u2018B\u2019"]},{"entry":[{},"passed validation."]},{"entry":["LOW_BATT","The battery in the reader is getting flat.","\u2018L\u2019"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"A number of message types are considered simple in that they consist solely of the message header described above followed by the message checksum byte and its complement. For example, a BADCARD message, a LOW_BATT message and a REMOVE message are simple messages. Table 11 shows the format of a simple message.",{"@attributes":{"id":"p-0207","num":"0222"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field","Description (Simple Message Format)","Bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Header","Message header as defined in Table 9.","14"]},{"entry":["Checksum","Message checksum. This is the sum of all the bytes","1"]},{"entry":[{},"in the message."]},{"entry":["Checksum'","The 1's complement of the checksum.","1"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"MOVE messages are formed of the message header described above followed by two fields defining the coordinates of the touch position on the touch panel  of the reader . Table 12 shows the format of a MOVE message.",{"@attributes":{"id":"p-0209","num":"0224"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field","Description (Move Message Format)","Bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Header","Message header as defined in Table 9.","14"]},{"entry":["X","The X co-ordinate of the touch position.","1"]},{"entry":["Y","The Y co-ordinate of the touch position.","1"]},{"entry":["Checksum","Message checksum. This is the sum of all the bytes","1"]},{"entry":[{},"in the message."]},{"entry":["Checksum'","The 1's complement of the checksum.","1"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Table 13 below shows the format of PRESS and RELEASE messages. PRESS and RELEASE messages, like MOVE messages contain the message header and touch coordinates. In addition, PRESS and RELEASE messages send data associated with a user-interface element if the touch position matches a user-interface element object defined on the smart card . This data is of variable length, the actual size being defined by a corresponding smart card . If the touched position does not match a user-interface element object defined on the smart card  (including if no user-interface elements are defined on the smart card ), zero bytes of data associated with user interface elements are sent. If there is no smart card  in the reader  then the service identifiers are all set to zero (ie 0x00) and zero bytes of data associated with the user-interface elements are transmitted to the remote module. The data associated with the user interface element normally corresponds to the data associated with the user interface element defined on the smart card  but may be modified or generated by processing on the smart card  or reader .",{"@attributes":{"id":"p-0211","num":"0226"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field","Description (Press and Release Message Format)","Bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Header","Message header as defined by Table 9.","14\u2002"]},{"entry":["X","The X co-ordinate of the touch position.","1"]},{"entry":["Y","The Y co-ordinate of the touch position.","1"]},{"entry":["Length","The number of bytes of data. Can be zero.","2"]},{"entry":["Data","The data associated with the user","Length"]},{"entry":[{},"interface element."]},{"entry":["Checksum","Message checksum. This is the sum of all the","1"]},{"entry":[{},"bytes in the message."]},{"entry":["Checksum'","The 1's complement of the checksum.","1"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"INSERT messages are formed of the message header described above and the contents of the card data object from an inserted smart card . Table 14 below shows the format of an INSERT message.",{"@attributes":{"id":"p-0213","num":"0228"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field","Description (INSERT Message Format)","Bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Header","Message header as defined in Table 9.","14\u2002"]},{"entry":["Length","The number of bytes of data. Can be zero.","2"]},{"entry":["Data","The data from a Card Data object on the card.","Length"]},{"entry":["Checksum","Message checksum. This is the sum of all the","1"]},{"entry":[{},"bytes in the message."]},{"entry":["Checksum'","The 1's complement of the checksum.","1"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0214","num":"0229"},"figref":["FIG. 13","FIG. 27"],"b":["600","100","1100","1213","1045","300","901","920","901","902","903","904"]},"The operation of the system  will now be further explained with reference to the following example. The system  is customisable by virtue of a user being able to utilise a number of different smart cards  to perform corresponding different operations. For example, with particular reference to the system B, ) shows a memory card C which according to the user interface elements  printed thereon is configured for the retrieval of on-line music associated with an Internet site entitled \u201cBlues Guitar Masters\u201d. The on-line music can be accessed over the system B using the memory card C and then purchased using a CPU card D configured for use with an electronic banking application, as will be explained below with reference to ) and (). Alternatively, other functions may be performed on the system B, using different smart cards , such as home shopping, ordering home delivery fast food such a pizzas, and the like. In each instance, insertion of an appropriate smart card  into the reader  causes a corresponding computer application to commence operation, either within the set-top box  or the computer system , in order to service user commands entered via the reader  and to return appropriate information for audio-visual feedback to the user.","For the memory card C, on-line music is provided as data to the set-top box  which permits reproduction of audio and any related visual images on the output device  or the display  of the computer system . The user interface elements  of the memory card C are in the form of a \u201cplay button\u201d , a \u201crewind button\u201d , a \u201cfast forward button\u201d , a \u201cstop button\u201d , a \u201cselect button\u201d , a \u201crecord button\u201d  and a two-way directional controller , printed on a front face  of the memory card C.",{"@attributes":{"id":"p-0217","num":"0232"},"figref":["FIG. 14(","FIG. 14("],"i":["b","b"],"b":["1431","1401","1417","1431","100","219","100","1431","1420","1421","1422","1423","1424","1425","1420","1409","1409","1421","1409","1431","1409","1433","100","1425","1409"]},"The memory card C also includes a card data object as described above with reference to Table 5. The card data object contains data that relates specifically to a particular smart card  and is normally sent as part of an INSERT message, upon the smart card  being inserted into the reader . In the case of the memory card C, the card data object indicates a URL, \u2018www.bluesguitarmasters.com\u2019, corresponding to the address of the \u2018Blues Guitar Masters\u2019 Internet site. A person skilled in the relevant art would appreciate that the URL is stored in the memory of the memory card C in a digital format corresponding to the American Standard Code for Information Interchange (ASCII) values of the characters making up the URL. Alternatively, a card identifier can be stored in the memory of the memory card C and can be mapped to the URL by the directory service .","The memory card C also includes a card identifier, as described with reference to Table 1, stored in the memory of the memory card C. The card identifier includes a service identifier which in the case of the memory card C can be mapped to the URL, \u2018www.bluesguitarmasters.com\u2019, corresponding to the address of the \u2018Blues Guitar Masters\u2019 Internet site by the directory service . The card identifier also includes a service-specific identifier which in this case is a three-byte vendor identifier related to the vendor of the Blues Guitar Masters Internet site. The service-specific identifier can be assigned by the provider of the service (e.g. the vendor of the Blues Guitar Masters Internet site), and can be equal to any particular three-byte value. Each card  associated with the \u2018Blues Guitar Masters\u2019 Internet site, for example, can have a different service-specific identifier.","For the CPU card D, the user interface elements  are in the form of a numerical keypad , an \u201cOK button\u201d , a \u201ccancel button\u201d , a \u201cclear button\u201d , a \u201cbackspace button\u201d , and a four way directional controller  printed on the front face  thereof.","Similar to the memory card C, each of the user interface elements  of the CPU card D has at least one associated user interface element object (e.g. ) stored in a storage means (not shown) formed within the CPU card D similar to the storage means  of the CPU card B. Again, as described above with reference to Table 6 and as shown in ), each of the user interface element objects (e.g. ) has six fields being a flags field , an X1 field , a Y1 field , an X2 field , a Y2 field  and a data field , describing the position of and data associated with a corresponding user interface element. For example, the X1 field  associated with the \u201cnumber 2 button\u201d  of the numerical keypad , is a one byte field set to a value of \u201c0005\u201d indicating the coordinate value of the bottom left hand point  of the user interface element  with respect to the top left point  of the CPU card D. The data field  of the \u201cnumber 2 button\u201d  is a variable size field which in the case of the CPU card D value corresponds to a hexadecimal representation corresponding to the ASCII value of the character \u20182\u2019.","The CPU card D also includes a card data object, as described above with reference to Table 5. In the case of the CPU card D, the card data object indicates a URL (e.g. www.anz.com), corresponding to the address of an electronic banking Internet page. A person skilled in the relevant art would appreciate that the URL is stored in the storage means of the CPU card D in a digital format corresponding to the ASCII values of the characters making up the URL.","Similar to the memory card C, the CPU card D also includes a card identifier, as described with reference to a Table 1 stored in the storage means of the CPU card D. The card identifier includes a service identifier, which in the case of the CPU card D can be mapped to the URL corresponding to the electronic banking application (e.g. www.anz.com). The card identifier also includes a service-specific identifier, which in this case is a three-byte vendor identifier. The service-specific identifier can be related to the vendor of the electronic banking package (e.g. the Australia New Zealand Banking Group Limited). Again, each CPU card B associated with the electronic banking package, for example, can have a different service-specific identifier.",{"@attributes":{"id":"p-0224","num":"0239"},"figref":["FIG. 16","FIG. 17(","FIG. 17(","FIG. 17(","FIG. 17(","FIG. 17("],"b":["1600","600","1601","100","300","100","300","650","601","616","1720","1603","300","1413","1722","616","1605","1722","1413","1605","1724","616","1605","1605","1726","1724","1728","1607","1728","1607","1730","616","100","300","1730","1609","100","100","300","1611","154","308","154","100","100","100","652","601","616","1613","1514","100","616","1720","1722","1724","1730","720","1720","1722","1724","1730"],"i":["a","b","c","d","e"]},{"@attributes":{"id":"p-0225","num":"0240"},"figref":"FIG. 18","b":["1800","300","100","100","300","1601","1600","1800","300","1609","100","1800","300","1800","1045","1801","100","300","1800","1802","1802","100","100","300","1800","1803","1800","1803","100","1045","1800","1804","100","1045","300","100","1800","1804","1045","100","100","1804","1805","601","1045","805","1806","1800"]},"If the \u201cmagic number\u201d and \u201cchecksum\u201d fields are not correct (ie: the memory card C is not valid) at step , then the method  proceeds to step  where the don't beep, no move events and event co-ordinate flags are set. At the next step , a BAD CARD message is sent to the set top box  by the CPU , and the BAD CARD message is processed by the CPU  resulting in display of such a message on the output device . Then at step , a \u201cBOOP\u201d is sounded and the method  concludes.","If the memory card C is not inserted into the reader  at step , then the method  proceeds to step . At step , if this is the first operation of the reader  after the reset then the method  concludes. Otherwise, the method  proceeds to step  where the \u201cBeep\u201d, \u201cNo MoveEvents\u201d and \u201cNo Event Co-ordinates\u201d flags are set to default values by the CPU  and the card identifier stored in memory of the memory card C is set to \u201cNO_CARD\u201d. At the next step , a REMOVE message is sent to the set top box  by the CPU , and the REMOVE message is processed by the CPU . The method  concludes after step .",{"@attributes":{"id":"p-0228","num":"0243"},"figref":["FIG. 19","FIG. 16"],"b":["1900","308","300","600","900","1900","1045","1603","1605","1607","1720","1514","1900","1514","1901","308","1900","1902","1900","1912","308","1900","1913","1900"]},"At step , the \u201cbeep\u201d, \u201cmove events\u201d and \u201cno event co-ordinate\u201d flags are set according to their corresponding values in the associated card header if a card is present. If a card is not present in the reader  then these flags are set to default values. Then at step , the message type is set to RELEASE and the method  proceeds to step .","The method  continues at step , where if this is the first time that a touch has been noticed since there was no touch, then the method  proceeds to step . At the next step , the CPU  determines if a bad card has been inserted into the reader  by checking the result of step , then in the case that a bad card has been inserted into the reader , the method  proceeds to step . Then at step , a BAD Card message is sent to the set top box , the BAD CARD message is stored in memory , and the method  concludes. If it was determined at step  that the memory card C was valid, by checking the result of step , or that no card was inserted into the reader , by the checking of step , then the method  proceeds to step , where the type of message is set to PRESS in the message header of Table 9. At the next step , the CPU  determines the touch coordinates (i.e. X, Y coordinates of user press location) via the touch panel interface . Then at the next step , the offset and scale functions are applied to the coordinates by the CPU . The offset and scale functions map the coordinate space of the touch panel  to the coordinate space of the card C. The method  continues at the next step , where if the CPU  determines that the sent message was a MOVE and\/or no card was inserted into the reader , by checking step , then the method  proceeds directly to step . Otherwise, the method  proceeds to step  and the memory of the memory card C is searched by the CPU  in order to find the first user interface element whose X1, Y1, X2, Y2 values form a range within which the touch coordinates fall and data associated with matched user interface element is read from the memory card A. At the step , the message is sent along with any data to the set top box , and the CPU  processes the message. The method  continues at the next step , where a BEEP sound is sounded and the method  concludes.","If this is not the first time that a touch has been noticed since there was no touch, at step , then the method  proceeds to step . At step , if the touch detected at step  was a move, then the method  proceeds to step . Otherwise the method  concludes. At step , the message type is set to MOVE and the method  proceeds to step . For example, a MOVE message can be sent along with the X, Y coordinates of a touch position as defined by Tables. 12 and 15, a PRESS and RELEASE message can be sent along with X, Y coordinates of a touch position and data associated with a user interface object as defined by Tables. 12 and 16. If it was determined at step  that the message was a MOVE, at step , then the CPU  sends a MOVE message to the set top box . The CPU  of the set top box  processes the X, Y coordinates as cursor information resulting in a cursor move that is displayed on the output device . In this case, the next RELEASE message can be interpreted as a command to select the displayed object at the cursor position (e.g. to select an icon  of the menu screen ). Further, if NO Event Coordinates (see Table 2) have been set in the memory card C, then the reader  may send the data associated with a user interface object to the event manager  in the computer  or set top box  without sending the X, Y coordinates of the touch position.","The method  can be similarly performed at steps  and  for the CPU card D. However, in the case of the CPU card D, the mapping of the offset and scale functions to the coordinate space of the touch panel  of the card D at step  and the searching of the CPU card D at step , is performed by the CPU (not shown) of the CPU card D. The operation of the CPU cards B and D in this regard will be described in more detail later in this document.",{"@attributes":{"id":"p-0233","num":"0248"},"figref":"FIG. 20","b":["2000","600","900","2000","705","600","100","300","1601","2000","2001","901","2001","920","901"]},"At the next step , the event manager  starts the launcher . Then at the step , the event manager  passes a message to the launcher , enabling the launcher  to determine which application  to execute, and the launcher  then starts the corresponding application . In the case of the memory card C, the corresponding application  is an application associated with the Blues Guitar Masters Internet site. The process  continues at the next step , where once the currently running application  is no longer needed (e.g. whilst the Blues Guitar Masters application selection is being streamed to the set-top box  from another location on the computer network  not associated with the generation of the menu screens , ,  and  or when the CPU card D is inserted into the reader  at step ), the launcher  provides an exit message to the running application (i.e. the application associated with the Blues Guitar Masters Internet site) in order to end the execution of the running application. All applications are terminated when the system B is powered down or switched off.",{"@attributes":{"id":"p-0235","num":"0250"},"figref":"FIG. 21","b":["2100","901","2001","2100","705","2100","805","2100","2101","903","2103","901","2103","300","2105","2100","2107","2100","2109","2100","2111","2111","2100","2103","2109","2100","2113","2100","2103"]},"If the event is from the reader  at step , then the method  proceeds to step . If the event is a BADCARD, LOWBAT, INSERT or REMOVE event at step  then the method  proceeds to step . Otherwise the method  proceeds to step . At step , the event is passed to the launcher  and the method  returns to step . If the card identifier is the NO_CARD identifier at step , then the corresponding message is passed to the launcher  at step . Otherwise the method  proceeds to step , where the service identifier portion of the card identifier is compared with the service identifier used in determining the current front application (i.e. the application to receive messages from the event manager). If the service identifier is not the same as that which has been used to determine the front application, then the method  proceeds to step  where this message is passed to the launcher . Otherwise, the method  proceeds to step , where the event is sent to the front application and the method  returns to step .",{"@attributes":{"id":"p-0237","num":"0252"},"figref":"FIG. 22","b":["2200","903","2002","2004","2000","3700","705","2200","4305","2200","2201","903","901","2202","600","2203","903","903","2205","2205","2207","2200","2209","2207","903","616","2200","2203"]},"If the event at decision step  is determined not to be a NO_CARD identifier, another decision step  is entered to determine whether or not the event is a PRESS, RELEASE, REMOVE, MOVE or INSERT. If this decision step  returns a \u201cyes\u201d, that is, the event is one of the aforementioned events, then the method  proceeds to step . Otherwise the method  proceeds to a further decision step . At step , the launcher  changes the application and the method  returns to step . A REMOVE event followed by an INSERT event would occur at step  of the process  when the user removes the memory card C from the reader  and inserts the CPU card D. The INSERT event results in the reader  sending an INSERT message containing the URL of the banking application to the CPU  of the set top box  which passes the URL to a server (e.g. the server computer ) associated with the banking application.","If the event at step  is not one of the PRESS, RELEASE, REMOVE, MOVE or INSERT events, then a decision step  is entered. This decision step  makes a determination on a BADCARD or LOW_BATT event. If the event is a BADCARD or LOW_BATT event at step , then the method  proceeds to step , otherwise the method  proceeds to step . At step , the launcher  gives the user feedback on the event that has occurred (e.g. displaying a \u201cLow Battery\u201d message on the output device  if the LOW_BATT event is determined or a \u201cIncorrect Card\u201d upon determination of a BADCARD event) and the method  returns to step . If the event at decision step  is neither a BADCARD or LOW_BATT event, then step  is entered.","If the event is an APP_REGISTER event at step , then the method  proceeds to step , application registering. Otherwise the method  proceeds to step . At step , the application is registered (i.e. the application informs the other components ,  and  that it is now ready to receive messages) and the method  returns to step . At step , the event is discarded and the method  returns to step .","The operation of the CPU cards described above will be discussed below with reference to the CPU card B. However, a person skilled in the relevant art would appreciate that the following description applies equally to the CPU card D.","The CPU card B has several advantages over the memory card A and over other conventional memory card or user interface card platforms. Firstly, a personal identification number (PIN) and other data may be kept secure by ensuring that all coordinate translation from the reader , in regard to a user selecting one or more of the user interface elements , is executed by the CPU  of the CPU card B, thus providing some protection against discovery and copying of the data stored on the card B. In order to provide such security, the user interface element objects (see Table 5) are stored in the storage means  of the CPU card B. The CPU card B can protect the data stored in the storage means  by read\/write protecting the storage means . Secondly, data returned by the CPU card B can be the result of a transformation executed by the CPU  and applied to a certain sequence of user interface elements  being selected. The CPU card B can itself store the sequence in the storage means  and release the necessary data only after the card B has detected that a valid sequence has been selected. For example, entry of a personal identification number by a user can be used to authenticate a user of the card B, prior to which other features provided by the CPU card B are locked out.","A third advantage of the CPU card B over the memory card A, and over other conventional memory cards and user interface card platforms, is that the CPU card B can offer secure connection between the CPU card B and a remote application executing on the computer system  or remote server computers , . The CPU card B can be configured with cryptographic functions together with a Public Key Infrastructure (PKI) to establish a secure communications channel between the CPU card B and a remote application, even when working with an unsecured reader .","Still another advantage of the CPU card B is that the CPU card B can be loaded with several different application programs, which can interact with one another. For example, card resident applications, such as secure online payment applications, can provide additional functionality to the standard user interface card application described below, allowing data generated by these applications to be associated with user interface elements.","The CPU card B preferably communicates with the reader  using the \u201cT=0\u201d protocol as defined in the \u201cInternational Standards Organisation (ISO)\/International Electrotechnical Commission (IEC) 7816-3: 1997 Standards, Part 3: Electronic Signals and Transmission Protocol\u201d, [hereinafter referred to as the \u2018ISO 7816-3 standards\u2019]. However, any other suitable bi-directional protocol (e.g. T=1) can be used for communications between the CPU card B and the reader . As will be described in detail below, the reader  issues different commands to the CPU card B depending on a user interface element  selected by the user. All commands issued to the CPU card B by the reader  are in an \u2018Application Protocol Data Unit (APDU)\u201d format as described in the \u201cISO\/IEC 7816-4 Standards, Part 4: Electronic Signals and Transmission Protocol\u201d [hereinafter referred to as the \u2018ISO 78164 standards\u2019]. The format and fields of the commands issued to the CPU card B will be described in detail below.","The CPU card B is configured to utilise any generic multi-application operating platform such as the \u2018Multos\u2019 operating system or \u2018JavaCard\u2019. However, the CPU card B can also utilise a single application operating platform.",{"@attributes":{"id":"p-0247","num":"0262"},"figref":["FIG. 23","FIG. 23"],"b":["2300","100","300","2300","1045","300","1046","2300","1045","2300","300","276","100","275","2313","1045","300","154","275","100"]},"The software executing on the CPU card B may be divided into two separate parts being an operating system and an application program. The operating system (hereinafter referred to as the \u2018Card Operating System\u2019) is configured to manage the interface between an \u2018application\u2019 program and the reader , where the card operating system forms the platform for the execution of applications on the CPU card B. The application program provides user interface functions of the CPU card B. The dashed line  in  indicates steps (i.e. steps  to ) in which the application program is active. The application program will be hereinafter referred to as the \u2018User Interface Card Resident Application\u2019.","As described above, user interface element objects as described herein, represent mapping data, which relate the user interface elements  directly imprinted on a surface of the CPU smart card B, to commands or addresses (eg: Uniform Resource Locators (URLs)). Mapping data includes (X,Y) coordinate pairs which typically define the size and location of user interface elements  on the CPU card B, as described above for the memory card A. The user interface element objects are stored in the storage means  of the CPU card B and are not able to be accessed by the reader .","The method  begins at step  where the CPU card B is powered up. The CPU card B can be powered up automatically upon being inserted into the reader  by a user or after a user touches the touch panel . At the next step , the user interface card resident application, stored in the storage means , is selected by the operating system executing within the CPU  upon the operating system receiving a command from the CPU  of the reader . According to the ISO 7816-4 standard, CPU card application programs are selected by a SELECT FILE command. The format of the SELECT FILE command sent by the CPU  of the reader  to the CPU card B is shown in Table 15 below.",{"@attributes":{"id":"p-0251","num":"0266"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Field","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CLA (Class)","0x00"]},{"entry":["INS (Instruction)","0xA4"]},{"entry":["P1 (Parameter 1)","0x04"]},{"entry":["P2 (Parameter 2)","0x0C"]},{"entry":["Lc (Command Data Length)","Length of user interface card resident"]},{"entry":[{},"application identifier"]},{"entry":["Data (Command Data)","User interface card resident application"]},{"entry":[{},"identifier"]},{"entry":["Le (Response Data Length)","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The SELECT FILE command can result in further commands sent by the reader  being re-directed to the user interface card resident application rather than the operating system. The SELECT FILE command will fail if the user interface card resident application does not exist in the storage means  on the CPU card B or cannot be selected for another reason. The process performed by the CPU card B in response to the SELECT FILE command will be explained in further detail below with reference to . A \u2018user interface card resident application identifier\u2019, referred to in Table 15, is an identifier associated with the user interface card resident application. The user interface card resident application identifier is configured in accordance to the guidelines set out in \u201cInternational Standards Organisation (ISO)\/International Electrotechnical Commission (IEC) 7816-5: 1994 Standards, Part 5: Numbering System and Registration Procedure for Application Identifiers\u201d [hereinafter referred to as the \u2018ISO 7816-5 standards\u2019]. The user interface card resident application identifier consists of a registered application provider identifier (RID) assigned by a standards authority, and a proprietary application provider extension (PIX) assigned by the application provider.","The method  continues at the next step  where the CPU  of the reader  reads a card header  associated with the card B. The card header  was described above with reference to  and is stored in the storage means  of the CPU card B. Step  is implemented using a READ BINARY command, according to the ISO 78164 standard, sent by the CPU . If the user interface card resident application is implemented in accordance with an ISO 78164 standard file system, as will be explained below, then the card header  is contained in an elementary file (EF) having an identifier 0x0000. Such an elementary file is implicitly selected when the user interface card resident application is selected at step . The format of the READ BINARY command invoked by the reader  is shown in Table 16 below.",{"@attributes":{"id":"p-0254","num":"0269"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 16"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0x00"]},{"entry":[{},"INS","0xB0"]},{"entry":[{},"P1","0x00"]},{"entry":[{},"P2","0x00"]},{"entry":[{},"Lc","0"]},{"entry":[{},"Data","Empty"]},{"entry":[{},"Le","0x13"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"As explained above, the card header  is 19 bytes long and if any error or warning identifiers are encountered at step , then the reader  will assume that the card header  cannot be read properly and register a bad card. The process performed by the CPU card B in response to the READ BINARY command will be explained in further detail below with reference to . At the next step , if the reader  is in low-power mode, then the method  proceeds to step . Otherwise, at the next step , the state of the smart card B is restored as will be explained in detail below. Step  is implemented using a RESTORE STATE command sent to the CPU  by the CPU  of the reader  and which is configured as an application protocol data unit having a format as shown in Table 17 below.",{"@attributes":{"id":"p-0256","num":"0271"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 17"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0x00"]},{"entry":[{},"INS","0x12"]},{"entry":[{},"P1","0x00 (other values are RFU)"]},{"entry":[{},"P2","0x00 (other values are RFU)"]},{"entry":[{},"Lc","Length of state code"]},{"entry":[{},"Data","State code"]},{"entry":[{},"Le","0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"After receiving the RESTORE STATE command with the parameters shown in Table 17 from the CPU  of the reader , the user interface card resident application executing within the CPU  checks that a present state code provided by the user interface resident card application is identical to a previous state code generated during a previous SAVE STATE command stored in non-volatile memory of the storage means  of the CPU card B and in the memory  of the reader . The previous state code is provided to the user interface card resident application in the \u2018Data\u2019 field of the RESTORE STATE command. The SAVE STATE command will be explained in further detail later in this document. If the present state code is not identical to the previous state code generated during a previous SAVE STATE command then previous state information stored in non-volatile memory of the storage means  is erased. Warning and error conditions shown in Table 18 below can also occur. However, if the present state code is identical to the previous state code received from the reader , then current volatile state information is replaced with the state information stored in the non-volatile memory of the storage means . The process performed by the CPU card B in response to the RESTORE STATE command will be explained in further detail below with reference to .",{"@attributes":{"id":"p-0258","num":"0273"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 18"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Value","Meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0x6300","Invalid code presented - state erased"]},{"entry":[{},"0x6B00","Incorrect parameters P1-P2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At step , the CPU  waits for an event such as the selection of a user interface element  in the form of a press or release. Upon selection of a user interface element  by the user, the method  proceeds to step  where the CPU  of the reader  sends an (X, Y) position coordinate pair associated with the selection to the CPU  of the CPU card B for processing. Step  is implemented using a PROCESS COORD command configured as an application protocol data unit sent to the CPU card B by the CPU  of the reader  and having a format shown in Table 19 below.",{"@attributes":{"id":"p-0260","num":"0275"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 19"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0x90"]},{"entry":[{},"INS","0x00 (PRESS) or 0x02 (RELEASE)"]},{"entry":[{},"P1","X co-ordinate"]},{"entry":[{},"P2","Y co-ordinate"]},{"entry":[{},"Lc","0"]},{"entry":[{},"Data","Empty"]},{"entry":[{},"Le","Maximum length of data to receive"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"As will be explained in further detail later in this document, the user interface card resident application processes the coordinate data by comparing the (X Y) position coordinate pair to the data stored in the storage means  of the microprocessor . The reader  typically sets the maximum length of data to receive (Le) field to a maximum possible value, 0x00 (which is used to encode x100). Data associated with a user interface element object, which is stored in the storage means  of the microprocessor  and which is associated with the (X Y) position coordinate pair sent from the reader , is returned by the user interface card resident application in response to the PROCESS COORD command. The format of the data returned by the user interface card resident application in response to the PROCESS COORD command is shown in Table 20 below. The process performed by the CPU card B in response to the PROCESS COORD command will be explained in further detail below with reference to .",{"@attributes":{"id":"p-0262","num":"0277"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 20"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Length","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["flags","1 byte","Flags specific to a matched User Interface Element"]},{"entry":["data","0 or more","Data associated with the matched User Interface"]},{"entry":[{},"bytes","Element"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Certain user interface element objects may be designated to be active only on a press or a release event corresponding to a user selection, and separate instruction codes can be used to allow the reader  to distinguish one from the other. If the (X, Y) position coordinate pair supplied by the reader  is in the range [(0,0), (127, 255)] but no data is found to match the position coordinate data, then the \u201cflags\u201d field, as shown in table 20, is constructed from global button flags specified in the card header . Further, the data field is returned empty and one of the error identifiers shown in Table 21 below may also be returned by the user interface card resident application.",{"@attributes":{"id":"p-0264","num":"0279"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 21"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x6985","Data must be encrypted, but no session key available, or session"]},{"entry":[{},"key invalid"]},{"entry":["0x6A82","There is no user interface card image loaded (File not found)"]},{"entry":["0x6A86","The co-ordinates provided are outside the allowable range"]},{"entry":[{},"(Incorrect P1-P2)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"If the CPU  has not received any events for a predetermined period (e.g. one minute), at step , then the method  proceeds to step  where the user interface card resident application executing within the CPU  saves current state information in non-volatile memory of the storage means . Step  is implemented using a SAVE STATE command sent from the reader  and which is configured as an application protocol data unit having a format shown in Table 22 below.",{"@attributes":{"id":"p-0266","num":"0281"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 22"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0x90"]},{"entry":[{},"INS","0x10"]},{"entry":[{},"P1","0x00"]},{"entry":[{},"P2","0x00"]},{"entry":[{},"Lc","0"]},{"entry":[{},"Data","Empty"]},{"entry":[{},"Le","Maximum length of random data to be generated"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"After receiving the SAVE STATE command with correct parameters the user interface card resident application executing within the CPU  saves all volatile state information to non-volatile memory of the storage means  and then generates a random state code of a specified length. The user interface card resident application also returns the state code to the reader . The state code is saved in the memory  of the reader  in order to use the RESTORE STATE command described above. The process performed by the CPU card B in response to the SAVE STATE command will be explained in further detail below with reference to . One of the error identifiers shown in Table 23 below may also be returned to reader  by the user interface application upon receiving the SAVE STATE command.",{"@attributes":{"id":"p-0268","num":"0283"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 23"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x6300","State saved, but no random number returned"]},{"entry":["0x6B00","Incorrect parameters P1\u2013P2"]},{"entry":["0x6CXX","Incorrect Le specified. XX specifies recommended length."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The error identifier 0x6CXX shown in Table 23 is returned to the reader  by the user interface card resident application executing within the CPU  when the CPU card B is unwilling to accept the requested state code length because it is too short. The user interface card resident application can also provide a value corresponding to the shortest appropriate length along with the error condition. Alternatively, if the requested length is longer than the CPU card B can handle, then the user interface card resident application generates the longest code that the CPU card B is configured for and returns a value corresponding to the longest code. A typical length for the state code is between eight and sixteen bytes. However, the state code can be of any length up to two hundred and fifty six bytes.","The method  continues at the next step , where the CPU card B is powered down by the operating system executing in the CPU . Then after a predetermined period, the CPU  of the reader  assigns the reader B to low power mode at the next step . At the next step , the reader  is woken up and the method  then returns to step . The reader  can be woken up automatically by the CPU , for example, upon a CPU card B being inserted into the reader  as shown in  and\/or by a user touching the touch panel .","The user interface card resident application executing within the CPU  of the CPU card B operates in one of two different operating modes (i.e. Standard Input Mode and Buffered Input Mode), which affect the response of the user interface card resident application to a touch on the touch panel .","Standard input mode is the default mode. In standard input mode, the CPU  of the CPU card B returns the data field associated with a given user interface element  if a match is found in the storage means , in response to a PROCESS COORD command sent from the reader . Conversely, if a match is not found, the CPU  returns default data. The returned information may be inline data (i.e. stored within the definition of the particular user interface element), file data (i.e. stored within a file in a file system implemented on the CPU card B), data indicating a transition to buffered input mode or data returned by a delegated application, as will be explained in more detail below.","When the user interface card resident application is in buffered input mode, the PROCESS COORD command does not result in the return of any data to the reader  in response to the selection of a user interface element . Instead, a default flags field is returned by the CPU  to the CPU  of the reader  in response to the selection of a user interface element . Certain user interface elements are designated as input user interface elements, which, when pressed, cause an associated object identifier to be stored in a temporary input buffer.","Additionally, four special user interface elements may be defined. One of these user interface elements  is the \u201cOK button\u201d , which serves to commit the temporary input buffer and perform some action on the buffered data. The other special user interface elements are the \u201ccancel button\u201d , the \u201cbackspace button\u201d  and the \u201cclear button\u201d , which represent \u201cCancel\u201d, \u201cBackspace\u201d and \u201cClear\u201d roles, respectively. A user interface element  configured as a \u201cCancel\u201d button, when selected, clears an input buffer of the CPU card B and returns the user interface card resident application to standard mode, in exactly the same state as the user interface card resident application was in when buffered input mode was activated. A user interface element configured as a \u201cBackspace\u201d button, when selected, clears a reference to a last entered user interface element from an active buffer of the CPU card B. If the buffer is empty, no action is taken. Finally, a user interface element  configured as a \u201cClear\u201d button, when selected, removes references to all user interface elements  contained within the input buffer of the CPU card B. If the buffer is already empty, no action is taken.","The properties of a particular buffered input session are associated with a buffer descriptor, which is read from data stored on the CPU card B as will be described later in this document. The buffer descriptor has the structure shown in Table 24 below:",{"@attributes":{"id":"p-0276","num":"0291"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 24"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Length","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Flags","1 byte","Various parameters about the buffer descriptor."]},{"entry":[{},{},"See Table 25."]},{"entry":["Action","1 byte","A code, indicating the action to be performed"]},{"entry":[{},{},"after the OK button is pressed. See Table 26."]},{"entry":["Butlen","1 byte","The maximum number of bytes that can be stored"]},{"entry":[{},{},"in the buffer."]},{"entry":["1_buttons","1 byte","The length of the subsequent \u201cbuttons\u201d field."]},{"entry":[{},{},"Must be equal to 4 or more bytes, in order to"]},{"entry":[{},{},"accommodate the special user interface"]},{"entry":[{},{},"element definitions."]},{"entry":["Buttons","1_buttons","An array storing the identifiers of the user"]},{"entry":[{},{},"interface elements that can be used as buffer"]},{"entry":[{},{},"elements. See Table 27."]},{"entry":["1_data","1 byte","The length of the subsequent \u201cdata\u201d field."]},{"entry":[{},{},"Its value depends on the specified action."]},{"entry":["Data","1_data","Other data specific to the requested action."]},{"entry":["Output","Variable","If the buffered input mode is invoked by pressing"]},{"entry":[{},{},"a user interface element on the card, this data is"]},{"entry":[{},{},"sent to the reader as data when that user interface"]},{"entry":[{},{},"element is pressed. This field may be empty."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0277","num":"0292"},"figref":["FIG. 49(","FIG. 49(","FIG. 49(","FIG. 49("],"i":["a","a","a","b"],"b":["4900","4900","4901","154","4901","4902","4901","4903","4900","4905","4900","100","100","4907","4907","4901","4911","4905"]},"The flags for the flags field of the buffer descriptor structure of Table 24 are described in Table 25 below:",{"@attributes":{"id":"p-0279","num":"0294"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 25"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Circular","0x01","In a circular buffer, a character that overflows the buffer"]},{"entry":[{},{},"replaces the oldest character. If this flag is not set,"]},{"entry":[{},{},"overflowing characters are ignored."]},{"entry":["expand","0x02","Normally, buffer data is stored and processed as the"]},{"entry":["data",{},"Object identifiers corresponding to the user interface"]},{"entry":[{},{},"elements that were pressed. If this flag is set, the buffer"]},{"entry":[{},{},"data is expanded to the contents of the user interface"]},{"entry":[{},{},"elements that were pressed before being processed."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The actions described in Table 26 below are defined for the action field of the structure of Table 24:",{"@attributes":{"id":"p-0281","num":"0296"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 26"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","Value","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Output","0x00","An output buffer."]},{"entry":[{},"Passcode","0x10","A passcode buffer."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The \u201cbuttons\u201d field has the format shown in Table 27 below:",{"@attributes":{"id":"p-0283","num":"0298"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 27"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Length","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Ok_id","1 byte","The identifier of the \u201cOK button\u201d."]},{"entry":["Cancel_id","1 byte","The identifier of the \u201cCancel button\u201d."]},{"entry":["Bksp_id","1 byte","The identifier of the \u201cBackspace button\u201d."]},{"entry":["Clear_id","1 byte","The identifier of the \u201cClear button\u201d."]},{"entry":["Input_id","Variable","An array storing the identifiers of the user"]},{"entry":[{},{},"interface elements that can be used as input"]},{"entry":[{},{},"elements."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The \u201cok_id\u201d field shown in Table 27 stores a valid object identifier. The other three special user interface elements do not need to be specified and can be set to a default identifier (e.g. defined by the value 0).","The user interface card resident application executing within the CPU  of the CPU card B can be configured to begin in buffered input mode when the application is initialised. This is enabled by setting up an appropriate buffer descriptor in a file with a certain identifier (i.e. 0x0002), as an \u201cinitial\u201d buffer descriptor (as described above in Table 28). A typical use of this feature is to disable all of the features of the CPU card B until a pass-code (e.g. a personal identification number) is entered. As an example, the pass-code can be in the form of a series of user interface element objects associated with user interface elements  associated with an image (e.g. a human face) formed on a surface of a CPU card. For example,  shows a CPU card E depicting an image  of a face. In this example, the card E includes ten regions (e.g. ), shown in phantom lines which define user interface elements arbitrarily positioned on the surface of the user interface card E. However, in this case the user interface elements defined by the regions (e.g. ) are not visible to a user of the card E. The user's pass-code can be made up, for example, of the regions ,  and  adjacent the left-eye, the left-side of the mouth and the right-eye, respectively, of the image , and the user can enter the pass code by selecting these regions ,  and  in sequence.","When a buffer descriptor is configured to have an action field of \u201coutput\u201d, as shown in Table 26, an associated buffer is referred to as the output buffer. When a user interface element (e.g. user interface element ) configured as an \u201cOK button\u201d (i.e. having the function described above in section 2.3.1.2) is selected, a response is created by appending buffered data to what is stored in the \u201cdata\u201d field of the buffer descriptor associated with the user interface element  and stored in the storage means . If the \u201cexpand data\u201d flag is set, the buffered object identifiers are replaced with the data associated with the user interface element that the object identifiers represent.","When a user interface element (e.g. the user interface element ) configured as a \u201cCancel button\u201d (i.e. having the function described above in section 2.3.1.2) is selected, only the header  is returned. The user interface card resident application can be configured to enter standard input mode after the user interface elements configured as \u201cOK\u201d (e.g. ) and configured as \u201cCancel\u201d (e.g. ) are selected.","When a buffer descriptor is configured to have an action field of \u201cpasscode\u201d, as shown in Table 26, the associated buffer is a Pass-code buffer. The \u201cdata\u201d field of the buffer descriptor as shown in Table 24 stores the identifier of a file containing the required pass-code for a particular CPU card B. When the user interface element  configured as an \u201cOK\u201d button is selected, a string stored in a temporary input buffer in the storage means  is compared against a string stored in the pass-code file corresponding to the identifier. A standard message can be configured to indicate whether or not a correct pass-code was entered by a user. The CPU card B exits buffered input mode only if a pass-code match occurs.","For security, a cancel function should not be defined in a pass-code buffer descriptor. The pass-code buffer descriptor is preferably specified as an initial buffer.","An international standards organisation (ISO) file system can be implemented on the CPU card B to provide users of the CPU card B with access to certain information stored in the storage means  of the CPU card B. Such a file system preferably has a flat directory structure containing transparent elementary files (EF) referenced by 16-bit identifiers in accordance with ISO 7816-4 standards. However, a person skilled in the relevant art would realise that any suitable file system and corresponding directory structure can be used on the CPU card B.","Table 28 below lists elementary files and associated identifiers, which can be configured on the CPU card B.",{"@attributes":{"id":"p-0292","num":"0307"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 28"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["File ID","File Name","File Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x0000","User","The header portion of the user interface card"]},{"entry":[{},"interface"]},{"entry":[{},"card header"]},{"entry":["0x0001","User","The data portion of the user interface card"]},{"entry":[{},"interface"]},{"entry":[{},"card data"]},{"entry":["0x0002","Initial","A buffer descriptor indicating that the card"]},{"entry":[{},"buffer","should be initially in buffered input mode"]},{"entry":[{},"descriptor"]},{"entry":["0x0008","Card key","A cryptographic key used by the CPU card (for"]},{"entry":[{},{},"example, to facilitate secure transmission of a"]},{"entry":[{},{},"new session key)"]},{"entry":["0x0009","Session","A previously negotiated cryptographic key used to"]},{"entry":[{},"key","encrypt data destined for the remote application"]},{"entry":["0x0101","SL1 key","A cryptographic key used to authenticate access"]},{"entry":[{},{},"to security level 1"]},{"entry":["0x0102","SL2 key","A key used to authenticate access to security"]},{"entry":[{},{},"level 2"]},{"entry":["0x0103","SL3 key","A key used to authenticate access to security"]},{"entry":[{},{},"level 3"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"A \u2018User Interface Card Header\u2019 file having identifier (0x0000), as shown in Table 28, is implicitly selected when the user interface card resident application executing on the CPU card B is activated (e.g. at step  of the method ). The data in the User Interface Card Header file would typically conform to the format  as shown in .","The data associated with a single file is stored in one contiguous area of non-volatile memory in the storage means  of the CPU card B. Each file is assigned a maximum length, and the data region associated with that file is preferably configured to provide enough space to store a longest possible file.","A file directory can be used to store certain information about each file present in the file system where the file directory consists of a list of entries beginning at address 0x10 of a static data area in the storage means . A two-byte word at address 0x00 can be used to represent the total number of files currently present in the directory. The region between 0x02 and 0x10 of the static data area is configured as an array of pointers to the directory entries for files 0x0000 through 0x0006, providing for quicker access to these particular files. Each directory entry is 25 bytes long, and consists of the following fields as shown in Table 29 below:",{"@attributes":{"id":"p-0296","num":"0311"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 29"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Length","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Id","2 bytes","The file's two-byte ISO 7816 identifier"]},{"entry":["Flags","2 bytes","Flags associated with the file"]},{"entry":["Offset","2 bytes","The offset of the first byte of the file from the"]},{"entry":[{},{},"bottom of the static data area"]},{"entry":["Read level","1 byte","The minimum security level allowed to read the file"]},{"entry":["Write","1 byte","The minimum security level allowed to write the"]},{"entry":["level",{},"file"]},{"entry":["Length","2 bytes","The current length of the file"]},{"entry":["Maxlen","2 bytes","The maximum possible length of the file"]},{"entry":["RFU","4 bytes","Currently unused - reserved for future use"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The flags associated with the file are a combination of zero or more of the following values shown in Table 30:",{"@attributes":{"id":"p-0298","num":"0313"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 30"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Value","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x80","erasable","Parts of the file may be erased if write permissions"]},{"entry":[{},{},"satisfied"]},{"entry":["0x40","hide length","Do not report the length of the file when selected,"]},{"entry":[{},{},"unless read permissions are already satisfied"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The elementary files of the ISO file system can be accessed through the following commands.","When selecting a file stored in the storage means  of the card B, the user can receive a structure containing file control information. This structure preferably complies with Table 2 of the ISO 7816-4 standard, which includes the following:","(i) File length\u2014this can be suppressed by the CPU  if a security level of the CPU card B is lower than a corresponding read level for the file, as will be explained in further detail later in this document;","(ii) File descriptor byte\u2014as outlined in Table 3 of the ISO 7816-4 standard;","(iii) File identifier; and","(iv) File security attributes\u2014can be configured as a two byte number where a first byte can describe a read security level of a file and a second byte can describe a write level for the file.","The CPU card B can be configured such that a user can select a file stored in the storage means  for viewing or editing. The file can be associated with one of the user interface elements  (e.g. the user interface element ). In this case, upon selecting the associated user interface element , the CPU  of the reader  sends a SELECT FILE command to the user interface card resident application executing within the CPU . The SELECT FILE command is configured as an application protocol data unit and has a format as shown in Table 31 below. The SELECT FILE command is a subset of the specification for such a command as outlined in the ISO 7816-4 standards.",{"@attributes":{"id":"p-0306","num":"0321"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 31"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0x00"]},{"entry":[{},"INS","0xA4"]},{"entry":[{},"P1","0x00 (select MF, DF, or EF)"]},{"entry":[{},{},"0x02 (select EF under current DF)"]},{"entry":[{},{},"Both 0x00 and 0x02 produce equivalent results"]},{"entry":[{},"P2","0x00 (select first or only occurrence, return File Control"]},{"entry":[{},{},"Information (FCI)"]},{"entry":[{},{},"0x0C (select first or only occurrence, return no data)"]},{"entry":[{},"Lc","2"]},{"entry":[{},"Data","two-byte file identifier"]},{"entry":[{},"Le","maximum length of FCI buffer (or 0, if no FCI requested)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"If the two-byte file identifier as shown in Table 31 points to a valid file, then that file becomes an active file. File control information (FCI) is returned to the reader  by the user interface card resident application if the P2 parameter is set to \u20180x00\u2019. The error and warning identifiers as seen in Table 32 below can also be returned by the user interface card resident application upon the user interface card resident application receiving a SELECT FILE command.",{"@attributes":{"id":"p-0308","num":"0323"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 32"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Value","Meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0x6283","File exists, but empty"]},{"entry":[{},"0x6A81","Incorrect parameters P1-P2"]},{"entry":[{},"0x6A82","File not found"]},{"entry":[{},"0x6A87","Lc incorrect"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Up to two hundred and fifty six bytes can be read from a selected elementary file stored in the storage means  upon the reader  sending a READ BINARY command to the user interface card resident application executing within the CPU . If the end of a file is reached or exceeded then all available bytes of the file are read and a warning code is returned to the reader  by the user interface card resident application. The READ BINARY command is configured as an application protocol data unit and has a format as shown in Table 33 below.",{"@attributes":{"id":"p-0310","num":"0325"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 33"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0x00"]},{"entry":[{},"INS","0xB0"]},{"entry":[{},"P1","MSB of offset, must be <0x80 since"]},{"entry":[{},{},"short EF addressing not allowed"]},{"entry":[{},"P2","LSB of offset"]},{"entry":[{},"Lc","0"]},{"entry":[{},"Data","Empty"]},{"entry":[{},"Le","Number of bytes to be read"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The error and warning identifiers as seen in Table 34 below can also be returned to the CPU  of the reader  by the user interface card resident application upon the user interface card resident application receiving a READ BINARY command.",{"@attributes":{"id":"p-0312","num":"0327"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 34"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Value","Meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0x6282","End of file reached"]},{"entry":[{},"0x6982","File's read permissions are not satisfied"]},{"entry":[{},{},"by current security level"]},{"entry":[{},"0x6A81","Incorrect parameters (P1 >= 0x80)"]},{"entry":[{},"0x6B00","offset beyond end of file"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"WRITE BINARY and UPDATE BINARY commands are used to write one or more bytes to an elementary file stored in the storage means  of the CPU card B. The WRITE BINARY and UPDATE BINARY commands are configured as application protocol data units having a format as shown in Table 35 below.",{"@attributes":{"id":"p-0314","num":"0329"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 35"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0x00"]},{"entry":[{},"INS","0xD0 (WRITE) or 0xD6 (UPDATE)"]},{"entry":[{},"P1","MSB of offset, must be <0x80 since"]},{"entry":[{},{},"short EF addressing not allowed"]},{"entry":[{},"P2","LSB of offset"]},{"entry":[{},"Lc","Number of bytes to write"]},{"entry":[{},"Data","Bytes to write"]},{"entry":[{},"Le","0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Up to two hundred and fifty-five bytes of data can be written to a selected elementary file stored in the storage means  using the WRITE BINARY and UPDATE BINARY commands. When writing to file offsets where data is already present, that data is replaced with the new data specified in the WRITE BINARY and UPDATE BINARY commands. If the end of a file is exceeded, the length of the file is extended to accommodate the entire data string being written by the WRITE BINARY and UPDATE BINARY commands, unless the maximum length specified in the properties of the file being written to is exceeded.","The error and warning identifiers as seen in Table 36 below can be returned to the CPU  of the reader  by the user interface card resident application upon the user interface card resident application receiving a WRITE BINARY and UPDATE BINARY command.",{"@attributes":{"id":"p-0317","num":"0332"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 36"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x6381","Maximum length exceeded - full length not written"]},{"entry":["0x6982","File's write permissions are not satisfied by current security level"]},{"entry":["0x6A81","Incorrect parameters (P1 >= 0x80)"]},{"entry":["0x6B00","Offset beyond end of file"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"An ERASE BINARY command can be sent to the user interface card resident application by the reader  to truncate a file stored in the storage means  of the CPU card B, according to an offset indicated by the parameters of the ERASE BINARY command.","The format of the ERASE BINARY command is shown in Table 37 below:",{"@attributes":{"id":"p-0320","num":"0335"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 37"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0x00"]},{"entry":[{},"INS","0x0E"]},{"entry":[{},"P1","MSB of offset, must be <0x80 since"]},{"entry":[{},{},"short EF addressing not allowed"]},{"entry":[{},"P2","LSB of offset"]},{"entry":[{},"Lc","0"]},{"entry":[{},"Data","Empty"]},{"entry":[{},"Le","0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The ERASE BINARY command truncates a file from the offset indicated by the parameters P1 and P2. Further, the following error and warning identifiers can be returned by the user interface card resident application upon receiving an ERASE BINARY command, as shown in Table 38 below:",{"@attributes":{"id":"p-0322","num":"0337"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 38"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Value","Meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0x6981","File is not erasable"]},{"entry":[{},"0x6982","File's write permissions are not satisfied"]},{"entry":[{},{},"by current security level"]},{"entry":[{},"0x6A81","Incorrect parameters (P1 >= 0x80)"]},{"entry":[{},"0x6B00","Offset beyond end of file"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At any given time, the user interface card resident application is executing at a certain security level on the microprocessor  of the CPU card B. Four security levels are described herein. However, up to thirty-two security levels can be implemented on the CPU card B. The user interface card resident application executing within the CPU  is configured to begin at security level zero, as defined in Table 39 below:",{"@attributes":{"id":"p-0324","num":"0339"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 39"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["SL","User Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","Default","Restricted access, normal operation within the reader."]},{"entry":["1","Application","Used by the remote application to establish a session"]},{"entry":[{},{},"key through a trusted set-top box or reader."]},{"entry":["2","Owner","Used by the user of the CPU card to customise data"]},{"entry":[{},{},"such as personal details, passcode etc within a file."]},{"entry":["3","Issuer","Used by the card's issuer for administrative purposes."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"To increase the security level of the CPU card B the user follows the authentication process as will be described below with reference to . In accordance with the described authentication process, the CPU  of the card B provides random challenge data in response to a GET CHALLENGE command. The challenge data is provided by the CPU  for subsequent encryption and returned to the CPU  with an EXTERNAL AUTHENTICATE command as will be described below with reference to section 2.4.2.2.","The user interface card resident application decrypts the encrypted challenge data according to a key provided by a user and compares this with the original challenge. If the decrypted challenge matches the original challenge then a user is authenticated and the CPU card B is set to a required security level as requested by the user. Otherwise, the CPU  denies permission to increase the security level of the CPU card B.","Generally, no authentication is required to decrease the security level of the CPU card B.","Each file of a file system implemented on the CPU card B is associated with a read security level, and a write security level. The READ BINARY, WRITE BINARY, UPDATE BINARY and ERASE BINARY commands sent to the CPU card B from the reader  will only succeed if the current security level of the CPU card B is greater than or equal to the appropriate security level associated with the selected file.","The security attributes of a file are encoded in file control information (FCI) as a two-byte field marked by a tag \u201886\u2019, which is associated with a particular file. The first byte represents the read security level, while the second byte represents the write security level associated with the file. The following commands are sent to the CPU  of the CPU card B by the CPU  of the reader  during the process of changing the security level of the CPU card B.","The PROCESS COORD command can be utilised to effectively override the security level of a file. A file that is referenced in a user interface element object specified by the P1 and P2 co-ordinates of an PROCESS COORD command can be accessed without the card B being set to the required security level, if a user interface element  corresponding with the file (i.e. the user interface element object) is pressed or released. The file can only be accessed in this manner through the mechanisms provided by the PROCESS COORD command. However, this enables the issuer of the card B to provide limited access to the contents of a file while still protecting the file from general use.","The format of the GET CHALLENGE command follows a subset of a similar command specification in the ISO 78164 standard, as shown in Table 40.",{"@attributes":{"id":"p-0332","num":"0347"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 40"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0x00"]},{"entry":[{},"INS","0x84"]},{"entry":[{},"P1","0x00"]},{"entry":[{},"P2","0x00"]},{"entry":[{},"Lc","0"]},{"entry":[{},"Data","Empty"]},{"entry":[{},"Le","Variable (must be positive"]},{"entry":[{},{},"multiple of 8)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A number of bytes (i.e., determined by the Le field) of challenge data are returned by the CPU  of the CPU card B in response to the GET CHALLENGE command. Further, the error and warning identifiers as shown in Table 41 can also be returned by the CPU  in response to the GET CHALLENGE command.",{"@attributes":{"id":"p-0334","num":"0349"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 41"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Value","Meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0x6A81","Incorrect parameters"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"If the security level requested by a user is greater than the security level that the CPU card B is currently set to, then an EXTERNAL AUTHENTICATE command having a format shown in Table 42 below, is sent to the CPU . The ETERNAL AUTHENTICATE command attempts to decrypt the security level data stored in the storage means  using a key associated with the requested security level. If the EXTERNAL AUTHENTICATE command is successful, then the security level of the CPU card B is changed in accordance with the request made by the user. Conversely, if the requested security level is less than or equal to the security level that the CPU card B is currently set to then the security level is changed without attempting to authenticate the user. A nominal number of attempts (e.g. three) can be allowed before a fresh challenge is requested by the CPU .",{"@attributes":{"id":"p-0336","num":"0351"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 42"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Field","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLA","0 \u00d7 00"]},{"entry":[{},"INS","0 \u00d7 82"]},{"entry":[{},"P1","0 \u00d7 00"]},{"entry":[{},"P2","0 \u00d7 80 & S, where S is a 5-bit number"]},{"entry":[{},{},"representing the requested SL"]},{"entry":[{},"Lc","Length of key to encrypt challenge"]},{"entry":[{},"Data","Encrypted challenge"]},{"entry":[{},"Le","0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The error and warning identifiers shown in Table 43 can also result from an EXTERNAL AUTHENTICATE command being sent to the CPU card B.",{"@attributes":{"id":"p-0338","num":"0353"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 43"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0 \u00d7 63CX","Authentication failed: X more attempts are allowed before a"]},{"entry":[{},"new challenge must be issued"]},{"entry":["0 \u00d7 6700","Lc inconsistent with parameters (must be equal to 64 if"]},{"entry":[{},"authentication required)"]},{"entry":["0 \u00d7 6985","No challenge data available: GET CHALLENGE command"]},{"entry":[{},"must first be issued"]},{"entry":["0 \u00d7 6A81","Invalid parameters P1-P2"]},{"entry":["0 \u00d7 6A88","Key file for referenced security level not available"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In one example of the security architecture described herein, the CPU card B can contain some information about its user. The information can be associated with one or more user interface elements. For example, one user interface element object can store the user's home address, while another user interface element object stores the user's credit card number. If the issuer of the CPU card B wishes to make the data associated with both user interface element objects easy to modify at a later date without having to change the mapping data associated with the user interface element objects, both pieces of user information can be stored in separate files in the memory  of the card B, and references to these files can stored in a mapping data file associated with the user interface element objects.","If the user's place of residence were to change, the user can be allowed to change the address by giving the associated file a write security level of 2, so that the user must authenticate themselves before being able to change the information. However, if the user desires to change the credit card number stored on the card B, the issuer might require that the user bring the card B to a central authority, for example, together with the new credit card, at which point the issuer can update the credit card number on the CPU card B. Such a file can be created with a write security level of 3, denying the user the opportunity to modify the file, but allowing the issuer to do so.","The commands and classes referred to herein are configured in accordance with the ISO 7816-4 standard. Whenever a command configured as an application protocol data unit is received by the user interface card resident application executing within the CPU , an instruction pointer is set to zero. The user interface card resident application analyses a header associated with the received application protocol data unit to determine whether a valid command has been received. If valid, a process corresponding to the command is executed by the CPU  of the CPU card B. Alternatively, if the command is not valid then an error identifier (e.g. \u20180x6E00\u2019 representing \u2018class not supported\u2019) is returned to the CPU  of the reader .","A main process , as shown in , is executed by the CPU  upon a command being issued to the user interface card resident application by the reader . The process  checks whether or not the CPU card B has been initialised and if not, then an initialisation process, as seen in , is executed by the CPU . The initialisation process will be explained in detail below.","The main process  is implemented as software, preferably as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . The process  begins at step  upon the user interface card resident application receiving a command. If an \u2018Initialised Flag\u2019 stored in the storage means  is set then the process  continues at the next step . Otherwise, the process  proceeds to step , where the CPU  executes the initialisation process  in order to set the user interface card resident application to a standard or buffered input mode. At step , if the class of the command is \u20180x90\u2019 then the process  proceeds to step  where a proprietry instruction process is executed by the CPU , on all commands not conforming to ISO 7816-4 standard interfaces but which are specific to the user interface card resident application. Otherwise the process  proceeds to step  where if the class of the command is \u20180x00\u2019 then the process  proceeds to step . The proprietary instruction process executed at step  will be explained in detail below with reference to . At step , an ISO instruction process is executed by the CPU  on all commands not conforming to ISO 7816-4 standard interfaces. The ISO instruction process will be explained in more detail below with reference to . If the class of the command is not \u20180x00\u2019, at step , then the process  proceeds to step , where a \u2018bad class\u2019 error identifier is returned to the CPU  of the reader  by the CPU  of the CPU card B and the process  concludes.",{"@attributes":{"id":"p-0344","num":"0359"},"figref":"FIG. 25","b":["2405","275","100","275","259","276","2405","2501","276","2405","2503","2501","2405","2505","100","2505","276","275","2405"]},{"@attributes":{"id":"p-0345","num":"0360"},"figref":"FIG. 26","b":["2407","2407","275","259","276"]},"The process of step  begins at sub-step , where if the CPU  determines that the command received by the user interface card resident application is 0x12 representing a RESTORE STATE command then the process proceeds to sub-step . Otherwise, the process of step  proceeds to sub-step  where if the CPU  has saved the state information in the storage means  then the process proceeds to sub-step .","At sub-step , a restore state process is executed by the CPU . The restore state process is configured to erase previous state information stored in non-volatile memory of the storage means  if the present state code is not identical to the previous state code generated during a previous SAVE STATE command. The restore state process will be described in more detail below with reference to .","At sub-step , the state information and state code are erased from the non-volatile memory of the storage means . The process of step  continues at the next sub-step  where if the command received by the user interface card resident application is 0x10 representing a SAVE STATE command, then the process continues at sub-step . Otherwise, the process of step  continues at sub-step . At sub-step , a save state process is executed by the CPU . The save state process saves all volatile state information to non-volatile memory of the storage means  and then generates a random state code of a specified length. The save state process will be described in more detail below with reference to .","At sub-step , if the command is 0x00 or 0x02 representing a PROCESS COORD coordinate command then the process of step  proceeds to sub-step  where a process coordinate process is executed by the CPU . The process coordinate process searches the data stored on the storage means  to determine a user interface element object corresponding to the coordinates provided by the reader  upon a user selecting one of the user interface elements . The process coordinate process will be described below with reference to . Otherwise, the process of step  proceeds to sub-step  where a bad instruction error identifier is returned to the CPU  of the reader  by the user interface card resident application executing within the CPU .",{"@attributes":{"id":"p-0350","num":"0365"},"figref":["FIG. 27","FIG. 42"],"b":["2411","2400","2411","275","300","2411","275","259","276","2411","2701","275","100","2703","2411","2705","2703","275"]},"At sub-step , if the command received by the CPU  of the CPU card B is 0xB0, representing a READ BINARY command then the process proceeds to sub-step . Otherwise, the process of step  proceeds to sub-step . At sub-step  a read binary process is executed by the CPU  to read data from a currently selected elementary file. The read binary process will be described in more detail below with reference to .","The process of step  continues at sub-step , where if the command received by the CPU  of the CPU card B is 0xD0 or 0xD6, representing a WRITE BINARY command or an UPDATE BINARY command, respectively, then the process proceeds to sub-step . Otherwise, the process of step  proceeds to sub-step . At sub-step  a write binary process is executed to write data to a currently selected elementary file. The write binary process will be described in more detail below with reference to .","At sub-step , if the command received by the CPU  of the CPU card B is 0x0E, representing an ERASE BINARY command then the process proceeds to sub-step . Otherwise, the process of step  proceeds to sub-step . At sub-step  an erase binary process is executed by the CPU  to truncate a currently selected elementary file depending on the parameters received with the ERASE BINARY command. The erase binary process will be described in more detail below with reference to .","The process of step  continues at sub-step , where if the command received by user interface card resident application executing within the CPU  of the CPU card B is 0x84, representing a GET CHALLENGE command then the process proceeds to sub-step . Otherwise, the process of step  proceeds to sub-step . At sub-step  a get challenge process is executed by the CPU  to provide challenge data in order to allow the security level of the CPU card B to be changed. The get challenge process will be described in more detail below with reference to .","At sub-step , if the command received by the CPU  of the CPU card B is 0x82, representing an EXTERNAL AUTHENTICATE command then the process proceeds to sub-step . Otherwise, the process of step  proceeds to sub-step . At sub-step  an external authenticate process is executed by the CPU  to decrypt presented challenge data using a key associated with a requested security level. The external authenticate process will be described in more detail below with reference to .","At sub-step  a bad instruction error identifier is returned by the user interface card resident application executing within the CPU  and the process of step  concludes.",{"@attributes":{"id":"p-0357","num":"0372"},"figref":["FIG. 28","FIG. 26","FIG. 29"],"b":["2615","275","275","154","276","100","300","308","2615","275","259","276","2615","2801","1045","300","2805","2615","2803","275","276","2803","2615","2809","2807","2615","2813","2803","2813","1045","300","2815","2615","2803","2815","275","154"]},"The process of sub-step  continues at the next sub-step  where an output object data process is executed by the CPU . The output object data process is executed when the CPU  has to output any data to the reader  and will be described in more detail below with reference to .","At sub-step , the output flags associated with a default user interface element are set and the process proceeds to sub-step .","The process of sub-step  concludes at sub-step  where an invalid (X,Y) error is returned to the CPU  of the reader  by the user interface card resident application executing within the CPU .","The user interface element handler process of  is executed at sub-step  of the process coordinate process, in order to examine a user interface element object associated with a selected user interface element . The process of sub-step  determines what action the CPU  should take in response to the (X,Y) coordinates received by the user interface card resident application at step . The process of sub-step  is preferably implemented as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . The process of sub-step in  begins at sub-step  where if the CPU card B is in buffered input mode then the process proceeds to sub-step . Otherwise, the process of sub-step  proceeds to sub-step . At sub-step  if the input event is a press event, then the process of sub-step  proceeds to sub-step  where a buffered input user interface element handler process is executed by the CPU . Otherwise, the process of sub-step  proceeds to sub-step . The buffered input user interface element handler process is executed to append a user interface element selection to an input buffer and will be described in more detail below with reference to .","At sub-step , if the input event is a press event (i.e. associated with a user interface element  selection), then the process of sub-step  proceeds to sub-step . Otherwise, the process proceeds to sub-step . At sub-step , if a \u201cno press\u201d flag associated with the received command is set, then the process proceeds to sub-step  where the output flags associated with a default user interface element are set and the process of sub-step  concludes. At sub-step  if a \u201cno release\u201d flag is set then the process proceeds to sub-step . Otherwise, the process of sub-step  proceeds to sub-step .","The process of sub-step  continues at sub-step  where if the data associated with the selected user interface element  is inline data (as described above) then the process of step  proceeds to sub-step . Otherwise, the data associated with the selected user interface element  is file data and the process proceeds to sub-step . At sub-step , the inline data associated with the selected user interface element  is read by the CPU . At sub-step , an inline header associated with the data is stored in an output buffer. The process of sub-step  continues at sub-step  where the data associated with the selected user interface element  is read from an associated file stored in the storage means . At the next sub-step , the user interface element object type associated with the selected user interface element  is determined. If the user interface element object is a delegator object then the process of sub-step  proceeds to sub-step  where a delegator user interface element handler process is executed by the CPU . The delegator user interface element handler process will be described in more detail below with reference to . Alternatively, if the object associated with the selected user interface element is a buffer user interface element object, then the process of sub-step  proceeds to sub-step . At sub-step , a buffer user interface element handler process, which will be explained below in more detail with reference to , is executed by the CPU . Still further, if the object associated with the selected user interface element  is a text user interface element object, then the process of sub-step  proceeds to sub-step . At sub-step , a text user interface element handler process, which will be explained below with reference to , is executed, by the CPU , on the object data associated with the selected user interface element . The process of step  concludes after the user interface element handler process of sub-steps ,  and  have been executed by the CPU .",{"@attributes":{"id":"p-0364","num":"0379"},"figref":["FIG. 30","FIG. 29","FIG. 31","FIG. 33"],"b":["2907","2907","154","100","2907","275","259","276","2907","3001","2801","3003","2907","3005","3007","3005","275","3007","2907","3009","3011","3009","275"]},"The process of sub-step  continues at sub-step  where if the buffer descriptor designates the selected user interface element as a \u201cclear button\u201d (i.e. having the function described above) then the process proceeds to sub-step . Otherwise the process of sub-step  proceeds to sub-step . At sub-step  the input buffer is cleared by the CPU . If the buffer descriptor designates the selected user interface element as a \u201cbackspace\u201d button (i.e. having the function described above) at sub-step  then the process proceeds to sub-step  where a buffer backspace process is executed by the CPU . The buffer backspace process will be explained in more detail below with reference to . If the buffer descriptor does not designate the selected user interface element as a \u201cbackspace\u201d button at sub-step  then the process proceeds to sub-step . At sub-step , if the selected user interface element is valid for the given input buffer then the process of sub-step  proceeds to sub-step . Otherwise, the process proceeds to sub-step  where the output flags associated with the default user interface element are set and the process of sub-step  concludes. A buffer append process is executed by the CPU  at sub-step , which will be explained in more detail below with reference to .","Following the buffer OK and buffer cancel process executed at sub-steps  and  respectively, the process of sub-step  proceeds to sub-step  where the output flags associated with the buffer descriptor are set and the process concludes.","The buffer OK process of sub-step , as seen in , is executed by the CPU , when the CPU card B is in buffered input mode and a user interface element configured as an \u201cOK button\u201d (i.e. user interface element ) has been selected by a user at step . The process of sub-step  is preferably implemented as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . The process of sub-step , begins at sub-step  where if an \u201cexpand data\u201d flag of the buffer descriptor associated with the current input buffer is set, then the process proceeds to sub-step . Otherwise, the process proceeds to sub-step . At sub-step  the data of the user interface element object associated with the selected user interface element is expanded into a working buffer. At sub-step , the working buffer is set as the current input buffer.","The process of sub-step  continues at the next sub-step  where if the buffer action field of the buffer descriptor is set to pass-code mode, then the process proceeds to sub-step . Otherwise, the process proceeds to sub-step . At sub-step  a pass-code checker process is executed by the CPU  to determine whether there are valid pass-code entry attempts remaining and if so, whether the entered pass-code stored in the input buffer matches a predetermined pass-code stored in the storage means  of the CPU card B. The pass-code checker process will be explained in more detail below with reference to . At sub-step , the data in the data field of the buffer descriptor is copied into an output data. The process of sub-step  continues at the next sub-step  where the contents of the working buffer are copied into the output buffer. At the next sub-step , the CPU card B is set to standard input mode. The process of sub-step  concludes at the next sub-step  where the input buffer is cleared.","The pass-code checker process executed at sub-step  of the process of , is invoked when user interface card resident application executing on CPU  of the CPU card B is in buffered pass-code input mode and the user interface element  is selected. The process of sub-step  is preferably implemented as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . As, seen in , the process of sub-step  begins at sub-step  where if a pass-code retry counter stored in the storage means  is greater than zero then the process proceeds to sub-step . Otherwise, the process of sub-step  proceeds to sub-step  where the output buffer is set to \u201cwrong password\u201d. At sub-step , a pass-code file referenced in the buffer descriptor data is read by the CPU . If the pass-code matches the input buffer at the next sub-step , then the process proceeds to sub-step  where an initial value is written to the pass-code retry counter. Otherwise, the process of sub-step  proceeds to sub-step  where the pass-code retry counter is decremented and the process proceeds to sub-step . After sub-step  the process of sub-step  proceeds to sub-step  where the output buffer is set to \u201cpass-code OK\u201d. The process of sub-step  concludes at sub-step  where the user interface card resident application executing on the CPU card B is set to standard input mode.","The buffer cancel process is executed at sub-step  during the process of  is invoked when the CPU card B is in buffered input mode and the user interface element  configured as a \u201ccancel button\u201d is selected by a user. The buffer cancel process results in the cancellation of buffered input mode (e.g. pass-code entry). However, in an implementation where pass-code entry is mandatory a \u201ccancel button\u201d is not defined in the active buffer descriptor. The process of sub-step  is preferably implemented as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . As seen in , the process of sub-step  begins at sub-step  where if the buffer action is set to pass-code mode as defined by the action field of the buffer descriptor for the input buffer, then the process proceeds to sub-step . Otherwise, the process proceeds to sub-step  where the data defined by the data field of the current buffer descriptor is copied into the output buffer. At sub-step  the output buffer is set to \u201cpass-code cancel\u201d. The process of sub-step  continues at the next sub-step  where the CPU card B is set to standard input mode. The process concludes at the next sub-step  when the input buffer is cleared.","The buffer backspace process as executed at sub-step  of  and is invoked when the CPU card B is in buffered input mode and a user interface element , which is configured as a backspace button (i.e. user interface element ) is selected by a user. The process of sub-step  is preferably implemented as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . As seen in , the process of sub-step  begins at sub-step  where if the input buffer length is greater than zero, then the process of sub-step  proceeds to sub-step . Otherwise, the process of sub-step  concludes. At sub-step , the last byte in the input buffer is cleared The process of sub-step  concludes at the next sub-step  where the input buffer length is decremented.","The buffer append process as executed at sub-step  of  is invoked when the CPU card B is in buffered input mode and a valid user interface element  is selected by a user. The process of sub-step  is preferably implemented as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . As seen in , the process of sub-step  begins at sub-step  where if the length of the input buffer is less than a maximum length then the process proceeds to sub-step . Otherwise, the process proceeds to sub-step . At sub-step  the length of the input buffer is incremented. The process of sub-step  continues at the next sub-step  where the last byte in the input buffer is set to the current object identifier corresponding to the data object associated with the selected user interface element. At sub-step  if the input buffer is circular, then the process proceeds to sub-step . Otherwise, the process concludes. At sub-step  the bytes in the input buffer are moved one place to the left and process proceeds to sub-step . The process of sub-step  concludes after sub-step .","The text user interface element process of sub-step , is executed to process a standard user interface element  having associated data which is stored in a corresponding user interface element object definition stored in the storage means . The process of sub-step  is preferably implemented as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . As seen in , the process begins at sub-step  where the flags associated with the selected user interface element corresponding to the (X,Y) coordinates received at step , are set for output by the CPU . At the next sub-step  if data is associated with the selected user interface element , then the process proceeds to sub-step . Otherwise, the process of sub-step  concludes. At sub-step  the data associated with the selected user interface element  is appended to the output buffer and the process of sub-step  concludes.","The buffered user interface element process, as executed at sub-step  of , checks a buffer descriptor associated with the current input buffer session and enters the CPU card B into buffered input mode. The process of sub-step  is preferably implemented as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . As seen in , the process of sub-step  begins at sub-step  where the input buffer descriptor is examined by the CPU  to determine whether the buffer descriptor is valid and whether data is present in the data field of the buffer descriptor. If the result of sub-step  is true, then the process of sub-step  proceeds to sub-step  where the user interface resident application executing on the CPU card B is set to buffered input mode using the data associated with the user interface element  selected at sub-step . This data is used as the buffer descriptor. At the next sub-step , the output field of the buffer descriptor is appended to the output buffer and the process of sub-step  concludes. If the result of sub-step  is false, then the flags associated with the selected user interface element  are set for output and the process of sub-step  concludes.","The delegator user interface element process of sub-step  reads the object data associated with the user interface element  corresponding to the (X,Y) coordinates received by the user interface card resident application and determines an application identifier and an application protocol data unit to be sent to the application referenced by the identifier (i.e. the delegated application). The process of sub-step  then invokes the identified application and returns the result of the application as the data associated with the selected user interface element. The \u2018Multos\u2019 delegate command can be used to invoke the identified application. Therefore, as discussed above, the CPU card B can be loaded with several different application programs, which can interact with one another. This allows card resident applications (e.g secure online payment applications), to provide additional functionality to the user interface card resident application described below, allowing data generated by these applications to be associated with user interface elements.","The process of sub-step  is preferably implemented as part of the user interface card resident application program executing within the CPU  of the microprocessor  and being stored in the storage means . The process of sub-step  begins at sub-step  where the flags associated with the selected user interface element  are set for output. At the sub-step  if the data associated with the selected user interface element is present and identifies a valid delegator descriptor then the process proceeds to sub-step . Otherwise, the process of sub-step  concludes. At the sub-step  a delegator header associated with the delegate command is appended to the output buffer. The process continues at the next sub-step , where if the application identified in the delegator header exists then the process continues at sub-step . Otherwise, the process of sub-step  concludes. At sub-step  the identified application is invoked by the CPU  with a provided application protocol data unit. The process of sub-step  continues at the next sub-step  where if the operating system executing on the CPU card B responded with success then the process continues at sub-step . Otherwise, the process of sub-step  concludes. At sub-step  the delegator response is appended to the output buffer and the process concludes.",{"@attributes":{"id":"p-0377","num":"0392"},"figref":"FIG. 39","b":["2817","275","100","300","2817","275","259","276","2817","3001","154","2801","3000","3003","3000","3007","3003","276","2817","3005","2817","3913","275","2817","3005","2817","3007","300","278","3009","1045","300","2817","3911","1045","300"]},{"@attributes":{"id":"p-0378","num":"0393"},"figref":["FIG. 40","FIG. 26","FIG. 40"],"b":["275","2611","276","2611","275","259","276","2611","4001","275","276","4003","275","2611","4005","276","2611","4007","1045","300","1046"]},{"@attributes":{"id":"p-0379","num":"0394"},"figref":["FIG. 41","FIG. 26","FIG. 41"],"b":["275","2603","276","2603","275","259","276","2603","4101","276","4103","4103","276","276","300","100","100","100","4105","275","300"]},"If the presented state code is not correct, at sub-step , then the save state process of sub-step  proceeds to sub-step , where the state information previously stored in non-volatile memory of the storage means  is erased. At the next sub-step , an operations failed error is returned by the CPU  to the CPU  of the reader  and the process of sub-step  concludes. Therefore, the user interface card resident application returns to an initial default state and a user of the CPU card B is forced to log back in the CPU card B, for example. This function provides the card B with greater security since it prevents unauthorised readers from restoring the state information of the user interface card resident application and thus the CPU card B. The state of the CPU card B can only be restored when the present state code is equal to the previous state code supplied by the reader .",{"@attributes":{"id":"p-0381","num":"0396"},"figref":["FIG. 42","FIG. 42"],"b":["275","2703","275","2703","275","259","276","2703","4201","4203","275","300","2703","4203","4205","2703","4209","275","300","4205","275","1045","300","2703"]},{"@attributes":{"id":"p-0382","num":"0397"},"figref":["FIG. 43","FIG. 43"],"b":["275","2707","275","2707","275","259","276","276","2707","4301","4303","4317","300","275","4303","4305","2707","4315","300","275","4305","275","4307","4309","4307","300","275","4311","300","275","2707","4309","275","4313","275","2707"]},{"@attributes":{"id":"p-0383","num":"0398"},"figref":["FIG. 44","FIG. 44"],"b":["275","2711","275","2711","275","259","276","2711","2711","4401","275","4403","4417","300","275","4403","2711","4405","2711","4415","300","275","4405","275","4407","4409","4407","275","4411","300","275","2711","4409","275","276","4413","275","300","2711"]},{"@attributes":{"id":"p-0384","num":"0399"},"figref":"FIG. 45","b":["275","2715","275","2715","275","259","276","2715","276","2715","4501","4503","4517","300","275","4503","4505","2715","4513","300","275","4505","4507","4511","4507","275","4509","300","275","2715","4511","300","275","2715"]},{"@attributes":{"id":"p-0385","num":"0400"},"figref":"FIG. 46","b":["275","2719","275","2719","275","259","276","100","2719","4601","275","4603","276","4605","276","2719","4607","1045","300"]},{"@attributes":{"id":"p-0386","num":"0401"},"figref":"FIG. 47","b":["275","2723","275","2723","275","259","276","2723","4701","4703","4709","4703","100","275","2723","4705","276","4707","275"]},"At sub-step  if there is any command data associated with the EXTERNAL AUTHENTICATE command then the process proceeds to sub-step . Otherwise, the process proceeds to sub-step  where a bad command data error identifier is returned by the CPU . At sub-step  if the retry counter is greater than zero then process proceeds to sub-step . Otherwise, the process proceeds to sub-step  where a bad challenge error identifier is returned to the reader  by the CPU . At sub-step  if a private key exists for the requested security level then the process proceeds to sub-step . Otherwise, the process proceeds to sub-step  where a data not found error is returned to the reader  by the CPU . At sub-step , the command data associated with the external authenticate command is decrypted using the private key. The process of sub-step  continues at the next sub-step  where if the decrypted data matches the original challenge data then the process proceeds to sub-step . Otherwise, the process of step  proceeds to sub-step  where the retry count is decremented. The process of sub-step  concludes at the next sub-step  where the CPU  generates the number of attempts remaining.","The aforementioned preferred methods comprise a particular control flow. There are many other variants of the preferred methods which use different control flows without departing the spirit or scope of the invention. Furthermore one or more of the sub-steps of the preferred method(s) may be executed in parallel rather sequential.","The foregoing describes only some embodiments of the present invention, and modifications and\/or changes can be made thereto without departing from the scope and spirit of the invention, the embodiments being illustrative and not restrictive. For example, the user interface elements ,  can be positioned otherwise than on the smart card . The user interface elements ,  may, for example, be displayed on a display device (e.g. ).","In the context of this specification, the word \u201ccomprising\u201d means \u201cincluding principally but not necessarily solely\u201d or \u201chaving\u201d or \u201cincluding\u201d and not \u201cconsisting only of\u201d. Variations of the word comprising, such as \u201ccomprise\u201d and \u201ccomprises\u201d have corresponding meanings."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["One or more embodiments of the present invention will now be described with reference to the drawings, in which:",{"@attributes":{"id":"p-0023","num":"0025"},"figref":"FIG. 1(","i":"a"},{"@attributes":{"id":"p-0024","num":"0026"},"figref":"FIG. 1(","i":"b"},{"@attributes":{"id":"p-0025","num":"0027"},"figref":["FIG. 2(","FIG. 1("],"i":["a","a"]},{"@attributes":{"id":"p-0026","num":"0028"},"figref":"FIG. 2(","i":"b"},{"@attributes":{"id":"p-0027","num":"0029"},"figref":["FIG. 3","FIGS. 1(","FIG. 1("],"i":["a","b","b"],"b":"1"},{"@attributes":{"id":"p-0028","num":"0030"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0029","num":"0031"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0030","num":"0032"},"figref":"FIG. 6(","i":"a"},{"@attributes":{"id":"p-0031","num":"0033"},"figref":"FIG. 6(","i":"b"},{"@attributes":{"id":"p-0032","num":"0034"},"figref":["FIG. 7","FIGS. 6("],"i":["a","b"],"b":"6"},{"@attributes":{"id":"p-0033","num":"0035"},"figref":["FIG. 8","FIG. 6("],"i":"b"},{"@attributes":{"id":"p-0034","num":"0036"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0035","num":"0037"},"figref":["FIG. 10","FIG. 3"]},{"@attributes":{"id":"p-0036","num":"0038"},"figref":["FIG. 11","FIG. 1(","FIG. 1("],"i":["a","b"]},{"@attributes":{"id":"p-0037","num":"0039"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0038","num":"0040"},"figref":["FIG. 13","FIGS. 6("],"i":["a","b"],"b":"6"},{"@attributes":{"id":"p-0039","num":"0041"},"figref":"FIG. 14(","i":"a"},{"@attributes":{"id":"p-0040","num":"0042"},"figref":["FIG. 14(","FIG. 14("],"i":["b","a"]},{"@attributes":{"id":"p-0041","num":"0043"},"figref":"FIG. 15(","i":"a"},{"@attributes":{"id":"p-0042","num":"0044"},"figref":["FIG. 15(","FIG. 15("],"i":["b","a"]},{"@attributes":{"id":"p-0043","num":"0045"},"figref":["FIG. 16","FIG. 6("],"i":"b"},{"@attributes":{"id":"p-0044","num":"0046"},"figref":["FIGS. 17(","FIG. 6("],"i":["a","e","b"],"b":"17"},{"@attributes":{"id":"p-0045","num":"0047"},"figref":["FIG. 18","FIGS. 14(","FIG. 16"],"i":["a","a"],"b":"15"},{"@attributes":{"id":"p-0046","num":"0048"},"figref":["FIG. 19","FIG. 3","FIG. 16"]},{"@attributes":{"id":"p-0047","num":"0049"},"figref":["FIG. 20","FIG. 6(","FIG. 16"],"i":"a"},{"@attributes":{"id":"p-0048","num":"0050"},"figref":["FIG. 21","FIG. 20"]},{"@attributes":{"id":"p-0049","num":"0051"},"figref":["FIG. 22","FIG. 20"]},{"@attributes":{"id":"p-0050","num":"0052"},"figref":["FIG. 23","FIG. 1(","FIG. 3"],"i":"b"},{"@attributes":{"id":"p-0051","num":"0053"},"figref":["FIG. 24","FIG. 1("],"i":"a"},{"@attributes":{"id":"p-0052","num":"0054"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0053","num":"0055"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0054","num":"0056"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0055","num":"0057"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0056","num":"0058"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0057","num":"0059"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0058","num":"0060"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0059","num":"0061"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0060","num":"0062"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0061","num":"0063"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0062","num":"0064"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0063","num":"0065"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0064","num":"0066"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0065","num":"0067"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0066","num":"0068"},"figref":["FIG. 39","FIG. 1(","FIG. 3"],"i":"b"},{"@attributes":{"id":"p-0067","num":"0069"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0068","num":"0070"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0069","num":"0071"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0070","num":"0072"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0071","num":"0073"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0072","num":"0074"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0073","num":"0075"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0074","num":"0076"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0075","num":"0077"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0076","num":"0078"},"figref":"FIG. 49(","i":"a"},{"@attributes":{"id":"p-0077","num":"0079"},"figref":"FIG. 49(","i":"b"}]},"DETDESC":[{},{}]}
