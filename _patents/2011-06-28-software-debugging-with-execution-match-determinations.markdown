---
title: Software debugging with execution match determinations
abstract: Software debugging with execution match determinations, including: inserting, by a compiler while compiling source code into a debuggable program, a phantom breakpoint at every line of source code; including in the debuggable program, by the compiler, a breakpoint handling module and an exit handler; executing the debuggable program including encountering one or more of the phantom breakpoints and removing, by the breakpoint handling module, each encountered phantom breakpoint; creating, by the exit handler, upon exiting execution of the debuggable program, a copy of the debuggable program that includes only phantom breakpoints not encountered during execution; and providing the copy of the debuggable program to a debugger.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009678&OS=09009678&RS=09009678
owner: International Business Machines Corporation
number: 09009678
owner_city: Armonk
owner_country: US
publication_date: 20110628
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS"],"p":["1. Field of the Invention","The field of the invention is data processing, or, more specifically, methods, apparatus, and products for software debugging with execution match determinations.","2. Description of Related Art","Often software debugging is initiated in response to an error in execution of the software outside of a debugging environment. That is, an execution preceding debugging results in one or more errors\u2014a crash, a buffer overflow, an execution freeze, and so on. Once the software is being debugged, it would be useful for a software developer to be certain that execution in the debugging environment was the same as the execution that preceded debugging. That is, having a controlled testing environment where conditions are the same as the conditions in which the execution resulted in errors is useful, but at present, debugging tools cannot insure that such conditions are the same or inform a user when the conditions are not the same.","Methods, apparatus, and products for software debugging with execution match determinations are disclosed. Such software debugging may be carried out with a compiler and a debugger. From the compiler's perspective software debugging includes: inserting, by a compiler while compiling source code into a debuggable program, a phantom breakpoint at one or more lines of source code; including in the debuggable program, by the compiler, a breakpoint handling module and an exit handler; executing the debuggable program including encountering one or more of the phantom breakpoints and removing, by the breakpoint handling module, each encountered phantom breakpoint; creating, by the exit handler, upon exiting execution of the debuggable program, a copy of the debuggable program that includes only phantom breakpoints not encountered during execution; and providing the copy of the debuggable program to a debugger.","From the debugger's perspective, software debugging includes: receiving the copy of a debuggable program; identifying, by the debugger, lines of source code of the copy of the debuggable program that do not include a phantom breakpoint; inserting, by the debugger, an executed phantom breakpoint at one or more of the identified lines of source code of the copy of the debuggable program; executing, by the debugger, the copy of the debuggable program including, removing any phantom or executed phantom breakpoint; and, after exiting execution of the copy of the debuggable program, determining, by the debugger, whether execution of the copy of the debuggable program matches the execution of the debuggable program including, determining that the executions do not match if any phantom breakpoints were removed during execution of the copy of the debuggable program or any executed phantom breakpoint remain after exiting execution of the copy of the debuggable program.","The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular descriptions of exemplary embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of exemplary embodiments of the invention.","Exemplary methods, apparatus, and products for software debugging with execution match determinations in accordance with the present invention are described with reference to the accompanying drawings, beginning with .  sets forth a block diagram of automated computing machinery forming a system for software debugging with execution match determinations according to embodiments of the present invention. The system of  includes an exemplary computer () that, in turn, includes at least one computer processor () or \u2018CPU\u2019 as well as random access memory () (\u2018RAM\u2019) which is connected through a high speed memory bus () and bus adapter () to processor () and to other components of the computer ().","Stored in RAM () is a debugger (). A debugger () is an application that controls operation of another application\u2014a debuggee, or \u2018a debuggable program\u2019 (, )\u2014for the purpose of testing execution of the debuggee. The source code of the debuggee may run on an instruction set simulator (ISS), a technique that allows great power in its ability to halt when specific conditions are encountered but which will typically be somewhat slower than executing the code directly on a processor for which the code is written. When execution of a program crashes or reaches a preset condition, a debugger typically displays the position in the source code at which the execution of the program crashed. A \u2018crash\u2019 occurs when the program cannot normally continue because of a programming bug. In addition to displaying a position in source code when execution of the source code crashes, debuggers also often offer other functions such as running a program step by step (single-stepping or program animation), stopping, breaking, or pausing the program to examine the current state, at some event or specified instruction by means of a breakpoint, and tracking the values of some variables.","In the example system of , the debugger () presents a graphical user interface () as a front-end of the debugger (). Front-ends are extensions to debugger engines that provide Integrated Development Environment (\u2018IDE\u2019) integration, program animation, and visualization features, rather than console-based command line interfaces. The \u2018front-end\u2019 directly faces a client\u2014or user\u2014in contrast to the debugger () in the example of , which interfaces indirectly with the clients through the GUI ().","Also stored in RAM () is a compiler (). A compiler is a module of computer program instructions that transforms source code written in a programming language (the source language) into another computer language (the target language, often having a binary form known as object code). The most common transformation of source code creates an executable program. The compiler () of  is also configured to generate a debuggable program ()\u2014the debuggee.","In the example of , the compiler () and the debugger () support software debugging with execution match determinations in accordance with embodiments of the present invention. The compiler () operates for software debugging with execution match determinations by inserting, while compiling source code () into a debuggable program (), a phantom breakpoint () at one or more lines of source code. In some embodiments, the compiler () inserts a phantom breakpoint at every line of source code while in other embodiments, a user may specify the one or more lines of source code at which to insert a phantom breakpoint. A breakpoint is one or more predefined instructions inserted into debuggee source code that, when executed, cause debuggee execution to pause or stop. The breakpoint instructions typically replace or \u2018overlay\u2019 original source code instructions. In some embodiments, a breakpoint is implemented as a particular operational code, \u2018opcode,\u2019 that when executed is trapped and handled by a particular module. In other embodiments, a breakpoint may be implemented by a code that results in an error or causes an interrupt. In this specification, a breakpoint is described as a \u2018phantom\u2019 when a compiler inserts the breakpoint and when a user is relatively unaware of the existence of the breakpoint, the insertion of the breakpoint, and the handling of the breakpoint when encountered during execution.","The example compiler () of  also supports software debugging with execution match determinations by including in the debuggable program () a breakpoint handling module () and an exit handler (). A breakpoint handling module () is a module of computer program instructions configured to administer phantom breakpoint encounters during execution of the debuggable program. Including such a module in a debuggable program may be carried out ways, such as, for example, including in an executable package forming the debuggable program, one or more dynamically linked libraries that include routines forming the breakpoint handling module and inserting into the source code linking instructions for the DLLs.","An exit handler is a module of computer program instructions that runs upon completion of a program's execution. Including an exit handler in the debuggable program may be carried out in various ways including, for example, including one or more DLLs that include routines forming the exit handler and inserting in the debuggable program instructions to register the exit handler with the operating system. Once registered, the exit handler will be executed at the behest of the operating system upon the debuggable program exiting by, for example, calling the system-level \u201cexit( )\u201d function in a Unix\u2122-style operating system environment.","The compiler () may insert the phantom breakpoints () by replacing, at one or more lines of source code, original source code with a phantom breakpoint, storing the original source code, and generating a breakpoint table (). The compiler breakpoint table () includes an entry for each phantom breakpoint inserted in the source code. Each entry in the compiler breakpoint table () references the original source code replaced by the phantom breakpoint. That is, each entry includes a pointer to a memory location at which the original source code is stored.","The example compiler () of  also supports software debugging with execution match determinations by executing the debuggable program (). During execution, one or more of the phantom breakpoints are encountered and the breakpoint handling module () removes each encountered phantom breakpoint. The breakpoint handling module () may remove the encountered phantom breakpoints by replacing the encountered phantom breakpoint with original source code through use of the compiler breakpoint table ().","The exit handler (), upon exiting execution of the debuggable program (), creates a copy of the debuggable program that includes only phantom breakpoints not encountered during execution. In operation, only a portion of the debuggable program () may be copied into RAM () during and for execution while a complete version of the debuggable program () may be stored on a disk drive (). The exit handler () may be configured to compare the portion of the debuggable program () in RAM () with the version of the debuggable program () in disk drive () to insure that any encounters of phantom breakpoints in the portion in RAM () is captured by in the created copy ().","The compiler () may then provide the copy () of the debuggable program to the debugger (). Upon receipt, the debugger () may identify lines of source code of the copy () of the debuggable program that do not include a phantom breakpoint and insert an executed phantom breakpoint at one or more of the identified lines of source code of the copy of the debuggable program. An executed phantom breakpoint is a breakpoint, inserted into a copy of a debuggable program by a debugger, at a line of source code that does not include a phantom breakpoint originally inserted by a compiler. Said another way, an executed phantom breakpoint effectively represents a line of source code that was executed in a previous execution of the debuggable program. The debugger () while inserting the executed phantom breakpoints may replace original source code of the copy () with one or more predefined breakpoint instructions or opcode, store the original source code of the copy (), and create a debugger breakpoint table (). Each entry of the debugger breakpoint table () represents a breakpoint in source code of the copy () of the debuggable program. Each entry may also specify a memory location of the original source code that was removed from the copy () upon insertion of the breakpoint. In some embodiments, the debugger's breakpoint table () may also be used as the debugger's primary breakpoint table where entries represent any type of breakpoint including breakpoints specified by a user. In such embodiments, each entry of the breakpoint table may also specify the type of breakpoint represented by the entry\u2014such as \u201cuser-specified,\u201d \u201cexecuted phantom,\u201d or \u201cphantom.\u201d Alternatively, the debugger may maintain separate tables for each type of breakpoint.","After insertion of the executed phantom breakpoints, the debugger () in the example of  may execute the copy () of the debuggable program. During execution, the debugger () removes, without user interaction, any phantom or execution phantom breakpoint. Upon completion of execution, the copy () of the debuggable program exits execution.","After exiting execution, the debugger () in the example of  determines whether execution of the copy () of the debuggable program matches the execution of the debuggable program. The debugger () determines that the executions do not match if any phantom breakpoints () were removed during execution of the copy of the debuggable program or any executed phantom breakpoint () remains after exiting execution of the copy of the debuggable program. If any phantom breakpoints () were removed during execution of the copy of the debuggable program, the copy () executed lines of source code not originally executed during the preceding execution. Thus, the executions do not match. If any executed phantom breakpoint () remain after exiting execution of the copy of the debuggable program, lines of source code originally executed in the preceding execution where not executed during the subsequent execution of the copy () of the debuggable program under debugger control. Thus, the executions do not match. In the example of , the debugger () may display, in a graphical user interface (\u2018GUI\u2019) (), an indication () of matching or non-matching execution corresponding to the outcome of the execution match determination.","Also stored in RAM () is an operating system (). Operating systems that support software debugging with execution match determinations according to embodiments of the present invention include UNIX\u2122, Linux\u2122, Microsoft XP\u2122, AIX\u2122, IBM's i5\/OS\u2122, and others as will occur to those of skill in the art. The operating system (), debugger (), compiler (), GUI (), and debuggee () in the example of  are shown in RAM (), but many components of such software typically are stored in non-volatile memory also, such as, for example, on a disk drive ().","The computer () of  includes disk drive adapter () coupled through expansion bus () and bus adapter () to processor () and other components of the computer (). Disk drive adapter () connects non-volatile data storage to the computer () in the form of disk drive (). Disk drive adapters useful in computers that support software debugging with execution match determinations according to embodiments of the present invention include Integrated Drive Electronics (\u2018IDE\u2019) adapters, Small Computer System Interface (\u2018SCSI\u2019) adapters, and others as will occur to those of skill in the art. Non-volatile computer memory also may be implemented for as an optical disk drive, electrically erasable programmable read-only memory (so-called \u2018EEPROM\u2019 or \u2018Flash\u2019 memory), RAM drives, and so on, as will occur to those of skill in the art.","The example computer () of  includes one or more input\/output (\u2018I\/O\u2019) adapters (). I\/O adapters implement user-oriented input\/output through, for example, software drivers and computer hardware for controlling output to display devices such as computer display screens, as well as user input from user input devices () such as keyboards and mice. The example computer () of  includes a video adapter (), which is an example of an I\/O adapter specially designed for graphic output to a display device () such as a display screen or computer monitor. Video adapter () is connected to processor () through a high speed video bus (), bus adapter (), and the front side bus (), which is also a high speed bus.","The exemplary computer () of  includes a communications adapter () for data communications with other computers () and for data communications with a data communications network (). Such data communications may be carried out serially through RS-232 connections, through external buses such as a Universal Serial Bus (\u2018USB\u2019), through data communications networks such as IP data communications networks, and in other ways as will occur to those of skill in the art. Communications adapters implement the hardware level of data communications through which one computer sends data communications to another computer, directly or through a data communications network. Examples of communications adapters useful in computers that support software debugging with execution match determinations according to embodiments of the present invention include modems for wired dial-up communications, Ethernet (IEEE 802.3) adapters for wired data communications network communications, and 802.11 adapters for wireless data communications network communications.","The arrangement of servers and other devices making up the exemplary system illustrated in  are for explanation, not for limitation. Data processing systems useful according to various embodiments of the present invention may include additional servers, routers, other devices, and peer-to-peer architectures, not shown in , as will occur to those of skill in the art. Networks in such data processing systems may support many data communications protocols, including for example TCP (Transmission Control Protocol), IP (Internet Protocol), HTTP (HyperText Transfer Protocol), WAP (Wireless Access Protocol), HDTP (Handheld Device Transport Protocol), and others as will occur to those of skill in the art. Various embodiments of the present invention may be implemented on a variety of hardware platforms in addition to those illustrated in .","For further explanation,  sets forth an example GUI () presented to a user by a debugger in accordance with embodiments of the present invention. The example GUI () of  provides an interface for a user to control operation of a debugger and thereby a debuggee. The debugger presenting the example GUI () of  is configured for software debugging with execution match determinations in accordance with embodiments of the present invention.","The example GUI () of  includes a menu bar () that, in turn, includes a number of separate menus: a File menu, an Edit menu, a View menu, and a Help menu. The example GUI () of  also includes several independent portions\u2014called panes (as in \u2018window panes\u2019) for clarity of explanation\u2014a project pane (), a source code pane (), and two separate data panes (, ). Project pane () presents the files and resources available in a particular software development project. Source code pane () presents the source code of the multi-threaded debuggee. The data panes (, ) present various data useful in debugging the source code. In the example of , data pane () includes three tabs, each of which presents different data: a call stack tab (), a register tab (), and a memory tab () tab. Data pane () includes four tabs: a watch list tab (), a breakpoints () tab, a local variable tab (), and a global variable tab ().","The example GUI () of  sets forth various indications of matching and non-matching execution. Readers of skill in the art will recognize that in many embodiments only one indication will be displayed at a time. Further, even in embodiments in which multiple indications are displayed simultaneously in a GUI (), only one type (matching or non-matching execution) of indication will be displayed at one time.","The debugger presenting the example GUI () of  displays an indication () of non-matching execution upon determining that a preceding execution outside of the debugging environment and the most recent execution within the debugging environment of the debuggable program do not match. The example indication () of non-matching execution is implemented as a pop-up dialog box titled \u201cExec. Alert,\u201d including a warning symbol and text that reads, \u201cExecutions Do Not Match.\u201d The example indication () implemented as a pop-up dialog box also includes a GUI button with text reading \u201cGo.\u201d The GUI button, when invoked, may change the perspective (the display) of the GUI to present one or more source code lines at which execution did not match. That is, the GUI may display source code lines that include an executed phantom breakpoint (indicating that the line was executed in the preceding execution but not during execution under debug control) or source code lines from which a phantom breakpoint was removed (indicating that the line was not executed in the preceding execution but was executed under debug control).","The example GUI () of  also includes another indication () of non-matching execution at line  of the source code displayed in the source code pane (). The indication () is implemented by as underlined, italicized, and bolded text. The indication () may also be implemented with a predefined text color, such as red. The indication () is identifies a particular line of source code at which non-matching execution occurs.","The example GUI () of  also includes an indication () of matching execution in the menu bar (). The indication () is implemented in the example of  with italicized text that states \u201c*** Matching Execution ***\u201d along with an icon. The icon may be configured to provide additional information describing the matching execution responsive to user interaction\u2014a mouse-clock or pointer hover over the icon, for example.","Readers of skill in the art will recognize that the three indications (, , and ) depicted in the example GUI () of  are for example only, not limitation. Many other forms of indication may be implemented in GUIs that support software debugging with execution match determinations. Pop-up dialog boxes, text notifications, audio notifications, fonts, text styles, icons, images, and so on are all other example implementations of indications of matching or non-matching execution and each such example is well within the scope of the present invention.","The GUI items, menus, window panes, tabs, and so on depicted in the example client-specific GUI () of , are for explanation, not for limitation. Other GUI items, menu bar menus, drop-down menus, list-boxes, window panes, tabs, and so on as will occur to readers of skill in the art may be included in GUIs presented by debuggers configured for software debugging with execution match determinations in accordance with embodiments of the present invention.","As mentioned above, software debugging with execution match determinations may be carried out with a compiler and a debugger. For further explanation, therefore,  sets forth a flow chart illustrating an exemplary method for software debugging with execution match determinations according to embodiments of the present invention from the perspective of a compiler. To that end, the method of  includes inserting (), by a compiler () while compiling source code into a debuggable program (), a phantom breakpoint () at one or more lines of source code.","The method of  continues by the compiler () including () in the debuggable program () a breakpoint handling module () and an exit handler (). Including () in the debuggable program () a breakpoint handling module () and an exit handler () may be carried out in various ways such as, for example, including in an executable package forming the debuggable program\u2014a .exe file for example\u2014one or more dynamically linked libraries that include routines forming the breakpoint handling module and inserting linking instructions for the DLLs into the source code. When the debuggable program is executed, the linking instructions are executed and the DLLs are loaded for use by the debuggable program.","The method of  also includes executing () the debuggable program. Executing () the debuggable program may be carried out in various ways, including, for example, by a system level fork( ) call in a Unix\u2122-style operating system environment. In the example of , executing () the debuggable program includes encountering () one or more of the phantom breakpoints () and removing (), by the breakpoint handling module (), each encountered phantom breakpoint.","The method of  also includes creating (), by the exit handler, upon exiting execution of the debuggable program, a copy () of the debuggable program that includes only phantom breakpoints not encountered during execution. Creating () a copy () of the debuggable program that includes only phantom breakpoints not encountered during execution may be carried out by examining a portion of the debuggable program in memory and the debuggable program () on disk, identifying any lines of source code from which phantom breakpoints have been removed in memory but not from the disk, and generating the copy of the debuggable program so as to insure that the identified lines will not include phantom breakpoints in the copy and that all other lines having phantom breakpoints removed during execution also do not include phantom breakpoints in the copy. In the example of , the phantom breakpoints in the copy () of the debuggable program are referred to as unencountered phantom breakpoints () having not been encountered during the execution () outside debugger control.","The method of  continues by providing () the copy () of the debuggable program to a debugger (). In some embodiments providing the copy () of the debuggable program also includes providing a compiler breakpoint table that lists only those phantom breakpoints remaining in the copy (). Providing the copy () of the debuggable program to the debugger () may be carried out in various ways. The compiler may provide the copy () through an application programming interface (API) exposed by the debugger for use by the compiler, by storing the copy () in computer memory, by notifying the debugger of the copy's () location in memory and so on as will occur to readers of skill in the art. After providing () the copy of the debuggable program to the debugger, the method of  continues to , step ().","As mentioned above,  sets for a method of software debugging with execution match determinations from the perspective of the compiler. For further explanation,  sets forth a flow chart illustrating a further exemplary method for software debugging with execution match determinations according to embodiments of the present invention from the perspective of the debugger.","The method of  continues from the method of , after the compiler () provides () the copy of the debuggable program to the debugger (). The method of  includes receiving () the copy () of the debuggable program. Receiving () the copy () of the debuggable program may be carried out by loading the debuggable program's source files, executing a process for the debuggable program, calling a system-level call such a ptrace( ) in Unix to attach the debugger to the process, and so on as will occur to readers of skill in the art.","The method of  also includes identifying (), by the debugger (), lines () of source code of the copy () of the debuggable program that do not include a phantom breakpoint. Identifying () lines () of source code of the copy () of the debuggable program that do not include a phantom breakpoint may be carried out in various ways. For example, the phantom breakpoints may be implemented as a predefined opcode well known to the debugger () and the debugger may search the source code for all lines that do not include the predefined opcode. As another example, consider embodiments in which the compiler provides, along with the copy () of the debuggable program, a compiler breakpoint table that includes only those phantom breakpoints remaining the in copy when the debugger () loads the copy. Each entry in the compiler breakpoint table may include an identification of a source code line at which the phantom breakpoint represented by the entry is inserted. In such example embodiments, the debugger () may identify lines () of source code that do not include a phantom breakpoint by identifying all lines of source code not represented in the entries of the compiler breakpoint table.","The method of  also includes inserting (), by the debugger (), an executed phantom breakpoint () at one or more of the identified lines () of source code of the copy of the debuggable program. Inserting () an executed phantom breakpoint () may be carried out by replacing original source code at a line of source code with a predefined opcode representing an executed phantom breakpoint (), replacing original source code at a line of source code with a predefined opcode representing a breakpoint and indicating the breakpoint's type in the debugger's breakpoint table, replacing original source code at a line of source code with a predefined opcode representing a breakpoint and creating an entry in an executed phantom breakpoint table that includes entries only for executed phantom breakpoints, and in other ways as may occur to readers of skill in the art. Once original source code is removed (replaced by the executed phantom breakpoint), the original source code is stored and the storage location of the original source code is indicated in an entry in a breakpoint table.","The method of  also includes executing (), by the debugger (), the copy () of the debuggable program. In the method of , executing () the copy () includes removing () any phantom () or executed phantom () breakpoint. Removing () any phantom () or executed phantom () breakpoint may be carried out by replacing the breakpoint with original source code\u2014source code stored during the insertion of the breakpoint.","After exiting execution () of the copy of the debuggable program, the method of  continues by determining (), by the debugger (), whether execution of the copy of the debuggable program matches the execution of the debuggable program. That is, the debugger determines whether execution under debugger control matches the preceding execution outside of debugger control. In the method of , determining () whether execution of the copy () matches execution of the debuggable program is carried out by determining () whether any phantom breakpoints were removed during execution of the copy () of the debuggable program. If any phantom breakpoints were removed during execution of the copy (), the debugger determines () that the executions do not match. If no phantom breakpoints were removed during execution of the copy (), the debugger then determines () whether any executed phantom breakpoint remains after exiting execution of the copy of the debuggable program. If any executed phantom breakpoint remains, the debugger () determines () that the executions do not match. If no executed phantom breakpoints remain, the debugger () in the example of , determines () that the executions do match.","The steps of determining () whether any phantom breakpoints were removed and determining () whether any executed phantom breakpoint remains are depicted in the example method of  in a particular order for ease and clarity of description, not limitation. Readers will understand that there is no limitation on the order for these two determinations. The debugger need only determine one of two things to identifying non-matching executions: that a phantom breakpoint was removed or that an executed phantom breakpoint remains. If either or both of these two conditions exist, the executions do not match.","For further explanation,  sets forth a flow chart illustrating a further exemplary method for software debugging with execution match determinations according to embodiments of the present invention. The method of  is similar to the method of  including as it does: identifying () lines of source code that do not include a phantom breakpoint; inserting () an executed phantom breakpoint at one or more of the identified lines of source code; executing () the copy, removing () any phantom or executed phantom breakpoint; and determining () whether execution of the copy matches execution of the debuggable program.","The method of  differs from the method of , however, in that, two alternative methods of inserting () an executed phantom breakpoint at one or more of the identified lines of source code are depicted. In one method, the debugger inserting () an executed phantom breakpoint at each identified line of source code.","That is, for each line identified as not including a phantom breakpoint\u2014a breakpoint originally inserted by the compiler and not removed during a preceding execution of debuggable program outside of debugger control\u2014the debugger inserts an executed phantom breakpoint.","In another example method of inserting () an executed phantom breakpoint at one or more of the identified lines depicted in the example of , the debugger () inserts (), at an entry point of each routine in an identified line () of source code, an executed entry breakpoint () without inserting an executed phantom breakpoint () at lines of source code within the routine and inserting (), at each other identified line of source code, an executed phantom breakpoint. Examples of entry points may include a jump, a branch, a functional call and so on as will occur to readers of skill in the art. An executed entry breakpoint represents a phantom breakpoint originally inserted by the compiler but encountered and removed during a previous execution, where the source code line of the breakpoint is an entry into a routine\u2014such as a functional call, for example. In this method of inserting () executed phantom breakpoints, the debugger () may insert fewer total breakpoints than in the previous example method of insertion where a breakpoint is inserted at every identified line. That is, by not inserting executed phantom breakpoints within routines, the time needed to process the copy of the debuggable program upon receiving or loading the program (readying the program for debugging) may be reduced in comparison to implementations in which a breakpoint is inserted at each identified line of source code regardless of its location within a routine.","In the example of , when the debugger is configured to insert () an executed entry breakpoint at entry points of routines not having a phantom breakpoint, executing () the copy of the debuggable program includes encountering an executed entry breakpoint () a the entry point of a routine, thereby stopping execution of the copy () of the debuggable program, inserting () an executed phantom at each line of source code within the routine, and resuming () execution. In this way, the executed entry breakpoint operates as a trigger to insert executed phantom breakpoints within a routine.","In addition to the various methods of inserting () an executed phantom breakpoint at one or more identified lines of source code, the method of  also includes displaying (), by the debugger () in a GUI, an indication of matching execution if the executions match () and displaying (), by the debugger () in the GUI, an indication of non-matching execution if the executions do not match (). An indication of matching or non-matching execution may be implemented in various ways including, for example: as a text notification in a pop-up dialog box, a text notification embedded in a menu bar, as an icon or image (such as a green colored check, a yellow warning symbol, a red letter \u2018X\u2019) displayed in a location of the GUI designated for providing information regarding execution match determinations, as an audible notification (such as a buzzer, a bell, a human voice, and the like), as a combination of any of these examples, and in many other ways as will occur to readers of skill in the art.","For further explanation,  sets forth a flow chart illustrating a further exemplary method for software debugging with execution match determinations according to embodiments of the present invention. The method of  is similar to the method of  including as it does: inserting () a phantom breakpoint at one or more lines of source code, including () a breakpoint handling module and an exit handler in the debuggable program; executing () the debuggable program, encountering () and removing () phantom breakpoints; creating () a copy () of the debuggable program that includes only phantom breakpoints not encountered during execution; and providing the copy to a debugger.","The method of  differs from the method of , however, in that in the method of  inserting () a phantom breakpoint () at one or more lines of source code is carried out by replacing (), at the one or more lines of source code, original source code with a phantom breakpoint (), storing () the original source code, and generating () a breakpoint table (). In the example of , the breakpoint table () includes an entry for each phantom breakpoint inserted in the source code. Each entry in the breakpoint table () references the original source code replaced by the phantom breakpoint. Each entry also identifies a source code line at which the phantom breakpoint was inserted.","Also in the method of , removing () each phantom breakpoint encountered during execution includes replacing (), in dependence upon the breakpoint table (), the encountered phantom breakpoint with original source code. That is, the breakpoint handling module (), upon an encounter of a phantom breakpoint, may identify the source code line at which the encounter of the phantom breakpoint occurred and search the breakpoint table () for an entry that identifies that line of source code, using the source code identification as a type of index into the breakpoint table. Once located, the breakpoint handling module may utilize the reference\u2014such as a pointer to a memory location\u2014to original source code stored in the entry to retrieve the original source code. The breakpoint handling module may then overwrite the phantom breakpoint with the retrieved original source code.","In view of the explanations set forth above, readers will recognize that the benefits of software debugging with execution match determinations according to embodiments of the present invention include:\n\n","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable transmission medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.","A computer readable transmission medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable transmission medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention are described above with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.","It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
