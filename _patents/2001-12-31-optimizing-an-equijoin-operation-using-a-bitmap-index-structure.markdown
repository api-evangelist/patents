---
title: Optimizing an equi-join operation using a bitmap index structure
abstract: A method, computer program and database system are disclosed for joining a plurality of tables T through TN, where each of the tables has an associated Star Map, S through SN, respectively. Each Star Map includes bitmap entries having locations indexed by the hash of one or more values associated with one or more join key columns of its associated table. A bitmap entry in a Star Map, if set, indicates the presence of a row in its associated table that has entries in the one or more join key columns that together hash to the location of the bitmap entry. The method includes a) performing a Boolean operation using the bitmap entries of the Star Maps S through SN to produce a join Star Map SJ, b) using SJ to select rows from the tables T through TN, and c) joining the resulting rows to produce a join result.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07092954&OS=07092954&RS=07092954
owner: NCR Corporation
number: 07092954
owner_city: Dayton
owner_country: US
publication_date: 20011231
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["Relational DataBase Management Systems (RDBMS) using a Structured Query Language (SQL) interface are well known in the art. The SQL interface has evolved into a standard language for RDBMS software and has been adopted as such by both the American National Standards Institute (ANSI) and the International Standards Organization (ISO). In an RDBMS, all data is externally structured into tables. A table in a relational database is two dimensional, consisting of rows and columns. Each column has a name, typically describing the type of data held in that column. As new data is added, more rows are inserted into the table. A user query selects some rows of the table by specifying clauses that qualify the rows to be retrieved based on the values in one or more of the columns.","The SQL interface allows users to formulate relational operations on the tables either interactively, in batch files, or embedded in host languages such as C, COBOL, etc. Operators are provided in SQL that allow the user to manipulate the data, wherein each operator performs functions on one or more tables and produces a new table as a result. The power of SQL lies on its ability to link information from multiple tables or views together to perform complex sets of procedures with a single statement.","The SQL interface allows users to formulate relational operations on the tables. One of the most common SQL queries executed by the RDBMS is the SELECT statement. In the SQL standard, the SELECT statement generally comprises the format: \u201cSELECT <clause> FROM <clause> WHERE <clause> GROUP BY<clause> HAVING <clause> ORDER BY <clause>.\u201dThe clauses generally must follow this sequence, but only the SELECT and FROM clauses are required.","Generally, the result of a SELECT statement is a subset of data retrieved by the RDBMS from one or more existing tables stored in the relational database, wherein the FROM clause identifies the name of the table or tables from which data is being selected. The subset of data is treated as a new table, termed the result table.","A join operation is usually implied by naming more than one table in the FROM clause of a SELECT statement. A join operation makes it possible to combine tables by combining rows from one table with another table. The rows, or portions of rows, from the different tables are concatenated horizontally. Although not required, join operations normally include a WHERE clause that identifies the columns through which the rows can be combined. The WHERE clause may also include a predicate comprising one or more conditional operators that are used to select the rows to be joined.","An equi-join operation combines rows from the tables identified in the FROM clause in which columns specified in the WHERE clause satisfy an equality relationship. A database system may execute such a query by comparing the specified columns in each row of each table according to the WHERE clause predicate.","In general, in one aspect, the invention features a method for joining a plurality of tables T through TN, where each of the tables has an associated Star Map, S through SN, respectively. Each Star Map includes bitmap entries having locations indexed by the hash of one or more values associated with one or more join key columns of its associated table. A bitmap entry in a Star Map, if set, indicates the presence of a row in its associated table that has entries in the one or more join key columns that together hash to the location of the bitmap entry. The method includes a) performing a Boolean operation using the bitmap entries of the Star Maps S through SN to produce a join Star Map SJ, b) using SJ to select rows from the tables T through TN, and c) joining the resulting rows to produce a join result.","Implementations of the invention may include one or more of the following. The Boolean operation may include a logical AND. Using SJ to select rows from the tables T through TN may include for each set bitmap entry in SJ, searching T through TN for rows having values in their one or more join key columns that hash to the location of the set bitmap entry. Each bitmap entry in each Star Map may have an associated row number and column number. The row number and the column number for a set bitmap entry in a Star Map may be combined to produce a value that corresponds to the hash value of the one or more join key columns of the Star Map's associated table. At least one of the tables T through TN may be ordered by the hash of the values of its one or more join key columns.","In general, in another aspect, the invention features a method for joining a plurality of tables T through TN, where each of the tables has an associated Star Map, S through SN, respectively. Each Star Map includes bitmap entries having locations indexed by the hash of one or more values associated with one or more join key columns of its associated table. A bitmap entry in a Star Map, if set, indicates the presence of a row in its associated table that has entries in the one or more join key columns that together hash to the location of the bitmap entry. The method includes a) logically ANDing the Star Maps S through SN to produce Star Map SJ, b) for each set bitmap entry in SJ, searching T through TN for rows having values in their one or more join key columns that hash to the location of the set bitmap entry, and c) joining the resulting rows to produce a join result.","Implementations of the invention may include one or more of the following. The method may include determining the cardinality of the join result and if the cardinality is less than a predefined threshold value, performing a) through c); and if the cardinality is greater than the predefined threshold value, not performing a) through c). Logically ANDing the Star Maps may include setting an entry in SJ having a location defined by a hash value if the entries in all of S through SN having locations defined by the hash value are set. Logically ANDing the Star Maps may includes a1) performing a logical AND of S and S to produce SJ; a2) setting i to 3; a3) while i is less than or equal to N, performing a4) through a6), a4) performing a logical AND of Si with SJ to form Stemp, a5) setting SJ equal to Stemp, and a6) incrementing i.","S through SN and SJ may be the same size and performing a logical AND of Si with SJ to form Stemp may include ANDing the entry at a location in Si defined by a hash value with the entry at a location in SJ defined by the hash value. Each of T through TN may be indexed by the hash of the combined entries in its respective one or more join key columns, and searching T through TN for rows having values in its one or more columns that hash to the location of the set bitmap entry may include using the hash value associated with the location of the set bitmap entry as an index to retrieve rows from tables T through TN.","One or more of the Star Maps may be a table and a first portion of the hash value that indexes the locations of a Star Map may define a row within the Star Map and a second portion of the hash value may define an offset within the defined row. The first portion may be the first half of the hash value and the second portion is the second half of the hash value. The hash value may be 32 bits long, the first portion may be the first 16 bits of the hash value, and the second portion may be the second 16 bits of the hash value. At least one of tables T through TN may be ordered by the values of its one or more join key columns. Each entry in a Star Map may be one bit. Each entry in a Star Map may be sixteen bits. Each Star Map entry may include one or more bits and each bit may correspond to the hash of one or more values associated with the one or more join key columns of its associated table.","In general, in another aspect, the invention features a computer program, stored on a tangible storage medium, for use in joining a plurality of tables T through TN. Each of the tables has an associated Star Map, S through SN, respectively. Each Star Map includes bitmap entries having locations indexed by the hash of one or more values associated with one or more join key columns of its associated table. A bitmap entry in a Star Map, if set, indicates the presence of a row in its associated table that has entries in the one or more join key columns that together hash to the location of the bitmap entry. The program includes executable instructions that cause a computer to a) logically AND the Star Maps S through SN to produce Star Map SJ, b) for each set bitmap entry in SJ, search T through TN for rows having values in their one or more join key columns that hash to the location of the set bitmap entry, and c) join the resulting rows to produce a join result.","In general, in another aspect, the invention features a database system for accessing a database. The database system includes a massively parallel processing system which includes one or more nodes, a plurality of CPUs, each of the one or more nodes providing access to one or more CPUs, a plurality of virtual processes each of the one or more CPUs providing access to one or more processes, each process configured to manage data stored in one of a plurality of data-storage facilities, a plurality of tables T through TN. Each table is distributed among the data-storage facilities. Each of the tables has an associated Star Map, S through SN, respectively. Each Star Map is distributed among the data-storage facilities. Each Star Map includes bitmap entries having locations indexed by the hash of one or more values associated with one or more join key columns of its associated table. A bitmap entry in a Star Map, if set, indicates the presence of a row in its associated table that has entries in the one or more join key columns that together hash to the location of the bitmap entry. A join process executed on one or more of the plurality of CPUs causes the CPUs to a) logically AND the Star Maps S through SN to produce Star Map SJ, b) for each set bitmap entry in SJ, search T through TN for rows having values in their one or more join key columns that hash to the location of the set bitmap entry, and c) join the resulting rows to produce a join result.","In general, in another aspect, the invention features a data structure stored in a memory for use in performing a join in a database management system executed by a computer. The data structure includes a Star Map associated with a table referenced in a query. The Star Map includes bitmap entries having locations indexed by a combination of one or more values associated with one or more join key columns of its associated table. A bitmap entry in the Star C Map, if set, indicates the presence of a row in the associated table that has entries in the one or more join key columns that, when combined, identify the location of the bitmap entry.","In general, in another aspect, the invention features a method for joining a plurality of tables T through TN, where each of the tables has an associated Star Map, S through SN, respectively. Each Star Map includes bitmap entries having locations indexed by one or more values associated with a join key column of its associated table. A bitmap entry in a Star Map, if set, indicates the presence of a row in its associated table that has an entry in the join key column that identifies the location of the bitmap entry. The method includes a) performing a Boolean operation using the bitmap entries of the Star Maps S through SN to produce a join Star Map SJ, b) using SJ to select rows from the tables T through TN, and c) joining the resulting rows to produce a join result.","Implementations of the invention may include one or more of the following. Using SJ to select rows from the tables T through TN may include for each set bitmap entry in SJ, searching T through TN for rows having values in their respective join key columns that identify the location of the set bitmap entry. Each bitmap entry in each Star Map may have an associated row number and column number. The row number and the column number for a set bitmap entry in a Star Map may be combined to produce a value that corresponds to the value of the join key column of the Star Map's associated table. At least one of the tables T through TN is ordered by the values of its join key column.","Other features and advantages will become apparent from the description and claims that follow.","In the following description of the preferred embodiment, reference is made to the accompanying drawings which form a part hereof, and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.","Overview","The present invention comprises a bitmap index structure, known as a Star Map, that improves the performance of large table joins that have low join cardinality, where cardinality is related to the number of rows in the join result. The database system uses hash-based addressing in the Star Map, so that the size of the Star Map is constant and therefore access times are constant. Moreover, access times are independent of the number of rows in the tables being joined, up to a preset limit, which can be altered by a systems administrator. As a result, the Star Map improves the performance of equi-joins where two or more large tables are joined and the cardinality of the join is small (i.e., the join result has a small number of rows).","Environment",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","102","104","102","106","102","108"]},"Operators of the computer system  typically use a workstation , terminal, computer, or other input device to interact with the computer system . This interaction generally comprises queries that conform to the Structured Query Language (SQL) standard, and invoke functions performed by a Relational DataBase Management System (RDBMS) executed by the system .","In one example, the RDBMS comprises the Teradata\u00ae product offered by NCR Corporation, the assignee of the present invention, and includes one or more Parallel Database Extensions (PDEs) , Parsing Engines (PEs) , and Access Module Processors (AMPs) . These components of the RDBMS perform the functions necessary to implement the RDBMS and SQL functions, i.e., definition, compilation, interpretation, optimization, database access control, database retrieval, and database update.","Generally, the PDEs , PEs , and AMPs  are tangibly embodied in and\/or accessible from a device, media, carrier, or signal, such as RAM, ROM, one or more of the DSUs , and\/or a remote system or device communicating with the computer system  via one or more of the DCUs . The PDEs , PEs , and AMPs  each comprise logic and\/or data which, when executed, invoked, and\/or interpreted by the PUs  of the computer system , cause the necessary steps or elements described below to be performed.","Those skilled in the art will recognize that the exemplary environment illustrated in  is not intended to limit the present invention. Indeed, those skilled in the art will recognize that other alternative environments may be used without departing from the scope of the present invention. In addition, it should be understood that the present invention may also apply to components other than those disclosed herein.","In an example system, work is divided among the PUs  in the system  by spreading the storage of a partitioned relational database  managed by the RDBMS across multiple AMPs  and the DSUs  (which are managed by the AMPs ). Thus, a DSU  may store only a subset of rows that comprise a table in the partitioned database  and work is managed by the system  so that the task of operating on each subset of rows is performed by the AMPs  managing the DSUs  that store the subset of rows.","The PDEs  provide a high speed, low latency, message-passing layer for use in communicating between the PEs  and AMPs . Further, the PDE  is an application programming interface (API) that allows the RDBMS to operate under either the UNIX MP-RAS or WINDOWS NT operating systems, in that the PDE  isolates most of the operating system dependent functions from the RDBMS, and performs many operations such as shared memory management, message passing, and process or thread creation.","The PEs  handle communications, session control, optimization and query plan generation and control, while the AMPs  handle actual database  table manipulation. The PEs  fully parallelize all functions among the AMPs . Both the PEs  and AMPs  are known as \u201cvirtual processors\u201d or \u201cvprocs\u201d.","The vproc concept is accomplished by executing multiple threads or processes in a PU , wherein each thread or process is encapsulated within a vproc. The vproc concept adds a level of abstraction between the multi-threading of a work unit and the physical layout of the parallel processing computer system . Moreover, when a PU  itself is comprised of a plurality of processors or nodes, the vproc concept provides for intra-node as well as the inter-node parallelism.","The vproc concept results in better system  availability without undue programming overhead. The vprocs also provide a degree of location transparency, in that vprocs communicate with each other using addresses that are vproc-specific, rather than node-specific. Further, vprocs facilitate redundancy by providing a level of isolation\/abstraction between the physical node  and the thread or process. The result is increased system  utilization and fault tolerance.","The system  does face the issue of how to divide a query or other unit of work into smaller sub-units, each of which can be assigned to an AMP . In one example, data partitioning and repartitioning may be performed, in order to enhance parallel processing across multiple AMPs . For example, the database  may be hash partitioned, range partitioned, or not partitioned at all (i.e., locally processed).","Hash partitioning is a partitioning scheme in which a predefined hash function and map is used to assign records to AMPs , wherein the hashing function generates a hash \u201cbucket\u201d number and the hash bucket numbers are mapped to AMPs . Range partitioning is a partitioning scheme in which each AMP  manages the records falling within a range of values, wherein the entire data set is divided into as many ranges as there are AMPs . No partitioning means that a single AMP  manages all of the records.","Execution of SQL Queries",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 2"},"Block  represents SQL statements being accepted by the PE .","Block  represents the SQL statements being transformed by a Compiler or Interpreter subsystem of the PE  into an execution plan. Moreover, an Optimizer subsystem of the PE  may transform or optimize the execution plan in a manner described in more detail later in this specification.","Block  represents the PE  generating one or more \u201cstep messages\u201d from the execution plan, wherein each step message is assigned to an AMP  that manages the desired records. As mentioned above, the rows of the tables in the database  may be partitioned or otherwise distributed among multiple AMPs , so that multiple AMPs  can work at the same time on the data of a given table. If a request is for data in a single row, the PE  transmits the steps to the AMP  in which the data resides. If the request is for multiple rows, then the steps are forwarded to all participating AMPs . Since the tables in the database  may be partitioned or distributed across the DSUs  of the AMPs , the workload of performing the SQL query can be balanced among AMPs  and DSUs .","Block  also represents the PE  sending the step messages to their assigned AMPs .","Block  represents the AMPs  performing the required data manipulation associated with the step messages received from the PE , and then transmitting appropriate responses back to the PE .","Block  represents the PE  merging the responses that come from the AMPs .","Block  represents the output or result table being generated.","Equi-Join Operation",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 3","b":["300","305","310","300","300","305","305","310","310","300","305","310","305","310"],"i":["a","b","a","b","a","b "]},"An exemplary SQL query for performing the equi-join operation shown in  would be the following:\n\n","In this example, the tables , , and  are joined according to equivalence relations indicated in the query. A typical execution plan for the exemplary SQL query would be to perform a sequence of binary joins between the tables , , and . It is the job of the Optimizer subsystem of the PE , at step  of , to select a least costly binary join order.","In a join such as that illustrated in , there may be numerous unnecessary accesses to the tables ,  and  when performing the join operations. Consider one example using . Assume that each of the three tables ,  and  has approximately 1 billion rows, and the join operation produces only 100,000 result rows. In this example, a large percentage of the accesses to the tables ,  and  are unnecessary.","Star Maps , ,  associated with each table , , , respectively, can be used to minimize unnecessary accesses to the tables , , . The Star Maps , ,  are bitmap index structures used to filter accesses to the tables ,  and , i.e., to determine whether join operations among the tables ,  and  would be productive.","Star Map Structure","An example structure for a Star Map will now be discussed in relation to Star Map . It will be understood that this discussion will be equally applicable to the other Star Maps ,  illustrated in . The example Star Map , which is associated with table , includes a plurality of rows , wherein each row includes a plurality of columns , as shown in . In one example, the Star Map  includes 64K rows , each of the rows  includes 64K columns , and each of the columns  comprises either a 1-bit or a 16-bit value. In one example, a bit in the 1-bit value having a value \u201c1\u201d, rather than \u201c0\u201d, is referred to as a \u201cset bitmap entry.\u201d When the number of rows  of the Star Map  is 64K and each row  has 64K columns , then the Star Map  can map approximately 232 or 4 billion rows in its associated table  when the column  comprises a 1-bit value or 236 or 64 billion rows in its associated table  when the column  comprises a 16-bit value.","The number of rows , the number of columns , the size of each column  value, and the hashing functions used are determined and fixed at creation time, depending on the cardinality of the table being represented. Of course, those skilled in the art will recognize that any number of rows , any number of columns , any size of column  value, and any number of different hashing functions could be used without departing from the scope of the present invention. Further, those skilled in the art will recognize that the Star Map  may take a form different from the form illustrated in , such as an ordered sequence of bits, bytes, or words, without departing from the scope of the present invention.","One or more join columns of the table  associated with the Star Map  are used to generate the column  values of the Star Map , wherein the join columns usually comprise a partition index, or a primary index. With some additional enhancements, a secondary index of the table can be used. Depending on the structure of the data base and its indexes any other suitable index can be used. The primary index of the table is used in the following examples. In the example shown in , the join key columns , , , , , and are used to generate the respective Star Maps ,  and , respectively.","In one example, the table's  join key columns and are concatenated, or combined in some other way, and then hashed to generate a 32-bit hash-row value. This 32-bit hash-row value is then used to address the Star Map . In one example, the upper 16 bits of the 32-bit hash-row value are used to select a row  of the Star Map  and the lower 16 bits of the 32-bit hash-row value are used to select a column  of the selected row  of the Star Map . The column  value indicates whether the corresponding row may exist in the table  associated with the Star Map . If the selected column  value is set, then the corresponding row might exist in the table ; otherwise, the row would not exist in the table .","When the number of rows in the table  associated with the Star Map  is less than 4 billion, and when there is not significant skew in the join column values of its associated table, then each column  of the Star Map  may only comprise a 1-bit value to indicate whether the corresponding record exists in the table . However, when the number of rows in the table exceeds 4 billion, or when there is significant skew in the join columns of the table  associated with the Star Map, then additional bits may be added to each column  of the Star Map , so that a single column  can be used for multiple hash-row values of its associated table , in order to deal with hash collisions.","In one example, each column  within a row  of the Star Map  selected by the hash-row value of the table  associated with the Star Map  may comprise 16 bits. In that case, each hash-row value of the table  would select both a row  and a column  of the Star Map , and then another hash function would be performed on the join columns of the table  to select one of the bits within the selected column . If the selected bit is set, then the corresponding row might exist in the table ; otherwise, the row would not exist in the table . Of course, there would still be the possibility of hash collisions, even with the larger columns  of the Star Map .","The Star Map  is updated whenever changes are made to its associated table . For example, when a row is inserted into the associated table , a corresponding column  value in a corresponding row  of the Star Map  is set. Similarly, when a row is deleted from the table , a corresponding column  value in a corresponding row  of the Star Map  is reset, taking hash collisions into account. When a row is updated in the associated table , a column  value in a row  of the Star Map  corresponding to the new hash-row value and new column values are set, while a column  value in a row  of the Star Map  corresponding to the old hash-row value and column values are reset, while taking hash collisions into account.","The number of bits stored in each of the 64K columns  of the Star Map  is called the \u201cdegree\u201d of the Star Map  and determines the size of each row  in the Star Map . For example, a Star Map  of degree 1 has a row  length of 8 K bytes, while a Star Map  of degree 16 has a row  length of 128 K bytes. Generally, the degree of the Star Map  may be implemented as a parameter, so that the row size can be set to any desired value.","In the examples described above, the total size of the Star Map  is either 512 MB (a Star Map  of degree 1) or 8192 MB (a Star Map  of degree 16), respectively. The Star Map  may be partitioned across PUs  (for example, in a manner similar to the table) according to the upper 16 bits of the 32-bit hash-row value. Therefore, in a 20-node system , each PU  would store approximately 25 MB (a Star Map  of degree 1) or 410 MB (a Star Map  of degree 16) of a partitioned Star Map , respectively. Similarly, in a 96-node system, each PU  would manage approximately 5 MB (a Star Map  of degree 1) or 85 MB (a Star Map  of degree 16) of a partitioned Star Map , respectively. Partitions of these sizes may fit entirely within the main memory of the PUs .","Logic of the Join Algorithm","Star Maps can make the execution of joins involving a set of tables T through TN more efficient. Assume that each of the tables T through TN has an associated Star Map, S through SN, respectively. To perform a join, the system first performs a Boolean operation (such as a logical AND, OR, XOR, NAND, etc., or a combination of such operations) using the bitmap entries of the Star Maps S through SN to produce a join Star Map SJ. The system then uses SJ to select rows from the tables T through TN. For example, the system may use set bitmap entries in SJ as keys to select rows from T through TN. In one example, the hash value of the row or rows to be selected can be derived by concatenating the 16 bit Star Map row position and the 16 bit Star Map column position of a set bitmap entry to create a 32 bit hash value. Tables T through TN can then be searched for rows that hash to that hash value. Depending on the hash algorithm, the search can result in the retrieval of more than one row from a given table or tables. However, reconstruction of a hash value in any kind of Star Map environment can be performed very easily. Alternatively, the system may use unset bitmap entries in SJ as keys.","The system joins the resulting rows to produce a join result. Under certain circumstances, determined by the query, the Boolean operation being performed, and other factors including the size of SJ and the size of the tables T through TN, such a system will access fewer rows in T through TN to perform the join, thereby reducing the cost of the query.","Use of Star Maps to perform an equi-join using Star Maps for a join between two tables, T and T having Star Maps S and S, respectively, is illustrated in . The join is performed by logically ANDing S and S to form a join Star Map SJ (block ), as shown in . In one example, S and S are the same size and are created using the same hashing algorithm. In that case, ANDing the two Star Maps together requires applying a logical AND function to corresponding entries from the two Star Maps. An entry in the join Star Map is set only if the corresponding entries in S and S are set.","This is illustrated in , which shows two very simple Star Maps , , each having two rows and two columns. When they are ANDed together, only the first column of the first row of the join Star Map  is set. This is because the corresponding row and column are the only ones set to \u201c1\u201d in both source Star Maps  and .","A person of ordinary skill will recognize that it is not necessary for S and S to be the same size, be created using the same hash function or have the same mapping of hash values. If any of those parameters or any other parameter or parameters of S and S are different, the system will make the necessary adjustments between the two Star Maps prior to performing the AND function or as the AND function is being performed, assuming that S and S are sufficiently similar to allow such adjustments to be made. Persons of ordinary skill will also recognize that the AND function can be accomplished using other equivalent Boolean expressions, such as, for example, expressions equivalent to the AND function by virtue of DeMorgan's Law.","The resulting join Star Map SJ contains bitmap entries, which, when set, indicate that both T and T may contain rows that hash to the location of the set bitmap entry in the Star Map SJ. Consequently, joins between those sets of rows may contribute to the join result. If a bitmap entry in the Star Map SJ is not set then one of T or T does not contain any rows that hash to the location of that bitmap entry in the Star Map SJ. Consequently, joins between those sets of rows would not contribute to the join result.","Taking advantage of this characteristic, the system searches T and T for rows that hash to the location of each of the set bitmap entries in join Star Map SJ (block ). The system then Joins the resulting rows to produce a join result (block ). By joining only those rows that hash to locations of set bitmap entries in the join Star Map SJ, the system avoids accessing those rows in T and T that would not contribute to the join result, thereby saving time and cost in performing the join. If instead of a hash value, an actual column value is used to set the bitmap, then there would not even be a need to probe the base tables. However, this causes a limitation in the value range which, for example, could not exceed 4 billion for a degree 1 bitmap. To extend this range higher values, for example two 32 bit values or any other higher sized value could be used. It can be recognized that using an actual column value to set the bitmap also enables other key features that result in performance enhancements for qualifications based on range comparisons and joins that are not based on equality conditions (not equi-joins but joins such as T.column>T.column).","The use of Star Maps to perform join operations adds overhead to the join operation. The Star Maps for the tables must be read and logically ANDed to create the join Star Map and the base tables T and T must be searched for rows identified by the join Star Map. Above a threshold value of join result cardinality, the use of Star Maps as described above to perform joins will be less efficient than using traditional join methods. Thus, in one example system, the system will not apply the Star Map method described above if the join result cardinality is greater than a predetermined threshold. Cardinality of the join result may be predicted by the optimizer prior to performing the join based on statistics and operation cost collected by the system.","A similar algorithm may be applied if the number of tables involved in the join is greater than two, as shown in . In this scenario, an arbitrary number N of tables T through TN is involved in the query and Star Maps S through SN have been created for each respective table. If the cardinality of the search result is greater than a predetermined threshold (block ), as shown in , the system will use traditional join techniques to perform the join (block ).","If the cardinality of the search report is less than the predetermined threshold, the system will logically AND all of the Star Maps S through SN to form a join Star Map SJ. To accomplish this, the system first logically ANDs S and S to form the join Star Map SJ (block ). The system then enters a loop in which it ANDs the remaining Star Maps (S through SN) with the join Star Map SJ to produce a final join Star Map SJ. The system first initializes a counter (i) by setting it to 3 (block ). The system then determines if the index is less than or equal to N (block ). If it is, indicating that not all of the Star Maps have been ANDed into the join Star Map, the system ANDs the next Star Map, Si, with the join Star Map to form a temporary Star Map Stemp (block ). The system then sets the join Star Map SJ equal to the temporary Star Map Stemp (block ), increments the index i (block ) and returns to the beginning of the loop (block ).","Once all of the Star Maps, S through SN have been ANDed together, the index i will be greater than N and the system will operate as described above with respect to . For each set bitmap entry in SJ, the system will search T through TN for rows that hash to the location of the set bitmap entry in SJ (block ). The system will then join the resulting rows to produce a join result (block ).","This concludes the description of the preferred embodiment of the invention. The following describes some alternative embodiments for accomplishing the same invention. In one alternative embodiment, any type of computer, such as a mainframe, minicomputer, or personal computer, could be used to implement the present invention. In addition, any DBMS that performs equi-joins could benefit from the present invention.","The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
