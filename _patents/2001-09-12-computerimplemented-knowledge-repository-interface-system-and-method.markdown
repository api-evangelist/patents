---
title: Computer-implemented knowledge repository interface system and method
abstract: A computer-implemented knowledge repository data interface system and method for use by client applications to interact with a plurality of knowledge repositories. The knowledge repositories contain analytical models of interest to the client applications. A request handling module receives requests regarding the models from one of the client applications over a network. Knowledge repository application programming interfaces (APIs) are used to retrieve data about the models in the knowledge repositories based upon the received requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07039622&OS=07039622&RS=07039622
owner: SAS Institute Inc.
number: 07039622
owner_city: Cary
owner_country: US
publication_date: 20010912
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND AND SUMMARY","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention is directed to the field of computer-implemented knowledge repositories. More specifically, the present invention is directed to computer-implemented interfaces to knowledge repositories.","Modern business enterprises generate sizeable amounts of data concerning the operation and performance of their businesses. This data is typically stored within a large data warehouse, or some other large database infrastructure. Business analysts then review this voluminous data in order to make business recommendations. The data may be analyzed manually, in order to develop an intuition about the data, or to pick up patterns in the data, or it may be analyzed using statistical software to determine trends, clusters of data, etc.","More recently, with the explosion of Internet-related traffic, business enterprises are generating volumes of data that are one or more orders of magnitude larger than before. This increase in scale has made it almost impossible to develop an intuition about the data or to pick up patterns in the data by simply examining the data in its original form. Similarly, this increase in scale has made it difficult to manually execute separate statistical analyses on the data. Knowledge repository software applications have surfaced, but remain difficult to use on a wide-scale. Much of this difficulty stems from using traditional cumbersome methods of interfacing with the software applications.","The present invention overcomes these difficulties and others. In accordance with the teachings of the present invention, a computer-implemented knowledge repository data interface system and method are used by client applications to interact with a plurality of knowledge repositories. The knowledge repositories contain analytical models of interest to the client applications. A request handling module receives a request regarding the models from one of the client applications over a network. Knowledge repository application programming interfaces (APIs) are used to retrieve data about the models in the knowledge repositories based upon the received request.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["30","30","32","34","36","32","34","36"]},"The types of models differ based upon the needs of the end user . For example if the end user  is a business analyst, then the models may analyze customer survey responses or the types of web sites their customers visit. If the end user  is a rocket scientist, then the models may be finite element analysis fluid flow models or fuzzy logic engine control models (or other heuristic type algorithms). As still another example, a knowledge repository may concern the construction of a vehicle. Each model in the knowledge repository contains a portion of the knowledge used to construct a vehicle.","Typically, knowledge repositories contain numerous models to analyze the problems at hand. The numerosity results from different analysts contributing models to the knowledge repositories to study many different aspects of the problems. Not only are numerous models used to analyze the many different aspects of a problem, but also the models evolve over time. Model evolution may result in refinement, in which case the end user  would want to be certain that the end user  is using the latest version.","However to further complicate the situation, model versions may also reflect that different variables were tried with different versions. While a later model version may have suited one analyst's problem, the end user  may be more interested in the variables analyzed in an earlier version. The knowledge repository interface system  allows the end user  to easily and quickly locate the one or more models that best serve the end user's needs.","For example, the end user  may know that a decision tree model in one of the knowledge repositories will solve the end user's problem. However, the end user  only knows that the desired model was generated sometime between Jun. 1, 2001 and Jul. 31, 2001. The end user  provides a request to the knowledge repository interface system  for decision tree models that fall within that date range.","To submit requests to the knowledge repositories  and , the end user  invokes a client system . Within the client system , a client application  receives information from the end user  sufficient to formulate a request for the knowledge repositories  and . A data format, such as an extensible markup language (XML), may be used as the communication format between the client system  and the remote server system . A query XML module  translates the end user's request into an XML format. The XML formatted request might be requesting what models are contained in the knowledge repositories  and .","A sender module  transmits the XML formatted request using the web address of the remote server system . The web address may be the uniform resource locator (URL) of the remote server system . In a web environment, the sender module  uses the hypertext transfer protocol (http) to issue the request. However, the sender module  may use other types of protocols depending upon what protocols are compatible with the network environment at hand.","Within the remote server system , a web server  receives the request over the Internet . The web server  sends the XML formatted request to a requester module  (i.e., a request handling module). The requester module  contains an XML parser for determining the nature and details of the request. Because a request may involve more than one knowledge repository, the requester module  ascertains which knowledge repositories concern the request. For example if there were twenty knowledge repositories, the requester module  may ascertain that only three of the twenty knowledge repositories are relevant to the request. In another situation, all twenty knowledge repositories may be involved as when the requester module  receives a general request from the client system  as to what models are contained in the knowledge repositories. In such a capacity, the requester module  acts in part as a coordinator to optimize request handling among the different knowledge repositories. The requester module  may use a knowledge repository configuration file that indicates what knowledge repositories are located \u201cdownstream\u201d on knowledge repository servers to handle incoming requests. The configuration file may also provide instructions on how to \u201cscope\u201d the search. For example if a knowledge repository is added to handle incoming requests, the configuration file is updated to reflect the augmented informational scope that is available for searching due to the new knowledge repository. The configuration file may be a text file which allows configuration changes without necessitating a change to and re-compiling of the executable code of the requester module .","After the requester module  ascertains which knowledge repositories are needed to service the request, the requester module  formulates specific requests for these ascertained knowledge repositories. The specific requests are sent to the web servers that connect these knowledge repositories. For example, the specific requests may be sent to knowledge repository server systems  and  because they contain the knowledge repositories (e.g.,  and ) that can service the client's request. The requests formulated by the requester module  are transmitted to web servers  and  via their URL addresses. In this way, the knowledge repositories  and  are URL addressable as respectively indicated at reference numerals  and .","By way of an example, consider the processing performed by the web server  of a request from the requester module . Suppose that the request is to return information contained in the knowledge repository . An application programming interface (API) dispatcher  determines which API (or set of APIs) from a list  of knowledge repository APIs is needed to retrieve the requested information from the knowledge repository . Each API corresponds to an operation that can be performed upon the knowledge repository . An API may query the knowledge repository for what models are contained in that knowledge repository, or as another example an API may retrieve a specific model at the request of the end user . The names of the APIs may indicate their function, such as for example: getAllModels, getSiblingModels, getTargetVariable, getInputVariableList, getLift, getPercentResponse, getPercentCapturedResponse, getProfit, getROI (i.e., return on investment), getDiagnostic, getFitStat, and the like.","If the request is to return the knowledge repository home page, then the API dispatcher  retrieves its home page to send back to the server system . The home page may contain top-level model information, such as what is the general subject matter of the models contained within the knowledge repository.","A knowledge repository server system may contain both similar and different APIs from other knowledge repository server systems. For example, all knowledge repository server systems may contain the general API that retrieves all models contained in their own knowledge repositories. Knowledge repository server systems may also contain different APIs in order to provide information specific to their respective knowledge repositories. Suppose that knowledge repository server system  contains only decision tree models while knowledge repository server system  contains only fuzzy logic models. Knowledge repository server system  would contain APIs specific to how decision tree models are structured, and therefore would be able to process requests involving decision tree splitting values and the like. On the other hand, knowledge repository server system  would contain APIs specific to how fuzzy logic models are structured. Such APIs would understand how to handle requests for fuzzification mapping data and the like. However, it should be understood that a knowledge repository server system may contain APIs to handle model types that are not contained in its knowledge repository.","After the API dispatcher  selects the appropriate API to handle the request, an API execution module  uses the selected API to issue a query to the knowledge repository .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 2","FIG. 2"],"b":["38","34","68","62","52","58","62","56","58","50","38"]},"If the requester module  had dispatched requests to other knowledge repository server systems, then the assembler module  waits until the other knowledge repository server systems have provided their query results. The assembler module  examines the query results from each of the knowledge repository server systems in order to best package the results. This may include eliminating redundant query results. The assembler module  converts the multiple query results into an XML formatted message and sends it over the Internet  to the originally requesting client system . It should be further understood that the query processing performed by the assembler module  may also be performed in an asynchronous mode.","A receiver module  operating within the client system  accepts the message and passes it to a result XML module . The result XML module  includes a conventional XML parser to extract the reply to the end user's request. The client application  provides the reply to the end user . Based upon the reply, the end user  may initiate another request, such as obtaining more detailed model information now that the end user  knows what models are available to the end user .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3","b":["100","110","100","100","100","32","100","100","100","100","100","100"]},"The request  is sent to the remote server system . The requester module  queries the knowledge repository servers  via their URLs so that they may report whether they contain any decision tree models that satisfy the end user's criteria.","The knowledge repositories  may use model indexes  to speed up the model searching process. A model index contains metadata about what is stored in its associated knowledge repository, such as what decision tree models (if any) are stored in the knowledge repository. Even more detailed metadata may be contained in the model index such as what splitting variables were used for the models.","The selected knowledge repository APIs recognize whether they may search a model index for the information needed, or may bypass the model index and directly query the model data contained in the knowledge repositories. In some situations, the selected knowledge repository APIs search the model indexes in order to locate where in the knowledge repositories the requested data is located. In still other situations, the selected APIs search the model indexes to locate a portion of the requested data and then query the model data in the knowledge repositories to locate the other portions. It should be understood that the location of the model indexes may vary. A model index may be located separately from the knowledge repository on the knowledge repository server system, or located within the knowledge repository on the server. Still further the model index may be located on the remote server system  to prevent in certain situations the need to query the knowledge repository server systems.","The multiple knowledge repository search results are sent back to the assembler model  which formats the query results in an XML format . Tags A and B demarcate the starting and ending tags for information about one of the located models. Response  may include additional model tags for any other decision tree model that satisfies the end user's request.","Within the beginning and ending model tags A and B may be detailed model information, such as what the target variable of the decision tree model was (e.g., \u201cPurchase\u201d) and other information such as the date and version of the model. The analytical model specific tags allow much flexibility and model information to be provided to the user. The XML response message  is sent to the client system  where the result XML module  parses the response message  for presentation to the end user .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 4","b":["38","36","38","36","90","32","80","90","80","86"]},"Any query results may be processed through an assembler A that is resident on the knowledge repository server system . It should be noted that the knowledge repository interface system  may include an API function that provides knowledge repository URL information to the client system  so that the knowledge repositories may be directly accessed.","It should be understood that client systems may be accessing the knowledge repository interface system  without utilizing XML. In such cases, any commercially available structured request format may be used to transmit the request. The knowledge repository interface system  sends back responses to such client systems in a format understandable by the client systems.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIGS. 5\u20138","FIG. 5"],"b":["120","122"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6","b":["130","132","132","132","132","132","132","132","132","132","132"]},"With reference to , the client system issues at  as a second request the \u201cgetAllTreeModels\u201d API whose structure was returned by the remote web server. The request instructs the remote web server to return a list in an XML format of all decision tree models that are contained in the remote knowledge repositories.","The remote web server's XML formatted response is shown at  in . The XML formatted response  may contain multiple decision trees models within the models tag A. A listing of one decision tree model is shown by the model tag B. Details of the decision tree model are indicated by various tags within the model tag B, such as: the target variable analyzed by the decision tree model (as shown by tag C); the project within which the model is associated (as shown by tag D); the input data source (as shown by tag E); the target measurement type (as shown by tag F); the model name (if any) (as shown by tag G); various attributes of the decision tree model (as generally shown at H); and the like.","The back-and-forth information interchanges between the client system and the remote web server may be used to build queries on-the-fly for a model repository software application. The return codes from the function calls can thus be tested. The interchanges may occur in the XML data formats shown in . However, it must be understood that other formats may be used for the interchanges. For example, the remote web server may present its results as a formatted web page, where a user may select which operations are to be performed upon the remote knowledge repositories through combo boxes, checkboxes and the like.  depict such an exemplary scenario.","With reference to , interface  shows query results sent in an HTML format to the client system. The client system presents the query results as web pages to a human end user. The different viewing options are shown at , wherein an overall summary of the query results or the entire knowledge repository may be viewed by selecting the \u201cSummary\u201d button. A new model search may be performed by the end user by selecting the \u201cModel Search\u201d button, or the user may view the groups of models available for searching by selecting the \u201cModel Groups\u201d button. Other views and options may be created to suit the situation at hand.","The end user is presented with a category breakdown for knowledge repository . By selecting the other buttons indicated at , the end user may see a category breakdown for knowledge repositories  and . For the currently selected knowledge repository (i.e., \u201cRepository 1\u201d), the categories include: the time range in which the model was created; segment name; algorithm type; target variable; etc. The number of models in knowledge repository  that fall within each category is also listed. For example, thirty-five models have been created in knowledge repository  within the last three months. As another example, six models have studied online purchasing characteristics of customers as a target variable.","If an end user is interested in models that concern this characteristic, then the end user knows to issue a request to knowledge repository . The end user selects the model search button within region  to go to the search interface shown in .","With reference to , a model search interface is provided to the end user at . Repository  is selected via pull down control , and the end user specifies via control  that only models within the last three months are to be retrieved. All segment names are selected via control , as well as the algorithm type via controls . The \u201cOnline Purchase\u201d target variable is highlighted at control . The end user may also select hyperlink  to see the model predictor variables in order to further subset the search results.","At control , the end user may specify that only models which have been highly rated by model designers and other end users may be selected. The search is submitted to the remote web server when the end user activates hyperlink , or the search criteria may be saved by activating hyperlink  for submission at a later time. When the end user selects the search request submission hyperlink, the web server retrieves the model information that satisfies the search criteria.","Based upon the request, search results are sent by the remote web server as shown in  at . The search results match the end user's criteria. The end user may find several of the online purchase models of keen interest and select via select column  one or more of them so that they may be saved in a model group via controls . A listing of the selected model identifiers can be saved on the client system, or alternatively in a different location specified by the end user, such as on the remote web server or in another persistent store that is controlled by a knowledge repository web server. If the end user is particularly interested in online purchase models that relate to male children, then the end user may select model  via column .",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 12","b":["236","240","242"]},"An end user may evaluate a group of models together as shown for example in . Interface  lists a user-defined group of models  that have been stored under the group name \u201cCampaign Management Model Group\u201d. An end user may evaluate the models  by examining sibling models, historical models, or a diagnostic charts. Sibling models are models that have identical input data. Historical models are models that have the same target and segment. Diagnostic charts evaluate the predictive accuracy of a model.","Other model comparison techniques may be used, such as an input variable rank evaluation, which examines which input variables had the most pronounced effect upon the online purchase target variable. It must be understood that still other model comparison techniques may be used, such as examining the evolutions of each model that is to be compared. The examination provides a genealogical hierarchy of the selected models' evolution (i.e., a first model that has evolved into a second model which has further evolved into third and fourth models). A model's evolutionary hierarchy provides insight as to what variables were used at which stage of the evolution to attempt to solve the problem and what results were obtained. By understanding the model's evolution, the user can better understand how effective the model may be for the user's problem at hand. Based upon the evaluation, the end user may rate the selected models or remove certain models from the list of selected models .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIGS. 14A and 14B","FIG. 14A"],"b":["260","262"]},{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<function name=\u201cfunction_name\u201d >"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<arg name=\u201cx1\u201d value=\u201cyl\u201d\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},"."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<arg name=\u201cxn\u201d value=\u201cyn\u201d\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/function>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"1"},"When a computer program submits a function call, it may resemble the following:",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<function name=\u201cgetModel\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<arg name=\u201cproject\u201dvalue=\u201cEOY\u201d\/>"]},{"entry":[{},"<arg name=\u201cdiagram\u201dvalue=\u201c000\u201d\/>"]},{"entry":[{},"<arg name=\u201cmodel\u201dvalue=\u201cA000072\u201d \/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/function>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":"getModel(project=\u201cEOY\u201d, diagram=\u201c000\u201d, model=\u201cA000072\u201d);\n\nThe request is sent over the network at process block  and is received by the remote server system at process block . If the request is in an XML format, the function call is parsed by an XML parser. Processing continues on  as shown by continuation block .\n"}}}},"With reference to , the parsed name of the function call is used at process block  to select the proper knowledge repository API(s). It is noted that the function call contained in the request may have the same or different name from the selected knowledge repository API, and even may map to multiple knowledge repository APIs, with each API performing a part of the task. In this way, the calling computer program can send the same function call to multiple types of knowledge repositories data stores without having to tailor the query to each one. It is also noted that if the API evolves over time, the remote server system may detect which version of the API is being used by the calling computer program and return the response corresponding to that version. Because tagging (XML, HTML, etc.) languages evolve over time, the called program may further detect which version of the tagging language is being used and return the response corresponding to that version (e.g., <function name=\u201cgetTreeModels\u201d version=\u201c2.5\u201d>).","Process blocks  and  parse the parameters contained in the request and bind the request to the API. If the process blocks determine that the parameters are incompatible with the knowledge repository API, then a notification message is sent to the calling computer program. However if no errors arise, the knowledge repository API is dispatched at process block  to perform the requested task. At process block , the response is sent back to the calling computer program over the network. The computer program may initiate another request depending upon its examination of the current response. Processing terminates at end block .",{"@attributes":{"id":"p-0072","num":"0072"},"figref":"FIGS. 15\u201320"},"With reference to , a system diagram  depicts a structure of a model repository . The model repository  may be used with a data mining application . The data mining application  can search through the large volumes of data stored in the data warehouse  and can identify patterns in the data using a variety of pattern-finding algorithms. These patterns are then accessed by the business analyst through the knowledge repository interface system in order to make business recommendations. An example of such a data mining tool is Enterprise Miner\u2122, available from SAS Institute Inc., of Cary, N.C.","The data mining application  preferably includes an integrated model repository facility (MRF) A to control the export of models to the model repository , and the construction or update of one or more model indexes , , and . Alternatively, however, the MRF A could be a stand-alone application, in which case it would not be integrated into the data mining application .","The data mining application  analyzes data records stored in a data warehouse , or some other form of data storage facility. In particular, the data mining application  includes the decision tree processing module so that models with splitting variables may be generated, where the splitting variables are the variables in the data that best predict the outcome of the transactions. Although a single data warehouse  is shown in  for storing the data records, the data analyzed by the data mining application  could be spread out among numerous data warehouses  or numerous other database systems.","If the decision tree models are saved in the model repository , there are one or more dimension indexes ( and ) for the models. These indexes ( and ) include text representations, graph representations, pointers to model databases, and model level descriptions. These indexes are used to search the model repository for the decision tree models.","As described above, the data mining application  is executed using a particular model specification. A model specification typically indicates which input data to analyze from the data warehouse , which pattern-finding algorithm (such as a neural network, decision tree, fuzzy logic, etc.) to use for the analysis, how to partition the data, how to assess the results from the analysis, etc.","A data mining model, as generated, is a set of attributes related to a run of a data mining application or another type of statistical-related software application. For example, depending on the algorithm used to create the model, the attributes include the location of the input data, the scoring code, the fit statistics, and so on. However, it should be understood that data mining models can be generated by applications other than a data mining application, such as by a statistical modeling software application.","The models A, B, C that are generated by the data mining application  are initially stored in individual project folders . For example, each model creator  may have his or her own project folder stored in a database of project folders . The model creators  would then store their own models A, B, C in their individual project folders.","Using the model repository facility A, certain useful ones of the generated models A, B, or C can be selected and exported into the model repository . These useful models can then be searched for and retrieved manually by end users , or programmatically by end user applications . As described in more detail with reference to , the models A, B, N (of ) stored in the model repository  are organized according to a plurality of logical levels, including a project level, a diagram level, and a model level. The project level may include one or more diagrams, each of which describes a particular set of model specifications. Each diagram at the diagram level may then be associated with one or more individual models at the model level.","With reference back to , for each level of the model repository structure, one or more additional descriptive attributes may be associated with the models. The attributes provide descriptive information about the model that can be used to identify a particular model in the model repository  via a search and retrieval process. These attributes may be automatically associated with the models by the data mining application , or by the model repository facility A when the model is exported to the model repository . In addition, any of the system users , ,  may associate additional attributes with the models. The model attributes may be assigned at the project level, the diagram level, or at the individual model level.","These model attributes are then organized and structured into one or more indexes , , , which are also stored in the model repository . These indexes may include a main type index , which includes some or all of the attributes for each of the models A, B and N in the model repository , and\/or may include one or more special indexes, such as a tree-type index , which includes the attributes for a sub-set of all the models stored in the model repository . For example, the tree-type index  would include certain attributes of those models that were generated using a decision-tree algorithm. As described above, the decision-tree algorithm generates a type of attribute known as splitting variables, which are stored in the tree-type index . Also shown in  is a mini-index , which provides a quick-search capability for the tree-type index . These various indexes are used by end users , or by end user applications , in order to find a particular model, or set of models, within the model repository by executing a search and retrieval operation on the attributes stored in the indexes , , .","A variety of system users can interact with the data mining application  and the model repository , including a model creator  (e.g., a model designer), a model repository administrator , and an end user . The model creator  is the person who operates the data mining application  in order to generate a particular model. The model creator  determines the specifications for a particular data mining run, generates the corresponding model based on the specification, and then stores the model in his or her individual project folder . Alternatively, the model creator  could take an existing model from one of the project folders , modify the specification in some manner, and then generate a new model. Moreover, because the data in the data warehouse  typically changes over time, a model creator  can use the same specification against a later version of the data to generate a new model based on the updated data. The model creator  may then utilize the MRF A to export certain useful models to the model repository .","The model repository administrator  performs a variety of functions. One of these functions is to control access to the model repository . This may include controlling access rights to certain users, such as read access rights and write access rights. In this manner, the model repository administrator  can control which users can add or over-write models in the model repository (those having write access) and which users can only read models (those having only read access). The model repository administrator  may also control the process of deleting models from the model repository. Control of model deletion is important to ensure that a user with write access does not inadvertently delete a useful model from the model repository . In addition, the model repository administrator  may also determine which model attributes will be included in the main index .","The end user  may be a person who is interested in using the models in the model repository . The end user  could also be a model creator , although not all end users will be creating models. The end user  accesses the model repository  and searches for an appropriate model A, B, N by possibly examining the one or more index structures , , . By supplying search parameters and then comparing these search parameters against the attributes stored in the index structures, the end user  is able to find one or more useful models. Having found a useful model, the end user  may then obtain a copy of the information contained in the model.","The end user  may also be an end user application program that programmatically searches for and retrieves an appropriate model from the model repository . The end user application program can send a search and\/or retrieval request to the model repository  over a network, such as a local, wide area, or global (e.g., Internet) network. This search and retrieval capability makes it possible to automate the deployment of models for specific purposes. For example, suppose that part of the operation of an application requires that it find a \u201cbest\u201d model (perhaps based on the one with the best assessment results). Or suppose that part of the operation requires the application to choose a model from many similar ones (perhaps based on the one that was most recently generated from certain input data). That part of the operation can be accomplished automatically using the indexes , ,  to find the one or more models , and then by employing a comparison algorithm (which may be user-specified) to determine which model is most suitable for the particular task. For example, the comparison algorithm could look for the model with the lowest rate of misclassification. The ability to search for a model or models programmatically is particularly important in real-time applications, such as web-based applications, because a person could not find the appropriate model or models fast enough to suit the real-time nature of the task. The selected model  then could be used by the end user , for example to generate scored data .","In addition, with the appropriate access level, an end user  could from time to time make a copy of the index(es) , ,  and modify them in order to improve performance. Search and retrieval performance on the indexes would be improved because the modified copies would be stored locally to the end user, and because the copies could contain only the rows and columns of the index structure needed for his or her purpose. In this manner, each end user  could maintain his or her own index structures for the model repository .","Although a single model repository  is shown in , this is just one example of system . Alternatively, a particular business enterprise may have more than one model repository . In addition, a given model repository  may have more than one main-type index , or more than one special-type indexes , . For example, the marketing group of a particular business could have their own main index structure  that is based on the model attributes that matter for their purposes, and the sales group could have their own main index structure  that is based on other model attributes that matter for their purposes. Although a particular model repository  may have more than one special-type index , it is preferable that for the particular type of special-type index, such as the tree-type index  and mini-index , there would be only one of that type of index for each model repository .",{"@attributes":{"id":"p-0089","num":"0089"},"figref":"FIG. 16","b":["300","300","400","402","404","400","402","1","404"]},"Using this structure, multiple data mining projects can be associated with the same model repository , multiple data mining diagrams can be associated with the same project, and multiple models can be associated with the same diagram. A diagram represents the specifications for a number of data mining runs. There are typically groups of specifications, such as those related to the input data, the sampling technique, the data partitions, the data mining algorithm, the assessment methods, etc. More than one model may be associated with each of these diagrams. For example, although the specification may be the same for two models, there may be some attributes of the models that is different, such as when the model was run, that will result in a different model based on the same specification.","The first time that a request is received by the MRF A to export a model to the model repository  for a given project, a folder is created at the project level  for that project. The name of the project-level folder preferably identifies the current date and time and the last three characters of the requestor's user identification. For example if the current time was 19May2000:16:15:40 and the model export request was made by a person with the user identification \u201cabc,\u201d then the name of the new project-level folder would be \u201c20000519161540_abc_project\u201d. Note, however, Note, however, that this is just one way to determine the name for the project-level folders, and other methods could certainly be utilized.","The first time that a diagram is encountered within a particular project, the diagram is given a sequential number, such as 000, 001, 002, 003, . . . , etc. For a given diagram, there could be multiple models. For example, suppose the input data is sales records. If the diagram is used once a month, there will be one model each month. If every month's model is worth saving, every month the model repository  receives an additional model that is associated with that diagram of that project. Within a given project and diagram, there is thus a one-to-many relationship between the diagram and its models (and between the project and its diagrams).","The name of the model's folder preferably identifies the diagram with which the model is associated (i.e., 000, 001, 002, 003, . . . , etc.) and also preferably identifies the model itself. Each model preferably has a model-identification that is unique within the diagram and unique within the project.","The coarse organization is provided by project-id, diagram-number, and model-id. Although these identifiers provide a useful way to identify a model, a typical search is likely to require a finer level of granularity. In order to provide this finer level of granularity, model attributes are used. Some attributes are automatically generated and associated with the models in the project folder  by the data mining application  or by MRF A.","Model descriptors are attributes that are associated with the models in the model repository , and also may be used in the main index , which can be searched by an end user in order to find and retrieve a particular model  or set of models. Descriptors can be assigned at the project level, the diagram level, and\/or at the model level. Descriptors can be manually associated with the models in the project folder  by any of the system users , , . A descriptor preferably includes a variable-value pair, such as \u201csite=Chicago\u201d or \u201csize=100,000\u201d. In these examples, site is a variable and Chicago is its value, and size is a variable and 100,000 is its value. The variable-value pairs may be manually specified by one of the system users , ,  via a graphical user interface element, such as a pop-up window, notes tab, or other graphical data entry means, for selecting the particular project, diagram or model, and then for entering the appropriate descriptor.","As a result of these levels of attributes, a given model is identified by its own attributes, the attributes of its diagram, and the attributes of the diagram's project. By storing and organizing these model attributes in the various index structures , ,  of the model repository , a much finer granularity for searching is provided.",{"@attributes":{"id":"p-0097","num":"0097"},"figref":["FIG. 17","FIG. 15"],"b":["326","300","326","340","342","342","342","1","2","3","1","344"]},"In principle, the main-type index  could be constructed using the variables for every attribute associated with the models stored in the model repository . For practical reasons, however, the model repository administrator  preferably selects a subset of the attributes in order to construct the index, where the subset represents the attributes that end users  most likely would utilize in order to conduct a search. In addition, the model repository administrator  could decide to build more than one main-type index  for the model repository . Having more than one main index  would be useful if the search strategies employed by users can be grouped into several categories. In this situation, there could be one main-type index  per search category, with the attributes in that index being the ones that are useful in that category of search.",{"@attributes":{"id":"p-0099","num":"0099"},"figref":["FIG. 18","FIG. 15"],"b":["328","328","327","300","326","328","350","354","352","352","352","352","328","328","1","0"]},"A model that results from a decision tree analysis identifies the variables that enable groups to be identified within the data. The records\/observations within a group have similar behavior with respect to a target variable. For example, in a sales analysis, the target variable might be the one that contains the total amount of the sale. The variables that define the groups in the decision tree analysis are called predictor variables. The predictor variables that are most important to the analysis are called the splitting variables. It is these splitting variables that are listed in the tree-type index . The other predictor variables describe splits that are too trivial to matter to the outcome of the analysis.","The tree-type index A is preferably constructed using every splitting variable in the model repository . There are preferably two formats for the tree-type index . The format that is most comfortable for people to work with (such as, index A), if browsing the index, may or may not be the format that gives the best performance (such as, index B) to an application that may be automatically searching for and retrieving models from the model repository .","The first format A is shown in , as described above. The second format B is a table that has as many rows per model as the model has splitting variables. This second format B is shown in , and includes two columns, a first column  that identifies the model, and a second column  that identifies the splitting variable. If the model's identification is not unique within the model repository, then an additional column is used to identify the project for which the model was generated. In this second format B, if a model has four splitting variables, then the model has four rows in the table.","If the number of rows in the tree-type index  becomes too large for efficient searching, then an additional mini-index  can be provided in the model repository . The mini-index  contains a list of the names of all the splitting variables in all the models. In the mini-index , each splitting variable name appears only once. In the tree-type index , each splitting variable name may appear many times. Thus, the mini-index  is an index to the tree-type index . If the mini-index  is searched first, and the splitting variable that is needed is not there, then there is no need to search the tree-type index , thus making the search process more efficient.",{"@attributes":{"id":"p-0104","num":"0104"},"figref":["FIG. 20","FIG. 15"],"b":["330","300"]},"The embodiments described above are examples of structures, systems and methods having elements corresponding to the elements of the present invention recited in the claims. This written description enables those skilled in the art to make and use embodiments having alternative elements that likewise correspond to the elements of the invention recited in the claims. The intended scope of the invention may thus include other structures, systems or methods that do not differ from the literal language of the claims, and may further include other structures, systems or methods with insubstantial differences from the literal language of the claims. As an illustration,  depicts the knowledge repository interface system being used by a model creator . The model creator  constructs models and stores them in the knowledge repositories . The model creator  invokes the knowledge repository design-related APIs. The design-related APIs allow the model creator  to create new models in the knowledge repositories  and hone the models by conducting experiments with them. In this way, the model designer  can interact in a design capacity although remotely located from where the models are located.","It is further noted that different configurations of the knowledge repository interface system may result due to security reasons. The remote server system  may be interposed between the client system  and the knowledge repository server systems  as a security buffer. Different client systems and their users may have different authorizations to the knowledge repositories. One user on a client system may have access to all knowledge repositories, while another user on the same client system may have only read access (i.e., no edit, delete or write access) to a limited portion of information within one knowledge repository. Security authorization may also restrict what knowledge repository APIs are available to an end user."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 14A and 14B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 21"}]},"DETDESC":[{},{}]}
