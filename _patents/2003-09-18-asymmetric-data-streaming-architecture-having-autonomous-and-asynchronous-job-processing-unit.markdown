---
title: Asymmetric data streaming architecture having autonomous and asynchronous job processing unit
abstract: In a preferred embodiment, the present invention is an asymmetric data processing system having two or more groups of processors that have attributes that are optimized for their assigned functions. A first processor group, which may be SMP machines, are responsible for interfacing with applications and/or end users to obtain queries, and for planning query execution. A second processor group consists of many streaming record-oriented processors called Job Processing Units (JPUs), typically arranged as an MPP structure. The JPUs carry out the bulk of the data processing required to implement the logic of a query, running autonomously and asynchronously from other processors in the system. The JPUs preferably use a multi-tasking operating system that permits multiple tasks to run at a given instant in time, in either an absolute-priority-based or a weighted-priority-based demand scheduling environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07634477&OS=07634477&RS=07634477
owner: Netezza Corporation
number: 07634477
owner_city: Marlborough
owner_country: US
publication_date: 20030918
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","Brief Description of a Preferred Embodiment","DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/412,057 entitled \u201cAsymmetric Streaming Record Processing Computer System,\u201d filed on Sep. 19, 2002, and U.S. Provisional Application No. 60\/411,686 entitled \u201cIntelligent Storage Device Controller,\u201d filed on Sep. 18, 2002. The entire teachings of these provisional applications is hereby incorporated by reference.","This application is also related to U.S. Patent Application entitled \u201cIntelligent Storage Device Controller,\u201d (application Ser. No. 10\/667,203); U.S. Patent Application entitled \u201cField Oriented Pipeline Architecture for a Programmable Data Streaming Processor,\u201d (application Ser. No. 10\/665,726); U.S. Patent Application entitled \u201cAsymmetric Streaming Record Data Processor Method and Apparatus,\u201d (application Ser. No. 10\/666,729); and U.S. Patent Application entitled \u201cProgrammable Streaming Data Processor For Database Appliance Having Multiple Processing Unit Groups,\u201d (application Ser. No. 10\/668,113), all of which are being filed together on the same date as this application. The entire teachings of each of these co-pending patent applications is also hereby incorporated by reference. This application and the above applications are also all assigned to Netezza Corporation.","This invention relates to distributed data processing systems that use multiple processing unit groups, and in particular to an asymmetric architecture that allows for autonomous and asynchronous operation of processing units in at least one group.","With continued development of low cost computing systems and proliferation of computer networks, the world continues to see an exponential growth in the amount and availability of information. Indeed, the Massachusetts-based Enterprise Storage Group has observed a doubling of information every few months. Demand for easy and efficient access to this ever-growing amount of digital information is another certainty. For example, World Wide Web traffic increased 300% in 2001 according to Forrester Research. Included among the applications that continue to make the greatest demands are systems for processing:\n\n","Greg Papadopolous, the Chief Technical Officer of Sun Microsystems, Inc., has observed that the demand for access to decision support databases, referred to as the Input\/Output (I\/O) demand growth, doubles every nine months. To put this in context, Moore's Law predicts that Central Processing Unit (CPU) power doubles only about every 18 months. In other words, the demand for access to information is growing at least twice as fast the ability of a single CPU to process and deliver it.","In a typical general purpose data processing system, data is stored on one or more mass storage devices, such as hard disk drives. One or more computers are then programmed to read data from the disks and analyze it\u2014the programs may include special database software written for this purpose. The problem with a general purpose system architecture, however, is that all the data must be retrieved from the disk and placed in a computer's memory, prior to actually being able to perform any operations on it. If any portion of the data retrieved is not actually needed, the time spent fetching it is wasted. Valuable time is thus lost in the process of retrieval and storage of unnecessary data.","The speed at which the data analysis can be performed is typically limited to the speed at which the entire set of data can be transferred into a computer's memory and then examined by the CPU(s). Usually, the aggregate data transfer rate of the disks does not govern the speed at which the analysis can be performed. Disks are inexpensive, and as such, data can be spread across a large number of disks arranged to be accessed in parallel. The effective data transfer rate of a set of disks, collectively, can therefore be almost arbitrarily fast.","The bandwidth of an interface or communications network between the disks and the CPUs is also typically less than the aggregate data transfer rate of the disks. The bottleneck is thus in the communications network or in the CPUs, but not in the disks themselves.","It has been recognized for some time that achieving adequate performance and scalability in the face of vast and rapidly growing data thus requires some kind of system architecture that employs multiple CPUs. The three most prevalent classes of so-called multiprocessing systems today include:\n\n","SMP systems consist of several CPUs, each with their own memory cache. Resources such as memory and the I\/O system are shared by and are equally accessible to each of the processors. The processors in an SMP system thus constitute a pool of computation resources on which the operating system can schedule \u201cthreads\u201d of executing code for execution.","Two weaknesses of the SMP approach impair its performance and scalability when processing very large amounts of data. The first problem results from a limited ability to actually provide information to the processors. With this architecture, the I\/O subsystem and the memory bus are shared among all processors, yet they have a limited bandwidth. Thus, when the volume of data is too high, the speed of the processors is wasted waiting for data to arrive. A second problem with the SMP approach is cache coherence. Within each processor is typically a cache memory for storing records so that they may be accessed faster. However, the more that processors are added to an SMP system, the more that time must be spent synchronizing all of the individual caches when changes are made to the database. In practice, it is rare for SMP machines to scale linearly beyond about 64 processors.","Asymmetric Multiprocessing (ASMP) systems assign specific tasks to specific processors, with a master processor controlling the system. This specialization has a number of benefits. Resources can be dedicated to specific tasks, avoiding the overhead of coordinating shared access. Scheduling is also easier in an ASMP system, where there are fewer choices about which processor to assign to a task. ASMP systems thus tend to be more scalable than SMP systems. One basic problem with asymmetry is that it can result in one processor being overloaded while others sit idle.","Massively Parallel Processing (MPP) systems consist of very large numbers of processors that are loosely coupled. Each processor has its own memory and devices and runs its own operating system. Communication between the processors of an MPP system is accomplished by sending messages over network connections. With no shared resources, MPP systems require much less synchronization than SMP and ASMP systems.","One weakness of the MPP model is that communication among processors occurs by passing messages over a network connection, which is a much slower technique than communication through shared memory. If frequent inter-processor communication is required, then the advantages of parallelism are negated by communication latency. Another problem with the MPP approach is that traditional programming models do not map cleanly onto message passing architectures. Using approaches such as Common Object Request Broker Architecture (CORBA), which are designed to handle message passing, are considered awkward by some designers.","In the late 1970s and early 1980s, several database machine architectures were proposed to move database processing closer to the data, and to offload other work from CPUs. A common theme of these machines was special hardware for performing database functions, integrated tightly with a disk. David DeWitt of the University of Wisconsin proposed a categorization scheme for these machines according to whether they had a processor per track (PPT), a processor per head (PPH), or a processor per disk (PPD).","The Content-Addressable Segment Sequential Memory (CASSM) machine was designed as a complete database engine, with a proprietary query language, and a processor per track (PPT). The CASSM processors could perform aggregation functions and had a bit-mapping scheme to process field-based searches.","The Rotating Associative Relational Store (RARES) was a selection and sorting machine, in which record data was laid out across disk tracks (rather than within disk tracks), which allowed it to examine the different fields of a record in parallel.","The DIRECT machine used a symmetric two-tier MPP system. The first tier compiled queries into packets, which could be distributed to processors in the second tier to balance the load. The processors in the second tier used a crossbar switch that allowed them to access data from any storage unit. The present invention also uses a two-tier MPP approach, but unlike the DIRECT machine, the present invention assumes an asymmetric approach, in which each back-end processor is the exclusive \u201cowner\u201d of its data. This avoids time spent in load balancing and in coordinating access to data among multiple processors. By tightly coupling processing with a set of data, the cost and complexity of the DIRECT crossbar switch can be avoided.","So-called Intelligent Disks (\u201cIDISKs\u201d) are a package including disk drive, power, CPU, memory, and network interface, running a full and standard operating system. They are intended to offload computation from desktop machines. Intelligent disks are typically positioned as commodities for use in various applications, supporting file systems and directories, database, Internet, and mail. One goal of Intelligent Disks is to allow the incremental addition of capacity by plugging in new slices and choosing a personality (such as \u201cfile system\u201d or \u201cmail\u201d) to extend.","In the Magi system (Notre Dame), Kendall and Freeh describe a programming model in which applications apply modular stream-oriented operations to data. They discuss the use of IDISKs for intelligent caching, data compression, and database search.","Bill Bridge (Oracle) explains that, for purposes of database processing, Intelligent Disks can help allocate storage at a block level, but space within a block must be controlled by the application access method, and Intelligent Disks cannot get involved at this low level.","Like Intelligent Disks, so-called Active Disks bundle processing power, memory, and network connectivity with a disk to offer performance and functionality enhancements. Erik Reidel (CMU), a leading proponent of Active Disks, cites the following advantages of the technology:\n\n","Mustafa Uysal (University of Maryland) stresses the importance of a restricted execution environment for application disklets, controlled by a thin disk operating system (DiskOS), which manages scheduling, memory management, and communications. Along with Acharya (UCSB) and Saltz (UMD), Uysal notes that, while disklets can be written in any language, they should not be allowed to initiate I\/O, allocate or free memory, or determine the source or destination of a stream of data. These characteristics differentiate Active Disks from Intelligent Disks. Where the former has a thin special-purpose operating system, the latter uses a general OS like Linux. Where the former allows disklets to be written in any programming language, with execution restrictions, the latter provides special stream-processing primitives, and does not impose execution restrictions.","In a performance simulation, Uysal found limited benefit to having more than 32 megabytes of memory available to the Active Disk. Instead, Uysal's simulation indicated the value of processing intermediate results as they arrive (to reduce memory usage and synchronization), and of forwarding partial results on to other processors when out of memory.","Several researchers focus on the use of Active Disks for non-database applications. For example, Lim (University of Minnesota), Kapoor (Valicert), and Wighe (Wind River Systems) use Active Disks to implement a scalable file system.","In a preferred embodiment, the present invention is a data processing system having two or more groups of processors that have attributes that are optimized for their assigned functions. A first processor group consists of one or more host computers, which are responsible for interfacing with applications and\/or end users to obtain queries, for planning query execution, and for, optionally, processing certain parts of queries. The hosts in the first group may be SMP type machines. A second processor group consists of many streaming record-oriented processors called Job Processing Units (JPUs), typically arranged as an MPP structure. The JPUs typically carry out the bulk of the data processing required to implement the logic of a query.","Functions of the host computers include parsing queries, generating query execution plans, optimizing parallelizing execution plans, controlling transactions, sending requests for processing to the JPUs, and receiving results of such requests. The hosts are also responsible for scheduling the execution of jobs to run locally within the host itself, or even in a third group of computers referred to as Large Job Processing Units (LJPUs).","LJPUs, which may or may not be present, preferably consist of a relatively high speed processor and relatively large amounts of memory. The LJPUs may be organized as an SMP that share portions of memory. If LJPUs are present, they can be employed to carry out suitable jobs as part of a query, such as operations that must be performed on large materialized data sets. This may include sorting, grouping, relational joining and other functions that might not otherwise be possible on a given JPU. The LJPUs may be located in the same SMP cluster as the first processor group.","However, the LJPUs also preferably play an important role in other functions, such as an Execution Engine which assist the host with coordinating the results from the many jobs that may be running autonomously and asynchronously in the JPUs.","JPUs typically include a general purpose microcomputer, local memory, one or more mass storage devices, and one or more network connections. The JPUs preferably use a multi-tasking operating system that permits multiple tasks to run at a given instant in time, in either an absolute-priority-based or a weighted-priority-based demand scheduling environment.","The JPUs are responsible for:\n\n","In a preferred embodiment, each of the JPU components is dedicated to processing a predetermined subset of the a larger data set. This architectural limitation further permits each JPU to run jobs and\/or portions of queries autonomously and asynchronously from jobs in process by other JPUs.","The architecture thus supports a programming model for JPUs based on jobs. A job is a portion of a larger query that can be processed to completion by either a JPU or an LJPU or a combination of the two. When processed by a JPU, a job is preferably structured so that it may run using only (a) the information already locally and authoritatively available to the JPU, and\/or (b) the information directly provided to the JPU as part of the job. This allows JPUs to run autonomously and asynchronously.","A JPU may also perform other activities asynchronously and autonomously for its associated data sets such as storage allocation and deallocation; insertion, deletion and retrieval of records; committing and rolling back transactional changes; locking; logging; mirroring; replication; compression, decompression; view maintenance; and software and hardware status reporting. As a result, such functions and other administrative tasks can be carried out in a manner that is optimized for that particular JPU.","It is the case that many query execution plans require coordination such that certain jobs must be carried out in a specific sequence, which others may execute in parallel. A job dispatch component in the host may be thus used in some embodiments of the invention to enforce a requirement that certain jobs must be run in sequence. This can be implemented by issuing each job a job identifier \u2018tag\u2019. A job listener component in the host then coordinates receiving job identifiers from one or more JPUs or LJPUs as jobs are completed. The Execution Engine in the LJPU may also assist with coordinating these reports from the JPUs. This then permits results from one or more JPUs or LJPUs to be amalgamated, before results of a particular job are reported to the application.","In a preferred embodiment, each JPU also has a special purpose programmable processor, referred to herein as a Programmable Streaming Data  Processor (PSDP). The PSDP acts as an interface between the CPU of a JPU and storage controller and\/or the mass storage device. The PSDP is a processor that is distinct from the more general purpose CPU in each JPU. It is also distinct from the CPU of the \u201chost\u201d in the first group.","The PSDP can be implemented as a Field Programmable Gate Array (FPGA), as in the preferred embodiment, or as an Application-Specific Integrated Circuit (ASIC), a fully-custom Application Specific Standard Product (ASSP), or even as discrete logic on a printed-circuit board. It can also be included in an integrated processor (i.e., a CPU that includes peripheral interface logic) on a single chip or in a single package, or it could be included with the circuitry of the mass storage device.","In addition to assisting the JPU in accessing data, the PSDP is a programmable device that is used to interpret data in a specific format as it is read from or written to the associated disk(s). This enables PSDP to perform portions of jobs on data directly, as it is read off the disk, prior such data being loaded into the memory of the JPU.","In an embodiment specifically adapted for processing of record-oriented data, data can be filtered by the PSDP as records and fields of a database, so that only certain fields from certain records are actually forwarded to be written into the associated JPU's main memory.","However, many other operations beyond simple filtering are possible to implement in the PSDP. For example, records with certain characteristics can be tagged as they are written in the JPU's main memory, to indicate that such records are to be ignored in further processing, or to indicate certain attributes of such records, such as if they are to be handled differently in a transactions from other records.","While the invention is of use in processing field-oriented database records, it should be understood that the system can also be used to advantage in processing many different types of data, including other field delimited data such as tables, indices, and views. The system is also advantageously used to process less structured data such as character strings, Binary Large Objects (BLOBS), XML, graphics files, and the like.","Discussion of Advantages","An important advantage of using an asynchronous, autonomous job model for execution is that JPUs can complete jobs without waiting for additional information from a host or another JPU. This increases the potential throughput of requests through a JPU, and minimizes the scheduling\/coordination overhead that would otherwise be required to suspend requests in the middle of their operation until additional information was supplied.","This also enables autonomous (i.e., independent) operation of the JPUs. Specifically, each JPU may have its own multi-tasking operating system with a scheduler that determines the particular job that each JPU is dedicated to doing at a particular time based upon its local conditions. For example, if a group of JPUs are collectively assigned a sequence of jobs by the host, individual JPUs are free to complete the sequence on their own data without coordinating with other JPUs, waiting for results from other JPUs, or otherwise being constrained in the timing of their completion. This frees individual JPU to then run other jobs that may even relate to other queries, while neighboring JPU's continue to process jobs from the first query.","In certain prior art MPP architectures, parallel components operate synchronously, in lockstep. However, even if certain parallel processors finish a requested function quickly, such a system must still wait for the processor that performs the requested function most slowly to finish, before it can proceed with further work. This is not a particular problem in applications such as digital signal processing or image processing, where an identical sequence of operations is to be executed on all elements of a data set at the same time. However, in database systems, operations such as scan and restrict typically select only a portion of a data set to be subjected to further operations.","In contrast to such synchronous lock-step systems, in the present invention, a JPU processes requests asynchronously and autonomously. Each JPU is thus free to process its requests as quickly as it can, and return its results (partial or complete) to the requestor. In the interim, the JPU is available to process a different job. This asynchronous approach allows more work to flow through a system consisting of many independent JPUs.","In further aspects of the invention, the JPUs are implemented as embedded components. Thus, they are not directly accessible to applications or end users of the system. This architectural limitation has several advantages, among them:\n\n","This architecture also relieves remote or host processors from the necessity of tracking the state of multiple JPUs and making remote decisions about local affairs, which has further advantages of avoiding:\n\n","A. System Level Architecture","First Group Components","The present invention is a data processing system having at least two \u201cgroups\u201d of processing units, in which the individual components of each group are individual network \u201cnodes\u201d within the system. As will be explained in detail below, the present invention has to do with how the processors on the second group may operate (a) asynchronously, with respect to each other and with respect to processors in the first group and (b) autonomously, in the sense that they can complete assigned tasks without waiting for data from other processors.","As more particularly shown in , the first group  consists of one or more SMP \u201chost\u201d computers -, . . . , -, each with its own memory, network interface, and local storage (not shown in ). Each host  runs its own operating system, and typically, but not necessarily, each host  uses the same type of operating system as the other hosts .","The hosts  typically accept queries that are requests for data stored on mass storage devices, such as hard disk drives . The requests may originate from any number of applications, typically business intelligence applications, that may be residing on local processors  or client computers  or separately running application software , that may originate through a computer network  or locally. Queries are typically provided in a format such as Structured Query Language (SQL), Open DataBase Connectivity (ODBC), Java DataBase Connectivity (JDBC), or the like.","The hosts  accept queries that can retrieve, modify, create and\/or delete data stored on disk  and the schema for such data. The hosts  also accept requests to start, commit, and rollback transactions against the data. The hosts  also perform typical administrative functions such as reporting on the status of the system , start and shutdown operation, backing up the current state of the data, restoring previous states of the data, replicating the data, and performing maintenance operations.","Optionally, there is a load balancing function  in front of the host  processors, which directs individual transactions to specific host or hosts  so as to evenly distribute workload.","A catalog management component  contains descriptions of the fields and layout of data. Catalog management  also contains information about which users and applications have which permissions to operate in which ways on which types of records, datasets, and relations. The various hosts  interact with catalog management  in order to process the requests they receive. In one embodiment, catalog management  is embedded within one of the hosts , with parts replicated to the other hosts  and second group  components. As will be understood shortly, the catalog manager is used to provide information to permit the components of the second group  to perform filtering functions.","With the exception of their need to consult catalog management , the hosts  are generally able to respond to requests without having to communicate among themselves. In very rare instances, inter-host  communication may occur to resolve a transaction sequencing issue.","Second Group Components","The second group  consists of a plurality of Job Processing Units (JPUs) -, -, . . . , -. As shown in , each JPU  consists of a network interface  for receiving requests and delivering replies, a general purpose Central Processing Unit (CPU)  such as a microprocessor , memory , and a Programmable Streaming Record Processor (PSDP) . Each JPU  runs a multi-tasking schedule-based operating system. Each JPU  also has an attached disk  and disk controller from which the JPU  may read streaming data. In other embodiments, the JPU  can receive streaming record data from alternate or additional sources such as other on-board processors or via other network interfaces in place of the disk drives . Such streaming data might include stock quotes, satellite data, patient vital signs, and other kinds of \u201clive-feed\u201d information available via a network connection.","The JPU  accepts and responds to requests from host computers  in the first group  to process the streaming record-oriented data under its control. These requests are typically \u201cjobs\u201d of a larger query, and are expressed as sequences of primitive operations on an input stream. The primitive operations could be interpreted, but in the preferred embodiment, they are packaged as compiled code that is ready for execution. An exemplary job-based query is described in more detail below.","In addition to processing jobs, a JPU  also accepts and responds to requests from hosts for other operations such as:\n\n","Each JPU  also accepts and responds to requests from the hosts  to:\n\n","JPU(s)  typically use a multi-tasking Operating System (OS) to allow receiving, processing, and reporting the results from multiple jobs in a job queue. In the preferred embodiment, the OS should also support overlapping job execution. To coordinate this, the OS typically is responsible scheduling and prioritizing requests according to a number of factors that are determined in real time. These may include a job priority as assigned by the user and\/or host , as well as a job's expected impact on the JPU's  local resources includes the amount of memory, disk, network, and\/or I\/O queues needed to complete the job. The JPU  can also contain software for performing concurrency control, transaction management, recovery and replication of data for which the JPU is responsible.","In the preferred embodiment, JPUs  in the second group  are not directly visible or accessible to the users of, or the applications that run on, for example, the external clients that present queries to the system . The JPUs are an embedded component and maintain significant autonomy and control over their data. A given record (or other data primitive) in the system  is thus normally directly accessible to, and processed by only one JPU . While JPUs may replicate their records to increase reliability or performance, they do not share responsibility for processing a given record with other JPUs  when carrying at a job as part of a query.","The storage manager  within each JPU  provides autonomous and asynchronous support for other functions such as error checking, creation and deletion of tables, the use and maintenance of indices and views, record insert and delete, mass loading of existing user data among various JPUs, and the like.","3. Third Group Components","The system architecture exhibits further aspects of asymmetry in that one or more so-called Large Job Processing Units (LJPUs)  can also play a part in processing queries. Each LJPU  consists of a network interface for receiving job requests and delivering replies, and one or more general purpose Central Processing Units (CPUs) -, . . . , -(each of which may have their own internal memory), as well as a shared memory . The CPUs  in the LJPUs  preferably represent a relatively powerful computing resources, consisting of a relatively high speed processor that has access to relatively large amounts of memory. The LJPUs may be organized as an SMP that share portions of memory . The LJPUs may be located in the same SMP cluster as the first processor group.","LJPUs are employed to carry out jobs that are not otherwise suitable or possible to perform on the JPUs, such as operations that must be performed on large materialized data sets. This may include sorting, grouping, relational joining and other functions on filtered data, that might not otherwise be possible on a given JPU.","The LJPUs also preferably play an important role in other functions. One such function is to serve as an Execution Engine which assists the hosts  with coordinating the results from the many jobs that may be running autonomously and asynchronously in the JPUs .","LJPU(s)  may also typically use a multi-tasking Operating System (OS) to allow receiving, processing, and reporting the results from multiple jobs in a job queue. In the preferred embodiment, the OS should also support overlapping job execution. To coordinate this, the OS typically is responsible scheduling and prioritizing requests according to a number of factors that are determined in real time.","Throughout the system, the components and sub-components are designed to optimize performance through extensive use of streaming operations coupled with tuple set operations. As will be understood shortly most operations are designed to take tuple sets (records or groups of records) as their input and output streams; these operations try not to materialize data, but instead they stream the output to the next operation. As a consequence many operations can be handled as one continuous data flow, whereas in a conventional system, it would be necessary to handle them in various layers.","For instance, a storage layer can be designed as a tuple set manager where (from the view of other JPU processes) it stores and retrieves tuple sets. From the storage layer onward, data is normally handled in tuple sets, providing a consistent, well organized, and easily accessible format for internal operations. This is in contrast to other systems where the storage layer stores and retrieves undifferentiated blocks of data which are later converted to tuple sets by some other downstream process. Another example of the streaming\/tuple set architecture is the network layer, which sends and receives tuple sets instead of blocks of data.","Yet another example is a merge aggregation node, where a sorted data stream is aggregated as requested, and whenever a new key index value is received, the aggregation from the previous key index value may be streamed to the next node.","A streaming\/tuple set operation can be illustrated by tracking a typical dataflow during a load operation. In this example load case, as data is read into a host  over TCP\/IP network connection , that data is parsed, error-checked, and transformed, and the distribution value calculated, all while the specific byte\/field is in processor cache, and saved to the internal network output frame buffers as one step.","The result is that the input data is read and transformed in a streaming fashion and converted to network-ready tuple set packets at streaming speed with minimal overhead. Specifically, as each data record is received, it is sent over the internal network  to an appropriate JPU  (as determined by the a distribution value in a Query Plan). At the JPU , the received data is read, converted into an approved storage format, and placed in memory buffers on a record-by-record basis. As memory buffers are filled, a storage layer in the JPU double-checks that the data corresponds to the indicated table, and that the table \u201cowns\u201d the physical space on the disk , and then writes that data to the disk . Note that during this process, a given byte of data was \u201ctouched\u201d only a few times, and that the data was manipulated in tuple sets thereby optimizing performance and reliability.","A second illustration of a streaming tuple set operation is a join\/aggregate operation where three joins and one co-located aggregation are performed on JPUs , and the results are returned through the host  via ODBC to the ODBC client  (e.g., Business Objects). In this example, on each of three JPU's, the disk  is scanned and data read off the disk through the associated PSDP, which filters records of interest and fields of interest within those records, and places the resulting tuples into a tuple set buffer in JPU memory. As each tuple set buffer is filled, that tuple set is passed through each of three JPU join nodes and the aggregate node in turn. Each time a new key value is received by the aggregate node, the previous aggregate value and associated key value tuple are transformed as necessary per the ODBC request, and placed in the JPU network packet output buffer associated with the requesting host . When a network packet output buffer in the JPU is filled, its contents are sent to the host , where it is immediately placed in the user-side network buffer and is immediately sent to the ODBC client .","Note that, as in the previous example, the data was \u201ctouched\u201d only a few times. Because the data was handled in tuple sets, it could be operated on as integral units with very minimal overhead. Because the operations are extremely integrated, mixed operations such as joins, aggregates, output transformation, and network packet creation are all performed while the data is in processor cache memory.","B. Host Software Functions",{"@attributes":{"id":"p-0090","num":"0120"},"figref":"FIG. 3","b":["12","22"]},"Postmaster \/Postgres ",{"@attributes":{"id":"p-0091","num":"0000"},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":{"@attributes":{"id":"ul0017-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":["Serves as Front-end for query processing","Postmaster  accepts requests from user applications via API ","Creates an Execution Plan","May use authentication\n\nPlan Generator \n","Parse\/query rewrite\/planner\u2014plans how query will be processed.","Supports SQL-92 DDL\/DML","Supports SQL Functions","Provides compatibility with Oracle, SQL Server","Integrated with SQL triggers, stored procedures\n\nPlan Optimizer \n","Cost-based optimizer, with the addition of locale costs which optimizes for most efficient operation\/highest level performance","Indicates which operations will be done within host and which will be done within JPU","Communicates with Plan Link, providing tips on what filtering should be done within the Programmable Data Streaming Processing (\u201cPSDP\u201d) if there are multiple filters that can be done there (more than the PSDP can handle)","Maintains usage\/reference statistics for later index creation, refreshing cluster indices\n\nPlan Link \n","Takes an Execution Plan as input","Analyzes Execution Plan and splits plan further, identifying what will be done within the PSDP , what will be done within the JPU  after the PSDP  has returned its data to the JPU , and what will be done in the Host  after the JPU  has returned its data\n\nSQL Expression Evaluator\/SQL Converter \n","Expression Evaluator","Creates object code for evaluating given expression to be executed on the Host, JPU, and PSDP based on the expressions, their type, and the capabilities of the installed hardware\n\nHost Dispatch \n","Similar to standard UNIX scheduler\/dispatcher","Queues execution plan and prioritizes based on (a) the plan's priority, history, and expected resource requirements, and (b) available resources and other plans' requirements","Controls number of jobs being sent to any one JPU  or LJPU  to avoid JPU\/LJPU Scheduler or JPU\/LJPU memory overload","Sends Host jobs to host","Sends JPUs jobs to be monitored to the Execution Engine  in the LJPU.\n\nCommunications Layer \n","Provides communications among the nodes","Includes Job Listener to await data from nodes","Uses striping data from a Topology Manager to direct multicast and unicast messages","Detects non-responsiveness of nodes and communicates with Topology","Manager to trigger failover processing\n\nCall Home \n","Initiates message to a Technical Assistance Center (not shown) to identify failed part and trigger service call or delivery of replacement component (as appropriate given user support level)","Optionally communicates via SNMP to a defined app to receive a failure indicator and callhome trigger","Logs error(s)\n\nLogger\/Replication Server \n","Logs transaction plans, messages, failures, etc. to Netezza log in conventional fashion","Implemented as a standard transaction logger\/replication server\n\nSystem Manager \n","Defines and maintains JPU\/LJPU Configuration information, striping information","Mirror Master\u2014maintains mirrors info\u2014what JPUs are being mirrored where, maintains SPA data, maintains info on system spares","Initiates failover processing when informed by Comm layer of a non-communicative JPU\u2014directs mirror of failed JPU to take over as primary and begin copying to designated spare, directs primary of JPU mirrored on failed JPU to copy its data to that same designated spare, to reduce load on mirror of original failed JPU also directs mirror of the primary on that failed JPU's mirror to do double duty and act as new primary until failover copying has been completed","Communicates to callhome component to initiate replacement process","Manages system expansion and allows for redistribution of data as appropriate or as requested by user during expansion","Initiates JPU\/LJPU diagnostics when appropriate","Provides an API to allow client management interface to get configuration data for user display\/control\n\nHost Diags \n","Runs diagnostics on Host as required\/requested\n\nLoader \n","Provides fast loader capability for loading user data onto disks","Communicates directly to Host Dispatch to load database\/insert records","Communicates with System Manager to get configuration and mirroring data","Controls index creation on primary (and sets up job to run later to create indices on mirror)","Supports input via a number of methods (e.g., tab-separated data, backup\/recovery)","Does ETL, converts data from Oracle, SQL Server, DB\/2, etc. to the internal data format\n\nMOX\/OLAP \n","Provides OLAP\/MDX, ROLAP Engine on Host","Creates and maintains MOLAP cubes","Supports multi-user MDX","Creates Execution Plans for OLAP requests and communicates these directly to Host Dispatch","Supports metadata writeback","Provides administrative support for user creation, security","Access System Catalog through API\n\nCube Builder User Interface (UI) \n","Provides interface for defining and managing cubes to be used in OLAP Processing\n\nJPU Downloader \n","Downloads Firmware to System JPUs  at system initiation\/boot","Downloads PSDP  and JPU  images","Communicates with System Manager to understand number of JPUs and JPU configurations","Initializes spares for failover","Initializes replacements\n\nHost Disk Manager \n","Manages Host Disk (used for Catalog, Temp Tables, Transaction Log, Netezza Log, Swap space)\n\nHost Transaction Manager \n","Manages transactions on the host ","Controls requests sent to JPUs  that will be involved in the transaction","Provides lock management and deadlock detection","Initiates abort processing","Sends state data to Recovery Manager ","Sends ID requests to the Transaction I.D.(TID) Manager ","Provides transaction IDs and deleted transaction IDs to ensure that disk records are preceded","Manages catalog requests as transaction requests as required\n\nTID Manager \n","Provides unique transaction identifiers (TIDs)","Coordinates with other hosts to avoid generating duplicate TIDs\n\nHost Recovery Manager \n","Ensures transaction atomicity after component (e.g., JPU) failure","Maintains journal of transaction state","Initiates rollback as required\n\nBackup\/Recovery \n","Supports Host side of Backup\/Recovery process","Interfaces with Transaction Manager and JPU Storage Manager\n\nC. JPU Software Components\n"]}}}},{"@attributes":{"id":"p-0092","num":"0196"},"figref":"FIG. 4A","b":"22"},"Communications Layer ",{"@attributes":{"id":"p-0093","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":{"@attributes":{"id":"ul0019-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":["Provides internal communication among nodes","Includes Job Listener  to await requests","Includes Network Poster  to send data when buffer filled, job completed, or at Host request\n\nJPU Dispatch\/Scheduler \n","Receives plan through Communications Layer ","Queues Plan","Schedules\/dispatches jobs according to their priority, \u201cfairness\u201d to date, expected resource requirements, and available resources\n\nJPU Transaction Manager \n","Processes changes in transaction state to begin a transaction, pre-commit a transaction, commit a transaction, or abort a transaction","Handles processing of dependencies among transactions as flagged by the lock manager; broadcasts information about these dependencies to relevant host(s); initiates deadlock checks\n\nJPU Lock Manager \n","Controls concurrent access to data","Interfaces with EventTask  before a query is executed and for each result set returned from a scan","Provides support for arithmetic locking\n\nJPU Recovery Manager \n","Maintains a Journal to track transaction status on the JPU , using the Storage Manager API","Performs transaction recovery when requested by JPU Transaction Manager\n\nJPU Mirror Manager \n","Mirror Sender receives copies of record updates from Storage Manager  and transmits these to the mirror for this JPU when an updating transaction commits","Mirror Receiver receives record updates, buffers these in memory, and flushes out to disk through the Storage Manager when the Mirror Receiver buffer is full","Transmits all data to a spare system during failover processing\n\nStorage Manager \n","Stores and manages information on disk in optimal fashion","Has an API that supports storage and retrieval of tuple sets","Supports error checking to insure that the data conforms to the indicated table and the indicated table \u201cowns\u201d the physical space to which the data is being written","Supports creation and deletion of tables, views, and indices","Handles record inserts and deletes","Supports ETL and mass loading of existing user data","Provides storage support for commit\/rollback","Provides support for Precise Indexes","Provides mirroring support for failover","Optimizes sort operations and utilizes smart hash algorithm for data distribution\/striping","Provides support for compression and smart storage optimization","Controls disk I\/O\n\nJPU Resource Scheduler \n","Schedules jobs to run on the PSDP ; communicates with JPU\/PSDP Scheduler  to queue up PSDP requests to retrieve required data","Optimizes the queue to keep the PSDP\/disk as busy as possible, with requests from multiple queries intermixed in the queue based on disk characteristics and location of data on the disk","Takes into account the needs of any data loading for new tables being created and transformed to internal data format (i.e., to optimize the loading process)","Supports heuristic-based scheduling, ensuring that jobs are scheduled on a priority basis, but also ensuring that all jobs do get serviced (e.g., raising a job in priority if it has not been run in a certain interval of time)","Supports synchronous\/piggy-backed scans, combining similar requests to optimize PSDP processing","Manages memory buffers\/memory allocation on JPU; allocates memory to Execution Plans based on expected needs and hints received from Plan Optimizer","JPU Paging (if required)\n\nPSDP Prep \n","Defines the instructions that will be given to the PSDP  in order to process a request (instructions tell the PSDP  what to do with each field being read from the disk)","Identifies what filtering, transformation, projection, and aggregation operations are to by run by the PSDP \n\nEventTask \n","Executes the portion of the Execution Plan that could not be handled by the PSDP but that does not have to be handled at the Host level","Handles sorts, joins, transformations, and aggregations that could not be done as data stream through the PSDP ","Maintains a memory buffer of result set records and returns these to Host through the Comm Layer when buffer filled, job completed, or at Host request\n\nJPU Diags \n","Runs diagnostics on JPU as required\/requested\n\nJPU Boot\/Init \n","Executes image burned into flash memory at boot time to bootstrap the JPU, run diagnostics, register the JPU with the primary Host server, and download new image from Host to run","Loads and transfers control to the image downloaded from the primary Host server to load the JPU application code, the operating system, the network stack, and disk driver code\n\nBackup\/Recovery \n","Supports JPU side of Backup\/Recovery process","Interfaces with Transaction Manager and JPU Storage Manager\n\nDBA Lite \n","Provides automatic and dynamic disk and Storage Manager support","Supports dynamic index creation, defragging, index garbage collection, timers, agents\n\nJPU\/PSDP Scheduler \n","Schedules jobs to run on the PSDP; queues up PSDP requests to retrieve required data"]}}}},"D. LJPU Software Components",{"@attributes":{"id":"p-0095","num":"0246"},"figref":"FIG. 4B","b":["30","22","23","360","22","360","12"]},"LJPU Communications Layer ",{"@attributes":{"id":"p-0096","num":"0000"},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":{"@attributes":{"id":"ul0021-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":["Provides internal communication among nodes","Includes Job Listener  to await requests","Includes Network Poster  to send data when buffer filled, job completed, or at Host request\n\nLJPU Dispatch\/Scheduler \n","Receives plan through Communications Layer ","Queues Plan","Can schedules\/dispatch jobs according to their priority, \u201cfairness\u201d to date, expected resource requirements, and available resources\n\nLJPU Transaction Manager \n","Processes changes in transaction state to begin a transaction, pre-commit a transaction, commit a transaction, or abort a transaction","Handles processing of dependencies among transactions as flagged by the lock manager; broadcasts information about these dependencies to relevant host(s); initiates deadlock checks\n\nLJPU Lock Manager \n","Controls concurrent access to data","Provides support for arithmetic locking\n\nLJPU Recovery Manager \n","Maintains a Journal to track transaction status on the LJPU , using the Storage Manager API","Performs transaction recovery when requested by LJPU Transaction Manager \n\nLJPU Resource Scheduler \n","Schedules jobs to run on the LJPU\n\nLJPU Diags \n","Runs diagnostics on JPU as required\/requested\n\nLJPU Boot\/Init \n","Executes image burned into flash memory at boot time to bootstrap the LJPU, run diagnostics, register the LJPU with the primary Host server, and download new image from Host to run","Loads and transfers control to the image downloaded from the primary Host server to load the LJPU application code, the operating system, the network stack, and disk driver code\n\nLJPU Backup\/Recovery \n","Supports LJPU side of Backup\/Recovery process","Interfaces with LJPU Transaction Manager\n\nLJPU Scheduler \n","Schedules jobs to run on the LJPU\n\nExecution Engine \n","Receives partial record sets from JPUs  through the Comm Layer Job Listener","Executes remainder of Execution Plan that has to be done at LJPU","Provides intermediate and final sort-merge of JPU  results sorted data as required","Handles joins of data returned from JPUs  as required","Communicates to JPUs through Comm Layer  to request partial result sets from JPU buffers when idle (e.g., to get and sort\/process partial records that the JPU currently has instead of waiting for JPU  to fill a buffer"]}}}},"E. Details of PSDP Component  of the JPUS ","As discussed above, the PSDP  functions as the disk drive controller and as a coprocessor or hardware accelerator for the JPU to which it is attached. During DMA disk read operations, the PSDP  filters the data it is reading. More specifically, it parses the disk data to identify block, record, and field boundaries. Fields can thus be transformed and compared with data from other fields or with constants, right in the PSDP , and prior to storing any data within the JPU memory or processing any data with the JPU CPU . The comparisons are combined to determine if a record is wanted, and if so, selected header and data fields are formatted and returned to SPU memory. If a record is not wanted, the PSDP ignores it and proceeds to the next. The PSDP  thus performs two major functions: as a disk driver logic interface  and tuple filter .","Each of these functions is described in some detail below. It is sufficient here to note that the disk driver logic interface  accepts standard disk drive interface signaling, such as IDE (Integrated Device Electronics) or SCSI (Small Computer Systems Interface), adapting it to a particular CPU native \u201cbus\u201d such as a Advanced Technology Attachment (ATA) bus or the like. Alternatively, if there is a communications network, such as Ethernet or Fibre Channel, instead of array of disks  to provide access to input data stream(s), the interface  becomes a network interface that is suitable to receive and\/or transmit data over a communications network. The disk driver logic  is usually implemented in an Integrated Circuit (IC) in a computer or communications device, in or part of an IC that contains other logic, such as other interface logic or the CPU  itself. The disk driver  could even be inside the disk  itself, making the disk a special-purpose unit attachable only to JPUs or communications devices for which the interface is specific.","In the preferred embodiment, the PSDP  is an IC that interfaces a standard disk  to a peripheral bus of the JPU . All such controllers have the basic function of allowing the CPU  in the JPU  to read and write the disk , typically by setting up long data transfers between contiguous regions on the disk and contiguous regions in the CPU's  memory (a process usually referred to as DMA, for Direct Memory Access).","Most importantly, the PSDP  also provides programmable hardware directly in the disk read path, to and from the controller. This portion of the PSDP hardware, called a \u201cfilter\u201d unit , can be programmed by the JPU's CPU  to understand the structure of the data the analysis software running on the CPU  wishes to read and analyze. The PSDP  can be this programmed to operate on data it received from the disk , before it is shared into the CPU's memory, in the process discarding fields and entire records that the CPU  would have to analyze and discard in the absence of the filter unit.","In an embodiment specifically adapted for processing of record-oriented data, data can be filtered by the PSDP  as records and fields of a database, so that only certain fields from certain records are actually written into the associated JPU's main memory . However, many other operations beyond simple filtering are possible to implement in the PSDP. For example, records with certain characteristics can be tagged as they are processed, to indicate that such records are to be ignored in further processing, or to indicate certain attributes of such records, such as if they are to be handled differently in a transactions from other records.","While the invention is of use in processing field-oriented database records, it should be understood that the system can also be used to advantage in processing many different types of data, including other field delimited data such as tables, indices, and views. The system is also advantageously used to process less structured data such as character strings, Binary Large Objects (BLOBS), XML, graphics files, and the like.","Although referred to here as a \u201cfilter\u201d unit, it should also be understood that filter  can also perform other functions such as compression\/decompression; encryption\/decryption; certain job operations; and other administrative functions.","As one example of filtering, the PSDP  can be programmed to recognize that a certain set of records in a database have a specified format, for example, a preamble or \u201cheader\u201d of determined length and format, perhaps a field, including the length of the record, followed by data including some number of fields of a certain type and length (e.g., 4-byte integers), followed by some number of fields of a different type and length (e.g., 12-byte character strings), followed by some number of fields of variable length, whose first few bytes specify the length of the field in some agreed-upon manner, and so forth.","The filter unit  can then execute this program as it reads data from the disk , locate record and field boundaries, and even employ further appropriate Boolean logic or arithmetic methods to compare fields with one another or with literal values. This allows the filter unit  to determine precisely which fields of which records are worth transferring to memory. The remaining records are discarded, or tagged in a manner that signals the JPU that a record need not be analyzed. Again, there will be more discussion of how this is done in detail below.","In the preferred embodiment, there are two basic reasons for which the filter unit  can discard a record (or mark it as unworthy of attention). The first is an analysis of the contents of the fields as described above. Using a previous example, the filter unit  can, for example, be programmed to check a purchase date field against a range of numbers that correspond to dates in the month of July in the year 1999, another field for a number or string uniquely associated with the North Carolina store, another field for a set of SKU (stock-keeping unit) values belonging to various styles or manufacturers of blue raincoats, and in this fashion mark only certain records for further processing. The filter unit  can further be programmed to know which fields contain the name and address of the customer who made the purchase, and return only these fields from the interesting records. Although other database software could perform these operations, the filter unit  can perform them at the same rate as the data is supplied by the disk . Far less data ends up in the JPU's memory as a result leaving the CPU  free for more complex tasks such as sorting the resulting list of names and addresses by last name or by postal code.","A second example of how the filter unit  can be used is to discard or mark a record, such as in record creation and deletion in a multi-user environment. Databases are not static, and it is common for some users to be analyzing a database while others are updating it. To allow such users concurrent access to the database, records can be tagged with transaction numbers that indicate when or by whom a record was created or marked obsolete. A user querying a database may not wish to see records created by another user whose activity began subsequently, or whose activity began previously but is not yet complete; if so, he probably will want to see records marked obsolete by such a user. Or the user may wish to see only the results of transactions entered by certain users, or only the results of transactions not entered by certain users. To facilitate this kind of record filtering, record headers can contain creation and deletion identifiers that the filter unit  can be programmed to compare with the current user's identifier to determine whether records should be \u201cvisible\u201d to the current user. Once again, the filter unit can avoid transferring useless data to memory or relieve the CPU  of a time-consuming analysis task.","In the preferred embodiment there are two basic methods the filter  unit can filter out data that is unnecessary for a given query, thereby reducing traffic on the communications network and reducing the workload on the CPU. As described above, the filter unit  can simply discard the data. This is not always practical, however. Imagine a very long record with many fields, or large fields, many of which are to be returned to the CPU if the record meets the criteria, arranged in such a way that the contents of the last field are relevant to the decision to transfer or discard the selected fields of the record. Practical implementations of the filter unit  may not be able to store (\u201cbuffer\u201d) the largest possible set of returnable fields. In such a case, the filter unit must begin sending the selected fields to the CPU  before it can tell whether they should be sent. After the record has been completely processed by the filter unit, and all the selected fields transferred to the CPU , the filter can tag the transferred data with a bit that says \u201cnever mind\u201d, thus saving the CPU  and the communications network a great deal of work. In practice, the filter unit must append a length indication to every record fragment it does transfer to the CPU , so that the CPU  can find the boundaries between the record fragments the filter unit deposits in memory. This is a natural place for a status bit (or bits, if the CPU  must distinguish among multiple reasons) indicating the transfer of a useless record.","In addition to selecting certain fields from certain records for transfer to the CPU , the filter unit  can create and return additional fields not present on the database, by performing calculations on the contents of the fields that are present. This can further relieve the CPU  of work, speeding up database analysis even more. An example of this is the calculation of a \u201chash\u201d function on the values of specified fields from a record, some of whose fields are to be transferred to the CPU . A hash function is a numerical key assigned to a collection of numeric or non-numeric field values that speeds up the process of searching through a list of records. Other examples of useful information that can be computed by the filter unit  include running sums or averages of field values from one record to the next. All of these benefits accrue from the filter unit's  ability to parse the data into records and fields as it transfers the data from the disk  to the CPU .","Another example is a transformation, such as an ASCII substitution. One usage for an ASCII substitution is to change the collation sequence of a given field. For example, if the LAST_NAME starts with the French \u2018\u00e7\u2019 (ASCII ) then the SQL clause \u201cWHERE LAST_NAME IS>\u2018H\u2019\u201d will erroneously fail unless \u2018\u00e7\u2019 has been mapped to \u2018C\u2019 (ASCII ). Similar issues involve the use of the UPPER( ) and LOWER( ) functions. In the preferred embodiment, the PSDP has two groups of registers, each 256 bytes long. If transformation of a given field is selected, then the PSDP setup loads transformation fields into these registers before the data is streamed in. Each register in the transformation fields corresponds to an extended ASCII value and the register contains the value that each extended ASCII character is to be converted into. In the example above, register number  contains the value . During the streaming phase, as each tuple streams through the PSDP, for those fields where a transformation is indicated, each byte is individually transformed to its converted value. Two registers are provided so that two types of transforms may be applied to different fields in a given stream, such as UPPER( ) and LOWER( ). The transforms may be applied either (a) in the \u201cfilter\u201d path, before evaluation and comparisons or (b) in the \u201cproject\u201d path so that a given field is converted before being output from the PSDP. This is especially useful for correcting collation sequences in preparation for the CPU performing a sort.","A more detailed discussion of the transformation\/substitution of fields is contained in the co-pending patent application U.S. patent application entitled \u201cField Oriented Pipeline Architecture for a Programmable Data Streaming Processor,\u201d (application Ser. No. \/,) referenced above.","E. Detailed Description of PSDP  Architecture","The preferred embodiment of the PSDP  is now described in further detail. The PSDP  is in one sense an On-Line Analytic Processing (OLAP)-oriented disk drive interface. It contains logic that is capable of identifying records, filtering out the unwanted records, and selecting fields for return. It therefore dramatically increases database analysis speed by identifying and returning selected fields from requested records.","As shown in , a PSDP  consists of a finite state machine called the Data Engine  to carry out filter logic and other control operations, a host interface , a disk interface, here the ATA interface  for connection to the disk , First-In-First-Out (FIFO) memories  and , and a DMA host driver .","The PSDP  has two major functions: to act as disk controller  while moving data between memory and the disk , and to process or \u201cfilter\u201d  disk data during filtered reads from the disk . In acting as the disk controller , the PSDP translates signaling used on the JPU, such as PowerPC compatible interface signaling to the interface used in the disk , such as the Integrated Device Electronics (IDE) (also known as Advanced Technology Attachment (ATA)) interface as defined by ANSI NCITS 340-2000. The PSDP  supports both a Programmed I\/O (PIO) Mode-2 for register access and a UDMA (Ultra-Direct Memory Access) mode-4 for data transfers.","The terms \u201cflow through\u201d and \u201cfiltered\u201d are used to differentiate DMA reads. In flow-through mode, also referred to as raw read mode, data moves directly from the input to the output of the data engine without being filtered. Data that is filtered has been processed, perhaps by culling records via the comparison and\/or transaction ID circuits, but certainly by reformatting the records into tuple format, during which uninteresting fields can be dropped and PSDP-generated fields added. The processing of culling records is called the \u201crestrict\u201d. The process of formatting fields into tuples is called the \u201cproject\u201d.","There are three DMA modes: write, raw read, and filtered read. For all three, the PSDP  shadows the read\/write disk command in order to control its own DMA state machines. It does not shadow the disk address or sector count, nor does it have access to the memory addresses. For writes and raw reads, the PSDP  blindly moves data from one interface to the other until the JPU  disables the mode. The JPU  knows the quantity of data to be moved for these modes and uses the disk and DMA controller interrupts to identify the end of transfer. For filtered reads, the quantity of data to be transferred to memory is generally unknown, and the JPU identifies the end of transfer from the disk and filter interrupts. All of the record information\u2014header and data\u2014can be projected during a filtered read, but the block header info can only be returned by a raw read. DMA data integrity is protected across the disk interface by the IDE CRC check.","As mentioned already, during disk read operations, the PSDP  can filter data (or perform other operations on the data) as it is being read from the disk . More specifically, the PSDP parses the disk data and identifies block, record, and field boundaries. Data from specified fields are transformed and compared with data from other fields or with constants. The comparisons are combined to determine if a record is wanted (this is referred to as a restricted scan of the database). If so, data from fields to be returned (referred to as selected or projected fields) are returned to JPU memory. If a record is not wanted, the PSDP ignores it and proceeds to the next record. Details are in the Filter Unit section.","As alluded to above, the PSDP  operates in two modes. It can return raw disk sectors in block read mode; and it can process the records within the disk block and selectively return specified fields in filtering mode. [A special case of filtering mode is the return of all records without any modifications whatsoever, with or without any record header elements.] In filtering mode, the Filter Unit  pulls disk blocks from a Disk Read FIFO, feeding them through the Block Header, Record Header, NULL Vector, Transaction ID, Field Parse, and Filter circuits. Fields to be returned are pushed into the Memory Write FIFO. Notice that this version of the chip does not return transformed fields. In fact, the only tuple entries created by the PSDP are the record address, tuple length, and tuple status.","The terms \u201cflow through\u201d and \u201cfiltered\u201d are used to differentiate DMA reads. In flow-through mode, also referred to as raw read mode, data moves directly from the input to the output of the data engine without being filtered. Data that is filtered has been processed, perhaps by culling records via the comparison and\/or transaction ID circuits, but certainly by reformatting the records into tuple format, during which uninteresting fields can be dropped and PSDP-generated fields added. The processing of culling records is called the \u201crestrict\u201d. The process of formatting fields into tuples is called the \u201cproject\u201d (as in throwing something, not as in this document).","There are three DMA modes: write, raw read, and filtered read. For all three, the PSDP shadows the read\/write disk command in order to control its own DMA state machines. It does not shadow the disk address or sector count, nor does it have access to the memory addresses. For writes and raw reads, the PSDP blindly moves data from one interface to the other until the JPU disables the mode. The JPU knows the quantity of data to be moved for these modes and uses the disk and DMA controller interrupts to identify the end of transfer. For filtered reads, the quantity of data to be transferred to memory is generally unknown, and the JPU identifies the end of transfer from the disk and filter interrupts. All of the record info\u2014header and data\u2014can be projected during a filtered read, but the block header info can only be returned by a raw read. DMA data integrity is protected across the disk interface by the IDE CRC check.","The Data Engine , as shown in , includes filter logic , a data parser block , header storage , transaction ID processing , error checking , and output tuple generator . In general, the data parser  is responsible for taking information from the disk  and formatting it into headers and fields so that the filter logic , header storage  and error checking  blocks can perform their respective tasks. The tuple generator takes the output of the filter and TID processing blocks and formats the results in a \u201ctuple\u201d, suitable for processing by the JPU  or host .","Raw user table data as read from the disk  is understood and interpreted by the data parser . In one preferred embodiment at the present time, user table data is stored on disk in 128 KB segments called \u201cblocks\u201d. Each block begins with an 8-word header, followed by 0 or more records. The format of the block header may be as follows:",{"@attributes":{"id":"p-0125","num":"0299"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Block",{},{}]},{"entry":["Header Field","Size","Details"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Magic number","4B","identifies beginning of block, always"]},{"entry":[{},{},"\u201cFEEDFACE\u201d"]},{"entry":["CRC-32","4B","not used"]},{"entry":["Block number","4B","within the table, 0 based, only 19 significant bits"]},{"entry":["Block address","4B","starting sector number of the block"]},{"entry":["Block length","4B","in bytes, including header, but not trailing 0's"]},{"entry":["Layout ID","4B","like a version number on the data format"]},{"entry":["Table ID","4B","the Postgres object ID that uniquely identifies"]},{"entry":[{},{},"the table"]},{"entry":["Sector count","1B","defines block size, 0 means 256, as of this time,"]},{"entry":[{},{},"it's always 0"]},{"entry":["Record count","3B","number of records in the block, 0 means 0"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The CRC-32 is meant to be computed by software and written to the disk along with the rest of the block header. Its calculation was to include all data from the block number through the end of the last sector of the block, including any trailing 0's. Its primary purpose was to detect data corruption resulting from hardware or software bugs, but it could have detected disk data-retention problems as well. It is unrelated to the UDMA-mode CRC-16 calculation required by the ATA-5 specification, which only guards the physical interface between the PSDP and disk-drive IO buffers.","The sector count is the number of sectors in the block, which must be from 1 to 256. Thus a 0 in this 1-byte field means 256. The sector count occupies the most-significant byte of the last word of the block header.","The record count is the number of records in the block, which may be 0. Although the record count occupies the least-significant three bytes of the last word of the block header, only 13 bits are used.","A record is typically composed of a record header and one or more data fields, where the record header consists of three special fields, a length, and a null vector. The special fields are the row number, created transaction ID, and deleted transaction ID. All of the record header entries are optional on a per-table (not per-record) basis. However, if the record has a null vector, it must also have a record length, but not vice versa. The data types are described above in the data types section.",{"@attributes":{"id":"p-0130","num":"0304"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Record Header Field","Size","Detail"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Row number","0 or 8B","existence per RowNumberSize register"]},{"entry":["Created XID","0 or 8B","existence per CreatedXIDSize register"]},{"entry":["Deleted XID","0 or 8B","existence per DeletedXIDSize register"]},{"entry":["Record length","0 or 2B","size per RecordLengthSize register"]},{"entry":["Record NULL","0 to 512B","size per FieldCount register"]},{"entry":"vector"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The row number (sometimes called row_num) is the unique number of the row or record in the user's table. It is distinct from the row address (sometimes called row_addr), which is the complete physical address of a row in node-table-block-record format. The row number is also distinct from the record number, which is the 0-based ordinal number of a record within a block. The record number is the final component of the row address. The row address is computed by the PRSP.","The created XID contains the number, or ID, of the transaction that created the record.","The deleted XID. In the preferred embodiment, records are not actually deleted. Rather, they are marked as deleted so they can be restored if the transaction that did the deleting is rolled back. (There are system management tools to reclaim the space.) A value of 0 indicates the record has not been deleted. A value of 1 indicates that the record was created by a transaction that was rolled back. These XIDs support a multi-version database system.","The record length is the length of the record in bytes, excluding the row number and the transaction IDs, but including the record length, the record null vector, the data fields, and any pad bytes at the end of the record needed for proper alignment of the first item of the following record. Thus, it is the distance in bytes from the beginning of the record length field to the beginning of the next record. Note that although all records in a table must have the same makeup, record lengths may vary because of variable-length character fields. The RecordLengthSize register defines record length sizes of 0, 1, 2, and 4 bytes, but only 0 and 2 are used.","The record null vector specifies which fields in the record are null, thereby indicating validity, not existence. For instance, a null varchar is not the same as an empty one. The record null vector consists of an even number of bytes. If it exists, the record null vector has the same number of bits as the record has data fields, and computes the number of half-words in the null vector as (FieldCount+15)>>4. This vector is an array of bytes. Bit  of the byte immediately following the record length corresponds to the 0data field; bit  of that byte corresponds to the 7data field; bit  of the last byte of the word that contains the record length corresponds to the 8data field; and so on.","There are strict rules governing field order and alignment. Both the record and its first data field must start on a word boundary (addr[1:0]=0). All record fields are self-aligned up to word boundaries. This means that 16, 12, 8, and 4 byte fields are word-aligned, 2-byte fields are \u00bd-word-aligned (addr[0]=0), and 1-byte fields can start anywhere. The row number, created XID, and deleted XID are all 8 byte fields and do not require pad bytes to align them. If there is a record length but no record null vector, two pad bytes are required following the record length. If the record null vector exists, it immediately follows the record length and naturally starts on a two-byte boundary, but two pad bytes may be required following the record null vector to properly align the first data field. The physical order of data fields, which often is not the same as the logical order, takes care of aligning non-character data fields; the physical order is N, T, N, , F, N, , F, D, , D, I, C, . . . C, V. The fixed-length character fields are packed in as tightly as possible and are not aligned. Variable-length character fields start with a 2-byte length; they are \u00bd-word-aligned and may require a preceding pad byte. Up to three pad bytes may follow the record's last data field in order to align the next record. If so, they are counted in the length of the earlier record. More details of TID processing are contained in a co-pending U.S. patent application entitled \u201cControlling Visibility in Multi-Version Database Systems\u201d by Foster D. Hinshaw et. al. filed in the U.S. Patent and Trademark Office on Aug. 22, 2003.","A project function encompasses the selection of record fields, the generation of new fields, and the tuple formation and return. Tuples typically consist of a row number, some data fields, and a 2-byte length\/status, but they can also include the created and\/or deleted transaction IDs, the row address, up to 255 pad words, the 32 instructions results formed into a boolean word, the hash result, and a null vector.","The hash is used to organize similar tuples into groups for processing joins or grouping selects, and with the exception of the record null vector and length\/status, all record-header and data fields can be used in its calculation. There are 7 defined hash modes, such as full CRC, which calculate a 32-bit CRC hash starting with a seed of zero and using all of the bytes of all of the fields selected. Blank spaces in character fields are skipped, as are leading 0's in positive and unsigned numbers and leading 1's in negative numbers. Hash operations are defined on a per-field basis by the comparison instructions.","Within the PSDP , a \u201ctuple\u201d is used to describe projected data as provided by the tuple generator . The tuple generator  uses principally the filter  output but can also use TID processing  and error checking  outputs. The term \u201ctuple\u201d is used here for the purpose of differentiating disk  and PSDP  output record formats. A tuple contains fields projected from the source record and up to six \u201cvirtual\u201d fields: row address, pad words (tuple scratch pad), the boolean results from each of the filter operations, a hash result, the tuple null vector, and the tuple length. All are optional on a per-table basis. The order of these fields is given in the following table.","F. Query Processing Example","As an aid in the illustrating how the system  processes data, an example database will be described that contains store sales data. The database defines a SalesDetail data table, a Customer data table, and a Store data table as follows:",{"@attributes":{"id":"p-0142","num":"0316"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SalesDetail"]},{"entry":[{},"\u2003StoreID"]},{"entry":[{},"\u2003CustomerID"]},{"entry":[{},"\u2003SaleDate"]},{"entry":[{},"\u2003ProductCategory"]},{"entry":[{},"\u2003Units"]},{"entry":[{},"\u2003Amount"]},{"entry":[{},"Customer"]},{"entry":[{},"\u2003CustomerID"]},{"entry":[{},"\u2003Gender"]},{"entry":[{},"Store"]},{"entry":[{},"\u2003StoreID"]},{"entry":[{},"\u2003StoreLocation"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A sample query might be to \u201cshow me the total units and dollar amount of rain gear sold to females in North Carolina in 2000, by customer ID.\u201d This can be translated into the SQL statement:",{"@attributes":{"id":"p-0144","num":"0318"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT SalesDetail.CustomerID AS \u201cCustID\u201d,"]},{"entry":[{},"\u2003Sum(SalesDetail.Units) AS \u201cSales Units\u201d,"]},{"entry":[{},"\u2003Sum(SalesDetail.Amount) AS \u201cSales Amount\u201d"]},{"entry":[{},"FROM SalesDetail, Customer, Store"]},{"entry":[{},"WHERE SalesDetail.StoreID = Store.StoreID"]},{"entry":[{},"\u2003AND SalesDetail.CustomerID = Customer.CustomerID"]},{"entry":[{},"\u2003AND Store.StoreLocation = \u201cNC\u201d"]},{"entry":[{},"\u2003AND Customer.Gender = \u201cFemale\u201d"]},{"entry":[{},"\u2003AND Year(SalesDetail.SaleDate)=\u201c2000\u201d"]},{"entry":[{},"\u2003AND SalesDetail.ProductCategory = \u201cRaingear\u201d"]},{"entry":[{},"\u2003GROUP BY SalesDetail.CustomerID;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"An output from this sample query with the total units and dollar amount of rain gear sold to females in North Carolina in 2000 by customer ID might be shown in tabular format:",{"@attributes":{"id":"p-0146","num":"0320"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["CustID","Sales Units","Sales Amount"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["021442","1,300","\u2002$45,000"]},{"entry":["021443","1,200","\u2002$41,000"]},{"entry":["021449","1,800","\u2002$60,000"]},{"entry":["021503","3,500","\u2002$98,000"]},{"entry":["021540","4,200","$112,000"]},{"entry":["021599","5,000","$150,000"]},{"entry":["021602","4,700","$143,000"]},{"entry":["021611","4,100","$104,000"]},{"entry":["021688","3,600","$101,000"]},{"entry":["021710","2,000","\u2002$65,000"]},{"entry":["021744","1,200","\u2002$41,000"]},{"entry":["021773","1,500","\u2002$43,000"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The mechanism for processing this query to produce these results involves a series of steps. Referring to , the query is passed from the user (for example, Business Intelligence Application ) over the external network  to the host . On the host , the Plan Generator  then creates tentative execution plans.","An execution plan describes the query processing steps that are required to produce results. Some of these steps can be executed in parallel, while others must be executed in sequence. Different steps may be optimally executed in different processing locales. Some steps, such as sorting large amounts of data, can benefit from fast processors with lots of shared memory, as may be the case in an SMP environment. Some steps, such as reading lots of data from disk, can benefit from running in a massively parallel environment, where I\/O can be overlapped. Still other steps, such as filtering a stream of data, can benefit from specialized hardware circuits that can perform simple comparisons at streaming speeds.","The Plan Optimizer  selects an execution plan, optimizes that plan, annotates the steps of the plan to note dependencies between steps and optimum processing locales, and passes it to the Plan Link . The Plan Link  expands the plan as necessary, based on where parts of the plan will be executed, resulting in a sequence of Jobs, in which each job is a group of steps that can be performed as a sequential unit within a processing locale.","The execution plan for the example query is shown below. It consists initially of a sequence of seven jobs, each job performing a portion of the work required for evaluating the query.",{"@attributes":{"id":"p-0151","num":"0325"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Job","Needs","Locale","Operation"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","0","JPU","SCAN Customer"]},{"entry":[{},{},"PSDP","RESTRICT Gender = \u201cFemale\u201d"]},{"entry":[{},{},"PSDP","PROJECT CustomerID"]},{"entry":[{},{},"JPU","SAVE AS TEMPCustomer"]},{"entry":["2","0","JPU","SCAN Store"]},{"entry":[{},{},"PSDP","RESTRICT StoreLocation = \u201cNC\u201d"]},{"entry":[{},{},"PSDP","PROJECT StoreID"]},{"entry":[{},{},"JPU","BROADCAST AS TEMPStore"]},{"entry":["3","1&2","JPU","SCAN SalesDetail"]},{"entry":[{},{},"PSDP","RESTRICT ProductCategory = \u201cRain-"]},{"entry":[{},{},{},"gear\u201d AND Year(SaleDate)=\u201c2000\u201d"]},{"entry":[{},{},"PDSP","PROJECT CustomerID, StoreID, Units,"]},{"entry":[{},{},{},"Amount"]},{"entry":["[4]","3","JPU","JOIN WITH TEMPStore, StoreID="]},{"entry":[{},{},{},"TEMPStore.StoreID"]},{"entry":[{},{},"JPU","PROJECT CustomerID, Units, Amount"]},{"entry":["[5]","4","JPU","JOIN WITH TEMPCustomer,"]},{"entry":[{},{},{},"CustomerID="]},{"entry":[{},{},{},"TEMPCustomer.CustomerID"]},{"entry":[{},{},"JPU","PROJECT CustomerID, Units AS"]},{"entry":[{},{},{},"\u201cUnits\u201d, Amount AS \u201cAmt\u201d"]},{"entry":["[6]","5","JPU","GROUP By CustomerID"]},{"entry":[{},{},"JPU","AGGREGATE Sum(Units) AS \u201cUnits\u201d,"]},{"entry":[{},{},{},"Sum(Amt) AS \u201cAmtTotal\u201d"]},{"entry":[{},{},"JPU","PROJECT CustomerID, \u201cUnits\u201d,"]},{"entry":[{},{},"JPU","\u201cAmtTotal\u201d RETURN HOST"]},{"entry":["7","\u20026*","HOST","RETURN USER"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"For example, Job 1 directs each JPU  to scan the portion of the Customer table that is local to its disk , then to use the specialized PSDP  to filter out everything from the Customer table except the identifiers of female customers, and then to store those CustomerIDs in a temporary file on the JPU 's local disk .","Similarly, Job 2 scans the Store table, bringing into the JPU 's memory  only the identifiers of stores in North Carolina, and since this is a relatively small set of data, broadcasting the resulting set of identifiers to all JPUs , where they are then accumulated and saved in memory as TEMPStore. Jobs 1 and 2 do not depend on any other jobs, and are specified to run concurrently if possible.","When two or more jobs sharing the same processing locale must execute in sequence, the system combines them together into a single job, and avoids intermediate materialization. In the example given, Jobs 3 through 6 form such a sequence, and are combined by the Host Dispatch  into on streaming job. This combined job scans the SalesDetail table, with its restrictions and projections. As the tuples are received from scan and filtered through the PSDP , each tuple is joined with TEMPStore and TEMPCustomer and aggregated. On the aggregation node, as each new customer ID is received, the previous one and its sums are sent to the host, where Job 7 is then invoked in a streaming fashion, to return the aggregated tuples through the ODBC connection  back to the user.","After it potentially combines jobs, the Host Dispatch  then sends individual Jobs within the plan to the respective locales (e.g., the JPUs  or the LJPUs ) for execution. In this example, jobs 1-6 are sent to the JPUs  for execution, with job 7 reserved for the host .",{"@attributes":{"id":"p-0156","num":"0330"},"figref":"FIG. 7","b":"22"},{"@attributes":{"id":"p-0157","num":"0331"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["3","JPU","SCAN SalesDetail"]},{"entry":[{},"PSDP","RESTRICT ProductCategory = \u201cRaingear\u201d AND"]},{"entry":[{},{},"Year(SaleDate)=\u201c2000\u201d"]},{"entry":[{},"PDSP","PROJECT CustomerID, StoreID, Units, Amount"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Individual jobs are forwarded from the host  to typically many JPUs  (and to the LJPUs if specified as a locale for the job) in parallel as a message sent via the communication layers described above. While the messages are typically sent as a User Datagram Protocol (UDP) type broadcast message to all JPUs in parallel, it should be understood that unicast messaging can also be used, and that other protocols such as Transmission Control Protocol (TCP) can also be used. More details of messaging protocols suitable use with the invention can be found in our co-pending U.S. patent application Ser. No. 10\/145,564 filed May 13, 2002, entitled \u201cNetwork Interface For Distributed Intelligence Database System\u201d, by Hinshaw et al.","Upon receipt of a job message at the job listener , the JPU dispatch unit  adds the job to a queue of pending jobs. The JPU Resource Scheduler  subsequently schedules the job for execution based on factors that can include the availability of memory or disk or I\/O resources for processing the job. As shown in , the typical system  has a number of JPUs -, -, -, each capable of queuing and scheduling jobs independently of the other JPUs .","In this example, the SalesDetail table would have already been distributed across multiple JPUs. In the illustrated example, three JPUs store various non-overlapping portions of the SalesDetail table. Thus a given JPU is said to \u201cown\u201d the data (records) sent to it for the purpose of insertion or loading.","When a table is created, one of its fields may be selected (such as the CustomerID field ) to distribute records more or less evenly across the multiple JPUs . Thus, for example, if there were  Sales Detail records and three JPUs , then the host  would distribute approximately  records per JPU based upon the value of the CustomerID field. One scheme for distributing data records to JPUs  is described in co-pending U.S. patent application entitled \u201cDisk Mirror Architecture for Database Appliance\u201d, by Hinshaw, et al., filed on Sep. 18, 2003.","Any such distribution may not be random for all fields, however. For example, the distribution of records may be such that JPU - contains a preponderance of SalesDetail records with a 1998 date, while JPU - contains a preponderance of SalesDetail records with a 2000 date. In the example shown, the RESTRICT operator of Job 3 passes only those SalesDetail records with a year of 2000. Therefore, JPU - may have more data records to process than other JPUs - or -. This is, in part, at least one reason why a particular JPU may finish a job sooner than another JPU.","Each JPU Resource Scheduler  allocates a priority to the jobs in its queue based upon resource availability conditions local to its respective JPU . For example, JPU memory is often a high demand resource, and jobs that make a high relative demand on memory reserves may be given lower priority than other jobs. Other schemes can use other parameters to determine the priorities to be assigned to various jobs, such as desired completion time, or estimated demands on other resources such as local JPU disk and\/or network I\/O demand, user specified priority, and the like.","In the example illustrated in , JPU - will typically finish its operations first before JPU -. This is because the RESTRICT operation, requiring selection of records where the \u201cYear\u201d field is equal to \u201c2000\u201d, will pass through fewer records for processing in subsequent steps than will be passed through on JPU -. In the simple example given, there were no other steps after the RESTRICT and PROJECT. However, if Job 3 included a fourth step to SORT the data resulting from the PROJECT step, then JPU - would have additional processing on the order of N*logN where N was the number of SalesDetails records passing the RESTRICT step. JPU - would thus be freed to perform other jobs for the same query, or even other jobs for different queries, as soon as it finishes processing its own data.","When any record is created, such as a SalesDetail record in this example, it is distributed to a particular JPU. In the preferred embodiment, each record is processed exclusively by the JPU on which it was created, so long as that JPU is operational and so long as the record is accessible to that JPU. The record may be replicated to other JPUs for mirroring purposes, but such replicas are not used for normal job processing.","Even though JPU - may require more time to process Job 3 than does JPU -, JPU - cannot help JPU - by processing some of its data. This frees JPU - to do other work.","This architecture can be thought of as asymmetric scheduling scheme, whereby each JPU  is able to schedule jobs for itself, without regard to how jobs are scheduled for other JPUs. It allows each JPU to complete its assigned tasks independently of the other JPUs, thereby freeing it to perform other tasks. In the simple example presented in , no great advantage is evident since there is only a single job illustrated. However, in the typical environment where many users or applications are making queries at the same time, it can be appreciated that the job queue within a given JPU  will quickly become filled with different jobs of varying demands and priority. In such an environment, by making the JPU operations asynchronous, overall throughput is greatly increased.","This asynchronism in job execution by the JPUs , however, should not be carried forward in the result reporting by the Host  to the application . The job listener component  in the host  thus acts to first coordinate job responses from multiple JPUs. In particular, the job listener  waits to receive results data from each JPU before reporting back to the Host Event Handler  that a particular job has been completed.","To expedite this, each job can be tagged with a unique job identifier (JID) . When each JPU returns results of a particular job to a host, the JID is included, as well as an identifier for the particular JPU. The Host Event Handler , thus knowing how many JPUs  are active, can then tally responses from the JPUs to ensure that job identifiers are received from each, before taking the next step in a plan that has jobs that must be run sequentially, and before ultimately reporting the results back to the application.","As alluded to previously, JPU-assigned jobs can run asynchronously and in parallel. In the example being described, Jobs 1 and 2 can run concurrently and therefore be dispatched to the JPUs  at the same time. However, Job 3 must only be run after both Jobs 1 and 2 have been completed. Thus, Execution Engine  will not permit Host Dispatch  to issue Job 3 until Jobs 1 and 2 are complete.",{"@attributes":{"id":"p-0171","num":"0345"},"figref":"FIG. 8","b":["22","1","22","2","22"]},{"@attributes":{"id":"p-0172","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"JPU","SCAN SalesDetail"]},{"entry":[{},"PSDP","RESTRICT ProductCategory = \u201cRaingear\u201d AND"]},{"entry":[{},{},"Year(SaleDate)=\u201c2000\u201d"]},{"entry":[{},"PDSP","PROJECT CustomerID, StoreID, Units, Amount"]},{"entry":[{},"JPU","SORT by CustomerID"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"This is similar to Job 3 of the earlier example, but with a subsequent sort step. Given the data distribution discussed above for , the first JPU - has very few records that pass the RESTRICT, so that the sort step completes quickly and its local memory is relatively free after finishing Job 1.","However, the second JPU - had many, many records pass the RESTRICT (such as one million records), and its local memory may now be heavily used in the process of executing the last sorting step of Job 3.","As a next sequence of events, the host  has generated a pair of additional jobs, including a Job 2 requesting that a SalesDetail table be processed to count all records where the Year field is equal to 2000, and a Job 4 that is a JOIN of two SCANS. For Job 2, the count operation does not require the continuing presence of each record, merely a running total. Such a job does not make particularly large demands on memory local to the JPU , since each record that is processed is simply discarded once it is counted.","Job 4 however, is a more complicated job in the sense that to perform a JOIN which requires instantiation of at least one data set in the JPU's memory. Job 4 therefore makes higher demands on local memory.","With this scenario, the JPU Resource Scheduler  may choose to schedule Job 4 first on JPU -, prior to allowing Job 2 to run (or at least with a higher priority than Job 2). This is because the prior Job 1 did not make very heavy demands on local memory, and so sufficient memory is available to process Job 4.","However, in the case of JPU -, the scheduler  may choose Job 2 to execute first, and then Job 4. This may be a result of the fact that JPU -'s memory is already heavily loaded as a result of performing Job 1. It may not have enough spare memory to support Job 4, but yet have enough to complete Job 2.","While this invention has been particularly shown and described with references to preferred embodiments thereof, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular description of preferred embodiments of the invention, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the invention.",{"@attributes":{"id":"p-0051","num":"0071"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0052","num":"0072"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0053","num":"0073"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0054","num":"0074"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0055","num":"0075"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0056","num":"0076"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0057","num":"0077"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0058","num":"0078"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0059","num":"0079"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
