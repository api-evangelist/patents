---
title: Method and apparatus for executing stored code objects in a database
abstract: A system, method and database development tool are disclosed for automatically generating parameters for use in executing a stored code object in a data base, by parsing source code derived nom existing data base code which represents the stored code object, wherein the parameters may represent complex data types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08707279&OS=08707279&RS=08707279
owner: CA, Inc.
number: 08707279
owner_city: Islandia
owner_country: US
publication_date: 20060516
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","DISCLOSURE OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Best Mode for Carrying Out the Invention","THE PREFERRED EMBODIMENT"],"p":["This application is a continuation of U.S. Ser. No. 09\/602,441 filed Jun. 23, 2000, now U.S. Pat. No. 7,047,249 granted May 16, 2006, which is continuation of U.S. Ser. No. 09\/219,253 filed Dec. 22, 1998 which is now U.S. Pat. No. 6,108,659 granted Aug. 22, 2000.","This invention relates to the field of computer related systems and methods. More specifically, the invention is a system and method for automatically generating parametric data for use in executing code objects in a data base.","It is desirable to provide efficient and cost effective means for generating code for executing a stored code object in a data base. Such stored code objects must be executed for testing the object, determining the code coverage of the object, profiling the object, debugging the object, and for other similar reasons. Generating code used for testing, profiling, debugging, etc. such an object in most data base systems is highly expensive and inefficient in that it is time consuming and highly error-prone. For example, in an Oracle\u2122 data base system using a PL\/SQL\u2122 query a stored code object or subprogram can be executed in one of two ways:","1) Use an Application programming interface such as Oracle Call Interface (OCI) that handles binding of parameters in addition to allowing the capability to execute an anonymous block that calls the subprogram; and","2) Use a PL\/SQL development tool to construct an anonymous block that calls the subprogram.","Using an application programming interface to write a program that executes a subprogram object is very time consuming and is not a practical alternative to execute subprograms. Constructing an anonymous block that calls the subprogram can also be very time consuming. SQL*Plus\u2122 provides an \u2018Execute\u2019 command that allows users to execute subprograms. To bind parameters, SQL*Plus provides the command \u2018Variable\u2019. Using a combination of these two commands, a PL\/SQL developer can execute subprograms. However, the SQL*Plus execution facility has only very limited use because of the following issues: (SQL*Plus and ORACLE and ORACLE7 are trademarks of ORACLE Corporation).","1) The \u2018Execute\u2019 command cannot be used to execute code objects that have complex parameter types in such PL\/SQL records and PL\/SQL table of records. Oracle7\u2122 application programming interfaces do not support binding complex parameter types and so any implementations based on binding parameters will be limited by the fact that it will not be able to support complex parameter types.","2) Executing a code object with a number of parameters involves writing many, many \u2018Variable\u2019 commands which is very time consuming.","In the past, many attempts have been made to automate data base testing and debugging. One such attempt was to use a compiler to store modified debug information and to construct debug tables to determine the actual data types of objects, as described in U.S. Pat. No. 5,361,351 titled \u201cSystem & Method for supporting run-time data type identification of objects within a computer program.\u201d Another such attempt is described in U.S. Pat. No. 5,519,859 titled \u201cMethod & Apparatus for Automatic table selection and generation of structured query language instructions,\u201d which describes a system of automatically generating structured query language statements from data in predefined data tables and automatically selected output tables. In both of these cases an: inordinate amount of time and effort is devoted to preparing and developing the data tables and compiler developed tables. Many other US patents describe various debugging and testing systems for data bases but none of these which is known to Applicant provides the method and system of the present invention for automatically generating the parameters necessary to execute such a subprogram.","It would be advantageous to have a method for executing subprograms that allows programmers to input the values of the parameters and display the values of the output parameters after the subprogram executes. The method of generating and executing anonymous blocks automatically should eliminate coding errors while declaring parameter data types in the anonymous blocks, at the same time initializing values for the declared parameters. The method should also allow for executing subprograms that take complex user defined types as parameters, a task which is very laborious and error prone to do in a manual fashion. A complete execution facility should facilitate thorough testing of code objects during development. This should in turn save money by reducing logical errors when these code objects are later deployed and executed in production environments through client programs.","The present invention addresses these issues through a framework to provide a complete execution facility that can be used to execute a code object. It generates an executable anonymous block automatically by avoiding binding parameters altogether. Instead, variables corresponding to the parameter types are declared and initialized in the anonymous block. After the code object is called, the variables that correspond to the parameters that are bound by reference contain the values that are returned by the subprogram. The variable declarations and initializations are accomplished through a combination of parsing the source code, looking up the parameter information stored about the subprogram in the catalog and using a wizard to get the parameter values.","A system, method and database development tool are disclosed for automatically generating parameters for use in executing a stored code object in a data base, by parsing source code derived from existing data base code which represents the stored code object, wherein the parameters may represent complex data types.","Also a method for generating an executable anonymous block for executing a subprogram in an Oracle database is claimed. Additionally claimed are a method for executing subprograms in an Oracle data base using anonymous blocks which themselves use parameter values that have been extracted from the subprogram to be executed, and a method for generating valid declaration statements of a subprogram in an Oracle data base. Also claimed is a system for developing database programs comprizing a computer system and a program code mechanism for automatically generating PL\/SQL code by parsing source code derived from existing code residing in the data base.","Other embodiments of the present invention will become readily apparent to those skilled in these arts from the following detailed description, wherein is shown and described only the embodiments of the invention by way of illustration of the best mode known at this time for carrying out the invention. The invention is capable of other and different embodiments some of which may be described for illustrative purposes, and several of the details are capable of modification in various obvious respects, all without departing from the spirit and scope of the present invention.","The present invention provides a method and apparatus for executing a subprogram in a database. The ability to execute a subprogram is a fundamental requirement for a developer. This allows verifying the logic of code objects as they is being developed.","In the following description for purposes of explanation, specific data and configurations are set forth in order to provide a thorough understanding of the present invention. In the presently preferred embodiment the invention is described in terms of an Oracle Integrated development Environment (IDE). However, it will be apparent to one skilled in these arts that the present invention may be practiced without the specific details, in various Data Base systems such as Oracle, Sybase, DB2, Informix, etc. In other instances, well-known systems and protocols are shown and described in diagrammatical or block diagram form in order not to obscure the present invention unnecessarily.","Additional Background Information","PL\/SQL is programming language available in Oracle7 servers. It is a procedural extension of the standard SQL language. SQL stands for Structured Query Language which is a standard query language designed to write queries against Relational Databases. PL\/SQL as implemented in Oracle7 databases is a procedural language geared towards implementing rules and other business logic in the database server. In a procedural programming language, logic for a program is typically implemented as subprograms. In PL\/SQL, subprograms take the form of one of the following:","1) A PL\/SQL stored procedure, which is a routine that can take input parameters and return output parameters';","2) A PL\/SQL stored function, which is a routine that can take input parameters and return output parameters. In addition stored functions can be used in an expression and returns a value of a particular type declared in the specification;","3) A PL\/SQL stored package, which is a collection of stored functions and procedures identified as a single named entity;","4) A PL\/SQL stored trigger, which is a routine that gets executed automatically, when a data manipulation statement is executed in the database server; and","5) An anonymous PL\/SQL block, which is an unnamed set of PL\/SQL statements that can be executed on the server.","Once deployed, the named routines reside in the database server and can be executed. An anonymous block on the other hand is executed immediately and is not stored in the database server.","A parameter for a subprogram is a named storage location capable of containing a certain type of data that can be read and modified during execution of the subprogram. The rules governing whether a parameter can be read or modified is specified in Oracle through the use of parameter modes. The parameter mode \u2018IN\u2019 specifies that the parameter can be read but not modified, \u2018OUT\u2019 specifies that the parameter can be read but cannot be modified and \u2018IN OUT\u2019 specifies that the parameter can be read and modified. Each parameter has a data type, which specifies the possible range of values for the parameter, the operations that can be performed on the values and the way in which the values are stored.","PL\/SQL supports a standard set of scalar data types. In addition, PL\/SQL also supports a set of user defined data types. User defined types can be based on the data definition of a particular database table or can be based on a user defined type definition. User defined type definitions can be a composite of the basic scalar data types and can also have an unlimited number of nesting.","During development of subprograms, it is important for PL\/SQL programmers to be able to execute the object to see how the function behaves when given different parameter values for the input parameters. Even when the logic is correct, the object might behave incorrectly when an invalid set of parameters is passed in. Subprogram execution based on different parameter values are necessary to detect coding errors during development.","In order to execute a subprogram, the caller needs to know about all the parameters and the associated data types. This knowledge is required independent of whether:","1) an anonymous block is constructed to execute the procedure; or","2) a program that executes the subprogram is written using an Oracle Application Programmer Interface.","Using either of these methods to execute a subprogram is a time-consuming task. The former method involves doing a couple of time consuming and error-prone tasks","1) Constructing an anonymous block that has the correct data type declarations for the parameters; and","2) Initializing the parameters manually with a set of valid parameter values.","The latter method involves debugging and testing a new program just to execute a subprogram.","Operating Environment","The present invention operates in and as a part of a general purpose computer unit which may include generally some or all of the elements shown in , wherein the general purpose system  includes a motherboard  having thereon an input\/output (\u201cI\/O\u201d) section , one or more central processing units (\u201cCPU\u201d) , and a memory section  which may have a flash memory card  related to it. The I\/O section  is connected to a keyboard , other similar general purpose computer units , , a disk storage unit  and a CD-ROM drive unit . The CD-ROM drive unit  can read a CD-ROM medium  which typically contains programs  and other data. Logic circuits or other components of these programmed computers will perform series of specifically identified operations dictated by computer programs as described more fully below.","The present invention provides a method and apparatus for executing a subprogram in an [Oracle] database. In a preferred embodiment, the method takes the values of input parameters, executes the code object and displays the values of the output parameters. A selected code object, a user interface that allows inputting parameter values of the selected code object and a user interface to display the values of the output parameters are used in the process. The selected code object provides the information required to reverse engineer the source code corresponding to the object. The source code is then passed to a specialized parser that extracts complex parameter declarations out of, the source code. Information about the parameter name, type and storage length are all reverse engineered from the Oracle catalog The parameter information from the catalog and the declaration statement parsed out of the source code is in turn used to construct variable declaration statements and variable initialization statements. The parameter information from the catalog is sufficient to construct declaration statements for scalar data types. However, for complex data types the actual declaration needs to be duplicated. This process allows bypassing of the explicit binding of parameters to values, a process that is not completely implemented for complex types. The anonymous block generation is completed by constructing the string to make the actual call to execute the subprogram. To display the output variable values a set of printing routines based on the DBMS OUTPUT Oracle system package is appended after the call to the subprogram. The anonymous block generated is then executed and the DBMS OUTPUT messages that output parameter values are displayed.","An Anonymous Block is an unnamed block of PL\/SQL code that can be executed on the server. Anonymous blocks are compiled and executed in a single operation as opposed to named blocks which are compiled and executed in two distinct operations. To execute a subprogram in PL\/SQL, one has to construct an anonymous block that calls the subprogram. The call to the subprogram involves passing in parameter values. A parameter is a named variable that can be associated with a value. The subprogram can then access these parameters as variables within the source code. Each parameter has a parameter name, a parameter type and a parameter mode. A parameter name is an identifier given to the parameter. A parameter type defines the set of data that specifies the range of values that a parameter can assume. The parameter type can be either scalar or complex. Examples of scalar parameter types include NUMBER and VARCHAR2. Examples of complex parameter types include RECORDS and RECORDS of PL\/SQL tables. A RECORD is a PL\/SQL data type that is a composite of scalar types. RECORDS can be nested in the sense that you can have RECORDS that contain other RECORDS. A parameter mode defines the behavior of the parameters. The three parameter modes, IN, OUT and IN OUT, can be used with any subprogram. An IN parameter allows you to pass values to the subprogram being called. Inside the subprogram, the IN parameter acts as a constant and so cannot be assigned a value. An OUT parameter allows you to return values to the caller. Inside the subprogram, the OUT parameter acts as an uninitialized variable and so cannot be read. An IN OUT parameter allows you to pass values into the subprogram and return modified values back. Inside the subprogram, the IN OUT parameter acts as an initialized variable and so can be read and modified.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 1","b":["11","12","18","12","15","13","14"]},"To construct an anonymous block that executes the subprogram, the present invention receives the following inputs in the preferred embodiment:","1) The subprogram name and location within the database (component  in ); and","2) The parameter values for the selected subprogram (component  in ).","The present invention generates a template for entering parameter values based on the subprogram selected and prompts for the values of the individual parameters. To do this, component  in , queries the database catalog to identify the parameter types and the subtypes of each parameter. The following Oracle query against the Oracle catalog gives this information for a stored procedure. Similar queries can be written to extract this information for a stored function, a stored package procedure or a stored package function:",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT u.name, o.name, a.argument, a.sequence#, a.overload#,"},{"entry":"\u2003a.position, a.type, DECODE(DECODE(a.type,29,3,69,11,a.type),"},{"entry":"\u2003\u20030,\u2018No Parameters\u2019, 1,\u2019VARCHAR2\u2019, 2,\u2019NUMBER\u2019, 3,\u2019NATIVE"},{"entry":"\u2003\u2003INTEGER\u2019, 8, \u2018LONG\u2019, 11, \u2018ROWID\u2019, 12, \u2018DATE\u2019,"},{"entry":"\u2003\u200323, \u2018RAW\u2019, 24,\u2019LONG RAW\u2019, 96,\u2019CHAR\u2019, 106,\u2019MLSLABEL\u2019,"},{"entry":"\u2003\u2003105, \u2018MSLABEL\u2019, 250,\u2019RECORD\u2019, 251, \u2018TABLE\u2019,"},{"entry":"\u2003\u2003252, \u2018BOOLEAN\u2019),"},{"entry":"\u2003DECODE(NVL(a.default#,0),I, \u2018YES\u2019, \u2018NO\u2019) DEFAULT#,"},{"entry":"\u2003NVL(a.in_Out,0),"},{"entry":"\u2003NVL(a. level#, 0),"},{"entry":"\u2003\u2003NVL(a.length,0),"},{"entry":"\u2003\u2003NVL(a.precision,0),"},{"entry":"\u2003\u2003NVL(a.scale,0),"},{"entry":"\u2003NVL(a.radix,0), decode(o. status, 1, 1,0),"},{"entry":"\u2003\u2003bitand(b.options,4)"},{"entry":"\u2003FROM sys.argument$ a, sys.obj$ o, sys.user$ u, sys.procedure$ b"},{"entry":"\u2003WHERE a.OBJ#(+) = o.obj#"},{"entry":"\u2003and o.obj# = b.obj#"},{"entry":"\u2003AND o.owner# = u.user#"},{"entry":"\u2003and o.linkname is null"},{"entry":"\u2003and o.type = 7"},{"entry":"\u2003and"},{"entry":"\u2003(o.owner# in (uid, 1\/* PUBLIC*\/)"},{"entry":"\u2003or"},{"entry":"\u2003(o.obJ# in (select obj# from sys.objauth$"},{"entry":"\u2003\u2003where grantee# in (select kzsrorol from ptsql_auth)"},{"entry":"\u2003\u2003and privilege# = 12)\/* EXECUTE *\/"},{"entry":"\u2003)"},{"entry":"\u2003or"},{"entry":"\u2003(exists (select null from sys.v_$enabledprivs"},{"entry":"\u2003where priv_number in (\u2212144 \/* EXECUTE ANY PROCEDURE *\/,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2212142, \u2212143, \u2212141 \/*CREATE ANY PROCEDURE *\/)"},{"entry":"\u2003)"},{"entry":"\u2003)"},{"entry":"\u2002)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the preferred embodiment, the present invention constructs a list of parameters and its associated types in memory. The list is singly nested for complex parameter types whose components are all scalars. There is a plurality of nesting in this list in the case of complex parameter types that are nested. This list is used to generate the template for getting the input parameter values. This mechanism allows error detection while inputting these values\u2014the values have to conform to the range of values specified by the type of the parameter.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 2 through 5","FIG. 1"],"b":["21","22","12"]},"The present invention then scans the list (component  in ) starting with the first item. Component  in  checks whether the item is a complex parameter. If it is a complex parameter, the flowchart in  illustrates the anonymous block construction steps that declare and initialize a complex parameter. Otherwise, the flowchart in  illustrates the steps that declare and initialize a scalar parameter. The steps starting in component  in  are repeated for every parameter to construct a string that declare and initialize all parameters of the subprogram. After the declaration and initialization of parameters is completed, the flow chart in  illustrates the steps the present invention uses to complete the construction of the anonymous block. Once the anonymous block is constructed, it is executed on the server and the output parameters are outputted.","The present invention keeps two strings to construct the declaration and initialization sections of the anonymous block. To declare a complex parameter, the present invention first reverse engineers the source code of the object from the Oracle server (component  in ). It then parses the source code to extract the string that declares the complex parameter (component  in ). A standard searching algorithm or a simple state diagram based parser may be used for this purpose. The string parsed out is then modified to make it a variable declaration statement as opposed to a parameter declaration statement. The resulting string is appended to the string that stores the declaration section of the anonymous block.","After constructing the string for the declaration of the complex type, the present invention accesses the nested list that holds the parameters of the subprogram to get the list that holds the sub components of the complex type (component  in ). It then scans the list starting with the first scalar sub component of the complex parameter. For each scalar sub component, an initialization statement is then constructed using the value inputted in component  in . The initialization statement is then appended to the string that holds the initialization section of the anonymous block (component  in ).","For a parameter with a scalar type, the present invention constructs the declaration of the parameter in component  in . The parameter information retrieved from the Oracle catalog (component  in ) is used for the purpose. The present invention then constructs the initialization statement using the component  in .","Once the declaration and initialization sections of the anonymous block are completed, the present invention combines the initialization and declarations sections to form a string that holds a partial block of PL\/SQL code.","The present invention then constructs the code to execute the subprogram using the subprogram name from component  in  and the parameter names from component  in . The string is then appended to the string that contains the partial anonymous block constructed in component  in .","The present invention then constructs the calls to output the values of the output parameters. The process of scanning the list of parameters is again applied for the purpose. For each scalar parameter, check whether it is an output parameter and if it is append the call to output the value. For a complex parameter, apply the recursive process of scanning the sub components. Then construct a single call to do a formatted output of the subcomponents of the parameter.","Following is an example of an anonymous block generated in the preferred embodiment for a stored procedure:","A stored procedure \u2018foo\u2019 has two parameters. The first parameter \u2018scalar1\u2019 is a scalar IN parameter of type VARCHAR2. The second parameter \u2018record I\u2019 is a complex parameter of type \u2018tab1% TYPE\u2019, where the table \u2018tab1\u2019 has two columns, the first column \u2018col1\u2019 of type VARCHAR2(30) and the second column \u2018col2\u2019 of type NUMBER. The anonymous block generated by applying the procedure above will be:","1. declare;","2. scalar1 varchar2(2000);","3. record1 tab 1% TYPE;","4. begin;","5. scalar1:=\u2018input 1\u2019;","6. record1.col1:=\u2018input 2\u2019;","7. record1.col2:=input3;","8. foo(scalar1, record1);","9. dbms_output.put_line(record1.col1\u2225\u2018,\u2019\u2225 record1.col2);","11. end;","Line 2 above is constructed by using the parameter list constructed in component  of . Line 3 above is constructed by parsing out the declaration out of the source code using the process in component  in . Lines 5 through 7 is constructed using the process illustrated in . Line 8 is constructed by using the parameter names stored in the parameter list, Line 9 which output the OUT parameters is constructed by scanning the parameter list and checking whether they are OUT parameters. Note that other Relational Data Base Management Systems (RDBMS) may refer to read only, write only and read\/write constraints by other terms.","Additional background information specific to the Oracle Data Base, PL\/SQL and SQL*Plus can be found in the following references which are hereby incorporated fully herein by reference:","1. SQL*Plus User's Guide and Reference Release 3.1 p 6-45.","2. PL\/SQL User's Guide and Reference Release 2.2 Chapter 8.","3. Oracle 7 Application Developer's Guide Release 7.3.","Having described the invention in terms of a preferred embodiment, it will be recognized by those skilled in the art that various types of general purpose computer hardware may be substituted for the configuration described above to achieve an equivalent result. Similarly, it will be appreciated that arithmetic logic circuits are configured to perform each required means in the claims for processing parametric input to automatically generate the required calls to execute a stored data object. It will be apparent to those skilled in the art that modifications and variations of the preferred embodiment are possible, which fall within the true spirit and scope of the invention as measured by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The features and advantages of the system and method of the present invention will be apparent from the following description in which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
