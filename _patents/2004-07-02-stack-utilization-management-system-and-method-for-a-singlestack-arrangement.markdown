---
title: Stack utilization management system and method for a single-stack arrangement
abstract: A system and method for managing utilization in a stack. A stack base and a stack pointer are initialized for the stack. Upon fetching a program instruction to be executed in a computing environment, a determination is made if the program instruction involves accessing a location within a valid stack range that is defined by a high water mark operable to identify the stack pointer's farthest location from the stack base. The farthest location is indicative of how far the stack has grown at any time during the program's execution. A warning may be provided upon determining that the location to be accessed is not within the valid stack range.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06904513&OS=06904513&RS=06904513
owner: Hewlett-Packard Development Company, L.P.
number: 06904513
owner_city: Houston
owner_country: US
publication_date: 20040702
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY UNDER 35 U.S.C. \u00a7120 & 37 C.F.R. \u00a71.78","CROSS-REFERENCE TO RELATED APPLICATION(S)","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE DRAWINGS"],"p":["This nonprovisional application is a divisional application claiming the benefit of the following prior U.S. patent application entitled: \u201cSTACK UTILIZATION MANAGEMENT SYSTEM AND METHOD FOR A SINGLE-STACK ARRANGEMENT,\u201d application Ser. No. 09\/973,156, filed Oct. 9, 2001, in the name(s) of: Dan Tormey, Joe Bolding and Gerald Everett, which is hereby incorporated by reference.","This application discloses subject matter related to the subject matter disclosed in the following commonly owned co-pending patent application(s): (i) \u201cStack Utilization Management System And Method For A Two-Stack Arrangement,\u201d application Ser. No. 09\/973,665, filed Oct. 9, 2001, in the name(s) of: Dan Tormey, Joe Bolding and Gerald Everett.","The use of stacks in association with program execution in computing environments is well known: stacks are initialized, contents are pushed or pulled based on calls to and returns from sub-functions, subroutines, etc., and the programs are executed to completion. There is no automatic way, however, to determine the required depth of a stack before a program is launched. Accordingly, it becomes necessary to ensure that there is no conflicting use of stack space due to, e.g., stack overflow, which can otherwise lead to stack corruption.","Two solutions are currently available. In one existing arrangement, the user is required to inspect the program code manually and place debug statements in the code to ensure that the stacks growing towards each other (for example, a stack area initialized for the program, which grows in one direction, and its associated register spill area set up by the operating system, which grows in the opposite direction) do not use the same memory. Another solution is to fill stack memory with markers having specific bit patterns. The code is executed in normal fashion and, after the execution is complete, the user needs to verify that the markers still exist.","While these solutions are generally useful, they are nevertheless beset with several shortcomings and disadvantages. First, forcing the user to step through the code manually is extremely inconvenient and imposes severe performance-related constraints. On the other hand, embedding marker patterns at arbitrary locations in a stack area is not a highly reliable mechanism for detecting stack overflow. For example, even if the marker pattern remained after executing the program, it is no guarantee that there was no stack overflow because the instruction(s) overwriting the marker area might have written a pattern that is identical to the marker pattern. Also, there may be situations where stack overflow does not actually overwrite the marker location. Rather, the overflow may simply \u201cskip\u201d the marker area in the stack, which makes it very difficult to diagnose a corrupted stack. Further, where two-stack arrangements are implemented, each stack growing towards the other, there is the additional problem of not being able to identify which of the two stacks actually caused the overflow.","Additionally, regardless of whether one-stack or two-stack arrangements are utilized, the conventional stack utilization management schemes are woefully inadequate with respect to detecting stack conditions that are either invalid or have the potential to become so. For instance, where stack pointer operations are involved, the current techniques do not test whether a new location to which the stack pointer is to be moved may violate a predetermined stack range. Also, because only write operations that affect the marker's bit pattern are detectable, invalid conditions arising out of read operations cannot be discovered in conventional schemes.","In one embodiment, a scheme is provided for managing utilization in a stack. A stack base and a stack pointer are initialized for the stack. Upon fetching a program instruction to be executed in a computing environment, a determination is made if the program instruction involves accessing a location within a valid stack range that is defined by a high water mark operable to identify the stack pointer's farthest location from the stack base. The farthest location is indicative of how far the stack has grown at any time during the program's execution. A warning may be provided upon determining that the location to be accessed is not within the valid stack range.","In the drawings, like or similar elements are designated with identical reference numerals throughout the several views thereof, and the various elements depicted are not necessarily drawn to scale. Referring now to , depicted therein is a stack  operable to grow in one direction that is managed in a conventional manner. A starting location  of the single stack  is set at a location that defines the single stack's stack base. A stack pointer (SP) associated with the stack is initialized to the stack base. Reference label SP-T represents the SP at time T. An arbitrary stack boundary marker is set at a location or region  relative to the stack base  for defining an expected maximum growth area A. Region B, which is contiguous with region A, may be occupied by other stacks, code portions, or other data, etc.","The stack boundary marker  is typically initialized with a predetermined bit pattern. When a program is executed, the arguments (e.g., local variables, etc.) and data associated with the program's subroutines and functions are pushed to the stack depending on where the stack pointer is. Accesses to or from the various stack locations are effectuated relative to the stack pointer's current location. Upon returning control from the subroutines, the local variables and data are pulled from the stack. Accordingly, as the stack  grows and\/or contracts during the execution of the program, the stack pointer also moves in accordance with stack utilization. In , SP-T and SP-T refer to the locations of the stack pointer at two different instances.","It is possible for the stack pointer to go beyond the expected maximum growth area A in the conventional arrangement. Thus, when the stack grows, it may overflow the boundary  and possibly corrupt the code and\/or data in the region B. When the user examines the boundary marker's bit pattern upon completion of the program's execution, an altered pattern therein caused during the overflow indicates the strong possibility of a corrupted stack. However, as pointed out in the Background section of the present patent application, there are several limitations in this approach including the lack of capability to detect illegal read\/write accesses and invalid stack pointer operations.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2A","b":["200","202","200","202","0","204","208","208","1","202","204","202","200","208","202","206","208","3"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2B","b":["200","202","200","0","210","204","1","1","210","210","202","2","3"]},"As a further guard against possible stack corruption resulting from overflow, the present invention introduces the concept of a \u201chigh water mark,\u201d which is operable to track a stack pointer's movement during the execution of a program and thus identify the farthest location to which the stack pointer has traveled with respect to the stack base. Referring now to , shown therein is the exemplary stack  where a stack pointer's high water mark (HWM) is tracked in accordance with an embodiment of the invention. The stack's base  and SP are initialized as explained hereinabove. Depending upon how the stack is utilized, the stack pointer is located at SP-T, SP-T, SP-T, SP-T and SP-T at different instances during a program run. Where the HWM is initialized to the stack base, it moves with the SP as the program is executed, changing only when the new SP is lower than (or, greater than, if the direction of growth is in the opposite direction, i.e., upward direction) the current SP location. As exemplified in , the farthest location from the stack base  to which the stack pointer has traveled is SP-T, which is identified at the end of the run as the high water mark of the stack.","It should be readily appreciated that by identifying a stack's high water mark for a particular program, the placement of a marker zone can be optimized based on historical high water mark data for the stack. Additionally, the high water mark may also be used in determining whether a particular SP operation involves modifying a current SP location to a new location that is beyond the historical high water mark. Varius such determinations with respect to SP operations will be described in additional detail hereinbelow with particular reference to the flow chart depicted in .",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["200","302","304"]},"Upon fetching an instruction at any time during the program's execution (step ), a determination is made if the instruction requires or involves accessing a stack location for a read operation or a write operation (decision block ). If the instruction does not involve accessing a stack location, the flow continues for normal operations (step ), whereby the program instruction is executed normally. If, on the other hand, it is determined that the instruction involves accessing a particular stack location, a further determination is made to verify if the stack location to be accessed is within a valid stack range, e.g., a range bounded by the stack base and the current valid SP pointer (decision block ). If the stack location to be accessed satisfies the valid range condition, a valid access is indicated (step ) and, subsequently, the access process is continued (step ).","If the stack location to be accessed does not satisfy the valid range condition, a user warning may be provided (step ). Thereafter, as an optional determination, the user may be queried (decision block ) whether to carry on with the program flow which involves an invalid access operation (step ), or return control to user where the computing environment in which the program is being executed comprises an architectural simulator (step ). In the exemplary embodiment where the methodology of the present invention is implemented in an actual hardware environment, a suitable default handler may be instigated via interrupts, etc.","Referring now to  together, depicted therein is a flow chart of the various steps involved in an exemplary stack utilization management method for managing a single stack according to another embodiment of the invention, where the validity of SP operations is verified with respect to a plurality of stack ranges. Similar to the stack access operation management methodology set forth above, the exemplary stack is initialized with respect to its stack base, associated fixed marker and a direction indicator, pursuant to executing a program in a simulated environment or on an actual hardware platform. Also, a stack pointer and current HWM are set to the stack base (step ). As will be seen below, the stack pointer and\/or HWM may be updated as necessary during the program execution.","Upon fetching an instruction at any time during the program's execution (step ), a determination is made if the instruction requires or involves modifying the current SP location (decision block ). If the instruction does not involve modifying the SP, the process flow continues to process the instruction in a normal manner (step ). On the other hand, if the SP's current location is to be changed to a new location, a plurality of conditions are tested to verify whether the new location is located within a predetermined stack range that ensures stack integrity. For instance, in decision block , it is determined if the new SP location is beyond the stack base (which could be above the stack base where the stack grows in downward direction, or beneath the stack base where the stack grows in upward direction). If so, the program instruction entails an invalid SP operation (step ) and, subsequently, steps such providing user warning and\/or return of program control may be implemented (step ). In decision block , it is determined if the new SP location is beyond the historical HWM of the stack. If not, the process flow continues with the SP operation. Thereafter, the stack's SP may be updated accordingly (step ).","If the new SP location is beyond the stack's historical HWM, it may be updated accordingly (step ). In decision block , it is further determined whether the new SP location is located at or beyond the stack marker. If not, the SP operation may proceed in a normal manner, whereby the SP may be updated (step ). Otherwise, the new SP location indicates an invalid SP, thereby instigating user warning (step ) and optional return of control. Decision block  and steps  and  exemplify these operations.","Those skilled in the art should readily recognize upon having reference hereto that in one exemplary embodiment of the present invention, the methodology for validating stack access operations and the methodology for validating stack pointer operations may be blended together in many different combinations. Also, the various determinations provided in the respective methodologies may be implemented in any order and in any combination or sub-combination thereof. Accordingly, it should be apparent that the stack utilization management method of the present invention is highly susceptible to numerous modifications and rearrangements.","Referring now to , shown therein is a conventional two-stack arrangement  where the stacks are operable to grow towards each other. Similar to the stack  depicted in , a first stack A is initialized by its stack pointer (SPA) that initially points to the stack's starting location  (i.e., first stack's base). Reference numeral  refers to the direction of the first stack's growth. A second stack B is similarly initialized by its stack pointer (SPB) that initially points to the second stack's starting location  (i.e., second stack's base). Reference numeral  refers to the direction of the second stack's growth. Typically, the first stack A is exemplified with a downward growth and the second stack B is exemplified with an upward growth. Furthermore, the second stack B may represent a register spill area that is set up by the operating system when the first stack A is initialized for executing the functional calls of a program.","In a conventional arrangement, an arbitrary boundary marker  is positioned between the two stack bases  and . A predetermined bit pattern is initialized therein that is operable as an overflow marker essentially in the same manner as described hereinabove with respect to the conventional stack arrangement shown in FIG. . As a consequence, the existing stack utilization management schemes for a two-stack system have the same problems as previously alluded to. In addition, where a stack overflow is encountered, there is inherent ambiguity concerning which of the two stacks actually caused it.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 6A","b":["600","602","606"]},"A first stack pointer (SPA) associated with the first stack is initially set to the stack base . A first direction indicator is provided for specifying the direction of growth from the stack base . Typically, the stack base  may be associated with a \u201chigh memory\u201d stack operable to grow downward. A second stack pointer (SPB) associated with the second stack is similarly initialized to point to the second stack's base . A second direction indicator is provided for specifying the direction of growth from the stack base , which may be associated with a \u201clow memory\u201d that is operable to grow upward.","During the execution of the program, the respective SPs are updated depending upon the occurrence of push and pop operations affecting the two stack portions, which can occur independently as long as there is no overflow. Each SP is thus located at a location which defines a valid stack area with respect to the stack portion it is associated with. For example, reference label SPA(T) refers to the first stack's SP at time T. Analogously, reference label SPB(T) refers to the second stack's SP at time T. Accordingly, stack area A bounded between the stack base  and SPA(T) is defined as a valid stack area which can be accessed by a program instruction involving access to a location in the first stack (i.e., downward-growing stack). Likewise, stack area C bounded between the stack base  and SPB(T) is defined as a valid stack area that can be accessed by a program instruction with respect to a location in the second stack (i.e., upward-growing stack). In the valid state where the SPs do not cross over each other, there is a \u201cno man's land\u201d (region B), access to which is not permitted. It should be apparent to those skilled in the art upon having reference hereto that the stack access validity rules with respect to the two-stack arrangement are essentially similar to the access validity rules provided in the foregoing section for the single-stack systems (for example, the flow chart depicted in ) and, accordingly, will not repeated here for the sake of brevity.","Referring now to , depicted therein is the exemplary two-stack arrangement  where stack pointer operations are tested in accordance with an embodiment of the invention. Similar to the rules set forth above for validating stack pointer operations in a single-stack system, the movement of the SPA and SPB pointers is tested against a plurality of conditions so as to prevent overflow, cross-over and other stack management problems. In the exemplary scenario depicted in , both SPA and SPB are located at valid locations at time T, as exemplified by SPA(T) and SPB(T). Thereafter, when a program instruction which involves modifying the SPA pointer to its new location, i.e., SPA(T) located in the valid access area for the second stack, is encountered during the execution of the program, the present invention's stack utilization management scheme is operable to detect the ensuing cross-over of the pointers and appropriately alert the user and\/or return control.","Since there are two SPs involved and each stack may be provided with a respective HWM, there are various combinations of conditions required to be tested for maintaining stack integrity. For instance, the following conditions may be tested in any combination on an instantaneous basis during the program flow: (i) SPB crosses SPA; (ii) SPB crosses SPA's HWM; (iii) SPA crosses SPB; and (iv) SPA crosses SPB's HWM. Moreover, because the HWMs of the two stacks can be advantageously monitored and updated, it is also possible to verify after the program's completion if the respective HWMs have crossed. This condition can occur even where there was no instantaneous SP overlap. Thus, by monitoring the HWM cross-over, potential stack overlap problems (which can be caused by different runtime algorithms) can be avoided.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 6C","FIG. 6C"],"b":["600","0","0","0","1","1","1","1","1","1","2","2","2","602","1","620","606","2","622","622","620"]},"Referring now to , depicted therein is a flow chart of the various steps involved in an exemplary stack utilization management method for managing a two-stack arrangement in accordance with an embodiment of the invention. At step , various stack initializations take place for the two stacks of the stack arrangement. As pointed out earlier, one or more user-operable routines may be provided via appropriate API or APIs to set the various stack initializations in any combination. Thereafter, SP updates and\/or HWM updates are effectuated in the normal course of the program execution as will be explained hereinbelow.","Upon fetching a program instruction at any time during the program run (step ), a determination is made whether the instruction involves access to a stack location or requires modifying either SPA or SPB pointer. This determination is captured in decision blocks ,  and . If the instruction involves accessing either stack, access validity rules set forth above with respect to the management of single-stack systems apply (step ). On the other hand, if the instruction does not involve stack access or stack pointer operations, the instruction is executed normally and the process flow simply continues (step ).","If the program instruction requires modifying SPA, a plurality of determinations are made to ensure that the stacks' integrity is not jeopardized by moving SPA from its current location to a new location. First, upon requesting an SPA operation, the associated HWM-A is updated accordingly (step ). In decision block , it is determined if the new location is higher than the stack base (since this is exemplified as a high memory stack). That is, in general, a determination is made if the new location is out of range with respect to the first stack's stack base. In decision block , it is determined if the new SPA location crosses or coincides with the current location of SPB. In decision block , it is determined if the new SPA location crosses or coincides with the current HWM-B location. Similar to the single-stack management methodology described above, when any one of these conditions is met, user warning and\/or optional return of control may be appropriately provided (step ). Upon completion of these determinations, a valid SPA operation is identified which is effectuated thereafter in normal fashion (step ). Subsequently, the current SPA pointer is updated (step ).","Similarly, if the program instruction requires modifying SPB, a plurality of determinations are made to ensure that the stacks' integrity is not jeopardized by moving SPB from its current location to a new location. Again, HWM-B is updated accordingly when an SPB operation is requested (step ). In decision block , it is determined if the new location is lower than the stack base (i.e., out of range), since this stack portion is exemplified as a low memory stack. In decision block , it is determined if the new SPB location crosses or coincides with the current location of SPA. In decision block , it is determined if the new SPB location crosses or coincides with the current HWM-A location. Again, when any one of these conditions is met, user warning and\/or optional return of control may be appropriately provided (step ). Similar to the SPA operation, a valid SPB operation is identified upon completion of these determinations, which operation is then effectuated normally (step ). Subsequently, the current SPB pointer is updated (step ).",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 8","b":["802","806","804","806","806","808","806"]},"An interface  is provided for facilitating user interaction with the simulated environment either directly or via an API . Preferably, API  is available for the user to implement the present invention in one or more API routines that allow interactions with a stack management module  associated with the simulator . The API routines are operable to set a plurality of initial values for managing stack utilization as described in greater detail hereinabove. Reference numerals - through -N exemplify stack identifiers which are operable to be set by the user by means of the API routines for managing two-stack arrangements. Each stack identifier is comprised of a stack base (e.g., reference numeral ) and a direction indicator (e.g., reference numeral ) associated with a particular stack. Further, one or more identifiers may also be provided (reference numerals - through -M) for managing a plurality of stacks in accordance with the teachings set forth above.","Referring now to , depicted therein is a block diagram of an exemplary multiprocessing (MP) system  wherein a stack utilization management system according to one embodiment of the invention can be advantageously utilized. Reference numerals - through -N refer to a plurality of processor complexes interconnected together via a high performance, MP-capable bus . Each processor complex, e.g., processor complex -, is comprised of a central processing unit (CPU) , a cache memory , and one or more coprocessors . Preferably, the MP system is architectured as a tightly coupled SMP system where all processors have uniform access to a main memory  and any input\/output (I\/O) device  in a shared fashion. As an SMP platform, each processor has equal capability to enable any kernel task to execute on any processor in the system. Whereas threads may be scheduled in parallel fashion to run on more than one processor complex, a single kernel controls all hardware and software in an exemplary implementation of the MP system , wherein locking and synchronization strategies provide the kernel the means of controlling MP events.","Continuing to refer to , each processor complex is preferably provided with its own data structures, including run queues, stacks, counters, time-of-day information, notion of current process(es) and priority. Global data structures available for the entire MP system  are protected by means such as semaphores and spinlocks. Furthermore, in other implementations of the MP system, the processors may be arranged as \u201ccells\u201d wherein each cell is comprised of a select number of processors (e.g., 4 processors), interrupts, registers and other resources.","An interface  is provided for facilitating interactions between the user and SMP computing environment. Analogous to the architectural simulator environment described hereinabove with reference to , one or more API routines may be provided for setting stack identifiers in the SMP system  in order to manage stack utilization when a program is executed thereon.","Based upon the foregoing Detailed Description, it should be readily apparent that the embodiments disclosed herein provide an innovative stack utilization system and method operable in a high performance computing environment for managing stack overflow without the limitations of the state-of-the-art solutions. Because stack access or stack pointer operations are verified for overflow conditions before the program instructions are actually executed, users are provided with a more dynamic view of stack consumption. Thus, in one embodiment, the invention allows the detection of stack overlap at the first occurrence of any potential overlap (in the case of two-stack arrangements) before any stack corruption takes place. Further, in one embodiment, the invention obviates the need for specific bit pattern markers embedded in the stacks to detect overflow or for manually inspecting the code by placing numerous debug statements therein.","It is believed that the operation and construction of the present invention will be apparent from the foregoing Detailed Description. While the system and method shown and described have been characterized as being preferred, it should be readily understood that various changes and modifications could be made therein without departing from the scope of the present invention as set forth in the following claims. For example, while the teachings of the present invention have been particularly exemplified within the context of SMP systems and\/or simulated environments therefor, those skilled in the art should recognize that the present invention can be practiced in conjunction with other hardware platforms including, for example, asymmetrical MP systems, loosely-coupled MP architectures, shared- or dedicated-cache systems, and other high performance computing machines. Furthermore, the stack utilization scheme of the present invention may be employed in conjunction with the execution of the any type of program code, e.g., application software, operating system software, API software, kernel programs, firmware, or a combination thereof. The various determinations for validating stack access and\/or stack pointer operations may be implemented in software structures, hardware structures or firmware structures. Accordingly, all such modifications, extensions, variations, amendments, additions, deletions, combinations, and the like are deemed to be within the ambit of the present invention whose scope is defined solely by the claims set forth hereinbelow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
