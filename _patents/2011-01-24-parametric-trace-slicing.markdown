---
title: Parametric trace slicing
abstract: A program trace is obtained and events of the program trace are traversed. For each event identified in traversing the program trace, a trace slice of which the identified event is a part is identified based on the parameter instance of the identified event. For each trace slice of which the identified event is a part, the identified event is added to an end of a record of the trace slice. These parametric trace slices can be used in a variety of different manners, such as for monitoring, mining, and predicting.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08719796&OS=08719796&RS=08719796
owner: The Board of Trustees of the University of Illinois
number: 08719796
owner_city: Urbana
owner_country: US
publication_date: 20110124
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","GOVERNMENT LICENSE","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Direct Program Instrumentation","Predictive Program Instrumentation","Parametric Trace Slicing","Parametric Trace Slice Monitoring","Parametric Trace Slice Mining","Example Computing Device"],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/298,303, filed Jan. 26, 2010, entitled \u201cParametric Trace Slicing\u201d, to Grigore Rosu, Feng Chen, and Patrick O. Meredith, which is hereby incorporated by reference herein.","This invention was made with Government support under Grant Numbers CCF-0448501, CNS-0509321, and CNS-0720512 awarded by the National Science Foundation (NSF), and Contract Number NNL08AA23C awarded by the National Aeronautics and Space Administration (NASA). The Government has certain rights in the invention.","Analyzing execution traces of programs is oftentimes performed to debug and\/or otherwise analyze computer programs. Unfortunately, many computer programs can result in execution traces that are very long and\/or complex. This problem is exacerbated for parametric traces, which are traces that contain events with parameter bindings. In parametric traces, the execution trace typically includes multiple trace slices merged together, with each trace slice corresponding to a parameter binding. Accordingly, it can be difficult to analyze execution traces, particularly for parametric traces.","This Summary is provided to introduce subject matter that is further described below in the Detailed Description. Accordingly, the Summary should not be considered to describe essential features nor used to limit the scope of the claimed subject matter.","In accordance with one or more aspects, a program trace is obtained and events of the program trace are traversed. For each event identified in traversing the program trace, a trace slice of which the identified event is a part is identified based on one or more parameter instances in the identified event. For each trace slice of which the identified event is a part, the identified event is added to an end of a record of the trace slice.","Parametric trace slicing is discussed herein. A program trace is a parametric execution trace containing events with parameter bindings, and is traversed to identify multiple parametric trace slices in the program trace. During the traversal, a table of parametric trace slices is generated. This table can be subsequently accessed to retrieve one or more parametric trace slices without re-traversing the program trace. These parametric trace slices can be used in a variety of different manners, such as for one or more of monitoring, mining, and predicting.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","102","104","106","108","110","102","104","106","108","110","102","104","106","108","110","100"]},"Parametric execution traces  can be generated using a variety of different techniques, such as using direct program instrumentation and\/or predictive program instrumentation. In one or more embodiments, parametric execution traces  are generated by module  using direct program instrumentation. In such embodiments, parametric traces are constructed in the order events occur in the actual program.","In alternate embodiments, parametric execution traces  are generated by module  using predictive program instrumentation. In such embodiments, multiple parametric execution traces  are output by module , one of which corresponds to the actual order of observed events in a program. The other parametric execution traces correspond to possible sequences of events with respect to a partial order such as \u201chappens-before\u201d or \u201csliced causality\u201d, and are relevant in multi-threaded or distributed programs. These other parametric execution traces are not the actual observed trace, although these other parametric execution traces may occur in different runs or executions of the program. Thus, using predictive program instrumentation additional bugs or errors can be found that did not occur when the program was actually run.","Parametric trace slicing module  receives one or more execution traces . Module  analyzes parametric execution traces  and outputs one or more trace slices  obtained from the parametric execution traces . In one or more embodiments, trace slices  are output by system  for analysis (e.g., by a program developer). In addition to (or alternatively in place of) system  outputting trace slices , trace slices  can be input to one or more of monitoring module  and mining module .","A parametric execution trace  is an execution trace that contains events with parameter bindings. Events with parameter bindings are present in programs where abstract parameters (e.g., variable names) are bound to concrete data (e.g., heap objects) at runtime. Accordingly, a parametric execution trace  can include numerous events with numerous parameter bindings. Parametric trace slicing module  analyzes a parametric execution trace  and obtains the trace slices corresponding to each instance of a parameter. Module  generates a record (e.g., a table) of parametric trace slices while traversing trace , thereby avoiding any need to re-traverse the trace for each instance of a parameter. Module  also obtains the trace slices without imposing restrictions on the type of parametric execution trace . For example, the first event for a particular property instance need not bind all the parameters for the property.","Monitoring module  monitors parametric execution traces and determines whether the monitored traces comply with particular constraints. These constraints can be specified, for example, as regular expressions identifying the format that monitored traces are to follow. Monitoring module  can operate on parametric execution traces  and\/or trace slices . An indication of whether traces and\/or trace slices comply with the particular constraints can be output by monitoring module  in a variety of different manners, such as by generating one or more tables and\/or other records. These indications are output by module  as monitoring results .","Mining module  analyzes trace slices  to generate non-parametric state-based specifications together with equivalent regular expressions. An indication of these specifications and\/or regular expressions are output by module  as mining results . Mining module  automatically detects various aspects regarding the manner in which the underlying program (that was executed to generate parametric execution traces ) operates. For example, mining module  can automatically detect Application Programming Interface (API) patterns, usage scenarios, and so forth.","Direct program instrumentation refers to obtaining a parametric execution trace corresponding to an actual execution of a program. Direct program instrumentation is performed by, for example, direct program instrumentation module  of .","Generally, using direct program instrumentation, particular points of interest in a program are specified. The location of these points of interest can be specified in different manners, such as by a user (e.g., a program developer or system administrator), or by another module or device. When such specified points of interest in the program are reached, they are reported as an event to one or more other modules in the system. A set of such events reported for a program are the parametric execution trace for the program. Direct program instrumentation can be performed in a variety of different conventional manners. For example, direct program instrumentation can be performed using an aspect language such as AspectJ. Additional information regarding the AspectJ aspect language can be found in, for example, \u201cAn Overview of AspectJ\u201d, by G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. G. Griswold, European Conference on Object Oriented Programming (ECOOP) '01 (2001).","Predictive program instrumentation refers to attempting to infer all possible execution traces in a multi-threaded or distributed program in which different inter-leavings of execution of the threads or distributed pieces can result in different execution traces. Predictive program instrumentation is performed by, for example, predictive program instrumentation module  of . It should be noted that although inferring all possible execution traces is attempted, the predictive program instrumentation may actually infer fewer than all possible execution traces.","Predictive program instrumentation begins by generating a direct trace of program events (e.g., using direct program instrumentation as discussed above). At predetermined points during the collection of the direct trace, a partial order of events is determined using control relations such as \u201chappens-before\u201d or \u201csliced causality\u201d. The partial order of events can be determined using a variety of different control relations. Additional information regarding the \u201chappens-before\u201d control relation can be found in, for example, \u201cTime, Clocks, and the Ordering of Events in Distributed Systems\u201d, by L. Lamport, Communications of the ACM, 21(7):558565 (1978). Additional information regarding the \u201csliced causality\u201d control relation can be found in, for example, \u201cParametric and Sliced Causality\u201d, by F. Chen and G. Rosu, Computer Aided Verification (CAV) '07 (2007).","The location of these predetermined points can be specified by a user (e.g., a program developer or system administrator), or by another module or device. In one or more embodiments, the location of the predetermined points is determined by balancing precision of the partial orders (which is increased or improved by spacing the predetermined points further apart) against runtime overhead (which is decreased or improved by spacing the predetermined points closer together).","The feasible traces with respect to these determined partial orders of events are generated. For example, assume a program generates a trace a b c, where each letter represents an event, and that the control relation used determines that a must occur before c. In this example, then, the feasible traces b a c and a c b can be inferred. The parametric execution traces generated by the predictive program instrumentation include these feasible traces as well as the actual traces from the direct trace of program events. Thus, the parametric execution trace includes feasible traces that were not actually part of the tested execution of the program. This allows errors that occur within a feasible trace (but do not occur in the actual tested execution of the program) to be identified or predicted. Referring to , this allows the monitoring performed by monitoring module  and\/or the mining performed by mining module  to be performed based on feasible traces that did not occur in the actual tested execution of the program.","Parametric trace slicing refers to obtaining from (or identifying in) a parametric execution trace multiple trace slices each of which corresponds to an instance of a parameter in the parametric execution trace. Parametric execution traces can be obtained using a variety of different instrumentation techniques, such as the direct program instrumentation and\/or predictive program instrumentation techniques discussed above. Parametric trace slicing is performed by, for example, parametric trace slicing module  of .","In the discussions herein, \u03b5 refers to a set of non-parametric events (also referred to as base events). An \u03b5-trace is a non-parametric trace when \u03b5 is understood or not important. An \u03b5-trace is referred to as any finite sequence of events in \u03b5, also referred to as an element in \u03b5*. An event can be referred to as e and a trace can be referred to as w, and if an event e\u2208\u03b5 appears in a trace w\u2208\u03b5*, this situation is also referred to as e\u2208w.","An \u03b5-property P, also referred to as a base or non-parametric property, is a function P:\u03b5\u2192C that partitions a set of traces into categories C. In one or more embodiments, categories in C include \u201cvalidating\u201d, \u201cviolating\u201d, and \u201cdon't know\u201d (also referred to as \u201c?\u201d). Other categories for C can alternatively be used, such as \u201cmatching\u201d and \u201cdon't care\u201d.","A regular expression can be used to identify an acceptable or proper format for a trace (or portion thereof). This can also be referred to as a constraint on the trace (or portion thereof). Assuming C is the set {validating, violating, don't know}, and for a given regular expression E of a trace, the property P:\u03b5*\u2192C of the regular expression E is defined as follows: P(w)=validating if and only if w is in the language of E, P(w)=violating if and only if there is no w\u2032\u2208\u03b5* such that w w\u2032 is in the language of E, and P(w)=don't know otherwise.","These preceding definitions can be extended to the parametric case where events carry concrete data instantiating abstract parameters as follows. For example, assume an event Acquire and an event Release are parametric in their resource (a resource to be acquired and released). Assume r is the name of the generic resource parameter, and that rand rare two concrete resources. Following this assumption, parametric acquire\/release events have the form Acquirerr, Releaserr, and so forth. It should be noted that not all events need carry instances for all parameters. For example, Begin and End parametric events (signifying the beginning and ending, respectively, of a procedure), have the form Begin\u22a5and End\u22a5, where \u22a5 refers to the partial map undefined everywhere and instantiates no parameter. The sets of total\/partial functions from A to B are also referred to as [A\u2192B]\/[AB].","A set of parameters is referred to as X, and a set of corresponding parameter values is referred to as V. A set of base events is referred to as \u03b5 as discussed above, and \u03b5X is a set of corresponding parametric events e\u03b8 where e is a base event in \u03b5 and \u03b8 is a partial function [XV]. A parametric trace is a trace with events in \u03b5X, also referred to as a word in \u03b5X*.","In the discussions herein, the parameter values set V is implicit to simplify writing. For example, a parametric trace can be: Begin\u22a5 Acquire\u03b8 Acquire\u03b8 Acquire\u03b8 Release\u03b8 End\u22a5 Begin\u22a5 Acquire\u03b8 Release\u03b8 End\u22a5, where \u03b8maps r to rand \u03b8maps r to r. Additionally, in the discussions herein just the parameter values are listed when writing parameter instance, such as r instead of rr, \u03c4rinstead of \u03c4rr, and so forth. Using this notation, the previous example parametric trace can be written as: Begin Acquirer Acquirer Acquirer Releaser End Begin Acquirer Releaser End. This example parametric trace thus involves two resources (rand r), and includes two trace slices (one for each of the two resources). The Begin and End events in the parametric trace belong to both trace slices. The trace slice corresponding to \u03b8is: Begin Acquire Acquire Release End Begin End. The trace slice corresponding to \u03b8is: Begin Acquire End Begin Acquire Release End.","Partial functions \u03b8 in [XV] are referred to as parameter instances. The \u03b8 and \u03b8\u2032\u2208[AB] are referred to as being compatible if for any x\u2208Dom(\u03b8)\u2229Dom(\u03b8\u2032) where \u03b8(x)=\u03b8\u2032(x). Compatible instances \u03b8 and \u03b8\u2032 can be combined, written as \u03b8\u2423\u03b8\u2032, as follows:",{"@attributes":{"id":"p-0035","num":"0034"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mi":"\u03b8","mo":["\u2062","\u2062"],"msup":{"mi":["\u03b8","\u2032"]}}},{"mo":["(",")"],"mi":"x"}],"mo":"\u2062"},{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"\u03b8","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}},{"mi":"\u03b8","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["when","is","defined"]}}},{"mtd":{"mrow":{"mrow":[{"msup":{"mi":["\u03b8","\u2032"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}},{"msup":{"mi":["\u03b8","\u2032"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["when","is","defined"]}}},{"mtd":{"mrow":{"mi":["undefined","otherwise"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}]}}],"mo":"="}}}},"The \u03b8\u03b8\u2032 is also referred to as the least upper bound (lub) of \u03b8 and \u03b8\u2032. The \u03b8\u2032 is less informative than \u03b8, or \u03b8 is more informative than \u03b8\u2032, also written as \u03b8\u2032\u03b8 if and only if for any x\u2208X, if \u03b8\u2032(x) is defined then \u03b8(x) is also defined and \u03b8\u2032(x)=\u03b8(x). For example,  is compatible with r and with r, but r and r are not compatible. Additionally, r and r.","Given a parametric trace \u03c4\u2208\u03b5X* and \u03b8 in [XV], then the \u03b8-trace slice \u03c4\u03b8\u2208\u03b5* is the non-parametric trace defined as:","\u03b5=\u03b5, where \u03b5 is the empty trace\/word, and","(\u03c4e\u03b8)\u03b8=(\u03c4\u03b8)e when \u03b8\u2032\u03b8, and","(\u03c4e\u03b8)\u03b8=\u03c4\u03b8 when \u03b8\u2032\u03b8.","The trace slice \u03c4\u03b8 first filters out the parametric events that are not relevant for the instance \u03b8. The parametric events that are not relevant for the instance \u03b8 are the parametric events that contain instances of parameters that \u03b8 does not care about (e.g., instances of parameters not included in \u03b8). For the remaining events relevant to \u03b8, the trace slice \u03c4\u03b8 forgets or drops the parameters so that the trace can be checked against base, non-parametric properties. It should be noted obtaining such trace slices is different from extracting traces from executions and abstracting traces from executions. Extracting traces refers to determining the events to include in the trace, as well as parameter instances carried by events. Abstracting traces refers to dispatching each event in the given trace to corresponding trace slices according to the event's parameter instance.","A set of parameters together with their corresponding parameter values V is referred to as X, and P:\u03b5*\u2192C refers to a non-parametric property as discussed above. The parametric property \u039bX\u00b7P is defined as the property (over traces \u03b5X* and categories [[XV]\u2192C]):","\u039bX\u00b7P:\u03b5X*\u2192[[X]\u2192C]","which is referred to as (\u039bX\u00b7P)(\u03c4)(\u03b8)=P(\u03c4\u03b8) for any \u03c4\u2208\u03b5X* and any \u03b8\u2208[XV]. If X={x, . . . , x}, then (\u039b{x, . . . , x}\u00b7P) can be written as \u039bx, . . . , x\u00b7P. Additionally, P, refers to a pattern or formula \u03c6 in some particular trace specification formalism, then \u039bX\u00b7P is written as \u039bX\u00b7\u03c6.","Parametric properties \u039bX\u00b7P over base properties P:\u03b5*\u2192C are thus properties taking traces in \u03b5X* to categories [[XV]\u2192C], in other words to function domains from parameter instances to base property categories. \u039bX\u00b7P is defined as if many instances of P are observed at the same time on the parametric trace, one property instance for each parameter instance, and each property instance concerned with its events only (dropping the unrelated events).","Generally, to slice parametric traces, a parametric slicing process is used that takes a parametric execution trace incrementally and builds a partial function of finite domain as a lookup table for all slices of the parametric trace. The parameter instances are the index used to lookup slices in the lookup table. The various parametric trace slices in the parametric trace are identified in this lookup table. A trace slice is computed for all combinations of parameter instances observed in parametric trace events in the trace. In order to obtain a particular slice for a particular set of functions instantiating a particular set of parameter values, a most informative set of parameter instances is calculated. This most informative set of parameter instances refers to all the parameter instances used in the particular slice. The lookup table is then accessed to identify the parametric trace slice identified by the most informative set of parameters. Thus, the parametric trace can be processed or traversed one time as the lookup table is being generated. Appropriate data structures are maintained as the lookup table so that parametric trace slices can be subsequently retrieved for any parameter instance without processing or traversing the parametric trace again.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","200","106","200","200"]},"In process , a program trace is obtained (act ). The program trace can be obtained from a variety of different sources in a variety of different conventional manners. The program trace can be a trace of a previously run program, or alternatively an on-going trace of a program currently running","The trace is traversed from the first event in the trace to the last event in the trace (act ). Each event in the trace is analyzed as the trace is traversed. Alternatively, the program trace can be traversed in different orders other than from the first event to the last event.","The first event in the trace is identified during the traversal (act ). This first event can be a parametric event or a non-parametric event.","Based on the parameter instances in the identified event, each trace slice of which the identified event is a part is identified (act ). An event is part of a trace slice if the parameter instance of the event is less informative than () the parameter instance of the trace slice. If the event includes no parameter instances, then the event is a part of all trace slices. A record of each different trace slice identified in the trace is maintained. These different trace slices correspond to different possible combinations of parameter instances observed while traversing the trace. A record of each possible trace slice resulting from each possible combination of parameter instances observed in the trace can be maintained regardless of whether the particular combination of parameter instances is actually observed in the trace. Alternatively, a record of each possible trace slice resulting from the combinations of parameter instances actually observed in the trace can be maintained.","The identified event is added to the end of the trace slice record for each trace slice of which the identified event is a part (act ). For each trace slice identified in act , the identified event is added to the end of the record of that trace slice. It should be noted that the identified event can be added with or without its parameter instances.","A check is then made as to whether the identified event is the last event in the trace (act ). If the identified event is the last event in the trace, then process  is finished for the obtained trace (act ).","However, if the identified event is not the last event in the trace, then the next event in the trace is identified during the traversal (act ). Process  then returns to act  to identify, based on the parameter instances in the identified event, each trace slice of which the identified event is a part.","Process  illustrates an example process for parametric trace slicing. Example pseudo code for an algorithm performing parametric trace slicing is included in Table I below. The algorithm AX in Table I takes a parametric trace \u03c4\u2208\u03b5X* incrementally and builds a partial function T\u2208[[XV]\u2192\u03b5*] of finite domain as a quick lookup table for all slices of \u03c4. Given sets of partial functions \u0398, \u0398\u2032[XV], \u2423\u0398 is the least informative partial function \u03b8\u2208[XV] such that for any \u03b8\u2032\u2208\u0398, \u03b8\u2032\u03b8; max \u0398 is the most informative \u03b8\u2208\u0398; \u0398\u0398\u2032={\u03b8\u03b8\u2032|\u03b8\u2208\u0398, \u03b8\u2032\u2208\u0398\u2032 such that \u03b8\u2423\u03b8\u2032 exists} and (\u03b8]={\u03b8\u2032|\u03b8\u2032\u2208\u0398 and \u03b8\u2032\u03b8}. It should be noted that \u2423\u0398 and max \u0398 may not exist. The algorithm AX in Table I takes an input of a parametric trace \u03c4\u2208\u03b5X* , and outputs a map or lookup table T\u2208[[XV]\u2192\u03b5*] and a set \u0398\u2282[XV].",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","T \u2190\u22a5 ; T(\u22a5) \u2190 \u03b5; \u0398 \u2190 {\u22a5}"]},{"entry":["2","for each e  \u03b8 \u2009in order in \u03c4 do"]},{"entry":["3",": for each \u03b8\u2032\u2208 {\u03b8} \u2423 \u0398 do"]},{"entry":["4",": : T (\u03b8\u2032) \u2190 T(max(\u03b8\u2032])e"]},{"entry":["5",": end for"]},{"entry":["6",": \u0398 \u2190 {\u22a5,\u03b8}\u2009 \u2009\u0398"]},{"entry":["7","end for"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The algorithm AX in Table I operates on input \u03c4, also written as AX(\u03c4), traverses \u03c4 from its first event to its last event and, for each encountered event e\u03b8, updates both its data structures T and \u0398. After processing each event, the relationship between T and \u0398 is that \u0398 is a domain of T.","In the algorithm AX in Table I, at line 1 the data structures T and \u0398 are initialized. T is undefined everywhere (\u22a5) except for the undefined everywhere function \u22a5, where T(\u22a5)=\u03b5. \u0398 is initialized to the set {\u22a5}. The code at lines 3 to 6, inside the outer loop (at lines 2 to 7) is triggered when a new event is received. When a new event e\u03b8 is received, T is updated as follows. For each \u03b8\u2032[XV] that can be obtained by combining \u03b8 with the compatible partial functions in the domain of the current T, update T(\u03b8\u2032) by adding the non-parametric event e to the end of the slice corresponding to the largest (the most knowledgeable) entry in the current table T that is less informative or as informative as \u03b8\u2032. Then, at line 6, \u0398 is extended.","As an example, consider a sample parametric trace with parametric events in {a, b, c}. The sample parametric trace \u03c4=ea ea eb eab ea e eb. The following example records illustrate how the algorithm AX works on the sample parametric trace \u03c4. An entry of the form \u03b8:w in a record corresponding to a current parametric event e\u03b8 means that T(\u03b8)=w after processing all the parametric events up to and including the current parametric event; T is undefined on any other partial function. The \u0398 corresponding to a record is the union of all the \u03b8's that appear in pairs \u03b8:w in that record. It should be noted that as each parametric event e\u03b8 is processed, the non-parametric event e is added at most once to the record of each slice. Tables II-VIII below illustrate the contents of each record for a trace slice after the event identified in each table has been analyzed during traversal of the sample trace.",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"e a "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00170","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00013.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00171","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00014.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00172","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00013.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00173","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00014.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1"]}]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"e a "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00176","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00015.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00177","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00016.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00178","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00015.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00179","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00016.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00180","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00015.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00181","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00016.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","2"]}]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE IV"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"e b "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00184","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00017.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00185","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00018.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00186","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00017.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00187","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00018.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00188","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00017.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00189","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00018.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","2"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00190","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00017.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00191","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00018.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","3"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00192","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00017.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00193","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00018.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1","1","3"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00194","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00017.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00195","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00018.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","1","2","3"]}]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE V"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"e ab "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00198","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00019.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00199","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00020.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00200","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00019.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00201","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00020.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00202","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00019.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00203","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00020.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","2"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00204","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00019.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00205","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00020.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","3"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00206","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00019.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00207","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00020.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1","1","3"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00208","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00019.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00209","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00020.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","1","2","3","4"]}]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE VI"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"e a "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00212","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00021.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00213","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00022.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00214","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00021.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00215","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00022.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1","5"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00216","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00021.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00217","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00022.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","2"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00218","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00021.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00219","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00022.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","3"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00220","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00021.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00221","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00022.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1","1","3","5"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00222","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00021.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00223","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00022.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","1","2","3","4"]}]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE VII"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"e\u2009 \u2009 "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00226","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00023.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00227","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00024.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":"6"}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00228","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00023.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00229","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00024.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1","5","6"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00230","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00023.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00231","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00024.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","2","6"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00232","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00023.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00233","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00024.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","3","6"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00234","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00023.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00235","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00024.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1","1","3","5","6"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00236","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00023.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00237","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00024.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","1","2","3","4","6"]}]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE VIII"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"e\u2009 \u2009b\u2009 "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00240","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00025.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00241","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00026.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":"6"}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00242","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00025.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00243","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00026.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1","5","6"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00244","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00025.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00245","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00026.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","2","6"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00246","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00025.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00247","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00026.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","3","6","7"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00248","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00025.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00249","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00026.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["1","1","1","3","5","6","7"]}]},{"entry":[{},{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00250","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00025.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00251","he":"2.79mm","wi":"0.68mm","file":"US08719796-20140506-P00026.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["2","1","\u2009","2","3","4","6","7"]}]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Trace slice monitoring refers to analyzing the parametric trace slices to verify parametric properties in the execution trace. This monitoring can be used, for example, to assist in the identification of errors or problems in the underlying program (the program whose execution results in the execution trace). Monitoring of the parametric trace slices is performed by a monitoring module, such as module  of . The monitoring of the parametric trace slices can be performed as the underlying program is running, or alternatively after the underlying program has run.","For parametric trace slice monitoring, a set of monitors M and a set of parametric monitors \u039bX\u00b7M are defined. Parametric monitors refer to monitors for parametric events and have parameter instance-indexed states and output categories. A parametric monitor \u039bX\u00b7M is a monitor for the property \u039bX\u00b7P, with P being the property monitored by M.","A monitor M is a tuple (S, \u03b5, C, \u03b9, \u03c3:S\u00d7\u03b5\u2192S, \u03b3:S\u2192C), where S refers to a set of states, \u03b5 refers to a set of input events, C refers to a set of output categories, \u03b9\u2208S is the initial state, \u03c3 is the transition function, and \u03b3 is the output function. The transition function is extended to \u03c3:S\u00d7\u03b5*\u2192S in the standard way: \u03c3(s,\u03b5)=s and \u03c3(s,we)=\u03c3(\u03c3(s,w),e) for any s\u2208S, e\u2208\u03b5, and w\u2208\u03b5*. It should be noted, however, that implementations of monitors need not generate all the state space ahead of time, but rather can generate the state space as needed. It should also be noted that, although a finite number of states is reached during any given (finite) execution trace, in general there is no bound on the number of states.","A monitor M=(S, \u03b5, C, \u03b9, \u03c3, \u03b3) is a monitor for property P:\u03b5*\u2192C if and only if \u03b3(\u03c3(\u03b9,w))=P(w) for each w\u2208\u03b5*. Each monitor M defines the property P:\u03b5*\u2192C with P(w)=\u03b3(\u03c3(\u03b9,w)). Each such monitor M is referred to as a monitor for P. Two monitors M and M\u2032 are equivalent, referred to as M\u2261M\u2032 and only if P=P.","Given parameters X with corresponding values V, and monitor M=(S, \u03b5, C, \u03b9, \u03c3:S\u00d7\u03b5\u2192S, \u03b3:S\u2192C), the parametric monitor \u039bX\u00b7M is the monitor","([[XV]\u2192S], \u03b5X,[[XV]\u2192C], \u03bb\u03b8\u00b7\u03b9,\u039bX\u00b7\u03c3,\u039bX\u00b7\u03b3)","with \u039bX\u00b7\u03c3: [[XV]\u2192S]\u00d7\u03b5X\u2192[[XV]\u2192S]","and \u039bX\u00b7\u03b3:[[XV]\u2192S]\u2192[[XV]\u2192C] defined as, for any \u03b4\u2208[[XV]\u2192S] and any \u03b8, \u03b8\u2032\u2208[XV], the following:","(\u039bX\u00b7\u03c3)(\u03b4e\u03b8\u2032)(\u03b8)=\u03c3(\u03b4(\u03b8),e) if \u03b8\u2032\u03b8, and","(\u039bX\u00b7\u03c3)(\u03b4, e\u03b8\u2032)(\u03b8)=\u03b4(\u03b8) if \u03b8\u2032\u03b8, and","(\u039bX\u00b7\u03b3)(\u03b4) (\u03b8)=\u03b3(\u03b4(\u03b8)).","In other words, a state \u03b4 of parametric monitor \u039bX\u00b7M maintains a state \u03b4(\u03b8) of M for each parameter instance \u03b8, takes parametric events as input, and outputs categories indexed by parameter instances (one output category of M per parameter instance).","Generally, to monitor parametric trace slices, a monitoring process is used that takes parametric trace slices and builds records of states of monitor instances, and also builds records indicating violation or validation of a property. Similar to the parametric slicing process discussed above, the parametric trace slices can be processed or traversed one time as the records are generated.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 3","FIG. 1"],"b":["300","300","300","108","300","300"]},"In process , a program trace is obtained (act ). The program trace can be obtained from a variety of different sources in a variety of different conventional manners. The program trace can be a trace of a previously run program, or alternatively an on-going trace of a program currently running Additionally, the program trace can be a parametric trace slice (e.g., generated by slicing module  of ) rather than an entire program trace (in which case the parameter instance of every event will be _|_).","The trace is traversed from the first event in the trace to the last event in the trace (act ). Each event in the trace is analyzed as the trace is traversed. Alternatively, the trace can be traversed in different orders other than from the first event to the last event.","The first event in the trace is identified during the traversal (act ). This first event can be a parametric event or a non-parametric event.","Based on the parameter instances in the identified event, the monitor instance corresponding to the identified event is identified (act ). An event is part of a trace slice if the parameter instance of the event is less informative than () the parameter instance of the trace slice. A record of each different monitor instance identified in the trace is maintained. These different monitor instances correspond to different possible combinations of parameter instances observed while traversing the trace. A record of each possible monitor instance resulting from each possible combination of parameter instances observed in the trace can be maintained regardless of whether the particular combination of parameter instances is actually observed in the trace. Alternatively, a record of each possible monitor instance resulting from the combinations of parameter instances actually observed in the trace can be maintained.","The identified event is added to the monitor instance record for each monitor instance corresponding to the identified event (act ). For each monitor instance identified in act , the identified event is added to the record of that monitor instance. The identified event can be added to the end of the record, or alternatively elsewhere in the record. It should be noted that the identified event can be added with or without its parameter instances.","An output corresponding to the identified monitor instance is also determined (act ). The output corresponding to the identified monitor instance, based on the events added to the identified monitor instance thus far, is calculated. This output comprises determining, for example, whether the trace slice corresponding to that monitor instance is validating, violating, or don't know. In other words, whether the trace slice corresponding to that monitor instance complies with the appropriate constraints. This determination is made, for example, based on a regular expression of a trace as discussed above. For example, if a regular expression indicates that an Acquire event is to precede a Release event, then it can be determined that the output corresponding to the identified monitor instance is validating if an Acquire event precedes the Release event in a trace slice (and any other regular expressions for the trace slice are satisfied), but violating if an Acquire event does not precede the Release event.","An indication of the determined output is added to a record corresponding to the identified monitor instance (act ). For example, an indication of validating, violating, or don't know can be added to the record. Alternatively, indications of validating or violating may be added to the record, but indications of don't know are not added.","A check is then made as to whether the identified event is the last event in the trace (act ). If the identified event is the last event in the trace, then process  is finished for the obtained trace (act ).","However, if the identified event is not the last event in the trace, then the next event in the trace is identified during the traversal (act ). Process  then returns to act  to identify, based on the parameter instances in the identified event, the monitor instance corresponding to the identified event.","Process  illustrates an example process for parametric trace slice monitoring. Example pseudo code for an algorithm performing parametric trace slice monitoring is included in Table IX below. The algorithm BX in Table IX encodes functions [[XV]S] as tables with entries indexed by parameters instances in [XV] and with content states in S. The algorithm BX in Table IX uses a data structure \u0394 that is a record of monitor instance states, and a data structure \u0393 that is a record of indications of whether the output corresponding to the monitor instance violates or validates the property (e.g., whether one or more regular expressions for the trace or trace slice is satisfied). In the algorithm BX in Table IX, \u0394 is mapped to [[XV]S], and \u0393 is mapped to [[XV]C].",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE IX"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","\u0394 \u2190\u22a5; \u0394(\u22a5) \u2190 \u03b9; \u0398 \u2190 {\u22a5}"]},{"entry":["2","for each e\u2009 \u2009\u03b8\u2009 \u2009in order in \u03c4 do"]},{"entry":["3",": for each \u03b8\u2032 \u2208 {\u03b8}\u2423\u0398 do"]},{"entry":["4",": : \u0394 (\u03b8\u2032) \u2190 \u03c3(\u0394(max(\u03b8\u2032]),e)"]},{"entry":["5",": : \u0393 (\u03b8\u2032) \u2190 \u03b3(\u0394(\u03b8\u2032))"]},{"entry":["6",": end for"]},{"entry":["7",": \u0398 \u2190 {\u22a5,\u03b8}\u2009 \u2009\u0398"]},{"entry":["8","end for"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The algorithm BX in Table IX is similar to the algorithm AX for which pseudo code is included in Table I discussed above. The algorithm BX in Table IX operates on input \u03b9, traverses \u03b9 from its first event to its last event and, for each encountered event e\u03b8, updates both its data structures \u0394, \u0393, and \u0398.","In the algorithm BX in Table IX, at line 1 the data structure \u0394 is initialized as undefined everywhere (\u22a5) except for the undefined everywhere function \u22a5, \u0394(\u22a5) is initialized to \u03b9, and \u0398 is initialed to the set {\u22a5}. The code at lines 3 to 7, inside the outer loop (at lines 2 to 8) is triggered when a new event is received. When a new event e\u03b8 is received, at line 4 the state of the monitor instance corresponding to \u03b8\u2032 is calculated and stored in the record \u0394 corresponding to \u03b8\u2032 by sending e to the corresponding monitor instance. Additionally, at line 5 a determination is made whether the output corresponding to the monitor instance violates or validates the property, and an indication of the determination is stored in the data structure \u0393. Then, at line 7, \u0398 is extended.","In the implementation of algorithm BX in Table IX, a search is made (at line 3) for all parameter instances in \u0398 that are compatible with \u03b8. Alternatively, an auxiliary data structure can be used to reduce the amount searching that is performed, so that a search for all parameter instances in \u0398 that are compatible with \u03b8 need not be performed. The auxiliary data structure maps each parameter instance \u03b8 into the finite set of parameter instances encountered in \u0394 thus far that are more informative than \u03b8. For example, the auxiliary data structure can be referred to as U, and is defined as U(\u03b8)={\u03b8\u2032|\u03b8\u2032\u2208 Dom(\u0394) and \u03b8\u03b8\u2032}. Accordingly, the amount of searching that is performed is reduced as only the parameter instances encountered thus far that are more informative than the current parameter instance need be considered.","Example pseudo code for another algorithm performing parametric trace slice monitoring is included in Table X below. The algorithm CX in Table X is similar to the algorithm BX in Table IX, except that the search at line 3 of algorithm BX in Table IX is replaced so that a reduced amount of searching is performed. The algorithm CX in Table X uses the auxiliary data structure U discussed above.",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE X"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Initialize U(0) \u2190 { } for any \u03b8 \u2208 [X  \u2009V]"]},{"entry":[{},"Initialize \u0394(\u22a5) \u2190 \u03b9"]},{"entry":[{},"function main (e\u2009 \u2009\u03b8\u2009 \u2009)"]},{"entry":["1","if \u0394(\u03b8) undefined then"]},{"entry":["2",": for each \u03b8\u2009 \u2009\u03b8\u2009 (in reversed topological order (larger to smaller)) do"]},{"entry":["3",": : if \u0394(\u03b8) defined then"]},{"entry":["4",": : : go to line 7"]},{"entry":["5",": : end if"]},{"entry":["6",": end for"]},{"entry":["7",": defineTo (\u03b8,\u03b8)"]},{"entry":["8",": for each \u03b8\u2009 \u2009\u03b8\u2009 (in reversed topological order (larger to smaller)) do"]},{"entry":["9",": : for each \u03b8\u2208 U(\u03b8) compatible with \u03b8 do"]},{"entry":["10",": : : if \u0394(\u03b8\u2009 \u2009\u03b8) undefined then"]},{"entry":["11",": : : : defineTo(\u03b8\u2423\u03b8,\u03b8)"]},{"entry":["12",": : : end if"]},{"entry":["13",": : end for"]},{"entry":["14",": end for"]},{"entry":["15","end if"]},{"entry":["16","for each \u03b8\u2032\u2208 {\u03b8} \u222a U(\u03b8) do"]},{"entry":["17",": \u0394 (\u03b8\u2032) \u2190 \u03c3(\u0394(\u03b8\u2032), e)"]},{"entry":["18",": \u0393 (\u03b8\u2032) \u2190 \u03b3(\u0394(\u03b8\u2032))"]},{"entry":["19","end for"]},{"entry":[{},"function defineTo(\u03b8,\u03b8\u2032)"]},{"entry":["1","\u0394(\u03b8) \u2190 \u0394(\u03b8\u2032)"]},{"entry":["2","for each \u03b8\u2033\u2009 \u2009\u03b8\u2009 do"]},{"entry":["3",": U(\u03b8\u2033) \u2190 U(\u03b8\u2033) \u222a { \u03b8 }"]},{"entry":["4","end for"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The algorithm CX in Table X using mappings for \u0394 and \u0393 as discussed above with reference to algorithm BX in Table IX, and in addition U is mapped to [XV]\u2192P([[XV]]), where P(S) is the finite power set of set S. The algorithm CX in Table X is composed of two functions: \u201cmain\u201d and \u201cdefineTo\u201d. The \u201cdefineTo\u201d function takes two parameter instances, \u03b8 and \u03b8\u2032, and adds a new entry corresponding to \u03b8 into \u0394 and U. More specifically, the \u201cdefineTo\u201d function sets \u0394(\u03b8) to \u0394(\u03b8\u2032) and adds \u03b8 into the set U(\u03b8\u2033) for each \u03b8\u2033\u03b8\u2032.","The \u201cmain\u201d function differentiates two cases when a new event ee is received and processed. The first case is that \u0394 is already defined on \u03b8, in other words \u03b8\u2208\u0398 at the beginning of the outer loop (lines 2-8) of the algorithm BX in Table IX. In this first case, {\u03b8}\u2423\u0398={\u03b8\u2032|\u03b8\u2032\u2208\u0398 and \u03b8\u03b8\u2032}\u0398, so lines 3 to 6 of the algorithm BX in Table IX become the lines 16 to 19 of the algorithm CX in Table X.","In the second case of the \u201cmain\u201d function, when \u0394 is not already defined on \u03b8, two steps are taken to process e. The first step searches for new parameter instances introduced by {\u03b8}\u2423\u0398 and adds entries for these new parameter instances into \u0394 (at lines 2 to 15). More specifically, at lines 2 to 7 an entry is added to \u0394 for \u03b8. A search for all parameter instances \u03b8that are compatible with \u03b8, making use of U (at lines 8 and 9), and for each such \u03b8an appropriate entry is added to \u0394 for its least upper bound with \u03b8, and U is updated accordingly (at lines 10 to 12). Thus, \u0394 is defined on the new parameter instances introduced by {\u03b8}\u0398 after the first step. In the second step, the related monitor states and outputs are updated in a similar way as in the first case (at lines 16 to 19).","Example pseudo code for another algorithm performing parametric trace slice monitoring is included in Table XI below, and is referred to as algorithm CX. Algorithm CX in Table XI is similar to algorithm CX in Table X, but extends algorithm CX in Table X to include creation events. Creation events refer to events that lead to creation of new monitor states. The algorithm CX in Table X can be viewed as a special case of the algorithm CX in Table XI in which all events are creation events. The creation events typically occur as a result of a request (e.g., a user request or a request from another component or module) to begin monitoring\u2014each new event encountered after the request to begin monitoring is a creation event. The algorithm CX in Table XI uses the data structure \u0394 that is a record of monitor instance states, the data structure \u0393 that is a record of indications of whether the output corresponding to the monitor instance violates or validates the property, and the auxiliary data structure U discussed above.","The algorithm CX in Table XI includes an additional function \u201cdefineNew\u201d that takes a parameter instance \u03b8 and adds a new entry corresponding to \u03b8 into \u0394 and U.",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XI"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Initialize U(0) \u2190 { } for any \u03b8 \u2208 [X\u2009 \u2009V]"]},{"entry":[{},"function main (e\u2009 \u2009\u03b8\u2009 \u2009)"]},{"entry":["1","if \u0394(\u03b8) undefined then"]},{"entry":["2",": for each \u03b8\u2009 \u2009\u03b8 (in reversed topological order (larger to smaller)) do"]},{"entry":["3",": : if \u0394(\u03b8) defined then"]},{"entry":["4",": : : go to line 7"]},{"entry":["5",": : end if"]},{"entry":["6",": end for"]},{"entry":["7",": if \u0394(\u03b8) defined then defineTo (\u03b8,\u03b8)"]},{"entry":["8",": else if e is a creation event then defineNew(\u03b8)"]},{"entry":["9","end if"]},{"entry":["10",": for each \u03b8\u2009 \u2009\u03b8 (in reversed topological order (larger to smaller)) do"]},{"entry":["11",": : for each \u03b8\u2208 U(\u03b8) compatible with \u03b8 do"]},{"entry":["12",": : : if \u0394(\u03b8\u2009 \u2009\u03b8) undefined then"]},{"entry":["13",": : : : defineTo(\u03b8\u2423\u03b8,\u03b8)"]},{"entry":["14",": : : end if"]},{"entry":["15",": : end for"]},{"entry":["16",": end for"]},{"entry":["17","end if"]},{"entry":["18","for each \u03b8\u2032\u2208 {\u03b8} \u222a U(\u03b8) do"]},{"entry":["19",": \u0394 (\u03b8\u2032) \u2190 \u03c3(\u0394(\u03b8\u2032), e)"]},{"entry":["20",": \u0393 (\u03b8\u2032) \u2190 \u03b3(\u0394(\u03b8\u2032))"]},{"entry":["21","end for"]},{"entry":[{},"function defineTo(\u03b8,\u03b8\u2032)"]},{"entry":["1","\u0394(\u03b8) \u2190 \u0394(\u03b8\u2032)"]},{"entry":["2","for each \u03b8\u2033\u2009 \u2009\u03b8\u2009 do"]},{"entry":["3",": U(\u03b8\u2033) \u2190 U(\u03b8\u2033) \u222a {\u03b8}"]},{"entry":["4","end for"]},{"entry":[{},"function defineNew(\u03b8)"]},{"entry":["1","\u0394(\u03b8) \u2190 \u03b9"]},{"entry":["2","for each \u03b8\u2033\u2009 \u2009\u03b8\u2009 do"]},{"entry":["3",": U(\u03b8\u2033) \u2190 U(\u03b8\u2033) \u222a {\u03b8}"]},{"entry":["4","end for"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Parametric trace slice mining refers to generating specifications for the underlying program based on the parametric trace slices obtained from an execution trace. The specifications identify various aspects regarding the manner in which the underlying program, such as API patterns, usage scenarios, and so forth. In addition to generating the specifications, regular expressions equivalent to the specifications can also be generated.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 4","FIG. 1"],"b":["400","400","400","110","400","400"]},"In process , trace slices are obtained (act ). These trace slices are parametric trace slices as discussed above. It should be noted that although these trace slices are referred to as parametric trace slices, in one or more embodiments they do not include parameters. As discussed above, events are added to trace slices during the parametric trace slicing process, but these different slices correspond to particular combinations of parameters. Thus, the parameters for these events need not recorded in the different slices as the events are associated with particular combinations of parameters by virtue of their being included in a particular trace slice.","Deterministic finite automata are produced based on the obtained trace slices (act ). A deterministic finite automaton (DFA) is a finite state machine in which for each pair of state and input, there is a single transition to a next state. These deterministic finite automata are generated using a probabilistic finite state automata (PFSA) learner.","Refined deterministic automata are produced based on the use trace slices (act ). Generally, the refined deterministic finite automata refines the deterministic finite automata produced in act  by expanding the deterministic finite automata produced in act  to split each state according to its incoming edges (e.g., one state per incoming edge). The expanded deterministic finite automata is then traversed using the obtained trace slices and edges in the expanded deterministic finite automata that are not used in any of the obtained trace slices are removed. The resulting deterministic finite automata is compressed by merging states having the same outgoing transitions and removing those states have no incoming transitions to produce the refined deterministic finite automata.","Equivalent regular patterns are generated from the refined deterministic finite automata (act ). These regular patterns are generated using a regular pattern generator that generates equivalent regular patterns from finite state machines.","The regular patterns generated in act  and the refined deterministic finite automata produced in act  are output (act ). One or more deterministic finite automata are generated for each trace slice obtained in act  and output in act  as the specification for the trace slice. Alternatively, both the regular patterns and refined deterministic finite automata are not output in act  (e.g., only one of the regular patterns and refined deterministic finite automata may be output).","The following describes an example implementation of parametric trace slice mining. The trace slices are input to a probabilistic finite state automata learner, the output automata are input to an automata refiner. The automata refiner refines the automata, generating the finite state machines that are the specifications for the trace slices. These finite state machines are also input to a regular pattern generator, which generates equivalent regular patterns from the finite state machines.","The probabilistic finite state automata learner infers a finite state machine (automaton) from a set of strings, which are the trace slices discussed above. The inferred state machine accepts at least the input trace slices and may allow more as oftentimes the probabilistic finite state automata learner generalizes during its learning process. A variety of different well-known probabilistic finite state automata learners can be used with the parametric trace slice mining discussed herein. In one or more embodiments, the probabilistic finite state automata learner is the well-known sk-string algorithm. Additional information regarding the sk-string algorithm can be found in, for example, \u201cThe sk-strings method for inferring pfsa\u201d, by A. V. Raman and J. D. Patrick, International Conference on Machine Learning (ICML) '97 (1997).","Generally, the sk-string PFSA learner first constructs a prefix tree, which is essentially a finite state automaton that accepts precisely the input set of strings. Each arc of the prefix tree is labeled with a frequency that represents how many times the arc was traversed during the creation of the tree. The sk-string algorithm is then used to merge states in the prefix tree to build a more compact and more general nondeterministic finite automaton.","State merging is based on a concept referred to as \u201csk-equivalence\u201d. In sk-equivalence, \u03a3 refers to the set of words used in the strings, Q refers to the set of states in the prefix tree, \u03b4: Q\u00d7\u03a3*\u21922refers to the transition function, and Frefers to the set of final states. The set of k-strings of state q is then defined as the set {z|z\u2208\u03a3*,|z|=k\u03b4(q,z)\u2282Q|z|<k\u03b4(q,z \u2229F\u2260{ })}. Each k-string has a probability associated with it that is the product of the probabilities of the arcs traversed in generating the string. Two states are considered mergeable if the sets consisting of the top s percent of their distribution of k-string are the same (that is, sk-equivalence). This is computed as follows: the k-strings of a state are arranged in decreasing order of their probabilities. The top n strings, whose probabilities add up to s percent or more with n being as small as possible, are retained and the remaining strings (those having lower probabilities) are ignored. Two states are sk-equivalent if the sets of the top n strings of both are the same. The process of merging states is repeated until no more states are sk-equivalent. This way, the algorithm infers a nondeterministic finite automaton accepting a superset of the input strings. This nondeterministic finite automaton is then converted into a deterministic finite automaton.","Thus, the probabilistic finite state automata learner outputs deterministic finite automata, each automaton having nodes that represent the involved components and edges are labeled with events.","The deterministic finite automata output by the probabilistic finite state automata learner can be over-generalized. To compensate for such over-generalization, the automata refiner refines the deterministic finite automata output by the probabilistic finite state automata learner using the trace slices.","Example pseudo code for an algorithm performing parametric trace slice mining is included in Table XII below, and is referred to as algorithm R. An automaton refers to a tuple (S, \u03b5, i, \u03b4, F), where S refers to a set of states, \u03b5 refers to a set of events, i\u2208S is the initial state, \u03b4:[S\u00d7\u03b5S] is the transition function, and FS is the set of final states. Algorithm R includes a function \u201cmain\u201d and a function \u201cexpand\u201d. The \u201cmain\u201d function of algorithm R takes as an input an automaton A=(S, \u03b5, i, \u03b4:[S\u00d7\u03b5S], F) and a set of trace slices T\u2282\u03b5*, and outputs an automaton A. The \u201cmain\u201d function of algorithm R uses local values of automaton A\u2032=(S\u2032, \u03b5, i\u2032, \u03b4\u2032, F\u2032), state s, s\u2032, and transition function \u03b4. The \u201cexpand\u201d function of algorithm R takes as an input an automaton A=(S, \u03b5, i, \u03b4, F) and outputs an automaton A\u2032=(S\u2032, \u03b5, i\u2032, \u03b4\u2032, F\u2032). The \u201cexpand\u201d function of algorithm R is initialized by setting S\u2032 to { }, setting F\u2032 to { }, and setting \u03b4\u2032 to \u22a5. The \u201cexpand\u201d function of algorithm R also use local values of integer n, set of states D, and map \u03b2:S\u21922.",{"@attributes":{"id":"p-0113","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"char"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XII"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Function main ( )"]},{"entry":["1","A\u2032 \u2190 Expand(A)"]},{"entry":["2","\u03b4\u2190 \u22a5"]},{"entry":["3","for each \u03c4 \u2208 T do"]},{"entry":["4",": s \u2190 i\u2032"]},{"entry":["5",": for each e \u2208 \u03c4 do"]},{"entry":["6",": : s\u2032 \u2190 s"]},{"entry":["7",": : s \u2190 \u03b4\u2032(s,e)"]},{"entry":["8",": : \u03b4(s\u2032,e) \u2190 s"]},{"entry":["9",": : if \u03b4=\u03b4\u2032 then"]},{"entry":["10",": : : go to line 14"]},{"entry":["11",": : end if"]},{"entry":["12",": end for"]},{"entry":["13","end for"]},{"entry":["14","A\u2032 \u2190 (S\u2032, \u03b5, i\u2032, \u03b4, F\u2032)"]},{"entry":["15","A\u2190 MergeIdenticalStates(A\u2032)"]},{"entry":[{},"Function Expand"]},{"entry":["1","for each s \u2208 S do"]},{"entry":["2",": n \u2190 CountIncomingEdges(s,A)"]},{"entry":["3",": if s=i then"]},{"entry":["4",": : n \u2190 n+1"]},{"entry":["5",": end if"]},{"entry":["6",": D \u2190 GetFreshStates(n)"]},{"entry":["7",": S\u2032 \u2190 D \u222a S\u2032"]},{"entry":["8",": \u03b2(s) \u2190 D"]},{"entry":["9","end for"]},{"entry":["10","for each s \u2208 S do"]},{"entry":["11",": for each s\u2032\u2260\u2208 S such that \u03b4(s\u2032,e)=s for some e do"]},{"entry":["12",": : s\u2033 \u2190 PickOneWithNoIncomingEdge(\u03b2(s),\u03b4\u2032)"]},{"entry":["13",": : for each s\u2032\u2033 \u2208 \u03b2(s\u2032) do"]},{"entry":["14",": : : \u03b4\u2032(s\u2032\u2033,e)=s\u2033"]},{"entry":["15",": : end for"]},{"entry":["16",": end for"]},{"entry":["17",": if s \u2208 F then"]},{"entry":["18",": : F\u2032 \u2190 F\u2032\u222a \u03b2(s)"]},{"entry":["19",": end if"]},{"entry":["20","if s=I then"]},{"entry":["21",": : i\u2032 \u2190 PickOneWithNoIncomingEdge(\u03b2(s),\u03b4\u2032)"]},{"entry":["22",": end if"]},{"entry":["23","end for"]},{"entry":["24","return A\u2032"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In algorithm R, the input automaton is expanded using the \u201cexpand\u201d function, which splits each state according to its incoming edges. The incoming edges are counted as follows: if \u03b4(s, e)=s\u2032 for some s\u2260s\u2032, then e represents an incoming edge to s\u2032. Additionally, it is assumed that the initial state has a default incoming edge (at lines 3 to 5 in the \u201cexpand\u201d function). If state s has n incoming edges then n new states are generated for the new automaton and the mapping from s to the corresponding set of newly created states is kept in \u03b2 (at lines 6 to 8 in the \u201cexpand\u201d function). The \u201cexpand\u201d function then builds transitions in the new automaton (at lines 10 to 23) as follows. If \u03b4(s\u2032, e)=s is a transition in the input automaton and s\u2260s\u2032 then a state s\u2033 from \u03b2(s) with no incoming edges yet is chosen and transitions are added from every state in \u03b2(s\u2032) to s\u2033. Ifs is a final state then all states in \u03b2(s) are also final; if s is the initial state then a state from \u03b2(s) with no incoming edges is chosen as the new initial state. Thus, the input automaton is expanded to an equivalent automaton in which every state has a set of incoming edges corresponding to one incoming edge in the original automaton.","The algorithm R then traverses the expanded automaton using the input set of trace slices and marks the transitions used in the traversal (at lines 3 to 13 of the \u201cmain\u201d function). After all the traces are applied, the unmarked transitions (which are not traversed in the trace slice) are removed from the expanded automaton to generate a reduced automaton. The reduced automaton is then compressed by merging states that have the same outgoing transitions and removing those states that have no incoming states. At the end, the compressed automaton is associated with parameter information (the combination of parameters associated with the trace slice being analyzed) removed when performing the parametric trace slicing discussed above. The output of the algorithm R is the finite state machines that are the specifications for the trace slices.","The output of the algorithm R can also be input to a regular pattern generator that generates equivalent regular patterns form the finite state machines. A variety of different well-known regular pattern generators can be used with the parametric trace slice mining discussed herein. In one or more embodiments, the regular pattern generator uses the well-known Brzozowski method. Additional information regarding the Brzozowski method can be found in, for example, \u201cDerivatives of regular expressions\u201d, by J. A. Brzozowski, Journal of the Association for Computing Machinery (ACM), 11(4):481-494 (1964).",{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 5","b":["500","500","500"]},"Computing device  includes one or more processor(s) , computer readable media such as system memory  and mass storage device(s) , input\/output (I\/O) device(s) , and bus . Processor(s)  include one or more processors or controllers that execute instructions stored in system memory  and\/or mass storage device(s) . Processor(s)  may also include computer readable media, such as cache memory.","System memory  includes various computer readable media, including volatile memory (such as random access memory (RAM)) and\/or nonvolatile memory (such as read only memory (ROM)). System memory  may include rewritable ROM, such as Flash memory.","Mass storage device(s)  include various computer readable media, such as magnetic disks, optical discs, solid state memory (e.g., Flash memory), and so forth. Various drives may also be included in mass storage device(s)  to enable reading from and\/or writing to the various computer readable media. Mass storage device(s)  include removable media and\/or nonremovable media.","I\/O device(s)  include various devices that allow data and\/or other information to be input to and\/or output from computing device . Examples of I\/O device(s)  include cursor control devices, keypads, microphones, monitors or other displays, speakers, printers, network interface cards, modems, lenses, CCDs or other image capture devices, and so forth.","Bus  allows processor(s) , system , mass storage device(s) , and I\/O device(s)  to communicate with one another. Bus  can be one or more of multiple types of buses, such as a system bus, PCI bus, IEEE 1394 bus, USB bus, and so forth.","Although the description above uses language that is specific to structural features and\/or methodological acts in processes, it is to be understood that the subject matter defined in the appended claims is not limited to the specific features or processes described. Rather, the specific features and processes are disclosed as example forms of implementing the claims. Various modifications, changes, and variations apparent to those skilled in the art may be made in the arrangement, operation, and details of the disclosed embodiments herein."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
