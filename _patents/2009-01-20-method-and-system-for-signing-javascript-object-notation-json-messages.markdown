---
title: Method and system for signing JavaScript object notation (JSON) messages
abstract: A machine-implemented method for signing a JSON message begins by constructing a reference element for each data object in the JSON message. The data object is identified by a reference identifier that includes a pointer to a digest method, and a digest generated by applying the digest method to the data object. Then, a signature information element is constructed for reference elements corresponding to data objects in the message. The signature information element includes a pointer to a signature method, as well as one or more reference elements, or a canonical form of the one or more reference elements. Then, a signature element is constructed that includes the signature information element, and a signature value generated by applying the signature method to the signature information element. The signature enables a sending entity to generate a digest on a JSON message and to secure the digests using a signing key.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08291230&OS=08291230&RS=08291230
owner: International Business Machines Corporation
number: 08291230
owner_city: Armonk
owner_country: US
publication_date: 20090120
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","COPYRIGHT STATEMENT","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"p":["This application is related to Ser. No. 12\/356,305, filed Jan. 12, 2009, titled \u201cMethod and system for encrypting JavaScript Object Notation (JSON) Messages\u201d.","A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction of the patent document as it appears in the Patent & Trademark Office file or records, but it otherwise reserves all copyright rights.","1. Technical Field","This disclosure relates generally to adding integrity to JavaScript Object Notation (JSON) messages to protect these messages over a communication link.","2. Background of the Related Art","Asynchronous JavaScript and XML (collectively referred to as AJAX) are well-known technologies that allow user interaction with Web pages to be decoupled from the Web browser's communications with a Web server. AJAX is built upon dynamic HTML (DHTML) technologies including: JavaScript, a scripting language commonly used in client-side Web applications; the Document Object Model (DOM), a standard object model for representing HTML or XML documents; and Cascading Style Sheets (CSS), a style sheet language used to describe the presentation of HTML documents. In AJAX, client-side JavaScript updates the presentation of a Web page by dynamically modifying a DOM tree and a style sheet. In addition, asynchronous communication, enabled by additional technologies, allows dynamic updates of data without the need to reload the entire Web page. These additional technologies include XMLHttpRequest, an application programming interface (API) that allows client-side JavaScript to make HTTP connections to a remote server and to exchange data, and JavaScript Serialized Object Notation (JSON), a lightweight, text-based, language-independent data-interchange format.","JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262, 3Edition, dated Dec. 1999. It is also described in Request for Comment (RFC) 4627. JSON syntax is a text format defined with a collection of name\/value pairs and an ordered list of values. JSON is very useful for sending structured data over the wire (e.g., the Internet) that is lightweight and easy to parse. It is language-independent but uses conventions that are familiar to C-family programming conventions. Further information about JSON can be found as json.org.","Currently, JSON messages are secured over the wire using mere transport security (such as SSL), which only provides point-to-point message security. The data in the message, however, can still be compromised through malicious altering by an attacker, or accidental altering through transmission errors.","There remains a need to add message integrity to JSON messages.","JSON message integrity is provided using a digital signature scheme. The digital signature scheme implements a JSON signature syntax, together with a set of processing rules for creating and representing digital signatures.","The JSON signature syntax preferably comprises a set of named elements, including a reference element, a signature information element, and a signature element. In one embodiment, a machine-implemented method for signing a JavaScript Object Notation (JSON) message begins by constructing a reference element for each data object in the JSON message to be signed. The data object is identified by a reference identifier. The reference element includes the reference identifier, a pointer (such as a URI) to a digest method, and a digest generated by applying the digest method to the data object or a given function of the data object. Then, a signature information element is constructed for one or more of the reference elements corresponding to the one or more data objects in the message that are being signed. The signature information element includes a pointer to a signature method, as well as one or more reference elements, or a canonical form of the one or more reference elements. Then, a signature element is constructed. The signature element includes the signature information element, a key information element that includes a key value, and a signature value generated by applying the signature method (identified in the signature information element) to the signature information element. The key value is useful to verify the signature value. The signature element is the JSON message signature, and it provides message integrity (through the digest method) and authentication (through the signature method).","According to another aspect, a machine-implemented method is executed at a first processing device, where the first processing device is adapted to exchange data with a second processing device over a communications network using structured data messages. A structured data message comprises a collection of name\/value pairs, and an ordered list of values. A representative type of data message having this syntax is a JSON request message being transmitted from a Web browser on the first processing device to a Web server on the second processing device. According to the method, a digest is generated on all or parts of the request message and the digests are secured using a signing key. In particular, for each data object in the message to be signed, a reference element is constructed, where the reference element includes a reference identifier, a pointer to a digest method, and a digest generated by applying the digest method to the data object or a given function of the data object. A signature element is constructed from the one or more reference elements. In particular, the signature element includes a signature information element associated with the one or more reference elements, together with a signature value generated by applying a signature method to the signature information element. The signature information element includes a pointer to the signature method, and a canonical form of one or more reference elements. The message and the signature element are output to the second processing device from the first processing device.","In one embodiment, the signature element is detached from the message. In particular, the signature is generated over data in the message that is external to the signature element. In another embodiment, the signature element is enveloped within the message. In this case, the signature is generated over data in the message that includes the signature element.","The foregoing has outlined some of the more pertinent features of the invention. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed invention in a different manner or by modifying the invention as will be described.","In a typical scenario, illustrated in , JSON messages are sent from an initial sender  to an ultimate receiver  along a JSON message path comprising zero or more intermediaries . The devices ,  and  are computing entities, such as data processing systems each comprising hardware and software, which entities communicate with one another over a network, such as the publicly-routed Internet  (in this example), an intranet, an extranet, a private network, a wireless link, or any other communications medium or link. As described below, a data processing system typically comprises one or more processors, an operating system, one or more applications and one or more utilities. A given data processing system may be a sender or sending entity, in which case the system is deemed to be on a \u201csender side\u201d of the transmission, or a receiver or receiving entity, in which case the system is deemed to be on a \u201creceiver side.\u201d JSON messages, such as message , may flow in either direction. Typically, the sender  is a Web browser, and the receiver is a Web server , or vice versa. In AJAX, client-side JavaScript updates the presentation of a Web page displayed in the browser  by using the XMLHttpRequest API (or the like) to communicate to server  asynchronously, with the resulting request\/response typically involving the exchange of one or more JSON (or other structured data) messages. In the prior art, the JSON messages are delivered over the wire in the clear, although point-to-point security typically is used (between sender and receiver) using transport layer security mechanisms, such as HTTP over TLS (Transport Layer Security). In a typical scenario, the sending entity is a client machine executing an AJAX-enabled Web browser, and the receiving entity is a server machine executing an AJAX-enabled Web server. By \u201cAJAX-enabled,\u201d a particular device has the capability of creating and processing messages using AJAX technologies. Of course, these are merely representative data processing systems.","By way of additional background, known JSON syntax is built on two structures: a collection of name\/value pairs, and an ordered list of values. The collection of name\/value pairs goes by different nomenclature depending on the language involved, and this structure typically is realized as an object, a record, a struct, a hash table, a keyed list or an associative array. For discussion purposes, the object nomenclature will be used. The ordered list of values also goes by different nomenclature depending on the language involved, and this structure typically is realized as an array, a vector, a list or a sequence. For discussion purposes, the array nomenclature will be used.","An object is an unordered set of name\/value pairs. An object begins with \u201c{\u201d (left brace) and ends with \u201c}\u201d (right brace). Each name is followed by \u201c:\u201d (colon) and the name\/value pairs are separated by \u201c,\u201d (comma):\n\n",{"@attributes":{"id":"p-0026","num":"0027"},"figref":"FIG. 2","b":"200"},"RequestSecurityTokenCollection.RequestSecurityToken[0], which represents the first RequestSecurityToken in the array. Each element in the array in denoted by the brackets and comma separated, as described above.","RequestSecurityTokenCollection.RequestSecurityToken[0]. Token[0], which represents the first Token in the first RequestSecurityToken.","RequestSecurityTokenCollection.RequestSecurityToken[0].RequestType which represents a pointer to RequestType.","As will be seen, all elements of a message can be identified by this notation. Duplicate keys at the same level are not allowed because the message comprises a collection of name\/value pairs, so the ReferenceId notation is guaranteed to be unique.","According to this disclosure, one or more data objects in a JSON message are signed, as is now described in more detail.","The following Table 1 describes a JSON Signature syntax according this disclosure. The JSON signature comprises a set of properties that are described as follows:",{"@attributes":{"id":"p-0033","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Property\/",{}]},{"entry":["Element\/Object","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Signature","The element to digitally sign the message"]},{"entry":["VersionId","This optional element is used to identify the version of "]},{"entry":[{},"the JSON signature element, specified as a URI."]},{"entry":["SignedInfo","The information that is actually signed. The validation "]},{"entry":[{},"of SignedInfo comprises validation of the signature over "]},{"entry":[{},"SignedInfo and validation of each Referenced digest "]},{"entry":[{},"within SignedInfo. The algorithms used in"]},{"entry":[{},"calculating SignatureValue preferably are also included "]},{"entry":[{},"in the signed information while the SignatureValue "]},{"entry":[{},"element preferably is outside. This element is required."]},{"entry":["Canonicalization-","The method used to canonicalize the SignedInfo object "]},{"entry":["Method","before it is digested (signed) as part of the signature "]},{"entry":[{},"process. This element is required"]},{"entry":["Signature-","The algorithm used to convert the canonicalized "]},{"entry":["Algorithm","SignedInfo into a SignatureValue. Typically, it is a "]},{"entry":[{},"combination of a digest algorithm and a key "]},{"entry":[{},"dependent algorithm. Preferably, the Signature-"]},{"entry":[{},"Algorithm is signed as part of SignedInfo to resist "]},{"entry":[{},"attacks based on substituting a weaker algorithm. "]},{"entry":[{},"This element is required."]},{"entry":["ReferenceId[ ]","Each Reference element represents a digest method "]},{"entry":[{},"and resulting digest value on a piece of the message "]},{"entry":[{},"(a data object) identified by the ReferenceId. It may "]},{"entry":[{},"include Transforms that were used to produce the "]},{"entry":[{},"input to the digest. This element is required."]},{"entry":["Transforms[ ]","An ordered array of transform algorithm URIs. These "]},{"entry":[{},"are the one or more method(s) used to process the "]},{"entry":[{},"Reference element before the data object associated "]},{"entry":[{},"therewith is digested. An output of a transform may "]},{"entry":[{},"be supplied as an input to another. This element is "]},{"entry":[{},"optional."]},{"entry":["Digest","A base64 encoded digest string of a piece of the message "]},{"entry":[{},"(the data object) identified in the Reference element. "]},{"entry":[{},"This element is required"]},{"entry":["DigestAlgorithm","A URI (a pointer) for the algorithm used to generate the "]},{"entry":[{},"Digest, This is required."]},{"entry":["ReferenceId","The key that identifies the message for the Reference "]},{"entry":[{},"element. This is a required element."]},{"entry":["KeyInfo","The key information used to look up the public key to "]},{"entry":[{},"verify the SignatureValue. Typically, this is the X509 "]},{"entry":[{},"subject key identifier. It is a required element."]},{"entry":["SignatureValue","A signed digest on the canonicalization of the "]},{"entry":[{},"SignedInfo object. The array of Reference objects in "]},{"entry":[{},"the SignedInfo object is ordered, so that the "]},{"entry":[{},"canonicalization method would include sorting the "]},{"entry":[{},"Reference object contents. This is a required element."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The nomenclature set forth above should not be taken as limiting. Thus, for example, the \u201creference element,\u201d the \u201csignature information element\u201d and \u201csignature element\u201d may be generalized into \u201cfirst,\u201d \u201csecond\u201d and \u201cthird\u201d elements without loss of generality.","The following description summarizes one technique according to this disclosure for signing and validating a JSON message. In one embodiment, the signing process comprises two (2) distinct phases: Reference Generation, and Signature Generation. Reference Generation is carried out for each data object being signed in the JSON message. Each such data object (to be signed) is identified by its ReferenceId. That message may include one or more such data objects, and it is not required that all of the data objects in a message be signed. The Reference Generation phase is iterated for each data object being signed as illustrated in the process flow diagram of . The routine begins at step  by applying the one or more Transforms, as determined by the URIs, to the data object pointed to by the ReferenceId. One such Transform is a canonicalization method that, as described in more detail below, takes a data object and generates an \u201cordered data object\u201d (sometimes referred to herein as a \u201ccanonical form\u201d of the data object). An ordered data object allows control of the serialization order of attributes when serializing out to a string. At step , a Digest value is calculated over the data object that results from applying the one or more Transforms. This value is calculated by applying the DigestAlgorithm (sometimes referred to herein as a digest method). At step , a Reference element is constructed. The Reference element, as noted above, includes the identification of the data object (namely, the ReferenceId), a pointer to the DigestAlgorithm, and the Digest. It may also include any (optional) Transform elements. This completes the Reference Generation phase for the particular data object. As mentioned, this process is repeated for each data object to be signed in the message.",{"@attributes":{"id":"p-0036","num":"0037"},"figref":["FIG. 4","FIG. 3","FIG. 3","FIG. 4","FIG. 4"],"b":["400","402","404"]},"The following illustrates an example of a request message that is digitally signed using a JSON signature scheme such as described above with respect to . In this example, the signature is outside the message. In particular, this is a \u201cdetached\u201d signature over the data in the message that is external to the Signature element.",{"@attributes":{"id":"p-0038","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{ \u201cRequestSecurityTokenCollection\u201d: {"},{"entry":"\u2003\u2003\u201cVersionId\u201d: \u201chttp:\/\/www.ibm.com\/2008\/07\/json-rstc\u201d,"},{"entry":"\u2003\u2003\u201cRequestSecurityToken\u201d: ["},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u201cIssuer\u201d: \u201cESSUSERNAMETOKEN\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2002\u201cRequestType\u201d:"},{"entry":"\u201chttp:\/\/schemas.xmlsoap.org\/ws\/2005\/02\/trust\/Validate\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2002\u201cToken\u201d: ["},{"entry":"\u201cPHdzczpVc2 ... W1lVG9rZW4+\u201d"},{"entry":"\u2003\u2003\u2003\u2003],"},{"entry":"\u2003\u2003\u2003\u2003\u201cTokenType\u201d:"},{"entry":"\u201chttp:\/\/www.ibm.com\/websphere\/appserver\/tokentype#LTPAv2\u201d"},{"entry":"\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003]"},{"entry":"},"},{"entry":"\u201cSignature\u201d: {"},{"entry":"\u2003\u201cVersionId\u201d: \u201chttp:\/\/www.ibm.com\/2008\/07\/json-dsig\u201d,"},{"entry":"\u2003\u201cSignedInfo\u201d: {"},{"entry":"\u2003\u2003\u2002\u201cCanonicalizationMethod\u201d: \u201chttp:\/\/www.ibm.com\/2008\/07\/"},{"entry":"\u2003\u2003\u2002json-c14n\u201d,"},{"entry":"\u2003\u2003\u2002\u201cSignatureAlgorithm\u201d: \u201chttp:\/\/www.w3.org\/2000\/09\/"},{"entry":"\u2003\u2003\u2002xmldsig#rsa-sha1\u201d,"},{"entry":"\u2003\u2003\u2002\u201cReference\u201d: ["},{"entry":"\u2003\u2003\u2003\u2002{"},{"entry":"\u2003\u2003\u2003\u2003\u201cDigest\u201d: \u201cCZONTL32O6UjUZyjMEmCfR3ViEw=\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u201cDigestAlgorithm\u201d: \u201chttp:\/\/www.w3.org\/2000\/09\/"},{"entry":"\u2003\u2003\u2003\u2003xmldsig#sha1\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u201cReferenceId\u201d: \u201cRequestSecurityTokenCollection\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u201cTransforms\u201d: ["},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cAlgorithm\u201d: \u201chttp:\/\/www.ibm.com\/2008\/07\/json-c14n\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2002]"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2002],"},{"entry":"\u2002},"},{"entry":"\u201cKeyInfo\u201d: {"},{"entry":"\u2003\u2002\u201cX509Data\u201d: {"},{"entry":"\u2003\u2003\u2002\u201cX509SKI\u201d: \u201cR8ReXSemNK ... QWGNM=\u201d"},{"entry":"\u2003\u2003}"},{"entry":"\u2003},"},{"entry":"\u2003\u201cSignatureValue\u201d:"},{"entry":"\u201cY7f7FY1ZPQfjCrZqB ... fAQpAVMQ=\u201d,"},{"entry":"\u2003}"},{"entry":"\u2002}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following illustrates another example of a request message that is digitally signed using the JSON signature scheme. It uses a signature contained within the message. In this latter approach, the signature is over the data in the message that includes the signature element. This approach is sometimes referred to as an enveloped signature. When this approach is used, the CanonicalizationMethod in the transform excludes the signature from the message identified in the ReferenceId before canonicalization occurs.",{"@attributes":{"id":"p-0040","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"( \u201cRequestSecurityTokenCollection\u201d: {"},{"entry":"\u2003\u2003\u201cVersionId\u201d: \u201chttp:\/\/www.ibm.com\/2008\/07\/json-rstc\u201d,"},{"entry":"\u2003\u2003\u201cRequestSecurityToken\u201d: ["},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2002\u2009\u201cIssuer\u201d: \u201cESSUSERNAMETOKEN\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cRequestType\u201d:"},{"entry":"\u201chttp:\/\/schemas.xmlsoap.org\/ws\/2005\/02\/trust\/Validate\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cToken\u201d: ["},{"entry":"\u201cPHdzczpVc2 ... Wl1VG9rZW4+\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2002\u2009],"},{"entry":"\u2003\u2003\u2003\u2003\u2002\u2009\u201cTokenType\u201d:"},{"entry":"\u201chttp:\/\/www.ibm.com\/websphere\/appserver\/tokentype#LTPAv2\u201d"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003],"},{"entry":"\u2003\u2002\u2009\u201cSignature\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u201cVersionId\u201d: \u201chttp:\/\/www.ibm.com\/2008\/07\/json-dsig\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u201cSignedInfo\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cCanonicalizationMethod\u201d: \u201chttp:\/\/www.ibm.com\/2008\/07\/"},{"entry":"json-c14n\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cSignatureAlgorithm\u201d: \u201chttp:\/\/www.w3.org\/2000\/09\/"},{"entry":"xmldsig#rsa-sha1\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cReference\u201d: ["},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u201cDigest\u201d: \u201cCZONTL32O6UjUZyjMEmCfR3ViEw=\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cDigestAlgorithm\u201d:"},{"entry":"\u201chttp:\/\/www.w3.org\/2000\/09\/xmldsig#sha1\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cReferenceId\u201d: \u201cRequestSecurityTokenCollection\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cTransforms\u201d: ["},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cAlgorithm\u201d: \u201chttp:\/\/www.ibm.com\/2008\/07\/"},{"entry":"json-c14n-env\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003]"},{"entry":"\u2003\u2003\u2003\u2003\u2003} ],"},{"entry":"\u2003},"},{"entry":"\u2003\u201cKeyInfo\u201d: {"},{"entry":"\u2003\u2003\u2002\u2009\u201cX509Data\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u201cX509SKI\u201d: \u201cR8ReXSemNK ... QWGNM=\u201d"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003},"},{"entry":"\u2003\u2003\u201cSignatureValue\u201d:"},{"entry":"\u201cY7f7FYlZPQfjCrZqB ... fAQpAVMQ=\u201d,"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2002}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The Signature preferably is validated before being sent on the wire. Preferably, validation includes two aspects: Reference Validation, which verifies the Digest contained in each Reference in SignedInfo, and cryptographic signature validation of the SignatureValue calculated over SignedInfo. These are conventional operations.","Although not meant to be limiting, the signature methods may be any known algorithms such as: (a) DSA with SHA-1 signature algorithm which uses the SHA-1 digest algorithm and DSA to create and verify DSA digital signatures as defined in FIPS Publication 186, or (b) the signature algorithm with SHA-1 and the RSA encryption algorithm as defined in the OSI Interoperability Workshop, using the padding conventions described in PKCS #1. A representative message digest algorithm is the Secure Hash Algorithm, as defined in Secure Hash Standard, NIST FIPS Publication 180-1. An MD5 message digest algorithm may be used as well. These algorithms are merely representative, however, as any known or later-developed digest and\/or signature algorithms may be used.","A preferred canonicalization method is now described with respect to the process flow diagram of . The method begins at step  by creating an Ordered JSON Object. At step , all the keys from the JSON Object get passed in (to the Ordered JSON Object). At step , the method sorts the keys, which are strings. The method then iterates as follows, for each key. In particular, at step , the method gets the value from the JSON Object passed in by looking it up from the key. A test is then performed at step  to determine if the value is a JSON Object. This is step . If so, the method puts the key and canonicalized value into the Ordered JSON Object. To canonicalize the value, the method calls step , passing in the value (this is recursion). If the outcome of the test at step  is negative, a test is performed at step  to determine if the value is a JSON Array. If so, the method continues at step  and creates a JSON Array to store the contents of the value. The method then continues at step  to get each object in the value array. It then performs the following sub-loop. In particular, a test is performed at step  to determine if the object is a JSON Object. If the outcome of the test at step  is yes, the method continues at step  to add the canonicalized object to the JSON Array. To canonicalize the object, the method calls step , passing in the object (this is recursion). If, however, the outcome of the test at step  is negative (because the object is not a JSON Object), and if the object is a string, the string is added to the JSON Array at step . After each object in the value array is processed, the method continues at step  to canonicalize the JSON array, e.g., by sorting the contents of the array. For items that are JSON objects, during the sort the method serializes them to a string before comparing. At step , the method puts the key and canonicalized JSON array in the Ordered JSON Object.","If the outcome of the test at step  is negative (because the value is not a JSON Object and is not a JSON Array), and if the value is a string, the method puts the key and value into the Ordered JSON Object. This is step . This completes the processing for each key in the loop defined by step . The method then completes at step . In this step, the Ordered JSON Object is now serialized to a string, and it is against this string that the digest or signature (as the case may be) is generated.","In particular, when the canonicalization method of  is used as a Transform, the DigestAlgorithm is applied to the string (output in step ) to generate the Digest. When the canonicalization method of  is used as the CanonicalizationMethod, the string (output in step ) becomes part of the SignedInfo element, which when processed by SignatureAlgorithm generates the SignatureValue. As noted above, for the enveloped signature approach, the signature element is excluded before canonicalization.","As can be seen, a canonicalization algorithm such as described above orders the JSON message Reference elements. This operation generates a \u201ccanonical form\u201d of these elements (for use, for example, as part of the SignedInfo element). The canonical form of the data object may be generated using this approach as well. In particular, the canonicalization method sorts the contents of the JSON message recursively and creates an Ordered JSON Object on which to generate the appropriate digest. An Ordered JSON Object allows control of the serialization order of attributes. The order in which items are put into the instance controls the order in which they are serialized out. For canonicalization to work, no spaces are allowed in the JSON syntax for the message. As can be seen from the JSON syntax, the canonicalization method recursively calls itself, sorting the contents of the message, which includes the keys and values. A value can obtain another object and an array, and this is where the recursion is performed. When serializing out to a string (i.e., to turn into bytes for digesting), the Ordered JSON Object allows control of the serialization order of attributes.","This canonicalization operation generates a \u201ccanonical form\u201d of the Reference elements (for use, for example, as part of the SignedInfo element). The canonical form of the data object may be generated using this approach as well.","The techniques described herein are advantageous. The disclosed subject matter solves the problem of JSON message integrity. Using the signature syntax as described, a sending entity can provide message integrity and authentication through message digests and signatures. The JSON signature allows the sender to generate a digest on all or parts of a JSON request message and then to secure the digests using a signing key. The JSON signature scheme provides a convenient way of identifying the data object in the message and canonicalizing the data for generating the digest. The signature technique is lightweight and fast to parse, resulting in increased performance and smaller disk and memory footprint. By implementing JSON message integrity in this manner, an additional layer of security (over and above any transport layer security) is applied to the message. Thus, the data in the message is further secured against malicious altering by an attacker (who can compromise the transport security), or against accidental altering through transmission errors. Using this approach, the sending entity need not even use transport security.",{"@attributes":{"id":"p-0049","num":"0050"},"figref":"FIG. 6","b":["600","600","602","605","604","606","608","610","612","614","616","618","620"]},"The disclosed subject matter can take the form of an entirely hardware embodiment, an entirely software embodiment or an embodiment containing both hardware and software elements. In one embodiment, the JSON signature syntax and associated routines (including the canonicalization method) are implemented in software, which includes but is not limited to firmware, resident software, microcode, and the like. Furthermore, as noted above, the disclosed subject matter can take the form of a computer program product accessible from a computer-usable or computer-readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description, a computer-usable or computer readable medium can be any apparatus that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device. The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read-only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk-read only memory (CD-ROM), compact disk-read\/write (CD-R\/W) and DVD. The transform and related functions may also be implemented as a managed or hosted service.","In one embodiment, the program instructions are stored in a computer readable storage medium in a data processing system, and these instructions are downloaded over a network from a remote data processing system. In an alternative embodiment, the instructions are stored in a computer readable storage medium in a server data processing system, and the instructions are downloaded over a network to a remote (e.g., a client) data processing system for use in a computer readable storage medium with the remote system.","While the above describes a particular order of operations performed by certain embodiments of the invention, it should be understood that such order is exemplary, as alternative embodiments may perform the operations in a different order, combine certain operations, overlap certain operations, or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic.","Finally, while given components of the system have been described separately, one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions, program sequences, code portions, and the like.","The subject matter herein is not limited to signing JSON messages. The techniques may be applied to any text-based, data-interchange message format that is used to create a portable representation of structured data. Thus, the techniques described herein apply to signing structured data messages, where a structured data message comprises a collection of name\/value pairs, and an ordered list of values. Thus, the techniques described herein may be generalized for use with respect to any structured data-interchange format. Examples of such alternative formats include those where the collection of name\/value pairs is a record, a struct, a hash table, a keyed list or an associative array, or where the ordered list of values is realized as a vector, a list or a sequence.","As used herein, a \u201cgiven function\u201d of a data object may be the data object itself, the ordered data object that results from applying a canonicalization method (such as described in ) to the data object, or the data object resulting from applying other such transforms. Likewise, a \u201ccanonical form\u201d of an object (such as a set of reference elements) may be the reference elements, or the result of applying the canonicalization method (such as described in ) to those elements.","The following is a representative Java implementation of the canonicalization method shown in  (\u00a9 2009, IBM Corporation):",{"@attributes":{"id":"p-0057","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\/**"]},{"entry":[{},"\u2003\u2003\u2003\u2009* Canonicalize JSONObject"]},{"entry":[{},"\u2003\u2003\u2003\u2009* @param jsonObject"]},{"entry":[{},"\u2003\u2003\u2003\u2009* @return"]},{"entry":[{},"\u2003\u2003\u2003\u2009*\/"]},{"entry":[{},"\u2003\u2003\u2003public static byte[ ] canonicalizeJSONObject(JSONObject"]},{"entry":[{},"jsonObject) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003OrderedJSONObject orderedJSONObject ="]},{"entry":[{},"getOrderedJSONObject(jsonObject);"]},{"entry":[{},"\u2003\u2003\u2003\u2003byte[ ] canonicalBytes = null;"]},{"entry":[{},"\u2003\u2003\u2003\u2003try {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003canonicalBytes ="]},{"entry":[{},"orderedJSONObject.serialize( ).getBytes(\u201cUTF-8\u201d);"]},{"entry":[{},"\u2003\u2003\u2003\u2003} catch (Exception e) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003canonicalBytes = null;"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003return canonicalBytes;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\/**"]},{"entry":[{},"\u2003\u2003\u2003\u2009* Recursive method to order a JSON object such that we can"]},{"entry":[{},"generate"]},{"entry":[{},"\u2003\u2003\u2003\u2009* a digest on it."]},{"entry":[{},"\u2003\u2003\u2003\u2009*"]},{"entry":[{},"\u2003\u2003\u2003\u2009* @param jsonObject"]},{"entry":[{},"\u2003\u2003\u2003\u2009* @return"]},{"entry":[{},"\u2003\u2003\u2003\u2009*\/"]},{"entry":[{},"\u2003\u2003\u2003public static OrderedJSONObject"]},{"entry":[{},"getOrderedJSONObject(JSONObject jsonObject) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003OrderedJSONObject orderedJSONObject = new"]},{"entry":[{},"OrderedJSONObject( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003Object keys[ ] = jsonObject.keySet( ).toArray( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003Arrays.sort(keys);"]},{"entry":[{},"\u2003\u2003\u2003\u2003for (int i=0; i < keys.length; i++) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003String key = (String)keys[i];"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003Object value = jsonObject.get(key);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003if (value instanceof JSONObject) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003orderedJSONObject.put(key,"]},{"entry":[{},"getOrderedJSONObject((JSONObject)value));"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003} else if (value instanceof JSONArray){"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003JSONArray orderedArray = new, JSONArray( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003JSONArray array = (JSONArray)value;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003for (Iterator k=array.iterator( ); k.hasNext( );) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003Object item = k.next( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (item instanceof JSONObject) {"]},{"entry":[{},"orderedArray.add(getOrderedJSONObject((JSONObject)item));"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003orderedArray.add(item);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Collections.sort(orderedArray, new"]},{"entry":[{},"JSONArrayComparator( ));"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003orderedJSONObject.put(key, orderedArray);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003orderedJSONObject.put(key, value);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003return orderedJSONObject;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003private static class JSONArrayComparator implements"]},{"entry":[{},"\u2003\u2003\u2003Comparator {"]},{"entry":[{},"\u2003\u2003\u2003\u2003public int compare(Object o1, Object o2)"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003String s1 = \u201c\u201d;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003String s2 = \u201c\u201d;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003if (o1 instanceof JSONObject) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003try {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003s1 = ((JSONObject)o1).serialize( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003} catch(Exception e) { }"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003} else if (o1 instanceof String) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003s1 = (String)o1;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003if (o2 instanceof JSONObject) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003try {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003s2 = ((JSONObject)o2).serialize( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003} catch(Exception e) { }"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003} else if (o2 instanceof String) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003s2 = (String)o2;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return s1.compareTo(s2);"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Having described our invention, what we now claim is as follows."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
