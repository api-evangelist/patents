---
title: Systems and methods for synchronizing computer systems through an intermediary file system share or device
abstract: The invention is directed to systems and methods for the synchronization of two clients both utilizing a common storage platform (e.g., the new storage platform of the related inventions) to synchronize through an intermediary that is not using the same common storage platform (e.g., instead using a legacy storage platform that does not itself support synchronization for the new storage platform). Data is synchronized using the existing capabilities of the intermediary but where the data structure of the clients is preserved. An “adapter” is used to enable a client to interact with an intermediary by compensating for the intermediaries inability to preserve the data structure elements inherent to the client's storage platform. Specific embodiments are directed to either or both upload-syncing data from a client to a intermediary and/or download-syncing data from an intermediary to a client. Certain additional embodiments are further directed to compaction of data on the intermediary.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07401104&OS=07401104&RS=07401104
owner: Microsoft Corporation
number: 07401104
owner_city: Redmond
owner_country: US
publication_date: 20040712
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims benefit of U.S. Provisional Application No. 60\/567,141, filed Apr. 30, 2004, entitled \u201cSYSTEMS AND METHODS FOR SYNCHRONIZING COMPUTER SYSTEMS THROUGH AN INTERMEDIARY FILE SYSTEM SHARE OR DEVICE\u201d, the entire contents of which are hereby incorporated herein by reference.","This application is also a continuation-in-part of U.S. patent application Ser. No. 10\/883,621, filed on Jun. 30, 2004, entitled \u201cSYSTEMS AND METHODS FOR PROVIDING CONFLICT HANDLING FOR PEER-TO-PEER SYNCHRONIZATION OF UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM,\u201d which is a continuation-in-part of U.S. patent application Ser. No. 10\/673,978, filed on Sep. 29, 2003 now U.S. Pat. No. 6,987,222, entitled \u201cSYSTEMS AND METHODS FOR PROVIDING RELATIONAL AND HIERARCHICAL SYNCHRONIZATION SERVICES FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM,\u201d which is a continuation-in-part of U.S. patent application Ser. No. 10\/646,646, filed on Aug. 21, 2003 now abandoned, entitled \u201cSTORAGE PLATFORM FOR ORGANIZING, SEARCHING, AND SHARING DATA,\u201d the entire contents of which are hereby incorporated herein by reference and partially replicated herein for convenience.","This application is related by subject matter to the inventions disclosed in the following commonly assigned applications, the contents of which are hereby incorporated into this present application in their entirety (and partially summarized herein for convenience): U.S. patent application Ser. No. 10\/647,058, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR REPRESENTING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM BUT INDEPENDENT OF PHYSICAL REPRESENTATION\u201d; U.S. patent application Ser. No. 10\/646,941, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR SEPARATING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM FROM THEIR PHYSICAL ORGANIZATION\u201d; U.S. patent application Ser. No. 10\/646,940, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A BASE SCHEMA FOR ORGANIZING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10\/646,632, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A CORE SCHEMA FOR PROVIDING A TOP-LEVEL STRUCTURE FOR ORGANIZING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10\/646,645, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHOD FOR REPRESENTING RELATIONSHIPS BETWEEN UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10\/646,575, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR INTERFACING APPLICATION PROGRAMS WITH AN ITEM-BASED STORAGE PLATFORM\u201d; U.S. patent application Ser. No. 10\/646,580, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR DATA MODELING IN AN ITEM-BASED STORAGE PLATFORM\u201d; U.S. patent application Ser. No. 10\/692,779, filed on Oct. 24, 2003, entitled \u201cSYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A DIGITAL IMAGES SCHEMA FOR ORGANIZING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10\/692,515, filed on Oct. 24, 2003, entitled \u201cSYSTEMS AND METHODS FOR PROVIDING SYNCHRONIZATION SERVICES FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10\/693,362, filed on Oct. 24, 2003, entitled \u201cSYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A SYNCHRONIZATION SCHEMAS FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; and U.S. patent application Ser. No. 10\/693,574, filed on Oct. 24, 2003, entitled \u201cSYSTEMS AND METHODS FOR EXTENSIONS AND INHERITANCE FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d.","The present invention relates generally to synchronization and, more particularly, to synchronization between two or more computers utilizing a common storage platform (e.g., WinFS) but synchronizing through an different intermediary file system application programming interface (API) accessible file share or other storage device (e.g., a Win32 file share or other storage device that is API accessible) to support data-sharing, end-user roaming (including but not limited to roaming end-user profiles and their equivalents), and other synchronization purposes.","Individual disk capacity has been growing at roughly seventy percent (70%) per year over the last decade. Moore's law accurately predicted the tremendous gains in central processing unit (CPU) power that has occurred over the years. Wired and wireless technologies have provided tremendous connectivity and bandwidth. Presuming current trends continue, within several years the average laptop computer will possess roughly one terabyte (TB) of storage and contain millions of files, and 500 gigabyte (GB) drives will become commonplace.","Consumers use their computers primarily for communication and organizing personal information, whether it is traditional personal information manager (PIM) style data or media such as digital music or photographs. The amount of digital content, and the ability to store the raw bytes, has increased tremendously; however the methods available to consumers for organizing and unifying this data has not kept pace. Knowledge workers spend enormous amounts of time managing and sharing information, and some studies estimate that knowledge workers spend 15-25% of their time on non-productive information related activities. Other studies estimate that a typical knowledge worker spends about 2.5 hours per day searching for information.","Developers and information technology (IT) departments invest significant amounts of time and money in building their own data stores for common storage abstractions to represent such things as people, places, times, and events. Not only does this result in duplicated work, but it also creates islands of common data with no mechanisms for common searching or sharing of that data. Just consider how many address books can exist today on a computer running the Microsoft Windows operating system. Many applications, such as e-mail clients and personal finance programs, keep individual address books, and there is little sharing among applications of the address book data that each such program individually maintains. Consequently, a finance program (like Microsoft Money) does not share addresses for payees with the addresses maintained in an email contact folder (like the one in Microsoft Outlook). Indeed, many users have multiple devices and logically should synchronize their personal data amongst themselves and across a wide variety of additional sources, including cell phones to commercial services such as MSN and AOL; nevertheless, collaboration of shared documents is largely achieved by attaching documents to e-mail messages\u2014that is, manually and inefficiently.","One reason for this lack of collaboration is that traditional approaches to the organization of information in computer systems have centered on the use of file-folder-and-directory-based systems (\u201cfile systems\u201d) to organize pluralities of files into directory hierarchies of folders based on an abstraction of the physical organization of the storage medium used to store the files. The Multics operating system, developed during the 1960s, can be credited with pioneering the use of the files, folders, and directories to manage storable units of data at the operating system level. Specifically, Multics used symbolic addresses within a hierarchy of files (thereby introducing the idea of a file path) where physical addresses of the files were not transparent to the user (applications and end-users). This file system was entirely unconcerned with the file format of any individual file, and the relationships amongst and between files was deemed irrelevant at the operating system level (that is, other than the location of the file within the hierarchy). Since the advent of Multics, storable data has been organized into files, folders, and directories at the operating system level. These files generally include the file hierarchy itself (the \u201cdirectory\u201d) embodied in a special file maintained by the file system. This directory, in turn, maintains a list of entries corresponding to all of the other files in the directory and the nodal location of such files in the hierarchy (herein referred to as the folders). Such has been the state of the art for approximately forty years.","However, while providing a reasonable representation of information residing in the computer's physical storage system, a file system is nevertheless an abstraction of that physical storage system, and therefore utilization of the files requires a level of indirection (interpretation) between what the user manipulates (units having context, features, and relationships to other units) and what the operating system provides (files, folders, and directories). Consequently, users (applications and\/or end-users) have no choice but to force units of information into a file system structure even when doing so is inefficient, inconsistent, or otherwise undesirable. Moreover, existing file systems know little about the structure of data stored in individual files and, because of this, most of the information remains locked up in files that may only be accessed (and comprehensible) to the applications that wrote them. Consequently, this lack of schematic description of information, and mechanisms for managing information, leads to the creation of silos of data with little data sharing among the individual silos. For example, many personal computer (PC) users have more than five distinct stores that contain information about the people they interact with on some level\u2014for example, Outlook Contacts, online account addressees, Windows Address Book, Quicken Payees, and instant messaging (IM) buddy lists\u2014because organizing files presents a significant challenge to these PC users. Because most existing file systems utilize a nested folder metaphor for organizing files and folders, as the number of files increases the effort necessary to maintain an organization scheme that is flexible and efficient becomes quite daunting. In such situations, it would be very useful to have multiple classifications of a single file; however, using hard or soft links in existing file systems is cumbersome and difficult to maintain.","Several unsuccessful attempts to address the shortcomings of file systems have been made in the past. Some of these previous attempts have involved the use of content addressable memory to provide a mechanism whereby data could be accessed by content rather than by physical address. However, these efforts have proven unsuccessful because, while content addressable memory has proven useful for small-scale use by devices such as caches and memory management units, large-scale use for devices such as physical storage media has not yet been possible for a variety of reasons, and thus such a solution simply does not exist. Other attempts using object-oriented database (OODB) systems have been made, but these attempts, while featuring strong database characteristics and good non-file representations, were not effective in handling file representations and could not replicate the speed, efficiency, and simplicity of the file and folder based hierarchical structure at the hardware\/software interface system level. Other efforts, such as those that attempted to use SmallTalk (and other derivatives), proved to be quite effective at handling file and non-file representations but lacked database features necessary to efficiently organize and utilize the relationships that exist between the various data files, and thus the overall efficiency of such systems was unacceptable. Yet other attempts to use BeOS (and other such operating systems research) proved to be inadequate at handling non-file representations\u2014the same core shortcoming of traditional file systems\u2014despite being able to adequately represent files while providing some necessary database features.","Database technology is another area of the art in which similar challenges exits. For example, while the relational database model has been a great commercial success, in truth independent software vendors (ISV) generally exercise a small portion of the functionality available in relational database software products (such as Microsoft SQL Server). Instead, most of an application's interaction with such a product is in the form of simple \u201cgets\u201d and \u201cputs\u201d. While there are a number of readily apparent reasons for this\u2014such as being platform or database agnostic\u2014one key reason that often goes unnoticed is that the database does not necessarily provide the exact abstractions that a major business application vendor really needs. For example, while the real world has the notion of \u201citems\u201d, such as \u201ccustomers\u201d or \u201corders\u201d (along with an order's embedded \u201cline items\u201d as items in and of themselves), relational databases only talk in terms of tables and rows. Consequently, while the application may desire to have aspects of consistency, locking, security, and\/or triggers at the item level (to name a few), generally databases provide these features only at the table\/row level. While this may work fine if each item gets mapped to a single row in some table in the database, in the case of an order with multiple line items there may be reasons why an item actually gets mapped to multiple tables and, when that is the case, the simple relational database system does not quite provide the right abstractions. Consequently, an application must build logic on top of the database to provide these basic abstractions. In other words, the basic relational model does not provide a sufficient platform for storage of data on which higher\u2014level applications can easily be developed because the basic relational model requires a level of indirection between the application and the storage system\u2014where the semantic structure of the data might only be visible in the application in certain instances. While some database vendors are building higher-level functionality into their products\u2014such as providing object relational capabilities, new organizational models, and the like\u2014none have yet to provide the kind of comprehensive solution needed, where a truly comprehensive solution is one which provides both useful data model abstractions (such as \u201cItems,\u201d \u201cExtensions,\u201d \u201cRelationships,\u201d and so on) for useful domain abstractions (such as \u201cPersons,\u201d \u201cLocations,\u201d \u201cEvents,\u201d etc.).","In view of the foregoing deficiencies in existing data storage and database technologies, there is a need for a new storage platform that provides an improved ability to organize, search, and share all types of data in a computer system\u2014a storage platform that extends and broadens the data platform beyond existing file systems and database systems, and that is designed to be the store for all types of data. The invention disclosed in U.S. patent application Ser. No. 10\/646,646, filed on Aug. 21, 2003, entitled \u201cSTORAGE PLATFORM FOR ORGANIZING, SEARCHING, AND SHARING DATA,\u201d satisfies this need. Synchronization services for this storage platform (including conflict resolution methods) are further provided in the invention disclosed by U.S. patent application Ser. No. 10\/646,646, filed on Oct. 24, 2003, entitled \u201cSYSTEMS AND METHODS FOR PROVIDING RELATIONAL AND HIERARCHICAL SYNCHRONIZATION SERVICES FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d and U.S. patent application Ser. No. 10\/883,621, filed on Jun. 30, 2004, entitled \u201cSYSTEMS AND METHODS FOR PROVIDING CONFLICT HANDLING FOR PEER-TO-PEER SYNCHRONIZATION OF UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM.","Of course, with the initial utilization of the new storage platform described in these related patent applications, enterprises having synchronization networks comprising various individual computer systems will have mixture in that some individual computer systems will utilize the new storage platform while other individual computer systems will continue to utilize legacy storage platforms. Consequently, it may be necessary for two computer systems utilizing the new storage platform (the \u201cclients\u201d) to synchronize through a computer system utilizing a legacy storage platform (the \u201cintermediary\u201d). For example, some clients may be enrolled in legacy roaming services using software such as Roaming User Profiles (RUP) or Folder Redirection with Client Side Caching (CSC). Since legacy roaming software for these legacy storage platforms does not support roaming data for the new storage platform, a new roaming service for the new storage platform is necessary. Various embodiments of the present invention are directed to system and methods for client synchronization through an intermediary.","The following summary provides an overview of various aspects of the invention described in the context of the related inventions incorporated-by-reference earlier herein (the \u201crelated inventions\u201d). This summary is not intended to provide an exhaustive description of all of the important aspects of the invention, nor to define the scope of the invention. Rather, this summary is intended to serve as an introduction to the detailed description and figures that follow.","The related inventions are collectively directed to a storage platform for organizing, searching, and sharing data that extends and broadens the concept of data storage beyond existing file systems and database systems. This storage platform is designed to be the store for all types of data including structured, non-structured, or semi-structured data.","The storage platform comprises a data store implemented on a database engine. The database engine comprises a relational database engine with object relational extensions. The data store implements a data model that supports organization, searching, sharing, synchronization, and security of data. Specific types of data are described in schemas, and the platform provides a mechanism to extend the set of schemas to define new types of data (essentially subtypes of the basic types provides by the schemas). A synchronization capability facilitates the sharing of data among users or systems. File-system-like capabilities are provided that allow interoperability of the data store with existing file systems but without the limitation of such traditional file systems. A change tracking mechanism provides the ability track changes to the data store. The storage platform further comprises a set of application program interfaces that enable applications to access all of the foregoing capabilities of the storage platform and to access the data described in the schemas.","The data model implemented by the data store defines units of data storage in terms of items, elements, and relationships. An item is a unit of data storable in a data store and can comprise one or more elements and relationships. An element is an instance of a type comprising one or more fields (also referred to herein as a property). A relationship is a link between two items. (As used herein, these and other specific terms may be capitalized in order to offset them from other terms used in close proximity; however, there is no intention whatsoever to distinguish between a capitalized term, e.g. \u201cItem\u201d, and the same term when not capitalized, e.g., \u201citem\u201d, and no such distinction should be presumed or implied.)","The computer system further comprises a plurality of Items where each Item constitutes a discrete storable unit of information that can be manipulated by a hardware\/software interface system; a plurality of Item Folders that constitute an organizational structure for said Items; and a hardware\/software interface system for manipulating a plurality of Items and wherein each Item belongs to at least one Item Folder and may belong to more than one Item Folder.","An Item or some of the Item's property values may be computed dynamically as opposed to being derived from a persistent store. In other words, the hardware\/software interface system does not require that the Item be stored, and certain operations are supported such as the ability to enumerate the current set of Items or the ability to retrieve an Item given its identifier (which is more fully described in the sections that describe the application programming interface, or API) of the storage platform\u2014for example, an Item might be the current location of a cell phone or the temperature reading on a temperature sensor. The hardware\/software interface system may manipulate a plurality of Items, and may further comprise Items interconnected by a plurality of Relationships managed by the hardware\/software interface system.","A hardware\/software interface system for the computer system further comprises a core schema to define a set of core Items which said hardware\/software interface system understands and can directly process in a predetermined and predictable way. To manipulate a plurality of Items, the computer system interconnects said Items with a plurality of Relationships and manages said Relationships at the hardware\/software interface system level.","The API of the storage platform provides data classes for each item, item extension, and relationship defined in the set of storage platform schemas. In addition, the application programming interface provides a set of framework classes that define a common set of behaviors for the data classes and that, together with the data classes, provide the basic programming model for the storage platform API. The storage platform API provides a simplified query model that enables application programmers to form queries based on various properties of the items in the data store, in a manner that insulates the application programmer from the details of the query language of the underlying database engine. The storage platform API also collects changes to an item made by an application program and then organizes them into the correct updates required by the database engine (or any kind of storage engine) on which the data store is implemented. This enables application programmers to make changes to an item in memory, while leaving the complexity of data store updates to the API.","Through its common storage foundation and schematized data, the storage platform of the present invention enables more efficient application development for consumers, knowledge workers and enterprises. It offers a rich and extensible application programming interface that not only makes available the capabilities inherent in its data model, but also embraces and extends existing file system and database access methods.","As part of this overarching structure of interrelated inventions (described in detail in Section II of the Detailed Description), certain of the related inventions are specifically directed to the Synchronization APIs (described in detail in Section III of the Detailed Description) which, in turn, described the broad synchronization capabilities of the storage platform. It is anticipated that several embodiments of the present invention would be incorporated with these synchronization capabilities to handle conflicts as they arise during peer-to-peer synchronization. The ability to correctly and efficiently handle conflicts minimizes data loss while retaining good usability and reduces the need for user intervention during synchronization. To this end, Section III of the Detailed Description also includes a detailed description of various embodiments of the related inventions directed to systems and methods for handling conflicts in a peer-to-peer synchronization system including but not limited to the synchronization system of or storage platform of the related inventions.","In light of the foregoing, various embodiments of the present invention are directed to systems and methods for the synchronization of two clients both utilizing a common storage platform (e.g., the new storage platform of the related inventions) to synchronize through an intermediary that is not using the same common storage platform (e.g., instead using a legacy storage platform that does not itself support synchronization for the new storage platform). In summary, various embodiments of the present invention employ a methodology by which data is synchronized using the existing capabilities of the intermediary but where the data structure of the clients is preserved. Various embodiments utilize an \u201cadapter\u201d to enable a client to interact with an intermediary where said adapter effectively compensates for the intermediaries inability to preserve the data structure elements inherent to the new storage platform of the client. Various embodiments of the present invention are direct to either or both upload-syncing data from a client to a intermediary as well as download-syncing data from an intermediary to a client. In addition, certain embodiments are further directed to compaction of data on the intermediary.","Specific features and advantages of the present invention, alone and in conjunction with the related inventions, will become apparent from the following detailed description of the invention and accompanying drawings.","I. Introduction","The subject matter of the present invention is described with specificity to meet statutory requirements. However, the description itself is not intended to limit the scope of this patent. Rather, the inventors have contemplated that the claimed subject matter might also be embodied in other ways, to include different steps or combinations of steps similar to the ones described in this document, in conjunction with other present or future technologies. Moreover, although the term \u201cstep\u201d may be used herein to connote different elements of methods employed, the term should not be interpreted as implying any particular order among or between various steps herein disclosed unless and except when the order of individual steps is explicitly described.","A. Exemplary Computing Environment","Numerous embodiments of the present invention may execute on a computer.  and the following discussion is intended to provide a brief general description of a suitable computing environment in which the invention may be implemented. Although not required, various aspects of the invention may be described in the general context of computer executable instructions, such as program modules, being executed by a computer, such as a client workstation or a server. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Moreover, the invention may be practiced with other computer system configurations, including hand held devices, multi processor systems, microprocessor based or programmable consumer electronics, network PCs, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","As shown in , an exemplary general purpose computing system includes a conventional personal computer  or the like, including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the personal computer , such as during start up, is stored in ROM . The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read only memories (ROMs) and the like may also be used in the exemplary operating environment. Likewise, the exemplary environment may also include many types of monitoring devices such as heat sensors and security or fire alarm systems, and other sources of information.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system , one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite disk, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers. The exemplary system of  also includes a host adapter , Small Computer System Interface (SCSI) bus , and an external storage device  connected to the SCSI bus .","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","As illustrated in the block diagram of , a computer system  can be roughly divided into three component groups: the hardware component , the hardware\/software interface system component , and the applications programs component  (also referred to as the \u201cuser component\u201d or \u201csoftware component\u201d in certain contexts herein).","In various embodiments of a computer system , and referring back to , the hardware component  may comprise the central processing unit (CPU) , the memory (both ROM  and RAM ), the basic input\/output system (BIOS) , and various input\/output (I\/O) devices such as a keyboard , a mouse , a monitor , and\/or a printer (not shown), among other things. The hardware component  comprises the basic physical infrastructure for the computer system .","The applications programs component  comprises various software programs including but not limited to compilers, database systems, word processors, business programs, videogames, and so forth. Application programs provide the means by which computer resources are utilized to solve problems, provide solutions, and process data for various users (machines, other computer systems, and\/or end-users).","The hardware\/software interface system component  comprises (and, in some embodiments, may solely consist of) an operating system that itself comprises, in most cases, a shell and a kernel. An \u201coperating system\u201d (OS) is a special program that acts as an intermediary between application programs and computer hardware. The hardware\/software interface system component  may also comprise a virtual machine manager (VMM), a Common Language Runtime (CLR) or its functional equivalent, a Java Virtual Machine (JVM) or its functional equivalent, or other such software components in the place of or in addition to the operating system in a computer system. The purpose of a hardware\/software interface system is to provide an environment in which a user can execute application programs. The goal of any hardware\/software interface system is to make the computer system convenient to use, as well as utilize the computer hardware in an efficient manner.","The hardware\/software interface system is generally loaded into a computer system at startup and thereafter manages all of the application programs in the computer system. The application programs interact with the hardware\/software interface system by requesting services via an application program interface (API). Some application programs enable end-users to interact with the hardware\/software interface system via a user interface such as a command language or a graphical user interface (GUI).","A hardware\/software interface system traditionally performs a variety of services for applications. In a multitasking hardware\/software interface system where multiple programs may be running at the same time, the hardware\/software interface system determines which applications should run in what order and how much time should be allowed for each application before switching to another application for a turn. The hardware\/software interface system also manages the sharing of internal memory among multiple applications, and handles input and output to and from attached hardware devices such as hard disks, printers, and dial-up ports. The hardware\/software interface system also sends messages to each application (and, in certain case, to the end-user) regarding the status of operations and any errors that may have occurred. The hardware\/software interface system can also offload the management of batch jobs (e.g., printing) so that the initiating application is freed from this work and can resume other processing and\/or operations. On computers that can provide parallel processing, a hardware\/software interface system also manages dividing a program so that it runs on more than one processor at a time.","A hardware\/software interface system shell (simply referred to herein as a \u201cshell\u201d) is an interactive end-user interface to a hardware\/software interface system. (A shell may also be referred to as a \u201ccommand interpreter\u201d or, in an operating system, as an \u201coperating system shell\u201d). A shell is the outer layer of a hardware\/software interface system that is directly accessible by application programs and\/or end-users. In contrast to a shell, a kernel is a hardware\/software interface system's innermost layer that interacts directly with the hardware components.","While it is envisioned that numerous embodiments of the present invention are particularly well-suited for computerized systems, nothing in this document is intended to limit the invention to such embodiments. On the contrary, as used herein the term \u201ccomputer system\u201d is intended to encompass any and all devices capable of storing and processing information and\/or capable of using the stored information to control the behavior or execution of the device itself, regardless of whether such devices are electronic, mechanical, logical, or virtual in nature.","B. Traditional File-based Storage","In most computer systems today, \u201cfiles\u201d are units of storable information that may include the hardware\/software interface system as well as application programs, data sets, and so forth. In all modern hardware\/software interface systems (Windows, Unix, Linux, Mac OS, virtual machine systems, and so forth), files are the basic discrete (storable and retrievable) units of information (e.g., data, programs, and so forth) that can be manipulated by the hardware\/software interface system. Groups of files are generally organized in \u201cfolders.\u201d In Microsoft Windows, the Macintosh OS, and other hardware\/software interface systems, a folder is a collection of files that can be retrieved, moved, and otherwise manipulated as single units of information. These folders, in turn, are organized in a tree-based hierarchical arrangement called a \u201cdirectory\u201d (discussed in more detail herein below). In certain other hardware\/software interface systems, such as DOS, z\/OS and most Unix-based operating systems, the terms \u201cdirectory\u201d and\/or \u201cfolder\u201d are interchangeable, and early Apple computer systems (e.g., the Apple IIe) used the term \u201ccatalog\u201d instead of directory; however, as used herein, all of these terms are deemed to be synonymous and interchangeable and are intended to further include all other equivalent terms for and references to hierarchical information storage structures and their folder and file components.","Traditionally, a directory (a.k.a. a directory of folders) is a tree-based hierarchical structure wherein files are grouped into folders and folder, in turn, are arranged according to relative nodal locations that comprise the directory tree. For example, as illustrated in , a DOS-based file system base folder (or \u201croot directory\u201d)  may comprise a plurality of folders , each of which may further comprise additional folders (as \u201csubfolders\u201d of that particular folder) , and each of these may also comprise additional folders  ad infinitum. Each of these folders may have one or more files  although, at the hardware\/software interface system level, the individual files in a folder have nothing in common other than their location in the tree hierarchy. Not surprisingly, this approach of organizing files into folder hierarchies indirectly reflects the physical organization of typical storage media used to store these files (e.g., hard disks, floppy disks, CD-ROMs, etc.).","In addition to the foregoing, each folder is a container for its subfolders and its files\u2014that is, each folder owns its subfolders and files. For example, when a folder is deleted by the hardware\/software interface system, that folder's subfolders and files are also deleted (which, in the case of each subfolder, further includes its own subfolders and files recursively). Likewise, each file is generally owned by only one folder and, although a file can be copied and the copy located in a different folder, a copy of a file is itself a distinct and separate unit that has no direct connection to the original (e.g., changes to the original file are not mirrored in the copy file at the hardware\/software interface system level). In this regard, files and folders are therefore characteristically \u201cphysical\u201d in nature because folders are the treated like physical containers, and files are treated as discrete and separate physical elements inside these containers.","II. WINFS Storage Platform for Organizing, Searching, and Sharing Data","The present invention, in combination with the related inventions incorporated by reference as discussed earlier herein, is directed to a storage platform for organizing, searching, and sharing data. The storage platform of the present invention extends and broadens the data platform beyond the kinds of existing file systems and database systems discussed above, and is designed to be the store for all types of data, including a new form of data called Items.","A. Glossary","As used herein and in the claims, the following terms have the following meanings:\n\n","B. Storage Platform Overview","Referring to , a storage platform  comprises a data store  implemented on a database engine . In one embodiment, the database engine comprises a relational database engine with object relational extensions. In one embodiment, the relational database engine  comprises the Microsoft SQL Server relational database engine. The data store  implements a data model  that supports the organization, searching, sharing, synchronization, and security of data. Specific types of data are described in schemas, such as schemas , and the storage platform  provides tools  for deploying those schemas as well as for extending those schemas, as described more fully below.","A change tracking mechanism  implemented within the data store  provides the ability track changes to the data store. The data store  also provides security capabilities  and a promotion\/demotion capability , both of which are discussed more fully below. The data store  also provides a set of application programming interfaces  to expose the capabilities of the data store  to other storage platform components and application programs (e.g., application programs , , and ) that utilize the storage platform. The storage platform of the present invention still further comprises an application programming interfaces (API) , which enables application programs, such as application programs , , and , to access all of the foregoing capabilities of the storage platform and to access the data described in the schemas. The storage platform API  may be used by application programs in combination with other APIs, such as the OLE DB API  and the Microsoft Windows Win32 API .","The storage platform  of the present invention may provide a variety of services  to application programs, including a synchronization service  that facilitates the sharing of data among users or systems. For example, the synchronization service  may enable interoperability with other data stores  having the same format as data store , as well as access to data stores  having other formats. The storage platform  also provides file system capabilities that allow interoperability of the data store  with existing file systems, such as the Windows NTFS files system . In at least some embodiments, the storage platform  may also provide application programs with additional capabilities for enabling data to be acted upon and for enabling interaction with other systems. These capabilities may be embodied in the form of additional services , such as an Info Agent service  and a notification service , as well as in the form of other utilities .","In at least some embodiments, the storage platform is embodied in, or forms an integral part of, the hardware\/software interface system of a computer system. For example, and without limitation, the storage platform of the present invention may be embodied in; or form an integral part of, an operating system, a virtual machine manager (VMM), a Common Language Runtime (CLR) or its functional equivalent, or a Java Virtual Machine (JVM) or its functional equivalent. Through its common storage foundation, and schematized data, the storage platform of the present invention enables more efficient application development for consumers, knowledge workers and enterprises. It offers a rich and extensible programming surface area that not only makes available the capabilities inherent in its data model, but also embraces and extends existing file system and database access methods.","In the following description, and in various ones of the figures, the storage platform  of the present invention may be referred to as \u201cWinFS.\u201d However, use of this name to refer to the storage platform is solely for convenience of description and is not intended to be limiting in any way.","C. The Data Model","The data store  of the storage platform  of the present invention implements a data model that supports the organization, searching, sharing, synchronization, and security of data that resides in the store. In the data model of the present invention, an \u201cItem\u201d is the fundamental unit of storage information. The data model provides a mechanism for declaring Items and Item extensions and for establishing relationships between Items and for organizing Items in Item Folders and in Categories, as described more fully below.","The data model relies on two primitive mechanisms, Types and Relationships. Types are structures which provide a format which governs the form of an instance of the Type. The format is expressed as an ordered set of Properties. A Property is a name for a value or set of values of a given Type. For example a USPostalAddress type might have the properties Street, City, Zip, State in which Street, City and State are of type String and Zip is of Type Int32. Street may be multi-valued (i.e. a set of values) allowing the address to have more than one value for the Street property. The system defines certain primitive types that can be used in the construction of other types\u2014these include String, Binary, Boolean, Int16, Int32, Int64, Single, Double, Byte, DateTime, Decimal and GUID. The Properties of a Type may be defined using any of the primitive types or (with some restrictions noted below) any of the constructed types. For example a Location Type might be defined that had Properties Coordinate and Address where the Address Property is of Type USPostalAddress as described above. Properties may also be required or optional.","Relationships can be declared and represent a mapping between the sets of instances of two types. For example there may be a Relationship declared between the Person Type and the Location Type called LivesAt which defines which people live at which locations. The Relationship has a name, two endpoints, namely a source endpoint and a target endpoint. Relationships may also have an ordered set of properties. Both the Source and Target endpoints have a Name and a Type. For example the LivesAt Relationship has a Source called Occupant of Type Person and a Target called Dwelling of Type Location and in addition has properties StartDate and EndDate indicating the period of time for which the occupant lived at the dwelling. Note that a Person may live at multiple dwellings over time and a dwelling may have multiple occupants so the most likely place to put the StartDate and EndDate information is on the relationship itself.","Relationships define a mapping between instances that is constrained by the types given as the endpoint types. For example the LivesAt relationship cannot be a relationship in which an Automobile is the Occupant because an Automobile is not a Person.","The data model does allow the definition of a subtype-supertype relationship between types. The subtype-supertype relationship also known as the BaseType relationship is defined in such a way that if Type A is a BaseType for Type B it must be the case that every instance of B is also an instance of A. Another way of expressing this is that every instance that conforms to B must also conform to A. If, for example A has a property Name of Type String while B has a property Age of Type Int16, it follows that any instance of B must have both a Name and an Age. The type hierarchy may be envisaged as an tree with a single supertype at the root. The branches from the root provide the first level subtypes, the branches at this level provide the second level subtypes and so on to the leaf-most subtypes which themselves do not have any subtypes. The tree is not constrained to be of a uniform depth but cannot contain any cycles. A given Type may have zero or many subtypes and zero or one super type. A given instance may conform to at most one type together with that type's super types. To put it another way, for a given instance at any level in the tree the instance may conform to at most one subtype at that level. A type is said to be Abstract if instances of the type must also be an instance of a subtype of the type.","1. Items","An Item is a unit of storable information that, unlike a simple file, is an object having a basic set of properties that are commonly supported across all objects exposed to an end-user or application program by the storage platform. Items also have properties and relationships that are commonly supported across all Item types including features that allow new properties and relationships to be introduced, as discussed below.","Items are the objects for common operations such as copy, delete, move, open, print, backup, restore, replicate, and so forth. Items are the units that can be stored and retrieved, and all forms of storable information manipulated by the storage platform exist as Items, properties of Items, or Relationships between Items, each of which is discussed in greater detail herein below.","Items are intended to represent real-world and readily-understandable units of data like Contacts, People, Services, Locations, Documents (of all various sorts), and so on.  is a block diagram illustrating the structure of an Item. The unqualified name of the Item is \u201cLocation\u201d. The qualified name of the Item is \u201cCore.Location\u201d which indicates that this Item structure is defined as a specific type of Item in the Core Schema. (The Core Schema is discussed in more detail later herein.)","The Location Item has a plurality of properties including EAddresses, MetropolitanRegion, Neighborhood, and PostalAddresses. The specific type of property for each is indicated immediately following the property name and is separated from the property name by a colon (\u201c:\u201d). To the right of the type name, the number of values permitted for that property type is indicated between brackets (\u201c[ ]\u201d) wherein an asterisk (\u201c*\u201d) to the right of the colon (\u201c:\u201d) indicates an unspecified and\/or unlimited number (\u201cmany\u201d). A \u201c1\u201d to the right of the colon indicates that there can be at most one value. A zero (\u201c0\u201d) to the left of the colon indicates that the property is optional (there may be no value at all). A \u201c1\u201d to the left of the colon indicates that there must be at least one value (the property is required). Neighborhood and MetropolitanRegion are both of type \u201cnvarchar\u201d (or equivalent) which is a predefined data type or \u201csimple type\u201d (and denoted herein by the lack of capitalization). EAddresses and PostalAddresses, however, are properties of defined types or \u201ccomplex types\u201d (as denoted herein by capitalization) of types EAddress and PostalAddress respectively. A complex type is type that is derived from one or more simple data types and\/or from other complex types. The complex types for the properties of an Item also constitute \u201cnested elements\u201d since the details of the complex type are nested into the immediate Item to define its properties, and the information pertaining to these complex types is maintained with the Item that has these properties (within the Item's boundary, as discussed later herein). These concepts of typing are well known and readily appreciated by those of skill in the art.",{"@attributes":{"id":"p-0124","num":"0126"},"figref":["FIG. 5B","FIG. 5C","FIG. 5C","FIG. 5A"]},"Similar to but distinct from properties and their property types, Items inherently represent their own Item Types that can also be the subject of subtyping. In other words, the storage platform in several embodiments of the present invention allows an Item to be a subtype of another Item (whereby the one Item inherits the properties of the other, parent Item). Moreover, for various embodiments of the present invention, every Item is a subtype of the \u201cItem\u201d Item type which is the first and foundational Item type found in the Base Schema. (The Base Schema will also be discussed in detail later herein.)  illustrates an Item, the Location Item in this Instance, as being a subtype of the Item Item type found in the Base Schema. In this drawing, the arrow indicates that the Location Item (like all other Items) is a subtype of the Item Item type. The Item Item type, as the foundational Item from which all other Items are derived, has a number of important properties such as ItemId and various timestamps, and thereby defines the standard properties of all Items in an operating system. In the present figure, these properties of the Item Item type are inherited by Location and thereby become properties of Location.","Another way to represent the properties in the Location Item inherited from the Item Item type is to draw Location with the individual properties of each property type from the parent Item listed therein.  is a block diagram illustrating the Location Item wherein its inherited types described in addition to its immediate properties. It should be noted and understood that this Item is the same Item illustrated in , although in the present figure Location is illustrated with all of its properties, both immediate-shown in both this figure and FIG. A\u2014and inherited\u2014shown in this figure but not  (whereas in  these properties are referenced by showing with an arrow that the Location Item is a subtype of the Item Item type).","Items are stand-alone objects; thus, if you delete an Item, all of the Items immediate and inherited properties are also deleted. Similarly, when retrieving an Item, what is received is the Item and all of its immediate and inherited properties (including the information pertaining to its complex property types). Certain embodiments of the present invention may enable one to request a subset of properties when retrieving a specific Item; however, the default for many such embodiments is to provide the Item with all of its immediate and inherited properties when retrieved. Moreover, the properties of Items can also be extended by adding new properties to the existing properties of that Item's type. These \u201cextensions\u201d are thereafter bona fide properties of the Item and subtypes of that Item type may automatically include the extension properties.","The \u201cboundary\u201d of the Item is represented by its properties (including complex property types, extensions, and so forth). An Item's boundary also represents the limit of an operation performed on an Item such as copy, delete, move, create, and so on. For example, in several embodiments of the present invention, when an Item is copied, everything within that Item's boundary is also copied. For each Item, the boundary encompasses the following:\n\n","2. Item Identification","Items are uniquely identified within the global items space with an ItemID. The Base.Item type defines a field ItemID of type GUID that stores the identity for the Item. An Item must have exactly one identity in the data store .","An item reference is a data structure that contains information to locate and identify an Item. In the data model, an abstract type is defined named ItemReference from which all item reference types derive. The ItemReference type defines a virtual method named Resolve. The Resolve method resolves the ItemReference and returns an Item. This method is overridden by the concrete subtypes of ItemReference, which implement a function that retrieves an Item given a reference. The Resolve method is invoked as part of the storage platform API .","ItemIDReference is a subtype of ItemReference. It defines a Locator and an ItemID field. The Locator field names (i.e. identifies) an item domain. It is processed by a locator resolution method that can resolve the value of the Locator to an item domain. The ItemID field is of type ItemID","ItemPathReference is a specialization of ItemReference that defines a Locator and a Path field. The Locator field identifies an item domain. It is processed by a locator resolution method that can resolve the value of the Locator to an item domain. The Path field contains a (relative) path in the storage platform namespace rooted at the item domain provided by the Locator.","This type of reference cannot be used in a set operation. The reference must generally be resolved through a path resolution process. The Resolve method of the storage platform API  provides this functionality.","The reference forms discussed above are represented through the reference type hierarchy illustrated in . Additional reference types that inherit from these types can be defined in the schemas. They can be used in a relationship declaration as type of the target field.","3. Item Folders and Categories","As discussed more fully below, groups of Items can are organized into special Items called Item Folders (which are not to be confused with file folders). Unlike in most file systems, however, an Item can belong to more than one Item Folder, such that when an Item is accessed in one Item Folder and revised, this revised Item can then be accessed directly from another Item folder. In essence, although access to an Item may occur from different Item Folders, what is actually being accessed is in fact the very same Item. However, an Item Folder does not necessarily own all of its member Items, or may simply co-own Items in conjunction with other folders, such that the deletion of an Item Folder does not necessarily result in the deletion of the Item. Nevertheless, in several embodiments of the present invention, an Item must belong to at least one Item Folder so that if the sole Item Folder for a particular Item is deleted then, for some embodiments, the Item is automatically deleted or, in alternative embodiments, the Item automatically becomes a member of a default Item Folder (e.g., a \u201cTrash Can\u201d Item Folder conceptually similar to similarly-named folders used in various file-and-folder-based systems).","As also discussed more fully below, Items may also belong to Categories based on common described characteristic such as (a) an Item Type (or Types), (b) a specific immediate or inherited property (or properties), or (c) a specific value (or values) corresponding to an Item property. For example, a Item comprising specific properties for personal contact information might automatically belong to a Contact Category, and any Item having contact information properties would likewise automatically belong to this Category. Likewise, any Item having a location property with a value of \u201cNew York City\u201d might automatically belong to a NewYorkCity Category.","Categories are conceptually different form Item Folders in that, whereas Item Folders may comprise Items that are not interrelated (i.e., without a common described characteristic), each Item in a Category has a common type, property, or value (a \u201ccommonality\u201d) that is described for that Category, and it is this commonality that forms the basis for its relationship to and among the other Items in the Category. Moreover, whereas an Item's membership in a particular Folder is not compulsory based on any particular aspect of that Item, for certain embodiments all Items having a commonality categorically related to a Category might automatically become a member of the Category at the hardware\/software interface system level. Conceptually, Categories can also be thought of as virtual Item Folders whose membership is based on the results of a specific query (such as in the context of a database), and Items that meet the conditions of this query (defined by the commonalities of the Category) would thus comprise the Category's membership.",{"@attributes":{"id":"p-0140","num":"0145"},"figref":"FIG. 4","b":["402","404","406","408","410","412","414","416","418","420","422","424","426","428","430","402","422","424","402","404","406","408","410","412","432","434","436","414","416","418","420"]},"In contrast to files, folders, and directories, the Items, Item Folders, and Categories of the present invention are not characteristically \u201cphysical\u201d in nature because they do not have conceptual equivalents of physical containers, and therefore Items may exist in more than one such location. The ability for Items to exist in more than one Item Folder location as well as being organized into Categories provides an enhanced and enriched degree of data manipulation and storage structure capabilities at the hardware\/software interface level, beyond that currently available in the art.","4. Schemas","a) Base Schema","To provide a universal foundation for the creation and use of Items, various embodiments of the storage platform of the present invention comprise a Base Schema that establishes a conceptual framework for creating and organizing Items and properties. The Base Schema defines certain special types of Items and properties, and the features of these special foundational types from which subtypes can be further derived. The use of this Base Schema allows a programmer to conceptually distinguish Items (and their respective types) from properties (and their respective types). Moreover, the Base Schema sets forth the foundational set of properties that all Items may possess as all Items (and their corresponding Item Types) are derived from this foundational Item in the Base Schema (and its corresponding Item Type).","As illustrated in , and in regard to several embodiments of the present invention, the Base Schema defines three top-level types: Item, Extension, and PropertyBase. As shown, the Item type is defined by the properties of this foundational \u201cItem\u201d Item type. In contrast, the top level property type \u201cPropertyBase\u201d has no predefined properties and is merely the anchor from which all other property types are derived and through which all derived property types are interrelated (being commonly derived from the single property type). The Extension type properties define which Item the extension extends as well as identification to distinguish one extension from another as an Item may have multiple extensions.","ItemFolder is a subtype of the Item Item type that, in addition to the properties inherited from Item, features a Relationship for establishing links to its members (if any), whereas both IdentityKey and Property are subtypes of PropertyBase. CategoryRef, in turn, is a subtype of IdentityKey.","b) Core Schema","Various embodiments of the storage platform of the present invention further comprise a Core Schema that provides a conceptual framework for top-level Items type structures.  is a block diagram illustrating Items in the Core Schema, and  is a block diagram illustrating the property types in the Core Schema. The distinction made between files with different extensions (*.com, *.exe, *.bat, *.sys, etc.) and other such criteria in file-and-folder-based systems is analogous to the function of the Core Schema. In the Item-based hardware\/software interface system, the Core Schema defines a set of core Item types that, directly (by Item type) or indirectly (by Item subtype), characterize all Items into one or more Core Schema Item types which the Item-based hardware\/software interface system understands and can directly process in a predetermined and predictable way. The predefined Item types reflect the most common Items in the Item-based hardware\/software interface system and thus a level of efficiency is gained by the Item-based hardware\/software interface system understanding these predefined Item types that comprise the Core Schema.","In certain embodiments, the Core Schema is not extendable\u2014that is, no additional Item types can be subtyped directly from the Item type in the Base Schema except for the specific predefined derived Item types that are part of the Core Schema. By preventing extensions to the Core Schema (that is, by preventing the addition of new Items to the Core Schema), the storage platform mandates the use of the Core Schema Item types since every subsequent Item type is necessarily a subtype of a Core Schema Item type. This structure enables a reasonable degree of flexibility in defining additional Item types while also preserving the benefits of having a predefined set of core Item types.","For various embodiments of the present invention, and in reference to , the specific Item types supported by the Core Schema may include one or more of the following:\n\n","Likewise, and in reference to , the specific property types supported by the Core Schema may include one or more of the following:\n\n","5. Relationships","Relationships are binary relationships where one Item is designated as source and the other Item as target. The source Item and the target Item are related by the relationship. The source Item generally controls the life-time of the relationship. That is, when the source Item is deleted, the relationship between the Items is also deleted.","Relationships are classified into: Containment and Reference relationships. The containment relationships control the life-time of the target Items, while the reference relationships do not provide any life-time management semantics.  illustrates the manner in which relationships are classified.","The Containment relationship types are further classified into Holding and Embedding relationships. When all holding relationships to an Item are removed, the Item is deleted. A holding relationship controls the life-time of the target through a reference counting mechanism. The embedding relationships enable modeling of compound Items and can be thought of as exclusive holding relationships. An Item can be a target of one or more holding relationships; but an Item can be target of exactly one embedding relationship. An Item that is a target of an embedding relationship can not be a target of any other holding or embedding relationships.","Reference relationships do not control the lifetime of the target Item. They may be dangling\u2014the target Item may not exist. Reference relationships can be used to model references to Items anywhere in the global Item name space (i.e. including remote data stores).","Fetching an Item does not automatically fetch its relationships. Applications must explicitly request the relationships of an Item. In addition, modifying a relationship does not modify the source or the target Item; similarly, adding a relationship does not affect the source\/target Item.","a) Relationship Declaration","The explicit relationship types are defined with the following elements:\n\n","The source Item is the owner of the relationship. While an Item designated as owner controls the life time of the relationship, the relationship itself is separate from the Items it relates. The storage platform API  provides mechanisms for exposing relationships associated with an Item.","Here is an example of a relationship declaration:",{"@attributes":{"id":"p-0162","num":"0192"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Relationship Name=\u201cEmployment\u201d BaseType=\u201cReference\u201d >"},{"entry":"\u2003\u2003<Source Name=\u201cEmployee\u201d ItemType=\u201cContact.Person\u201d\/>"},{"entry":"\u2003\u2003<Target Name=\u201cEmployer\u201d ItemType=\u201cContact.Organization\u201d"},{"entry":"\u2003\u2003\u2003ReferenceType=\u201cItemIDReference\u201d \/>"},{"entry":"\u2003\u2003<Property Name=\u201cStartDate\u201d Type=\u201cthe storage"},{"entry":"\u2003\u2003platformTypes.DateTime\u201d \/>"},{"entry":"\u2003\u2003<Property Name=\u201cEndDate\u201d Type=\u201cthe storage"},{"entry":"\u2003\u2003platformTypes.DateTime\u201d \/>"},{"entry":"\u2003\u2003<Property Name=\u201cOffice\u201d Type=\u201cthe storage"},{"entry":"\u2003\u2003platformTypes.DateTime\u201d \/>"},{"entry":"<\/Relationship>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"This is an example of a Reference relationship. The relationship can not be created if the person Item that is referenced by the source reference does not exist. Also, if the person Item is deleted, the relationship instances between the person and organization are deleted. However, if the Organization Item is deleted, the relationship is not deleted and it is dangling.","b) Holding Relationship","Holding relationships are used to model reference count based life-time management of the target Items.","An Item can be a source endpoint for zero or more relationships to Items. An Item that is not an embedded Item can be a target of in one or more holding relationships.","The target endpoint reference type must be ItemIDReference and it must reference an Item in the same store as the relationship instance.","Holding relationships enforce lifetime management of the target endpoint. The creation of a holding relationship instance and the Item that it is targeting is an atomic operation. Additional holding relationship instances can be created that are targeting the same Item. When the last holding relationship instance with a given Item as target endpoint is deleted the target Item is also deleted.","The types of the endpoint Items specified in the relationship declaration will generally be enforced when an instance of the relationship is created. The types of the endpoint Items can not be changed after the relationship is established.","Holding relationships play a key role in forming the Item namespace. They contain the \u201cName\u201d property that defines the name of the target Item relative to the source Item. This relative name is unique for all the holding relationships sourced from a given Item. The ordered list of this relative names starting from the root Item to a given Item forms the full name to the Item.","The holding relationships form a directed acyclic graph (DAG). When a holding relationship is created the system ensures that a cycle is not created, thus ensuring that the Item namespace forms a DAG.","While the holding relationship controls the life time of the target Item, it does not control the operational consistency of the target endpoint Item. The target Item is operationally independent from the Item that owns it through a holding relationship. Copy, Move, Backup and other operations on an Item that is a source of a holding relationship do not affect the Item that is a target of the same relationship\u2014for example that is, backing up a Folder Item does not automatically backup all the Items in the folder (targets of the FolderMember relationship).","The following is an example of a holding relationship:",{"@attributes":{"id":"p-0174","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Relationship Name=\u201cFolderMembers\u201d BaseType=\u201cHolding\u201d >"]},{"entry":[{},"\u2003\u2003<Source Name=\u201cFolder\u201d ItemType=\u201cBase.Folder\u201d\/>"]},{"entry":[{},"\u2003\u2003<Target Name=\u201cItem\u201d ItemType=\u201cBase.Item\u201d"]},{"entry":[{},"\u2003\u2003\u2003ReferenceType=\u201cItemIDReference\u201d \/>"]},{"entry":[{},"<\/Relationship>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The FolderMembers relationship enables the concept of a Folder as a generic collection of Items.","c) Embedding Relationships","Embedding relationships model the concept of exclusive control of the lifetime of the target Item. They enable the concept of compound Items.","The creation of an embedding relationship instance and the Item that it is targeting is an atomic operation. An Item can be a source of zero or more embedding relationship. However, an Item can be a target of one and only one embedding relationship. An Item that is a target of an embedding relationship can not be a target of a holding relationship.","The target endpoint reference type must be ItemIDReference and it must reference an Item in the same data store as the relationship instance.","The types of the endpoint Items specified in the relationship declaration will generally be enforced when an instance of the relationship is created. The types of the endpoint Items can not be changed after the relationship is established.","Embedding relationships control the operational consistency of the target endpoint. For example the operation of serializing of an Item may include serialization of all the embedding relationships that source from that Item as well as all of their targets; copying an Item also copies all its embedded Items.","The following is an example declaration:",{"@attributes":{"id":"p-0183","num":"0213"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Relationship Name=\u201cArchiveMembers\u201d BaseType=\u201cEmbedding\u201d >"},{"entry":"\u2003\u2003<Source Name=\u201cArchive\u201d ItemType=\u201cZip.Archive\u201d \/>"},{"entry":"\u2003\u2003<Target Name=\u201cMember\u201d ItemType=\u201cBase.Item \u201d"},{"entry":"\u2003\u2003\u2003ReferenceType=\u201cItemIDReference\u201d \/>"},{"entry":"\u2003\u2003<Property Name=\u201cZipSize\u201d Type=\u201cthe storage"},{"entry":"\u2003\u2003platformTypes.bigint\u201d \/>"},{"entry":"\u2003\u2003<Property Name=\u201cSizeReduction\u201d Type=\u201cthe storage"},{"entry":"\u2003\u2003platformTypes.float\u201d \/>"},{"entry":"<\/Relationship>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"d) Reference Relationships","The reference relationship does not control life time of the Item it references. Even more, the reference relationships do not guarantee the existence of the target, nor do they guarantee the type of the target as specified in the relationship declaration. This means that the reference relationships can be dangling. Also, the reference relationship can reference Items in other data stores. Reference relationships can be thought of as a concept similar to links in web pages.","An example of reference relationship declaration is the following:",{"@attributes":{"id":"p-0187","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Relationship Name=\u201cDocumentAuthor\u201d BaseType=\u201cReference\u201d >"},{"entry":"\u2003\u2003<Sourc ItemType=\u201cDocument\u201d"},{"entry":"\u2003\u2003ItemType=\u201cBase.Document\u201d\/>"},{"entry":"\u2003\u2003<Target ItemType=\u201cAuthor\u201d ItemType=\u201cBase.Author\u201d"},{"entry":"\u2003\u2003\u2003ReferenceType=\u201cItemIDReference\u201d \/>"},{"entry":"\u2003\u2003<Property Type=\u201cRole\u201d Type=\u201cCore.CategoryRef\u201d \/>"},{"entry":"\u2003\u2003<Property Type=\u201cDisplayName\u201d Type=\u201cthe storage"},{"entry":"\u2003\u2003platformTypes.nvarchar(256)\u201d \/>"},{"entry":"<\/Relationship>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Any reference type is allowed in the target endpoint. The Items that participate in a reference relationship can be of any Item type.","Reference relationships are used to model most non-lifetime management relationships between Items. Since the existence of the target is not enforced, the reference relationship is convenient to model loosely-coupled relationships. The reference relationship can be used to target Items in other data stores including stores on other computers.","e) Rules and Constraints","The following additional rules and constraints apply for relationships:\n\n","f) Ordering of Relationships","In at least one embodiment, the storage platform of the present invention supports ordering of relationships. The ordering is achieved through a property named \u201cOrder\u201d in the base relationship definition. There is no uniqueness constraint on the Order field. The order of the relationships with the same \u201corder\u201d property value is not guaranteed, however it is guaranteed that they may be ordered after relationships with lower \u201corder\u201d value and before relationships with higher \u201corder\u201d field value.","Applications can get the relationships in the default order by ordering on the combination (SourceItemID, RelationshipID, Order). All relationship instances sourced from a given Item are ordered as a single collection regardless of the type of the relationships in the collection. This however guarantees that all relationships of a given type (e.g., FolderMembers) are an ordered subset of the relationship collection for a given Item.","The data store API  for manipulating relationships implement a set of operations that support ordering of relationships. The following terms are introduced to help explain the operations:\n\n","The operations include but are not limited to:\n\n","As previously mentioned, every Item must be a member of an Item Folder. In terms of Relationships, every Item must have a relationship with an Item Folder. In several embodiments of the present invention, certain relationships are represented by Relationships existing between the Items.","As implemented for various embodiments of the present invention, a Relationship provides a directed binary relationship that is \u201cextended\u201d by one Item (the source) to another Item (the target). A Relationship is owned by the source Item (the Item that extended it), and thus the Relationship is removed if the source is removed (e.g., the Relationship is deleted when the source Item is deleted). Moreover, in certain instances, a Relationship may share ownership of (co-own) the target Item, and such ownership might be reflected in the IsOwned property (or its equivalent) of the Relationship (as shown in  for the Relationship property type). In these embodiments, creation of a new IsOwned Relationship automatically increments a reference count on the target Item, and deletion of such a Relationship may decrement the reference count on the target Item. For these specific embodiments, Items continue to exist if they have a reference count greater than zero, and are automatically deleted if and when the count reaches zero. Again, an Item Folder is an Item that has (or is capable of having) a set of Relationships to other Items, these other Items comprising the membership of the Item Folder. Other actual implementations of Relationships are possible and anticipated by the present invention to achieve the functionality described herein.","Regardless of actual implementation, a Relationship is a selectable connection from one object to another. The ability for an Item to belong to more than one Item Folder, as well as to one or more Categories, and whether these Items, Folders, and Categories are public or private, is determined by the meanings given to the existence (or lack thereof) in an Item-based structure. These logical Relationships are the meanings assigned to a set of Relationships, regardless of physical implementation, which are specifically employed to achieve the functionality described herein. Logical Relationships are established between the Item and its Item Folder(s) or Categories (and vice versa) because, in essence, Item Folders and Categories are each a special type of Item. Consequently, Item Folders and Categories can be acted upon the same way as any other Item\u2014copied, added to an email message, embedded in a document, and so and so forth without limitation\u2014and Item Folders and Categories can be serialized and de-serialized (imported and exported) using the same mechanisms as for other Items. (For example, in XML all Items might have a serialization format, and this format applies equally to Item Folders, Categories, and Items.)","The aforementioned Relationships, which represent the relationship between an Item and it Item Folder(s) can logically extend from the Item to the Item Folder, from the Item Folder to the Item, or both. A Relationship that logically extends from an Item to an Item Folder denotes that the Item Folder is public to that Item and shares its membership information with that Item; conversely, the lack of a logical Relationship from an Item to an Item Folder denotes that the Item Folder is private to that Item and does not share its membership information with that Item. Similarly, a Relationship that logically extends from an Item Folder to an Item denotes that the Item is public and sharable to that Item Folder, whereas the lack of a logical Relationship from the Item Folder to the Item denotes that the Item is private and non-sharable. Consequently, when an Item Folder is exported to another system, it is the \u201cpublic\u201d Items that are shared in the new context, and when an Item searches its Items Folders for other, sharable Items, it is the \u201cpublic\u201d Item Folders that provide the Item with information regarding sharable Items that belong thereto.",{"@attributes":{"id":"p-0201","num":"0247"},"figref":"FIG. 9","b":["900","902","904","906","900","912","902","902","900","904","906","900","902","900","900","902","902","904","924","900","900","904","900","904","904","900","902","906","900","902","904","900","916","906","906","926","900","906","900","902","904","900","900","906"]},"As previously discussed, the Items in an Item Folder do not need to share a commonality because Item Folders are not \u201cdescribed.\u201d Categories, on the other hand, are described by a commonality that is common to all of its member Items. Consequently the membership of a Category is inherently limited to Items having the described commonality and, in certain embodiments, all Items meeting the description of a Category are automatically made members of the Category. Thus, whereas Item Folders allow trivial type structures to be represented by their membership, Categories allow membership based on the defined commonality.","Of course Category descriptions are logical in nature, and therefore a Category may be described by any logical representation of types, properties, and\/or values. For example, a logical representation for a Category may be its membership to comprise Items have one of two properties or both. If these described properties for the Category are \u201cA\u201d and \u201cB\u201d, then the Categories membership may comprise Items having property A but not B, Items having property B but not A, and Items having both properties A and B. This logical representation of properties is described by the logical operator \u201cOR\u201d where the set of members described by the Category are Items having property A OR B. Similar logical operands (including without limitation \u201cAND\u201d, \u201cXOR\u201d, and \u201cNOT\u201d alone or in combination) can also be used describe a category as will be appreciated by those of skill in the art.","Despite the distinction between Item Folders (not described) and Categories (described), Categories Relationship to Items and Items Relationship to Categories essentially the same way as disclosed herein above for Item Folders and Items in many embodiments of the present invention.",{"@attributes":{"id":"p-0205","num":"0251"},"figref":"FIG. 10","b":["1000","1002","1004","1006","1008","1008","1000","1000","1012","1002","1002","1000","1004","1006","1000","1002","1000","1000","1002","1002","1004","1024","1000","1000","1004","1000","1004","1004","1000","1002","1006","1000","1002","1004","1000","1016","1006","1006","1026","1000","1006","1000","1002","1004","1000","1000","1006"]},"Finally, because Categories and Item Folders are themselves Items, and Items may Relationship to each other, Categories may Relationship to Item Folders and vice versa, and Categories, Item Folders, and Items can Relationship to other Categories, Item Folders, and Item respectively in certain alternative embodiments. However, in various embodiments, Item Folder structures and\/or Category structures are prohibited, at the hardware\/software interface system level, from containing cycles. Where Item Folder and Category structures are akin to directed graphs, the embodiments that prohibit cycles are akin to directed acyclic graphs (DAGs) which, by mathematical definition in the art of graph theory, are directed graphs wherein no path starts and ends at the same vertex.","6. Extensibility","The storage platform is intended to be provided with an initial set of schemas , as described above. In addition, however, in at least some embodiments, the storage platform allows customers, including independent software vendor (ISVs), to create new schemas  (i.e. new Item and Nested Element types). This section addresses the mechanism for creating such schemas by extending the Item types and Nested Element types (or simply \u201cElement\u201d types) defined in the initial set of schemas .","Preferably, extension of the initial set of Item and Nested Element types is constrained as follows:\n\n","Since an Item type or Nested Element type defined by the initial set of storage platform schemas may not exactly match an ISV application's need, it is necessary to allow ISVs to customize the type. This is allowed with the notion of Extensions. Extensions are strongly typed instances but (a) they cannot exist independently and (b) they must be attached to an Item or Nested Element.","In addition to addressing the need for schema extensibility, Extensions are also intended to address the \u201cmulti-typing\u201d issue. Since, in some embodiments, the storage platform may not support multiple inheritance or overlapping subtypes, applications can use Extensions as a way to model overlapping type instances (e.g. Document is a legal document as well a secure document).","a) Item Extensions","To provide Item extensibility, the data model further defines an abstract type named Base.Extension. This is a root type for the hierarchy of extension types. Applications can subtype Base.Extension to create specific extension types.","The Base.Extension type is defined in the Base schema as follows:",{"@attributes":{"id":"p-0215","num":"0265"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Type Name=\u201cBase.Extension\u201d IsAbstract=\u201cTrue\u201d>"]},{"entry":[{},"\u2003\u2003<Propety Name=\u201cItemID\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Type=\u201cthe storage platformTypes.uniqueidentified\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Nullable=\u201cfalse\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003MultiValued=\u201cfalse\u201d\/>"]},{"entry":[{},"\u2003\u2003<Property Name=\u201cExtensionID\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Type=\u201cthe storage platformTypes.uniqueidentified\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Nullable=\u201cfalse\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003MultiValued=\u201cfalse\u201d\/>"]},{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The ItemID field contains the ItemID of the item that the extension is associated with. An Item with this ItemID must exist. The extension can not be created if the item with the given ItemID does not exist. When the Item is deleted all the extensions with the same ItemID are deleted. The tuple (ItemID,ExtensionID) uniquely identifies an extension instance.","The structure of an extension type is similar to that of an item type:\n\n","The following restrictions apply for extension types:\n\n","There are no constraints on the types of extensions that can be associated with a given Item type. Any extension type is allowed to extend any item type. When multiple extension instances are attached to an item, they are independent from each other in both structure and behavior.","The extension instances are stored and accessed separately from the item. All extension type instances are accessible from a global extension view. An efficient query can be composed that will return all the instances of a given type of extension regardless of what type of item they are associated with. The storage platform APIs provides a programming model that can store, retrieve and modify extensions on items.","The extension types can be type sub-typed using the storage platform single inheritance model. Deriving from an extension type creates a new extension type. The structure or the behavior of an extension cannot override or replace the structure or behaviors of the item type hierarchy. Similar to Item types, Extension type instances can be directly accessed through the view associated with the extension type. The ItemID of the extension indicates which item they belong to and can be used to retrieve the corresponding Item object from the global Item view. The extensions are considered part of the item for the purposes of operational consistency. The Copy\/Move, Backup\/Restore and other common operations that the storage platform defines may operate on the extensions as part of the item.","Consider the following example. A Contact type is defined in the Windows Type set.",{"@attributes":{"id":"p-0223","num":"0279"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Type Name=\u201cContact\u201d BaseType=\u201cBase.Item\u201d >"]},{"entry":[{},"\u2003\u2003<Property Name=\u201cName\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Type=\u201cString\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Nullable=\u201cfalse\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003MultiValued=\u201cfalse\u201d\/>"]},{"entry":[{},"\u2003\u2003<Property Name=\u201cAddress\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Type=\u201cAddress\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Nullable=\u201ctrue\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003MultiValued=\u201cfalse\u201d\/>"]},{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A CRM application developer would like to attach a CRM application extension to the contacts stored in the storage platform. The application developer would define a CRM extension that would contain the additional data structure that the application can manipulate.",{"@attributes":{"id":"p-0225","num":"0281"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Type Name=\u201cCRMExtension\u201d BaseType=\u201cBase.Extension\u201d >"]},{"entry":[{},"\u2003\u2003<Property Name=\u201cCustomerID\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Type=\u201cString\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Nullable=\u201cfalse\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003MultiValued=\u201cfalse\u201d\/>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"An HR application developer may want to also attach additional data with the Contact. This data is independent from the CRM application data. Again the application developer can create an extension",{"@attributes":{"id":"p-0227","num":"0283"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Type Name=\u201cHRExtension\u201d EBaseType=\u201cBase.Extension\u201d >"]},{"entry":[{},"\u2003\u2003<Property Name=\u201cEmployeeID\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Type=\u201cString\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Nullable=\u201cfalse\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003MultiValued=\u201cfalse\u201d\/>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"CRMExtension and HRExtension are two independent extensions that can be attached to Contact items. They are created and accessed independently of each other.","In the above example, the fields and methods of the CRMExtension type cannot override fields or methods of the Contact hierarchy. It should be noted that instances of the CRMExtension type can be attached to Item types other than Contact.","When the Contact item is retrieved, its item extensions are not automatically retrieved. Given a Contact item, its related item extensions can be accessed by querying the global extension view for extensions with the same ItemId.","All CRMExtension extensions in the system can be accessed through the CRMExtension type view, regardless of which item they belong to. All item extension of an item share the same item id. In the above example, the Contact item instance and the attached CRMExtension and HRExtension instances the same ItemID.","The following table summarizes the similarities and differences between Item, Extension and NestedElement types:",{"@attributes":{"id":"p-0233","num":"0289"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Item vs Item Extension vs NestedElement"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Item","Item Extension","NestedElement"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Item ID","Has its own","Shares the item id","Does not have its"]},{"entry":[{},"item id","of the item","own item id."]},{"entry":[{},{},{},"Nested element is"]},{"entry":[{},{},{},"part of the item"]},{"entry":["Storage","Item hierarchy is","Item extension","Stored with item"]},{"entry":[{},"stored in its own","hierarchy is stored"]},{"entry":[{},"tables","in its own tables"]},{"entry":["Query\/","Can query item","Can query item","Can generally be"]},{"entry":["Search","tables","extension tables","queried only"]},{"entry":[{},{},{},"within the"]},{"entry":[{},{},{},"containing item"]},{"entry":[{},{},{},"context"]},{"entry":["Query\/","Can search across","Can search across","Can generally"]},{"entry":["Search","all instances of an","all instances of an","only search"]},{"entry":["scope","item type","item extension type","within nested"]},{"entry":[{},{},{},"element type"]},{"entry":[{},{},{},"instances of"]},{"entry":[{},{},{},"a singe"]},{"entry":[{},{},{},"(containing) item"]},{"entry":["Relationship","Can have","No Relationships to","No Relationships"]},{"entry":["semantics","Relationships to","item extensions","to nested"]},{"entry":[{},"items",{},"elements"]},{"entry":["Association","Can be related to","Can generally only","Related to item"]},{"entry":["to items","other items via","be related via","via fields."]},{"entry":[{},"holding,","extensions. The","Nested elements"]},{"entry":[{},"embedded and","extension semantics","are part of the"]},{"entry":[{},"soft","is similar to","item"]},{"entry":[{},"Relationships","embedded item"]},{"entry":[{},{},"semantics"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"b) Extending NestedElement Types","Nested Element types are not extended with the same mechanism as the Item types. Extensions of nested elements are stored and accessed with the same mechanisms as fields of nested element types.","The data model defines a root for nested element types named Element:",{"@attributes":{"id":"p-0237","num":"0293"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Type Name=\u201cElement\u201d"},{"entry":"\u2003\u2003IsAbstract=\u201cTrue\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<Property Name=\u201cElementID\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Type=\u201cthe storage platformTypes.uniqueidentifier\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Nullable=\u201cfalse\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003MultiValued=\u201cfalse\u201d\/>"},{"entry":"<\/Type>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The NestedElement type inherits from this type. The NestedElement element type additionally defines a field that is a multi-set of Elements.",{"@attributes":{"id":"p-0239","num":"0295"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Type Name=\u201cNestedElement\u201d BaseType=\u201cBase.Element\u201d"]},{"entry":[{},"\u2003\u2003IsAbstract=\u201cTrue\u201d>"]},{"entry":[{},"\u2003\u2003<Property Name=\u201cExtensions\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Type=\u201cBase.Element\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003Nullable=\u201cfalse\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003MultiValued=\u201ctrue\u201d\/>"]},{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The NestedElement extensions are different from item extensions in the following ways:\n\n","The following table summarizes and compares Item Extensions and NestedElement extensions.",{"@attributes":{"id":"p-0242","num":"0302"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Item extensions vs NestedElement extensions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Item Extension","NestedElement Extension"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Storage","Item extension hierarchy","Stored like nested elements"]},{"entry":[{},"is stored in its own tables"]},{"entry":["Query\/Search","Can query item extension","Can generally only be"]},{"entry":[{},"tables","queried within the"]},{"entry":[{},{},"containing item context"]},{"entry":["Query\/Search","Can search across all","Can generally only search"]},{"entry":["scope","instances of an item","within nested element type"]},{"entry":[{},"extension type","instances of a singe"]},{"entry":[{},{},"(containing) item"]},{"entry":["Programmability","Need special extension","NestedElement extensions"]},{"entry":[{},"APIs and special","are like any other multi-"]},{"entry":[{},"querying on extension","valued field of nested"]},{"entry":[{},"tables","element; normal nested"]},{"entry":[{},{},"element type APIs are used"]},{"entry":["Behavior","Can associate behavior","No behavior permitted (?)"]},{"entry":["Relationship","No Relationships to item","No Relationships to"]},{"entry":["semantics","extensions","NestedElement extensions"]},{"entry":["Item ID","Shares the item id of the","Does not have its own item"]},{"entry":[{},"item","id. NestedElement"]},{"entry":[{},{},"extension is part of the"]},{"entry":[{},{},"item"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"D. Database Engine","As mentioned above, the data store is implemented on a database engine. In the present embodiment, the database engine comprises a relational database engine that implements the SQL query language, such as the Microsoft SQL Server engine, with object relational extensions. This section describes the mapping of the data model that the data store implements to the relational store and provides information on the logical API consumed by storage platform clients, in accordance with the present embodiment. It is understood, however, that a different mapping may be employed when a different database engine is employed. Indeed, in addition to implementing the storage platform conceptual data model on a relational database engine, it can also be implemented on other types of databases, e.g. object-oriented and XML databases.","An object-oriented (OO) database system provides persistence and transactions for programming language objects (e.g. C++, Java). The storage platform notion of an \u201citem\u201d maps well to an \u201cObject\u201d in object-oriented systems, though embedded collections would have to be added to Objects. Other storage platform type concepts, like inheritance and nested element types, also map object-oriented type systems. Object-oriented systems typically already support object identity; hence, item identity can be mapped to object identity. The item behaviors (operations) map well to object methods. However, object-oriented systems typically lack organizational capabilities and are poor in searching. Also, object-oriented systems to do not provide support for unstructured and semi-structured data. To support the complete storage platform data model described herein, concepts like relationships, folders, and extensions would need to be added to the object data model. In addition, mechanisms like promotions, synchronization, notifications, and security would need to be implemented.","Similar to object-oriented systems, XML databases, based on XSD (XML Schema Definition), support a single-inheritance based type system. The item type system of the present invention could be mapped to the XSD type model. XSDs also do not provide support for behaviors. The XSDs for items would have to be augmented with item behaviors. XML databases deal with single XSD documents and lack organization and broad search capabilities. As with object-oriented databases, to support the data model described herein, other concepts like relationships, and folders would need to be incorporated into such XML databases; also, mechanisms like synchronization, notifications and security would need to be implemented.","In regard to the following subsections, a few illustrations are provided to facilitate the general information disclosed:  is a diagram illustrating a notification mechanism.  is a diagram illustrating an example in which two transactions are both inserting a new record into the same B-Tree.  illustrates a data change detection process.  illustrates an exemplary directory tree.  shows an example in which an existing folder of a directory-based file system is moved into the storage platform data store.","1. Data Store Implementation Using UDTs","In the present embodiment, the relational database engine , which in one embodiment comprises the Microsoft SQL Server engine, supports built-in scalar types. Built-in scalar types are \u201cnative\u201d and \u201csimple\u201d. They are native in the sense that the user cannot define their own types and they are simple in that they cannot encapsulate a complex structure. User-defined types (hereinafter: UDTs) provide a mechanism for type extensibility above and beyond the native scalar type system by enabling users to extend the type system by defining complex, structured types. Once defined by a user, a UDT can be used anywhere in the type system that a built-in scalar type might be used","In accordance with an aspect of the present invention, the storage platform schemas are mapped to UDT classes in the database engine store. Data store Items are mapped to UDT classes deriving from the Base.Item type. Like Items, Extensions are also mapped to UDT classes and make use of inheritance. The root Extension type is Base.Extension, from which all Extension types are derived.","A UDT is a CLR class\u2014it has state (i.e., data fields) and behavior (i.e., routines). UDTs are defined using any of the managed languages\u2014C#, VB.NET, etc. UDT methods and operators can be invoked in T-SQL against an instance of that type. A UDT can be: the type of a column in a row, the type of a parameter of a routine in T-SQL, or the type of a variable in T-SQL","The mapping of storage platform schemas to UDT classes is fairly straightforward at a high level. Generally, a storage platform Schema is mapped to a CLR namespace. A storage platform Type is mapped to a CLR class. The CLR class inheritance mirrors the storage platform Type inheritance, and a storage platform Property is mapped to a CLR class property.","2. Item Mapping","Given the desirability for Items to be globally searchable, and the support in the relational database of the present embodiment for inheritance and type substitutability, one possible implementation for Item storage in the database store would be to store all Items in a single table with a column of type Base.Item. Using type substitutability, Items of all types could be stored, and searches could be filtered by Item type and sub-type using Yukon's \u201cis of (Type)\u201d operator.","However, due to concerns about the overhead associated with such an approach, in the present embodiment, the Items are divided by top-level type, such that Items of each type \u201cfamily\u201d are stored in a separate table. Under this partitioning scheme, a table is created for each Item type inheriting directly from Base.Item. Types inheriting below these are stored in the appropriate type family table using type substitutability, as described above. Only the first level of inheritance from Base.Item is treated specially.","A \u201cshadow\u201d table is used to store copies of globally searchable properties for all Items. This table may be maintained by the Update( ) method of the storage platform API, through which all data changes are made. Unlike the type family tables, this global Item table contains only the top-level scalar properties of the Item, not the full UDT Item object. The global Item table allows navigation to the Item object stored in a type family table by exposing an ItemID and a TypeID. The ItemID will generally uniquely identify the Item within the data store. The TypeID may be mapped using metadata, which is not described here, to a type name and the view containing the Item. Since finding an Item by its ItemID may be a common operation, both in the context of the global Item table and otherwise, a GetItem( ) function is provided to retrieve an Item object given an Item's ItemID.","For convenient access and to hide implementation details to the extent possible, all queries of Items might be against views built on the Item tables described above. Specifically, views may be created for each Item type against the appropriate type family table. These type views may select all Items of the associated type, including sub-types. For convenience, in addition to the UDT object, the views may expose columns for all of the top-level fields of that type, including inherited fields.","3. Extension Mapping","Extensions are very similar to Items and have some of the same requirements. As another root type supporting inheritance, Extensions are subject to many of the same considerations and trade-offs in storage. Because of this, a similar type family mapping is applied to Extensions, rather than a single table approach. Of course, in other embodiments, a single table approach could be used. In the present embodiment, an Extension is associated with exactly one Item by ItemID, and contains an ExtensionID that is unique in the context of the Item. As with Items, a function might be provided to retrieve an Extension given its identity, which consists of an ItemID and ExtensionID pair. A View is created for each Extension type, similar to the Item type views.","4. Nested Element Mapping","Nested Elements are types that can be embedded in Items, Extensions, Relationships, or other Nested Elements to form deeply nested structures. Like Items and Extensions, Nested Elements are implemented as UDT's, but they are stored within an Items and Extensions. Therefore, Nested Elements have no storage mapping beyond that of their Item and Extension containers. In other words, there are no tables in the system which directly store instances of NestedElement types, and there are no views dedicated specifically to Nested Elements.","5. Object Identity","Each entity in the data model, i.e., each Item, Extension and Relationship, has a unique key value. An Item is uniquely identified by its ItemId. An Extension is uniquely identified by a composite key of (ItemId, ExtensionId). A Relationship is identified by a composite key (ItemId, RelationshipId). ItemId, ExtensionId and RelationshipId are GUID values.","6. SQL Object Naming","All objects created in the data store can be stored in a SQL schema name derived from the storage platform schema name. For example, the storage platform Base schema (often called \u201cBase\u201d) may produce types in the \u201c[System.Storage]\u201d SQL schema such as \u201c[System.Storage].Item\u201d. Generated names are prefixed by a qualifier to eliminate naming conflicts. Where appropriate, an exclamation character (!) is used as a separator for each logical part of the name. The table below outlines the naming convention used for objects in the data store. Each schema element (Item, Extension, Relationship and View), is listed along with the decorated naming convention used to access instances in the data store.",{"@attributes":{"id":"p-0266","num":"0326"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Object","Name Decoration","Description","Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Master Item","Master!Item","Provides a","[System.Storage]."]},{"entry":["Search View",{},"summary of items","[Master!Item]"]},{"entry":[{},{},"in the current"]},{"entry":[{},{},"item domain."]},{"entry":["Typed Item","ItemType","Provides all","[AcmeCorp.Doc]."]},{"entry":["search view",{},"property data","[OfficeDoc]"]},{"entry":[{},{},"from item and any"]},{"entry":[{},{},"parent type(s)."]},{"entry":["Master","Master!Extension","Provides a","[System.Storage]."]},{"entry":["Extension",{},"summary of all","[Master!Extension]"]},{"entry":["Search View",{},"extensions in the"]},{"entry":[{},{},"current item"]},{"entry":[{},{},"domain."]},{"entry":["Typed","Extension!extensionType","Provides all","[AcmeCorp.Doc]."]},{"entry":["extension",{},"property data for","[Extension!StickyNote]"]},{"entry":["search view",{},"extension."]},{"entry":["Master","Master!Relationship","Provides a","[System.Storage]."]},{"entry":["Relationship",{},"summary of all","[Master!Relationship]"]},{"entry":["View",{},"relationships in"]},{"entry":[{},{},"the current item"]},{"entry":[{},{},"domain."]},{"entry":["Relationship","Relationship!relationship","Provides all data","[AcmeCorp.Doc]."]},{"entry":["view","Name","associated with a","[Relationship!AuthorsFrom"]},{"entry":[{},{},"given relationship","Document]"]},{"entry":["View","View!viewName","Provides the","[AcmeCorp.Doc]."]},{"entry":[{},{},"columns\/types","[View!DocumentTitles]"]},{"entry":[{},{},"based on the"]},{"entry":[{},{},"schema view"]},{"entry":[{},{},"definition."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"7. Column Naming","When mapping any object model into a store, the possibility of naming collisions occur due to additional information stored along with an application object. In order to avoid naming collisions, all non-type specific columns (columns which do not map directly to a named Property in a type declaration) is be prefixed with an underscore (_) character. In the present embodiment, underscore (_) characters are disallowed as the beginning character of any identifier property. Further, in order to unify naming between CLR and the data store, all properties of a storage platform types or schema element (relationship, etc.) should have a capitalized first character.","8. Search Views","Views are provided by the storage platform for searching stored content. A SQL view is provided for each Item and Extension type. Further, views are provided to support Relationships and Views (as defined by the Data Model). All SQL views and underlying tables in the storage platform are read-only. Data may be stored or changed using the Update( ) method of the storage platform API, as described more fully below.","Each view explicitly defined in a storage platform schema (defined by the schema designer, and not automatically generated by the storage platform) is accessible by the named SQL view [<schema-name>].[View!<view-name>]. For example, a view named \u201cBookSales\u201d in the schema \u201cAcmePublisher.Books\u201d would be accessible using the name \u201c[AcmePublisher.Books].[View!BookSales]\u201d. Since the output format of a view is custom on a per-view basis (defined by an arbitrary query provided by the party defining the view), the columns are directly mapped based on the schema view definition.","All SQL search views in the storage platform data store use the following ordering convention for columns:\n\n","Members of each type family are searchable using a series of Item views, with there being one view per Item type in the data store.  is a diagram illustrating the concept of an Item search view.","a) Item","Each Item search view contains a row for each instance of an Item of the specific type or its subtypes. For example, the view for Document could return instances of Document, LegalDocument and ReviewDocument. Given this example, the Item views can be conceptualized as shown in .","(1) Master Item Search View","Each instance of a storage platform data store defines a special Item view called the Master Item View. This view provides summary information on each Item in the data store. The view provides one column per Item type property, a column which described the type of the Item and several columns which are used to provide change tracking and synchronization information. The master item view is identified in a data store using the name \u201c[System.Storage].[Master!Item]\u201d.",{"@attributes":{"id":"p-0278","num":"0343"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","The storage platform identity of the Item"]},{"entry":["_TypeId","TypeId","The TypeId of the Item-identifies the exact type"]},{"entry":[{},{},"of the Item and can be used to retrieve"]},{"entry":[{},{},"information on the type using a Metadata"]},{"entry":[{},{},"catalog."]},{"entry":["_RootItemId","ItemId","The ItemId of the first non-embedded ancestor"]},{"entry":[{},{},"that controls the lifetime of this item."]},{"entry":["<global",". . .","Global change tracking information"]},{"entry":"change"},{"entry":"tracking>"},{"entry":["<Item props>","n\/a","One column per Item type property"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"(2) Typed Item Search Views","Each Item type also has a search view. While similar to the root Item view, this view also provides access to the Item object via the \u201c_Item\u201d column. Each typed item search view is identified in a data store using the name [schemaName].[itemTypeName]. For example [AcmeCorp.Doc].[OfficeDoc].",{"@attributes":{"id":"p-0281","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","The storage platform identity of the Item"]},{"entry":["<type change",". . .","Type change tracking information"]},{"entry":"tracking>"},{"entry":["<parent props>","<property","One column per parent property"]},{"entry":[{},"specific>"]},{"entry":["<item props>","<property","One column per exclusive property of this"]},{"entry":[{},"specific>","type"]},{"entry":["_Item","CLR type of","CLR object - type of declared Item"]},{"entry":[{},"Item"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"9.","a) Item Extensions","All Item Extensions in a WinFS Store are also accessible using search views.","(1) Master Extension Search View","Each instance of a data store defines a special Extension view called the Master Extension View. This view provides summary information on each Extension in the data store. The view has a column per Extension property, a column which describes the type of the Extension and several columns which are used to provide change tracking and synchronization information. The master extension view is identified in a data store using the name \u201c[System.Storage].[Master!Extension]\u201d.",{"@attributes":{"id":"p-0287","num":"0352"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","The storage platform identity of the"]},{"entry":[{},{},"Item with which this extension is"]},{"entry":[{},{},"associated"]},{"entry":["ExtensionId","ExtensionId","Id of this extension instance"]},{"entry":[{},"(GUID)"]},{"entry":["_TypeId","TypeId","The TypeId of the Extension-identifies"]},{"entry":[{},{},"the exact type of the extension and can"]},{"entry":[{},{},"be used to retrieve information on the"]},{"entry":[{},{},"extension using the Metadata catalog."]},{"entry":["<global change",". . .","Global change tracking information"]},{"entry":"tracking>"},{"entry":["<ext properties>","<property","One column per Extension"]},{"entry":[{},"specific>","type property"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"10.","(1) Typed Extension Search Views","Each Extension type also has a search view. While similar to the master extension view, this view also provides access to the Item object via the _Extension column. Each typed extension search view is identified in a data store using the name [schemaName].[Extension!extensionTypeName]. For example [AcmeCorp.Doc].[Extension!OfficeDocExt].",{"@attributes":{"id":"p-0291","num":"0356"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","The storage platform identity of the Item"]},{"entry":[{},{},"with which this extension is associated"]},{"entry":["ExtensionId","ExtensionId","Id of this extension instance"]},{"entry":[{},"(GUID)"]},{"entry":["<type change",". . .","Type change tracking information"]},{"entry":"tracking>"},{"entry":["<parent","<property","One column per parent property"]},{"entry":["props>","specific>"]},{"entry":["<ext props>","<property","One column per exclusive property of this"]},{"entry":[{},"specific>","type"]},{"entry":["_Extension","CLR type of","CLR object - type of declared Extension"]},{"entry":[{},"Extension"]},{"entry":[{},"instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"b) Nested Elements","All nested elements are stored within Items, Extensions or Relationships instances. As such, they are accessed by querying the appropriate Item, Extension, or Relationship search view.","c) Relationships","As discussed above, Relationships form the fundamental unit of linking between Items in a storage platform data store.","(1) Master Relationship Search View","Each data store provides a Master Relationship View. This view provides information on all relationship instances in the data store. The master relationship view is identified in a data store using the name \u201c[System.Storage].[Master!Relationship]\u201d.",{"@attributes":{"id":"p-0298","num":"0363"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","Identity of source"]},{"entry":[{},{},"endpoint (ItemId)"]},{"entry":["RelationshipId","RelationshipId","The id of the relationship"]},{"entry":[{},"(GUID)","instance"]},{"entry":["_RelTypeId","RelationshipTypeId","The RelTypeId of the"]},{"entry":[{},{},"Relationship-identifies"]},{"entry":[{},{},"the type of the relationship"]},{"entry":[{},{},"instance using the"]},{"entry":[{},{},"Metadata catalog."]},{"entry":["<global change",". . .","Global change tracking"]},{"entry":["tracking>",{},"information."]},{"entry":["TargetItemReference","ItemReference","Identity of target endpoint"]},{"entry":["_Relationship","Relationship","Instance of the Relationship"]},{"entry":[{},{},"object for this instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"(2) Relationship Instance Search Views","Each declared Relationship also has a search view which returns all instances of the particular relationship. While similar to the master relationship view, this view also provides named columns for each property of the relationship data. Each relationship instance search view is identified in a data store using the name [schemaName].[Relationship!relationshipName]. For example [AcmeCorp.Doc].[Relationship!DocumentAuthor].",{"@attributes":{"id":"p-0301","num":"0366"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","Identify of source"]},{"entry":[{},{},"endpoint (ItemId)"]},{"entry":["RelationshipId","RelationshipId","The id of the relationship"]},{"entry":[{},"(GUID)","instance"]},{"entry":["<type change",". . .","Type change tracking"]},{"entry":["tracking>",{},"information"]},{"entry":["TargetItemReference","ItemReference","Identity of target endpoint"]},{"entry":["<source name>","ItemId","Named property of source"]},{"entry":[{},{},"endpoint identity (alias"]},{"entry":[{},{},"for ItemId)"]},{"entry":["<target name>","ItemReference or","Named property of target"]},{"entry":[{},"derived class","endpoint identity (alias"]},{"entry":[{},{},"and cast for"]},{"entry":[{},{},"TargetItemReference)"]},{"entry":["<rel property>","<property","One column per property of"]},{"entry":[{},"specific>","the relationship definition"]},{"entry":["_Relationship","CLR type of","CLR object - type of declare"]},{"entry":[{},"Relationship","Relationship"]},{"entry":[{},"instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"d)","11. Updates","All views in the storage platform data store are read-only. In order to create a new instance of a data model element (item, extension or relationship), or to update an existing instance, the ProcessOperation or ProcessUpdategram methods of the storage platform API must be used. The ProcessOperation method is a single stored procedure defined by the data store which consumes an \u201coperation\u201d that details an action to be performed. The ProcessUpdategram method is a stored procedure which takes an ordered set of operations, known as an \u201cupdategram\u201d, which collectively detail a set of actions to be performed.","The operation format is extensible and provides various operations over the schema elements. Some common operations include:\n\n","12. Change Tracking & Tombstones","Change tracking and tombstone services are provided by the data store, as discussed more fully below. This section provides an outline of the change tracking information exposed in a data store.","a) Change Tracking","Each search view provided by the data store contains columns used to provide change tracking information; the columns are common across all Item, Extension and Relationship views. Storage platform Schema Views, defined explicitly by schema designers, do not automatically provide change tracking information\u2014such information is provided indirectly through the search views on which the view itself is built.","For each element in the data store, change tracking information is available from two places\u2014the \u201cmaster\u201d element view and the \u201ctyped\u201d element view. For example, change tracking information on the AcmeCorp.Document.Document Item type is available from the Master Item View \u201c[System.Storage].[Master!Item]\u201d and typed Item search view [AcmeCorp.Document].[Document].","(1) Change Tracking in \u201cMaster\u201d Search Views","Change tracking information in the master search views provides information on the creation and update versions of an element, information on which sync partner created the element, which sync partner last updated the element and the version numbers from each partner for creation and update. Partners in sync relationships (described below) are identified by partner key. A single UDT object named _ChangeTrackingInfo of type [System.Storage.Store].ChangeTrackingInfo contains all this information. The type is defined in the System.Storage schema. _ChangeTrackingInfo is available in all global search views for Item, Extension and Relationship. The type definition of ChangeTrackingInfo is:",{"@attributes":{"id":"p-0313","num":"0389"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Type Name=\u201cChangeTrackingInfo\u201d BaseType=\u201cBase.NestedElement\u201d>"},{"entry":"\u2003<FieldProperty Name=\u201cCreationLocalTS\u201d\u2003\u2003 Type="},{"entry":"\u2003\u201cSqlTypes.SqlInt64\u201d"},{"entry":"\u2003Nullable=\u201cFalse\u201d \/>"},{"entry":"\u2003<FieldProperty Name=\u201cCreatingPartnerKey\u201d"},{"entry":"\u2003Type=\u201cSqlTypes.SqlInt32\u201d\u2003\u2003 Nullable=\u201cFalse\u201d \/>"},{"entry":"\u2003<FieldProperty Name=\u201cCreatingPartnerTS\u201d"},{"entry":"\u2003Type=\u201cSqlTypes.SqlInt64\u201d\u2003\u2003 Nullable=\u201cFalse\u201d \/>"},{"entry":"\u2003<FieldProperty Name=\u201cLastUpdateLocalTS\u201d"},{"entry":"\u2003Type=\u201cSqlTypes.SqlInt64\u201d\u2003\u2003 Nullable=\u201cFalse\u201d \/>"},{"entry":"\u2003<FieldProperty Name=\u201cLastUpdatingPartnerKey\u201d"},{"entry":"\u2003Type=\u201cSqlTypes.SqlInt32\u201d\u2003\u2003 Nullable=\u201cFalse\u201d \/>"},{"entry":"\u2003<FieldProperty Name=\u201cLastUpdatingPartnerTS\u201d\u2003\u2003 Type="},{"entry":"\u2003\u201cSqlTypes.SqlInt64\u201d"},{"entry":"\u2003Nullable=\u201cFalse\u201d \/>"},{"entry":"<\/Type>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"These properties contain the following information:",{"@attributes":{"id":"p-0315","num":"0391"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Column","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["_CreationLocalTS","Creation time stamp by the local machine"]},{"entry":["_CreatingPartnerKey","PartnerKey of the partner who created"]},{"entry":[{},"this entity. If the entity was locally created,"]},{"entry":[{},"this is the local machine's PartnerKey."]},{"entry":["_CreatingPartnerTS","Timestamp of the time at which this entity"]},{"entry":[{},"was created at the partner corresponding to"]},{"entry":[{},"_CreatingPartnerKey."]},{"entry":["_LastUpdateLocalTS","Local timestamp corresponding to the update"]},{"entry":[{},"time at the local machine"]},{"entry":["_LastUpdatingPartnerKey","PartnerKey of the partner who last updated"]},{"entry":[{},"this entity. If the last update to the entity was"]},{"entry":[{},"done locally, this is the local machine's"]},{"entry":[{},"PartnerKey."]},{"entry":["_LastUpdatingPartnerTS","Timestamp of the time at which this entity"]},{"entry":[{},"was updated at the partner corresponding to"]},{"entry":[{},"_LastUpdatingPartnerKey."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(2) Change Tracking in \u201cTyped\u201d Search Views","In addition to providing the same information as the global search view, each typed search view provides additional information recording the sync state of each element in the sync topology.",{"@attributes":{"id":"p-0318","num":"0394"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<global change",". . .","Information from global change"]},{"entry":["tracking>",{},"tracking"]},{"entry":["_ChangeUnitVersions","MultiSet<ChangeUnitVersion>","Description of version numbers"]},{"entry":[{},{},"of the Change Units within the"]},{"entry":[{},{},"particular element"]},{"entry":["_ElementSyncMetadata","ElementSyncMetadata","Additional version-independent"]},{"entry":[{},{},"metadata about this item that is"]},{"entry":[{},{},"only of interest to the"]},{"entry":[{},{},"Synchronization runtime."]},{"entry":["_VersionSyncMetadata","VersionSyncMetadata","Additional version-specific"]},{"entry":[{},{},"metadata about this version that"]},{"entry":[{},{},"is only of interest to the"]},{"entry":[{},{},"Synchronization runtime"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"b) Tombstones","The data store provides tombstone information for Items, Extensions and Relationships. The tombstone views provide information about both live and tombstoned entities (items, extensions and relationships) in one place. The item and extension tombstone views do not provide access to the corresponding object, while the relationship tombstone view provides access to the relationship object (the relationship object is NULL in the case of a tombstoned relationship).","(1) Item Tombstones","Item tombstones are retrieved from the system via the view [System.Storage].[Tombstone!Item].",{"@attributes":{"id":"p-0323","num":"0399"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","Identity of the Item"]},{"entry":["_TypeID","TypeId","Type of the Item"]},{"entry":["<Item properties>",". . .","Properties defined for"]},{"entry":[{},{},"all items"]},{"entry":["_RootItemId","ItemId","ItemId of the first"]},{"entry":[{},{},"non-embedding item"]},{"entry":[{},{},"which contains this item."]},{"entry":["_ChangeTrackingInfo","CLR instance of","Change tracking"]},{"entry":[{},"type","information for this item"]},{"entry":[{},"ChangeTrackingInfo"]},{"entry":["_IsDeleted","BIT","This is a flag that is 0 for"]},{"entry":[{},{},"live items, and 1 for"]},{"entry":[{},{},"tombstoned items."]},{"entry":["_DeletionWallclock","UTCDATETIME","The UTC wall clock date"]},{"entry":[{},{},"time according to the"]},{"entry":[{},{},"partner which deleted the"]},{"entry":[{},{},"item. It is NULL if the"]},{"entry":[{},{},"Item is live."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"(2) Extension Tombstones","Extension tombstones are retrieved from the system using the view [System.Storage].[Tombstone!Extension]. Extension change tracking information is similar to that provided for Items with the addition of the ExtensionId property.",{"@attributes":{"id":"p-0326","num":"0402"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","Identity of the Item"]},{"entry":[{},{},"which owns the"]},{"entry":[{},{},"Extension"]},{"entry":["ExtensionId","ExtensionId","Extension Id of the"]},{"entry":[{},{},"Extension"]},{"entry":["_TypeID","TypeId","Type of the extension"]},{"entry":["_ChangeTrackingInfo","CLR instance of","Change tracking"]},{"entry":[{},"type","information for this"]},{"entry":[{},"ChangeTrackingInfo","extension"]},{"entry":["_IsDeleted","BIT","This is a flag that is 0 for"]},{"entry":[{},{},"live items, and 1"]},{"entry":[{},{},"for tombstoned"]},{"entry":[{},{},"extensions."]},{"entry":["_DeletionWallclock","UTCDATETIME","The UTC wall clock"]},{"entry":[{},{},"date time according to"]},{"entry":[{},{},"the partner which deleted"]},{"entry":[{},{},"the extension. It is NULL"]},{"entry":[{},{},"if the extension is live."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"(3) Relationships Tombstone","Relationship tombstones are retrieved from the system via the view [System.Storage].[Tombstone!Relationship]. Relationships tombstone information is similar to that provided for Extensions. However, additional information is provided on the target ItemRef of the relationship instance. In addition, the relationship object is also selected.",{"@attributes":{"id":"p-0329","num":"0405"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","Identity of the Item which"]},{"entry":[{},{},"owned the relationship"]},{"entry":[{},{},"(identity of relationship"]},{"entry":[{},{},"source endpoint)"]},{"entry":["RelationshipId","RelationshipId","RelationshipId of the"]},{"entry":[{},{},"relationship"]},{"entry":["_TypeID","TypeId","Type of the relationship"]},{"entry":["_ChangeTrackingInfo","CLR instance of","Change tracking"]},{"entry":[{},"type","information for this"]},{"entry":[{},"ChangeTrackingInfo","relationship"]},{"entry":["_IsDeleted","BIT","This is a flag that is 0 for"]},{"entry":[{},{},"live items, and 1 for"]},{"entry":[{},{},"tombstoned extensions."]},{"entry":["_DeletionWallclock","UTCDATETIME","The UTC wall clock date"]},{"entry":[{},{},"time according to the"]},{"entry":[{},{},"partner which deleted the"]},{"entry":[{},{},"relationship. It is NULL"]},{"entry":[{},{},"if the relationship is live."]},{"entry":["_Relationship","CLR instance of a","This is the relationship"]},{"entry":[{},"Relationship","object for live"]},{"entry":[{},{},"relationship. It is NULL"]},{"entry":[{},{},"for tombstoned"]},{"entry":[{},{},"relationships."]},{"entry":["TargetItemReference","ItemReference","Identity of target"]},{"entry":[{},{},"endpoint"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"(4) Tombstone Cleanup","In order to prevent unbounded growth of tombstone information, the data store provides a tombstone cleanup task. This task determines when tombstone information may be discarded. The task computes a bound on the local create\/update version and then truncates the tombstone information by discarding all earlier tombstone versions.","13. Helper APIs and Functions","The Base mapping also provides a number of helper functions. These functions are supplied to aid common operations over the data model.","a) Function [System.Storage].GetItem\n\n","b) Function [System.Storage].GetExtension\n\n","c) Function [System.Storage].GetRelationship\n\n","14. Metadata","There are two types of metadata represented in the Store: instance metadata (the type of an Item, etc), and type metadata.","a) Schema Metadata","Schema metadata is stored in the data store as instances of Item types from the Meta schema.","b) Instance Metadata","Instance metadata is used by an application to query for the type of an Item and finds the extensions associated with an Item. Given the ItemId for an Item, an application can query the global item view to return the type of the Item and use this value to query the Meta.Type view to return information on the declared type of the Item. For example,",{"@attributes":{"id":"p-0343","num":"0428"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Return metadata Item object for given Item instance"]},{"entry":[{},"\/\/"]},{"entry":[{},"SELECT m._Item AS metadataInfoObj"]},{"entry":[{},"FROM [System.Storage].[Item] i INNER JOIN [Meta].[Type] m"]},{"entry":[{},"ON i._TypeId = m.ItemId"]},{"entry":[{},"WHERE i.ItemId = @ItemId"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"E. Security","In general, all securable objects arrange their access rights using the access mask format shown in the . In this format, the low-order 16 bits are for object-specific access rights, the next 7 bits are for standard access rights, which apply to most types of objects, and the 4 high-order bits are used to specify generic access rights that each object type can map to a set of standard and object-specific rights. The ACCESS_SYSTEM_SECURITY bit corresponds to the right to access the object's SACL.","In the access mask structure of , item specific rights are placed in the Object Specific Rights section (low order 16-bits). Because in the present embodiment, the storage platform exposes two sets of APIs to administer security\u2014Win32 and the storage platform API, the file system object specific rights must be considered in order to motivate the design of the storage platform object specific rights.","The security model for the storage platform of the present invention is fully described in the related applications incorporated by reference earlier herein. In this regard,  (parts a, b, and c) depicts a new identically protected security region being carved out of an existing security region, in accordance with one embodiment of a security model.","F. Notifications and Change Tracking","According to another aspect of the present invention, the storage platform provides a notifications capability that allows applications to track data changes. This feature is primarily intended for applications which maintain volatile state or execute business logic on data change events. Applications register for notifications on items, item extensions and item relationships. Notifications are delivered asynchronously after data changes have been committed. Applications may filter notifications by item, extension and relationship type as well as type of operation.","According to one embodiment, the storage platform API  provides two kinds of interfaces for notifications. First, applications register for simple data change events triggered by changes to items, item extensions and item relationships. Second, applications create \u201cwatcher\u201d objects to monitor sets of items, item extensions and relationships between items. The state of a watcher object can be saved and re-created after a system failure or after a system has gone off-line for an extended period of time. A single notification may reflect multiple updates.","Additional details regarding this functionality can be found in the related applications incorporated by reference earlier herein.","G. Traditional File System Interoperability","As mentioned above, the storage platform of the present invention is, in at least some embodiments, intended to be embodied as an integral part of the hardware\/software interface system of a computer system. For example, the storage platform of the present invention may be embodied as an integral part of an operating system, such as the Microsoft Windows family of operating systems. In that capacity, the storage platform API becomes a part of the operating system APIs through which application programs interact with the operating system. Thus, the storage platform becomes the means through which application programs store information on the operating system, and the Item based data model of the storage platform therefore replaces the traditional files system of such an operating system. For example, as embodied in the Microsoft Windows family of operating systems, the storage platform might replace the NTFS file system implemented in that operating system. Presently, application programs access the services of the NTFS file system through the Win32 APIs exposed by the Windows family of operating systems.","Recognizing, however, that completely replacing the NTFS file system with the storage platform of the present invention would require recoding of existing Win32-based application programs and that such recoding may be undesirable, it would be beneficial for the storage platform of the present invention to provide some interoperability with existing file systems, such as NTFS. In one embodiment of the present invention, therefore, the storage platform enables application programs which rely on the Win32 programming model to access the contents of both the data store of the storage platform as well as the traditional NTFS file system. To this end, the storage platform uses a naming convention that is a superset of the Win32 naming conventions to facilitate easy interoperability. Further, the storage platform supports accessing files and directories stored in a storage platform volume through the Win32 API.","Additional details regarding this functionality can be found in the related applications incorporated by reference earlier herein.","H. Storage Platform API","The storage platform comprises an API that enables application programs to access the features and capabilities of the storage platform discussed above and to access items stored in the data store. This section describes one embodiment of a storage platform API of the storage platform of the present invention. Details regarding this functionality can be found in the related applications incorporated by reference earlier herein, with some of this information summarized below for convenience.","Referring to , a Containment Folder is an item which contains holding Relationships to other Items and is the equivalent of the common concept of a file system folder. Each Item is \u201ccontained\u201d within at least one containment folder.",{"@attributes":{"id":"p-0359","num":"0444"},"figref":"FIG. 19","b":["1900","302","1900","340","302","340","322","332","350","350","350","322"],"i":["a","b","c"]},{"@attributes":{"id":"p-0360","num":"0445"},"figref":"FIG. 20","b":["2002","2004","2006","2008"]},"The hierarchy of classes resulting from a given schema directly reflects the hierarchy of types in that schema. As an example, consider the Item types defined in the Contacts schema as shown in  and .",{"@attributes":{"id":"p-0362","num":"0447"},"figref":"FIG. 22","ul":{"@attributes":{"id":"ul0035","list-style":"none"},"li":{"@attributes":{"id":"ul0035-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":["1. An application , , or binds to an item in the storage platform.","2. The framework  creates an ItemContext object  corresponding to the bound item and returns it to the application.","3. The application submits a Find on this ItemContext to get a collection of Items; the returned collection is conceptually an object graph  (due to relationships).","4. The application changes, deletes, and inserts data.","5. The application saves the changes by calling the Update( ) method."]}}}},{"@attributes":{"id":"p-0363","num":"0453"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0364","num":"0454"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0365","num":"0455"},"figref":["FIG. 25","FIG. 25"]},"In regard to APIs, a programming interface (or more simply, interface) may be viewed as any mechanism, process, protocol for enabling one or more segment(s) of code to communicate with or access the functionality provided by one or more other segment(s) of code. Alternatively, a programming interface may be viewed as one or more mechanism(s), method(s), function call(s), module(s), object(s), etc. of a component of a system capable of communicative coupling to one or more mechanism(s), method(s), function call(s), module(s), etc. of other component(s). The term \u201csegment of code\u201d in the preceding sentence is intended to include one or more instructions or lines of code, and includes, e.g., code modules, objects, subroutines, functions, and so on, regardless of the terminology applied or whether the code segments are separately compiled, or whether the code segments are provided as source, intermediate, or object code, whether the code segments are utilized in a runtime system or process, or whether they are located on the same or different machines or distributed across multiple machines, or whether the functionality represented by the segments of code are implemented wholly in software, wholly in hardware, or a combination of hardware and software.","Notionally, a programming interface may be viewed generically, as shown in  or .  illustrates an interface Interface as a conduit through which first and second code segments communicate.  illustrates an interface as comprising interface objects I and I (which may or may not be part of the first and second code segments), which enable first and second code segments of a system to communicate via medium M. In the view of , one may consider interface objects I and I as separate interfaces of the same system and one may also consider that objects I and I plus medium M comprise the interface. Although  show bi-directional flow and interfaces on each side of the flow, certain implementations may only have information flow in one direction (or no information flow as described below) or may only have an interface object on one side. By way of example, and not limitation, terms such as application programming interface (API), entry point, method, function, subroutine, remote procedure call, and component object model (COM) interface, are encompassed within the definition of programming interface.","Aspects of such a programming interface may include the method whereby the first code segment transmits information (where \u201cinformation\u201d is used in its broadest sense and includes data, commands, requests, etc.) to the second code segment; the method whereby the second code segment receives the information; and the structure, sequence, syntax, organization, schema, timing and content of the information. In this regard, the underlying transport medium itself may be unimportant to the operation of the interface, whether the medium be wired or wireless, or a combination of both, as long as the information is transported in the manner defined by the interface. In certain situations, information may not be passed in one or both directions in the conventional sense, as the information transfer may be either via another mechanism (e.g. information placed in a buffer, file, etc. separate from information flow between the code segments) or non-existent, as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation, e.g., depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration, and so this list should be considered illustrative and non-limiting.","This notion of a programming interface is known to those skilled in the art and is clear from the foregoing detailed description of the invention. There are, however, other ways to implement a programming interface, and, unless expressly excluded, these too are intended to be encompassed by the claims set forth at the end of this specification. Such other ways may appear to be more sophisticated or complex than the simplistic view of , but they nonetheless perform a similar function to accomplish the same overall result. We will now briefly describe some illustrative alternative implementations of a programming interface.","Factoring: A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown, some interfaces can be described in terms of divisible sets of functionality. Thus, the interface functionality of  may be factored to achieve the same result, just as one may mathematically provide 24, or 2 times 2 time 3 times 2. Accordingly, as illustrated in , the function provided by interface Interface may be subdivided to convert the communications of the interface into multiple interfaces InterfaceA, Interface B, Interface C, etc. while achieving the same result. As illustrated in , the function provided by interface I may be subdivided into multiple interfaces I, I, I, etc. while achieving the same result. Similarly, interface I of the second code segment which receives information from the first code segment may be factored into multiple interfaces I, I, I, etc. When factoring, the number of interfaces included with the 1st code segment need not match the number of interfaces included with the 2nd code segment. In either of the cases of , the functional spirit of interfaces Interface and I remain the same as with , respectively. The factoring of interfaces may also follow associative, commutative, and other mathematical properties such that the factoring may be difficult to recognize. For instance, ordering of operations may be unimportant, and consequently, a function carried out by an interface may be carried out well in advance of reaching the interface, by another piece of code or interface, or performed by a separate component of the system. Moreover, one of ordinary skill in the programming arts can appreciate that there are a variety of ways of making different function calls that achieve the same result.","Redefinition: In some cases, it may be possible to ignore, add or redefine certain aspects (e.g., parameters) of a programming interface while still accomplishing the intended result. This is illustrated in . For example, assume interface Interface of  includes a function call Square(input, precision, output), a call that includes three parameters, input, precision and output, and which is issued from the 1st Code Segment to the 2nd Code Segment. If the middle parameter precision is of no concern in a given scenario, as shown in , it could just as well be ignored or even replaced with a meaningless (in this situation) parameter. One may also add an additional parameter of no concern. In either event, the functionality of square can be achieved, so long as output is returned after input is squared by the second code segment. Precision may very well be a meaningful parameter to some downstream or other portion of the computing system; however, once it is recognized that precision is not necessary for the narrow purpose of calculating the square, it may be replaced or ignored. For example, instead of passing a valid precision value, a meaningless value such as a birth date could be passed without adversely affecting the result. Similarly, as shown in , interface I is replaced by interface I\u2032, redefined to ignore or add parameters to the interface. Interface I may similarly be redefined as interface I\u2032, redefined to ignore unnecessary parameters, or parameters that may be processed elsewhere. The point here is that in some cases a programming interface may include aspects, such as parameters, that are not needed for some purpose, and so they may be ignored or redefined, or processed elsewhere for other purposes.","Inline Coding: It may also be feasible to merge some or all of the functionality of two separate code modules such that the \u201cinterface\u201d between them changes form. For example, the functionality of  may be converted to the functionality of , respectively. In , the previous 1st and 2nd Code Segments of  are merged into a module containing both of them. In this case, the code segments may still be communicating with each other but the interface may be adapted to a form which is more suitable to the single module. Thus, for example, formal Call and Return statements may no longer be necessary, but similar processing or response(s) pursuant to interface Interface may still be in effect. Similarly, shown in , part (or all) of interface  from  may be written inline into interface I to form interface I\u2033. As illustrated, interface I is divided into Iand I, and interface portion Ihas been coded in-line with interface I to form interface I\u2033. For a concrete example, consider that the interface I from  performs a function call square (input, output), which is received by interface I, which after processing the value passed with input (to square it) by the second code segment, passes back the squared result with output. In such a case, the processing performed by the second code segment (squaring input) can be performed by the first code segment without a call to the interface.","Divorce: A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown in , one or more piece(s) of middleware (Divorce Interface(s), since they divorce functionality and\/or interface functions from the original interface) are provided to convert the communications on the first interface, Interface, to conform them to a different interface, in this case interfaces InterfaceA, InterfaceB and InterfaceC. This might be done, e.g., where there is an installed base of applications designed to communicate with, say, an operating system in accordance with an Interface protocol, but then the operating system is changed to use a different interface, in this case interfaces InterfaceA, InterfaceB and InterfaceC. The point is that the original interface used by the 2nd Code Segment is changed such that it is no longer compatible with the interface used by the 1st Code Segment, and so an intermediary is used to make the old and new interfaces compatible. Similarly, as shown in , a third code segment can be introduced with divorce interface DI to receive the communications from interface I and with divorce interface DI to transmit the interface functionality to, for example, interfaces Iand I, redesigned to work with DI, but to provide the same functional result. Similarly, DI and DI may work together to translate the functionality of interfaces I and I of  to a new operating system, while providing the same or similar functional result.","Rewriting: Yet another possible variant is to dynamically rewrite the code to replace the interface functionality with something else but which achieves the same overall result. For example, there may be a system in which a code segment presented in an intermediate language (e.g. Microsoft IL, Java ByteCode, etc.) is provided to a Just-in-Time (JIT) compiler or interpreter in an execution environment (such as that provided by the .Net framework, the Java runtime environment, or other similar runtime type environments). The JIT compiler may be written so as to dynamically convert the communications from the 1st Code Segment to the 2nd Code Segment, i.e., to conform them to a different interface as may be required by the 2nd Code Segment (either the original or a different 2nd Code Segment). This is depicted in . As can be seen in , this approach is similar to the Divorce scenario described above. It might be done, e.g., where an installed base of applications are designed to communicate with an operating system in accordance with an Interface  protocol, but then the operating system is changed to use a different interface. The JIT Compiler could be used to conform the communications on the fly from the installed-base applications to the new interface of the operating system. As depicted in , this approach of dynamically rewriting the interface(s) may be applied to dynamically factor, or otherwise alter the interface(s) as well.","It should also be noted that the above-described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways, serially and\/or in parallel, or with other intervening code. Thus, the alternative embodiments presented above are not mutually exclusive and may be mixed, matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in . It is also noted that, as with most programming constructs, there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein, but nonetheless are represented by the spirit and scope of the invention, i.e., it is noted that it is at least partly the functionality represented by, and the advantageous results enabled by, an interface that underlie the value of an interface.","III. Synchronization API","Several approaches to synchronization are possible in an Item-based hardware\/software interface system.","A. Synchronization Overview","For several embodiments of the present invention, and in regard to , the storage platform provides a synchronization service  that (i) allows multiple instances of the storage platform (each with its own data store ) to synchronize parts of their content according to a flexible set of rules, and (ii) provides an infrastructure for third parties to synchronize the data store of the storage platform of the present invention with with other data sources that implement proprietary protocols.","Storage-platform-to-storage-platform synchronization occurs among a group of participating \u201creplicas.\u201d For example, with reference to , it may be desirable to provide synchronization between the data store  of the storage platform  with another remote data store  under the control of another instance of the storage platform, perhaps running on a different computer system. The total membership of this group is not necessarily known to any given replica at any given time.","Different replicas can make the changes independently (i.e., concurrently). The process of synchronization is defined as making every replica aware of the changes made by other replicas. This synchronization capability is inherently multi-master (that is, peer-to-peer).","The synchronization capability of the present invention allows replicas to:\n\n","1. Storage-Platform-to-Storage-Platform Synchronization","The primary application of the synchronization service  of the storage platform of the present invention is to synchronize multiple instances of the storage platform (each with its own data store). The synchronization service operates at the level of the storage platform schemas (rather than the underlying tables of the database engine ). Thus, for example, \u201cScopes\u201d are used to define synchronization sets as discussed below.","The synchronization service operates on the principle of \u201cnet changes\u201d. Rather than recording and sending individual operations (such as with transactional replication), the synchronization service sends the end-result of those operations, thus often consolidating the results of multiple operations into a single resulting change.","The synchronization service does not in general respect transaction boundaries. In other words, if two changes are made to a storage platform data store in a single transaction, there is no guarantee that these changes are applied at all other replicas atomically\u2014one may show up without the other. The exception to this principle is that if two changes are made to the same Item in the same transaction, then these changes are guaranteed to be sent and applied to other replicas atomically. Thus, Items are the consistency units of the synchronization service.","a) Synchronization (Sync) Controlling Applications","Any application can connect to the synchronization service and initiate a sync operation. Such an application provides all of the parameters needed to perform synchronization (see sync profile below). Such applications are referred to herein as Sync Controlling Applications (SCAs).","When synchronizing two storage platform instances, sync is initiated on one side by an SCA. That SCA informs the local synchronization service to synchronize with the remote partner. On the other side, the synchronization service is awoken by the messages sent by the synchronization service from the originating machine. It responds based on the persistent configuration information (see mappings below) present on the destination machine. The synchronization service can be run on schedule or in response to events. In these cases, the synchronization service implementing the schedule becomes the SCA.","To enable synchronization, two steps need to be taken. First, the schema designer must annotate the storage platform schema with appropriate sync semantics (designating Change Units as described below). Second, synchronization must be properly configured on all of the machines having an instance of the storage platform that is to participate in the synchronization (as described below).","b) Schema Annotation","A fundamental concept of the synchronization service is that of a Change Unit. A Change Unit is a smallest piece of schema that is individually tracked by the storage platform. For every Change Unit, the synchronization service may be able to determine whether it changed or did not change since the last sync.","Designating Change Units in the schema serves several purposes. First, it determines how chatty the synchronization service is on the wire. When a change is made inside a Change Unit, the entire Change Unit is sent to the other replicas, since the synchronization service does not know which part of the Change Unit was changed. Second, it determines the granularity of conflict detection. When two concurrent changes (these terms are defined in detail in subsequent sections) are made to the same Change Unit, the synchronization service raises a conflict; on the other hand, if concurrent changes are made to different Change Units, then no conflict is raised and the changes are automatically merged. Third, it strongly affects the amount of metadata kept by the system. Much of the synchronization service metadata is kept per-Change Unit; thus, making Change Units smaller increases the overhead of sync.","Defining Change Units requires finding the right trade-offs. For that reason, the synchronization service allows schema designers to participate in the process.","In one embodiment, the synchronization service does not support Change Units that are larger than an element. However, it does support the ability for schema designers to specify smaller Change Units than an element\u2014namely, grouping multiple attributes of an element into a separate Change Unit. In that embodiment, this is accomplished using the following syntax:",{"@attributes":{"id":"p-0395","num":"0492"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Type Name=\u201cAppointment\u201d MajorVersion=\u201c1\u201d MinorVersion=\u201c0\u201d"]},{"entry":[{},"\u2003\u2003ExtendsType=\u201cBase.Item\u201d\u2003\u2003\u2003\u2003\u2003\u2003ExtendsVersion=\u201c1\u201d>"]},{"entry":[{},"\u2003<Field Name=\u201cMeetingStatus\u201d Type="]},{"entry":[{},"\u2003\u201cthe storage platformTypes.uniqueidentifier"]},{"entry":[{},"\u2003\u2003Nullable=\u201cFalse\u201d\/>"]},{"entry":[{},"\u2003<Field Name=\u201cOrganizerName\u201d Type="]},{"entry":[{},"\u2003\u201cthe storage platformTypes.nvarchar(512)\u201d"]},{"entry":[{},"\u2003\u2003Nullable=\u201cFalse\u201d\/>"]},{"entry":[{},"\u2003<Field Name=\u201cOrganizerEmail\u201d Type="]},{"entry":[{},"\u2003\u201cthe storage platformTypes.nvarchar(512)\u201d"]},{"entry":[{},"\u2003\u2003TypeMajorVersion=\u201c1\u201d \u2003\u2003\u2003\u2003\u2003MultiValued=\u201cTrue\u201d\/>"]},{"entry":[{},"\u2003\u2009..."]},{"entry":[{},"\u2003<ChangeUnit Name=\u201cCU_Status\u201d>"]},{"entry":[{},"\u2003\u2003<Field Name=\u201dMeetingStatus\u201d\/>"]},{"entry":[{},"\u2003<\/ChangeUnit>"]},{"entry":[{},"\u2003<ChangeUnit Name=\u201cCU_Organizer\u201d\/>"]},{"entry":[{},"\u2003\u2003<Field Name=\u201cOrganizerName\u201d \/>"]},{"entry":[{},"\u2003\u2003<Field Name=\u201cOrganizerEmail\u201d \/>"]},{"entry":[{},"\u2003<\/ChangeUnit>"]},{"entry":[{},"\u2003..."]},{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"c) Sync Configuration","A group of storage platform partners that wish to keep certain parts of their data in sync are referred to as a sync community. While the members of the community want to stay in sync, they do not necessarily represent the data in exactly the same way; in other words, sync partners may transform the data they are synchronizing.","In a peer-to-peer scenario, it is impractical for peers to maintain transformation mappings for all of their partners. Instead, the synchronization service takes the approach of defining \u201cCommunity Folders\u201d. A community folder is an abstraction that represents a hypothetical \u201cshared folder\u201d that all community members are synchronizing with.","This notion is best illustrated by an example. If Joe wants to keep My Documents folders of his several computers in sync, Joe defines a community folder called, say, JoesDocuments. Then, on every computer, Joe configures a mapping between the hypothetical JoesDocuments folder and the local My Documents folder. From this point on, when Joe's computers synchronize with each other, they talk in terms of documents in JoesDocuments, rather than their local items. This way, all Joe's computers understand each other without having to know who the others are\u2014the Community Folder becomes the lingua franca of the sync community.","Configuring the synchronization service consists of three steps: (1) defining mappings between local folders and community folders; (2) defining sync profiles that determine what gets synchronized (e.g. whom to sync with and which subsets should be sent and which received); and (3) defining the schedules on which different sync profiles should run, or running them manually.","(1) Community Folder\u2014Mappings","Community Folder mappings are stored as XML configuration files on individual machines. Each mapping has the following schema:","\/mappings\/communityFolder","This element names the community folder that this mapping is for. The name follows the syntax rules of Folders.","\/mappings\/localFolder","This element names the local folder that the mapping transforms into. The name follows the syntax rules of Folders. The folder must already exist for the mapping to be valid. The items within this folder are considered for synchronization per this mapping.","\/mappings\/transformations","This element defines how to transform items from the community folder to the local folder and back. If absent or empty, no transformations are performed. In particular, this means that no IDs are mapped. This configuration is primarily useful for creating a cache of a Folder.","\/mappings\/transformations\/mapIDs","This element requests that newly generated local IDs be assigned to all of the items mapped from the community folder, rather than reusing community IDs. The Sync Runtime will maintain ID mappings to convert items back and forth.","\/mappings\/transformations\/localRoot","This element requests that all root items in the community folder be made children of the specified root.","\/mappings\/runAs","This element controls under whose authority requests against this mapping are processed. If absent, sender is assumed.","\/mappings\/runAs\/sender","The presence of this element indicates that the sender of messages to this mapping must be impersonated, and requests processed under his credentials.","(2) Profiles","A Sync Profile is a total set of parameters needed to kick off synchronization. It is supplied by an SCA to the Sync Runtime to initiate sync. Sync profiles for storage platform-to-storage platform synchronization contain the following information:\n\n","The synchronization service provides a runtime CLR class that allows simple building of Sync Profiles. Profiles can also be serialized to and from XML files for easy storage (often alongside schedules). However, there is no standard place in the storage platform where all the profiles are stored; SCAs are welcome to construct a profile on the spot without ever persisting it. Note that there is no need to have a local mapping to initiate sync. All sync information can be specified in the profile. The mapping is, however, required in order to respond to sync requests initiated by the remote side.","(3) Schedules","In one embodiment, the synchronization service does not provide its own scheduling infrastructure. Instead, it relies on another component to perform this task\u2014the Windows Scheduler available with the Microsoft Windows operating system. The synchronization service includes a command-line utility that acts as an SCA and triggers synchronization based on a sync profile saved in an XML file. This utility makes it very easy to configure the Windows Scheduler to run synchronization either on schedule, or in response to events such as user logon or logoff.","d) Conflict Handling","Conflict handling in the synchronization service is divided into three stages: (1) conflict detection, which occurs at change application time\u2014this step determines if a change can be safely applied; (2) automatic conflict resolution and logging\u2014during this step (that takes place immediately after the conflict is detected) automatic conflict resolvers (or \u201cconflict handlers\u201d) are consulted to see if the conflict can be resolved\u2014if not, the conflict can be optionally logged; and (3) conflict inspection and resolution\u2014this step takes place if some conflicts have been logged, and occurs outside of the context of the sync session\u2014at this time, logged conflicts can be resolved and removed from the log. Vartious embodiments of the present invention direct to conflict handling are discussed in much greater detail herein below at Section III.","2. Synchronizing to Non-Storage Platform Data Stores","According to another aspect of the storage platform of the present invention\u2014and closely related to the various embodiments of the present invention described in Section IV herein below\u2014the storage platform provides an architecture for ISVs to implement Sync Adapters that allow the storage platform to synchronize to legacy systems such as Microsoft Exchange, AD, Hotmail, etc. Sync Adapters benefit from the many Sync Service provided by the synchronization service, as described below.","Despite the name, Sync Adapters do not need to be implemented as plug-ins into some storage platform architecture. If desired, a \u201csync adapter\u201d can simply be any application that utilizes the synchronization service runtime interfaces to obtain services such as change enumeration and application.","In order to make it simpler for others to configure and run synchronization to a given backend, Sync Adapter writers are encouraged to expose the standard Sync Adapter interface, which runs sync given the Sync Profile as described above. The profile provides configuration information to the adapter, some of which adapters pass to the Sync Runtime to control runtime services (e.g. the Folder to synchronize).","a) Sync Services","The synchronization service provides a number of sync services to adapter writers. For the rest of this section, it is convenient to refer to the machine on which the storage platform is doing synchronization as the \u201cclient\u201d and the non-storage platform backend that the adapter is talking to as the \u201cserver\u201d.","(1) Change Enumeration","Based on the change-tracking data maintained by the synchronization service, Change Enumeration allows sync adapters to easily enumerate the changes that have occurred to a data store Folder since the last time synchronization with this partner was attempted.","Changes are enumerated based on the concept of an \u201canchor\u201d\u2014an opaque structure that represents information about the last synchronization. The anchor takes the form of the storage platform Knowledge, as described in the proceeding sections. Sync adapters utilizing change enumeration services fall into two broad categories: those using \u201cstored anchors\u201d vs. those using \u201csupplied anchors\u201d.","The distinction is based on where the information about the last sync is stored\u2014on the client, or on the server. It is often easier for adapters to store this information on the client\u2014the backend is often not capable of conveniently storing this information. On the other hand, if multiple clients synchronize to the same backend, storing this information on the client is inefficient and in some cases incorrect\u2014it makes one client unaware of the changes that the other client has already pushed up to the server. If an adapter wants to use a server-stored anchor, the adapter needs to supply it back to the storage platform at the time of change enumeration.","In order for the storage platform to maintain the anchor (either for local or remote storage), the storage platform needs to be made aware of the changes that were successfully applied at the server. These and only these changes can be included in the anchor. During change enumeration, Sync Adapters use an Acknowledgement interface to report which changes were successfully applied. At the end of synchronization, adapters using supplied anchors must read the new anchor (which incorporates all of the successfully-applied changes) and send it to their backend.","Often, Adapters need to store adapter-specific data along with the items they insert into the storage platform data store. Common examples of such data are remote IDs and remote versions (timestamps). The synchronization service provides a mechanism for storing this data, and Change Enumeration provides a mechanism to receive this extra data along with the changes being returned. This eliminates the need for adapters to re-query the database in most cases.","(2) Change Application","Change Application allows Sync Adapters to apply changes received from their backend to the local storage platform. Adapters are expected to transform the changes to the storage platform schema.  illustrates the process by which storage platform API classes are generated from the storage platform Schema.","The primary function of change application is to automatically detect conflicts. As in the case of Storage Platform-to-Storage Platform sync, a conflict is defined as two overlapping changes being made without knowledge of each other. When adapters use Change Application, they must specify the anchor with respect to which conflict detection is performed. Change Application raises a conflict if an overlapping local change that is not covered by the adapter's knowledge is detected. Similar to Change Enumeration, adapters may use either stored or supplied anchors. Change Application supports efficient storage of adapter-specific metadata. Such data may be attached by the adapter to the changes being applied, and might be stored by the synchronization service. The data might be returned on next change enumeration.","(3) Conflict Resolution","The Conflict Resolution mechanisms described below (which include logging and automatic resolution options) are available to sync adapters as well. Sync adapters may specify the policy for conflict resolution when applying changes. If specified, conflicts may be passed on to the specified conflict handler and resolved (if possible). Conflicts can also be logged. It is possible that the adapter may detect a conflict when attempting to apply a local change to the backend. In such a case, the adapter may still pass the conflict on to the Sync Runtime to be resolved according to policy. In addition, Sync Adapters may request that any conflicts detected by the synchronization service be sent back to them for processing. This is particularly convenient in the case where the backend is capable of storing or resolving conflicts.","b) Adapter Implementation","While some \u201cadapters\u201d are simply applications utilizing runtime interfaces, adapters are encouraged to implement the standard adapter interfaces. These interfaces allow Sync Controlling Applications to: request that the adapter perform synchronization according to a given Sync Profile; cancel on-going synchronization; and receive progress reporting (percentage complete) on an ongoing sync.","3. Security","The synchronization service strives to introduce as little as possible into the security model implemented by the storage platform. Rather than defining new rights for synchronization, existing rights are used. Specifically,\n\n","The synchronization service does not maintain secure authorship information. When a change is made at replica A by user U and forwarded to replica B, the fact that the change was originally made at A (or by U) is lost. If B forwards this change to replica C, this is done under B's authority, not that of A. This leads to the following limitation: if a replica is not trusted to make its own changes to an item, it cannot forward changes made by others.","When the synchronization service is initiated, it is done by a Sync Controlling Application. The synchronization service impersonates the identity of the SCA and performs all operations (both locally and remotely) under that identity. To illustrate, observe that user U cannot cause the local synchronization service to retrieve changes from a remote storage platform for items that user U does not have read access.","4. Manageability","Monitoring a distributed community of replicas is a complex problem. The synchronization service may use a \u201csweep\u201d algorithm to collect and distribute information about the status of the replicas. The properties of the sweep algorithm ensure that information about all configured replicas is eventually collected and that failing (non-responsive) replicas are detected.","This community-wide monitoring information is made available at every replica. Monitoring tools can be run at an arbitrarily-chosen replica to examine this monitoring information and make administrative decisions. Any configuration changes must be made directly at the affected replicas.","B. Synchronization API Overview","In an increasingly distributed, digital world, individuals and workgroups often store information and data in a variety of different devices and locations. This has fueled the development of data synchronization services that can keep the information in these separate, often disparate, data stores synchronized at all times, with minimal user intervention.","The synchronization platform of the present invention, which is part of the rich storage platform described in Section II herein (a.k.a., \u201cWinFS\u201d), addresses three main objectives:\n\n","1. General Terminology","Herein below are some further refined definitions and key concepts relevant to later discussions herein this Section III.B:","Sync Replica: Most applications are only interested in tracking, enumerating and synchronizing changes for a given subset of items within the WinFS store. The set of items that take part in a synchronization operation is termed as a Synchronization Replica. A Replica is defined in terms of items contained within a given WinFS containment hierarchy (usually rooted at a Folder item). All synchronization services are carried out within the context of a given replica. WinFS Sync provides a mechanism to define, manage and cleanup replicas. Every replica has a GUID identifier that uniquely identifies it within a given WinFS store.","Sync Partner: A sync partner is defined as an entity capable of affecting changes on WinFS items, extensions and relationships. Thus, every WinFS store can be termed as a sync partner. When synchronizing with a non-WinFS store, the external data source (EDS) is also termed as a sync partner. Every partner has a GUID identifier that uniquely identifies it.","Sync Community: A synchronization community is defined as a collection of replicas that are kept in sync by means of peer-to-peer synchronization operations. These replicas may all be in the same WinFS store, different WinFS stores, or even manifest themselves as virtual replicas on non-WinFS stores. WinFS sync does not prescribe or mandate any specific topology for the community, especially if the only sync operations in the community are through the WinFS Sync service (WinFS adapter). Synchronization adapters (defined below) may introduce their own topology restrictions.","Change Tracking, Change Units and Versions: Every WinFS store tracks changes to all local WinFS Items, Extensions and Relationships. Changes are tracked at the level of change unit granularity defined in the schema. The top-level fields of any Item, Extension and Relationship type can be sub-divided by the schema designer into change units, with the smallest granularity being one top-level field. For change tracking purposes, every change unit is assigned a Version, where a version is a pair of sync partner id and a version number (the version number is a partner-specific monotonically increasing number). Versions are updated as changes happen in the store locally or as they are obtained from other replicas.","Sync Knowledge: Knowledge represents the state of a given sync replica at any time, i.e. it encapsulates meta-data about all the changes a given replica is aware of, either local or from other replicas. WinFS sync maintains and updates knowledge for sync replicas across sync operations. Important thing to note is that the Knowledge representation allows it to be interpreted with respect to the entire community and not just relative to the particular replica where the Knowledge is stored.","Sync Adapters: A synchronization adapter is a managed code application that accesses WinFS Sync services through the Sync Runtime API and enables synchronization of WinFS data to a non-WinFS data store. Depending on the requirements of the scenario, it's upto the adapter developer as to which subset of WinFS data and what WinFS data types to synchronize. The adapter is responsible for communication with the EDS, transforming WinFS schemas to and from EDS supported schemas and defining and managing its own configuration and metadata. Adapters are strongly encouraged to implement the WinFS Sync Adapter API to take advantage of the common configuration and control infrastructure for adapters provided by the WinFS Sync team. For more details, please refer to the WinFS Sync Adapter API spec [SADP] and the WinFS Sync Controller API [SCTRL] spec.","For adapters that synchronize WinFS data to external non-WinFS stores and cannot produce or maintain knowledge in WinFS format, WinFS Sync provides services to obtain remote knowledge that can be used for subsequent change enumeration or application operations. Depending on the capabilities of the backend store, the adapter may wish to store this remote knowledge on the backend or on the local WinFS store.","For simplicity, a synchronization \u201creplica\u201d is a structure that represents a set of data in a \u201cWinFS\u201d store that exists in a single logical location, whereas data on a non-\u201cWinFS\u201d store is called a \u201cdata source\u201d and generally requires the use of a adapter.","Remote Knowledge: When a given sync replica wishes to obtain changes from another replica it provides it's own knowledge as a baseline against which the other replica enumerates changes. Similarly, when a given replica wishes to send changes to another replica, it provides it's own knowledge as a baseline which can be used by the remote replica for detecting conflicts. This knowledge about the other replica that's provided during sync change enumeration and application is termed a Remote Knowledge.","2. Synchronization API Principals","For certain embodiments, the synchronization API separates into two parts: the synchronization configuration API and the synchronization controller API. The synchronization Configuration API enables applications to configure synchronization and to specify parameters for a particular synchronization session between two replicas. For a given synchronization session, configuration parameters include the set of Items to be synchronized, the type of synchronization (one-way or two-way), information about the remote data source, and the conflict resolution policy. The synchronization controller API initiates a synchronization session, cancels synchronization, and receives progress and error information about the on-going synchronization. Moreover, for specific embodiments where synchronization needs to be performed on a pre-determined schedule, such systems may include scheduling mechanism to customize scheduling.","Several embodiments of the present invention employ synchronization adapters for synchronizing information between \u201cWinFS\u201d and non-\u201cWinFS\u201d data sources. Examples of adapters include an adapter that synchronizes address book information between a \u201cWinFS\u201d contacts folder and a non-WinFS mailbox. In these instances, adapter developers might use the \u201cWinFS\u201d synchronization core services API described herein for accessing services provided by the \u201cWinFS\u201d synchronization platform in order to develop schema transformation code between the \u201cWinFS\u201d schema and the non-\u201cWinFS\u201d data source schema. Additionally, the adapter developer provides protocol support for communicating changes with the non-\u201cWinFS\u201d data source. A synchronization adapter is invoked and controlled by using the synchronization controller API and reports progress and errors using this API.","However, for certain embodiments of the present invention, when synchronizing \u201cWinFS\u201d data store with another \u201cWinFS\u201d data store, a synchronization adapter may be unnecessary if \u201cWinFS\u201d to \u201cWinFS\u201d synchronization services are integrated within the hardware\/software interface system. In any event, several such embodiments provides a set of synchronization services for both \u201cWinFS\u201d to \u201cWinFS\u201d and synchronization adapter solutions that include:\n\n","Referring to , which illustrates a three instances of a common data store and the components for synchronizing them. A first system  has a WinFS data store  comprising a WinFS-to-WinFS Sync services  and Core Sync Services , for WinFS-to-nonWinFS synchronization, which exposes  a Sync API  for utilization. Similar to the first system , a second system  has a WinFS data store  comprising a WinFS-to-WinFS Sync services  and Core Sync Services , for WinFS-to-nonWinFS synchronization, which exposes  a Sync API  for utilization. The first system  and the second system  synchronize  via their respective WinFS-to-WinFS Sync services  and . A third system , which is not a WinFS system, has an application for using WinFS Sync  to maintain a data source in a sync community with WinFS replicas. This application can utilize either a WinFS Sync Config\/Control service  to directly interface  with the WinFS data store  via the WinFS to WinFS synch services  (if it is so capable of virtualizing itself as a WinFS data store) or via a Sync Adapter  that interfaces  with the Sync API .","As illustrated in this figure, the first system  is aware of and directly synchronizes with both the second system  and third system . However, neither the second system  nor the third system  are aware of each other and, thus, do not synchronize their changes directly with each other but, instead, changes that occur on one system must propogate through the first system .","C. Synchronization API Services","Several embodiments of the present invention are directed to synchronization services comprising two foundational services: change enumeration and change application.","1. Change Enumeration","As previously discussed earlier herein, Change Enumeration allows sync adapters to easily enumerate the changes that have occurred to a data store Folder since the last time synchronization with this partner was attempted based on the change-tracking data maintained by the synchronization service. In regard to change enumeration, several embodiments of the present invention are directed to:\n\n","2. Change Application","As discussed earlier herein, change application allows Sync Adapters to apply changes received from their backend to the local storage platform since the adapters are expected to transform the changes to the storage platform schema. In regard to change application, several embodiments of the present invention are directed to:\n\n","3. Sample Code","The following is a code sample for how a FOO Sync adapter might interact with Sync Runtime (where all adapter specific functions are prefixed with FOO):",{"@attributes":{"id":"p-0471","num":"0598"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"ItemContext ctx = new ItemContext ( \u201c\\.\\\\System\\UserData\\dshah\\"},{"entry":"My Contacts\u201d, true );"},{"entry":"\/\/ Get the replica item id and remote partner id from the profile."},{"entry":"\/\/ Most adapters would get this information from the sync profile"},{"entry":"Guid replicaItemId = FOO_GetReplicaId( );"},{"entry":"Guid remotePartnerId = FOO_Get_RemotePartnerId( );"},{"entry":"\/\/"},{"entry":"\/\/ Lookup stored knowledge in the store using storedKnowledgeId like"},{"entry":"above."},{"entry":"\/\/"},{"entry":"ReplicaKnowledge remoteKnowledge = ...;"},{"entry":"\/\/"},{"entry":"\/\/ Initialize ReplicaSynchronizer"},{"entry":"\/\/"},{"entry":"ctx.ReplicaSynchronizer = new ReplicaSynchronizer( replicaItemId,"},{"entry":"remotePartnerId);"},{"entry":"ctx.ReplicaSynchronizer.RemoteKnowledge = remoteKnowledge;"},{"entry":"ChangeReader reader = ctx.ReplicaSynchronizer.GetChangeReader( );"},{"entry":"\/\/"},{"entry":"\/\/ Enumerate changes and process them"},{"entry":"\/\/"},{"entry":"bool bChangesToRead = true;"},{"entry":"while ( bChangesToRead )"},{"entry":"{"},{"entry":"\u2003ChangeCollection<object> changes = null;"},{"entry":"\u2003bChangesToRead = reader.ReadChanges( 10, out changes );"},{"entry":"\u2003foreach (object change in changes)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\/\/ Process enumerated object, adapter does it's own schema"},{"entry":"\u2003\u2003transform"},{"entry":"\u2003\u2003\/\/ and ID mapping. It may even retrieve additional objects from the"},{"entry":"\u2003\u2003\/\/ Ctx for this purpose and modify adapter metadata after change"},{"entry":"\u2003\u2003\/\/ has been applied to remote store"},{"entry":"\u2003\u2003ChangeStatus status ="},{"entry":"\u2003\u2003FOOProcessAndApplyToRemoteStore(change);"},{"entry":"\u2003\u2003\/\/ Update learned knowledge with status"},{"entry":"\u2003\u2003reader.AcknowledgeChange ( changeStatus );"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"remoteKnowledge ="},{"entry":"ctx.ReplicaSynchronizer.GetUpdatedRemoteKnowledge( );"},{"entry":"reader.Close( );"},{"entry":"\/\/"},{"entry":"\/\/ Save updated knowledge and adapter metadata, if any"},{"entry":"\/\/"},{"entry":"ctx.Update( );"},{"entry":"\/\/"},{"entry":"\/\/ Sample for change application, first initialize remote knowledge using"},{"entry":"\/\/ storedKnowledgeId as before."},{"entry":"\/\/"},{"entry":"remoteKnowledge = ...;"},{"entry":"ctx.ReplicaSynchronizer.ConflictPolicy = conflictPolicy;"},{"entry":"ctx.ReplicaSynchronizer.RemotePartnerId = remotePartnerId;"},{"entry":"ctx.ReplicaSynchronizer.RemoteKnowledge = remoteKnowledge;"},{"entry":"ctx.ReplicaSynchronizer.ChangeStatusEvent +="},{"entry":"FOO_OnChangeStatusEvent;"},{"entry":"\/\/"},{"entry":"\/\/ Obtain changes from remote store. Adapter is responsible for retrieving"},{"entry":"\/\/ it's backend specific metadata from the store. This can be an extension"},{"entry":"\/\/ on the replica."},{"entry":"\/\/"},{"entry":"object remoteAnchor = FOO_GetRemoteAnchorFromStore( );"},{"entry":"FOO_RemoteChangeCollection remoteChanges ="},{"entry":"FOO_GetRemoteChanges( remoteAnchor );"},{"entry":"\/\/"},{"entry":"\/\/ Fill in the change collection"},{"entry":"\/\/"},{"entry":"foreach( FOO_RemoteChange change in remoteChanges )"},{"entry":"{"},{"entry":"\u2003\/\/ Adapter responsible for doing ID mapping"},{"entry":"\u2003Guid localId = FOO_MapRemoteId ( change );"},{"entry":"\u2003\/\/ Let's say we're syncing Person objects"},{"entry":"\u2003ItemSearcher searcher = Person.GetSearcher( ctx );"},{"entry":"\u2003searcher.Filters.Add( \u201cPersonId=@localId\u201d );"},{"entry":"\u2003searcher.Parameters[\u201cPersonId\u201d] = localId;"},{"entry":"\u2003Person person = searcher.FindOne( );"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Adapter transforms remote changes to modifications on Person object"},{"entry":"\u2003\/\/ As part of this adapter may even make changes to item-level backend-"},{"entry":"\u2003\/\/ specific metadata for the remote object."},{"entry":"\u2003\/\/"},{"entry":"\u2003FOO_TransformRemoteToLocal ( remoteChange, person );"},{"entry":"}"},{"entry":"ctx.Update( );"},{"entry":"\/\/"},{"entry":"\/\/ Save the new remote anchor (this can be an extension on the replica)"},{"entry":"\/\/"},{"entry":"FOO_SaveRemoteAnchor( );"},{"entry":"\/\/"},{"entry":"\/\/ This is a regular WinFS API save since remote knowledge is not synced."},{"entry":"\/\/"},{"entry":"remoteKnowledge ="},{"entry":"ctx.ReplicaSynchronizer.GetUpdatedRemoteKnowledge( );"},{"entry":"ctx.Update( );"},{"entry":"ctx.Close( );"},{"entry":"\/\/"},{"entry":"\/\/ Adapter callback for processing application status callbacks"},{"entry":"\/\/"},{"entry":"void FOO_OnEntitySaved( object sender, ChangeStatusEventArgs args )"},{"entry":"{"},{"entry":"remoteAnchor.AcceptChange( args.ChangeStatus );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"4. Methods of API Synchronization","In one embodiment of the present invention, synchronization between a WinFS store and a non-WinFS store is accomplished is possible via the Synchronization APIs exposed by the WinFS-based hardware\/software interface system.","In one embodiment, all synchronization adapters are required to implement the synchronization adapter API, a common language runtime (CLR) managed API, so that they can be consistently deployed, initialized, and controlled. The adapter API provides:\n\n","There are two potential process models for adapters, depending on the requirements of the scenario. The adapter can execute in the same process space as the application invoking it or in a separate process all by itself. To execute in its own separate process, the adapter defines its own factory class, which is used to instantiate the adapter. The factory can return an instance of the adapter in the same process as the invoking application, or return a remote instance of the adapter in a different Microsoft common language runtime application domain or process. A default factory implementation is provided which instantiates the adapter in the same process. In practice, many adapters will run in the same process as the invoking application. The out of process model is usually required for one or both of the following reasons:\n\n","Referring to , one embodiment of the present invention presumes a simple adapter that is unaware of how state is calculated or it associated metadata is exchanged. In this embodiment, synchronization is achieved by the replica, in regard to the data source with which it wants to synchronize, by first, at step , determining which changes have occurred since it last synchronized with said data source, and the replica then transmits the incremental changes that have occurred since this last synchronization based on its present state information, and this present state information and incremental changes are to the data source via the adapter. At step , the adapter, upon receiving the change data from the replica in the previous step, implements as many changes to the data source as possible, tracks which changes are successful and which fail, and transmits the success-and-failure info back to WinFS (of the replica). The hardware\/software interface system of the replica (WinFS), at step , upon receiving the success-and-failure info from the replica, then calculates the new state information for the data source, stores this information for future use by its replica, and transmits this new state info back to the data source, that is, to the adapter for storage and subsequent use by the adapter.","D. Synchronization Hierarchy","As discussed earlier herein, each replica (and data source and\/or adapter) maintains an incremental and sequential enumeration of its changes, with each such change assigned a corresponding incremental and sequential change number (i.e., the first change is 1, the second change is 2, the third change is 3, and so on and so forth). Moreover, each replica also maintains the state information for the other known replicas (sync partners) in its sync community for tracking which changes it has received from these other replicas. By knowing the change number of the last change applied to first replica that came from a second replica, the first replica can then use this number thereafter to request, receive, or process only those changes that are greater than the number of this last applied change.  illustrate how changes are tracked, enumerated, and synchronized using this sequential change enumeration methodology.","In , sync partners A and B are relicas in a common sync community and are shown in their present state which, since no changes have yet been made, equates to a change number of zero for each replica\u2014for example, A and B for each replica respectively. (In this embodiment, a unique change number is used to reflect the initial state.) Each replica, aware of its own state and tracking the state of its sync partner, reflects this information in its \u201cvector\u201d as shown herein (which, as illustrated, lists the relicas own state first followed by the last known state of each of its partners based on the last synchronization or, in this case, initialization). The initial vector for replica A is \u201c[A, B]\u201d and the initial vector for replica B is \u201c[B, A]\u201d, and the two replicas are presently fully in sync.","In , replica A make a change and assigns that change the unique incremental change number A (the change number comprising a unique identification for the replica itself, \u201cA\u201d, as well as a unique and incremented number for the change on that replica, \u201c1\u201d). Replica B, on the other hand, makes two changes and assigns those changes the unique incremental change numbers of B and B respectively. At this point, and prior to the next synchronization, the replicas are now out of sync, and the vector for replica A is now [A, B] and the vector for replica B is [B, A] (which, again, reflects the last changes known).","In , replica A synchronizes with replica B by sending replica B its current vector to request changes (step 1). Replica B, receiving replica A's vector, calculates that it needs to send both changes, B and B, to replica A, and thus proceeds to do so (step 2). Replica A receives Replica B's changes (the change units, that is) identified as B and B, applies them, and updates its own vector to [A, B] (step 3).","In an alternative embodiment illustrated in , replica B, along with calculating and sending the correct changes to replica A (step 2), also determines, based on the replica A's vector, that there have been changes made to replica A that replica B does not have, and thus replica B also sends its own vector and a request for changes to replica A (step 2\u2032). Then, when Replica A receives Replica B's changes, applies them, and updates its own vector to [A, B] (during step 3), it also calculates which of its changes to send to replica B and transmits them as well (step 3\u2032). Replica B, upon receiving this information, makes the changes and updates it vector to [B, A] (step 4).","In regard to the foregoing examples, it is possible that a conflict might arise in a number of circumstances. For example, A and B may have been changes made to the same change unit, or A might be a deletion to the same change unit that B was modifying. While some of these conflicts can be resolved using the conflict resolution options discussed earlier herein, certain conflicts provide particularly difficult challenges, and these challenges and their solutions are discussed herein below in light of the present examples.","1. Synchronizing Previously \u201cOut of Scope\u201d Changes","In certain embodiments of the present invention, the scope of a replica may not be static. Consequently, replica A might effectively increase it scope with a change that creates a new relationship between an Item that is in its scope with an Item that is not within its scope. However, presuming that change units for the Item that is out-of-scope have not been synchronized between replicas A and B (because it has been out of the scope of synchronization for the replicas), a synchronization inconsistency may occur in regard to a version path for that particular item. The solution to this problem is for replica A to send to replica B all changes made to the out-of-scope Item along with the specific change that creates the relationship between the in-scope Item and the out-of-scope Item in replica A.","2. Synchronizing Parent-Child Disordering","In certain embodiments of the present invention, it is a general principal that, for synchronization, a parent Item is always sent before the child item (e.g., if Item K, a child, is embedded in Item J, a parent, Item K cannot be transmitted before Item J is transmitted). However, for replica A it is possible that, between synchronizations, both Items J and K are changed but where child Item K has a lower sorting number (based on, for example, the sequential precedence of its identification number) than child Item J, and thus would normally be transmitted first. One solution to this problem for synchronization in various embodiments of the present invention is to break the changes into two groups, one that reflects only changes made to Item K, and a second that reflects only the changes made to Item J, and send them in the correct order (that is, send the group of changes for the child Item K after sending those for the parent Item J).","3. Tombstones Propogation","As discussed earlier herein, tombstones are used to mark deleted change units for purposes of synchronization. However, because synchronization is asynchronous for multiple vectors in a sync community, these tombstones must propogate throughout the entire data platform. The problem is that, without accounting for tombstone propogration, replica A may create an Item and, during a sync with replica B, send that Item to replica B. Replica A may then delete the Item and, during a sync with replica C, it would send nothing regarding the Item because there is nothing to send (since the Item was deleted). Then, when replica B and replica C attempt to sync, replica C would receive the Item from replica B and there on B persist.","The solution to this problem for various embodiments of the present invention is for replica A to mark the deleted item with a tombstone. Then, when replica A deletes the Item, during a sync with replica C it sends the tombstone to replica B. When replica B and replica C then attempt to sync, replica B receives the tombstone as well and the Item is now completely eliminated from the sync community.","4. Root Tombstone Propogation","In P, if an Item X has a plurality of embedded items A, B, C, D, and E, then an interesting scenario arises when P first deletes these children Items and second the parent Item X between synchronizations (i.e., del A, del B, del C, del D, del E, and del X as six changes), because the same net result would have occurred it P had simply deleted the parent X (one change), in which case the embedded Items would be automatically deleted as well. In this regard, several embodiments of the present invention, upon synchronization, obtain an efficiency by recognizing deleting X would indeed be the equivalent of the six separate delete events, and thus P would only send to P the change unit corresponding to the deletion of X and allow this deletion to naturally propogate to the embedded Items of X in P.","5. Relationship Name Swapping","As previously discussed, Relationships have names, and thus it is possible for one replica (P) to swap the names for two Relationships (R and R) through the use of a temporary name element (X)\u2014that is, R's name is copied to X, R's name is then copied to R, X is then copied to R, and lastly X is deleted. However, because a partner replica (P) does not know about the temporary name element X, an error will occur during synchronization because, recognizing that R has a new name, P's attempt to change this name results in an error for using the same name for both R and R. One solution to this problem for various embodiments of the present invention is for P, upon receiving or recognizing this same-name error, to presume a possible name swap scenario and automatically create its own temporary name element (Y) and, if a subsequent change does indeed involve renaming R to the name in X, then it completes the swap (otherwise, it generates the scenario as a regular conflict event).","6. Reference Relationships","For synchronization between a replica P (running on a WinFS system) and a data source P (which is running on a non-WinFS system), a problem arises in the context of a dangling Relationship (supported by WinFS) is not supported by the non-WinFS system. This problem arises when two Items A and B having a relationship R on P, and P creates them in the order of A (as change unit P-) then R (as change unit P-) then B (as change unit P-). When R is created (P-), R is a dangling relationship, so when P applies these changes in order, an impermissible dangling relationship error results. The solution to this problem for several embodiments of the present invention is to instead reorder the changes such that all reference relationships (e.g., R) are sent after all other changes are sent from P to P, and thus the problem is avoided altogether by first creating the Items A and B and then relating them to each other with R.","E. Synchronization\u2014Conflict Handling","As mentioned earlier herein, conflict handling in the synchronization service is divided into three stages: (1) conflict detection, which occurs at change application time\u2014this step determines if a change can be safely applied; (2) automatic conflict resolution and logging-during this step (that takes place immediately after the conflict is detected) automatic conflict handlers are consulted to see if the conflict can be resolved\u2014if not, the conflict can be optionally logged; and (3) conflict inspection and resolution\u2014this step takes place if some conflicts have been logged, and occurs outside of the context of the sync session\u2014at this time, logged conflicts can be resolved and removed from the log.","Various embodiments of the present invention are specifically directed to conflict handling for conflicts that occur in a peer-to-peer synchronization system (such as for the synchronization system described herein above). The ability to correctly and efficiently handle conflicts minimizes data loss while retaining good usability and reduces the need for user intervention during synchronization. Several embodiments of the present invention are directed to a conflict handling schema comprising one or more of the follow conflict handling elements: (a) schematized representation of conflicts; (b) detection of conflicts; (c) logging of conflicts into a durable store; (d) automatic resolution of conflicts according to a flexible and configurable conflict resolution policy; (e) composable and extensible conflict handlers to filter and resolve conflicts; (f) automatic detection and removal of obsolete conflicts; and (g) programmatic conflict resolutions. Moreover, separate from the conflict handling schema, each of these conflict handling elements are themselves respresentative of additional embodiments of the present invention.","1. Conflict Types","In general, conflicts arise whenever there is an inability to synchronize data during a synchronization operation (a \u201cchange application failure\u201d). These failures may occur for a variety of reasons, although generally conflicts can be divided into two categories: constraint conflicts and knowledge conflicts.","a) Knowledge-Based Conflicts","A knowledge-based conflict occurs when two replicas make independent changes to the same Change Unit. Two changes are called independent if they are made without knowledge of each other\u2014in other words, the version of the first is not covered by the knowledge of the second and vice versa. The synchronization service automatically detects all such conflicts based on the replicas' knowledge as described above and handles these conflicts as described herein below. Some specific types of knowledge conflicts include Update-Delete, Delete-Update and Update-Update conflicts (where each name refers to the local action and the remote action in order; for example, the Update-Delete conflict is due to a local update and a remote delete to the same data).","It is sometimes helpful to think of conflicts as forks in the version history of a Change Unit. If no conflicts occur in the life of a Change Unit, its version history is a simple chain\u2014each change occurring after the previous one. In the case of a knowledge-based conflict, two changes occur in parallel, causing the chain to split and become a version tree.","In summary, knowledge conflicts occur as a result of knowledge and version processing. These are created by the WinFS Synchronization when changes having conflicting versions to information stored in the database are applied. The conflicts need to include the conflicting change information, as well as the version information. Most requirements for knowledge conflicts are also requirements for constraint conflicts. However, knowledge conflicts may be detected solely on the bases of sync versions and knowledge.","b) Constraint-Based Conflicts","There are cases where independent changes violate an integrity constraint when applied together. For instance, two replicas creating a file with the same name in the same directory could cause such a conflict to occur where constraints in the system (such as enforcement of unique item names within a folder) give rise to this type of constraint-based conflict.","Generally, a constraint-based conflict involves two independent changes, just as for a knowledge-based conflict; however, a constraint-based conflict comprises changes that do not affect the same Change Unit but instead affect different Change Units with a constraint existing between them. A constraint-based conflict can result from a single change, such as when syncing between two different types of systems where one has a constraint and the other does not. For example, if a system has a constraint that the maximum file name length is eight (8) characters long, and if that system receives a change to a file from another system that has no such constraint where the change is to the filename making it greater than eight characters long, a constraint conflict results (which occurred from the single change one a single machine).","Specific types of constraint conflicts include but are not limited to:\n\n","In summary, constraint conflicts are caused by failures to apply changes for various reasons. Such failures are termed constraint conflicts if they if they can be meaningfully handled, either in the form of a resolution that results in eventual convergence, or if they can be logged for ultimate resolution through user interaction. Failures that cannot be meaningfully handled other than being reported are simply called change application errors. For certain embodiments, all change application failures are treated as errors\u2014that is, there are no recognized constraint conflicts. And for certain embodiments, all conflicts that occur during Send synchronization are ignored as knowledge conflicts are expected to be re-presented at the next Receive synchronization. (Other failures that lead to non-convergence may also be ignored.)","2. Conflict Detection","The synchronization service detects constraint violations at change application time and raises constraint-based conflicts automatically. Resolving constraint-based conflicts usually requires custom code that modifies the changes in such as way as to not violate the constraint, and a synchronization service may or may not provide a general-purpose mechanism for doing so.","For various embodiments of the present invention, conflicts are detected per change unit by checking whether the local knowledge is aware of the remote version and vice versa. For knowledge-based conflicts, here are four conflict detection scenarios:\n\n","3. Conflict Processing","Conflicts may occur during either send or receive synchronization; however, if both partners in a one-way synchronization operation are similar (such as two similarly configured WinFS stores), the scenarios are symmetric and may be most easily handled on the receiving side by automatically resolving the conflict synchronously or logging the conflict for asynchronous resolution (automatic or manual).","Of course, there are situations in which the sending partner may need to handle a conflict, such as in a WinFS to non-WinFS synchronization. In such a case, constraint conflicts that may not travel back to the sending partner in a subsequent Receive synchronization. Further, the receiving partner may not have a conflict log, or may need to use the sender's conflict log for ease of management. In such cases, a change may be rejected altogether to force the sender to resolve the conflict (discussed herein below).","Sync initiators configure conflict resolution in their Sync Profiles. The synchronization service supports combining multiple conflict handlers in a single profile. Because the conflict handling mechanism is extensible, there are several ways to combine multiple conflict handlers. One particular method involves specifying a list of conflict handlers to be tried one after another until one of them succeeds (as described herein below). Another method involves associating conflict handlers with conflict types such as, for example, directing update-update knowledge-based conflicts to one conflict handler, and directing all the other conflicts to the log.","When a conflict is detected, the synchronization service can take one of three actions (selected by the sync initiator in the Sync Profile): (1) reject the change (2) resolve the conflict automatically; or (3) log the conflict into a conflict log.","a) Reject Changes","If a change is rejected, the synchronization service acts as if the change did not arrive at the replica and a negative acknowledgement is sent back to the originator. This resolution policy is primarily useful on head-less replicas (such as file servers) where logging conflicts is not feasible. Instead, such replicas force the others to deal with the conflicts by rejecting them.","b) Automatic Conflict Resolution","Automatic conflict resolution is the process of resolving conflicts synchronously according to specified policy. In a WinFS synchronization operation, policy can be specified independently for send operations and receive operations. Automatic conflict resolution policy is specified via the synchronization profile. Conflicts that are raised are passed to the top-level conflict handler specified in the profile. This conflict handler may resolve the conflict, log it, or pass the conflict to another conflict handler for further processing along the conflict handling pipeline.",{"@attributes":{"id":"p-0523","num":"0665"},"figref":"FIG. 39A","b":["3910","3902","3912","3912","3902","3914","3910","3912","3922","3902","3912","3914","3914","3922","3910","3922","3936","3934","3944"]},{"@attributes":{"id":"p-0524","num":"0666"},"figref":["FIG. 39B","FIG. 39A","FIG. 39B","FIG. 39A"],"b":["3902","3950","3910","3952","3912","3902","3912","3954","3902","3956","3914","3902","3958","3998","3960","3922","3962","3902","3998","3964","3932","3966","3934","3902","3934","3968","3902","3972","3936","3970","3998","3902","3972","3938","3902","3938","3974","3902","3976","340","3902","3978","3998","3980","3942","3982","3902","3998","3902","3936","3984","3998"]},"Although not shown in , it should be noted that a path of consecutive conflict resolvers can also be constructed where, if a conflict cannot be resolved by one resolver, that conflict is passed on to the next resolver which then attempts to resolve the conflict, and so on and so forth. It is only at the end of a path that, if the conflict remains unresolved, that conflict is passed back up the path to a list in order to proceed to the next path. Similarly, once all of the paths for a list have been exhausted and the conflict remains unresolved, the list then passes the conflict back up its pathway until it reaches the next list, and so on and so forth.","It is also important to note that a pipeline does not necessarily have to begin with a list; on the contrary, it may start with any type of conflict handler such as, for example, a filter. Regardless, however, if a conflict is passed back up a path to the first conflict handler in the pipeline, and that conflict handler has no additional paths to try (which would only be the case for a conflict handler list where all of the paths have not been attempted), then the conflict passes out of the pipeline and is, automatically and by default, logged to the Conflict Log.","The ConflictHandler type is the base type for conflict handlers, including the conflict handler list, the conflict log, and conflict filters, and other types of conflict handlers. In addition, the synchronization service may also provide a number of default conflict handlers which includes but is not limited to:\n\n","For example, a conflict handler may specify that, for Update-Delete conflicts, a Local Wins resolution should be applied, and that for all other conflicts a Last Writer Wins resolution should be applied, as follows:",{"@attributes":{"id":"p-0529","num":"0675"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<conflictHandlerList xmlns=\u201dhttp:\/\/schemas.microsoft.com\/"},{"entry":"winfs.2003\/10\/conflicts\u201d>"},{"entry":"\u2002<conflictFilter xmlns=\u201dhttp:\/\/schemas.microsoft.com\/"},{"entry":"\u2002winfs.2003\/10\/conflicts\u201d>"},{"entry":"\u2002\u2002<conflictType>UpdateDeleteConflict<\/conflictType>"},{"entry":"\u2002\u2002<conflictResolver><ResolutionType>LocalWins<\/ResolutionType><\/"},{"entry":"\u2002\u2002conflictResolver>"},{"entry":"\u2002<\/conflictFilter>"},{"entry":"\u2002<conflictResolver><ResolutionType>LastWriterWins<\/"},{"entry":"\u2002ResolutionType><\/conflictResolver>"},{"entry":"<\/conflictHandlerList>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Of course, if no conflict handler is specified, or if a conflict is not handled by any of the specified conflict handlers, then the conflict is placed in the conflict log. For certain embodiments, the conflict log is also a conflict handler.","For various embodiments of the present invention, ISVs can implement and install their own conflict handlers. Custom conflict handlers may accept configuration parameters, though such parameters must be specified by the SCA in the Conflict Resolution section of the Sync Profile.","When a conflict resolver handles a conflict, it returns the list of operations that need to be performed (in lieu of the conflicting change) back to the runtime. The synchronization service then applies these operations, having properly adjusted remote knowledge to include what the conflict handler has considered.","It is possible that another conflict is detected while applying the resolution. In such a case, the new conflict must be resolved or logged before the original processing resumes.","When thinking of conflicts as branches in the version history of an item, conflict resolutions can be viewed as joins\u2014combining two branches to form a single point. Thus, conflict resolutions turn version histories into directed acyclic graphs (DAGs).","c) Conflict Logging","While some reported conflicts may be synchronously resolved using Automatic Conflict Resolution, others may be logged for later programmatic resolution. Conflict logging allows the conflict resolution process to proceed asynchronously\u2014that is, the conflicts do not have to be resolved at the time they are detected but may be logged for future resolution. For example, a Conflict Viewer application may allow a user to inspect and manually resolve the logged conflicts after the fact.","For several embodiments of the present invention, a very particular kind of a conflict handler is the Conflict Logger (or, more simply, the \u201clogger\u201d). The synchronization service logs conflicts in a conflict log as Items of type ConflictRecord (or, in alternative embodiments, simply as type Conflict). These records are related back to the items that are in conflict (unless the items themselves have been deleted). For certain embodiments, each conflict record contains: the incoming change that caused the conflict; the type of the conflict (e.g., update-update, update-delete, delete-update, insert-insert, or constraint); and the version of the incoming change and the knowledge of the replica sending it. For certain alternative embodiments of the present invention, each such conflict item contains the conflicting change data and metadata, a description of the conflict as well as other contextual information such as the change applier information, the enlistment data, and the remote partner name. In addition, the change data is stored in a format that can be used to apply the change. Furthermore, for various embodiments of the present invention, each type derived from Conflict can add new fields that are relevant to that type of conflict. For example, the InsertInsertConflict type adds the item ID of the item that caused the uniqueness constraint to be violated.","For several embodiments of the present invention, a conflict item to be logged will also include a copy of the target item either as an extension to the conflict item or merely as a separate item also stored in the conflict log with a relationship defined between it and the conflict item itself or, alternately, as part of the conflict item itself (such as a set of property-value pairs). This target item to be stored as part of or in conjunction with the conflict item in the conflict log (kept on a durable data store) will reflect the specific changes that gave rise to the conflict in the first place.  is a block diagram illustrating this approach using an example contact item. In this example, the contact item  (the \u201ctarget item\u201d) comprises a name field  which is initially set to \u201cJohn\u201d as of the last successful synchronization. This field  is then changed locally to \u201cBob\u201d by the local system. During a subsequent synchronization, if an attempt to change this same field  to \u201cJane\u201d results in a conflict because the local system cannot ascertain which name change, \u201cBob\u201d or \u201cJane,\u201d should be applied, then the local change (\u201cBob\u201d) is retained and a conflict  is logged in the Conflict Log  along with a copy of the contact item \u2032 reflecting the application of the change (\u201cJane\u201d) that led to the conflict. In this way, the Conflict Log comprises the complete target item which gave rise to a conflict, and this particular target item is updated to reflect the change that was attempted to be made on the item that led to the conflict.","To add a conflict to the conflict log, the log is first searched to determine if there are other conflicts on the same change unit(s). If there are any existing conflicts on the same change unit, they are examined for possible removal. An existing conflict is removed if its change awareness is subsumed by the change awareness of the new conflict. On the other hand, if the change awareness of the new conflict is subsumed by the change awareness of an existing logged conflict, the new conflict is discarded, and vice versa (that is, a conflict is also rendered obsolete if its awareness is subsumed by the awareness of the store, such as when the store receives and successfully applies a change whose awareness subsumes the awareness of the conflict). In the third case where neither of the two change awarenesses subsumes the other, the new conflict is added to the log, and both conflicts corresponding to the same change unit exist in the log until later resolved either manually or automatically.","d) Conflict Inspection and Resolution","The synchronization service provides an API for applications to examine the conflict log and to suggest resolutions of the conflicts in it. The API allows application to enumerate all conflicts, or conflicts related to a given Item. It also allows such applications to resolve logged conflicts in one of three ways: (1) remote wins\u2014accepting the logged change and overwriting the conflicting local change; (2) local wins\u2014ignoring conflicting parts of the logged change; and (3) suggest new change\u2014where the application proposes a merge that, in its opinion, resolves the conflict. Once conflicts are resolved by an application, the synchronization service removes them from the log.","e) Convergence of Replicas and Propagation of Conflict Resolutions","In complex synchronization scenarios, the same conflict can be detected at multiple replicas. If this occurs, several things can happen: (1) the conflict can be resolved on one replica, and the resolution be sent to the other; (2) the conflict is resolved on both replicas automatically; or (3) the conflict is resolved on both replicas manually (through the conflict inspection API).","To ensure convergence, the synchronization service forwards conflict resolutions to other replicas. When a change that resolves a conflict arrives at a replica, the synchronization service automatically finds any conflict records in the log that are resolved by this update and eliminates them. In this sense, a conflict resolution at one replica is binding on all the other replicas.","If different winners are chosen by different replicas for the same conflict, the synchronization service applies the principle of binding conflict resolution and picks one of the two resolutions to win over the other automatically. The winner is picked in a deterministic fashion that is guaranteed to produce the same results at all times (one embodiment uses replica ID lexicographic comparisons).","If different \u201cnew changes\u201d are suggested by different replicas for the same conflict, the synchronization service treats this new conflict as a special conflict and uses the Conflict Logger to prevent it from propagating to other replicas. Such situation commonly arises with manual conflict resolution.","F. Additional Aspects of the Sync Schema and the Conflict Handling Schema","The following are additional (or more specific) aspects of the synchronization schema for various embodiments of the present invention.\n\n","The following are additional (or more specific) aspects of the conflict handling schema for various embodiments of the present invention.\n\n","IV. Synchronization Through Intermediary","With the initial utilization of the new storage platform described herein, enterprises having synchronization networks comprising various individual computer systems may have a mixture in that some individual computer systems utilize the new storage platform while other individual computer systems continue to utilize legacy storage platforms. This is particularly significant in any client-server synchronization structure where two clients comprise the new storage platform but where the server comprises a legacy storage platform. Consequently, in such circumstances, it may be necessary for two computer systems utilizing the new storage platform (the \u201cclients\u201d) to synchronize through a computer system utilizing a legacy storage platform (the \u201cintermediary\u201d). For example, some clients may be enrolled in legacy roaming services using software such as Roaming User Profiles (RUP) or Folder Redirection with Client Side Caching (CSC). Since legacy roaming software for these legacy storage platforms does not support roaming data for the new storage platform, a new roaming service for the new storage platform is necessary. Various embodiments of the present invention are directed to system and methods for the synchronization of two clients both utilizing a common storage platform (e.g., the new storage platform of the related inventions) through an intermediary that is not using the same common storage platform (e.g., instead using a legacy storage platform that does not itself support synchronization for the new storage platform).","A. Structure of Data for Intermediary","For several embodiments of the present invention are directed to \u201cSync Through Intermediary\u201d (STI) Adapters that exist and operate between a replica client and the non-replica intermediary. For these embodiments, STI Adapters are designed to serialize results of change enumeration from a replica client to an non-replica intermediary, as well as deserialize these change results from a non-replica intermediary to a replica client.",{"@attributes":{"id":"p-0554","num":"0708"},"figref":"FIG. 41","b":["4102","4112","4114","4102","4112","4114","4102","4112","4114","4102","4112","4114","4102","4112","4114","4102"]},"Clients A  and client B  interface with the intermediary  via STI Adapters  and  respectively, said STI Adapters being specifically tailored to intereface between the new storage platform of the clients  and  and the specific legacy platform of the intermediary . Several alternative embodiments of the present invention are directed to several specific STI Adapters corresponding to several legacy storage platforms with which an intermediary may need to synchronize. This enables the clients  and  still logically synchronize with the intermediary  (via the STI Adapters  and ) as if it were a true replica, although in reality it is the Adapters local to the clients that make the synchronization successful.","In regard to serializing results of change enumeration from a replica client to an non-replica intermediary, each serialization corresponds to a batch of changes that are serialized into a triplet of files to be written to the intermediary. For certain embodiments, these files are written to a specific folder (a \u201ccommunity folder\u201d) corresponding to the specific synchronization community, and differenct synchronization communities would have different community folders. This aforementioned triplet of files includes a change data file (CDF), a prerequisite knowledge file (PKF), and a learned knowledge file (LKF). The CDF contains information pertaining to the specific changes to WinFS items at the change unit level. The PKF specifies what a synchronization peer must already know in order to apply the associated changes. The LKF, on the other hand, specifies what the synchronization peer will learn if it applies the associated changes. For efficiency, and similar to a peer-to-peer sync, the STI Adapter only serializes change unit information (the \u201cchanged parts\u201d and its associated metadata), and for several embodiments this data may only comprise (for a specific change to an Item) the Item type, the Item version number, the change unit version, and the value of the property that was changed. For various embodiments, the triplet of files are written to the intermediary using a sequential naming convention based on the message sequence of the serializations (for reasons discussed later herein); for example, the first serialization could comprise three files that are stored as 1. PKF (the PKF file), 1.CDF (the CDF file), and 1.LKF (the LKF file) on the intermediary, and the second serialization may comprise 2. PKF, 2.CDF, and 2.LKF, and so on and so forth.","B. STI Adapter Processes","For several embodiments of the present invention, The STI Adapter comprises three core operations: send sync, receive sync, and data compaction.","1. Send Sync Operation",{"@attributes":{"id":"p-0560","num":"0714"},"figref":"FIG. 42","b":["4202","4204","4206"]},"At step , the STI Adapter concurrently acquires \u201cwrite mode\u201d process locks on the intermediary's community folder (via the intermediary's file system) in order to preserve data integrity by preventing other clients (or other peers or processes) from reading or writing to the community folder for the duration of the send sync operation. At step , the STI Adapter then communicates the ILK to the client. Based on the ILK and its own client local knowledge (CLK), at step  the client determines if there are any changes not covered by the ILK and, if not, the process skips to step . On the other hand, if the client determines there are changes not covered by the ILK, at step  the client prepares the enumerated changes not covered by the ILK and passes them to the STI Adapter. At step  the STI Adapter serializes each batch of change information (change data and knowledge) and, at step , the STI Adapter then writes the serialized change batches to the intermediary's community folder as sequentially-increasings triplets of files as previously discussed. Once all of the serialized changed batches have been written to the intermediary, at step  the STI Adapter then releases the \u201cwrite mode\u201d process locks to allow other clients (or other peers or processes) to examine the updated content on the intermediary.","Although the send sync operation is completed, it should be noted that the STI Adapter stores the identity (or reference number) of the last and highest sequentially-increasing change triplet (HCT) that was written to the intermediary for later reference (discussed below). It should also be noted that no conflict handling is performed as part of a send sync operation. Lastly, for peer-to-peer embodiments where clients only \u201cpull\u201d data (and so clients do not initiate the send sync operation), and presuming the intermediary has not functionality for intiating it itself, the STI Adapter may initiate the send sync operation on its own accord on behalf of the intermediary.","2. Receive Sync Operation","For synchronization in the other direction,  is a flow diagram illustrating the steps by which a client, via an STI Adapter, receives change data from an intermediary (a \u201creceive sync\u201d operation). At step , the STI Adapter first receives the client local knowledge (CLK) which, for several embodiments of the present invention, occurs when the client sends a sync request to the intermediary thru the STI Adapter, said sync request inherently including the CLK per the peer-to-peer synchronization scheme discussed earlier herein. At step , the STI Adapter then acquires \u201cread mode\u201d process locks on the intermediary's community folder (via the intermediary's file system) in order to preserve data integrity by preventing other clients (or other peers or processes) from writing to (but, for certain embodiments, not reading from) the community folder for the duration of the receive sync operation. For certain embodiments, this \u201cread mode\u201d can might be optimized to lock each triplet rather than the entire directory for better concurrency.","At step , and in regard to the HCT stored by the STI Adapter for that intermediary (which, for example, may have resulted from a send sync operation as discussed above), the STI Adapter scans the community folder on the intermediary for the next higher change triplet (a) that is sequentially higher than the HCT, (b) where the CLK (client local knowledge) is greater than the prerequisite knowledge (from the PKF) for that change triplet, and (c) where the CLK is less than the learned knowledge (from the LKF) for the change triplet. (Such a change triplet is referred to as an \u201capplicable change triplet\u201d or \u201cACT\u201d herein.) If there is such a change triplet (an ACT) at step , then at step  the Sync Adapter deserializes the contents of that change triplet (the ACT) into a replica-undersrtandable enumerated change and at step  sends the change to the client for processing. The process then returns to step  for the next ACT and the process continues until none remain, at which time the STI Adapter unlocks the read mode at step  and the process ends.","3. Intermediary File Data Compression\/Compaction","For various embodiments of the present invention it is necessary to routinely compact the serialized data and knowledge files created by the STI Adapter; otherwise the ever-increasing number of change triplets would fill up all available storage space on the intermediary. In this regard, the goal of data compaction is to ensure that the growth of data and knowledge files is appropriately bounded on the intermediary. One method employed by several embodiments of the present invention is to set an \u201cupper threshold\u201d on the number of change packets which are allowed to exist on the shared file system and, once that threshold is exceeded, the next STI Adapter capable of doing so is required to compact the shared file system (the files in the community folder) on the intermediary via a compaction operation. The compaction operation reduces the amount of data stored in the shared file system by (a) compacting the change history for individual existing objects and (b) removing the changes broadcast for objects which have been deleted (either explicitly, via conflict resolution, or as a result of tombstone cleanup). However, compaction can only be carried out by by an STI Adapter for a client which has just performed a receive sync and which can immediately perform a \u201cfull\u201d send sync (that is, full change enumeration with zero baseline as if there was no community folder on the intermediary). Thus, compaction cannot be performed by clients who only do send syncs or only do receive syncs with an intermediary.",{"@attributes":{"id":"p-0568","num":"0722"},"figref":["FIG. 44","FIG. 43"],"b":["4402","4312","4314","4404","4406","4408"]},"For those embodiments that where the \u201cread mode\u201d has been optimized to lock each triplet rather than the entire directory for better concurrency, and for other alternative embodiments of the present invention using the standard \u201cread mode,\u201d the process differs slightly in that the STI Adapter checks to see if compaction is needed before the STI Adapter then acquires \u201cread mode\u201d process locks on the intermediary's community folder (via the intermediary's file system) (at step  of ) and, if compaction is needed, using the standard (not optimized) \u201cread mode\u201d in order to preserve data integrity by preventing other clients (or other peers or processes) from writing to (but, for certain embodiments, not reading from) the community folder for the duration of the receive sync operation.","For certain alternative embodiments, the data on the intermediary is not deleted until after the client has uploaded all change triplets by overwriting the existing change triplets starting with the first one, and then once all change triplets have been uploaded (and the old ones rewritten), all remaining change triplets of a higher sequence number than the last one uploaded during the full read sync are deleted.","Lastly, certain alternative embodiments also begin compaction after the complete receive sync operation has completed (include release of the read mode process locks). For such embodiments, the process starts with acquiring a write mode process blocks and then proceeds to perform all of the steps previously alluded to.","C. STI and Down-Level Client Support","In addition to the foregoing, several additional embodiments of the present invention are directed to variations of the sync-through-intermediary technology described earlier herein. Certain embodiments are directed to a system that further comprise a client that is also running a legacy storage platform where said \u201clegacy client\u201d can also access all data files. It is also anticipated that certain legacy clients and other applications and processes would be able to access these data files for other purposes. For example, for a legacy client that synchronizes files based on date of creation or some other inherent file characteristic. Another example would be a legacy client that directly accesses any or all of files (e.g., a *.CDK file) and copies same. I many regards, a legacy client might be thought of in the same terms as a second intermediary that communicates directly (perhaps using legacy synchronization techniques) with the first intermediary, and thus multi-intermediary synchronization is possible and hereby disclosed.","V. Conclusion","As the foregoing illustrates, the present invention is directed to a storage platform for organizing, searching, and sharing data. The storage platform of the present invention extends and broadens the concept of data storage beyond existing file systems and database systems, and is designed to be the store for all types of data, including structured, non-structured, or semi-structured data, such as relational (tabular) data, XML, and a new form of data called Items. Through its common storage foundation and schematized data, the storage platform of the present invention enables more efficient application development for consumers, knowledge workers and enterprises. It offers a rich and extensible application programming interface that not only makes available the capabilities inherent in its data model, but also embraces and extends existing file system and database access methods. It is understood that changes may be made to the embodiments described above without departing from the broad inventive concepts thereof. Accordingly, the present invention is not limited to the particular embodiments disclosed, but is intended to cover all modifications that are within the spirit and scope of the invention as defined by the appended claims.","As is apparent from the above, all or portions of the various systems, methods, and aspects of the present invention may be embodied in the form of program code (i.e., instructions). This program code may be stored on a computer-readable medium, such as a magnetic, electrical, or optical storage medium, including without limitation a floppy diskette, CD-ROM, CD-RW, DVD-ROM, DVD-RAM, magnetic tape, flash memory, hard disk drive, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer or server, the machine becomes an apparatus for practicing the invention. The present invention may also be embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, over a network, including the Internet or an intranet, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates analogously to specific logic circuits."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of the invention, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary embodiments of various aspects of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 5B","FIG. 5A"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 6B","FIG. 6A"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 21A"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 21B","FIG. 21A"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 30A","b":"1"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 30B","b":["1","2"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 31A","b":["1","1","1","1"]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 31B","b":["1","1","1","1"],"i":["a","b","c; "]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 32A"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 32B"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 33A"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 33B"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 34A"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 34B"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 35A"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 35B"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIGS. 38A-D"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 39A"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 39B","FIG. 39A"]},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 44"}]},"DETDESC":[{},{}]}
