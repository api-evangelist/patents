---
title: Method and system using exceptions for code specialization in a computer architecture that supports transactions
abstract: A method and system uses exceptions for code specialization in a system that supports transactions. The method and system includes inserting one or more branchless instructions into a sequence of computer instructions. The branchless instructions include one or more instructions that are executable if a commonly occurring condition is satisfied and include one or more instructions that are configured to raise an exception if the commonly occurring condition is not satisfied.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483275&OS=09483275&RS=09483275
owner: Intel Corporation
number: 09483275
owner_city: Santa Clara
owner_country: US
publication_date: 20111216
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION OF THE DRAWINGS"],"p":["Some computer architectures can support hardware and\/or software transactional memory systems, such as Restricted Transactional Memory (RTM) systems and Software Transactional Memory (STM) systems. In transactional memory systems, computer instructions are permitted to execute concurrently, e.g. as single-threaded operations of a multi-threaded application. To do this, sequences of instructions in the computer program are defined as transactions, which can execute read and write instructions to shared memory independently of instructions running on other threads. The transactions can be defined by an interpreter, translator, program compiler, optimizer, or application programming interface (API), for example, depending on the type of transactional system. The transactional memory system includes control mechanisms to prevent concurrently executing instructions from accessing shared memory at the same time or in the wrong order. For example, a validation mechanism verifies that a transaction has successfully completed, e.g., without other program threads making changes to memory accessed by the transaction before the transaction completed. If the validation is successful, the results of the transaction are made permanent (e.g. by a \u201ccommit\u201d operation).","If the transaction cannot be committed, an exception may be raised or the transaction may be aborted. If an exception is raised or the transaction is aborted, execution of the transaction can be rolled back to an earlier point in the program code, e.g., to a \u201ccheckpoint.\u201d If the transaction is aborted, it may be re-executed from the beginning until it completes successfully, or simply terminated.","Computer program code can contain many specialized instructions, each of which may be designed to handle a particular condition that may be satisfied during execution of the program. Code specialization is a program optimization technique that attempts to, at runtime, optimize a computer program or portion thereof for a commonly occurring condition. However, code specialization typically adds branch instructions that can affect performance.","While the concepts of the present disclosure are susceptible to various modifications and alternative forms, specific exemplary embodiments thereof have been shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that there is no intent to limit the concepts of the present disclosure to the particular forms disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the invention as defined by the appended claims.","In the following description, numerous specific details such as logic implementations, opcodes, means to specify operands, resource partitioning\/sharing\/duplication implementations, types and interrelationships of system components, and logic partitioning\/integration choices are set forth in order to provide a more thorough understanding of the present disclosure. It will be appreciated, however, by one skilled in the art that embodiments of the disclosure may be practiced without such specific details. In other instances, control structures, gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art, with the included descriptions, will be able to implement appropriate functionality without undue experimentation.","References in the specification to \u201cone embodiment\u201d, \u201can embodiment\u201d, \u201can example embodiment\u201d, etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to effect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described. Embodiments of the invention may be implemented in hardware, firmware, software, or any combination thereof. Embodiments of the invention implemented in a computer system may include one or more bus-based interconnects between components and\/or one or more point-to-point interconnects between components. Embodiments of the invention may also be implemented as instructions carried by or stored on a transitory or non-transitory machine-readable medium, which may be read and executed by one or more processors. A machine-readable medium may be embodied as any device, mechanism or physical structure for storing or transmitting information in a form readable by a machine (e.g., a computing device). For example, a machine-readable medium may be embodied as read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; mini- or micro-SD cards, memory sticks, electrical signals, and others.","In the drawings, specific arrangements or orderings of schematic elements, such as those representing devices, modules, instruction blocks and data elements, may be shown for ease of description. However, it should be understood by those skilled in the art that the specific ordering or arrangement of the schematic elements in the drawings is not meant to imply that a particular order or sequence of processing, or separation of processes, is required. Further, the inclusion of a schematic element in a drawing is not meant to imply that such element is required in all embodiments or that the features represented by such element may not be included in or combined with other elements in some embodiments. In general, schematic elements used to represent instruction blocks may be implemented using any suitable form of machine-readable instruction, such as software or firmware applications, programs, functions, modules, routines, processes, procedures, plug-ins, applets, widgets, code fragments and\/or others, and that each such instruction may be implemented using any suitable programming language, library, application programming interface (API), and\/or other software development tools. For example, some embodiments may be implemented using Java, C++, and\/or other programming languages. Similarly, schematic elements used to represent data or information may be implemented using any suitable electronic arrangement or structure, such as a register, data store, table, record, array, index, hash, map, tree, list, graph, file (of any file type), folder, directory, database, and\/or others.","Further, in the drawings, where connecting elements, such as solid or dashed lines or arrows, are used to illustrate a connection, relationship or association between or among two or more other schematic elements, the absence of any such connecting elements is not meant to imply that no connection, relationship or association can exist. In other words, some connections, relationships or associations between elements may not be shown in the drawings so as not to obscure the disclosure. Also, for ease of illustration, a single connecting element may be used to represent multiple connections, relationships or associations between elements. For example, where a connecting element represents a communication of signals, data or instructions, it should be understood by those skilled in the art that such element may represent one or multiple signal paths (e.g., a bus), as may be needed, to effect the communication.","Referring now to , an illustrative computing device  includes at least one processor , a memory , an input\/output (I\/O) subsystem , a storage device , and one or more peripheral devices . The processor  supports a transactional memory system  as shown in . As described in more detail below, computer program code is analyzed during execution. A specializer  interfaces with the transactional memory system  to specialize code regions or transactions for one or more commonly occurring conditions. Rather than adding branch instructions to the program code, as is often done when conventional code specialization techniques are employed, the specializer  inserts one or more branchless instructions in the code region or transaction that are configured to utilize the exception handling features of the transactional memory system . More specifically, the instruction(s) inserted by the specializer  are configured to raise an exception if a commonly occurring condition is not satisfied. In this way, the normal program flow is allowed to continue uninterrupted, and without branching, in response to the commonly occurring condition being satisfied. The computing device  may be embodied in or as any type of computing device, such as, for example, a desktop computer system, a laptop or tablet computer system, a server, an enterprise computer system, a network of computers, a handheld computing device, or other electronic device depending on the particular application.","The illustrative processor  includes multiple processor cores or logical sections of a single core, , , , which are referred to herein simply as \u201ccores\u201d for ease of description. One or more of the cores , ,  can be configured to process multi-threaded computer programs. The cores , ,  include or are communicatively coupled to one or more cache memory . The cache  may be utilized to temporarily store data and\/or instructions during operation of the specializer  and\/or other components of the computing device .","In addition to the cache memory , the processor  and\/or its cores , ,  include, or are otherwise communicatively coupled to, the memory . Portions of the memory  may be embodied as any type of suitable memory device, such as a dynamic random access memory device (DRAM), synchronous dynamic random access memory device (SDRAM), double-data rate dynamic random access memory device (DDR SDRAM) and\/or other volatile memory devices.","The processor  is also communicatively coupled to the I\/O subsystem . Although not specifically shown, the I\/O subsystem  typically includes a memory controller (e.g., a memory controller hub (MCH) or northbridge), an input\/output controller (e.g., an input\/output controller hub (ICH) or southbridge), and a firmware device. Of course, in other embodiments, I\/O subsystems having other configurations may be used. For example, in some embodiments, the I\/O subsystem  may form a portion of a system-on-a-chip (SoC) and be incorporated, along with the processor  and other components of the computing device , on a single integrated circuit chip. As such, it will be appreciated that each component of the I\/O subsystem  may be located on a common integrated circuit chip in some embodiments.","The I\/O subsystem  is communicatively coupled to one or more storage devices . Portions of the storage  may be embodied as any suitable device for storing data and\/or instructions, such as disk storage (e.g. hard disks), memory cards, memory sticks, and\/or others. In some embodiments, an operating system (O\/S) , one or more sequences of program code (e.g., application code) , a program compiler  and\/or a database management system (DBMS)  may be embodied in the storage . During execution, portions of the O\/S , code , compiler  and\/or DBMS  may be loaded into the memory  and\/or the cache , for faster processing or other reasons.","The I\/O subsystem  may be communicatively coupled to one or more peripheral devices . The peripheral device(s)  may include one or more network interfaces, graphics and\/or video adaptors, keyboard, touchscreens, displays, printers, data storage devices, and\/or other peripheral devices, depending upon, for example, the intended use of the computing device . Further, it should be appreciated that the computing device  may include other components, sub-components, and devices not illustrated in  for clarity of the description.","In general, the components of the computing device  are communicatively coupled as shown in , by one or more signal paths, which are represented schematically as double-headed arrows. Such signal paths may be embodied as any type of wired or wireless signal paths capable of facilitating communication between the respective devices. For example, the signal paths may be embodied as any number of wires, printed circuit board traces, via, bus, point-to-point interconnects, intervening devices, and\/or the like. Referring now to , the illustrative processor core  includes a fetch unit , a logic unit , one or more registers , an execution unit , and a retirement unit . While not specifically shown, it should be understood that one or more of the cores ,  may have the same or similar configuration as the core . Each of the fetch unit , logic unit , registers , execution unit , and retirement unit  may be embodied as computer circuitry, e.g. as electronic components of a central processing unit of the core .","During operation of the computing device , the fetch unit  obtains instructions to be executed by the core  from the cache , the memory , and\/or the storage . The logic unit  processes the instructions and converts them to a form that can be executed by the execution unit  (e.g. machine-level instructions). In accordance with the design of the transactional memory system , after instructions are successfully executed by the execution unit , the retirement unit  may commit and then retire the instructions (by de-allocating registers or updating the processor state, for example). The registers  may be used to store values that are involved in the processing and\/or execution of the instructions, such as data values, pointer addresses, and\/or trip counts. In general, the translator  is configured to translate programmer-accessible computer instructions to an executable form that is compatible with the processor architecture. In the illustrative embodiments, the translator  adapts program code to run on a computer architecture that supports the transactional memory system . In other embodiments, which may include, for example, software transactional memory systems, the translator  may be embodied as a compiler, application programming interface (API), database management system, or the like, depending on the specific implementation.","The translator  includes an optimizer . Generally speaking, the optimizer  is configured to minimize or maximize one or more attributes of a computer program during execution of the program. As should be understood by those skilled in the art, there are many types of optimization that can be used, depending on the requirements of a particular application or system design. For example, some optimizers examine the program code to see if any sequences of computer instructions, in particular frequently-executed sequences, can be replaced with less code.","In the illustrative embodiments, the optimizer  identifies regions of code that require access to shared memory (e.g., code regions that include load or store instructions), and defines the regions of code as transactions. The optimizer  inserts checkpoint and commit instructions into the code regions as needed to define the transactions. In some embodiments, a binary translation dynamic optimizer, or similar device configured to optimize sequences of instructions as encountered and then cache the optimized instructions, may be used. In other embodiments, a static optimizer may be used.","The optimizer  may include the specializer  as a subcomponent, or the specializer  may be embodied as a separate component of the translator  as shown. The specializer  is configured to optimize a sequence of computer instructions for a commonly occurring condition. Whether or not a particular condition is considered to be commonly occurring may be determined in advance (e.g. by the programmer), or \u201con the fly\u201d (e.g. as a result of previous executions of the computer instructions). Some examples of commonly occurring conditions for which it may be desirable to specialize computer instructions include runtime disambiguation checks (e.g., where code is specialized for the occurrence of a specific alias or no alias), value specialization (e.g., where code is specialized for the occurrence of a frequently occurring value of a variable, such as NULL), and loop multiversioning (e.g., where code is specialized for the occurrence of a particular loop trip count).","As described below in connection with , the illustrative specializer  is configured to use the features of the transactional memory system  to optimize a sequence of computer instructions for a commonly occurring condition without introducing any new branch instructions.","The illustrative transactional memory system  is embodied as a hardware system that supports transactions, such as a restricted transactional memory (RTM) system. However, it should be understood that a software transactional memory system (STM) or other system that implicitly transfers control on exceptions may be used in other embodiments. The transactional memory system  includes checkpointing logic , transaction execution semantics , overflow logic , and an exception handler .","The checkpointing logic  includes computer instructions that are configured to interface with the optimizer  to establish the checkpoints and define code regions or transactions in a sequence of computer instructions. In addition, the checkpointing logic  may specify the action(s) to be taken in response to a checkpoint instruction. For example, the checkpointing logic  may initiate the storing of data relating to a particular state of the core  or other component of the computing device  in response to a checkpoint instruction.","The transaction execution semantics  include the semantics (e.g. instructions or code libraries) that can be used in program code to invoke and utilize the features of the transactional memory system . For example, the transaction execution semantics  enable the implicit transfer of control (e.g. to an interpreter or to native execution, depending on the system design) on exceptions. In the illustrative embodiment, the transaction execution semantics  include checkpoint, rollback, and commit semantics, as well as semantics for Boolean or bitwise logic, arithmetic, and invoking the exception handler .","The overflow logic  includes logic configured to specify action(s) to be taken if an overflow occurs (e.g., a value exceeds the maximum size that can be stored in the cache  or the memory ). For example, the overflow logic  may store data relating to the state of the computing device  or a component thereof in response to an overflow event.","The exception handler  includes logic configured to determine action(s) to be taken if an exception is raised by an instruction obtained by the fetch unit . For example, the exception handler  may include logic configured to roll back the program execution to a previous checkpoint in a sequence of instructions and continue execution from the checkpoint, or to abort a transaction.","The arithmetic and logic unit (ALU)  includes an arithmetic unit  and a logic unit . The arithmetic unit  is configured to handle arithmetic operations such as add, subtract, divide, multiply, and\/or others. The logic unit  is configured to handle Boolean and\/or bitwise logic operations such as and, or, and exclusive-or operations.","Referring now to , in operation, a sequence of computer instructions  is input to the translator . The instructions  are referred to as \u201cunspecialized\u201d code because they have not yet been processed by the optimizer  and\/or specializer . After processing by the translator  (including the optimizer  and the specializer ) as described herein, an optimized and\/or specialized version  of the instructions  is produced. The optimized and\/or specialized instructions  may be stored in the cache  until execution by the execution unit .","Referring now to , an illustrative method  executable by the code specializer  is shown. At block , the method  obtains (e.g., from the cache  or the memory ) one or more instructions that have been defined as a code region or transaction by the optimizer . For purposes of this disclosure, a \u201ccode region\u201d may include a sequence of computer instructions determined by the translator  (e.g., the optimizer ) to include at least one transaction. In other words, in some embodiments, a code region may include one or more transactions, while in other embodiments, a code region may include a single transaction.","In the illustrative embodiments, transactions are defined by a checkpoint instruction followed by a commit instruction. At block , the method  analyzes each transaction in the code region to determine which of the one or more instructions in the transaction are desired to be executable in response to a commonly occurring condition. To make this determination, the method  may consider whether there are certain instructions that are only executed if the commonly occurring condition is satisfied. Alternatively or in addition, the method  may determine that although all or multiple of the instructions in the transaction may be executed in response to the commonly occurring condition, it may be desirable to execute only certain of those instructions in response to the commonly occurring condition. This may be the case, for example, when portions of the code are optimized for different conditions.","At block , the method  inserts one or more branchless instructions into the code region. The branchless instructions are configured to preserve the normal program flow (e.g., without branching) for the commonly occurring condition. In the illustrative embodiments, the branchless instruction(s) include at least one instruction that is configured to raise an exception (and thereby invoke the exception handler ) in response to the commonly occurring condition not being satisfied. The branchless instructions may include any form of non-branching logical and\/or arithmetic operations that may be supported by the ALU . In other words, no compare and branch instructions are inserted into the code region as a result of block .","At block , the method  identifies any instructions in the code region that are not desired to be executable in response to the commonly occurring condition, and interfaces with the exception handler  to associate those instructions with an exception handling mechanism (e.g., a rollback or abort instruction), as may be appropriate for a particular application or design. In transactional memory systems and other systems that implicitly transfer control on exceptions, the transfer of control and execution of the instructions that are not executable in response to the commonly occurring condition is handled implicitly by the exception handler .","At block , the method  removes the instructions that are not desired to be executable in response to the commonly occurring condition (e.g., the instructions associated with the exception at block ), from the code region. This can be done, for example, by inserting comment brackets around the instructions. The instructions may be removed entirely (e.g. so that the program aborts if an uncommonly occurring condition is encountered) or may be moved to another location in the sequential listing of the program code. In this way, a code region or transaction can be specialized so that it only contains code that is directed to the commonly occurring condition. Moreover, if the code that is desired to be executable in response to the commonly occurring condition has been optimized, the code region may only contain optimized code. Any code that is directed to the handling of uncommonly occurring conditions, or which is not desired to be executable in response to the commonly occurring condition, may remain un-optimized, or may be separately processed by the optimizer .","Referring now to , an example of a sequence of computer instructions  that has been specialized using a conventional code specialization technique is shown. The instructions  include a code region . Although not illustrated, it should be understood that the code  may include other computer instructions and\/or code regions as well.","After processing using a conventional code specialization technique, the code region  is defined by a checkpoint instruction  followed sequentially by a commit instruction .","Between the checkpoint instruction  and the commit instruction , compare and branch instructions  have been added to the code region . The compare and branch instructions  compare the data stored in two registers, r and r. If the values stored in r and r are equal, the program execution skips over the instructions , which are configured to be executed if the commonly occurring condition is not satisfied, as indicated by the label, \u201cUnoptimized version.\u201d","The program flow jumps to the \u201cOptimized version\u201d label and continues executing from there, the instructions , which are configured to be executed if the commonly occurring condition is satisfied. Once the instructions  have finished executing, the program flow proceeds to the commit instruction .","If the results of the compare and branch instructions  indicate that the data stored in r and r are not equal, then the program flow proceeds to execute the instructions . When the instructions  are finished executing, the program flow jumps to the Fallthrough label . As can be seen from the above example, branching takes place both when the commonly occurring condition (e.g., r equals r) is satisfied and when an uncommonly occurring condition (e.g., r does not equal r) is satisfied.","Referring now to , a sequence of computer instructions  comprising a code region  is shown after having been processed by the specializer  as disclosed herein. The remainder of the sequence of instructions (e.g. the portion of the sequence of instructions  outside of the code region ) may remain unaffected by the processing of the code region , or may be altered by the processing of the code region . For example, instructions configured to be executed in response to the occurrence of an uncommon condition may be removed from the code region  and placed elsewhere in the sequence of instructions .","The specialized code region  does not include any compare and branch instructions. The specialized code region  is defined by a checkpoint instruction  and a commit instruction . Between the checkpoint instruction  and the commit instruction , a sequence of exception generating instructions , ,  is inserted into the code region . In the illustrated example, the exception generating instructions , ,  include a Boolean or bitwise logic instruction (), an arithmetic function (), and an exception raising instruction .","More specifically, in the illustrated example, an exclusive-or (XOR) function is used to compare data stored in the registers r and r. If the data stored in r and r are equal, the result of the XOR function will be zero and the value zero will be stored in r. An addition function (e.g., ADD) adds the value of r to the maximum allowable integer (e.g., $INT_MAX). If the value of r is anything other than zero, an overflow flag will be set because the sum of r and $INT_MAX will be greater than the maximum allowable integer.","An exception raising instruction (e.g., INTO) raises an exception, invoking the exception handler , if the overflow flag is set. If the overflow flag is not set, then the data stored in the registers r and r are equal and the program flow continues uninterrupted and without branching, to the sequence of instructions that are optimized for the commonly occurring condition (which is, in this example, that r and r are equal). For example, in some embodiments, an NOP (no operation performed) instruction may be issued if the overflow flag is not set. Following execution of the instructions for the commonly occurring condition, the program flow proceeds to the commit instruction .","If the overflow flag is set, thereby indicating that an uncommonly occurring condition has been satisfied, the exception handler  may be configured to roll back the transaction and\/or redirect the program flow to the location of the instructions to be executed in the case of an uncommonly occurring condition, or may abort the transaction.","While the disclosure has been illustrated and described in detail in the drawings and foregoing description, such an illustration and description is to be considered as exemplary and not restrictive in character, it being understood that only illustrative embodiments have been shown and described and that all changes and modifications that come within the spirit of the disclosure are desired to be protected. Further, while aspects of the present disclosure have been described in the context of a hardware-based transactional memory system, it will be understood that the various aspects have other applications, for example, any application in which it is desired to specialize program code for one or more commonly occurring conditions where the features of a transaction memory system, or other system that implicitly transfers control on exceptions, are available. (e.g., hardware and\/or software-based transactional systems). Such applications may include, for example, compilers, system or application software, and\/or database systems."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention described herein is illustrated by way of example and not by way of limitation in the accompanying figures. For simplicity and clarity of illustration, elements illustrated in the figures are not necessarily drawn to scale. For example, the dimensions of some elements may be exaggerated relative to other elements for clarity. Further, where considered appropriate, reference labels have been repeated among the figures to indicate corresponding or analogous elements.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
