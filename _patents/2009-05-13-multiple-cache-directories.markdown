---
title: Multiple cache directories
abstract: A first portion of an identifier can be used to assign the identifier to a slot in a first directory. The identifier can identify a cache unit in a cache. It can be determined whether assignment of the identifier to the slot in the first directory will result in the identifier and one or more other identifiers being assigned to the same slot in the first directory. If so, then the technique can include (1) using a second portion of the identifier to assign the identifier to a slot in a second directory; and (2) assigning the one or more other identifiers to one or more slots in the second directory. In addition, it can be determined whether a directory in a cache lookup data structure includes more than one pointer. If not, then a parent pointer that points to the subject directory can be removed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08161244&OS=08161244&RS=08161244
owner: Microsoft Corporation
number: 08161244
owner_city: Redmond
owner_country: US
publication_date: 20090513
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["A continuing problem in computer systems remains handling the growing amount of available information or data. The sheer amount of information being stored on disks or other storage media for databases in some form has been increasing dramatically. While files and disks were measured in thousands of bytes a few decades ago\u2014at that time being millions of bytes (megabytes), followed by billions of bytes (gigabytes)\u2014now databases of a million megabytes (terabytes) and even billions of megabytes are being created and employed in day-to-day activities.","With the costs of memory going down, considerably large caches can be configured on the desktop and server machines. In addition, in a world where hundreds of gigabytes of storage is the norm, the ability to work with most data in large caches can increase productivity and efficiency because the caches can be configured to retrieve data more quickly than the same data can be retrieved from many mass data stores. A cache is a collection of data that duplicates original value(s) stored elsewhere or computed earlier, where the cached data can be read from the cache in lieu of reading the original value(s). A cache is typically implemented where it is more efficient to read the cached data than to read the original value(s) so that use of the cache can increase the overall efficiency of computing systems.","In an effort to scale the size of caches in an organized manner, some caches are configured as distributed partitioned caches. A distributed cache is a cache that is distributed across one or more cache nodes. Typically, a distributed cache is distributed across one or more physical or virtual computing machines. A distributed partitioned cache is a cache that is partitioned across multiple cache nodes, where a primary location for each partition is on a single cache node. As used herein, a cache node refers to a storage process in a cache system. A cache node may be on a single machine or spread across multiple physical machines, and a single physical machine may include multiple storage nodes, such as where a single physical machine hosts multiple virtual machine processes. Thus, the distributed partitioned cache is spread over multiple storage processes, so that the entire set of primary data to be read from the cache is not stored on a single process, and typically is not stored on a single machine. As used herein, the term \u201cprimary\u201d data indicates the data that is currently set up to be accessed in the cache, such as to be read from the cache, as opposed to secondary or replicated data that is currently being stored as a backup. The primary data may also be replicated from other data outside the data store. For example, in a distributed cache the primary data may be replicated from more authoritative data that is stored in long-term mass storage. The term \u201cprimary\u201d is similarly used to refer to a primary region or partition, which is a region or partition currently set up to be accessed, as opposed to a replica of the primary region or partition. The term \u201cprimary\u201d can also be used to refer to a primary cache node, which is a cache node that stores the primary data, such as a primary region. Note, however, that a cache node can be a primary node for one set of cache data and a secondary node for another set of cache data. A distributed partitioned cache system is a system that is configured to implement such distributed partitioned caches.","The data manager component in a distributed cache is a component that handles the storage of the data.","Whatever the advantages of previous cache data management tools and techniques, they have neither recognized the cache data management tools and techniques described and claimed herein, nor the advantages produced by such tools and techniques.","In one embodiment, the tools and techniques can include using a first portion of an identifier to assign the identifier to a slot in a first directory. The identifier can identify a cache unit in a cache. It can be determined whether assignment of the identifier to the slot in the first directory will result in the identifier and one or more other identifiers being assigned to the same slot in the first directory. If so, then the technique can include (1) using a second portion of the identifier to assign the identifier to a slot in a second directory; and (2) assigning the one or more other identifiers to one or more slots in the second directory.","In another embodiment of the tools and techniques, a first portion of a first identifier can be used to assign the first identifier to a slot in a first directory in a cache lookup data structure, and a first portion of a second identifier can be used to assign the second identifier to a slot in the first directory. The first and second identifiers can identify respective first and second cache units in a cache. It can be determined whether the first identifier and the second identifier are assigned to the same slot in the first directory. If so, then a second portion of the first identifier can be used to assign the first identifier to a first slot in a second directory of the cache lookup data structure, and a second portion of the second identifier can be used to assign the second identifier to a second slot in the second directory.","In yet another embodiment of the tools and techniques, a multi-directory data structure can include a root directory and one or more lower directories below the root directory. The directories can each include one or more pointers pointing to another directory or to one or more cache units in a cache, and at least one of the directories can include a pointer pointing to a cache unit in the cache. It can be determined whether one of the directories includes more than one pointer. If not, then a parent pointer pointing to the directory from a parent slot in a parent directory above the subject directory can be removed from the parent slot.","In yet another embodiment of the tools and techniques, a low priority cleanup queue and a high priority cleanup queue can be maintained. The low priority queue can be configured to list low priority removal candidates to be removed from a cache, with the low priority removal candidates being sorted in an order of priority for removal. The high priority queue can be configured to list high priority removal candidates to be removed from the cache. In response to receiving a request for one or more candidates for removal from the cache, one or more high priority removal candidates from the high priority cleanup queue can be returned if the high priority cleanup queue lists any high priority removal candidates. Moreover, if no more high priority removal candidates remain in the high priority cleanup queue, then one or more low priority removal candidates from the low priority cleanup queue can be returned in the order of priority for removal. As an example, the returned removal candidates in this and the next embodiment can be expiration and\/or eviction candidates to be removed from the cache.","In yet another embodiment of the tools and techniques, a request for one or more candidates for removal from a cache can be received, and one or more candidates for removal can be returned in response to the request. Returning the candidates can include returning one or more candidates that are identified as being expired, determining when all candidates for removal that are identified as being expired have been returned. Moreover, when all candidates for removal that are identified as being expired have been returned, then returning the candidates can include returning candidates for removal according to a priority policy.","In yet another embodiment of the tools and techniques, a write operation can be performed on an existing cache unit that is pointed to by an existing committed pointer in a cache directory slot. The slot can be latched to prevent other write operations on the cache unit, but one or more read operations on the cache unit can be allowed during the write operation. After the write operation is complete, the slot can be unlatched.","In yet another embodiment of the tools and techniques, a request for cache data can be received at a cache enumerator. The request can include a state object, which can indicate a state of an enumeration of a cache. In response to the request, the enumeration can be continued by using the state object to identify and send cache data.","In yet another embodiment of the tools and techniques, in response to receiving a cache data request, an enumeration of cache units can be performed by traversing a multi-level data structure. The data structure can include internal nodes and object nodes, and the object nodes can correspond to the cache units. An enumeration state stack can be maintained. The state stack can include state nodes and can indicate a current state of the enumeration. The state nodes can correspond to a set of the internal nodes, where the set of internal nodes forms a path from an internal node under traversal in the data structure to an internal root node in the data structure.","In yet another embodiment of the tools and techniques, a cache can include cache units, and a main cache lookup data structure can include location information corresponding to the cache units. A cache index data structure can include a higher level table and a lower level table. The higher level table can have a leaf node pointing to the lower level table, and the lower level table can have a leaf node pointing to one of the cache units. Moreover, the lower level table can be associated with a tag.","This Summary is provided to introduce a selection of concepts in a simplified form. The concepts are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter. Similarly, the invention is not limited to implementations that address the particular techniques, tools, environments, disadvantages, or advantages discussed in the Background, the Detailed Description, or the attached drawings.","Described embodiments are directed to techniques and tools for improved cache data management. Such improvements may result from the use of various techniques and tools separately or in combination.","Such techniques and tools may include techniques to improve efficiency of data management in a cache. For example, the techniques can include using multiple cache directories, compaction of cache directories, write-only latches, improved eviction and expiration, stateful or stateless enumeration, and multiple table indexing.","As will become apparent in the discussion below, one or more substantial benefits can be realized from the data management tools and techniques described herein. However, the subject matter defined in the appended claims is not necessarily limited to the benefits described herein. A particular implementation of the invention may provide all, some, or none of the benefits described herein. Although operations for the various techniques are described herein in a particular, sequential order for the sake of presentation, it should be understood that this manner of description encompasses rearrangements in the order of operations, unless a particular ordering is required. For example, operations described sequentially may in some cases be rearranged or performed concurrently. Techniques described herein with reference to flowcharts may be used with one or more of the systems described herein and\/or with one or more other systems. Moreover, for the sake of simplicity, flowcharts may not show the various ways in which particular techniques can be used in conjunction with other techniques.","I. General Cache Layering Arrangement","The memory capacity of multiple computers or processes can be aggregated into a single unified cache, which can be scalable (e.g., a dynamic scaling) to a plurality of machines via a layering arrangement. Such layering arrangement can cache serializable Common Language Runtime (CLR) objects and provide access through a simple cache application programming interface (API). The layering arrangement can include a data manager component, an object manager component and a distributed object manager component, which can be implemented in a modular fashion. In one aspect, the data manager component supplies basic data functions (e.g., hash functions), and the object manager component implements object facade thereon including cache objects\u2014while the distributed object manager provides distribution of the data in the distributed cache.","As such, the object manager component can map regions to containers and manage data eviction thresholds and supply policy management for cached data. Such regions can represent cache containers that typically guarantee co-locations of the object placed\/inserted in the container (e.g., co-locations of objects in same cache node). Additionally, the object manager component can raise notifications (e.g., due to changes made to cached data) for various regions or objects of the distributed cache. Likewise, the distributed object manager component can dispatch requests to various cache nodes associated with different regions of the distributed cache.","Moreover, the distributed object manager can interface with partition maps, or routing tables, of the distributed cache for a given request, and can facilitate abstraction of the aggregated cache in the distributed environment, to a single unified cache. In one aspect, the distributed object manager component is positioned on top of the object manager component, which itself is placed on top of the data manager component. Moreover, tight integration can be provided with ASP.NET to enable cache ASP.NET session data in the cache without having to write it to source databases, for example.","These components can provide pluggable features that can readily adapt to a user's preferences (e.g., replacing a data manger component with another type thereof, based on user preferences). Likewise, the object manager component can be replaced with another object manager component, wherein plugging different models in the layering arrangement is enabled by enabling a call back mechanism with holding locks during call back throughout the stack.","In a related aspect, the layering arrangement can provide for a modular arrangement that facilitates operation on different levels and communication substrates (e.g., TCP\/IP), and which can be implemented in two topology models, namely as an independent separate tier model or an embedded application model. In the independent and separate tier model, the caching layer can function as an independent separate tier by itself (which can be positioned between application servers and data servers). For example, in such a configuration the distributed cache can run as a service hosted either by Windows Activation Services (WAS) or windows service, and can run separate from the application. The applications can either employ the client stubs provided by the distributed cache to talk thereto, or can communicate through a representational state transfer (REST) API directly into the service.","Alternatively, in the embedded application model the cache can be embedded within the application itself (e.g., connecting the applications together to form a cluster\u2014such as embedding caches in ASP.net instances to form a cluster of ASP.net machines, wherein upon storing an item in a local cache it can be viewed from other machines.) This embedding can further enable tagging and Language Integrated Query (LINQ) queries on the objects from a functionality perspective. LINQ queries can then be run natively on stored objects, and can be embedded in .Net applications.","The various aspects of the described tools and techniques will now be described with reference to the annexed drawings, wherein like numerals refer to like or corresponding elements throughout. However, the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the claimed subject matter. For example, data management may be implemented in an arrangement other than the disclosed cache layering arrangement.","II. Cache System & Tools","A. Cache Layering",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","131","133","100","110","112","114","114","112","110","110","112","114","112","110","114"]},"Moreover, a clustering substrate () can establish clustering protocols among a plurality of cache nodes that form a single unified cache. For example, when a cache node is to join or leave the cluster, requisite operations for adding or leaving the cluster can be managed, wherein a distributed components availability substrate () can employ such information to manage operations (e.g., monitoring health of cache nodes, managing life cycles of cache nodes, creating a primary cache node on another machine). In addition, for each cache node, each of the components forming the layering arrangement can be pluggable based on user preferences, system features, and the like.","As explained earlier, the data manager component () (e.g., in memory) can provide primitive high performance data structures such as hash tables, Btrees, and the like. Since the data manager component () can be memory bound and all operations of the distributed cache can be atomic, the data manager component () can typically implement highly concurrent hash tables. The data manager component () and the hash table structures can further facilitate creating the infrastructure for supplying containers and indexes on containers. In addition, the data manager component () can provide simple eviction and expiration on these hash structures. Due to pluggable features supplied by the layering arrangement (), users can plug in different types of data managers tailored to users' preferences, such as a transaction data manager or a disk paged data manager, or the like. Likewise, the object manager component () can provide object abstraction and can implement the concept of named caches and regions by employing data structures provided by the data manager component ().","Similarly, the distributed object manager component () can employ the local object manager component () and integrate with the distributed components availability substrate () to provide the abstraction of the distributed cache. The distributed components availability substrate () can provide the transport and data consistency operations to make the system scalable and available. The distributed object manager component () can optionally be implemented as part of a client tier to facilitate dispatching requests (e.g., directly) to the cache nodes associated with the single unified cache.","In one particular aspect, the distributed object manager component () can further include a dispatch manager component () and a distributed manager component (). The dispatch manager component () can further look up the routing table to dispatch the requests to a primary cache node (e.g., where a primary region is located) as part of a dynamically scalable distributed cache. Moreover, the dispatch manager component () can also be present in the client so that the client can directly dispatch requests to the primary cache node. For example, the distributed object manager component () on the receiving cache node can interact with a partition map to check if the cache node is indeed designated as the primary cache node as part of a plurality of cache nodes associated with the distributed cache, and can call the object manager component () to perform the operation. In the case of write operations, the distributed object manager component () can also communicate with a replicator to replicate the data to the secondary cache nodes. The distributed object manager component () can also interact with failover manager systems (not shown) to clone regions to create new secondary or primary cache nodes during reconfiguration procedures subsequent to possible failures.","The object manager component () can further include a notification management component () that can track changes to regions and objects, and can relay notifications to delegates listening to those events. Moreover, applications can also register delegates for notifications on any cache node which may be different from the primary cache node on which the object resides. The distributed object manager component () can further manage the propagation of notifications in a distributed fashion including providing high availability for such notifications when the primary cache node fails. For example, this can be handled by maintaining a local lookup table indexed by delegate id on the cache node where the application registers the delegate. The primary cache node that stores the object can maintain the delegate id and the originating cache node information. When an object changes, the distributed object manager component () of the primary cache node can notify all the originating cache nodes, passing along the delegate id.","Similarly, the distributed object manager component () associated with the receiver can employ the lookup table to call the appropriate delegate, thus providing the change information to the application in a distributed fashion. For example, notifications can be asynchronous and can further be backed up using the same secondary cache nodes. Accordingly, in the event of failures, the secondary cache nodes can attempt to deliver the pending notifications, wherein in the event of primary cache node failure, notifications can be resent because the primary cache node may not have synchronized the information regarding the delivered notifications before failure. Since all notifications can carry the region, key and version information, the application can use the version to ignore duplicate notifications. Following are some examples of callback syntax.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Example - Region Level Callback"},{"entry":"public delegate CacheCallback"},{"entry":"elec_cbk = new CacheCallback( myclass.handler );"},{"entry":"catalog.addCallback(\u201cElectronicsRegion\u201d, elec_cbk);"},{"entry":"Callback called for any updates to region"},{"entry":"Example - Object Level Callback"},{"entry":"public delegate CacheItemRemovedCallback"},{"entry":"elec_cbk = new CacheItemRemovedCallback( );"},{"entry":"\/\/ Add the callback to the object ; the elec_cbk delegate will be called"},{"entry":"\/\/ whenever the object changes regardless of where the object is present"},{"entry":"catalog.Add(\u201cElectronicsRegion\u201d, \u201ckey\u201d, object, elec_cbk);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The availability substrate () can provide scalability and availability to systems that contain a storage component associated with the distributed cache. For example, the availability substrate can include load balancers, fail over managers, replicators and the like. A communication substrate () can provide for failure detection of cache nodes and reliable message delivery between cache nodes. The communication substrate () can interact with the availability substrate (). Moreover, the communication substrate () can also provide the communication channels and cluster management. The communication substrate () can provide callbacks whenever a new cache node joins the cluster or when a node dies or fails to respond to exchanged messages (e.g., heart beat messages). Moreover, the communication substrate () can provide efficient point-to-point and multicast delivery channels, and can further provide reliable message delivery for implementing replication protocols. For example, the communication substrate () can support notifications by maintaining delegate information in cache items and triggering the notification when items are modified. The communication substrate () can also trigger eviction based on policies defined at the region or named cache level.","B. Cache Topology",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 2","FIG. 3","FIG. 2"],"b":["220","201","203","205"]},"Alternatively, in the embedded application model the cache system can be embedded within the application itself as illustrated in . Such can occur by connecting the applications (, , ) (1 to k, k being an integer) together to form a cluster; for instance as embedding caches in ASP.net instances to form a cluster of ASP.net machines, wherein upon storing an item in a local cache it can be viewed from other machines. For example, the distributed cache runtime dlls can be compiled with the application and the application can act as the cache host for the distributed cache runtime. All the thread pools and memory can come from the application's container.","In a related aspect, a Load Balancer () can dynamically redistribute load across the cluster in the event that one or more nodes are inundated. For example, data can be repartitioned to spread it to nodes that have less loads. All such nodes can periodically send their load status as part of the configuration metadata. The load balancer () can also periodically query the configuration to determine which nodes are overloaded and can be balanced. For example, distributing the load may include repartitioning the overloaded partition of data on a primary node and spreading the overloaded partition to one (or more) of its secondary nodes. This may involve only a change in the configuration data (partition map) and no data movement (since the secondary nodes already have the data). In other scenarios, the data may be distributed to other non-secondary nodes since the secondary nodes themselves might be loaded and cannot handle the additional load. In such cases, either the data partitions on the secondary nodes (for which this node is the primary) can be further load balanced; or non-secondary nodes can be chosen to distribute the load, in which case in addition to the changes in the partition map, data can be moved.","C. Distributed Cache Structure",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 4","b":["400","410","411","412","410","411","412","422","423","410","411","412","433","433","433","436"]},"The following is a code example that shows the creation of a named cache and region.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ CacheFactory class provides methods to return cache objects"]},{"entry":[{},"\/\/ Create instance of cachefactory (reads appconfig)"]},{"entry":[{},"DataCacheFactory fac = new DataCacheFactory( );"]},{"entry":[{},"\/\/ Get a named cache from the factory"]},{"entry":[{},"DataCache catalog = fac.GetCache(\u201ccatalogcache\u201d);"]},{"entry":[{},"\/\/-------------------------------------------------------"]},{"entry":[{},"\/\/ Simple Get\/Put"]},{"entry":[{},"catalog.Put(\u201ctoy-101\u201d, new Toy(\u201cthomas\u201d, .,.));"]},{"entry":[{},"\/\/ From the same or a different client"]},{"entry":[{},"Toy toyObj = (Toy)catalog.Get(\u201ctoy-101\u201d);"]},{"entry":[{},"\/\/ ------------------------------------------------------"]},{"entry":[{},"\/\/ Region based Get\/Put"]},{"entry":[{},"catalog.CreateRegion(\u201ctoyRegion\u201d);"]},{"entry":[{},"\/\/ Both toy and toyparts are put in the same region"]},{"entry":[{},"catalog.Put( \u201ctoy-101\u201d, new Toy( .,.), \u201ctoyRegion\u201d);"]},{"entry":[{},"catalog.Put( \u201ctoypart-100\u201d, new ToyParts(...), \u201ctoyRegion\u201d);"]},{"entry":[{},"Toy toyObj = (Toy)catalog.Get(\u201ctoy-101\u201d, \u201ctoyRegion\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Each cache region () can include one or more cache items (). Each cache item can include an identifier such as a key (), a value or payload (), and one or more tags (). Cache regions may also be nested so that a cache region may include one or more other cache regions () and\/or one or more cache items ().","III. Unified Cache System",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 5","b":["500","520","530","540","500","520"]},"IV. Distributed Cache with Artificial Intelligence Component",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 6","b":["630","600","630","640"]},"The AI component () can employ any of a variety of suitable AI-based schemes as described supra in connection with facilitating various aspects of the herein described tools and techniques. For example, a process for learning explicitly or implicitly how or what candidates are of interest, can be facilitated via an automatic classification system and process. Classification can employ a probabilistic and\/or statistical-based analysis (e.g., factoring into the analysis utilities and costs) to prognose or infer an action that a user desires to be automatically performed. For example, a support vector machine (SVM) classifier can be employed. Other classification approaches include Bayesian networks, decision trees, and probabilistic classification models providing different patterns of independence can be employed. Classification as used herein also is inclusive of statistical regression that is utilized to develop models of priority.","As will be readily appreciated from the subject specification, classifiers can be explicitly trained (e.g., via a generic training data) as well as implicitly trained (e.g., via observing user behavior, receiving extrinsic information) so that the classifier can be used to automatically determine according to a predetermined criteria which answer to return to a question. For example, with respect to SVM's that are well understood, SVM's are configured via a learning or training phase within a classifier constructor and feature selection module. A classifier is a function that maps an input attribute vector, x=(x1, x2, x3, x4, xn), to a confidence that the input belongs to a class\u2014that is, f(x)=confidence(class). Moreover, a rule based mechanism can further be employed for interaction of a routing manager and a routing layer associated therewith (e.g., load balancing, memory allocation and the like).","V. Suitable Computing Environment","The word \u201cexemplary\u201d is used herein to mean serving as an example, instance or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs. Similarly, examples are provided herein solely for purposes of clarity and understanding and are not meant to limit the subject innovation or a portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented, but have been omitted for purposes of brevity.","Furthermore, all or portions of the described tools and techniques can be implemented as a system, method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware or any combination thereof to control a computer to implement the disclosed tools and techniques. For example, computer readable storage media can include but are not limited to magnetic storage devices (e.g., hard disk, floppy disk, magnetic strips . . . ), optical disks (e.g., compact disk (CD), digital versatile disk (DVD) . . . ), smart cards, and flash memory devices (e.g., card, stick, key drive . . . ). Additionally a carrier wave can be employed to carry computer-readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network (LAN). Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.","In order to provide a context for the various aspects of the disclosed subject matter,  as well as the following discussion are intended to provide a brief, general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer-executable instructions of a computer program that runs on a computer and\/or computers, those skilled in the art will recognize that the tools and techniques also may be implemented in combination with other program modules.","As used in this application, the terms \u201ccomponent\u201d, \u201csystem\u201d, and \u201cengine\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and\/or thread of execution, and a component can be localized on one computer and\/or distributed between two or more computers.","Generally, program modules include routines, programs, components, data structures, and the like, which perform particular tasks and\/or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the innovative methods can be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, mini-computing devices, mainframe computers, as well as personal computers, hand-held computing devices (e.g., personal digital assistant (PDA), phone, watch . . . ), microprocessor-based or programmable consumer or industrial electronics, and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However, some, if not all aspects of the tools and techniques can be practiced on stand-alone computers. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary environment () for implementing various aspects of the described tools and techniques is described that includes a computer (). The computer () can include a processing unit (), a system memory (), and a system bus (). The system bus () can couple system components including, but not limited to, the system memory () to the processing unit (). The processing unit () can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit ().","The system bus () can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures including, but not limited to, 11-bit bus, Industrial Standard Architecture (ISA), Micro-Channel Architecture (MSA), Extended ISA (EISA), Intelligent Drive Electronics (IDE), VESA Local Bus (VLB), Peripheral Component Interconnect (PCI), Universal Serial Bus (USB), Advanced Graphics Port (AGP), Personal Computer Memory Card International Association bus (PCMCIA), and Small Computer Systems Interface (SCSI).","The system memory () can include volatile memory () and\/or nonvolatile memory (). The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer (), such as during startup, can be stored in nonvolatile memory (). By way of illustration, and not limitation, the nonvolatile memory () can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), or flash memory. The volatile memory () can include random access memory (RAM), which can act as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), and direct Rambus RAM (DRRAM).","Computer () can also include removable\/non-removable, volatile\/nonvolatile computer storage media.  illustrates a disk storage (), wherein such disk storage () can include, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-60 drive, flash memory card, or memory stick. In addition, disk storage () can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage () to the system bus (), a removable or non-removable interface is typically used, such as interface ().","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment (). Such software can include an operating system (). The operating system (), which can be stored on disk storage (), can act to control and allocate resources of the computer (). System applications () can take advantage of the management of resources by operating system () through program modules () and program data () stored either in system memory () or on disk storage (). It is to be appreciated that various components described herein can be implemented with various operating systems or combinations of operating systems.","A user can enter commands or information into the computer () through input device(s) (). Input devices () include, but are not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, TV tuner card, digital camera, digital video camera, web camera, and the like. These and other input devices connect to the processing unit () through the system bus () via interface port(s) (). Interface port(s) () include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB). Output device(s) () use some of the same type of ports as input device(s) (). Thus, for example, a USB port may be used to provide input to computer (), and to output information from computer () to an output device (). Output adapter () is provided to illustrate that there are some output devices () like monitors, speakers, and printers, among other output devices () that utilize such adapters. The output adapters () include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device () and the system bus (). Other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) ().","Computer () can operate in a networked environment using logical connections to one or more remote computers, such as remote computer(s) (). The remote computer(s) () can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to the computer (). For purposes of brevity, only a memory storage device () is illustrated with remote computer(s) (). Remote computer(s) () is logically connected to the computer () through a network interface () and then physically connected via a communication connection (). The network interface () encompasses communication networks such as local-area networks (LAN) and wide area networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet\/IEEE 802.3, Token Ring\/IEEE 802.5 and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","A communication connection(s) () refers to the hardware\/software employed to connect the network interface () to the bus (). While the communication connection () is shown for illustrative clarity inside computer (), it can also be external to the computer (). The hardware\/software for connection to the network interface () includes, for exemplary purposes only, internal and external technologies such as, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 8","b":["800","800","810","810","800","830","830","830","810","830","800","850","810","830","810","860","810","830","840","830"]},"VI. Cache Data Management","Distributed caches can solve the problem of data scale and performance by caching keys and their corresponding values across multiple cache nodes. As is discussed above, the data manager component in a distributed cache can handle the storage of the cache data.","Data management components often use data structures to map a key to a corresponding cache value, such as one or more values in a cache item or a cache region. For example, such a data structure may be in the form of a hash table that can be used as a main lookup data structure to look up and access cache values stored in the cache. Hash tables are data structures that map one or more keys to one or more corresponding values in an efficient fashion. The mapping can be done by hashing a key into an identifier, known as a hash key, and using that identifier to look up the corresponding cache value. Hash tables are often used for looking up and accessing cache units in caches. There are several design challenges in building a data manager that is scalable and efficient. The tools and techniques discussed below can address some of those challenges and\/or provide improvements in cache data management.","A. Multiple Cache Directories","A multi-directory cache lookup data structure can be used to provide scalability and efficiency. In one embodiment, a multi-directory hash table can be used.","Referring now to , a main cache lookup data structure (), such as a hash table, can include a hierarchy of directories. If hash keys () are used as identifiers for cache objects (i.e., cache units, which may be cache items, cache regions, etc.) using a cache directory, then the hash keys () can be produced from original keys, such as keys provided by users or applications accessing the cache, using standard hashing functions.","A first portion () of the hash key () can be used to identify a location in a parent directory (). A directory is an array of pointer slots (). Each slot () in a directory, such as the parent directory (), can include a pointer (). For example, the pointer () can point to a cache object or cache unit () or to a subdirectory or child directory (), which can also include pointers to one or more other directories and\/or one or more cache objects. One or more of the slots in each directory (, ) may be null or empty, so that the slot does not include a pointer (). The cache lookup data structure () can include a hierarchy of such directories. A specific slot () in the directory () can be identified using an offset () from a default position, such as a beginning of the directory (). This offset () for the parent directory () can be specified by the first portion () of the hash key (). A second portion of the hash key () may specify an offset to a specific slot in the child directory (), which can point another child directory or to a cache object, such as a cache unit. Thus, the hash key () can correspond to a cache unit, and the portion(s) of the hash key () can be used to follow pointer(s) in the directories of the cache lookup data structure () to locate and access the cache unit.","In one implementation, the first portion () of the hash key () can be an integer specifying the offset () as a number of slots from a default position (such as the beginning of the directory), and the integer can have a fixed number of bits. The directory size (i.e., the number of slots in the directory) can also be fixed at a size that allows the integer to identify any of the slots in the directory. For example, if the offset integer uses b bits, then n=2can be the size of the directory ().","The offset of a root directory can be specified in the first n least significant bits of a hash key. For example, if the first two significant bits were used as the integer to specify offset, then a root directory could have a size of four, with slots  to . If a hash key 01100100 was used as a hash key identifier for a cache object, then a pointer to the object could be placed in slot  (zero offset) of the root directory because the first two least significant bits are zero (in binary).","Directory overflow (i.e., hash key conflict) can occur if hash keys of two different keys have the same n least significant bits. In this case, a sub directory can be created and the subdirectory can include pointers to objects corresponding to both keys, using the next n least significant bits of the hash keys.","It may be useful to estimate the number of number of items that are going to be identified by the hash table, and to allocate the root directory to be large enough to accommodate that number of items. Doing so can help avoid frequent conflicts between hash keys, and thus prevent frequent creations of additional directories in the hash table. Indeed, if no conflicts occur between hash keys, then the hash table can operate in a manner similar to a standard static hash table. However, it can also be extensible by using additional new subdirectories to accommodate larger numbers of cache items and corresponding hash keys that can produce conflicts.","1. Multi-Directory Hash Table Examples","Referring now to , an example of a multi-directory hash table () will be discussed. The hash table () can include a root directory () with 4 slots, which can be numbered according to the numbers in the boxes illustrating those slots in  (i.e., 0, 1, 2, and 3). The slots of the root directory () can be addressed by the two least significant bits of hash keys, i.e., those two least significant bits can specify the offset to the corresponding slot in the root directory (). In this example, the hash keys can be the same as numeric keys given by a user, although they could be derived from the user-specified keys (e.g., names, numbers, etc.) using a hashing function. In either case, the hash keys can be hashed into the root directory () using the first n least significant bits of each hash key, where n is 2 in the example of . Initially, as shown in the left side of , the root directory () can include four pointers (, , , ) to four corresponding cache objects ():\n\n","A new operation \u201cadd(25)\u201d () can be invoked to add a new entry to the hash table () pointing to an object with a corresponding hash key () of 25, or binary 00011001, with a first portion (the first two least significant bits ()) being 01, or one. Accordingly, the two least significant bits of the new hash key (01) are the same as the existing hash key 5 (also 01). Accordingly, there is a hash conflict in slot  in the root directory () because two hash keys (5 and 25) both specify that same slot. In such case, the hash table can be rehashed, as shown on the right side of . Specifically, the pointer () in slot  in the root directory () can point to a new subdirectory (), which can be a newly-created directory, although it could alternatively be a previously-created directory. In the new subdirectory (), the keys that correspond to slot  in the root directory () can be rehashed using the next 2 least significant bits. The next two least significant bits for hash key 5 are 01, and the next two least significant bits for hash key 25 are 10. Accordingly, the subdirectory () can include pointers ( and ) to the cache items or objects () corresponding to hash keys 5 and 25 as follows: slot  of the subdirectory () can include a pointer () to the object corresponding to the hash key 5, and slot  of the subdirectory () can include a pointer () to the object corresponding to the hash key 25. Accordingly, this conflict can be resolved by extending the hash table () to include a new subdirectory () that points to the objects () corresponding to the conflicting hash keys.","Note that if new directories are always created according to the technique described with reference to , it may result in creating more subdirectories than are needed to resolve the conflict. This scenario will be discussed with reference to a specific example illustrated in .  illustrates a hash table () with the same initial state (illustrated on the left side) as the hash table () discussed above with reference to the example of , including a root directory () with pointers (, , , and ) pointing to corresponding objects () whose hash keys have the same values as the objects () illustrated in the initial example of .","An operation \u201cadd(42)\u201d () can be invoked to add a pointer to a new object with a corresponding hash key () of 42, or 00101010 in binary. The hash key () can have a first portion () (the first two least significant bits) of 10, a second portion () (the next two least significant bits) of 10, and a third portion () (the next two least significant bits) of 10. Because the first portion () has the bits  corresponding to slot  in the root directory, the hash key () can be assigned to that slot. That assignment results in a conflict on slot  in the root directory because the existing hash key 10 (binary 00001010) is already assigned to slot .","As discussed above and illustrated in the right side of , in response to the conflict, the hash table () can be extended to include a new subdirectory (), and the pointer () in slot  of the root directory () can point to the new subdirectory (). The conflicting keys 10 and 42 can be hashed in the new directory () using the next two least significant bits (second portions) of the conflicting hash keys. However, the next two least significant bits for 10 and 42 (second portions) are both 10, and both identify slot  in the new directory (). Accordingly, these keys also result in a conflict in the new directory (). New subdirectories can continue to be created until the conflict is resolved.","Here, a pointer () from slot  in the new subdirectory () can point to another new subdirectory (), and the keys 10 and 42 can be rehashed to this new directory () using the next two least significant bits (third portions) of the conflicting keys. For the key 10, the next two least significant bits are 00, so the key 10 can be assigned to slot  in the new directory (). For key 42, the next two least significant bits are 10, so key 42 can be assigned to slot  in the new directory. Thus, the new directory can include two pointers ( and ) pointing to the cache objects () corresponding to keys 10 and 42, with the pointer () in slot  pointing to the object corresponding to key 10 and the pointer () in slot  pointing to the object corresponding to key 42.","Accordingly, the operation \u201cadd(42)\u201d () can result in two new directories ( and ) being formed to resolve a single conflict. To avoid having multiple directories formed to resolve a single conflict, it is possible to just split on the bits that resolve the conflict. Referring to , the same conflicting keys from  are illustrated hashed into a hash table (), with a root directory () having pointers (, , and ) pointing to respective objects () corresponding to hash keys 0, 5, and 15. As with the example in  discussed above, there is a conflict in slot  of the root directory () between keys 10 and 42. Accordingly, the pointer () in slot  of the root directory () can point to a new subdirectory (). However, instead of forming two new directories to resolve the conflict, a mask () can be applied to hash the keys into the single new directory () using the bits of the hash keys that resolve the conflict. In this case, the mask () can specify that the fifth and sixth least significant bits are the second portions of the keys that will be hashed into the new directory (). For example, this can be specified by the mask () having the binary value 00110000, where the 1's specify the bits to be used in hashing keys into the new directory (). Accordingly, the new directory () can include pointers ( in slot  and  in slot ) pointing to respective objects () corresponding to hash keys 10 and 42.","Thus, the masking technique illustrated in  and discussed above can split on the bits that resolve the conflict and avoid the creation of unneeded subdirectories or levels. To do this, a data manager component can keep track of the mask of the bits for each subdirectory and compute slot numbers for hash keys using the corresponding masks.","2. Hash Table Nodes","A lookup hash table can include and point to different kinds of hash table nodes, such as those described below. A hash table can point to object nodes, which can each include an actual cache unit (such as a cache item or region) and a hash key derived from a key corresponding to the cache item.","A hash table can include different types of directory nodes, including internal nodes and conflict nodes (for completely conflicting hash values). Both internal nodes and conflict nodes can each contain an array of directory entries. An internal node is a directory, which can point to one or more other directory nodes, conflict nodes, and\/or object nodes. To access a node to which a directory is pointing, a number of offset bits can be specified for the directory. As discussed above, a directory slot or entry can be specified with an offset or depth value, which can have the number of offset bits, and can specify the offset into the directory. For example, if there is a 10-bit offset (size of directory is 1024), then in a root directory node, the depth or offset can be specified using the 10 least significant bits of a hash key. For a directory node one step below the root directory node, the next 10 least significant bits of a hash key can be used to specify the depth or offset.","The problem of conflicts, which was discussed above, can be more serious if there is a perfect hash conflict, where two different objects are assigned the same hash key. To deal with such a situation, a data structure such as a hash table can include conflict nodes. The hash table can store objects with pointers to the cache items corresponding to all of the conflicting hash keys. The conflict nodes can store such objects or pointers to such objects. Conflict nodes can be extended to accommodate as many keys as hash to the same hash key. Conflict nodes can be implemented as chained buckets to keep track of objects with conflicting hash key values. A get operation on such a conflict node can scan all the objects pointed to by the conflict node and look for the given key. The buckets can include multiple conflict nodes, and a conflict node level lock can be implemented when a change is made to any of the slots in the conflict node. Alternately, conflict nodes could be implemented in some other way, such as using concurrent linked lists, where locks may not need to be taken on an entire list when changes to the list are made.","Referring now to , hash table nodes in an example of a multi-directory hash table () will be discussed. In the illustrated example, a root directory or internal node () can include pointers ( and ), with one pointer () pointing to a subdirectory or internal node () and another pointer () pointing to an object node (). The lower level internal node () can include pointers ( and ), with one pointer () pointing to a conflict node () and another pointer () pointing to an object node ().","3. Multi-Directory Cache Lookup Techniques","Referring now to , a multi-directory cache lookup technique will be described. As with other techniques described herein, this technique can be used with the cache systems and components discussed above and\/or with other combinations of systems and components. In the technique, a first portion (such as a first number of least significant bits) of a first identifier identifying a first cache unit (such as a cache item or region) can be used to assign () the first identifier to a slot in a first directory in a cache lookup data structure. One or more other identifiers may previously have been assigned to the first directory as well. These assignments can be made in various ways, such as placing pointers to the items in directory slots if the slots are not yet filled, or placing pointers to other directories that can lead to the items through a chain of one or more pointers if the slots have already been filled.","It can be determined () whether one or more other identifiers have been assigned to the slot, or in other words whether multiple identifiers, including the first identifier and one or more other identifiers, will be assigned to the slot. If not, then the technique can come to an end. Note that references to the \u201cend\u201d and \u201cstart\u201d of techniques discussed herein and in the accompanying figures is for convenience; additional operations, acts, etc. may occur before and\/or after what is illustrated and discussed. If multiple identifiers will be assigned to the same slot in the first directory, then a second portion of the first identifier can be used to assign () the first identifier to a slot in a new directory, which can be a pre-existing or newly-created directory other than the first directory. For example, it can be determined whether the first slot in the first directory holds a pointer to another directory. If so, then that other directory can be the new directory. If not, then the new directory can be created and a pointer to the new directory can be inserted in the slot in the first directory where the conflict occurs. A second portion of each of the one or more other identifiers can be used to assign () each of the one or more other identifiers to one or more slots in the second directory. As an example, the first portion may be the first n least significant bits in the corresponding identifier, the second portion may be the next n least significant bits in each identifier, etc. Alternatively, the second portion may be identified by a mask, such as a mask that identifies bits that distinguish between the keys. It can also be determined () whether the new assignments to the new directory will result in multiple identifiers being assigned to the same slot in the new directory. If not, then the technique can come to an end. But if so, then the conflicting identifiers can be assigned to another new directory. This technique can continue to loop through the determination () and the assignment ( and ) of the identifiers to slots in new directories using new portions of the identifiers until the identifiers are assigned to different slots in a directory or it is determined that the identifiers are the same. If the identifiers are the same, then the identifiers can be assigned to a conflict node that points to the cache units corresponding to the identifiers or that includes the identifiers.","The technique can also include, for each conflicting slot in an existing directory to which multiple identifiers are assigned, inserting a pointer to the new directory where the multiple identifiers are assigned as well. In this way, the identifiers can be assigned to one or more slots in the new directory and to the conflicting slot in the existing directory. The identifiers discussed above with reference to  can be hash keys, and the directories can be included in a multi-directory cache lookup data structure, such as a multi-directory hash table.","B. Compaction","As discussed above, using multiple cache directories to resolve conflicts between keys may lead to some unnecessary directories being created, which can adversely affect performance of the directory structure. To address this issue, directories in a lookup data structure can be compacted. Specifically, if a directory node points to less than two other hash table nodes (i.e., if only one or none of the directory slots is filled), the directory node can be removed. It can be desirable to perform this removal\/compaction operation without taking latches or locks that would cause failures for read and write operations.","Referring now to , a compaction technique will be discussed, starting with an example of a directory node pointing to less than two other hash table nodes. Specifically, referring to the top portion of , initially a parent directory () may include pointers ( and ) in slots  and . The pointer () can point to other hash table nodes that are not illustrated. The pointer () in slot  of the parent directory () can point to a leaf directory (). The leaf directory () can be empty except for a pointer () in slot  pointing to a cache unit ().","In compacting this or similar structures, a first count can be performed, counting the non-empty slots in a directory, such as the leaf directory () of . If the result of this first count is found to be greater than one, then the technique can return control. If not, then there is no more than one item or pointer in the directory (). If this is the case, then the slot in the parent directory () can be replaced with a self-pointer () resulting in a self-loop, as is illustrated in the middle portion of . With this self-pointer () in place, read and write operations intended for the leaf directory () and the cache unit () will continue to loop so that no locks are needed during the compaction technique. After this self-pointer () is in place, a second count of pointers in the leaf directory () can be performed to assure that no items or pointers have been added to the leaf directory () since the first count. If the second count is not equal to the first count, then the technique can replace the self-pointer () with the original pointer () in the parent directory () and return control without compacting.","If the second count is equal to the first count, then the slot in the parent directory () can be replaced with the same pointer () that was found in the child directory (). If no pointers were found in the child directory in the first and second counts, then the slot in the parent directory can be null or empty. The slot in the child directory may include a temporary pointer () back to the parent directory to assure that any operations that were en-route to the slot in the child leaf directory () will be redirected to the parent directory (), and then to the cache unit ().","Referring now to , a general compaction technique will be discussed. In the technique, a multi-directory data structure, such as a hash table, can have directories including a root directory and one or more lower directories below the root directory. The directories can each include one or more directory items each pointing to another directory or to one or more cache units. In the technique it is determined () whether a child or subject directory in the data structure includes more than one item, such as a pointer to another directory or a cache unit. The child directory can be pointed to by a parent pointer in a parent slot in a parent directory. If the child directory does not include more than one item, then the parent pointer can be removed () from the parent slot. If the child directory has only one item, then removing () the parent pointer can include replacing the parent pointer with the one item from the child directory. If the child directory has no items, then removing () the parent pointer can include leaving the parent slot empty, or null.","Determining () whether the child directory has more than one item can include performing a first count of non-empty slots in the child directory, replacing the parent pointer in the parent slot with pointer that points to itself, and performing a second count of non-empty slots in the child directory. Removing () the parent pointer may be done if the first count is not more than 1 and the second count is equal to the first count, or not more than 1.","C. Write-Only Latches","In a typical cache, the number of reads (cache hits) are higher than the number of writes. Accordingly, it can be useful for a cache to satisfy reads faster than writes. Additionally, it can be desirable for a cache to facilitate concurrent operations on the cache. For example, it can be useful for a distributed cache to perform efficiently in a multi-core machine, where multiple read and\/or write operations may be occurring at the same time. In dealing with such concurrent operations, it can be useful for a cache to be able to handle write operations without locking out read operations. In addition, it can be useful for a cache hash table to handle large numbers of read requests without contention between resulting read operations.","Common Language Runtime (CLR) supports an existing hash table that is not distributed. The CLR hash table is thread safe for use by multiple reader threads and a single writing thread. It is thread safe for multi-thread use when only one of the threads perform write (update) operations, which can allow lock-free reads, provided that the writers are serialized to the hash table. To support multiple writers, all operations on the hash table must be done through the wrapper returned by the Synchronized method. The Synchronized method supports multiple writing threads, provided that no threads are reading the hash table. The synchronized wrapper does not provide for write-only locks on the hash table, and does not provide thread-safe access in the case of one or more readers and one or more writers. Whatever the advantages of such a hash table, it does not provide the advantages of the write-only latch tools and techniques discussed herein.","While concurrent operations are occurring in a cache lookup data structure, such as a hash table, it can be desirable for put and get operations to be atomic, so that an entire put or get succeeds or fails together. It can also be desirable for objects to be returned in some consistent state in response to get requests. In addition, it can be desirable to avoid losing requested updates to the data structure as a result of concurrent operations. In addition, as discussed above, it can be desirable to avoid blocking read-only operations.","Latches can be used to help ensure atomicity of get and put operations in a cache lookup data structure, such as a hash table, in case of concurrent modifications to the structure. Referring to , a directory node () can include one or more directory entries (), such as entries in the directory slots discussed above. Each directory entry () can include a latch (), which can toggle between a latched state and an unlatched state. Each directory entry () can also include a node pointer (), which can point to another node, such as one of the types of nodes discussed above with reference to  (object node, internal node, etc.). Write operations can flip the latch () to latch the directory entry () before changing the node pointer (), which can change the reference to which the directory entry points. Upon completion of a write operation, the latch () can be flipped back to the unlatched state.","Each object node that is referenced by a directory entry can be in a consistent state so that reads done without taking latches will always see the consistent object. This can occur by avoiding changes to the object nodes referenced by the lookup data structure. As discussed below, instead of making such changes or updates directly to the object node itself, a new object node can be saved and prepared for access, and then a pointer to an existing object node can be replaced with a pointer to the new object node. Thus, read operations can return either the full existing object node or the full new object node\u2014in either case the object returned can be consistent and the operation can be atomic.","1. Write Operations","Write operations can include pre-operations and post-operations, which can be performed while the subject directory entry is latched. The pre- and post-operations can be delegated with a command, such as the following: void PrePostOperation(object oldItem, object newItem).","In performing the write operations, a hash key corresponding to a given key corresponding to the cache unit of interest can be found. A leaf directory corresponding to the hash key can be found. For example, this can include using a first n least significant bits of the hash key to find a slot in a root directory, following a pointer in that slot, using the next n least significant bits of the hash key to find a slot in a subdirectory below the root directory, following a pointer in that subdirectory, etc. until a leaf node corresponding to the given hash key is found. The slot number corresponding to the given key in the leaf directory can be found, and the slot can be latched. If the slot is pointing to an internal node, the latch can be released, and the operation can resume following the links in the directories.","Once the object node is found, sanity checks and pre-operations can be performed on the latched slot and the referenced object node. For example, the operation can check whether the key for the object of interest matches the one in the object node that was found. If one or more of these checks fails, an error can be thrown, which may result in the slot being unlatched and the write operation being terminated.","If the checks succeed, the new pointer pointing to the new object node can be retrieved and marked as uncommitted (i.e., not currently in use). In addition, the existing committed pointer (i.e., the pointer that is currently in use) can be linked with the new pointer, and the new pointer can be placed in the slot.","A check can be done to determine whether a compaction of the directory structure would result in a bypass the slot. Specifically, the operation can check whether a parent hash node slot that should be pointing to the hash node with the slot of interest is actually pointing to some other node. If so, then any changes can be rolled back, the latch can be released, and the technique described herein can resume with traversing the directory structure to find the correct slot that is currently pointing to the cache unit or object of interest, and sanity checks can be performed again, the new pointer can be placed in the new slot, etc.","Standard post-operations can then be performed to prepare for use of the new cache unit. It can be desirable attempt to prevent the post-operations from failing, although the pre-operations discussed above may fail (such as if the sanity checks fail). The new pointer in the slot can then be marked as committed and the slot can be unlatched.","This general write operation can be used to implement specific operations like Add, Put, Delete, etc. in similar ways.","2. Read Operations","As discussed above, read operations, such as get operations, can be done without taking latches. A read operation can include finding a hash key corresponding to a given key for a cache unit to be read. The look-up data structure can be traversed from a root directory to find the object node corresponding to the given hash key. If the given key matches the one present in the object node, then the cache unit pointed to by the committed pointer, i.e., the cache unit in the committed object node, can be returned.","3. Write-Only Latch Technique","A write-only latch technique will be described with reference to . In the technique, a slot can be latched () to prevent other write operations while a subject write operation () is performed on an existing cache unit that is pointed to by an existing committed pointer in a cache directory slot. However, the latching () can allow read operations on the cache unit during the write operation (). The write operation () can include inserting () a new uncommitted pointer in the slot, and then marking () the new pointer as being committed. In addition, the slot can be unlatched () after the write operation is complete.","The write operation () can be any of a variety of write operations, such as a delete operation or an update operation. The write operation () may proceed even while one or more read operations are being performed on a cache unit. Those read operations can produce consistent data corresponding to the cache unit prior to the write operation.","D. Eviction and Expiration","It can be useful for a cache to efficiently handle eviction and expiration of objects. Eviction from a cache can be based on a policy, such as a least recently used policy or a least frequently used policy. In addition, expiration from a cache can be based on a time to live for a particular object. Eviction and expiration can be used for removing items, directories, etc. from a lookup data structure and from a cache to limit the memory consumption of the structure and the cache.","The granularity of cache clean-up using eviction and expiration can be defined by defining the candidates for removal. For example, candidates may include cache units or object nodes that are pointed to by an entry in a leaf directory, and\/or directories themselves. In addition, the cache units can be cache items, cache regions, etc. The candidates can be selected for removal based on their priority. This priority can be decided using statistics maintained along with the candidate in the lookup data structure. For example, the statistics can include a time to live and a creation time for a particular candidate, which can define the candidate's expiry status. In addition, the statistics can include a last access time for each candidate, which can define the candidate's eviction priority (e.g., according to a least recently used priority policy).","1. Eviction and Expiration Using Different Priority Queues","Referring to , using the priority statistics, a data manager component () can maintain a priority cleanup queue (PCQ) () of removal candidates. The data manager component () can perform a memory cleanup operation and can remove candidates in priority order using the PCQ (). For candidates having the highest possible priority of removal, sorting my not need to be done. These high priority candidates can be listed in a separate immediate cleanup queue (ICQ) (). In this context, \u201cimmediate\u201d does not mean that the candidates must be instantly deleted when they are included in the ICQ (). Rather, in response to a request for a candidate for cleanup, the data manager component () can return a candidate from the ICQ () before returning candidates from the PCQ (). The data manager component () can also maintain a separate queue for items to be sorted (TBSQ) (). When candidates are to be removed from the cache, the data manager component () can perform the removal by instructing an object manager component () to explicitly remove selected candidates returned from the ICQ () and\/or PCQ (). Each of the queues (, , and ) can include pointers to the actual candidates for removal, although they could include the candidates themselves.","The priority statistics (e.g., last access time) can be modified by each operation on the particular candidate. For example, in a least recently used strategy, the read operations and\/or write operations typically make the candidate being written or read the least suitable for eviction. Accordingly, after any such operation, the PCQ () may not be accurate until the PCQ () is sorted again.","Operations can check whether a candidate associated with a key is expired upon each operation, periodically, or according to some other scheme. If a candidate is expired, the candidate can be included in the ICQ (). Candidates can also be included in the ICQ () on-demand when the ICQ () is found to be empty upon receiving a request to remove an item from the cache. However, a removal request may not result in an immediate traversal and re-sorting of the PCQ () or TBSQ ().","Because sorting can be a resource-intensive operation, and sorting more candidates takes more resources, different approaches can be taken to reduce the number of candidates sorted by each sort operation. For example, a specified batch size can be selected, where only the batch size number of candidates are selected for each sort run, and\/or multiple TBSQ's () can be used to distribute the items to sort.","Following is a discussion of an example approach that can be taken to sort and remove candidates from a cache. A removal request can result in the selection of a candidate from either the head of the ICQ (), or if ICQ is empty (even after trying to repopulate it), then from head of the PCQ (). This candidate can be deleted explicitly by the object manager component (). This can be done for as many candidates as are requested to be removed.","The ICQ () and the PCQ () can be maintained by a sweeping technique. The sweeping technique can include walking over the PCQ () and the TBSQ () and finding candidates in those queues that are eligible for immediate cleanup (e.g., the expired candidates). Such candidates can be moved to the ICQ ().","The PCQ () can be maintained using a mark-and-sweep strategy. When a statistic for a candidate is updated (typically indicating that the candidate has been accessed), the candidate can be marked with a flag. When marked candidates are encountered in the PCQ () by an operation responding to a removal request, the marked candidates need not be removed. Instead, when marked candidates are encountered by such requests, the candidates can be moved to the TBSQ ().","During a sweep, the unsorted candidates can be collected from TBSQ () and unmarked. The collected candidates can be sorted, and the sorted candidates can be merged with the existing candidates in the PCQ ().","Sweeping can be invoked in various ways. For example, sweeping can be invoked asynchronously by a separate thread that calls a sweeping module periodically, and\/or on-demand when the corresponding queue is empty upon receipt of a removal request.","2. Eviction and Expiration Techniques","Referring now to , an eviction and expiration technique will be discussed. In the technique, a low priority cleanup queue can be maintained (). The low priority queue can list low priority removal candidates to be removed from a cache, the low priority removal candidates being sorted in an order of priority for removal, such as in a least recently used priority or a least frequently used priority. A high priority cleanup queue can also be maintained (). The high priority cleanup queue can list high priority removal candidates to be removed from the cache, such as candidates that are identified as being expired. A to-be-sorted queue can also be maintained (). The to-be-sorted queue can list removal candidates to be sorted in the low priority queue and\/or the high priority queue. A request for removal can be responded to (). Responding () can include returning () one or more removal candidates from the high priority cleanup queue if the high priority cleanup queue lists any high priority removal candidates. Responding () can also include returning () one or more low priority removal candidates from the low priority cleanup queue if no more high priority removal candidates remain in the high priority cleanup queue. The low priority removal candidates can be returned in an order of priority for removal. In addition, the returned candidates can be deleted (), such as in an order in which the candidates are returned.","Maintaining the low priority cleanup queue, the high priority cleanup queue, and the to-be-sorted queue can be done by listing new removal candidates in the to-be-sorted queue, identifying in the low priority cleanup queue and the to-be-sorted queue eligible candidates for listing in the high priority queue, moving the eligible candidates to the high priority queue, sorting the removal candidates in the to-be-sorted queue, and merging the candidates in the to-be-sorted queue with the low priority candidates in the low priority queue.","E. Enumeration","It can be useful for a cache to be efficient and scalable in terms of enumeration of the cache contents, especially if the contents are sent out of a cache server to cache clients. Typical cache server enumerations, which maintain state on the server side and do not do bulk operations, cannot be easily scaled. As used herein, an enumeration of a cache is a listing of all or part of the cache contents in an ordered manner. For example, this can include returning a cache unit, receiving a get next request and returning the next cache unit, etc. Enumeration can be done by traversing a lookup data structure, such as a hash table, that is used for accessing a cache. However, it can be difficult for a server interacting with numerous clients to maintain the state of each enumeration.","1. Stateful Enumerator","In one enumerator embodiment, an enumerator is implemented using traversal, such as depth first traversal of a cache lookup data structure, such as a multi-directory hash table. Referring to , a state of an enumeration can be maintained using a state stack () of state nodes (EnumStateNode) (), with each EnumStateNode () including the following information: directory node (DirNode) (), and index of last returned item (Index) (). DirNode () can include a pointer to a corresponding directory node in the cache lookup data structure that is being traversed, and Index () can indicate the index (or offset) under traversal in that directory node.","Each time the traversal extends another level deeper into the lookup data structure, a new EnumStateNode () can be created and pushed onto the top of the state stack (). Thus, the EnumStateNode () at the top of the stack can include a DirNode () pointing to the current directory node under traversal and an Index () indicating where the next traversal should start. When the traversal exhausts a directory node (and all child nodes of that directory node) in the lookup data structure and ascends up a level to a parent directory node, the EnumStateNode () corresponding to the exhausted directory node can be discarded, leaving EnumStateNode () corresponding to the parent directory node at the top of the state stack. Every GetNext operation can pop the EnumStateNode () from the top of the state stack () and start traversal from the directory node indicated by DirNode () in that EnumStateNode (). Once the enumerator has located the next object node, the enumerator can push the EnumStateNode () back to the top of the state stack () with current directory node as DirNode () and the current index+1 as Index (). The cache data in that next object can be returned. For example, the cache data may be returned to a cache client that sent a request for cache data by sending a GetNext request.","If directory nodes of the lookup data structure have been compacted, as discussed above, the state indicated by the state stack may no longer be valid. Hence enumerations may be invalidated by compaction.","The enumerator may be designed so that it does not deal with concurrent GetNext calls and is not shared for concurrent operations. However, if users desire to share such an enumerator across threads, then user-level concurrency control primitives could be used for GetNext access.","Referring now to , a stateful enumeration technique will be discussed. In the technique, in response to receiving a cache data request, such as a GetNext request, an enumeration of cache units can be performed (), such as by traversing a multi-level cache lookup data structure. The data structure can include internal nodes and object nodes, with the object nodes corresponding to the cache units.","In addition, an enumeration state stack can be maintained (). The state stack can include state nodes, and can indicate a current state of the enumeration. For example, each state node can include a node identifier and a state index, as discussed above. The state nodes can correspond to a set of the internal nodes in the data structure, with the set of internal nodes forming a path from an internal node under traversal in the data structure to an internal root node in the data structure. Maintaining () the state stack can include adding () a state node to the state stack when traversing down a level in the data structure as part of the enumeration. Maintaining () the state stack can also include removing () a state node from the state stack when traversing up a level in the data structure as part of the enumeration.","The technique can also include returning () cache data located in the enumeration. The cache data could include various types of data, such as a cache unit or a batch of cache units.","2. Stateless Enumerator","In another enumerator embodiment, a stateless batch enumerator can be useful in networked environments such as client-server environments. A cache server can expose a batch application programming interface (API), which can return a batch of data objects, and a client can enumerate on that batch. Once that batch is exhausted, the client can ask for a next batch from the server. The batch API can also be configured to send a current state of the enumeration between the server and client. For example, each time a client requests a batch, the client can send the state of the enumeration to the server along with the batch request. When the server returns the next batch, it can send an updated state of enumeration, which the client can store until the client requests the next batch of cache data.","Accordingly, enumeration can be done without maintaining the state of the enumeration on the server. This can save memory on the server, especially when the server is concurrently dealing with a large numbers of client enumerations.","Moreover, the batching can save resources because the client can cache each batch and does not need to call the enumerator on the server every time a GetNext command is received. Instead, the client can retrieve the data from the pre-fetched data in the batch.","As discussed above, the stateful enumerator can maintain a state stack, which can indicate a current state of enumeration over directory and conflict nodes. Referring to , the same state can be maintained in an enumeration state object (). The enumeration state object () can include a parent identifier (), which can be used to store an identifier such as a hash code of a parent hash table to check whether the batch request is called on the correct cache lookup data structure (such as the correct hash table). The enumeration state object () can also include a creation time (), which can be compared with compaction times for the cache lookup data structure to determine whether any compactions invalidate the enumeration.","In addition, the enumeration state object () can include a conflict index () and a path (), which can each be an unsigned integer variable. The path () indicate a current state of the enumeration and can thereby assist in locating a slot to be visited next in the traversal for the enumeration, and the conflict index () can provide a current index in a conflict node if the enumeration is currently traversing a conflict node. For an object node, the conflict index () can be null or zero.","Still referring to , the path () can include multiple portions (, , and ), each of which can provide an offset for a specified item in a directory, so that the overall path can specify a specific slot, such as the next slot after the slot pointing to the last object returned in the last batch sent to the client. For example, as shown in , a first portion () of the path () can be four, indicating slot  in a root directory (), which can include a pointer () pointing to a subdirectory (), which can include a pointer () to one subdirectory () and another pointer () to another subdirectory (). A second portion () of the path () can indicate slot  in the subdirectory (), which can indicate a subdirectory () pointed to by the pointer () in slot . The third and final portion () of the path () can indicate slot  of the subdirectory (), which can indicate a current slot for the enumeration, such as where slot  is the slot for the traversal to resume for the enumeration. If slot  of the subdirectory () were to point to a conflict node, then the conflict index () could indicate an index in the conflict node where the traversal is to resume.","As noted above, a state object () can be sent to a cache client with each batch of cache data from the enumeration. Each time the client requests data, the client can send the state object () along with the request. Accordingly, the enumeration can proceed without maintaining the state of the enumeration on the server.","Referring now to , a first enumeration request with a first state object can be received () at an enumerator, such as where the enumerator is at a cache server and receives the first enumeration request from a cache client. The first enumeration request can request cache data from a cache, and the first state object can indicate a state of an enumeration of the cache. Cache data to be sent in response to the request can be identified () using the first state object, and the identified data can be sent (). Identifying () the cache data to send using the first state object can include traversing a data structure that points to object nodes corresponding to cache units in the cache. The data structure can be a multi-level hash table data structure that includes internal nodes and object nodes, where one of the internal nodes points to each object node.","Moreover, a second state object can be sent () with the cache data in response to the first request, and a second enumeration request with the second state object can be received (), such as at an enumerator in a cache server. Accordingly, the enumeration can proceed without the state of the enumeration being maintained at the enumerator or elsewhere in the cache server.","F. Indexing","It can be useful for a cache data manager to support efficient creation and maintenance of indexes for performing lookups or searching on secondary values, such as tags. In one embodiment, an index data structure can be used for such lookups or searching. This index data structure can be in addition to the main lookup data structure discussed above, which can include location information corresponding to the cache units and can be managed by the data manager.","The index data structure can be a multi-level hash table structure, which can be used for implementing an index system with composite keys being used as indices for searching a cache, such as a distributed partitioned cache. The indices can be managed with the cache data manager component.","In the indexing hash table structure, one or more internal hash tables, including a root hash table, can point to lower level hash tables, which can in turn point to other even lower level hash tables. In an n-level hash table structure, each leaf node for the ith level hash table can point to the (i\u22121) level hash table or to a cache unit. Operations on the multilevel hash table structure can be done using composite keys, where a composite key is an ordered set of sub-keys, such as an ordered set of hash keys. Each hash table can include a single directory or multiple directories. For an n-level hash table structure, a composite key may include up to n sub-keys. The sub-keys within the composite key can be specified in a consistent order for all operations on the multi-level hash table structure. In other words, if an object is added to the multi-level hash table structure with a composite key {k_, k_, k_, . . . k_n}, then to access the object, the same composite key can be used with the same order of the keys. In addition, an ith-level hash table that points to an object of interest within the multi-level hash table structure could be accessed using the first (n\u2212i) keys in the composite key {k_, k_, k_ . . . k_n} with the same order of the keys.","Referring to , an example of a three-level hash table structure () will be discussed. The table structure () can include a third level () including a root hash table () associated with a tag () (e.g. a tag for \u201cBooks\u201d), a second level () including one or more sub-tables including a table () associated with a tag () (e.g., a tag for \u201cFiction\u201d), and a first level () including one or more sub-tables including a table () associated with a tag () (e.g., a tag for \u201cRomance Novels\u201d).","An object (), such as a cache object associated with a particular book, pointed to by a leaf node of the hash table () in the first level () can be specified with a composite key () having three ordered hash keys (, , and ). A first hash key () in the composite key () can specify a pointer in a leaf node of the root hash table (), where the pointer points to the hash table () in the second level (). A second hash key () in the composite key () can specify a pointer in a leaf node in the second-level hash table (), where that pointer points to the leaf hash table () in the first level (). A third hash key () in the composite key () can specify a pointer in a leaf node in the first-level hash table (), which can point to the specified object (), such as a cache unit. Accordingly, the hash table structure () in  can be considered a tree data structure, with the tables in the hash table structure () being nodes in the tree structure.","A tag index can be formed using the multiple level hash table structure (), where a tag (, , , etc.) can be associated with each hash table. Objects pointed to by a hash table or its sub-tables can be considered to correspond to a tag associated with the hash table.","Moreover, an index enumerator can maintain a list of one or more intermediate level hash table enumerator states and a leaf hash table enumerator state (current state). When a client asks for a batch with an index enumerator state, the enumerator can traverse over the list of state to locate a leaf hash table. Once the leaf hash table is located, a batch can be requested for that leaf hash table with the current enumeration state, such as by using the stateful or stateless enumeration techniques discussed above.","Accordingly, the multi-level hash table structure can be used to search for cache units associated with one or more tags. For example, if a root hash table was tagged for books and a sub-table was tagged for fiction, a search for fiction books could be performed by enumerating and returning all the book objects pointed to (either directly or indirectly such as through one or more sub-tables) by that sub-table.","Referring now to , an indexing technique will be discussed. The technique can be performed in a computing environment that includes a cache, such as a distributed partitioned cache, and that includes a main cache lookup data structure that includes location information corresponding to the cache units in the cache. The environment can also include a cache index data structure, such as the one illustrated in , with a higher level table and a lower level table, the higher level table having a leaf node pointing to the lower level table, and the lower level table having a leaf node pointing to one of the cache units. In addition, the lower level table can be associated with a tag. Alternatively, the technique can be performed in some other environment.","The technique can include conducting a search () for cache units associated with a tag, which can be associated with a cache table in a cache index data structure. The search () can be conducted using the cache index data structure. For example, a search request associated with the tag can be received (). In response to the request, a table in the data structure, such as the lower-level table discussed above, can be enumerated (). The enumeration can include enumerating () the table associated with the tag (such as by enumerating cache units or objects that nodes in the table point to) and enumerating other tables in the data structure that are pointed to by the table associated with the tag. Conducting the search can include using a key to access one or more cache units pointed to by one or more tables in the cache index data structure. The key can be a composite key that includes an ordered set of sub-keys, with each sub-key including location information (e.g., in the form of a hash key) for a table in the cache index data structure.","In addition, results from the search, such as a list of cache units from the enumeration or the cache units themselves, can be returned ().","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. For example, the acts and features may be beneficially used with a cache that is not a distributed cache. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 26"}]},"DETDESC":[{},{}]}
