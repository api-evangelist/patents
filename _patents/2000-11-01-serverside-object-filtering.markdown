---
title: Server-side object filtering
abstract: A computer-implemented method and apparatus for retrieving over a network a subset of object data from a persistence layer. The persistence layer is structured at least partially upon an object model definition. A server computer receives over the network a request from a client computer for object persisted data stored in the persistence layer. The server computer parses the request to obtain search criteria and object association data, wherein the object association data identifies at least one association between a pair of objects. Filtering criteria is created based upon the parsed search criteria and object association data. The object model definition determines how the search criteria and the object association data form the filtering criteria. The object data from the persistence layer is filtered by the filtering criteria in order to generate the object data subset. The object data subset may also be encoded as a package of objects formatted as an Extensible Markup Language (XML) document. The server computer transmits the encoded object data subset to the client computer over the network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06917937&OS=06917937&RS=06917937
owner: SAS Institute Inc.
number: 06917937
owner_city: Cary
owner_country: US
publication_date: 20001101
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Object Model Definition","Object Filtering Example"],"p":["1. Technical Field","The present invention is generally directed to the computer database technical field, and more specifically to the field of distributed client\/server database applications.","2. Description of the Related Art","Object Oriented programming has become the standard paradigm by which software is developed. As part of this paradigm, an object's state is often persisted. As software systems grow, the number of objects being persisted grows accordingly. In a complex software system, the object model contains many associations between the objects. These associations are also persisted. For example, an object model may contain over 90 classes and 180 associations that are stored in a persistence layer (which is usually a database).","In a distributed client\/server application, the client needs to query the object model, which is located on the server, to obtain the persisted states of the objects. Under such current approaches as the Distributed Component Object Model (DCOM) and Common Object Request Broker Architecture (CORBA) model, the client application requests and receives a single object or a collection of like objects. To navigate a specific path through the object model, the client application must retrieve each set of objects along the path to get to the next set of objects in the path.","For example in a company information database application, the client application may want to find all company divisions that have employees who make more than $17,000. These approaches obtain that information by retrieving each of the division objects (10 objects transferred to the client application), loop through each one and get its departments (100 objects transferred to the client application), and loop through each one getting its list of employees (1000 objects transferred to the client application). From these 1000 objects transferred, only one division may actually have been needed by the client application. This is an inefficient process that requires the transmission of significant amounts of potentially irrelevant information across the network.","The present invention solves the aforementioned disadvantage as well as other disadvantages. In accordance with the teachings of the present invention, a computer-implemented method and apparatus is provided for retrieving over a network a subset of object data from a persistence layer. The persistence layer is structured at least partially upon an object model definition. A server computer receives over the network a request from a client computer for object persisted data stored in the persistence layer.","The server computer parses the request to obtain search criteria and object association data, wherein the object association data identifies at least one association between a pair of objects. Filtering criteria are created based upon the parsed search criteria and object association data. The object model definition determines how the search criteria and the object association data form the filtering criteria. Object data from the persistence layer is filtered by the filtering criteria in order to generate an object data subset. The server computer transmits the object data subset to the client computer over the network.","In one embodiment of the present invention, the present invention provides to the client application the object data subset as a package of objects formatted as an Extensible Markup Language (XML) document. This allows the object package to be searched at the server-side using XML standard searching mechanisms. In this manner, the present invention provides a way to search a large collection of data objects and return only the salient results across a distributed network environment in real time.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["20","22","23","24","22","26","28","22"]},"The client application's request  may be formatted as an XPATH specification. The present invention uses a mapping module  to translate the incoming request  to a syntax that is consistent with the persistence layer . Common persistence mechanisms are object-oriented database management systems  and relational database management systems . Thus if the present invention is using a relational database management system , then, the request  needs to be translated to a format understandable by the relational database management system , such as into a structured query language (SQL) format.","The mapping module  translates the request in order to query the persistence layer . Query results from the persistence layer  are sent to the mapping module  so that the query results can be filtered and translated into an XML document. The mapping module  examines the client's request  to determine whether it contains any XPATH based search criteria that may be used to filter the query results. Due to the filtering, the mapping module  returns only the results to the client application  that were actually requested. The mapping module  then encodes with XML tags the filtered results using an object model definition  and predefined encoding rules . The encoded filtered results  are sent back to the client application .","The mapping module  uses the object model definition  and encoding rules  to perform the filtering and translation of the query results. The object model definition  describes the structure of the object model by detailing the object classes, attributes, and associations  of the object model. The encoding rules  specify how the classes, attributes, and associations of the filtered query results are to be translated into an XML format in accordance with the object model definition .","After filtering and translation, an API  returns the encoded filtered results as XML fragments to the client application . These XML fragments can either be used by the client application  either natively as XML, using XML parser , or can be used to populate the client-side object model.","In addition to the ability to subset the objects returned to the client, the information about each object can also be subset, to further decrease the amount of undesired data being sent across the network. This is accomplished by providing as input to the client interface, a template that defines which attributes are returned for objects of a given class.","Client computer  and server computer  exchange information over network . Network  may be any type of network, such as a local area network, an intranet, a wide area network, or a global network (e.g., Internet). The server computer  returning to the client computer  only the requested information significantly reduces the transmission of great amounts of potentially irrelevant information across the network .","With the overall system of the present invention discussed, the following components of the present invention are further described below: object model definition ; mapping module ; API ; and persistence layer .","The object model definition  describes the structure of the object model by detailing the object classes, attributes, and associations  of the object model (collectively termed \u201cmetadata\u201d). As shown in , a common way of defining an object model is to use an object modeling tool which utilizes the Unified Modeling Language (UML) as the diagramming syntax. For example, an exemplary object model may have four classes:\n\n","Between these four classes, the following associations are defined: 1) A Company contains Divisions as shown at reference numeral ; 2) a Division is made up of Departments as shown at reference numeral ; 3) a Department is made up of Employees as shown at reference numeral ; 4) a Division has an Employee who is the Division Head as shown at reference numeral ; 5) An Employee has another Employee who is their boss as shown at reference numeral ; and 6) a Company can be a Supplier to one or more other Companies as shown at reference numeral .","From this object model definition, a variety of implementations can be created. Most object modeling tools provide the facilities to generate Java classes, COM classes, etc. This class generation is done by creating a physical class per UML class (e.g., Company class ), providing attributes and \u201cget and set\u201d methods for each attribute (e.g., Attribute Name), methods getName and setname. The association traversal (e.g., Company to Division association ), is done by implementing a method that returns a collection of associated objects. For example, the Company class  would have a getDivisionList method that would return a collection (or the appropriate, language specific construct) of Division instances.","In this example, a naming convention has been applied to the names of the associations. Any association role name that ends in \u201cList\u201d indicates that there can be any number of objects that contribute to this association.","Mapping Module","With reference back to , the mapping module  maps UML to XML definition to encode the results to be sent to the client application . The mapping can be done in a variety of ways. Before explaining the mapping, several XML concepts warrant definition. An XML element is an entry in the XML that has the syntax of:\n\n","The value of an XML element can contain either text or other imbedded XML elements. All XML elements are ended by a closing <\/suffixed with the tag name. For example, <\/Company>is the closure of the Company element:\n\n","XML Syntax also allows for a shorthand specification of XML elements that have no value. In this syntax, the closing tag is collapsed into the initial tag definition, as shown in the following example:\n\n","To represent the object model specified in UML as XML, the following XML encoding rules  are applied:\n\n","For example,  shows a mapping of the Company and Division classes, their attributes, and the association ParentCompany\/DivisionList as generated in accordance with the teachings of the present invention. The Company class has XML element tag  with its is attributes Name , ID , Headquarters , and Annual Revenue . The Company class has a company closing tag  to indicate when information related to the Company class has completed. The UML association ParentCompany\/DivisionList is represented as an imbedded XML element between company tags  and .","The reverse traversal of this association (i.e., DivisionList\/ParentCompany) is also mapped into XML as shown generally at . The Division class has XML element tag  with its attributes Name , ID , and DivisionCode . The Division class has a division closing tag  to indicate when information related to the Division class has completed. The UML association DivisionList\/ParentCompany is represented as an imbedded XML element between division tags  and .","Note that the present invention maintains consistency between the object model definition of FIG.  and the XML document of  by having the object model definition guide how the tags are created in the XML document. Note also that this mapping technique allows for traversal of the object model in any direction, and allows the client application programmer to decide which is the shortest route to the desired information.",{"@attributes":{"id":"p-0038","num":"0049"},"figref":"FIGS. 4A-4E","b":["2","110","112","114","116","118","120","110","120","180","182","180","182","190","192","194","196","198","200"]},"Application Programming Interface","For the present invention, there can be any number of programming interfaces. The preferable ones are to use the Object Modeling tool generated classes in the appropriate programming language, and to access the entire object model contents as one large XML document.","This invention allows another API to be developed, which is to return XML fragments to the client application as shown in  at . These XML fragments can either be used natively as XML, using any number of XML parsers, or can be used to populate the client side object model.","Persistence Layer","With reference back to , the persistence layer  is responsible for persisting the state of objects. As mentioned above, there can also be a number of persistence mechanisms. The two most common mechanisms are an object-oriented database  and a relational database .","An object oriented database  takes a set of objects and stores them into a container. A container is normally a proprietary data structure implemented on top of the file system. Normally, the modeler defines how objects are grouped together into a container. In this example, we might choose to store a container per company and include in it all of the divisions, departments and employees of that company. We could also choose to make the containers more granular. This design decision should be based on the expected usage patterns of the client applications. Normally, an entire container is loaded into memory at once. Thus, intra-container traversals are very fast but more information may be loaded into memory than is needed. While this invention is not dependent on the container definitions, the performance of the invention may be dependent on it.","A relational database  takes a set of objects and maps them into normal, relational database structures, i.e., tables. Encoding rules  for a relational database for the mapping of an object model to a relational structure may be the following:\n\n",{"@attributes":{"id":"p-0044","num":"0059"},"figref":"FIG. 5","b":["220","220","222","224","226","224"]},"In the situation of the SupplierList\/ConsumerList association which has a max cardinality of n, a Supplier_Consumer association table  was created. Supplier_Consumer association table  includes a SupplierD and ConsumerID row in order to express this association in the relational model.","Note that in this database model, when an association is represented as a foreign key relationship, there is no persistence of the bidirectional nature of this association. This information may be persisted in additional \u201cmetadata\u201d about this database model. This metadata is used for the implementation of this present invention on a relational database persistence layer.","Attribute Filtering","In addition to the ability to subset the objects returned to the client, the information about each object can also be subset, to further decrease the amount of undesired data being sent across the network. This may be accomplished by providing as input to the client application's programming interface, a template that defines which attributes are returned for objects of a given class.","For example, if the application only needs the division's division code, a template can be included on the request which limits the information returned to just this. The template <Division DivisionCode=\u2033\u2033> will limit the returned information about any divisions to just be the DivisionCode.","As another example, if the application only needs the Company's headquarters location, a template can be included that limits the returned information. The template <Company Headquarters=\u2033\u2033\/>will limit the returned information about any companies to just be the Headquarters information.","If an individual company has 10 Divisions, each with 10 Departments, each with 10 employees. This means that there are 1000 employees in this company. As an example of the present invention, if the client application wants to find all the divisions that have employees who make more than $17,000, the client computer may issue a request to the server with a selection criteria, encoded using the XPATH specification, to limit the result set. The XPATH specification for this example is:\n\n","For ease of terminology, we can think of the specification as a series of nodes delimited by a slash. Each node can either by an object criteria node (e.g., Division or Employee[@Salary>17,000) or an association role specification (e.g., DepartmentList). The object criteria node is made up of a specification of a class that an object must meet and a set of attribute criteria, enclosed in brackets [ ], that the object must meet. The class specification can be a specific class name or an asterisk (*), which implies that the objects should not be limited based on their class. For example, if the object model had subclasses of Department called Group and Team, the following example XPATH specification would be used to ignore this fact in asking for this result set:\n\n","An object criteria node can also specify an attribute criteria (e.g., [@Salary>17,000]). If no attribute criteria is passed, then all objects that match the class criteria are included. All references to a property that is an XML attribute, e.g., Salary, are prefixed by the @ sign.","When this request is received by the mapping layer, it traverses the nodes. The nodes must alternate between a class specification (or object criteria specification) and an association role specification.","The traversal can be done in several ways: a left to right traversal; or a right to left traversal. Note that since this traversal is opposite how the query has been specified, there may be additional metadata which contains the partner role for each association role node. For example, for the EmployeeList association role that was passed, there may be information that indicates that the role of the other end of this association is WorksInDepartment.","An intelligent traversal is where the direction is based on the actual ordinality of the end object criteria. For example, if there are only a few divisions, then it might be more expedient to traverse left to right. However, if the employees who match the object criteria Employee[@Salary>17,000] is smaller than the number of divisions, then it might be more expedient to go right to left.","The bi-directional nature of the associations allow for an intelligent traversal to be accomplished. This makes the object filtering of the present invention as flexible and powerful as possible. For the sake of brevity, a right to left traversal mechanism is described in the next section.","Present Invention's Handling of the Example in Mapping to an Object Persistence Layer","Object persistence layers provide a mechanism for retrieving a set of objects based on an attribute search criteria, (e.g., Salary>17,000) or by class. The present invention assumes that the current node upon entry is an object criteria node. At the exit of processing this type of node, a working set of objects are passed to the next node for processing.","When an association role specification node is processed, the association traversal method is sent to each object in the input working object set. Each object that is retrieved via traversing the association is added to the working set which will be the output of this node.","More specifically, the flow chart for processing object criteria nodes is shown in FIG. . The start of the object criteria process flowchart is at block . At block , the search request from the client application is obtained by the server computer. The search request is parsed at block  into nodes. The present invention then iterates through the flow chart for each parsed node.","Decision block  examines whether a parsed node is the first node to be processed. If it is, then block  queries the persistence layer  for objects that match the current object criteria. Block  places results from the query in an output working object set.","However, if decision block  determines that this is not the first node to be processed, then processing continues at block . Block  applies to the working object set the object criteria of the criteria node that is currently being processed. The results are placed in the output working object set at block . Processing continues at decision block .","Decision block  examines whether the node that is currently being processed is the last node to be processed. If it is, then processing continues at block  which is described below in greater detail.","If decision block  determines that the node is not the last one, then the decision block  examines whether any objects satisfied the criteria in the object criteria node currently being processed. If no objects satisfied the criteria, then an empty set is returned to the client application, by first encoding the empty output working set in an XML format at block . The empty output working set is sent to the client at block  before processing terminates at end block .","If decision block  determines that at least one object satisfied the criteria in the object criteria node currently being processed, block  calls the Association Role Function for processing the output object set. Processing continues at the start block  on FIG. .",{"@attributes":{"id":"p-0065","num":"0082"},"figref":"FIG. 7","b":["302","32","304","306","308","306","310","312","276","6"]},"With reference back to , decision block  examines whether there were any results from the Association Role Function or only an empty set. If decision block  determines that no results were returned, then an empty set is returned to the client application, by first encoding the empty output working set in an XML format at block . The empty output working set is sent to the client at block  before processing terminates at end block .","However, if non-empty results were returned, then processing for the next node in the parsed search request continues at decision block . Ultimately if there are objects that satisfy the criteria specified in the parsed search request and there are results in response to the Association Role Function, then block  encodes the resultant objects. The resultant objects are encoded in an XML format using the object model definition  and encoding rules in accordance with the teachings of the present invention. Block  sends the encoded filtered results to the client application before processing terminates at end block .","As further illustration of the operation of the present invention, the following describes the operation of the above example in view of the flow charts of FIGS.  and :\n\n","The mapping to a relational database persistence layer is very similar in concept to that of the Object persistence layer mapping described above. There are two differences: 1) the interface to the relational database is normally structured query language (SQL) instead of using object method calls; and 2) most databases have extremely good query optimizers that can optimize the traversal path of the table structure. To use this most effectively, we should pass structure as large a query as possible. This allows the optimizer to figure out the best path.","For this sample implementation, it will be assumed that the underlying relational database can optimize the query when inline views are used in the resulting SQL. Thus, the present invention formulates for the above example the following SQL:\n\n","To further exemplify the present invention, a second example is provided. In this second example, the client application wants to find all companies that we buy goods from that also sell goods to companies that have an annual revenue less than 200,000. While this example only has three companies listed, it is easy to see that in a real world scenario, a company might have hundreds of suppliers and each of those suppliers might have thousands of consumers. The second example's XPATH specification is:","SupplierList\/Company\/ConsumerList\/Company[@AnnualRevenue<\u201c200,000\u201d] The resulting SQL is as follows:\n\n","These examples show that the preferred embodiment of the present invention can be applied to a variety of situations. However, the preferred embodiment described with reference to the drawing figures is presented only to demonstrate such examples of the present invention. Additional and\/or alternative embodiments of the present invention should be apparent to one of ordinary skill in the art upon reading this disclosure. For example, the present invention can reside on multiple server computers, such that each server computer can perform a different operation of the present invention. Thus, one server computer may receive the request from the client computer and pass the request onto a second server computer which may translate the request into a query. The translated query is sent to another server computer that contains the persistence mechanism. The ensuing results are filtered and encoded in accordance with the teachings of the present invention and sent to the client computer.","In still another example of the wide range of variations of the present invention, the present invention includes receiving a request from one client computer and sending the filtered and encoded results to one or more other client computers. The request itself may include who the intended recipient(s) of the results should be."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention satisfies the general needs noted above and provides many advantages, as will become apparent from the following description when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 4A-4D"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
