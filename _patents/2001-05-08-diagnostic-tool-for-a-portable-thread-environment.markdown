---
title: Diagnostic tool for a portable thread environment
abstract: A diagnostic tool for a portable thread environment is disclosed. In one embodiment, a system comprises a first portable thread environment (PTE), comprising a diagnostic tool; a second PTE configured to receive and send threads; a third PTE configured to receive and send the threads; and a PTE router configured to receive the threads and route said threads, wherein the router copies the threads and routes the copies to the diagnostic tool.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06938246&OS=06938246&RS=06938246
owner: Microtune (San Diego), Inc.
number: 06938246
owner_city: San Diego
owner_country: US
publication_date: 20010508
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","EMBODIMENTS OF THE INVENTION","PTE Overview","Task Types and Scheduling","Message Routing","Wireless Implementations","PTE Diagnostic Tool"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/203,245, filed May 8, 2000. This application is a continuation-in-part of U.S. patent application Ser. No. 09\/792,550 filed on Feb. 23, 2001.","1. Field of the Invention","This invention relates generally to the field for software design; and, more particularly, to a diagnostic tool for an application environment supporting portable, embedded, concurrent, and\/or real-time applications.","2. Description of the Related Art","The term \u201capplication\u201d is commonly used to refer to the objective or problem for which the software, or \u201capplication program\u201d, is a solution. The form of the solution\u2014the application program\u2014is dependent, in part, on the configuration of the hardware on which the software is executed and, in part, on the other programs that may be executing in concert with the application program.","An application program is typically translated from an instruction set derived from one of several well-known programming languages to an instruction set closely reflecting the capabilities of processor executing the application program. This translation is accomplished by programs generally know as \u201ccompilers,\u201d \u201cassemblers\u201d or \u201cinterpreters.\u201d These programs translate the application program's original instructions to a set of instruction typically know as \u201cmachine code\u201d for which there is a one-to-one correspondence between machine code instructions and the unitary operations the machine (or processor) is able to perform. Typically, machine code instructions are dependent on the machine's central processing unit (or CPU). The operation of these and similar programs are well known to those of ordinary skill in the art.","Application programs are frequently executed simultaneously with other application programs, sharing (and sometimes competing for) the resources of the host hardware.","Application programs must also frequently share the resources of the host hardware with \u201cinterrupts service routines\u201d (ISR). These ISRs are typically short program segments that interrupt the normal program instruction sequence and execute, substantially immediately, in response to a hardware signal (an \u201cinterrupt\u201d) to the CPU.","Application programs may be invoked by, or may invoke, the services of other sets of programs running on the host that are collectively know as an \u201coperating system.\u201d Operating system programs are typically responsible for controlling the allocation of the host's resources, including access to the host machine's data stores, central processing unit, and input\/output devices. One aspect of controlling the allocation of a host's resources typically involves insuring that no two applications, ISRs, or portions of the same application try to control a resource at the same time. A number of techniques for preventing this are well know in the art, including semaphores, counting semaphores, mutexes, signals, and critical sections. A critical section is a portion of a program that, once started, is uninterruptible and executes continuously without allowing other programs to run until the critical section has ended.","Application software is executed within some \u201chost environment,\u201d defined collectively by the host machine's hardware (including, possibly, application-specific support hardware such as an application-specific integrated circuit or \u201cASIC\u201d) and operating system.","Commonly, commercial application software vendors are required to adapt, or \u201cport,\u201d their application programs to run in a multiple heterogeneous host environments. These environments may differ in their CPU's, choice of operating systems, and applicaton-specific hardware. In order to port an application program from one host environment to another, it is typically necessary to account for any or all of these differences.","The tradition approach to porting applications is to write the application program in a \u201chigh-level language\u201d that hopefully can be recompiled to generate machine code that can run within any of the prospective processors. While this \u201ctraditional approach\u201d solves the portability problem at the machine code level, it is only partly addresses the application portability problem. It is also necessary to account for differences in the host environment's operating system and application-specific support hardware. For example, each operating system defines a unique application programming interface (\u201cAPI\u201d) which application programs use to access the operating systems services. Because these APIs are unique, portions of the application program having access to the operating system's API must be rewritten when the application program is ported to a new operating system. In addition, accounting differences in application-specific support hardware (circuits that are able to perform a portions of the application's function that otherwise have to be performed in software) also may require that some portion of the application software be rewritten.","A problem with the traditional porting method is that this method requires that at least some portion of the application program be rewritten. This is a potentially costly and error-prone process. Because there is a likelihood of introducing unintentional errors whenever the application program is altered, this method mandates that the application developer bare the additional expense of re-testing the application after the indicated changes are complete.","More significantly, and despite the availability of a number of commercially operating systems, most embedded applications are deployed today are in host environments that supply no operating system services. Thus, for application portability, a means must be provided to ensure application software can operate correctly isolated from the vagaries of its host environment.","Software developers traditionally desire tools for observing and controlling intermediate operations of their programs as an aid in demonstrating the correctness of their programs and for debugging.","A diagnostic tool for a portable thread environment is disclosed. In one embodiment, a system comprises a first portable thread environment (PTE), comprising a diagnostic tool; a second PTE configured to receive and send threads; a third PTE configured to receive and send the threads; and a PTE router configured to receive the threads and route said threads, wherein the router copies the threads and routes the copies to the diagnostic tool.","In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the invention.","Embodiments of the invention described below seek to avoid the problems associated with porting application software by creating a portable environment in which an application can be moved from one host environment to another unchanged.","As illustrated in , in one embodiment, an application  is constructed as a series of short, sequentially executed program fragments, referred to herein as \u201cthreads\u201d -. Each thread - is assigned to a logical grouping called a \u201ctask\u201d , . For example, in , threads - are grouped within task  and threads - are grouped within task . In general, tasks may be used to partition an application into one or more sub-units, each accomplishing a specific function. An application may be subdivided into any number of tasks and each task may contain any number of threads.","As illustrated in , one embodiment of the invention includes a Portable Thread Environment (\u201cPTE\u201d) which is comprised generally of a scheduler , one or more scheduling queues , and a host adaptation layer .","The scheduling queue  accepts messages from executing threads (e.g., internal message source ) and\/or from sources external to the PTE (e.g., external message source ). Each PTE-supported message is tagged with a code (e.g., a value or name) uniquely identifying a thread to which that message is to be delivered.","In one embodiment, threads are executed by the PTE scheduler  in a sequence determined by scheduling variables such as, for example, the message order in the PTE scheduling queue , and\/or the priority of messages stored in the queue . The scheduling queue  in one embodiment is a list formed as messages are received from internal sources  such as running threads and from external sources  with which the application interacts. One example of an external message source is application-specific support hardware found the host environment.","Threads which are members of the same task may share information through common memory stores or by passing messages between themselves. By contrast, in one embodiment, threads which are members of different tasks may exchanges data only by sending messages.","The task grouping is designed (in part) to support the use of application-specific support hardware in an application's design. When an application is designed, the functions which are to be supported by application-specific hardware are modeled in the form of one or more tasks. When the application-specific circuits are subsequently incorporated into the design, the tasks are removed from the application software  (i.e., they are provided by the application-specific circuit).","The host adaptation layer  in one embodiment ensures that messaging between threads in different tasks is identical to the messaging between threads and an application's support hardware. In other words, the application programming interface (\u201cAPI\u201d) used by the application is consistent, regardless of whether application-specific circuits are involved. The inclusion of an application-specific circuit, therefore, does not require modifications to the underlying application code (in one embodiment only an small amount of code in the host adaptation layer  is modified). As such, in this embodiment the application is effectively shielded from the host environment.","As illustrated in , in one embodiment, all interactions between the application program  and the host's operating system  occur through the PTE application interface  and the host adaptation layer . When the host environment includes operating system services, the PTE is scheduled and executed as an operating system task with the PTE's application program(s)  contained therein. In other words, the application program(s)  and the operation system  are isolated from one another by the host adaptation layer  and the PTE interface .","The majority of embedded applications, however, are implemented without the aid of an embedded operating system. For host environments without operating system support, the PTE and application can run in a stand-alone configuration as depicted in FIG. . When running stand-alone, the host adaptation layer  supplies any necessary hardware support (i.e., interfaces) and communicates to the internal application threads through the PTE messaging system.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 5","FIG. 5"],"b":["520","530","522","532","540","530","540"]},"As illustrated in , the application framework of one embodiment allows applications ,  to be distributed across multiple PTEs  and , respectively. This embodiment may be particularly suited for multi-processor configurations (e.g., where each PTE ,  is configured for a different processor). In one embodiment, a common API is used for both inter-PTE and intra-PTE messaging. The common API allows an application to be configured to run in either a multiprocessor environment or on a single processor by merely altering a single routing configuration file (i.e., no changes to the application are required).","In one embodiment, illustrated in , tasks are defined as either \u201ccooperative\u201d tasks  or \u201cpreemptive\u201d tasks . Cooperative tasks are composed exclusively of \u201ccooperative\u201d threads ,  while preemptive tasks are composed exclusively of \u201cpreemptive\u201d threads , . Cooperative tasks  and preemptive tasks  differ in their ability to provide shared memory pools and other resources  to their constituent threads. For example, threads  and  in a common cooperative task  are allowed share a common memory . By contrast, threads  and  in a preemptive task  are not permitted to share resources with other threads, including threads in their own task . Preemptive threads ,  communicate externally (e.g., with an external message source and\/or destination ) only through message passing (e.g., via an API function call ).","In one embodiment, all threads, both preemptive and cooperative, are individually configured to run at a specified priority level. It is not required that all threads in a task have the same priority (i.e., tasks may be composed of threads of differing priorities). In one embodiment, when a thread is requested, a message for the thread is placed in a priority-sorted FIFO queue (e.g., such as the scheduling queue  illustrated in FIG. ). Normally, if the requested thread is a higher priority thread than the currently-running thread, the running thread is suspended (or \u201cpreempted\u201d) while the higher priority thread is executed. This operation is illustrated and described in through ","To permit resource sharing within cooperative tasks, an additional condition is placed on cooperative threads: if a cooperative thread is requested while another thread in the same task is running or preempted, the requested thread\u2014regardless of its priority \u2014is \u201cblocked.\u201d That is, it is not allowed to run until the running or preempted thread in its task has completed. One example of this blocking function is illustrated and described in ","In contrast to a cooperative thread, in one embodiment, the execution of a preemptive thread is not constrained by conditions other that its priority relative to other requested threads. Thus, if it is the highest priority requested thread, it is executed immediately.","As illustrated in , in one embodiment, a PTE thread can exist in a variety of different states. In it's idle state  a thread is inactive, waiting to be requested. A thread enters the requested state  when it receives a message from a running thread or an interrupt service routine (\u201cISR\u201d). In one embodiment, the thread remains in the requested state until the requester terminates. At that point, the requested thread is either scheduled  or enters a \u201cblocked\u201d state  (depending on the circumstances as described herein).","As described above, only cooperative threads can enter a blocked state ; preemptive threads do not block. A cooperative thread is blocked if, after having been requested, a thread from its task is preempted. The thread remains blocked until all preempted threads from its task have resumed and terminated normally. In one embodiment of the PTE, cooperative thread blocking is a built-in mutual exclusion mechanism required for memory sharing between cooperative threads running at different priority levels.","A thread in a scheduled state  is queued, waiting for execution. Threads enter the scheduled state  after having been requested, after any blocking conditions have been cleared. Once scheduled, the thread cannot again be blocked. The thread will remain in the scheduling queue  until it is executed.","When running , the thread is performing the function for which it was designed. In one embodiment, only one thread may be running at a time. The thread will execute to completion unless it is preempted. The thread may enter into the preempted state  due to another higher priority thread(s) being scheduled (e.g., at the termination of an ISR).","Referring now to , in one embodiment the scheduler  manages the states of an application's threads and ensures that threads are executed in the proper order by passing message requests through a series of message queues.","The PTE input queue (\u201cQIN\u201d)  receives messages read from the external environment (i.e. other PTEs) and ISRs. The scheduler may route messages from QIN  to the temporary task queue (\u201cTTQ\u201d)  and\/or the priority scheduling queue (\u201cPSQ\u201d) .","The PSQ  includes a list of threads ready for immediate execution. The list is sorted based on scheduling variables such as, for example, thread priority and temporal order (i.e., the order in which the threads were requested). As a general rule, in one embodiment, higher priority threads are executed before lower priority threads. For threads with the same priority level, thread requests requested earlier are run before threads requested later.","Requests generated by a thread are stored in a temporary thread output queue (\u201cTOQ\u201d) until the thread terminates. This ensures that a thread's output does not cause itself to be inadvertently preempted. In one embodiment, a separate TOQ exists for each priority level. When a thread terminates its TOQ messages are distributed to the TTQ, the PSQ or the PTE output queue (\u201cQOUT\u201d).","The TTQ is a holding station for cooperative threads that have been requested but are not ready for scheduling because they are blocked by another active thread in their task group (as described above). This feature is necessary to ensure mutual exclusion between the members of a cooperative task with respect to the task's shared memory. In one embodiment, when the task's active thread terminates, the TTQ is emptied.","The PTE Output Queue (\u201cQOUT\u201d) is a temporary holder for all messages leaving the PTE. For example, the QOUT receives messages from the TOQ when a thread completes its execution.","An exemplary method for scheduler operation will now be described with respect to the flowchart in FIG. . The scheduler is executed after the normal termination of a thread and at the termination of any ISR and on PTE startup.","When started, the scheduler initially sets the scheduler's priority variable (PRI) to the maximum priority level supported by the PTE. The scheduler () reads any messages waiting for the PTE from external message sources (i.e. other possible PTEs) and copies () these messages to the tail end of the PTE's input queue (QIN) in the order received. All messages () in the PTE input queue (QIN) are then moved by the message routing function () to either the Priority Scheduling Queue (PSQ) or to the Temporary Thread Queue (TTQ).","Next, the scheduler evaluates the entry in the Preempted Task Table (PTT) corresponding to the current value of PRI (the scheduler's priority variable). If the PTT entry indicates that the priority level in \u201cin use\u201d, the scheduler exits immediately () and resumes a preempted thread at the point where interrupted by an ISR.","If, instead, the PTT indicates that no task in running at the priority level corresponding to PRI's value, the scheduler examines the PSQ for any messages to threads with priority assignments equal to the scheduler's priority variable's value (). If none are found, PRI is decremented by one () and if greater than zero (), the PTT () is again examined for evidence of a preempted thread at a now lower thread priority level. The loop between  to  continues, thusly, until PRI is decremented to a negative value, in which case the scheduler exits (); PRI is decremented to the priority level of a previously preempted thread (), in which case the preempted thread is resumed (); or a message is found in the PSQ to a thread with a priority level equal to the value of PRI.","If examination of the PSQ () finds a message waiting for a thread with a priority level equal to that of PRI, scheduler alters the PTT's values to indicate that the priority level of corresponding to PRI is \u201cin use\u201d. The scheduler then extracts the message from the PSQ, starts the thread to which it is addressed () and delivers the message to that thread.","When the thread ends, the scheduler routes each message () created by the thread (found in the Thread Output Queue (TOQ) corresponding to the thread's priority level) to an appropriate message queues (PSQ, TTQ, or QOUT) as determined by the message router (). The TTQ is then scanned () and messages therein are redistributed as determined by the message router (). Finally, each message () in the output queue (QOUT) is distributed to an external PTE address by the PTE write function () and the scheduler exits ().","In one embodiment, a routing function is implemented to route thread requests throughout the PTE (e.g., at each of the decision blocks of FIG. ). Thus, the scheduler, in a critical section, may invoke the message routing function to move messages between the PTE's various message queues. The routing function in one embodiment uses the message's thread name as a destination address for the message (in this embodiment, each message contains a header with a thread name identifying its destination).","The ultimate goal of the routing mechanism is to transfer a message from its source to a PSQ, and then to dispatch the message from the PSQ to the message's destination thread (e.g., specified by its thread name). To achieve this goal the router may pass the message through a series of intermediate queues (as described above).","One embodiment of a routing method is illustrated in FIG. . At  the router de-queues the message from its source. Then, at , the router determines whether the message is directed to an internal PTE thread or an external thread (i.e., located in a different PTE). If the destination is an external thread, then the router transfers the message to an output queue (at ) and the routing process is complete with respect to that message (i.e., the other PTE takes over the routing function after receiving the message from the output queue).","If, however, the message is for an internal thread, the router then determines whether the task is a preemptive task (at ). If the message is for a preemptive task, it transmits the message directly to the PSQ (at ) at a specified priority level. If the message is for a cooperative task, then at  the router determines whether any other thread from the thread's task is preempted. If no other thread from the thread's task is preempted, the router transmits the message to the PSQ at a specified priority level (e.g., specified by the thread name as described below). If another thread from the thread's task is preempted, however, the router queues the message in the TTQ at the thread's specified priority level.","In one embodiment, the router uses three tables to look up information about its tasks and\/or threads. As illustrated in , and , these include a thread attribute table (\u201cTAT\u201d), a task status table (\u201cTST\u201d), and\/or a preempted thread table (\u201cPTT\u201d), respectively.","In one embodiment, each thread in the PTE environment is uniquely identified by a thread \u201cname.\u201d Thread names may be used by the router to identify information such as, for example, a message's destination thread. In addition, as illustrated in , the thread name (e.g., \u201cThread[n]\u201d in ) may be used to identify other information such as the thread's PTE, Task ID, Thread ID, Thread Priority, and Task Type.","The task ID identifies the task to which the thread belongs. The task may be internal (i.e., within the local PTE) or external. If internal, messages sent to the task are delivered though internal message queues (as described above). If external, messages are routed to the common output queue (\u201cQOUT\u201d).","The thread ID identifies a specific thread within a task; the thread priority defines the thread's execution priority in relation to other threads (various priority levels may be implemented consistent with the underlying principles of the invention); and the task type identifies the thread's task as either preemptive or cooperative. It should be noted that although only one thread name entry is shown in , the underlying principles of the invention may be implemented using TAT's with a variety of different thread name entries.","As indicated in , in one embodiment, a task status table (\u201cTST\u201d) records the priority of each task's highest priority started thread (in this context, \u201cstarted\u201d can mean running, preempted, or interrupted). If no thread within the task is running, the TST records that the task is idle. In one embodiment, the scheduler uses the TST entries to route messages directed to started cooperative threads to the proper TTQ.","In addition to the TST, the PTE keeps a table, referred to as a preempted thread table (\u201cPTT\u201d), that records the priority levels which are currently in use.","In one embodiment, the PTE described herein is used to support a communications protocol stack. For example, if the system is configured to support the Bluetooth protocol, the protocol stack may be divided as illustrated in , with the RF layer  and portions of the baseband layer  programmed in a Bluetooth IC  (which may be an ASIC) and the remaining layers, including certain portions of the baseband layer , implemented as software executed in the host processor environment . In this embodiment, tasks and threads may reside in both the Bluetooth IC  and the host processing environment . Each layer in the protocol stack is implemented as a separate task. Messages transmitted between tasks in the hardware portion and tasks in the software portion will occur over the host interface .","In an alternate implementation of the same protocol stack, some stack layers, RFCOMM () and LCAP () for example, might be executed in a second host processing environment. A PTE would be implemented in each host environment sharing a common inter-processor messaging mechanism. Within the PTE Application Interface () as shown in , protocol layers (RFCOMM and LCAP in this case) can be moved from one host environment to the other without altering the software that implements the layer functions.","As described above, the PTE is ideal for this type of wireless communication environment because it can easily be ported from one host processing environment to another without significant modification. As previously described, applications run within a PTE are composed of tasks (groups of threads) threads which interact with the PTE through a limited number of fixed API calls. Because the API calls are invariant for all PTE instances, a Task created for one PTE can be run on any other PTE without modification, regardless of the host environment. All differences in host environments are accounted for in the Host Adaptation Layer illustrated in . It is typically be necessary to change only the Host Adaptation Layer when the PTE's host is changed. The PTE's simple common communication system for messaging and synchronization enable the PTE to be implemented with very little software in most operating environments. Being relatively small (and typically a small fraction of the size of the application code it supports), the PTE can be adapted to a new host, and be proven to be operating correctly with relatively little effort. No other changes are necessary. It is important to note that the apparatus and method described herein may be implemented in environments other than a physical integrated circuit (\u201cIC\u201d). For example, the circuitry may be incorporated into a format or machine-readable medium for use within a software tool for designing a semiconductor IC. Examples of such formats and\/or media include computer readable media having a VHSIC Hardware Description Language (\u201cVHDL\u201d) description, a Register Transfer Level (\u201cRTL\u201d) netlist, and\/or a GDSII description with suitable information corresponding to the described apparatus and method.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 15","b":["1510","1500","1540","1510","1500"]},"Most PTE applications are implemented as a collection of executable threads as described above. Threads execute in response to messages sent from other threads or from external sources. The messages are delivered solely by the system  through router . All system  messages contain a field identifying their destination thread.","A control thread exists within system , that when signaled by an external message, causes the message routing entity for specified message types, to spawn an additional diagnostic message containing all or part of the original message. This diagnostic message is delivered as an external diagnostic monitor that may selectively display the message contents.","In one embodiment, tool  shows thread execution order, it shows all messages from a thread, shows all messages to a thread; and shows message content. Tool  generates diagnostic messages that may be used to trigger events, either from external inputs or message traffic. Tool  also represents its own PTE . In one embodiment, it is blue tooth enabled. Tool  may identify a message's source. For example, a message may have been created by device , which is also connected to router ; and that message may be identified by tool  as originating from device . Tool  may also truncate messages exceeding a predetermined size before routing the messages. Tool  generates \u201ctrace\u201d lists, which detail the execution of threads within a PTE. Tool  may add or remove messages based on their source, destination, or content.","Windows device  is also connected to router . Windows device  has its own PTE  and may pass threads back and forth to device . Tool  may observe the thread messaging between device  and windows device .","The present method and tool, has advantages over prior art diagnostic tools that are integrated within software. For example test software, and the production software are inherently different. It may not be possible to run a diagnostic tool on the target hardware due to resource limitations, such as a lack of sufficient code space, a lack of suitable outputs, and an inflexible memory configuration. In addition prior art tools may introduce undesirable timing problems, as well as additional software bugs.","Although, system  is illustrated as only having two devices passing threads between each other, diagnostic tool  may be implemented in a system having numerous PTE thread passing devices.","Throughout the foregoing description, for the purpose of explanation, numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent, however, to one skilled in the art that the invention may be practiced without some of these specific details. For example, while the embodiments described above focused on the Bluetooth protocol, many of the underlying principles of the invention may practiced using various other types of wireless and terrestrial protocols. Accordingly, the scope and spirit of the invention should be judged in terms of the claims which follow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained from the following detailed description in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 8","i":"a-d "},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13","i":"a "},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 13","i":"b "},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 13","i":"c "},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
