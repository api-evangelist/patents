---
title: Method and system for automatically creating tests
abstract: A system and method for generalized scenarios, for automatically generating tests. The tests are generated from some underlying structure, such as one or more scenarios. The scenarios preferably include a plurality of constraints for generating a test program for generating input values to the test generation process. The scenarios provide a more generalized method for generating tests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07665067&OS=07665067&RS=07665067
owner: Cadence Design (Israel) II Ltd.
number: 07665067
owner_city: Rosh Ha'ayin
owner_country: IL
publication_date: 20030915
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This invention relates to computer software, more particularly to computer software for analyzing the functionality of a circuit design and for analyzing the functional correctness of the circuit design.","The field of electronic design automation (EDA) is well established. A number of software tools are used to describe a circuit at various levels of granularity or specificity. Such tools include gate level descriptions, which specify the circuit in very great detail, to high level descriptions written in hardware description languages such as Verilog or VHDL. The process of verifying a design through a simulation model of the device is aided by the availability of Verilog and VHDL. These languages are designed to describe hardware both at higher levels of abstraction and as gates or transistors, thus enabling designers to describe the elements and connections between elements of a circuit. Modern circuits have many millions of transistors, so it is essential to use some sort of design tools just to manage the complexity of the design, particularly for design verification.","Design verification is the process of determining whether an integrated circuit, board, or system-level architecture, exactly implements the requirements defined by the specification of the architecture for that device. Design verification for a device under testing (DUT) may be performed on the actual device, or on a simulation model of the device. For the purposes of explanation only and without intending to be limiting in any way, the following discussion centers upon testing which is performed on simulation models of the device.","As designs for different types of devices and device architectures become more complex, the likelihood of design errors increases. However, design verification also becomes more difficult and time consuming, as the simulation models of the design of the device also become more complex to prepare and to test.","The problem of design verification is compounded by the lack of widely generalizable tools which are useful for the verification and testing of a wide variety of devices and device architectures. Typical background art verification methods have often been restricted to a particular device having a specific design, such that the steps of preparing and implementing such verification methods for the simulation model must be performed for each new device.","As previously described, the process of verifying a design through a simulation model of the device is aided by the availability of hardware description languages such as Verilog and VHDL. The resultant simulated model of the device can receive input stimuli in the form of test vectors, which are a string of binary digits applied to the input of a circuit. The simulated model then produces results, which are checked against the expected results for the particular design of the device. However, these languages are typically not designed for actual verification. Therefore, the verification engineer must write additional programming code in order to interface with the models described by these hardware description languages in order to perform design verification of the device.","Examples of testing environments include static and dynamic testing environments. A static testing environment drives pre-computed test vectors into the simulation model of the DUT and\/or examines the results after operation of the simulation model. In addition, if the static testing environment is used to examine the results which are output from the simulation model, then errors in the test are not detected until after the test is finished. As a result, the internal state of the device at the point of error may not be determinable, requiring the simulation to be operated again in order to determine such internal states. This procedure consumes simulation cycles, and can require the expenditure of considerable time, especially during long tests.","A more useful and efficient type of testing is a dynamic testing environment. For this type of environment, a set of programming instructions is written to generate the test vectors in concurrence with the simulation of the model of the DUT and while potentially being controlled by the state feedback of the simulated device. This procedure enables directed random generation to be performed and to be sensitive to effects uncovered during the test itself on the state of the simulation model of the device. Thus, dynamic test generation clearly has many advantages for design verification.","Within the area of testing environments, both static and dynamic testing environments can be implemented only with fixed-vector or pre-generation input. However, a more powerful and more sophisticated implementation uses test generation to produce the environment, particularly for functional verification in order for the various elements be defined and connected together correctly in order to have the circuit perform as specified. Specman Elite\u2122, software developed by Verisity Ltd. in Israel and available through Verisity Design, Inc. in Mountain View, Calif., is the market leader in providing functional verification. Certain attributes of the software are described in copending, commonly assigned U.S. patent application Ser. No. 09\/327,966, entitled \u201cSystem and Method for Measuring Temporal Coverage Detection\u201d, filed Jun. 8, 1999, and incorporated herein in full by reference. Useful background information is presented in commonly assigned U.S. Pat. No. 6,182,258, filed Feb. 6, 1998 and issued Jan. 30, 2001, entitled \u201cMethod and Apparatus for Test Generation During Circuit Design\u201d, also hereby incorporated by reference.","The test generator disclosed in U.S. Pat. No. 6,182,258 interacts with, and sits as a higher level over, such hardware description languages as Verilog and VHDL. The test generation procedure is written in a hardware-oriented verification specific object-oriented programming language. This language is used to write various test programs (which may be also called tests), which are then used to automatically create a device verification test by a test generator module. A wide variety of design environments can be tested and verified with this language. Thus, the disclosed procedure is generalizable, yet is also simple to program and to debug by the engineer.","However, the reliance on human intervention is still highly problematic. In particular, human intervention is costly and also slows the process of testing. Furthermore, any aspect of a testing process that requires human intervention represents a potential bottleneck for the rapid and efficient performance of the testing process. As can be seen from the above description, testing processes which minimize human intervention, while maximizing the value and effect of such intervention, are clearly more desirable. Although significant progress has been made toward these goals, currently available testing systems still require significant human intervention, at least at the level of test creation.","The background art does not teach or suggest a method for truly automatic test program creation and generation. The background art also does not teach or suggest a method for generating a test program from a general description of such a program and\/or of the goals to be achieved by a test generated through such a test program.","The present invention overcomes these disadvantages of the background art by providing generalized scenarios for automatic test program generation, for design verification of a DUT (device under test). The tests themselves (instances of tests), which are generated by and\/or through the test program, are performed on a simulation model of the DUT; however, it should be noted that the terms \u201cDUT\u201d and \u201csimulation model\u201d are used interchangeably in the context of the testing and verification process.","The present invention is of a system and method for automatically generating such test programs according to a generalized mechanism. By \u201cgeneralized mechanism\u201d, it is meant that in place of having the user prepare a complete test program, the user may instead only create guidance for how the tests are to be generated. In the background art, as for example in co-assigned U.S. Pat. No. 6,182,258, previously incorporated by reference, the user creates a test program, which is loaded into the system and guides the test generator to generate tests. One such program can generate a multitude of tests because of the process of randomization. The present invention extends and generalizes the process of creating a test program, by allowing the user to only create guidance for test generation. As described below, such guidance may optionally include an at least partially automatic process for generating the code for the test program, and\/or a process of selecting code for the test program from a plurality of choices, for example.","One or more scenarios are defined for the operation of the present invention. These scenarios undergo a generation phase to create a \u201cprogram instance\u201d or a test program as described above. The program instance then undergoes generation to create a test instance (or test) as in the background art.","The present invention may optionally be performed in a two stage (or even multistage) process, or alternatively as one continuous stage. The former embodiment is implemented when external files, such as HDL files for example, need to be generated. These files are generated in a separate stage from the generation of the scenarios etc, before the test program can be run.","The first, more general implementation, starts with a plurality of scenarios being input by the user or otherwise provided. These scenarios are provided with (optionally) one or more meta data elements and one or more constraints indicating at least which scenarios may be combined together in a particular test program, and which are in conflict. Preferably, the constraint(s) are also provided for the test generation itself, as described in greater detail below. A selection is then made from these scenarios, including at least one such scenario but preferably including a plurality of (non-conflicting) scenarios. This selection is done by resolving the constraints associated. The selected scenario(s) are then combined in a combination phase, to form a combined scenario instance. This combination is then used to generate a test program at run time, in a generation phase, which is actually a continuation of the combination phase; the two phases are described separately herein for the purposes of description only and without any intention of being limiting.","According to an optional but preferred embodiment of the present invention, a plurality of scenarios is combined together during the combination phase. These scenarios are optionally and more preferably selected from a group of scenarios which may optionally contain potentially conflicting scenarios. The scenarios selected from this group and combined in the combination phase are a non conflicting subset of the group. One or more scenarios are more preferably sequences.","A sequence is a scenario that describes an application of a stimulus over time. As such a sequence includes at least one process which comprises a generation operation in which a data item is created and a driving operation in which said data item is applied. A sequence preferably comprises multiple such processes, with synchronization operations interleaved between the steps.","Sequences are optionally and preferably implemented as an e language construct which provides a \u201cmini-test\u201d. Although sequences may optionally be used with code generation, such code generation is not required for generating a test program. Sequences preferably define streams of data items (code instructions for the test program). Sequences are paired with sequence drivers, which enable the sequence to be operative for generating a test.","For the present invention, one or more sequences may optionally be selected for forming the test program. More preferably, one sequence is able to call the next sequence to be able to construct the test program from a plurality of sequences.","According to an optional but preferred embodiment of the present invention, the constraint(s) preferably also comprise a description of a type of expected variable and a type of operation to be performed on the expected variable. For example, the operation could optionally comprise a sampling process for a variable of the simulation model for simulating the DUT (device under test), again as previously described for the test program which would then generate the test.","According to an optional but preferred embodiment of the present invention, the test program is generated through a two stage generation process. The first stage of the generation process preferably includes the creation of code, such as a HDL (hardware description language) file and also verification language code, such as e code for example. One or more of the file(s) created in the first stage may optionally require compilation prior to use during the second stage. The second stage of the generation process preferably includes reading in some of the code generated in stage one and the generation of one or more actual test programs based at least in part on the code generated during stage one. The second stage may optionally be performed according to a randomized or semi-randomized process. It should be noted that the second stage may optionally include both pre-run time and also run-time processes, such that there is not necessarily a one-to-one mapping between \u201cfirst and second stages\u201d and \u201cpre-run time and run-time generation processes\u201d.","It should also be noted that the automatic test program generation according to the present invention should be distinguished from previously known test generation processes in that the generation process according to the present invention includes at least one process for generating data that is subsequently used for generating values for the test inputs.","The present invention is of a method for generating test programs according to generalized guidance, rather than according to a completely predefined set of rules or instructions. According to this method, one or more scenarios are defined for the operation of the present invention. These scenarios undergo a generation phase to create a \u201cprogram instance\u201d or a test program as described above. The program instance then undergoes generation to create a test instance (or test) as in the background art, as described for example in co-assigned U.S. Pat. No. 6,182,258.","The present invention may optionally be performed in a two stage (or even multistage) process, or alternatively as one continuous stage. The former embodiment is implemented when external files, such as HDL files for example, need to be generated. These files are generated in a separate stage from the generation of the scenarios etc, before the test program can be run.","The first, more general implementation, starts with a plurality of scenarios being input by the user or otherwise provided. These scenarios are provided with one or more constraints, indicating at least which scenarios may be combined together in a particular test program, and which are in conflict. Preferably, the constraint(s) are also provided for the test generation itself, as described in greater detail below. A selection is then made from these scenarios, including at least one such scenario but preferably including a plurality of (non-conflicting) scenarios. This selection is done by resolving the constraints associated. The selected scenario(s) are then combined in a combination phase, to form a combined scenario instance. This combination is then used to generate a test program at run time, in a generation phase, which is actually a continuation of the combination phase; the two phases are described separately herein for the purposes of description only and without any intention of being limiting.","According to an optional but preferred embodiment of the present invention, a plurality of scenarios is combined together during the combination phase. These scenarios are optionally and more preferably selected from a group of scenarios which may optionally contain potentially conflicting scenarios. The scenarios selected from this group and combined in the combination phase are a non conflicting subset of the group. One or more scenarios are more preferably sequences.","A sequence is a scenario that describes an application of a stimulus over time. As such a sequence includes at least one process which comprises a generation operation in which a data item is created and a driving operation in which said data item is applied. A sequence preferably comprises multiple such processes, with synchronization operations interleaved between the steps.","Sequences are optionally and preferably implemented as an e language construct which provides a \u201cmini-test\u201d. Although sequences may optionally be used with code generation, such code generation is not required for generating a test program. Sequences preferably define streams of data items (code instructions for the test program). Sequences are paired with sequence drivers, which enable the sequence to be operative for generating a test.","For the present invention, one or more sequences are optionally and preferably selected for forming the test program. More preferably, one sequence is able to call the next sequence to be able to construct the test program from a plurality of sequences.","Sequences may optionally comprise patterns of objects that are being generated according to a particular order. An example would be a sequence of CPU instructions, or a sequence of ATM cells. The pattern may optionally have some unique attributes such as \u201cstart with a load instruction, then perform some random\/pseudo-random operation, and end with a store to the same address\u201d.","According to an optional but preferred embodiment of the present invention, the constraint(s) preferably also comprise a description of a type of expected variable and a type of operation to be performed on the expected variable. For example, the operation could optionally comprise a sampling process for a variable of the simulation model for simulating the DUT (device under test), again as previously described for the test program which would then generate the test.","The constraint may optionally include a static constraint on a value of the type of expected input variable. The constraint may optionally (alternatively or additionally) include a dynamic constraint on this value. The previously described one or more rules preferably controls at least one characteristic of the constraint, such as whether a plurality of constraints are operable together or whether a constraint conflicts with another such constraint, for example.","The type of operation may also optionally (alternatively or additionally) include a monitoring operation for monitoring behavior of the simulation model. The simulation model typically includes a plurality of variables, such that the monitoring operation preferably includes sampling at least one value of at least one variable of the simulation model.","The type of expected input variable may optionally and preferably be at least partially determined according to a simulation model of the DUT.","According to an optional but preferred embodiment of the present invention, the test program is generated through a two stage generation process. The first stage of the generation process preferably includes the creation of code, such as a HDL (hardware description language) file and also verification language code, such as e code for example. The second stage of the generation process preferably includes reading in some of the code generated in stage one and the generation of one or more actual test programs based at least in part on the code generated during stage one. The second stage may optionally be performed according to a randomized or semi-randomized process. It should be noted that the second stage may optionally include both pre-run time and also run-time processes, such that there is not necessarily a one-to-one mapping between \u201cfirst and second stages\u201d and \u201cpre-run time and run-time generation processes\u201d.","Referring now to the drawings,  is a schematic block diagram illustrating an exemplary system according to the present invention for test generation. It should be noted that the illustrated system only includes those general functions of the test generation procedure which are required for the description of the present invention. A more complete description of the entire test generation procedure may be found in U.S. Pat. No. 6,182,258, previously incorporated by reference. It should also be noted that although the present invention is described in the context of a simulation model, the present invention is also useful for verification of a physical device. Both the physical device and the simulation model can be described as a DUT (device under test), which is in a test environment.","A test generation system  according to the present invention features a simulator , which may accept a design  for the device under test (DUT), written in a hardware descriptive language such as Verilog or VHDL. In addition, simulator  interacts with a test engine  for performing the test generation procedure at run-time. The interaction between simulator  and test engine  is shown as bi-directional, since test engine  provides input to simulator , and in turn receives the results from simulator  as input for further operation.","Test engine  features a test generator , connected to a run-time system  for testing DUT  at run-time. Test generator  receives a set of constraints  and an I\/O data model , and then performs the testing and verification of DUT . Constraints  may optionally include at least one set of a plurality of dynamic constraints. Run-time system  both drives and samples simulator  during the run-time testing procedure.","During the process of testing and verification, a data collector  requests the values for one or more variables from run-time system . These requests are optionally performed according to a triggering event emitted by run-time system . For example, for collection of data related to temporal coverage, such a triggering event is optionally a fixed, predefined sampling time and\/or the occurrence of a temporal pattern of state transitions as defined by a temporal expression given in a temporal language, for example. Data collector  is able to communicate with test generator  and to access the requested data through the API (application programming interface) for test generator . Such an API specifies the software function calls required in order to collect the desired data. This collected data is then analyzed by a data analyzer . The information obtained from the analysis by data analyzer  is then preferably used to create new tests and\/or adjust one or more constraints at constraints .","According to a preferred embodiment of the present invention, constraints  and I\/O data model  are preferably constructed in e code, which is the code language provided by the Specman\u2122 functional programming environment (Verisity Design, Inc., Mountain View, Calif., USA) and disclosed in U.S. Pat. No. 6,182,258, previously incorporated by reference. Such an embodiment is preferred because of the ease and flexibility of programming in e code.","The e code language is a hardware-oriented verification specific object-oriented programming language. Objects in this language are instances of \u201cstructs\u201d, which contain a field, and one or more functions, or methods, which operate on data stored within the field and which interact with other objects. Optionally, a constraint can operate on the field, thereby altering the data stored in the field, for example by restricting the range of possible values for the data. The field can also be used to store more complex structures, including other structs and lists of scalars or structs.","The process of test generation fills data elements, including structs and fields, with random values. The possible data values for each element can optionally be limited by constraints, which provide the direction for the directed test generation. For dynamic constraints, a selected, specific solution is preferably provided according to the present invention for each instance of test generation, as described with regard to PCT Application No. PCT\/IL01\/01011 (published as WO 02\/37340). This solution is then used to provide limitations on the generated data values.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 2","b":"1"},"As an example, currently (without the present invention) an illustrative test program could optionally be written in the e language as follows (the example is intended to detect an overflow of large packets, which are defined in this example as packets that are larger than a particular given size, as defined with regard to the \u201cpacket\u201d struct):",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"extend sys {"]},{"entry":[{},"\u2003\u2003keep buffer_size == 0;"]},{"entry":[{},"};"]},{"entry":[{},"extend packet {"]},{"entry":[{},"\u2003\u2003keep len > 100;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For the present invention, the instructions are preferably written in the e language as follows. First, the following type is preferably predefined for the sys file as follows:",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type scenario_kind: [ ];"]},{"entry":[{},"Extend sys {"]},{"entry":[{},"\u2003\u2003Scenario: scenario_kind;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"extend scenario_kind: [big_packets_overflow];"]},{"entry":[{},"extend sys {"]},{"entry":[{},"\u2003\u2003keep scenario == big_packets_overflow =>"]},{"entry":[{},"\u2003\u2003\u2003\u2003buffer_size ==0;"]},{"entry":[{},"};"]},{"entry":[{},"extend packet {"]},{"entry":[{},"\u2003\u2003keep sys. scenario == big_packets_overflow => len > 100;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Next a scenario is preferably selected for generating the test program in stage . The scenario contains the necessary constraint(s) and instructions for generating the test as described above. The process of selection is optionally and preferably performed according to type or configuration of the DUT.","Optionally and preferably, this stage includes selecting a plurality of scenarios according to their respective constraint(s), to avoid conflicts between the scenarios. Next, these selected scenarios are preferably combined to form a combined scenario instance.","The test program is then preferably generated from the scenario and\/or combined scenario instance in stage .","As previously described, this type of generation process for a test program may optionally be performed with sequences, an e language construct. A sequence is preferably created as follows. First, the sequence is defined by using the sequence statement. Next, the code is modified to inherit from such a defined sequence. The sequence driver is then hooked into the test environment (this \u201chook\u201d enables the sequence driver to operate the instructions of the sequence for generating a test program).","An illustrative non-limiting example for generalized scenarios is provided below.","TEST 1\u2014Overflow",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\u2018"]},{"entry":[{},"\/\/ Assume there is a packet type"]},{"entry":[{},"\/\/ A test file for creating overflow conditions"]},{"entry":[{},"extend sys {"]},{"entry":[{},"\u2003\u2003\/\/ buffer_size is a system parameter defining the size of"]},{"entry":[{},"\u2003\u2003\/\/ the buffer holding the data of the packets - many packets"]},{"entry":[{},"\u2003\u2003\/\/ with big data may cause an overflow"]},{"entry":[{},"\u2003\u2003keep buffer_size <= 2; \/\/ That will force an overflow..."]},{"entry":[{},"};"]},{"entry":[{},"extend packet {"]},{"entry":[{},"\u2003\u2003\u2003keep len > 100; \/\/ Big data will cause overflow ..."]},{"entry":[{},"};"]},{"entry":[{},"\u2019>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"TEST 2\u2014Small Packets, no Overflow",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\u2018"]},{"entry":[{},"\/\/ A test file for creating small packets"]},{"entry":[{},"extend packet {"]},{"entry":[{},"\u2003\u2003keep len < 20; \/\/ Force data to be small..."]},{"entry":[{},"};"]},{"entry":[{},"\u2019>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"SMALL\/BIG tests (in which a value for a parameter is made very small and\/or very large as a test of extreme edge conditions) may be provided through the following generalized scenario which is capable of creating either condition.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\u2018"]},{"entry":[{},"Type scenario_kind: [ ];"]},{"entry":[{},"Extend sys {"]},{"entry":[{},"\u2003\u2003\u2003Scenario: scenario_kind;"]},{"entry":[{},"};"]},{"entry":[{},"\/\/ Scenario 1"]},{"entry":[{},"extend scenario_kind: [big_packets_overflow];"]},{"entry":[{},"extend sys {"]},{"entry":[{},"\u2003\u2003keep scenario == big_packets_overflow => buffer_size ==0;"]},{"entry":[{},"};"]},{"entry":[{},"extend packet {"]},{"entry":[{},"\u2003\u2003\u2003keep sys. scenario == big_packets_overflow => len > 100;"]},{"entry":[{},"};"]},{"entry":[{},"\/\/ Scenario 2"]},{"entry":[{},"extend scenario_kind: [small_packets];"]},{"entry":[{},"extend packet {"]},{"entry":[{},"\u2003\u2003\u2003keep sys. scenario == small_packets => len <= 20;"]},{"entry":[{},"};"]},{"entry":[{},"\u2019>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"It should be noted that generating the Scenario field above will result in the choice of one of the two scenarios defined, and all subsequently generated packets will be generated accordingly.","GOOD\/BAD tests provide a test for conditions in which some input data is not correct. For the example below, the scenarios are enhanced with some sequences that are mixed in.",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"extend packet_sequence_kind: [two_good_one_bad, all_good"]},{"entry":[{},"and_wait];"]},{"entry":[{},"<\u2018"]},{"entry":[{},"\/\/ Assume a packet_sequence is defined"]},{"entry":[{},"extend two_good_one_bad packet_sequence {"]},{"entry":[{},"\u2003body( ) @driver.clock is {"]},{"entry":[{},"\u2003\u2003do packet keeping {.kind == GOOD};"]},{"entry":[{},"\u2003\u2003do packet keeping {.kind == GOOD};"]},{"entry":[{},"\u2003\u2003do packet keeping {.kind == BAD};"]},{"entry":[{},"\u2003};"]},{"entry":[{},"};"]},{"entry":[{},"extend all_good_and_wait packet_sequence {"]},{"entry":[{},"\u2003num_packets\u2003\u2003:uint;"]},{"entry":[{},"\u2003body( ) @driver.clock is {"]},{"entry":[{},"\u2003\u2003for i from 1 to num_packets {"]},{"entry":[{},"\u2003\u2003\u2003do packet keeping {.kind == GOOD};"]},{"entry":[{},"\u2003\u2003};"]},{"entry":[{},"\u2003\u2003wait cycle;"]},{"entry":[{},"\u2003};"]},{"entry":[{},"};"]},{"entry":[{},"\u2019>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following example demonstrates that by loading both BIG\/SMALL and GOOD\/BAD scenarios, the following variability may optionally be generated. For example, first select a case of either big or small packets (which are selected once per test, and are mutually exclusive). Next, throughout the test keep selecting a sequence from the two sequences defined. Packets may then be generated according to the sequence.","For example, the following pseudo-instructions may optionally be performed, in which the items starting with the symbol \u201c->\u201d are the expected response to the listed commands:",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"- choose with SMALL packets"]},{"entry":[{},"\u2002choose two_good_one_bad"]},{"entry":[{},"\u2003-> small good packet"]},{"entry":[{},"\u2003-> small good packet"]},{"entry":[{},"\u2003-> small bad packet"]},{"entry":[{},"\u2002choose all_good_and_wait"]},{"entry":[{},"\u2003-> small good packet"]},{"entry":[{},"\u2003\u2003...."]},{"entry":[{},"\u2003\u2003wait."]},{"entry":[{},"\u2002---"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 3","FIG. 2"],"b":["300","302","304","306"]},"The process continues with another, non-conflicting scenario being selected by selecting a sequence . The selected sequence  involves producing either two \u201cgood\u201d packets and one \u201cbad\u201d packet, or all \u201cgood\u201d packets and then waiting. It should be noted that the terms \u201cgood\u201d and \u201cbad\u201d are simply attributes, or enumerated values assigned to a variable. This classification typically relates to a packet containing valid data which is GOOD, as opposed to a packet containing corrupt data or bad error correction signature which is BAD. Of course any other attributes could be used in place of this particular exemplary classification. This selection feeds into the process of test generation for \u201cgood\u201d or \u201cbad\u201d packet instructions at packet generator ; the packet instructions themselves are shown as packets  that are \u201cgood\u201d (G) or \u201cbad\u201d (B); waiting is shown as wait . The process ends by producing generated input  for simulation engine .",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 4"},"In stage , optionally a plurality of scenarios is provided as for the method of . In stage , one or more scenarios are selected. Optionally and preferably, a plurality of scenarios are selected according to their respective constraints, as described above, and combined to form a combined scenario instance.","Next, in stage , an HDL (hardware description language) file for defining the simulation model according to the scenario program is preferably created. Also optionally and preferably, in stage , code is generated for executing this plurality of instructions for the scenario program. The code may optionally and more preferably include e language code, for example in one or more e language files. Stages - are preferably included in the first stage of the test program generation process.","In the second stage, starting with stage , the test program itself is preferably generated from the scenario program. Optionally and more preferably, the values for various fields are preferably generated as part of the test program generation process. This process is more preferably randomized. Stage  may optionally be performed during both the test pre-generation and run-time stages for test program generation.","A non-limiting, illustrative example of the above two stage generation process is provided below.","For this example, a multi port device is assumed. The device is tested with variable configurations, for example 2 ports, 5 ports and so forth. The simulation model for the device itself needs to be defined in Verilog HDL; different configurations require different top level HDL files to be created.",{"@attributes":{"id":"p-0083","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\u2018"]},{"entry":[{},"extend sys {"]},{"entry":[{},"\u2003number_of_ports :uint;"]},{"entry":[{},"\u2003keep number_of_ports in [1..5];"]},{"entry":[{},"\u2003post_generate( ) is also {"]},{"entry":[{},"\u2003\u2003\/\/ write a top level Verilog file with the"]},{"entry":[{},"\u2003\u2003\/\/ appropriate number of ports"]},{"entry":[{},"\u2003};"]},{"entry":[{},"};"]},{"entry":[{},"\u2019>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"After generating the test, a new top level Verilog file is created, which needs to be compiled and loaded into the simulator before the test can continue. Loading the above example causes the scenarios to be run with the selected configuration, e.g. the number of ports picked by the generation process for the first phase.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 5","FIG. 4","FIG. 3"],"b":"312"},"For the two stage process, unlike for , a process system  also includes a generated HDL configuration  which determines the configuration of the DUT itself by generating an HDL file (alternatively, the configuration may optionally be selected first, followed by generating an HDL file according to the selected configuration). Such an HDL file is an example of an external file that is generated in the first stage.","The generated external file is compiled in process , which results in a configured DUT . The configured DUT  is fed into simulation engine , along with the output of packet generator , which is shown as packet traffic . Packet traffic  is actually identical to generated input  of , but is addressed by a separate term and reference number to avoid confusion."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The attached figures illustrate certain aspects of the invention but are not meant to be limiting in any way.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 5","FIG. 4"]}]},"DETDESC":[{},{}]}
