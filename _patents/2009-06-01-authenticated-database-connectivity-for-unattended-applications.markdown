---
title: Authenticated database connectivity for unattended applications
abstract: A custom database connectivity component is deployed in conjunction with a native database connectivity component and a credential manager. The custom connectivity component has a requestor interface for communicating with a requestor application, a credential service interface for communicating with the credential manager, a native database connectivity interface for communicating with native connectivity components, and a decision engine for determining how to convert a request from a requestor to an appropriate API call to the credential manager. The custom connectivity component provides an authenticated and authorized database connection for a requestor application. The component transparently serves retrieves database, or other target resource, credentials on a real time basis, without requiring code changes to the requestor application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08839414&OS=08839414&RS=08839414
owner: Irdeto Canada Corporation
number: 08839414
owner_city: Ottawa
owner_country: CA
publication_date: 20090601
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND TO THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a National Entry of PCT\/CA2009\/000759, filed Jun. 1, 2009, which claims the benefit of U.S. Provisional Application No. 61\/057,557, filed May. 30, 2008, the contents of which are incorporated herein by reference in their entirety.","The present invention relates to security systems for computer systems. More particularly, it relates to methods and systems for credential management, particularly for granting access to resources to software applications without human intervention.","The ever rising dependency on computer systems has resulted in an attendant rise in concern regarding computer security. One well-known method for restricting access to computers and computer resources (e.g. one program or application accessing another) is that of using passwords. Hard-coded application passwords provide the de-facto methodology to permit one application (requester) to authenticate to another application or service (target), such as a database, for the purpose of gaining access to the resources and\/or data offered by the target.","However, hard-coding of passwords creates significant vulnerabilities to data since the hard-coded passwords remain as clear-text information that is susceptible to malicious viewing. Such passwords also require distribution to developers and have long validity periods to accommodate for their lack of change. These considerations only increase the vulnerability to security breaches.","For those organizations with password change policies, hard-coded passwords have a drawback in that they entail a recurring software maintenance issue. Also, there are significant costs associated with human redevelopment effort and there is a potential for application outages due to synchronization errors and timing.","Regardless of these drawbacks, hard-coded passwords remain in use for approximately 90% of all corporate applications. New applications are being developed and deployed that contain hard-coded passwords. Third-party (vendor) applications force corporations to accept and deploy systems containing hard-coded passwords. 70% of datacenter applications are database driven.","While User Identity Management systems offer authentication and authorization of individuals to systems, there are significant difficulties in utilizing these solutions for the purposes of unattended applications: they rely upon user manual interaction for authentication; they rely upon user manual interaction for recovery of authentication credentials; they do not include credential access and management capabilities for automatic use by unattended scripts and applications; they offer no tamper resistance; they offer no defence against static or dynamic analysis; and they assume that employees are generally to be trusted, an assumption which is demonstrably untenable due to the prevalence of insider attacks.","Another possibility is the use of provisioning systems. Provisioning systems offer the ability to push operating system and software configuration updates to servers. However, there are significant difficulties of utilizing these solutions for the purposes of unattended applications: they do not include run-time retrieval of credentials for use by unattended scripts and applications; they do not include credential access and management capabilities for automatic use by unattended scripts and applications; they offer no tamper resistance; and they offer no defence against static or dynamic analysis.","Another option is the use of Public Key Infrastructures. Public Key Infrastructures offer the components needed to create a comprehensive and elegant authentication and authorization solution. However, there are significant difficulties of utilizing these solutions for the purposes of unattended applications: they do not protect keying materials while in memory; they rely upon user interaction for access to authentication credentials; they do not include credential access and management capabilities for automatic use by unattended scripts and applications; they offer no tamper resistance; they offer no defence against static or dynamic analysis or tampering of the application code; they dramatically shift the authentication paradigm for corporations and incur larger integration and deployment efforts; and both the authenticator and the authenticate must be modified to make use of PKI for authentication purposes.","Another possibility is the use of the Kerberos authentication protocol. The Kerberos authentication protocol offers the components needed to create a comprehensive and elegant authentication and authorization solution. However, However, there are significant difficulties of utilizing this solution for the purposes of unattended applications: it does not protect keying materials while in memory; it relies upon user interaction for access to authentication credentials; it relies on hard-coded passwords for authentication by unattended applications; it does not include credential access and management capabilities for automatic use by unattended scripts and applications; it offers no tamper resistance; it offers no defence against static or dynamic analysis or tampering of the application code; it dramatically shifts the authentication paradigm for corporations and incurs large integration and deployment efforts; and it requires that both the authenticator and the authenticatee be modified to make use of Kerberos for authentication purposes.","There is therefore a need for systems and methods which will allow for unattended authentication of applications so that these applications can access resources. Ideally, such systems and methods avoid the shortcomings of hard-coded passwords while providing a similar if not higher level of security.","It is therefore an object of this invention to provide a novel method and system of password release that obviates or mitigates the disadvantages of the prior art.","According to an aspect, there is provided a computer-implemented method for providing secure credentials for accessing a target resource. The method, when executed on one or more processors, causes the one or more processors to perform the following steps. A connection request to the target resource is received from a requestor application. The request is then decoded, such as by parsing, to extract information required by a credential manager to authenticate the requestor application and to retrieve the secure credentials, such as username and password, for accessing the target resource. The credential manager manages and stores credentials for the target resource. The extracted information is then securely communicated to the credential manager to retrieve the credentials. The secure communication can, for example, comprise encrypting communications to and from the credential manager. Using the credentials retrieved from the credential manager, a native target resource connection request to the target resource is generated. This native target resource connection request is then passed to a native target resource connectivity component to establish a connection between the requestor application and the target resource.","According to embodiments, the method can implement Java Database Connectivity (JDBC) Application Programming Interfaces (APIs). Receiving the connection request comprises receiving a JDBC Uniform Resource Locator (URL) containing a target resource URL, and a target alias for retrieving the credentials from the credential manager, and generating the native target resource connection request comprises packaging the retrieved credentials with the target resource URL to provide a native JDBC URL.","According to further embodiments, the method can implement Open Database Connectivity (ODBC) APIs, wherein receiving the connection request comprises receiving an ODBC connection request containing a target alias for retrieving the credentials from the credential manager, and a connection string for the native target resource connectivity component, and generating the native target resource connection request comprises packaging the retrieved credentials with the connection string.","According to a further aspect, there is provided a computer program product comprising a computer-readable medium storing computer executable instructions to provide secure credentials for accessing a target resource. When executed, the instructions cause the one or more processors to implement the following functional modules. A requestor interface is implemented to communicate with a requestor application to receive a connection request including target resource information identifying the target resource and configuration information necessary to authenticate the requestor application. A credential service interface is implemented to securely communicate with a credential manager that manages and stores credentials for the target resource. A native database connectivity interface is implemented to communicate with a native database connectivity component that establishes a connection with the target resource. And, a decision engine is implemented to communicate with each of the requestor interface, the credential service interface and the native database connectivity interface. The decision engine function to decode the request to determine an identity of the target resource and the configuration information required by the credential manager to authenticate the requestor application and to retrieve the secure credentials for accessing the target resource, the credential manager managing and storing credentials for the target resource; securely communicate the extracted information to the credential manager to retrieve the credentials; generate a native database connection request to the target resource, including the retrieved credentials; and pass the native database connection request to the native database connectivity component to establish the connection.","Other aspects and features of the present invention will become apparent to those ordinarily skilled in the art upon review of the following description of specific embodiments of the invention in conjunction with the accompanying figures.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["10","12","14","16","18","12","20","20","22","24","12","20","26","28","30","28","20","12"]},"The requestor node , the CM node , and the target node  are all nodes in a computer network and may be single machine servers or a collection of interconnected servers. The various modules in  are software modules which interact with the hardware of the nodes to execute their instructions.","The CM node  operates with the CM module  controlling the data store  which stores the credentials required to access the resources . The requestor application , when it needs access to the resources , must request these credentials to gain access to the resources. The requestor application's request is communicated to the SPM module  residing on the same node as the requestor application . The SPM module  receives the request, extracts the relevant information from the request, and packages that information into a request package for transmission to the CM module. The SPM module  encrypts the request package using encryption keys generated by the CM module  and previously communicated to the SPM module . The SPM module  also transmits, with the encrypted request package, fingerprint data related to the requestor node .","To communicate the credentials to the target resources , the CM module  may send these credentials directly to the target resources  along with an identification of the requestor application  which is to be granted access. Alternatively, the CM module  may return the credentials to the SPM module  so that the requestor application  may directly use these credentials to access the target resources . The CM module  may also communicate with the target resources  and its associated SPM module  for updates regarding changed credentials such as passwords and encryption keys.","It should be noted that the SPM module  in the requestor node  may use the secure cache  to store credentials for the requestor application  so that future accesses to the target resources need not go through the CM module . Similarly, encryption keys generated by the CM module  and used by the SPM module  to encrypt\/decrypt communications with the CM module  may also be stored in the secure cache .","To operate securely, each SPM module ,  must, before being able to execute the process outlined above, identify itself to the CM module  and receive unique encryption keys for use in communicating with the CM module . As part of this setup stage, each SPM module ,  gathers data about its node ,  including what resources may be target resources, what applications may be requestor applications, and the details regarding these resources and applications. The SPM module ,  also gathers configuration information for its node such as the hardware installed on the node and other configuration information that would uniquely identify that node. This configuration information (which may include serial numbers, applications installed on the node, version numbers of both software and hardware installed) may then be used as a \u201cfingerprint\u201d of that node. The fingerprint data may collected on one node can then be sent, along with the other information on that specific node, to the CM node  for validation. Once validated, a requestor node, and the SPM module resident on it, can request access to resources registered with the CM module . Of course, only the requestor applications resident on nodes registered with the CM module  are permitted to access the target resources . New applications on a node must register and be validated by the CM module  prior to being able to request access to the target resources.","It should be noted that, to gain access to the credentials needed to access resources, each SPM module must provide its node's fingerprint data every time a requestor application resident on its node asks for access. As mentioned above, this fingerprint data is transmitted to the CM module  along with the relevant information relating to the target resource access request by the requestor application. When the CM module  receives such fingerprint data, the CM module  can retrieve the registration data for that particular node from the data store  to check if the fingerprint data received from the requester node matches the fingerprint data received when the requestor node was first validated. If there is a match, then the SPM module is what it purports to be and further checking may proceed. If there is no match, then the resource access request is denied. Denial of such a request means that the requestor node must undergo the initial registration\/validation process.","It should further be noted that, once a requestor node (through an SPM module resident on it) or an SPM module (if there is more than one SPM module per requestor node) is validated by the CM module , the CM module generates cryptographic keys which are to be used in communications between the CM module  and the SPM module or requestor node. These cryptographic keys are, once a copy has been sent to the relevant SPM module\/requestor node, kept in the data store  for use by the CM module. It should be clear that a requestor node may have more than one SPM module resident on it, with each SPM module being tasked with managing target resource access for at least one requestor application on the requestor node. For such a configuration, each SPM module may have its own set of cryptographic keys for use in communicating with the CM module. For greater security one may have a configuration in which each requestor application has its own encryption keys shared with the CM module for use when communicating between the two.","Each requestor application, along with its associated SPM module and the node it is resident on, is registered and validated with the CM module. To gain access to the target resources, the requestor application asks for such access and transmits data that it originally transmitted to the CM module when it sought validation and registration. Such data may include its application name, its application file storage location, its application execution path, its application identification (ID), its application one-way hash value, its session authorization key, and the machine fingerprint of the node it is resident on. Of course, depending on the configuration of the system, any subset of the above, with or without extra data, may also be used to gain access to the resources.","Regarding the data store  in the CM node , the data store may be in the form of a database. Critical values may be encrypted using a strong cipher for storage in a database field in the database. Critical encrypted data may be written into a private database using a long, strong password, the private database being part of the database. This private database may then be protected using a password that is encrypted using a managed symmetric key. The managed key may then be placed in a public database table to allow the key to be changed in an ad hoc or scheduled manner.","To simplify the record keeping duties of the CM module, the concept of aliases may be used. Each target resource (e.g. an application on a target server) may be associated with a specific alias. Also associated with the alias are the target resource's credentials (e.g. account and password). A potential requestor application which may request access to the target resource, when registered\/validated, is then mapped to the alias along with that requestor application's access rights and any run-time criteria required for the release of credentials for access to the target resource. This injects a level of indirection for retrieving credentials\u2014it allows credentials to change without any impact on the requestor application. Requestor applications, therefore, need not be individually notified if credentials required to access a specific resource are changed.","As noted above, the SPM module  may use the secure cache  so that previously accessed resources may be accessed by other requestor applications on the same node. This will allow faster access to resources for requestor applications. To use the secure cache , credentials received from the CM module  may be saved in the secure cache . Should a requestor application  on the same node as the SPM module  request access to resources for which credentials have been stored in the secure cache , the SPM module  can authenticate the requestor application locally and provide the necessary credentials. Of course, for security reasons, the contents of the secure cache may be encrypted and the contents may be time limited in that the contents may be automatically deleted after a predetermined amount of time. Such a scheme ensures that credentials need to be accessed periodically such that stale credentials are never stored indefinitely.","To ensure that the credentials (e.g. passwords and encryption keys) used to access the resources are up to date, the CM module may change the credentials for these resources. The CM module  can communicate with the resources (e.g. a software application) to change the credentials required to access the resources. Once the credentials have been changed, the new credentials are communicated to the CM module . The CM module  then updates the relevant records in the data store .","The system illustrated in  provides secure credential management for unattended applications. However, as will be appreciated by those of skill in the art, the SPM modules ,  must be integrated with the requestor application and the target node , requiring skilled programmers and changes to the code of the requestor application . To encourage adoption of secure password authority systems within large enterprises running legacy applications, it is, therefore, desirable to provide a means to interface with the password authority system without requiring specialized recoding or programming knowledge.","Generally, the present invention provides a method and system through which it is possible to authenticate database connections for unattended requestor applications by installing and configuring a SPM target resource connectivity component (hereafter \u201cSPM connectivity component\u201d), without need to recode the requestor application. The SPM database connectivity component intercepts requests for a target resource, repackages the requests in a form comprehensible to a credential manager, accesses secure credentials from the credential manager, and passes the credentials to the target resource. The credential manager can, for example, be a CM node as described above, such as the CloakWare\u00ae Server Password Manager or other available credential managers.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":["100","102","104","106","108","102","110","102","104","112","102","114"]},"The credential manager  is a component deployed to or available to a requestor node . The credential manager  coordinates credential requests for local requestor applications. The credential manager  typically provides API's for varying types of requestor applications. In an embodiment, the CM node  includes the components and functionality described above in relation to . The requestor node , the CM node , and the target node  are all nodes in a computer network and may be single machine servers or a collection of interconnected servers. The various modules in  are software modules which interact with the hardware of the nodes to execute their instructions.","The overall operation of a credential management system using the SPM connectivity component  is illustrated in , with reference to . The requestor application  requests connection to a target resource , such as a database (step ). The SPM connectivity component  intercepts or receives this request (step ), and decodes the connection request (step ). The SPM connectivity component then requests credentials from the credential manager  (step ). The credential manager  authenticates the request, and returns the necessary credentials to fulfill the request to the SPM connectivity component  (step ). The SPM connectivity component  initializes a native database connection through the native connectivity component  using the credentials supplied by the credential manager  (step ). The native connectivity component  then establishes, or attempts to establish, a connection to the external target system hosting the target resources  (step ). If the credentials are valid, and the connection is established, an established connection to the target  is returned to the requestor application  (step ). If the attempt to establish the connection is not successful, an optional retry can be executed. Further credentials are retrieved from the credential manager , and a connection retry is attempted commencing at step . The number of acceptable retries is a matter of design choice.","As shown in , the SPM connectivity component  is a software module. It is deployed in conjunction with the native database connectivity component  and the credential manager . The SPM connectivity component  comprises a requestor interface  for communicating with the requestor application , a credential service interface  for communicating with the credential manager , a native target resource connectivity interface  for communicating with native connectivity components, a security interface  for allowing for updates from a security manager, and a decision engine  for determining how to convert a request from a requestor to an appropriate API call to the credential manager .","The SPM connectivity component provides an authenticated and authorized database connection for a requestor application. The SPM connectivity component serves as the database connectivity component which retrieves database, or other target resource, credentials on a real time basis, without requiring code changes to the requestor application where native connectivity components are dynamically loaded. The SPM connectivity component authenticates and authorizes all access for database connections for requestor applications.","The functioning of the SPM connectivity component  can best be understood with reference to example implementations. Two example embodiments are described below: a JDBC SPM connectivity component, and an ODBC SPM connectivity component. These examples are non-limiting, and illustrative only. The examples assume a familiarity with Java programming, and with JDBC and ODBC connections, as is expected from someone of skill in the art.","JDBC is an API for the Java programming language that defines how a client may access a database. It provides methods for querying and updating data in a database. The JDBC uses a custom Java DataSource object. A DataSource object is the representation of a data source in the Java programming language. In basic terms, a data source is a facility for storing data. It can be as sophisticated as a complex database for a large corporation or as simple as a file with rows and columns. A data source can reside on a remote server, or it can be on a local desktop machine. Applications access a data source using a connection, and a DataSource object can be thought of as a factory for connections to the particular data source that the DataSource instance represents. The custom Java DataSource object encapsulates the call to a data source or target resource, and transparently accesses the credential manager  to retrieve the secure credentials needed to access the data source.","The role of the SPM connectivity component  is the transparent management of authentication in the database connection acquisition. To achieve this functionality and feature capability, a proxy JDBC Driver class, referred to herein as an SPM Proxy Driver, is provided and implements the decision engine . This proxy Driver class operates on a specially defined URL that encodes all information required for the true underlying JDBC connection management and Driver utilization, managed by the native connectivity component . This proxy class is specified, by a user during configuration, as the Driver class for any database. The user can then encode the necessary JDBC URL information in a standard way. In execution, the JDBC Proxy Driver behaves as a normal JDBC driver, but is transparently performing delegated JDBC driver invocations, and calls to the credential manager . The proxy JDBC Driver class uses a specialized JDBC URL encoding which will be referred to as an SPM JDBC URL, details of which are provided below. Functionally, the SPM Proxy Driver obeys all requirements and follow all conventions of use that apply to a Java JDBC Driver class.","To securely retrieve the necessary credentials to access a target resource, a custom designated URL property is used to declare an SPM Alias. As described above, each target resource (e.g. an application on a target server) can be associated with a specific alias. Also associated with the alias are the target resource's credentials (e.g. account and password). A potential requestor application, which requests access to the target resource, when registered\/validated, is then mapped to the alias along with that requestor application's access rights and any run-time criteria required for the release of credentials for access to the target resource. This injects a level of indirection for retrieving credentials\u2014it allows credentials to change without any impact on the requestor application. Requestor applications, therefore, need not be individually notified if credentials required to access a specific resource are changed.","The custom designated URL property is defined to declare the exact driver class that the SPM Proxy Driver should use as the true (target) JDBC Driver. In all connection attempts, the credentials, such as user\/password, are obtained from the credential manager . The SPM Proxy Driver ignores all caller-supplied user\/password instances. The SPM Proxy Driver can preferably also handle cases of failure or error in the invocation of the credential manager . To treat these cases, certain SPM specific exceptions, necessarily derived from SQLException, can be defined.","The core class for the SPM JDBC proxying is the SPM Proxy Driver class, which implements the java.sql.Driver interface and contains all of the required service implementations. The SPM Proxy Driver class manages all SPM JDBC URL's. More specifically: a single instance of the SPM Proxy Driver class registered with a driver manager manages all SPM JDBC URL's. This means that different databases may be accessed concurrently through a single SPM Proxy Driver instance.","The SPM JDBC URL is a custom JDBC URL that encodes a true JDBC URL along with addition information for proxying the Driver and for handling and managing the credentials through the credential manager . The SPM JDBC URL format is defined as:\n\nspm: [url]; P1=V1; . . . ; Pn=Vn\n\nwhere\n\n","The decision engine  is implemented within the SPM Proxy Driver class, and decodes or parses the SPM JDBC URL into relevant parts that it will use internally. These parts are:\n\n","It is the SPM JDBC URL that will be received by the SPM Proxy Driver class in all of its services where a URL parameter applies. The SPM Proxy Driver class obtains and holds the target JDBC Driver to call for the SPM JDBC URL connect by using an instance of the class named by the value of the property SPMDriver, if present, or otherwise by lookup for a driver which accepts the [url] (the Base URL). In either case, the acquisition of the target Driver can occurs by lookup through the DriverManager class. And, implementing the java.sql.Driver interface, the SPM Proxy Driver stores all of the data required for establishing connections for a given SPM JDBC URL, such as the configuration or fingerprint information of the requestor application or server, in an instance of the JdbcDriverUrlEntry class. The JdbcDriverUrlEntry instances can be stored in a cache keyed by the SPM JDBC URL.","The JDBC implementation of the SPM connectivity component provides a Java library (e.g. jar file with JavaDoc) that can be used by users to integrate the functionality of the credential manager  into their applications without recoding the application. In usage, the end user only needs to add the library with the driver and associated classes to the classpath of the requestor application Server; and configure DataSources in the requestor application server to use the SPM Proxy JDBC drivers specifying an SPM JDBC URL. More specifically, to use the SPM JDBC Driver, attributes in the configuration file are modified to set the connection-url as specified previously, and to set the driver-class to the SPM JDBC Driver","The SPM Proxy Driver class and its affiliated classes form an isolated component that can be separately deployed. It has integration dependencies on the cspmclient.jar library, possibly log4j (or other logging system) when integrated, and the vendor-specific JDBC Driver classes as declared in configuration through the SPM JDBC URL.","The connection request is made by the requestor application  supplying a URL and set of properties. The request is received by the SPM Proxy Driver, which first checks if the received URL is a SPM JDBC URL and thus handled by the class. If the URL is not a SPM JDBC URL, the connection request fails. If the URL is a SPM JDBC URL, then the required JdbcDriverUrlEntry instance is obtained from the JdbcDriverUrlEntryCache. The associateDriver service of the JdbcUrlDriverEntryCache class is responsible for locating the target JDBC Driver that is associated with (bound to) a SPM JDBC URL in a JdbcUrlDriverEntry instance. The cache entry is created at this point if it does not exist.","A call is made to the credential manager  to retrieve the necessary secure credentials, such as a username and password, in each iterated attempt. Communication between the credential manager  and the SPM connectivity component embodied by the SPM Proxy Driver is preferably encrypted to avoid detection or interception by unauthorized parties. The encryption is previously negotiated between the credential manager  and the SPM Proxy Driver, and may, for example, involve an exchange of encryption keys. The credential manager  returns the secure credentials necessary to establish a connection with the target resource . On each attempt, a call is then made to the native target JDBC driver to obtain a connection. The parameters used are the base JDBC URL and a properties object containing the merged properties from the JdbcDriverUrlEntry instance and the properties provided by the requestor application . In the merged properties, the credentials, such as a hard-coded username and password, are overwritten by the values returned from the credential manager . A connection is returned immediately to the requestor application  if one is obtained. Otherwise, a retry can be initiated as described above in relation to , or an SQLException can be thrown to the caller.","This low-level driver management for connection acquisition means that all new connections obtained for a user whose database password has been changed (e.g. by the credential manager ) are made using the new password. This action occurs automatically without any knowledge or intervention by any owning data source. Such connection management by the SPM JDBC driver ensures that database password changes are completely transparent to the data source's activities.","In an ODBC implementation, an custom SPM ODBC driver is provided. ODBC provides a standard software API method for accessing target resources, such as database management systems. The driver uses a credential manager COM object to retrieve the credentials from the credential manager  when a request to connect to the database is made from the requestor application . The request is then passed to the native target ODBC driver to complete the transition. Preferably, the SPM ODBC driver implements all ODBC 2.0 functions and some of the deprecated ODBC 1.0 functions for backward compatibility.","As with the SPM JDBC Driver, the SPM ODBC Driver implements the decision engine . The SPM ODBC Driver connection string contains the following information: Driver\u2014the name of SPM ODBC Driver; Alias\u2014the target Alias to send to the credential manager  when retrieving the credentials; and TargetDriver\u2014the connection string for the target driver. The TargetDriver string contains all of the information required by the target driver, but does not contain the userId and\/or password.","The SPM ODBC Driver needs to add functionality to three functions: SQLConnect\u2014creates a connection to a database using a predefined DSN; SQLDriverConnect\u2014creates a connection to a database using a connection string; and ConfigDSN\u2014creates, modifies or deletes a DSN.","The SQLConnect function has 7 parameters. The first parameter is passed when calling the API function SQLConnect. The second and third parameters are used to retrieve the configuration. The remaining 4 parameters, username and password, are ignored. When the driver's SQLConnect function is called, it will: retrieve the Target Alias and Target DSN; retrieve the credentials using the Target Alias; and call the API function SQLConnect function passing the Target DSN and the credentials retrieved from the credential manager.","The SQLDriverConnect function has 8 parameters. The third and forth parameters are used to retrieve the configuration information. The remaining parameters are passed down when the API function SQLDriverConnect is called. When the driver's SQLDriverConnect function is called, it will: extract the Target Alias and Target Driver from the connection string; retrieve the credentials using the Target Alias; create a copy of the Target Driver connection string and add the credentials (user id and password) retrieved from the credential manager ; and call the API function SQLDriverConnect function passing the update copy of Target Driver connection string.","In the preceding description, for purposes of explanation, numerous details are set forth in order to provide a thorough understanding of the embodiments of the invention. However, it will be apparent to one skilled in the art that these specific details are not required in order to practice the invention. In other instances, well-known electrical structures and circuits are shown in block diagram form in order not to obscure the invention. For example, specific details are not provided as to whether the embodiments of the invention described herein are implemented as a software routine, hardware circuit, firmware, or a combination thereof.","Embodiments of the invention can be represented as a software product stored in a machine-readable medium (also referred to as a computer-readable medium, a processor-readable medium, or a computer usable medium having a computer-readable program code embodied therein). The machine-readable medium can be any suitable tangible medium, including magnetic, optical, or electrical storage medium including a diskette, compact disk read only memory (CD-ROM), memory device (volatile or non-volatile), or similar storage mechanism. The machine-readable medium can contain various sets of instructions, code sequences, configuration information, or other data, which, when executed, cause a processor to perform steps in a method according to an embodiment of the invention. Those of ordinary skill in the art will appreciate that other instructions and operations necessary to implement the described invention can also be stored on the machine-readable medium. Software running from the machine-readable medium can interface with circuitry to perform the described tasks.","A person understanding this invention may now conceive of alternative structures and embodiments or variations of the above all of which are intended to fall within the scope of the invention as defined in the claims that follow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present invention will now be described, by way of example only, with reference to the attached Figures, wherein:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
