---
title: Method and apparatus for self-describing externally defined data structures
abstract: Embodiments of the invention provide a framework for computer application to utilize data structures by loading externally-defined container data structures, and building in-memory representation of data structures at runtime. Contrary to existing applications, computer applications implementing the invention may utilize data structures for which the architecture is not embedded within the application code. Embodiments of the invention provide mechanisms by which applications (or components thereof) implementing the invention may access and modify data structures and their individual elements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07143101&OS=07143101&RS=07143101
owner: 
number: 07143101
owner_city: 
owner_country: 
publication_date: 20030418
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The invention has application in the field of building software applications. More particularly, the invention is directed at providing a method and apparatus for building computer programs applications utilizing a self-describing externally defined container data structures.","In a typical computer program, the architecture of the in-memory data representation is provided within the binary code (or bytecode) which a compiler produces by compiling the program's source code. Modern programs are almost all written in a high level programming language. A variety of languages exist, and allow programmers to write code a in human-friendly syntax. Examples of programming languages are C\/C++, PASCAL, FORTRAN, ADA etc. A high level language essentially provides an easy to read and write syntax for describing computing operations. Furthermore, some high level languages (e.g. C++ and JAVA) may implement object oriented concepts such as the concept of objects itself, the concept of inheritance etc. Object oriented concepts allow programmers to design better data storage architectures, and implement code that is easy to manipulate and reuse.","Every high-level based source code has to be compiled with a compiler. A compiler analyzes the source code and generates executable code that computers are able to execute. However, not every high-level programming language is destined to be executed directly by a machine. For example, the JAVA programming language may be compiled into bytecode that is then run by a JAVA virtual machine, which is a computer program capable of translation bytecode into machine specific execution instructions. Other high-level programming languages are designed to be interpreted at run time. For example, the PERL and SHELL provide scripting languages. The programs are interpreted at run time by an interpreter.","Whether a programming language is destined to be compiled, translated or interpreted, the steps for declaring data architecture and creating associating computing operations with the data almost always follows the same path: the programmer inputs all the definitions of the data and the association with operations in the source code, and the high-level instructions are translated into computer executable instructions. For example, a variable may be declared with a name and a type in the source. The compiler reads the variable declaration in the source code and generates executable code that reserves a memory space of a predetermined size, and executable code for generating the memory location address. The size of the memory allocated during execution, is determined by one or both of two factors. First, the programming language may have a standard definition of the basic data types, and second the data size may depend on the hardware architecture of each platform. Hence, integers that may be represented by sixteen (16) bits (two bytes) on one hardware platform and by thirty two (32) bits (four bytes) on a different hardware architecture.","Data declarations in computer programs typically define variable names their type and sometimes their positions in relation to each other. Several concepts are implemented in existing high-level programming languages. At the basic level, a data structure may consist of a simple variable (e.g. an integer) implemented through a name and a size, or through a complex description of data entities. Examples of higher-level data descriptions include arrays, data structures and objects. Arrays are ensembles of equally sized memory spaces represented in the computer memory by a contiguous space of memory where each location can be addressed individually or using an offset from the beginning of the array using one or multiple dimensions schemes. Complex data structures contain data of different sizes, each of which may be addressed using an offset from the beginning of the data structure using pointers. Objects typically include data declarations and code for manipulating the data.","In existing programming schemes, a computer application must always include the definition declarations of the data in the source code in order to be included in the binary code. The obvious shortcoming of this approach is that the architecture of data structures may not be changed in the executable code. If a change is to be applied to the structure of the data, the source code has to be modified, and compiled de novo to generate executable code capable of representing the data.","Therefore, there is a need for a method that allows data manipulation in computer programs without involving the process of generating the executable code.","Embodiments of the invention provide a framework enabling computer programs to utilize externally-defined self-describing container data structures. Externally-defined container data structures enable applications embodying the invention to load descriptions from files external to the application, utilize the descriptions to build an in-memory representation of data structures, and provide a mechanism to communicate with the in-memory data structures (or portions thereof from one or more application processes.","Embodiments of the invention utilize the extensible markup language to provide external descriptions of container data structures. Container data structures provide descriptions of one or more data elements. Each data element is referenced by a name and one or more property descriptions. Properties are, in one or more embodiments of the invention, utilized to define attributes associated with the data element. Properties may define a valid set of values for a data element, a valid range of values, a type of data (e.g. Integer, string and other data types) and any other property required to define a data element.","In contrary to existing inventions where the data architecture is built into the application, the invention provides a framework for building applications that may not comprise the data structure descriptions, and load the data structures utilizing the container data structures. Embodiments of the invention, utilize an engine comprising a set of tools capable of communicating with applications that implement one or more application programming interfaces for using container data structures. The engine provides the capability of loading and parsing description files. The engine also provide access to the data structures following data access requests from applications (or components thereof), and provide a mechanism for notifying applications or components thereof of events involving data structures. The engine in embodiments of the invention provides access to the values, the properties and names of the data in the structures. The engine provides, in addition to accessing the data, the ability to restrict data structure manipulations. For example, access to the data in the structures may be allowed following access limits (or rules) defined in external files.","The invention discloses a method and apparatus for providing externally-defined container data structures. In the following description, numerous specific details are set forth to provide a more thorough description of embodiments of the invention. It will be apparent, however, to one skilled in the art, that the invention may be practiced without these specific details. In other instances, well known features have not been described in detail so as not to obscure the invention.","Throughout the following disclosure, the reference to a user is alternately used to refer to a person using a computer application and\/or to one or more automatic processes.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":"110"},"Embodiments of the invention implement a container data structure engine . The container data structure engine provides a set of tools that allow one or more applications  to create an in-memory representation of data . Embodiments of the invention also provide an application programming interface  which the application and the engine implement to provide the capability to load description files, create the in-memory representation of the data and handle the data input and output transactions.","The description files  contain a self-describing hierarchical data structure that provides information about properties for each data structure and each level of the hierarchy. Such a structure holds properties and descriptions of other structures. In embodiments of the invention a property is comprised of a name and value. Each structure and its subsidiary structures form a tree of structures. The tree contains a root structure which contains, directly or indirectly, all other structures in the tree. Thus, given only a reference to the root structure in such a tree, all other structures can be reached, and all properties contained in those structures can be found and their values inspected. In the present disclosure, the term \u201cschema\u201d is used to refer to the description of structures contents and relationships. The description may be defined in external data files.","In embodiments of the invention, the self-describing container data structures contain properties and other structures. Properties may be in the form of name\/value pairs, for example. Each property has a type that defines whether it is numeric, text or any other type defined in one or more standard definitions or custom built. Properties may describe a variety of attributes associated with the data. For example, properties may describe range limits of numerical values, maxima and minima or any other data property. Furthermore, every datum may have a fixed number of allowed values. Structures that are defined by a schema may have a fixed list of properties given in the schema.","In embodiments of the invention, the approach to building container data structures is extensible: new structure types and their relationships can be supported without changes to the interface or implementation. The interface allows all data structure manipulations, including construction and assignment provided in the schema.","In embodiments of the invention, the schema defines hierarchy constraints such as which structures may be allowed to be children of other which other structures, and the number of structures of a specified type in each sub-structure. For example, structures that contain other structures are built under the constraints defined in the schema.","Structure definitions comprise:\n\n","Property definitions comprised\n\n","Property names, values, and limits can be inspected at runtime. The Application Programming Interface  provides functions that allow the list of property names to be retrieved. For each property name, another function allows the value of the property to be retrieved. Each property may also be associated with one or more attributes defining the mechanisms for accessing the data in the structure at runtime. For example, the attributes may define how the engine is to handle broadcasting and\/or hiding the values of a given property.","Embodiments of the invention provide the capability to determine the child to parent relationships in hierarchical structures at runtime. One or more functions in the Application Programming Interface allow for building and inspecting hierarchical structures.","The descriptions of the container data structures and their hierarchical relationships are interpreted to create the in-memory representations of data structures that support applications embodying the invention.","Embodiments of the invention may utilize the Extensible Markup Language (XML) standard to build description files. In the following a brief description of a few aspects of the Extensible Markup Language is provided to guide the reader.","Extensible Markup Language (XML) is a human-readable, machine-understandable, general syntax for describing hierarchical data. XML is an open standard for describing data developed under the auspices by the World Wide Web Consortium (W3C). XML is a subset of the Standard Generalized Markup Language (SGML) defined in ISO standard 8879:1986. XML is a formal language that can be used to pass information about the component parts of a document from one computer system to another. XML is used to describe any logical text structure (e.g. form, book, database etc.). XML is based on the concept of documents composed of a series of entities. Each entity can contain one or more logical elements. Each of these elements can have certain attributes (properties) that describe the way in which it is to be processed. XML also provides a formal syntax for describing the relationships between the entities, elements and attributes that make up an XML document, such a syntax can be used to recognize component parts of each document.","XML differs from other markup languages in that it does not simply indicate where a change of appearance occurs, or where a new element starts. XML clearly identifies the boundaries of every part of a document, (e.g. whether a text block is new chapter, or a reference to another publication). XML uses custom tags enabling applications to define, transmit, validate and interpret data shared between applications and between organizations.","To allow a computer to check the structure of a document, users must provide it with a document type definition that declares each of the permitted entities, elements and attributes, and the relationships between them. By defining the role of each element of text in a formal model, known as a Document Type Definition (DTD), users of XML can check that each component of document occurs in a valid place within the interchanged data stream. An XML DTD allows computers to check, for example, that users do not accidentally enter a third-level heading without first having entered a second-level heading, something that cannot be checked using the HyperText Markup Language (HTML) previously used to code documents that form part of the World Wide Web (WWW) of documents accessible through the Internet. However, XML does not restrict users to using DTDs.","To use a set of markup tags that has been defined by a trade association or similar body, users need to know how the markup tags are delimited from normal text and in which order the various elements should be used. Systems that understand XML can provide users with lists of the elements that are valid at each point in the document, and will automatically add the required delimiters to the name to produce a markup tag. Where the data capture system does not understand XML, users can enter the XML tags manually for later validation. Elements and their attributes are entered between matched pairs of angle brackets (< . . . >) while entity references start with an ampersand and end with a semicolon (& . . . ;).","Because XML tag sets are based on the logical structure of the document they are somewhat easier to understand than physically based markup schemes of the type typically provided by word processors. As an example, a memorandum coded in XML might look as follows:",{"@attributes":{"id":"p-0034","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<memo>"]},{"entry":[{},"<to>All staff<\/to>"]},{"entry":[{},"<from>R. Michael<\/from>"]},{"entry":[{},"<date>April 1, 2001<\/date>"]},{"entry":[{},"<subject>Power Saving<\/subject>"]},{"entry":[{},"<text>Please turn off your desktops before you leave.<\/text>"]},{"entry":[{},"<\/memo>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As shown in the example above, the start and end of each logical element of the file has been clearly identified by entry of a start-tag (e.g. <to>) and an end-tag (e.g. <\/to>). This formatting is ideal for a computer to follow, and therefore for data processing.","To define tag sets users may create a Document Type Definition that formally identifies the relationships between the various elements that form their documents. For the simple memorandum example, the XML DTD might take the form:",{"@attributes":{"id":"p-0037","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<!DOCTYPE memo [",{}]},{"entry":[{},"<!ELEMENT memo","(to, from, date, subject?, para+) >"]},{"entry":[{},"<!ELEMENT para","(#PCDATA) >"]},{"entry":[{},"<!ELEMENT to","(#PCDATA) >"]},{"entry":[{},"<!ELEMENT from","(#PCDATA) >"]},{"entry":[{},"<!ELEMENT date","(#PCDATA) >"]},{"entry":[{},"<!ELEMENT subject","(#PCDATA) >"]},{"entry":[{},"]>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"This model indicates that a memorandum consists of a sequence of header elements, <to>, <from>, <date> and, optionally, <subject>, which must be followed by the contents of the memorandum. The content of the memo defined in this simple example is made up of a number of paragraphs, at least one of which must be present (this is indicated by the + immediately after para). In this simplified example a paragraph has been defined as a leaf node that can contain parsed character data (#PCDATA), i.e. data that has been checked to ensure that it contains no unrecognized markup strings.","XML-coded files are suitable for communicating data to be stored in databases. Because XML files are both object-orientated and hierarchical in nature they can be adapted to many types of databases. A standardized interface to XML data is defined through W3C's Document Object Model (DOM), which provides a Common Object Request Broker Architecture (CORBA) interface definition language (IDL) interface between applications exchanging XML data.","XML validation and well formedness can be checked using XML processors to which it is commonly referred as XML parsers. An XML processor parser checks whether an XML document is valid by checking that all components are present, and the document instance conforms to the rules defined in the DTD. An up-to-date version of the XML\/DTD is available on the World Wide Web Consortium web site URL<http:\/\/www.w3.org>.","The following XML code is provided with the following explanations are provided to illustrate a schema as utilized in embodiments of the invention.",{"@attributes":{"id":"p-0042","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?>"},{"entry":"<!ELEMENT Schema (SchemaType+, StructureTemplate*)>"},{"entry":"<!ATTLIST Schema name CDATA #REQUIRED"},{"entry":"windowed (true|false) \u201cfalse\u201d>"},{"entry":"<!ELEMENT SchemaType EMPTY>"},{"entry":"<!ATTLIST SchemaType name (Current|Persistent|"},{"entry":"Requested) \u201cPersistent\u201d>"},{"entry":"<!ELEMENT StructureTemplate (StructureName,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Description?,"]},{"entry":[{},"PrimaryKey,"]},{"entry":[{},"Property*,"]},{"entry":[{},"Relation*,"]},{"entry":[{},"StructureRef*,"]},{"entry":[{},"StructureTemplate*)>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<!ATTLIST StructureTemplate parentRelationType CDATA \u201cNULL\u201d"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"command (true|false) \u201cfalse\u201d"]},{"entry":[{},"buckets\u2003\u2003CDATA \u2003\u2003\u201c1\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<!ELEMENT StructureName (#PCDATA)>"},{"entry":"<!ATTLIST StructureName schemaName CDATA #IMPLIED>"},{"entry":"<!ELEMENT SchemaName (#PCDATA)>"},{"entry":"<!ELEMENT PrimaryKey (Property)>"},{"entry":"<!ELEMENT Relation (ForeignKey | ForeignKeyTemplate)+ >"},{"entry":"<!ATTLIST Relation name\u2003\u2003CDATA"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#REQUIRED"]},{"entry":[{},"cardinality (one-to-one|"]},{"entry":[{},"many-to-one|zero-one-to-one|"]},{"entry":[{},"zero-many-to-one) \u201cone-to-one\u201d"]},{"entry":[{},"direction \u2003(up|down)"]},{"entry":[{},"\u201cup\u201d"]},{"entry":[{},"maximum\u2003CDATA"]},{"entry":[{},"#IMPLIED"]},{"entry":[{},"defaultChildCount \u2003\u2003CDATA \u2003\u2003\u201c0\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<!ELEMENT StructureRef (StructureName)>"},{"entry":"<!ELEMENT ForeignKey (StructureName)>"},{"entry":"<!ELEMENT ForeignKeyTemplate (StructureNameTemplate)>"},{"entry":"<!ATTLIST ForeignKeyTemplate relationType\u2002CDATA #REQUIRED>"},{"entry":"<!ELEMENT StructureNameTemplate EMPTY >"},{"entry":"<!ATTLIST StructureNameTemplate name\u2003CDATA\u2003#IMPLIED>"},{"entry":"<!ELEMENT PropertyTemplate EMPTY >"},{"entry":"<!ATTLIST PropertyTemplate\u2003name \u2003\u2003CDATA \u2003#IMPLIED"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type \u2003\u2003\u2003CDATA \u2003\u2003#IMPLIED"]},{"entry":[{},"count \u2003\u2003\u2003CDATA \u2003\u2003#IMPLIED"]},{"entry":[{},"visible\u2003\u2003\u2003CDATA \u2003\u2003#IMPLIED>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<!ELEMENT Property (Description?,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EnumeratedValue*,"]},{"entry":[{},"MinValue?,"]},{"entry":[{},"MaxValue?,"]},{"entry":[{},"ForcedValue?,"]},{"entry":[{},"DefaultValue?)>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<!ATTLIST Property name\u2003\u2003\u2003CDATA \u2003\u2003#REQUIRED"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type\u2003\u2003\u2003CDATA \u2003\u2003#REQUIRED"]},{"entry":[{},"count\u2003\u2003\u2003CDATA\u2003\u2003\u201c1\u201d"]},{"entry":[{},"visible \u2003\u2003\u2003(true|false) \u2003\u201ctrue\u201d"]},{"entry":[{},"sortable \u2003\u2003\u2003(true|false) \u2003\u201cfalse\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<!ELEMENT DefaultValue (#PCDATA)>"},{"entry":"<!ELEMENT MinValue (#PCDATA)>"},{"entry":"<!ELEMENT MaxValue (#PCDATA)>"},{"entry":"<!ELEMENT EnumeratedValue (#PCDATA)>"},{"entry":"<!ELEMENT ForcedValue (#PCDATA)>"},{"entry":"<!-- end of $Workfile: Schema.dtd $ -->"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":[{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["The root element for a schema description file that defines the structural representation for native application. Every schema description XML file that specifies this file as the DTD must have the Schema element as the root element.\n\nContents:\n","StructureTemplate Defines the organizational StructureTemplate of the schema description. The schema will contain zero or more of these StructureTemplates.\n\nAttributes:\n","name: The name of this schema. It is used to distinguish the tables of this schema from those in another schema.\n\nSchemaType\n","Defines the variation of schema, which translates to the prefix of the table names for each StructureTemplate within the schema. The SchemaType has a name attribute which is enumerated with allowable values of Current, Persistent or Requested.\n\nContents:\n","none.\n\nAttributes:\n","name The name of this schema type. Allowable values are Current, Persistent or Requested\n\nStructureTemplate\n","Defines a collection of related properties. This is used to specify the format of a table in the relational database.\n\nContents:\n","StructureName The name of the SchemaStructure. It is used as the table name in the database.","PrimaryKey Uniquely identifies each row in a relational database table.","Property Defines an individual column in the table. There may be zero or more of these elements.","Relation A mapping between the SchemaStructure where it is defined and another SchemaStructure. There may be zero or more of these elements.","StructureRef a link to a sub-structure that may appear inside the StructureTemplate element where it is defined. this allows duplicate definitions to be avoided in a schema definition.","StructureTemplate Sub-StructureTemplates that may appear inside the StructureTemplate element where it is defined.\n\nAttributes:\n","parentRelationType Type of base StructureTemplate of which this StructureTemplate is a derived version.\n\nStructureName\n","The name of a StructureTemplate. The value is specified using parsed character data.","The Optional schemaName attribute, when defined, identifies the schema in which the corresponding StructureTemplate, identified by StructureName, is defined.\n\nSchemaName\n","The name of the schema in which the StructureTemplate in the ForeignKey is defined. The value is specified using parsed character data.\n\nPrimaryKey\n","A unique identifier for a given instance of an object\/row in a database table.\n\nContents:\n","Property The actual value that is used as the unique identifier for the object\/row in the database table. There are one or more of them in the primary key. Each one will result in a column in the database.\n\nRelation\n","Defines how two tables, usually different, are associated.\n\nContents:\n","ForeignKey Refers to an instance of an object in a, usually different, table.","ForeignKeyTemplate A description of the format that a foreign key must follow.\n\nAttributes:\n","name The name of this relation. It is used as the column name in the database table. cardinality Specifies how many instances of the object in which the relation is specified are related to a given instance of the objects specified in the relation. There are four allowed values: one-to-one, zero-one-to-one, many-to-one and zero-many-to-one. Cardinality of one-to-one means that only one instance of the StructureTemplate in which the relation is specified is related to a given instance of the StructureTemplate identified by the relation, and the relation must occur. Cardinality of many-to-one means that one or more instance of the StructureTemplate in which the relation is specified is related to a given instance of the StructureTemplate, and the relation must occur. The \u2018zero-\u2019 variations of cardinality specify that the relation is optional. Thus, when the foreign keys are mapped into columns in the database table, the \u2018zero-\u2019 variations will allow NULL values in the columns, but the one-to-one and many-to-one will not allow NULL values."]}},"direction Direction can have values of \u2018up\u2019 or \u2018down\u2019. Down indicates that the relation points from the Structure to a sub-Structure. Up indicates from sub-Structure to its parent Structure.","maximum If cardinality is many-to-one or zero-many-to-one, this specifies the maximum number of instances in the \u2018many\u2019 side of the relation that can be related to a given instance of the \u2018one\u2019 side of the relation. Optional.\n\nStructureRef\n    \n    "]}},{"@attributes":{"id":"p-0043","num":"0103"},"figref":"FIG. 2","b":["210","150","130"]},"At step , the application requests access to the data. The request may be issued following the application process of loading external data, or creating in-memory representation of data structure for further use. The application may issue a request to access data structures following a user's input to create one or more data objects. In embodiments of the invention, the application may have one or more separate processes running simultaneously.","In embodiments of the invention, each component of the application issuing a request to access data, also provides a handle (e.g. an identifier or an address to the component) that may be utilized by the engine's components to communicate back to the application's components. For example, an application component may access a data structure and needs to be notified if and when the data has been modified (e.g. by a different component). The application component passes to the engine a handle that enables the engine to call a specific procedure in the application component. In the framework of object oriented programming, the component may implement a listener and the handle to the listener is passed to the engine broadcast component to notify the listener when and if a datum is modified.","At step , the engine loads the container data structure description files. The latter step involves loading one or more description files, parsing the description, conducting several syntactic and logical checks, and translating one or more container data structures into one or more in-memory representations of data structures. At step , the engine creates the in-memory representation of one or more data structures. The memory is allocated to each structure based on the properties and hierarchical descriptions. At step , the engine provides application components access to the data structures by returning the output of specialized functions for handling input and output to each of the properties.",{"@attributes":{"id":"p-0047","num":"0107"},"figref":"FIG. 3","b":["310","320","330","340","350","360"]},"Thus, a method and apparatus for implementing container data structures that provide a self-describing externally define mechanism for creating and handling data structures."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
