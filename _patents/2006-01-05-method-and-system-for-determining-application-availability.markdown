---
title: Method and system for determining application availability
abstract: A method and system for determining an availability of an application. Pairs of processes utilized by the application are determined. Each pair includes consumer and provider processes. For each pair, a diagnostic transaction is initiated by the pair's consumer process, utilizes an application programming interface (API) to open a connection between the consumer process and provider process and to request access to a resource managed by the provider process. Any communication between a pair's consumer and provider processes uses the same API. The diagnostic transaction is completed by receiving or not receiving, at the consumer process, a response from the pair's provider process where the response provides the requested access. Receipt of the response designates the provider process as available to the application, whereas non-receipt of the response designates the provider process as unavailable. If responses are received for all diagnostic transactions, the application is available.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07587453&OS=07587453&RS=07587453
owner: International Business Machines Corporation
number: 07587453
owner_city: Armonk
owner_country: US
publication_date: 20060105
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Technical Field","The present invention relates to a method and system for determining the availability of applications, and in particular to a technique for determining the availability of applications in a multi-tier environment having redundant clusters of servers within each tier, and for isolating faults to the software processes impacting availability.","2. Related Art","Two conventional techniques exist to solve the problem of identifying, in complex applications running over a number of nodes or tiers and involving redundant clusters of nodes within the same tier, that a failure has occurred, the software process or hardware device responsible for the failure, and the application transactions impacted by the failure.","The first conventional technique involves component monitors that monitor software processes or hardware devices at an individual component level. For example, commercial component monitors are available for WebSphere\u00ae Application Server (WAS) (e.g., Introscope\u00ae and Tivoli\u00ae Monitoring for Web Infrastructure), and WebSphere\u00ae MQSeries\u00ae (MQ) (e.g., Tivoli\u00ae Monitoring for Business Integration and Omegamon\u00ae for MQ). WAS, WebSphere\u00ae MQSeries\u00ae, Tivoli\u00ae Monitoring for Business Integration, and Omegamon\u00ae for MQ are available from International Business Machines Corporation of Armonk, N.Y. Introscope\u00ae is available from Wily Technology, Inc. of Brisbane, Calif. In cases such as a UNIX server running on the Lightweight Directory Access Protocol (LDAP), customized component monitors are developed. Component monitors provide performance information about software components and detect some classes of software errors; however, when a software hang occurs, these monitors provide a \u201cfalse positive\u201d (i.e., the application is not available, but a failure is not detected). Further, component monitors provide inadequate or no information regarding which application transactions are impacted as a result of a failure.","The second conventional technique involves executing a series of synthetic transactions against a real production system to see whether the transactions produce a response that corresponds to a valid known state. This synthetic transaction technique suffers from a number of problems. First, synthetic transactions are not appropriate for all business applications (e.g., updating a bank balance). Second, once a failure is detected by the synthetic transaction technique, it is not easy to determine which node or software process is responsible for the failure. Third, when load balancing technologies direct transactions, it is difficult for the synthetic transaction technique to direct synthetic transactions to specific nodes to provide complete coverage of an infrastructure. Fourth, every distinct application architecture needs to have a synthetic transaction defined for it. Finally, because of all of the above, running synthetic transactions creates a substantial load.","Thus, there exists a need in the art to overcome the deficiencies and limitations described above.","In first embodiments, the present invention provides a method of determining an availability of an application in a computing environment, comprising:","determining a plurality of pairs of processes utilized by the application, wherein each pair includes a first process designated as a consumer process and a second process designated as a provider process, wherein the consumer process accesses a resource provided by the provider process;","initiating, by one process (CP) designated as the consumer process and included in a pair of the plurality of pairs, a diagnostic transaction between the CP and another process (PP) designated as the provider process and included in the pair,","wherein the diagnostic transaction utilizes an application programming interface (API) of a plurality of APIs to open a connection between the CP and the PP and to request an access to a resource managed by the PP, the API utilized by the CP and the PP to perform any communication therebetween;","completing the diagnostic transaction via receiving, at the CP, a response from the PP providing the access, or via not receiving the response at the CP;","designating the PP as available to the application in response to the completing via the receiving the response, or as unavailable to the application in response to the completing via the not receiving the response;","repeating the initiating, the completing, and the designating until each pair of the plurality of pairs is utilized by the initiating, the completing, and the designating; and","determining an availability of the application based on no process of the plurality of pairs being designated unavailable via the designating.","In second embodiments, the present invention provides a system for determining an availability of an application in a computing environment, comprising:","means for determining a plurality of pairs of processes utilized by the application, wherein each pair includes a first process designated as a consumer process and a second process designated as a provider process, wherein the consumer process accesses a resource provided by the provider process;","means for initiating, by one process (CP) designated as the consumer process and included in a pair of the plurality of pairs, a diagnostic transaction between the CP and another process (PP) designated as the provider process and included in the pair,","wherein the diagnostic transaction utilizes an application programming interface (API) of a plurality of APIs to open a connection between the CP and the PP and to request an access to a resource managed by the PP, the API utilized by the CP and the PP to perform any communication therebetween;","means for completing the diagnostic transaction via receiving, at the CP, a response from the PP providing the access, or via not receiving the response at the CP;","means for designating the PP as available to the application in response to the completing via the receiving the response, or as unavailable to the application in response to the completing via the not receiving the response;","means for repeating the initiating, the completing, and the designating until each pair of the plurality of pairs is utilized by the initiating, the completing, and the designating; and","means for determining an availability of the application based on no process of the plurality of pairs being designated unavailable via the designating.","In third embodiments, the present invention provides a computer program product comprising a computer-usable medium including computer-usable program code for determining an availability of an application in a computing environment, the computer program product including:","computer-usable code for determining a plurality of pairs of processes utilized by the application, wherein each pair includes a first process designated as a consumer process and a second process designated as a provider process, wherein the consumer process accesses a resource provided by the provider process;","computer-usable code for initiating, by one process (CP) designated as the consumer process and included in a pair of the plurality of pairs, a diagnostic transaction between the CP and another process (PP) designated as the provider process and included in the pair,","wherein the diagnostic transaction utilizes an application programming interface (API) of a plurality of APIs to open a connection between the CP and the PP and to request an access to a resource managed by the PP, the API utilized by the CP and the PP to perform any communication therebetween;","computer-usable code for completing the diagnostic transaction via receiving, at the CP, a response from the PP providing the access, or via not receiving the response at the CP;","computer-usable code for designating the PP as available to the application in response to the completing via the receiving the response, or as unavailable to the application in response to the completing via the not receiving the response;","computer-usable code for repeating the initiating, the completing, and the designating until each pair of the plurality of pairs is utilized by the initiating, the completing, and the designating; and","computer-usable code for determining an availability of the application based on no process of the plurality of pairs being designated unavailable via the designating.","In fourth embodiments, the present invention provides a method for deploying computing infrastructure, comprising integrating computer-readable code into a computing system, wherein the code in combination with the computing system is capable of performing a process of determining an availability of an application in a computing environment, the process comprising:","determining a plurality of pairs of processes utilized by the application, wherein each pair includes a first process designated as a consumer process and a second process designated as a provider process, wherein the consumer process accesses a resource provided by the provider process;","initiating, by one process (CP) designated as the consumer process and included in a pair of the plurality of pairs, a diagnostic transaction between the CP and another process (PP) designated as the provider process and included in the pair,","wherein the diagnostic transaction utilizes an application programming interface (API) of a plurality of APIs to open a connection between the CP and the PP and to request an access to a resource managed by the PP, the API utilized by the CP and the PP to perform any communication therebetween;","completing the diagnostic transaction via receiving, at the CP, a response from the PP providing the access, or via not receiving the response at the CP;","designating the PP as available to the application in response to the completing via the receiving the response, or as unavailable to the application in response to the completing via the not receiving the response;","repeating the initiating, the completing, and the designating until each pair of the plurality of pairs is utilized by the initiating, the completing, and the designating; and","determining an availability of the application based on no process of the plurality of pairs being designated unavailable via the designating.","Advantageously, the availability determination technique described herein provides an accurate and reliable diagnostic test to determine the availability of a software process utilized by an application. Further, the present invention provides a general technique for accurately and automatically diagnosing end-to-end availability of any customer-defined application transaction while avoiding indications of false positives. Since the technique described herein is lightweight, it can be executed more frequently than conventional synthetic transaction schemes. Still further, the present invention is capable of automatically isolating an application's failure to an individual software process. Yet further, the diagnostic tests described herein can be directed to specific nodes, even if the computing environment employs redundancy.","The present invention provides an automated approach to diagnosing the availability of applications by detecting that an application failure has occurred, and detecting an individual process utilized by one or more applications that is responsible for the failure. Further, the technique disclosed herein identifies applications that are impacted by a failed process, and re-routes workload away from the failed process in operational environments where alternate paths are available. The aforementioned functions are a pre-requisite to an autonomic (i.e., self-healing) approach for recovering from application failure.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 1A","b":["100","100","102","104","106","108","102","110","104"]},"Process  communicates with process , which resides in server . Process  also communicates with process , which resides in server . Further, process  communicates with process  residing in server . Processes , , , , and  are components of the application whose architecture is depicted in .","Communications between processes in  include, for example, one process (i.e., a consumer process) requesting access to one or more resources managed by another process (i.e., a provider process). When multiple processes exist in one server (e.g., processes ,  in server ), a multitasking operating system (not shown) provides the appearance of simultaneous execution of the processes by switching between their executions on a central processing unit (not shown).","Each of the processes of  includes one or more components. For example, process  includes driver component , which communicates with test component  residing in process . Driver component  initiates a diagnostic transaction that tests the connection between process  and process , thereby determining the availability of process , and facilitating determining whether a failure has occurred in the application being monitored. The diagnostic transaction is described in more detail below (see, e.g., ).","Driver component  is instantiated by a sensor , and returns the result of the diagnostic transaction to sensor . Sensor  is instantiated by an autonomic manager , and returns the result of the diagnostic transaction to autonomic manager . Autonomic manager resides on a management server (not shown). Autonomic manager  provides functions that facilitate the ability of computing system  to automatically identify a failure related to a process or server, and automatically take actions (a.k.a. self-healing actions) in response to the failure to maintain effective functioning of the system. Examples of functions performed by autonomic manager  include: (1) maintaining a topology of each application being monitored for availability; (2) maintaining a consolidated view of the set of connections between processes that need to be monitored; (3) analyzing the impact of a process or server failure on the availability of an application; (4) preventing additional workload from being sent to a failed process or server; and (5) initiating recovery and restart actions in response to a process or server failure.","The management server that includes autonomic manager  may be configured to be highly available, and therefore may be capable of running on clustered servers (not shown), and be capable of running across multiple data centers. Such a clustered configuration is typically part of, or feeds events into, an organization's central management console. Further, the clustered server configuration is enhanced so that each of the servers in the cluster monitors the other servers in the cluster to ensure that the autonomic manager instances do not fail. A central management console is, for example, Tivoli Enterprise Console, which is available from International Business Machines Corporation.","Although not shown in , driver components and test components are included in other pairs of processes so that the connection between the processes of each pair can be tested. For example, a driver component (not shown) in process  and a test component (not shown) in process  utilize a diagnostic transaction to test the connection between processes  and . Further, server  and server  each include a sensor (not shown) that communicates with each server's respective one or more driver components. Like sensor , the sensors in server  and  communicate with autonomic manager . Although not shown, each sensor, including sensor , communicates with the one or more test components residing in the server that includes the sensor (e.g., to instantiate the test components).","The present invention contemplates other configurations of servers in system . For instance, one or more servers of types already in system  and\/or of types not represented in  can be added to system  (e.g., system  can include multiple application servers). Further, any server in  can be replaced with another type of server. Still further, system  is not limited to servers, and may include one or more nodes that are servers and\/or one or more nodes that are non-server devices. Non-server devices include, for example, firewalls, load-balancing switches (i.e., application content switches), cryptographic coprocessors, intrusion detection appliances, and web caching devices. As used herein, a node is defined as a physical device attached to a network or another device (e.g., a cryptographic coprocessor is attached to a server PCI bus, and is therefore not directly network accessible). If system  includes non-server devices, a diagnostic transaction can test the connection between non-server devices or between a server and a non-server device, using the techniques described below.","System  can be extended to include architectures of multiple applications, whose processes reside on the nodes of system . The availability technique described below can determine which of the multiple applications are impacted by a failure of a process. Moreover, an application included in system  may be a single or multi-tiered application, and redundancy of one or more nodes may be built into system .",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 1B","FIG. 1A"],"b":"150"},"Process pair  includes consumer process P and provider process P. Process  requests resources from process  via API or application level protocol I. Hereinafter, it is to be understood that a reference to an API refers to an API or an application level protocol. Consumer process  includes a driver component , and provider process  includes a test component . A first set  of other application components is included in consumer process  and a second set  of other application components is included in provider process . First set  includes components C, C, . . . , C, which correspond in a one-to-one manner with components C, C, . . . , C, which are included in second set . Each component of first set  accesses services of its corresponding component in second set  via I. Driver component  is an infrastructure component embedded in process  that is used to drive the connection between Pand Pusing I. Driving a connection between processes is discussed below relative to .",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 2","FIG. 1A","FIG. 1A"],"b":["200","202","100","202"],"sub":["1 ","n","1 ","n ","1 ","n"]},"An application topology can be represented as a set of triplets {P, I, P}, where Pis a consumer process included in the processes P. . . P, Pis a provider process included in the processes P. . . P, Iis the API utilized in any communication between Pand P, 1\u2266i, j\u2266n, and i\u2260j. The subscript in Iis unbounded because a theoretically infinite number of APIs can be in use between Pand P. For practical purposes, an environment may have hundreds to thousands of APIs in use. If it is assumed that (1) each process pair has only one API in use between the processes of the pair (which is usually the case), and (2) there are no loops (i.e., i<j for all i and j), then the maximum number of APIs is (n\u22121)*n\/2.","The set of triplets {P, I, P} can be converted into a directed graph where Pand Prepresent vertices of the directed graph and the Ivalues represent the edges of the graph.","As one example, application topology information determined in step  is collected by an Application Response Measurement (ARM) API. ARM is a standard provided by The Open Group of Reading, United Kingdom. The ARM API is implemented by products such as Tivoli Monitoring for Transaction Performance (TMTP) and Enterprise Workload Manager (EWLM), which are available from International Business Machines Corporation. In the case of EWLM, the ARM API is implemented in underlying middleware products such as HTTP Server, WebSphere\u00ae Application Server, DB2\u00ae, and MQSeries\u00ae, which are available from International Business Machines Corporation.","System  (see ) can be included in a distributed computing environment. In this case, a calling hierarchy is also determined in step  by, for example, the ARM API. A calling hierarchy of an application is a sequence in which methods are invoked by the application. In one example, a calling hierarchy is restricted to operationally significant methods, which are methods that invoke APIs involving external processes. For instance, in a Java\u00ae environment running under WebSphere\u00ae Application Server (WAS), the calling hierarchy would include calls to an MQSeries\u00ae process external to WAS, wherein the calls utilize a Java\u00ae Message Service (JMS) API. WAS is software that manages e-business applications, and MQSeries\u00ae is software that provides message queuing services.","The ARM API builds the calling hierarchy by the use of correlators. Each method call passes a parent correlator to the application. The application also receives a child correlator in a response to the method call. A call tree generated using the parent and child correlators includes the calling hierarchy and the timing of the method calls.","As one example, an ARM Management Agent (not shown) residing in server  (see ) passes ARM information, including correlators, to sensor  (see ). Sensor  (see ) sends \u201cfirst of a kind\u201d (FOAK) application configurations to autonomic manager  (see ). A FOAK configuration is an application topology that is being detected by a sensor for the first time. A sensor can identify a configuration as a FOAK configuration by comparing the configuration to the sensor's maintained knowledge of the topology of applications relative to the node on which the sensor resides. FOAK configurations include: (1) an application that is newly detected by a sensor because a node is newly added to an existing cluster, or because the application is newly identified by the present invention as an application to be monitored; and (2) a process or a communication with an existing process that is newly added to an application.","Sending only FOAK configurations from the sensors to the autonomic manager ensures that massive amounts of data are not transmitted to the autonomic manager as a result of every transaction that reports its topology. Further, the automatic identification and transmission of FOAK configurations advantageously avoids the need for error-prone manually defined application topologies.","If inquiry step  determines that an additional one or more other applications included in system  are to be monitored for availability, and have topologies that have not yet been determined by step , then the process repeats starting at step  to determine the topology of one of the additional applications. If step  determines that no applications remain to be processed by step , then the application availability process continues with step .","Although not shown on , steps ,  and  are performed on a continual basis in parallel with polling activities, which are described in subsequent steps starting at step . In other words, a FOAK topology can be detected at any time during the process of , and in response to that detection, the FOAK topology is propagated to autonomic manager  (see ), which re-executes steps ,  and .","In step , the one or more application topologies determined in step , or the directed graphs representing the application topologies, are each converted to an adjacency matrix that includes rows and columns corresponding to the provider processes and consumer processes, respectively. A value of a first pre-defined set of values (e.g., a non-zero value) appears in an adjacency matrix at row i and column j to indicate a particular API that is used in a communication between the j-th consumer process and the i-th provider process. Hereinafter, a value of the first pre-defined set is referred to as a non-zero value. A value of a second pre-defined set of values (e.g., a zero value) in the adjacency matrix indicates that no communication is occurring between the consumer process and provider process indicated by the column and row associated with the value. Hereinafter, a value in the second pre-defined set is referred to as a zero value.","Step  also forms a union of all the adjacency matrices generated from the application topologies of step . The non-zero values of the union of the adjacency matrices indicate the set of processes that are to be monitored. Adjacency matrices are described below relative to , and a union of adjacency matrices is depicted in .","Periodic polling of connections between processes is initialized and periodic polling begins in step . Autonomic manager  (see ) instantiates sensors (e.g., sensor  of ) residing in nodes of system  (see ) (e.g., servers , ,  of FIG. A), and notifies each sensor of the APIs to be utilized for the monitoring of the node on which the sensor resides. Each sensor instantiates one or more driver components (e.g., driver component  of ) and one or more test components (e.g., test component  of ), which reside in the node on which the sensor resides.","Each driver component (e.g., driver component  of ) of a consumer process initiates a diagnostic transaction that utilizes a distinct API of the plurality of APIs to test a connection between the consumer process and a provider process invoked by the consumer process. As used herein, testing a connection between a consumer process and a provider process is equivalent to testing the availability of the provider process. The test of the connection includes (1) opening a connection between the consumer process and the provider process, and (2) requesting access to one or more resources managed by the provider process. The aforementioned actions (1) and (2) utilize the same API that an application being monitored uses for any of the application's transactions between the consumer process and the provider process.","The diagnostic transaction is directed to a test component (e.g., test component  of ) included in the provider process. The test component includes all the resources necessary to execute the code from the driver component, and provide a response. If the provider process is available, the test component's response to the driver component provides the requested access to the one or more resources, and validates the functionality of the provider process. If the provider process is unavailable, the driver component receives no response from the test component.","In certain aspects, a diagnostic transaction mimics other, non-diagnostic transactions of an application being monitored, which allows the present invention to monitor any arbitrary customer-defined transaction while avoiding the costly setup of synthetic transactions. Differences, however, do exist between diagnostic and non-diagnostic transactions. Diagnostic transaction functionality that is not shared by non-diagnostic transactions include (a) detecting a failure isolated to particular software process and reporting that failure to the aforementioned sensor and autonomic manager, which analyze the failure and initiate corrective action(s); (b) distinguishing an unavailable process from other factors that may cause a failed transaction (e.g., faulty application code, user error, etc.); (c) ascertaining, while coupled with correlation of events over time or from other client processes, whether there is an application failure or not; and (d) isolating failure to a single process without initially determining whether the failure is caused by faulty business logic. Function (d) is a distinguishing feature of diagnostic transactions because business logic is absent from diagnostic transactions and present in non-diagnostic transactions.","The availability of any arbitrary customer-defined application transaction can be determined by executing a diagnostic transaction for each of the connections utilized by the application. Moreover, to test the availability of multiple applications, the process of  executes a single diagnostic transaction for each communication connection between processes of every process pair. For example, if application X utilizes the connection between process P and process P via API I, and application Y utilizes the same P to P connection via API I, the P to P connection needs to be tested with a diagnostic transaction only once to facilitate determining the availability of both applications X and Y.","The following pseudo-code is an example of an initiation of a diagnostic transaction by a consumer process. The diagnostic transaction tests the establishment of a connection between the consumer process and a relational database via the JDBC\u00ae API.",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"DataSource = Context.getDataSource (\u201cMyDataSource\u201d);"},{"entry":"\/\/ Locate database"},{"entry":"SQLConnection = DataSource.getConnection (username, password);"},{"entry":"\/\/ Establish connection to database"},{"entry":"Is (SQLConnection.aValidConnection( )) {"},{"entry":"\/\/ Validate that a JDBC\u2009\u00ae connection can be established to the database"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ DB2\u2009\u00ae in the provider process is UP"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"} else {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ DB2\u2009\u00ae in the provider process is DOWN"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In one embodiment, a driver component of a consumer process being monitored includes (1) a driver manager that returns results from the connection tests of step  to a sensor residing in the same node that includes the consumer process, and (2) one or more driver routines, one routine for each of the distinct APIs associated with the connections to be tested. Further, a test component included in a provider process being monitored includes (1) the resources necessary to validate the functionality of the provider process, and (2) a test manager that initializes the resources, and which is in communication with a sensor residing in the same node that includes the provider process.","The test component contents vary according to the particular provider process on which it resides. For example, if the provider process is a relational database process (e.g., DB2\u00ae), the test component may contain tables, stored procedures, or other database objects. As another example, if the provider process is a message queue (e.g., WebSphere\u00ae MQ, which is available from International Business Machines Corporation), the test component may contain queue managers, queues, and transmission agents.","After the test of a connection (e.g., the connection between driver component  and test component  of ), the driver component reports the result of the test (i.e., whether the connection is available) to the associated sensor (e.g., sensor  of ). As used herein, the availability of the connection is equivalent to the availability of the provider process that includes the test component utilized by the test. The sensor returns the test result to autonomic manager  (see ). Each time a connection is tested, a status adjacency matrix is updated to indicate that a connection is available or unavailable based on the test.","The testing of a connection described herein is also known as driving the connection or pinging the connection at an application level. Being a ping at an application level, the test for availability described herein involves monitoring a provider process by invoking the public methods of the provider process (i.e., the API utilized in communications with the provider process), to verify that the provider process is functioning in the manner expected by the consumer of its services (i.e., the consumer process). The connection between the consumer and provider processes in an application level ping does not require a network (e.g., the consumer and provider process pair being monitored can be located on the same server).","It should be noted that an application level ping differs from a network level ping (e.g., Internet Control Message Protocol (ICMP)). The provider process associated with a network level ping must be capable of supporting TCP\/IP and must be listening on a nominated TCP\/IP port. An application level ping does not have these restrictions, and thus is capable of detecting faults on any process running on a node, rather than only processes that are listening on TCP\/IP ports.","Inquiry step  determines if a process has experienced a failure based on the availability diagnosis of step . If all processes utilized by applications are functioning properly (i.e., are available) based on the connection tests of step , then no failure of an application is detected by autonomic manager  (see ), and the process repeats the polling of connections at step . If one or more tests of connections determine that one or more processes are unavailable to their respective application(s), then a failure affecting one or more applications is determined by autonomic manager  (see ), and the process continues with step .","Step  determines the one or more applications impacted by the failure identified in step . The union of adjacency matrices formed in step  is compared to the one or more processes identified as failed processes in step  to determine which applications need to utilize the failed process(es). The one or more applications that need to utilize the failed process(es) are identified as the application(s) impacted by the identified failure(s). The determination of the impacted applications is performed by autonomic manager  (see ).","Step  determines if the applications determined in step  are available. The step  determination of availability is equivalent to a determination of availability of an information technology (IT) service. An IT service is an application whose availability is determined by the performance standards of an end user, without regard to the number of tiers used by the application, or the amount of redundancy employed. An IT service includes computer programs distributed across multiple systems, processes and threads. The process of the present invention determines that an application is available only if an end user's performance standards also determine that the corresponding IT service is available. An application is available if step  detected no failures in the processes utilized by the application.","If step  determines that the applications determined by step  are available, then the process repeats starting at step  (i.e., periodic polling continues). Otherwise, corrective action is taken in step  to address the unavailability of the application(s). If one or more applications are unavailable, step  can, for example, take a failed server offline, prevent work associated with an application being monitored from being sent to a failed process, start a new software process to provide a workaround for the failed process, provision a new server to run the failed server or failed process, or restart a failed process if the failure is determined to be transient (i.e., restartable).","Step  can also respond to unavailability determined in step  by re-routing workload associated with the impacted application(s) determined in step  away from the one or more processes identified as failed processes in step . The re-routing decisions are automatically made by autonomic manager  (see ), and are implemented by mechanisms (e.g., effectors) residing on nodes of system  (see ). For example, if redundancy were built into system  of  so that a clone of application server  was part of the system, an effector residing on reverse proxy server  (see ) is notified about the transactions that use a failed process of application server  (see ). The effector modifies software on server  (see ) to direct all HTTP requests requiring the failed process to the clone (not shown in ) of application server . Re-routing workload away from the failed process prevents additional transactions from failing.","Furthermore, performance modeling can determine if one or more applications are unavailable due to insufficient capacity in system  (see ). In this case, step  can, for instance, add servers to the system to increase capacity.","First Application Example",{"@attributes":{"id":"p-0099","num":"0098"},"figref":["FIG. 3A","FIG. 1A"],"b":["300","302","304","306","302","308","310","304","310","312","304","314","306","316","306","314","316"]},{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 3B","FIG. 3A","FIG. 3A"],"b":["350","352","354","356","358","360","308","310","312","314","316"],"sub":["1 ","2 ","3 ","4 ","5 ","1","2","3","4","5 ","1","2","2","3","2","4","2","5","2","5","1","2","3","4","5 "]},{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 3C","FIG. 3C","FIG. 3C","FIG. 3B","FIG. 3A","FIG. 3B","FIG. 3C"],"b":["370","350","370","352","354","356","358","360","372","374"],"sub":["1 ","2 ","3 ","4 ","5 ","1 ","1 ","1 ","2 ","2","i ","j ","a"]},{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Driver","API used to",{},"Test"]},{"entry":["Driver","component","test","Test","component"]},{"entry":["component","resides in","connection","component","resides in"]},{"entry":["(D)","(P)","(I)","(T)","(P)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["D372","P352","I","T374","P354"]},{"entry":["D376","P354","I","T378","P356"]},{"entry":["D376","P354","I","T380","P358"]},{"entry":["D376","P354","I","T384","P360"]},{"entry":["D372","P358","I","T384","P360"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"When a diagnostic transaction determines that a connection Dto Tusing Iis functioning correctly, the response returned by Tto Dis 1; otherwise 0 is returned. All diagnostic transactions must return a 1 for the application to be available. That is, all the diagnostic transaction results are ANDed together to determine end-to-end availability of an application.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":["FIG. 3D","FIG. 3B"]},"An adjacency matrix  includes zero elements and non-zero elements corresponding to the rows of provider processes of an application A and the columns of consumer processes of application A. A non-zero element Irepresents the API that is used in communications, including diagnostic transactions, between the consumer process and provider process indicated by the column and row, respectively, that correspond to the non-zero element. For example, in adjacency matrix , the element at the intersection of row Pand column Pis I, which indicates that the API Iis used by any communication between the consumer process Pand the provider process P. A zero element in adjacency matrix  indicates that application A does not include communications between the processes indicated by the corresponding row and column. For instance, in adjacency matrix , the zero at the intersection of row Pand column Pindicates that consumer process Pdoes not request any resources from provider process P.","Second Application Example",{"@attributes":{"id":"p-0106","num":"0105"},"figref":["FIG. 4A","FIG. 1A","FIG. 3A","FIG. 3A","FIG. 4A"],"b":["2","440","2","352","354","360","428","430","308","310","316","352","354","360","428","430"],"sub":["1 ","2 ","5 ","6 ","7 ","1 ","2 ","5 ","6 ","7 "]},{"@attributes":{"id":"p-0107","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Driver","API used to",{},"Test"]},{"entry":["Driver","component","test","Test","component"]},{"entry":["component","resides in","connection","component","resides in"]},{"entry":["(D)","(P)","(I)","(T)","(P)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["D372","P352","I","T374","P354"]},{"entry":["D376","P354","I","T384","P360"]},{"entry":["D376","P354","I","T450","P428"]},{"entry":["D452","P428","I","T454","P430"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"It should be noted that a single driver component-test component pair can be used in different applications while using a different API for each application, or the same APIs in each application. For example, both  include driver component Dinitiating a diagnostic transaction that requests one or more resources managed by test component T. The API used with Dand Tin  is Iwhile in , the API is I.","Similar to , when a diagnostic transaction of  determines that a connection Dto Tusing Iis functioning correctly, the response returned by Tto Dis 1; otherwise 0 is returned. All diagnostic transactions must return a 1 for application A to be available. If any of the diagnostic transactions return a 0, then application A is unavailable. That is, all the diagnostic transaction results are ANDed together to determine end-to-end availability of an application.",{"@attributes":{"id":"p-0110","num":"0109"},"figref":["FIG. 4B","FIG. 4A"],"b":["460","2","2","460","460"]},{"@attributes":{"id":"p-0111","num":"0110"},"figref":["FIG. 4C","FIGS. 3D and 4B","FIG. 3D) and 460","FIG. 4B"],"b":["470","390","470","470"],"sub":["4 ","6 ","2 ","5","4 ","6 ","2 ","5 ","5 "]},"Example of an Application Impacted by a Failed Process",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 5A","FIG. 1A"],"b":["500","500","3","3"],"sub":["i ","i "]},"Application A is deployed on reverse proxy server , application server , database server , and a SAP\u00ae server , which is a financial package available from SAP AG of Walldorf, Germany. Server  includes process  (e.g., IBM\u00ae HTTP Server), server  includes process  (e.g., WebSphere\u00ae Application Server), server  includes processes  and  (e.g., a CICS\u00ae and DB2\u00ae for z\/OS\u00ae process, respectively), and server  includes processes  and  (e.g., a SAP\u00ae and DB2\u00ae process, respectively). Process pairs in architecture  are described above relative to  and\/or . Architecture  illustrates that process  fails and is unavailable to the applications that utilize process .","An application is impacted by a failed process if a non-zero element in the application's original adjacency matrix becomes a zero element in the application's adjacency matrix which has been updated after the failed process has been detected.  is an update of the adjacency matrix  of  reflecting a process failure, in accordance with embodiments of the present invention. Updated adjacency matrix  illustrates that the failure of  has an impact on the application of . The circled 0 element at row P, column P, indicates that a diagnostic transaction returned a failed condition for provider process P(i.e., the failed process  shown on ). The circled 0 is a change from the original adjacency matrix  (see ) for the first application of , which includes a non-zero (i.e., I) element at the same Prow and Pcolumn. Because of this change from Ito 0, adjacency matrix  indicates that the first application is impacted by the failure in process  (see ). Moreover, since process Pis unavailable, any non-zero element in the consumer process Pcolumn indicates another process utilized by the application that is unreachable due to the failure detected and shown in . For example, since the circled Iappears in the Pcolumn of matrix , the row corresponding to the circled I(i.e., P) indicates that process Pis unreachable through failed process P.","Although not shown, an updated adjacency matrix for the second application of  based on the failure of  is exactly the same as the second application's original adjacency matrix  (see ), thereby indicating that the second application is not impacted by failed process  (see ). That is, the updated adjacency matrix indicates that all connections required by the second application are still available after the failure of process  (see ).","Example of Process Failure with Redundant Processes",{"@attributes":{"id":"p-0116","num":"0115"},"figref":["FIG. 6A","FIG. 3B","FIG. 3B","FIG. 6A","FIG. 3B","FIG. 6A"],"b":["620","4","622","1","624","1","626","1","628","1","630","1","352","354","356","358","360","4","1","622","2","624","2","626","2","628","2","630","2","622","1","624","1","626","1","628","1","630","1","626","1","628","1"]},{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 6B","FIG. 6A","FIG. 6A","FIG. 6A"],"b":["640","640"]},"When an application includes a set of redundant processes, an OR operation is performed on the results returned from the diagnostic transactions associated with the set of redundant processes to determine availability within the set of redundant processes. In terms of adjacency matrices adjusted based on failed processes, the OR operation is performed on the rows (a.k.a. row operands) of the adjusted adjacency matrix corresponding to the set of redundant processes and another OR operation is performed on the columns (a.k.a. column operands) of the adjusted adjacency matrix corresponding to the set of redundant processes. If the row-based OR operation results in a zero value at a column where a non-zero value had been located in the original adjacency matrix, then a process is designated as unavailable and the application is determined to be not available. In contrast, if the row-based OR operation results in a non-zero value corresponding to each of the non-zero values in the row operands of the original adjacency matrix, then the required application transactions can be routed via a redundant process instead of the failed process, and the set of redundant processes is available. Similar availability diagnoses are made if the column-based OR operation results in a zero value or in non-zero values as described above.","As one example, a row-based OR operation is applied to redundant processes Pand Pin . Based on the failure of process Pin , the Prow of adjacency matrix  is adjusted to be all zeros. The adjusted Prow is ORed with the P row of adjacency matrix , which results in:\n\n0 10 0 0 0 10 0 0\n\nThis result includes non-zero Ivalues that are in the same columns as each of the non-zero values included in row Pof the original adjacency matrix . A similar result with a non-zero Ivalue is obtained with a column-based OR operation between Pand P. Thus, the set of redundant processes Pand Pis available even though process Phas failed.\n","As another example, the row-based OR operation is applied to redundant processes Pand Pin . Based on the failure of process P, the Prow of adjacency matrix  is adjusted to all zero values. The adjusted Prow is ORed with the Prow of adjacency matrix  to obtain:\n\n0 0 0 0 0 0 10 0 0\n\nSince the zero in the Pcolumn (i.e., the second column) in the result of the OR operation corresponds to a non-zero value in the Pcolumn of the original adjacency matrix , the process Pis designated as unavailable because it can no longer connect to the Pprocess.\n\nCode Examples\n","The following code example implements a diagnostic transaction utilized in step  of . The code returns a failure (i.e., unavailable) or success (i.e., available) determination for a software process. An input XML file (not shown) identifies the LDAP services that are processed by the following code.",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public ServiceResponse service (ServiceRequest req) throws ServiceException"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ServiceResponse resp = new ServiceResponse( );"]},{"entry":[{},"ARequest[ ] requests = req.getRequests( );"]},{"entry":[{},"int length = requests == null ? 0 : requests.length;"]},{"entry":[{},"AResponse [ ] responses = new AResponse[length];"]},{"entry":[{},"resp.setRunning (true);"]},{"entry":[{},"resp.setResponse (responses);"]},{"entry":[{},"resp.setServiceName (req.getServiceName( ));"]},{"entry":[{},"\/\/ Temp Variables that are mapped to the Input XML file:"]},{"entry":[{},"String name = \u201c\u201d;"]},{"entry":[{},"String host = \u201c\u201d;"]},{"entry":[{},"String port = \u201c\u201d;"]},{"entry":[{},"String authMechanism = \u201c\u201d;"]},{"entry":[{},"String username = \u201c\u201d;"]},{"entry":[{},"String password = \u201c\u201d;"]},{"entry":[{},"String dn = \u201c\u201d;"]},{"entry":[{},"String initCtxFactory = \u201c\u201d;"]},{"entry":[{},"\/\/ Loop for each LDAP Service in the input XML file"]},{"entry":[{},"for (int = 0; i < length; i++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"responses[i] = new AResponse( );"]},{"entry":[{},"responses[i].setRunning (true);"]},{"entry":[{},"name = ServiceUtils.getValue (requests[i], Constants.NAME_KEY);"]},{"entry":[{},"responses[i].setName (name);"]},{"entry":[{},"host = ServiceUtils.getValue (requests[i], Constants.HOST_NODE);"]},{"entry":[{},"port = ServiceUtils.getValue (requests[i], Constants.PORT_NODE);"]},{"entry":[{},"dn = ServiceUtils.getValue (requests[i], Constants.LDAP_DN_NODE);"]},{"entry":[{},"initCtxFactory = ServiceUtils.getValue (requests[i],"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constants.LDAP_INIT_CTX_FACTORY_NODE);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"authMechanism = ServiceUtils.getValue (requests[i],"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constants.LDAP_AUTHENTICATION_MECHANISM_NODE);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"username = ServiceUtils.getValue (requests[i], Constants.USERNAME_NODE);"]},{"entry":[{},"password = ServiceUtils.getValue (requests[i], Constants.PASSWORD_NODE);"]},{"entry":[{},"Hashtable env = new Hashtable( );"]},{"entry":[{},"env.put(\u201cjava.naming.factory.initial\u201d, initCtxFactory);"]},{"entry":[{},"env.put(\u201cjava.naming.provider.url\u201d, \u201cldap:\/\/\u201d + host + \u201c:\u201d + port);"]},{"entry":[{},"env.put(\u201cjava.naming.security.authentication\u201d, authMechanism);"]},{"entry":[{},"if (!\u201cAnonymous\u201d.equalsIgnoreCase(username)) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"env.put(\u201cjava.naming.security.principal\u201d, username);"]},{"entry":[{},"env.put(\u201cjava.naming.security.credentials\u201d, password);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"DirContext ctx = null;"]},{"entry":[{},"Attributes entry = null;"]},{"entry":[{},"boolean exception = false;"]},{"entry":[{},"\/\/ Obtain the LDAP Context"]},{"entry":[{},"try {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ctx = new InitialDirContext (env);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} catch (NamingException e) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"logger.info (\u201cNaming exception occured:\u201d + e.getExplanation( ));"]},{"entry":[{},"resp.setRunning (false);"]},{"entry":[{},"responses[i].setRunning (false);"]},{"entry":[{},"responses[i].setResult(ExceptionInformation.stackTraceToString (e,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Constants.DEFAULT_LINES_TO_SHOW));"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"exception = true;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (exception) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (ctx != null) try { ctx.close( ); } catch(Exception e) { }"]},{"entry":[{},"continue;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"try {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"entry = ctx.getAttributes(dn);"]},{"entry":[{},"if (entry == null || entry.size( ) == 0) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ FAILURE: Process failure detected"]},{"entry":[{},"responses[i].setRunning (false);"]},{"entry":[{},"responses[i].setResult (\u201cFailed to get the \u201d + dn);"]},{"entry":[{},"logger.info (\u201cFailed to get the\u201d + dn);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ SUCCESS: Available process detected"]},{"entry":[{},"responses[i].setResult (Constants.SUCCESS);"]},{"entry":[{},"logger.info (\u201cSuccessful for the\u201d + dn);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} catch (Exception e) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"logger.info (\u201cNaming exception occured:\u201d + e.getMessage( ));"]},{"entry":[{},"resp.setRunning (false);"]},{"entry":[{},"responses[i].setRunning (false);"]},{"entry":[{},"responses[i].setResult"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(ExceptionInformation.stackTraceToString (e,Constants.DEFAULT_LINES_TO_SHOW));"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} finally {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (entry != null) try { entry.remove (dn); } catch(Exception e) { }"]},{"entry":[{},"if (ctx != null) try { ctx.close( ); } catch(Exception e) { }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"return resp;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The following code examples implement the generation of initial application topologies using adjacency matrices, and the determination of applications impacted by a failed process.",{"@attributes":{"id":"p-0124","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ This code snippet builds the initial application topology and a number of Adjacency Matrices:"},{"entry":"\/\/ (see step 206 of FIG. 2)"},{"entry":"\/\/ adjacencyMatrixTopologyAllConnections - matrix for the complete set of connections to be monitored"},{"entry":"\/\/ (changes only when a new topology for any application is discovered)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/","adjacencyMatrixTopologyA1 - matrix for application topology A1"]},{"entry":[{},"\/\/ (changes only when a new topology for A1 is discovered)"]},{"entry":["\/\/","adjacencyMatrixTopologyA2 - matrix for application topology A2"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ (changes only when a new topology for A2 is discovered)"},{"entry":"\/\/"},{"entry":"\/\/ For purposes of simplicity in this code snippet, A1 & A2 are shown as separate matrices. In an actual"},{"entry":"\/\/ system, A1 and A2 would be implemented in a single 3-dimensional matrix, whose three dimensions"},{"entry":"\/\/ indicate application, consumer process and provider process, or as a sparse matrix."},{"entry":"\/\/ Hard coding of application of application names has been done to provide a concrete example."},{"entry":"\/\/"},{"entry":"\/\/ This code example assumes that the ARM parent and child correlators, and other ARM data, are"},{"entry":"\/\/ available to the program."},{"entry":"consumerProcessID = parentCorrelator.extractProcessID( ) \/\/ Will be null if this is the first unit of work in"},{"entry":"\/\/ the application"},{"entry":"providerProcessID = childCorrelator.extractProcessID( )"},{"entry":"AppName = parentCorrelator.extractRootTransactionName( ) \/\/ Find the initial ARM transaction name"},{"entry":"\/\/ (i.e., the \u201cApplication Name\u201d)"},{"entry":"\/\/ Are these processes known (i.e., used in an application) already or are they \u201cfirst of a kind\u201d?"},{"entry":"i = consumerProcessList.returnIndex(consumerProcessID)"},{"entry":"if (i == NULL) \/\/ \u201cFirst of a kind\u201d consumer process detected"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"consumerProcessList.addProcess(consumerProcessID) \/\/ Add to process list of Consumer processes"]},{"entry":[{},"numberOfConsumerProcess++"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"j = providerProcessList.returnIndex(providerProcessID)"},{"entry":"if (j == NULL) \/\/ \u201cfirst of a kind\u201d provider process detected"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"providerProcessList.addProcess(providerProcessID) \/\/ Add to process list of Provider processes"]},{"entry":[{},"numberOfProviderProcess++"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"\/\/ Update all adjacency matrices that describe application topology"},{"entry":"connectiontype = parentCorrelator.extractURI( ) \/\/ Service type being invoked"},{"entry":"switch(connectiontype)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case (\u2018JDBC\u2019):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Enable monitoring of the connection as part of the Adjacency Matrix that describes all connections"]},{"entry":[{},"if (!(adjacencyMatrixTopologyAllConnections(i, j) & FLAG_JDBC)) \/\/ Is this a first of a kind connection?"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"adjacencyMatrixTopologyAllConnections(i, j) ="]},{"entry":[{},"adjacencyMatrixTopologyAllConnections(i, j) | FLAG_JDBC \/\/ Yes add it to overall matrix of"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ monitored connections"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Update the topology matrix that describes Application A1"]},{"entry":[{},"if (TranName = \u201cA1\u201d)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"adjacencyMatrixTopologyA1(i, j) = adjacencyMatrixTopologyA1(i,j) | FLAG_JDBC \/\/ Yes - add it to"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ overall matrix of monitored connections"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"\/\/ Repeat update of topology matrix for A2 and any other applications"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case ..."]},{"entry":[{},"\/\/ Repeat for as many other cases as there are APIs or protocols in use"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"\/\/ Code example to perform connection monitoring across all the consumer & provider processes used by"},{"entry":"\/\/ the applications being monitored (see step 208 of FIG. 2)"},{"entry":"\/\/"},{"entry":"\/\/ This step presumes that the application topology has already been discovered and a number of"},{"entry":"\/\/ Adjacency Matrices have already been constructed:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","adjacencyMatrixTopologyAllConnections - matrix for the complete set of connections to be monitored"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ (changes only when a new topology for any application is discovered)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","adjacencyMatrixStatusAllConnections - matrix for the complete set of connections to be monitored"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(can change whenever the test loop in this code snippet is executed)"},{"entry":"\/\/"},{"entry":"for i =1 to numberOfConsumerProcesses \/\/ Loop through all consumer processes"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for j =1 to numberOfProviderProcesses \/\/ Loop through all provider processes"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"consumerProcessID = consumerProcessList.returnProcess(i) \/\/ Lookup of Consumer process details"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ (system name, IP address, process number, etc.) from the ordered list of consumer processes"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"providerProcessID = providerProcessList.returnProcess(j) \/\/ Lookup of Provider process details"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ (system name, IP address, process number, etc.) from the ordered list of provider processes"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ For each connection and API or protocol that are used in the environment, test the connection to"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"determine"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ whether it is working"]},{"entry":[{},"if (adjacencyMatrixTopologyAllConnections(i , j) & FLAG_JDBC) \/\/ Does a JDBC connection need to"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ be tested between these two processes?"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (testConnection(consumerProcessID, providerProcessID,"]},{"entry":[{},"FLAG_JDBC) == FAIL)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Switch off the flag in the Status matrix to indicate that the connection is unavailable"]},{"entry":[{},"adjacencyMatrixStatusAllConnections(i, j) ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"adjacencyMatrixStatusAllConnections(i, j) & (FLAG_JDBC {circumflex over (\u2009)} X\u2018FFFF\u2019)"]},{"entry":[{},"\/\/ Exclusive OR the JDBC flag with ones and then AND them to turn it off in the status matrix"]},{"entry":[{},"else"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Set a flag in the Status matrix to Indicate that the connection is available"]},{"entry":[{},"adjacencyMatrixStatusAllConnections(i, j) ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"adjacencyMatrixStatusAllConnections(i, j) | FLAG_JDBC;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (adjacencyMatrixTopologyAllConnections(i , j) & FLAG_HTTP) \/\/ Does a HTTP connection need to"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ be tested between these two processes?"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (testConnection(consumerProcessID, providerProcessID,"]},{"entry":[{},"FLAG_HTTP) == FAIL)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (adjacencyMatrixTopologyAllConnections(i , j) & FLAG_xyz) \/\/ Does an xyz type connection need"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ to be tested between these two processes?"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"...\/\/ Test whether the connection is functioning or not"]},{"entry":[{},"}"]},{"entry":[{},"...\/\/ Test for as many different application connection protocols or APIs as the application supports"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"\/\/ Perform impact analysis to compare the determine from the processes which ones are impacted when"},{"entry":"\/\/ failure occurs. See step 212 of FIG. 2."},{"entry":"\/\/"},{"entry":"\/\/ The following code snippet presumes that the adjacency matrices used in the previous code snippet are"},{"entry":"\/\/ available and that topology matrices are available for each application being monitored:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","adjacencyMatrixTopologyA1 - matrix for application topology A1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ (changes only when a new topology for A1 is discovered)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","adjacencyMatrixTopologyA2 - matrix for application topology A2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ (changes only when a new topology for A2 is discovered)"},{"entry":"\/\/"},{"entry":"\/\/ For purposes of this code snippet, A1 & A2 are shown as separate matrices. In an actual system, A1"},{"entry":"\/\/ and A2 would be implemented in a single 3-dimensional matrix including dimensions for application,"},{"entry":"\/\/ consumer process and provider process, or as a sparse matrix."},{"entry":"\/\/ Hard coding of application of application names has been done to provide a concrete example."},{"entry":"\/\/"},{"entry":"\/\/ Check all connections required for A1 are available."},{"entry":"\/\/"},{"entry":"for i =1 to numberOfConsumerProcesses \/\/ Loop through all consumer processes used by application A1"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for j =1 to numberOfProviderProcesses \/\/ Loop through all provider processes used by application A1"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (adjacencyMatrixTopologyAllConnections(i , j) =="]},{"entry":[{},"adjacencyMatrixTopologyA1 (i, j)) \/\/ Are all connections available that are supposed to be available?"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"...\/\/ Yes - A1 is not impacted by failure(s) detected"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"...\/\/ No - A1 is impacted by failure(s) detected"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"\/\/ Check all connections required for A2 are available"},{"entry":"\/\/"},{"entry":"for i =1 to numberOfConsumerProcesses \/\/ Loop through all consumer processes used by application A2"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for j =1 to numberOfProviderProcesses \/\/ Loop through all provider processes used by application A2"]},{"entry":[{},"{"]},{"entry":[{},"..."]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"\/\/ Check all connections in any other applications."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0125","num":"0124"},"figref":["FIG. 7","FIG. 1A","FIG. 1A"],"b":["700","124","700","702","704","706","708","710","712","802","700","702","704","712","702","704","704"]},"I\/O interface  comprises any system for exchanging information to or from an external source. I\/O devices  comprise any known type of external device, including a display monitor, keyboard, mouse, printer, speakers, handheld device, printer, facsimile, etc. Bus  provides a communication link between each of the components in computing unit , and may comprise any type of transmission link, including electrical, optical, wireless, etc.","I\/O interface  also allows computing unit  to store and retrieve information (e.g., program instructions or data) from an auxiliary storage device, such as a non-volatile storage device (e.g., a CD-ROM drive which receives a CD-ROM disk) (not shown). Computing unit  can store and retrieve information from other auxiliary storage devices (not shown), which can include a direct access storage device (DASD) (e.g., hard disk or floppy diskette), a magneto-optical disk drive, a tape drive, or a wireless communication device.","Memory  includes computer program code comprising an application  that includes logic for determining application availability. Further, memory  may include other systems not shown in , such as an operating system (e.g., Linux) that runs on CPU  and provides control of various components within and\/or connected to computing unit .","The invention can take the form of an entirely hardware embodiment, an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment, the invention is implemented in software, which includes but is not limited to firmware, resident software, microcode, etc.","Furthermore, the invention can take the form of a computer program product accessible from a computer-usable or computer-readable medium providing program code  for use by or in connection with computing unit  or any instruction execution system to provide and facilitate the capabilities of the present invention. For the purposes of this description, a computer-usable or computer-readable medium can be any apparatus that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device.","The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid state memory, magnetic tape, a removable computer diskette, RAM , ROM, a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk-read-only memory (CD-ROM), compact disk-read\/write (CD-R\/W) and DVD.","A computing system  suitable for storing and\/or executing program code  include at least one processor  coupled directly or indirectly to memory elements  through a system bus . The memory elements can include local memory employed during actual execution of the program code, bulk storage, and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.","Furthermore, the present invention discloses a method for deploying or integrating computing infrastructure, comprising integrating computer-readable code into computer system , wherein the code in combination with computer system  is capable of optimally scheduling an activity managed by a web application. The disclosed method for deploying or integrating computing infrastructure with the capabilities described herein can be offered as a service on a subscription service.","The flow diagrams depicted herein are provided by way of example. There may be variations to these diagrams or the steps (or operations) described herein without departing from the spirit of the invention. For instance, in certain cases, the steps may be performed in differing order, or steps may be added, deleted or modified. All of these variations are considered a part of the present invention as recited in the appended claims.","While embodiments of the present invention have been described herein for purposes of illustration, many modifications and changes will become apparent to those skilled in the art. Accordingly, the appended claims are intended to encompass all such modifications and changes as fall within the true spirit and scope of this invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 2","FIG. 1A"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 3A","FIG. 1A"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 3B","FIG. 3A"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3C","FIG. 3C"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 3D","FIG. 3B"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4A","FIG. 1A"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 4B","FIG. 4A"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 4C","FIGS. 3D and 4B"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 5A","FIG. 1A"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 5B","FIG. 3D","FIG. 5A"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 6A","FIG. 3B"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 6B","FIG. 6A"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 7","FIG. 2"]}]},"DETDESC":[{},{}]}
