---
title: Optimized recovery logging
abstract: A system, method and computer-readable medium for optimizing recovery logging is provided. A calling component stably logs a message from a called component only when sending a second message or sending a second message after a log force that writes the return message from the first message to the stable log. The called component stably logs its return message before the return message is sent.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07418462&OS=07418462&RS=07418462
owner: Microsoft Corporation
number: 07418462
owner_city: Redmond
owner_country: US
publication_date: 20031124
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["The invention relates to computing and in particular to a technique that optimizes the use of redo recovery enabling stateful applications to persist across crashes.","After a soft crash, (a system failure in which stable storage is unaffected), a database is generally recovered to the last committed transaction and uncommitted or incomplete transactions are aborted. Although database state is recovered, the state of an application using the database, and its session, are typically lost.","U.S. Pat. No. 6,182,086 \u201cClient-Server Computer System with Application Recovery of Server Applications and Client Applications\u201d issued Jan. 20, 2001, describes a technique in which a stable log file is generated that is used to help recover a client-side application when a system crash occurs. U.S. patent application Ser. No. 09\/946,050 \u201cRecovery Guarantees for General Multi-Tier Applications\u201d, filed Sep. 1, 2001 and U.S. patent application Ser. No. 09\/946,092 \u201cPersistent Stateful Component-Based Applications Via Automatic Recovery\u201d, filed Sep. 1, 2001, describe other techniques for recovering an application after a system crash. For example, a stateless application may be broken into steps, each step executing within a transaction. Applications with state (stateful applications) can be recovered by intercepting interactions between components and stably logging them. In prior techniques implementing this approach, a client interacting with a number of servers: server , server  . . . server n, logs a message returned by server  (in a memory buffer, for instance) and forces the log (writes the memory buffer to stable storage) before sending a message to server  in order to capture all non-determinism encountered up to that point.","The overhead involved in all these techniques for recovering applications is relatively high. It would be helpful if there were an optimized recovery technique that would reduce the number of forced log writes required.","Stateful program components are persisted across system crashes via a technique of redo logging and application replay. Messages (inter-component interactions) are logged. Between interactions between components, the components execute deterministically. Thus, by using the logged messages and re-executing the component between message interactions, component state can be recreated.","The overhead required to persist stateful components is determined by the number of messages that have to be logged to the memory buffer and the number and timing of forced writes to the stable log. To achieve stateful component persistence, a committed interaction contract between the persistent components is established. When a calling persistent component issues calls to a number of different called persistent components, each called component must guarantee the persistence of its last return message to the calling component until the calling component releases the called component from this obligation. Thus, any non-determinism that may exist is captured stably in the logging at the called component. Because the calling component does not release the called component from its obligation to guarantee the persistence of the last return message until the calling component calls the called component a second time, the calling component does not have to force the log before each call to a called component. Should the calling component crash, the calling client can replay the application, and obtain the reply message from the called component's stable log.","A system, method and computer-executable medium containing computer-executable instructions to provide the above-described optimized recovery technique is described in more detail below.","Overview","The overhead required to persist stateful components is determined by the number of messages that have to be logged and the number and timing of forced writes to the log. To achieve stateful component persistence a committed interaction contract between the persistent components is established. Suppose, for example, that a calling component (a client, for instance) makes a number of calls to different called (server) components. When the client issues calls to a number of different servers, each server component must guarantee the persistence of its last return message to the client component until the client component releases the server component from this obligation. Thus, any non-determinism that may exist is captured stably in the logging at the server component. Because the client component does not release the server component from its obligation to guarantee the persistence of the last return message until the client component calls that server component a second time, the client component does not have to force the log before each call to a server component. Instead the client component only forces a log before the second call to the previously-called server component.","A called component table is maintained that keeps a history of calls made by the calling component to called components, and a log sequence number associated with each component (CLSN). Calls that have been written from the called component table to the stable log can be distinguished from calls that have not been written to the stable log by comparing the log sequence number in the table (the CLSN) with a highest log sequence number written to the stable log. Forcing a log resets the status of a \u201cpreviously-called\u201d component to \u201cuncalled\u201d or \u201cnot called since the last log force\u201d.","Exemplary Computing Environment",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["10","20","22","30","40","20","30","40"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2","b":["200","220","200","220","202","222","209","211","206","226","207","227","208","228"]},"An error handler (not shown) may be registered with each component runtime , . Furthermore, two recovery managers ,  are provided because of the machine boundary  between the server  and the client . When the client  issues a call to server , the call is intercepted by the component runtime  which captures the message in a log . The call is passed to the proxy , which sends the message, (e.g,. a method call message), across the boundary  to the stub . The stub calls the server side component runtime , which delivers the call. The process is reversed for a return message.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},"Although not required, the invention can be implemented via an application programming interface (API), for use by a developer, and\/or included within the network browsing software which will be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers, or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB).","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . A graphics interface , such as Northbridge, may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU, or host processing unit , and assumes responsibility for accelerated graphics port (AGP) communications. One or more graphics processing units (GPUs)  may communicate with graphics interface . In this regard, GPUs  generally include on-chip memory storage, such as register storage and GPUs  communicate with a video memory . GPUs , however, are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","One of ordinary skill in the art can appreciate that a computer  or other client device can be deployed as part of a computer network. In this regard, the present invention pertains to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. The present invention may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.","System and Method for Optimizing Committed Interaction Contracts","A component is typically an object instance (e.g., C++, Java C#, etc.) operating within a runtime environment, (e.g., CORBA, Enterprise Java Beans, MICROSOFT .NET\u00ae, etc.). Component states are stored in object fields and operations on the object instance are performed by calling methods. Components communicate via local or remote method calls. As illustrated in , a component  can detect four kinds of messages: an incoming method call  from a client component ; a reply message  to the client component ; an outgoing method call  to a server component  and a response  from the server component .","Persistent components are components that survive a system crash. In order to ensure that a component is persistent, the following guarantees must be made:","1. When sending a message (such as message  and  in ), the component ensures that the message and its state as of the send are persistent (such as by writing the state and message to a stable log or by replaying method calls).","2. When making a method call, a persistent component attaches a globally unique ID to the deterministically-derived outgoing method call message.","3. When receiving a method call from another persistent component, a persistent component checks the globally unique ID, to determine if the message has been received already. If it has not, processing continues normally. If it has, the component returns the reply of the previous method call with the same ID.","4. A persistent component repeats an outgoing method call to a server until the component receives a response back.","5. When recovering from a failure, if a persistent component was responding to an incoming method call before the failure, it does not send the reply (message ) until a reply is requested by the client.","The making of these guarantees between persistent components is sometimes referred to as a committed interaction contract. While it is possible for components to contain explicit application code to realize a committed interaction contract, it is much more effective to implement such a contract by an interception mechanism that captures method calls and returns made between software components. To recover a failed component, all logged incoming method calls are replayed from component creation or checkpoint until failure. Because all messages are persisted (by writing to a stable log, for instance), component state can be recovered back to the time of the last send message and execution can resume.","To replay an incoming method call, the logged method is called with the logged parameters. An outgoing call is suppressed if a reply to the call is found in the log. In that case, the reply is read from the log and returned. Otherwise either the last message is a return and recovery is complete without resending it, or the last message is an outgoing call, recovery is complete and the message is resent. Normal processing may then resume.","Previously known techniques enable components to be persistent by logging and forcing the log for each message sent and received. To recover a failed persistent component, all the method calls are replayed. A prior optimization involved forcing the log only when a message is sent, rather than both when a message is sent and when a message is received.","If, however, instead of examining each call in isolation, the effect of multiple calls is taken into account, the number of forced log writes can be diminished, realizing improved performance.","Consider, for example, a persistent component that calls multiple components. The calling component may be a client, for instance and the called components may be server components. It will be understood, however, that as used herein, the terms \u201cclient\u201d and \u201cserver\u201d refer to roles assumed within a particular interaction, rather than machine characteristics. Thus a \u201cclient\u201d (calling) component in one interaction may well be a \u201cserver\u201d (called) component in another interaction. In , client persistent component C  communicates with multiple persistent server components, server component S , server component S , server component S , . . . server component Sn . Each persistent component is associated with a (volatile) memory buffer log and a stable log (e.g., client component C  is associated with a (memory buffer) log C  and stable log C , server component S  is associated with a (memory buffer) log S  and stable log S , server component S  is associated with a (memory buffer) log S  and stable log S , server component S  is associated with a (memory buffer) log S  and stable log S  and server component n  is associated with a (memory buffer) log n  and stable log n .) Memory buffer logs , , ,  and  and stable logs , , ,  . . .  may include last call tables , , ,  . . .  and called component tables , , ,  . . .  respectively. Alternatively, last call tables , , ,  . . .  may exist independently of stable logs , , ,  . . . . Similarly, called component tables , , ,  . . .  may exist independently of stable logs , , ,  . . . . Memory buffer logs , , ,  and  and stable logs , , ,  . . .  may include sufficient information to re-create other tables not shown in . Stable logs , , ,  . . . , last call tables , , ,  . . . , called component tables , , ,  . . .  and other tables in some embodiments of the invention reside on stable storage media such as disk, tape, CDROM or the like. Alternatively, a number of persistent components may share a single stable log and tables.","A called component table, such as, for example, called component table C , may include the components called by a calling component (e.g., calling component C ). The called component table may also include, in some embodiments, messages sent to a called component and\/or received from the called components or a location of or pointer to those messages. Hence called component table C  may include one or more components for which messages have not yet been written to stable log C . Called component table C  may also include a list of components for which messages have been written to stable log C . Components for which messages have been written to stable log C  may be distinguished from those for which messages have not been written to stable log C  by the presence or absence of an identifier or marker, or by a comparison of a log sequence number and component log sequence number (CLSN). Alternatively, components for which messages have been written to stable log C  may be removed or deleted from called component table C .","In the absence of context information, each of the calls between persistent components commit component state and therefore must force the log. However certain provisions of the committed interaction contract between the persistent components can be exploited to realize performance advantages under certain circumstances, as described below.","Referring now concurrently to  and to the flow diagram of , in accordance with one embodiment of the invention, an exemplary method  of realizing an optimized committed interaction contract is described. If non-determinism is detected () at a calling component, the calling component forces a log (). The forced log captures all non-determinism encountered up to that point by the calling component.","For example, referring to , client component C  may write the last return message received from a component to memory buffer log C  and\/or force a log to stable log C .","The calling component may send a call to a (remote) persistent component () that has not been previously called, and hence is not in the called component table. For example, client component C  may send a first call message (Message  ) to a remote persistent component S . In some embodiments of the invention, the calling component determines that the persistent component has not been previously called, by consulting a called component table (e.g., called component table C ) or other suitable data structure that includes a list of previously called components.","In some embodiments of the invention, the call message sent to the called component is assigned a globally unique identifier. A record of the call message or a pointer thereto, may be logged in a memory buffer and\/or logged stably. For example, Message   may be logged in Log C  and\/or saved stably in Stable Log C . In some embodiments of the invention, the called component identifier and the message or a pointer to the message is stored in the called component table, indexed by remote component identifier in the memory buffer or stable log.","The called component may subsequently receive the call (). For example, server component S  may receive the call message (Message  ) from client component C . The called component may then execute the called procedure body ().","In one embodiment of the invention, the called component may stably log the return message () or otherwise make the message re-creatable. For example, server component S may stably log Return Message   to stable log S . The called component may send a return message (). For example, server component S  may send Return Message   to client component C . In some embodiments of the invention, the return message (e.g., Return Message  ) is identified by the globally unique identifier assigned to the call message (e.g., Message  ).","It will be understood that while in exemplary method  the return message is sent after the return message is stably logged, these steps may be reversed in order or may occur substantially concurrently, in some cases. For example, in the absence of non-determinism, the return message may be sent before being logged or may be sent concurrently with logging. In some embodiments of the invention, the return message (e.g., Return Message  ) is stored in a last call table (e.g., last call table S ). The return message may be saved in an intermediate step in the memory buffer log (e.g., log S ) in some embodiments of the invention.","The calling component may receive the return message (). For example, client component C  may receive Return Message  . The calling component may log the return message in the calling component's memory buffer but does not force the log at this point. For example, client component C  may log the Return Message   in log C , but does write to stable log C  at this point.","The calling component may then prepare to send another call message. For example, client component C  may then prepare to send Message  . Suppose, as shown in A, the next message the calling component sends is a message to a remote component that has not been previously called (that is, has not been called since the last log force) by the calling component (). For example, suppose client component C  sends Message   to server component S . Message   is another \u201cfirst message\u201d sent to a remote persistent component because no messages have been sent to server component S  since the last log force. In some embodiments of the invention, the call message (e.g., Message  ) sent to the called component (e.g., server component S ) is assigned a globally unique identifier. A record of the call message (e.g., Message  ) or a pointer thereto, may be logged in the memory log buffer (e.g., Log C ) and\/or logged stably (e.g., a forced write to Stable Log C  performed). In some embodiments of the invention, a called component identifier and the message or a pointer to the message is stored in a called component table, indexed by called component identifier.","The called component may receive the call message (). For example, server component S  may receive Message   from client component C . The called component may execute the called procedure (), log the return message in the called component's stable log and\/or buffer log () and send a return message (). For example, server component S  may execute the called procedure (), stably log Return Message   to its stable log S  () and may send Return Message   to client component C  (). In some embodiments of the invention, the return message (e.g., Return Message  ) is identified by the globally unique identifier assigned to the call message (Message  ). In some embodiments of the invention the return message (e.g., Return Message  ) is stored in a last call table (e.g., last call table S ).","The calling component may receive the return message (). For example, client component C  may receive Return Message  . The calling component may log the return message in the calling component's memory buffer but does not force the log at this point. For example, client component C  may log Return Message   in log C , but does write to stable log C  at this point.","Suppose, however, that instead of sending a first message to a persistent component that has not been called since the last log force, the called component sends a message to a component that has been called since the last log force. Such a circumstance is illustrated in process B.","Before a second message is sent to a previously called component (), the calling component stably logs () the return message previously sent by the called component.","For example, client component C  may send a second call message (Message  ) to remote persistent component S . Before Message   is sent to server component S , Return Message   is written to stable log C  (). In some embodiments of the invention, the calling component determines that the persistent component has been called since the last log force, by consulting a called component table or other suitable data structure that includes a list of components called since the last log force.","As described previously, in some embodiments of the invention, the call message sent to the called component is assigned a globally unique identifier. A record of the call message or a pointer thereto, may be logged in a memory buffer and\/or logged stably. For example, Message   may be logged in Log C  and\/or saved stably in Stable Log C . In some embodiments of the invention, the called component identifier and the message or a pointer to the message is stored in the called component table, indexed by called component identifier in the memory buffer or stable log.","The called component may subsequently receive the call (). For example, server component S  may receive the call message (Message  ) from client component C . The called component may execute the called procedure ().","In one embodiment of the invention, the called component may stably log the return message (). For example, server component S may stably log Return Message  to stable log S . The called component may send a return message (). For example, server component S  may send Return Message  (not shown) to client component C . In some embodiments of the invention, the return message (e.g., Return Message ) is identified by the globally unique identifier assigned to the call message (e.g., Message  ).","It will be understood that while in exemplary method  the return message is sent after the return message is stably logged, these steps may be reversed in order or may occur substantially concurrently in the absence of non-determinism. In some embodiments of the invention, the return message (e.g., Return Message  ) is stored in a last call table (e.g., last call table S ). The return message may be saved in an intermediate step in the memory buffer log (e.g., log S ) in some embodiments of the invention. In some embodiments of the invention, only the last return message is saved. Alternatively, any specified number of return messages may be saved in the last call table, thus avoiding the need to force the log until that number of return messages has been saved. For example, suppose the last call table can hold ten return messages. If ten return messages can be saved in the last call table, the calling component does not have to force the log until the tenth message is received, because if required, the ten return messages can be retrieved from the last call table.","The calling component may receive the return message (). For example, client component C  may receive Return Message . The calling component may log the return message in the calling component's memory buffer but does not force the log at this point. Processing continues as described in A or B until the process ends. It will be understood that any number of components may be called before the calling component sends a second message to a previously called component and forces a log.","The savings in log writes realized thus is one log write for each component called since the last log force to which a calling component sends a message until a second call to a previously-called component is made. It will be understood that any number of components may be called by the calling component.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 7","FIG. 5","FIG. 8"],"b":["700","540","8"],"i":["a","d. "]},"A log sequence number (LSN) is a unique number assigned to a record placed on the log. The LSN may denote a location on the log and is incremented for each new record to be placed on the log. Referring now to , suppose that a call to a called component is to be made (). For example, referring again to , suppose client component C  wants to send Message   to server component S .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 8","i":"a ","b":["540","1","550","1","504","802","512","802","850","820","830"]},"When Message   is to be sent to the called component S  (), the called component is entered into the called component table (). The CLSN is set to zero, indicating that the component has not been called previously. When the return message is received back from called component S, the return message is written to the memory buffer and the highest LSN number written to the memory buffer (LSN ) is incremented (). Because the last used LSN was 100 (for entry ), the LSN for Message   may be 101, as shown in , reference numeral . Then the CLSN is set to 101 (the same value as ) in .","In some embodiments of the invention, the called component table is accessed () to determine if the called component has been called before. For example, referring to , called component table C  may be accessed to determine if server component S  is already in the called component table. As there is no entry in called component table C  for server component S , an entry (entry ) is made into called component table C  (), as illustrated in and CLSN is set to the lowest possible value (e.g., 0) ().","The highest LSN written to the stable log (LSN ) is compared with the component LSN (CLSN) (). For example LSN  of (100) is compared with CLSN of entry  (0). As 100 is not less than 0, processing continues at step . CLSN is set to the highest LSN written to the memory buffer (LSN ) 101, as shown in , entry  when the return message from S is logged.","Processing may then continue as described above with respect to  (). The message (e.g., Message   may be sent, the called procedure executed and a message returned. As no forced log has occurred, the highest LSN written to the stable log (LSN ) is unchanged.","Suppose now that a message (e.g., Message  ) to server component S  is to be sent from client component C  (). The called component table C  () is accessed to determine if a call has been made to server component S  () before. As no entry is found for server component S , an entry  is made to called component table C  () and CLSN of entry  is set to 0 (), as shown in . The highest LSN written to the stable log (LSN ) is compared with the component LSN (CLSN) (). For example LSN  of (100) is compared with CLSN of entry  (0). As 100 is not less than 0, processing continues at step . CLSN is set to the highest LSN written to the memory buffer (LSN ) 102 (entry  of ).","Processing continues (). Message   may be sent, the called procedure executed and a message returned. The return message is written to the memory buffer and the highest LSN number written to the memory buffer (LSN ) is incremented () to 102 (). This LSN () is then entered into the called component table as the CLSN entry for component S (). As no forced log has occurred, the highest LSN written to the stable log () is unchanged.","Suppose now that a message (e.g., Message  ) to server component S  is to be sent from client component C  (). The called component table C  () is accessed to determine if a call has been made to server component S  () before. An entry is found for server component S  (that is, entry ). To determine if entry  has already been written to the stable log, the LSN for entry  (CLSN of entry , 101) is compared to the highest LSN written to the stable log (LSN ). Because the LSN for entry  (101) is greater than the highest LSN of the stable log (100), entry  has not been written to the stable log. The log is forced () and the highest LSN of the stable log (LSN ) is set to the highest LSN of the memory buffer (LSN ). Processing continues as described above (). This is illustrated in , where upon receiving the return message, the message is logged at LSN 103, and this LSN becomes the new value for  and for the CLSN of S ().","It will be apparent that method  can be modified in numerous ways not departing from the spirit of the invention as contemplated. For example, instead of using LSN and CLSN to determine if an entry has been forced to the log, an indicator may be set, signifying that the entry has been written to the stable log.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the creation and\/or implementation of domain-specific programming models aspects of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the present invention has been described in connection with the embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. Similarly it will be understood that although the framework is described within the context of an automated way of intercepting messages, the invention is not so limited and may be used wherever persisting application programs is useful. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of illustrative embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 8","i":["a","d "],"b":"8"}]},"DETDESC":[{},{}]}
