---
title: Methods and apparatus for protocol independent model to provide event-based discovery
abstract: Methods and apparatus for providing a storage resource management application having a protocol independent model for event-based discovery. In response to an event, discovery is performed using a protocol independent ontology model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09491056&OS=09491056&RS=09491056
owner: EMC Corporation
number: 09491056
owner_city: Hopkinton
owner_country: US
publication_date: 20121228
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["As is known in the art, storage area networks (SANs) can include a variety of different components and those components can be provided by different vendors. For example, storage network elements provide management information through various protocols: CISCO switches communicate via SNMP protocol, NAS (e.g., EMC Celerra) components communicate via Celerra XML API and arrays communicate via SMI-S. It can be challenging to communicate with components in the network using the different protocols.","In one aspect of the invention, a method comprises: receiving an event, creating a discovery job in response to the event, initiating the discovery job with a discovery collector, and performing discovery of a device using a protocol independent ontology model, wherein the device comprises a first one of an array in a storage layer, a switch in a network layer, a host in a compute layer, and a NAS device, wherein the device can be accessed by different protocols.","In another aspect of the invention, an article comprises: a computer-readable medium containing non-transitory stored instructions that enable a machine to perform: receiving an event, creating a discovery job in response to the event, initiating the discovery job with a discovery collector, and performing discovery of a device using a protocol independent ontology model, wherein the device comprises a first one of an array in a storage layer, a switch in a network layer, a host in a compute layer, and a NAS device, wherein the device can be accessed by different protocols.","In a further aspect of the invention, a system comprises: at least one processor, and at least one memory coupled to the at least one processor, the at least one processor and the at least one memory configured to: receive an event, create a discovery job in response to the event, initiate the discovery job with a discovery collector, and perform discovery of a device using a protocol independent ontology model, wherein the device comprises a first one of an array in a storage layer, a switch in a network layer, a host in a compute layer, and a NAS device, wherein the device can be accessed by different protocols.","In general, exemplary embodiments of the invention support multiple protocols for management of storage network elements in a virtualized storage resource management (SRM) application that provides an end-to-end view across abstraction layers. A protocol independent ontology model enables focused discovery and management of the storage network elements. In exemplary embodiments using an ontology model, each request\/method call to a data provider is modeled as an operation for any protocol.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["2","2","4","4","2","6","8","10","12","14","16","18","20"]},"The discovery component entities reside on the discovery appliance . Domain manager (DM) components transform source information models into a DMTF Common Information Model (CIM) based information model, maintaining their data in memory. This data is then migrated to the SRM appliance . DMs periodically persist their data in repository files (.rps). Some components that are written in java, for example, collect discovered data and do not persist it locally. In exemplary embodiment, each data collection component supports a specific protocol (e.g. CIM\/XML, SNMP) configured to collect information instances in the source format (e.g. CIM\/XML) and transfer that data stream to the appliance  with no transformation or inspection of the data, other than syntax checking (e.g. testing for well-formed XML). In some cases, as with SNMP, where there is no standard or de facto standard for a serialization format of the information model. In this case, the data is transformed into a specific format before transfer (e.g. jSON). This simple \u201cpull-and-post\u201d pattern enables data collections to be written quickly, as very little processing is required before the write. This also allows for high scalability, as each component is specifically written to minimize CPU and memory utilization. The methods used to achieve this include data streaming, which enables more instances and threads to run in parallel to achieve high throughput for discovery. These components are based on a flexible framework, which also facilitates the creation of new components by third parties (e.g. service organizations). Discovery components post their results to the appliance  using SSL-enabled HTTP (i.e. HTTPS) connections. In the appliance , the data is serialized to disk with multiple threads parsing and transforming the discovered elements into Resource Description Framework (RDF) statements that are then persisted in a topology service, which maintains an embedded RDF database. This results in information that is mapped and normalized to a standard data model. This enables flexible and efficient support for any source data model (e.g. SMI-S, SNMP MIB).","The following simple example shows how SMI-S CIM\/XML data is translated into an RDF statement. The CIM\/XML comes from an instance of a CIM_ComputerSystem class, which describes a host.","CIM\/XML\n\n","The resulting RDF statement creates a host object in the topology service with a name of \u201cIglor229.1ss.xxx.com\u201d. The response for an RDF database query for instances of host objects would have this host included in its list of host objects. The appliance  surfaces the discovered information to the application components through the topology service. Discovery profiles support two types of profiles to enable discovery, access and discovery. Access profiles encapsulate the credentials used to authenticate and authorize access to a SAN element. This access profile is then associated with a discovery profile that specifies the hostname(s)\/IP (e.g., SAN element or the element's management host). The combination is then used to detect and discover an element. Discovery may be scheduled to occur on a regular interval. Discovery will also occur based on asynchronous events that are generated as the result of changes to the elements. These events include SNMP traps and CIM indications. By default, full rediscoveries occur on a static schedule (daily for hosts and weekly for switches and storage arrays).","Data collection includes a detection phase and a discovery phase. The detection phase validates the ability of the discovery engine to communicate with the software representing the element. The discovery phase collects the element information. The SAN element needs to be associated with the discovery and access profiles appropriate for their type. For example, SMI-S access profiles are required for the array discovery components that provide an SMI-S interface. The discovery engine uses the information provided to enumerate and report the name and type of elements it has discovered. Discovery services then assign components responsibility for discovering the detected elements.",{"@attributes":{"id":"p-0032","num":"0037"},"figref":"FIG. 1A","b":["4","30","4","32","34","36","37","38","40","42","44","46"]},"In general, the SRM application is standards-based meaning that technologies leveraged internally and exposed externally should be standards based. The primary protocols in use are SMI-S for storage element discovery, SNMP for network devices, and WMI and SSH for host discovery. The standards used in the implementation cover both standard protocols (HTTP, SSL) as well as commonly deployed architectural principles (e.g. REST). The primary communication protocol in a RESTful architecture is HTTP, with SSL (i.e. HTTPS) implemented to provide secure communication and authorization between network endpoints. Components communicate via HTTPS. The formats used in the exposure of information are also based on standards such as Atom and JSON.","Managed objects, from a storage array to a user, are resources that are modeled, discovered, managed, and exposed using the most appropriate technology. A HTTP URI (Uniform Resource Identifier) uniquely identifies resources. Note that a URL is a network locator reference, or address of the resource. A resource name is just the name or identifier of the resource. The term URI applies to both of these terms, as both the location of the URL and the name of the URN are unique. HTTP URIs exists in Semantic Web applications that leverage RDF. An HTTP URI is used to identify an object uniquely, within the context of the application. Each resource in the system has a type, which is again uniquely identified by another URI. This includes storage elements (e.g. storage volume, storage port, HBA, switch port), as well as application infrastructure entities (e.g. log file, service, process). All of the instances of these resource types comprise the information model.","Properties, expressed as URIs, are used to associate types and instances of these types. When instances are discovered (e.g. storage array) a unique HTTP URI is created which identifies this new instance, a resource URI. With this newly minted URI, the resource instance can now be associated with other instances and statements may be made about the resource (e.g. \u201cstorageArray1 is Located in Houston\u201d).","Information about resources is exposed using the standards-based representation (e.g. Atom feeds etc.) most appropriate for the task to be accomplished. For example, a list of storage arrays is easily acquired and then divided into discrete pages, by using Atom Feed pagination. A collection of performance metrics for an entire day is most compactly expressed using JSON or CSV.","The system utilizes an event-driven architecture related to Service Oriented Architecture (SOA) to promote the coordination of loosely coupled components to provide intelligent data processing and enable highly scalable systems. In an event-driven architecture, messages representing events are communicated point-to-point or across a shared bus. Components use these messages to trigger analysis and other processes, usually emitting additional messages to communicate state changes.","The system uses messages to communicate including:\n\n","By decoupling the message and the processing related to the message, components can be distributed and aggregated to provide high availability and scalability. Because the interface to the component is a message, any number of components or threads can be deployed to process these messages concurrently, thus increasing the throughput of the system.","Complex Event Processing (CEP) services can be layered over this foundation to create a highly scalable and flexible framework to analyze events generated in a data center in near real-time to provide greater insight and clarity into storage related events. In exemplary embodiments, CEP technology is used to analyze large volumes of performance metrics against performance thresholds, in order to produce events that ultimately result in the creation of alerts. The event-driven architecture and CEP allow large volumes of events (thousands per second) to be processed. This enables near realtime results that can notify a storage administrator as soon as a problem is detected, regardless of the size of the environment under management.","In exemplary embodiments, the SRM application is distributed as a virtual appliance (vApp) that can be deployed and managed through industry standard tools provided by VMware or other virtualization application. Scaling the system is as simple as deploying additional virtual machines (VMs) and distributing the processing among them. Data is federated among VMs using a simple, but secure, mechanism that runs over HTTP using SSL (i.e., HTTPS) and standard TCP ports.",{"@attributes":{"id":"p-0042","num":"0054"},"figref":"FIG. 1B","b":["50","52","54","52","54","54"]},{"@attributes":{"id":"p-0043","num":"0055"},"figref":"FIG. 2","b":["210","212","214"]},{"@attributes":{"id":"p-0044","num":"0056"},"figref":"FIG. 2A","b":["250","252"]},{"@attributes":{"id":"p-0045","num":"0057"},"figref":"FIG. 3","b":["300","302","304","306","308","302","306","308","308","306","310","312","308","306","314","306"],"i":["a","c ","a","d","a","c "]},"The data center  has a number of objects that can be discovered, as shown in . A host layer  includes first and second host bus adapters coupled to respective first and second FC switches in the fabric layer. A disk array enclosure  includes first and second storage processors having respective interfaces coupled to the FC switches ","It is understood that any practical number of arrays, switches, hosts and other components can be coupled in a variety of configuration to meet the needs of a particular application.",{"@attributes":{"id":"p-0048","num":"0060"},"figref":"FIG. 5","b":["500","502","504","506","504","508","504","504","506","506","506"],"i":["a","b","c. "]},"The data collector  analyzes the model  and extracts operations from the model to generate the commands. The requested operations are executed based on input from the requestor and the model. The data collector  collects data from the providers and sends the information back to the requestor.",{"@attributes":{"id":"p-0050","num":"0062"},"figref":"FIG. 6","b":["600","602","604","606","608","610","612"]},{"@attributes":{"id":"p-0051","num":"0063"},"figref":"FIG. 7","b":["700","702","704","706","708","710","712","714","716","718","720","722","720"]},"In the non-parallel, sequential path, in step  commands are executed sequentially. In step , the first command is invoked. In step , the response is extracted to generate new commands. In step , the next command is executed after which processing continues in step ",{"@attributes":{"id":"p-0053","num":"0065"},"figref":["FIG. 8","FIG. 1A"],"b":["800","802","802","802"],"i":["a","b","c"]},"This arrangement provides a number of advantages such as enabling the use of a custom domain logic parser and custom command generator. In one embodiment, the model domain logic is implemented in RDF with domain logic parsed from RDF. Commands are generated based on input parameters and collected data is sent only if all commands are executed successfully.","It is understood that an event can be considered as change in the existing environment (e.g., switch port goes offline, a disk failure cause a volume to inactive, etc.). In one embodiment, an indication DM  () receives the event for notification to a discovery service, as described more fully below. Based on the event type (e.g., switch port offline), appropriate actions (discovery) can be invoked.","Exemplary RDF modeling for VOLUME-INACTIVE in  is set forth below:","VOLUME-INACTIVE Namespace RDF Instance","<!--ReDiscovery Algorithm for Volume InActive Event via SMI-S->","<rdf:Description rdf:about=\u201c#VOLUME-INACTIVE\u201d>\n\n","InActive<\/rdfs:comment>\n\n","Exemplary operations related to a VOLUME-INACTIVE event are set forth below:","<!--get Volume Information Instance-->","<rdf:Description rdf:about=\u201c#getVolumeInformation-Instance\u201d>\n\n","<\/rdf:Description>","Referring to  in conjunction with the above, it can be seen that the Operation-Argument model comprises a unified model that can address a wide variety of device\/protocol discovery use cases. The operation has set of attributes including:\n\n","Data collector  responsibilities include analyzing the model  and extracting operations from the model. With the model information, the command generator  generates commands for operations that are executed based on the input. Data from the provider  is collected and sent back to the requester .","As will be appreciated, in conventional systems, when a volume goes offline, all storage pools have to be discovered first and then all volumes have to rediscovered.","Below model is an example of Discovery of Volume on receiving a VOLUME-INACTIVE event. Here, VOLUME-INACTIVE is being modeled as a namespace. \u201cgetVolumeInformation\u201d is the corresponding method which lies under namespace and includes necessary input Arguments, and the reference on which the method needs to get executed.","<!--Namespaces refers to top level Actions like EVENTBASED-REDISCOVERY, DISCOVERY etc-->","<rdfs:Class rdf:about=\u201c#Namespaces\u201d\/>\n\n","<\/rdfs:comment>","<rdfs:label xml:lang=\u201cen\u201d>Namespaces<\/rdfs:label>","<owl:equivalentClass>\n\n","<\/owl:equivalentClass>","<!--Namespaces can exists without having operations-->","<rdfs:subClassOf>\n\n","\u201cxsd:notNegativeinteger\u201d>0<\/owl:minCardinality>\n\n","<\/rdfs:subClassOf>","<\/rdfs:Class>","Operations:","<rdfs:Class rdf:about=\u201c#Operations\u201d>\n\n","<!--Any instance whose hasInputArgs having the value (for all) \u201cInputArguments\u201d is an instance of Operations, hence equivalent Class-->\n\n","<\/owl: equivalentClass>","<!--Only WSMAN contains Operations nested under operations, hence minCardinality as 0-->","<owl:equivalentClass>\n\n","<\/owl:equivalentClass>","<rdfs:comment>List of SMI-S operations<\/rdfs:comment>","<rdfs:label>Operations<\/rdfs:label>","<\/rdfs:Class>","<!--Object Property-->","<owl:ObjectProperty rdf:about=\u201c#hasOperations\u201d>\n\n","<\/owl:ObjectProperty>","VOLUME-INACTIVE Namespace RDF Instance","<!--ReDiscovery Algorithm for Volume InActive Event via SMI-S-->","<rdf:Description rdf:about=\u201c#VOLUME-INACTIVE\u201d>\n\n","InActive<\/rdfs:comment>\n\n","<!--Modeling SMI Operation getVolumeInformation-->","<rdfs:Class rdf:about=\u201c#getVolumeInformation\u201d>\n\n","<\/rdfs:Class>","<!--get Volume Information Instance-->","<rdf:Description rdf:about=\u201c#getVolumeInformation-Instance\u201d>\n\n","<\/rdf:Description>","Modeling Arguments:","<rdfs:Class rdf:about=\u201c#InputArguments\u201d>\n\n","<\/rdfs:Class>","<rdfs:Class rdf:about=\u201c#CIMObjectPath\u201d>\n\n","<\/rdfs:Class>","<rdf:Description rdf:about=\u201c#Volume-CIMObjectPath\u201d>\n\n","<!--Value will be used as key at runtime to store Volume CIMObjectPath-->\n\n","<rdf:Description>","<!--SMI-S being modeled-->","<rdf:Description rdf:about=\u201c#SMIS-WBEM-Client\u201d>\n\n","<\/rdf:Description>","For an event-based discovery model, discovery of a switch for example, can be split into multiple phases:\n\n","Each phase is modeled as a namespace below. Say, in a Brocade SWITCHPORT DISCOVERY phase, listed the below sequence of Steps performed.\n\n","This model focuses on modeling the entire sequence of SMI-S extrinsic calls for specific namespace, i.e., each SMI-S call to a provider is treated as an operation.","Each Namespace includes multiple Operations. Each Operation includes:\n\n","An exemplary ontology-based model for FC switch discovery, such as the FC switch  of , is set forth below. This .owl specifies the list of classes and relations needed for completing a namespace discovery. In the illustrative embodiment, the model supports SMI-S","<!--Instance-->","<rdf:Description rdf:about=\u201chttp:\/\/ontologies.emc.com\/srm\/baSe\/2011\/10\/srm-smi-domainlogic#BROCADE-SWITCH-SMI\u201d>\n\n","rdf:resource=\u201chttp:\/\/ontologies.emc.com\/srm\/base\/2011\/10\/srm-smi-domainlogic#getSwitchInfo\u201d\/>","<\/rdf:Description>","<rdf:Description rdf:about=\u201chttp:\/\/ontologies.emc.com\/srm\/base\/2011\/10\/srm-smi-domainlogic#getInstance-1\u201d>\n\n","rdf:resource=\u201chttp:\/\/ontologies.emc.com\/srm\/base\/2011\/10\/srm-smi-domainlogic#switchID\u201d\/>\n\n","rdf:resource=\u201chttp:\/\/ontologies.emc.com\/srm\/base\/2011\/10\/srm-smi-domainlogic##ProviderDetails\u201d\/>","<\/rdf:Description>",{"@attributes":{"id":"p-0127","num":"0242"},"figref":"FIG. 9","b":["900","902","904","902","906","902","904","908","910","912","950","914","916","912","918","920","902","940"]},"A discovery appliance  is coupled to the discovery services . In one embodiment, the discovery appliance  includes a path DM , host DM , a SAN DM , a trap DM , an array DM , an OI DM , an indication DM , a TES (topology edit service)  and TS (topology service) populator .","A thread manager  is coupled between the discovery services  and the protocol independent discovery module . A plug in repository  is coupled to the protocol independent discovery module . In the illustrative embodiment, the plug ins include a universal remote REST plug in , a WS plug in , an CLARiiON ECOM Provider plug in , and a Celerra XML API plug in . It is understood that a variety of other plug ins can also be included.",{"@attributes":{"id":"p-0130","num":"0245"},"figref":["FIG. 10","FIG. 9","FIG. 5"],"b":["1000","1002","940","1002","1004","1002","1006","504"]},{"@attributes":{"id":"p-0131","num":"0246"},"figref":"FIG. 11","b":["1100","1100","1102","1102","1104","1104","1106","1108","1110","112","1114","1103"]},{"@attributes":{"id":"p-0132","num":"0247"},"figref":["FIG. 12","FIG. 11","FIG. 9"],"b":["1200","1100","1202","1204","940","1206","1204","1204","1210","1210","1204","1200"]},{"@attributes":{"id":"p-0133","num":"0248"},"figref":"FIG. 13","b":["1300","1302","1304","1306","1308","1302","1310","1312","1314","1316","1318","1304","1320","1324","1326","1304","1302","1302","1328","1306","1330","1332","1308","1334","1336","1300","1338"]},{"@attributes":{"id":"p-0134","num":"0249"},"figref":"FIG. 14","b":["1400","1402","1404","1406","1408","1410","1412","1414","1416","1418","1420","1422","1424","1426","1428","1430"]},"It is understood that a variety of topology tasks can be created. For example, for an array toplogy task, the following are discovered.\n\n","A switch topology task can discover the following:\n\n","The task manager processes the topology data  for the transformation service which provides transformation status  to the task manager. The transformation data is processed  for the topology service which sends a processing done notification  to the task manager. The processed data is sent  to the capacity server which sends a done notification  to the task manager. Capacity data is then collected  and sent  to the transformation service, which generates a success notification  after which the task is updated . The capacity data is processed  after which a success notification  is sent to the task manager. Performance data is then collected  and sent  to the performance data collection server . A success notification  is sent to the collector and the task is updated .",{"@attributes":{"id":"p-0138","num":"0262"},"figref":"FIG. 15","b":["1500","1500","1502","1504","1506","1508","1506","1512","1516","1518","1512","1502","1504","1520"]},"Processing may be implemented in hardware, software, or a combination of the two. Processing may be implemented in computer programs executed on programmable computers\/machines that each includes a processor, a storage medium or other article of manufacture that is readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and one or more output devices. Program code may be applied to data entered using an input device to perform processing and to generate output information.","The system can perform processing, at least in part, via a computer program product, (e.g., in a machine-readable storage device), for execution by, or to control the operation of, data processing apparatus (e.g., a programmable processor, a computer, or multiple computers)). Each such program may be implemented in a high level procedural or object-oriented programming language to communicate with a computer system. However, the programs may be implemented in assembly or machine language. The language may be a compiled or an interpreted language and it may be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program may be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network. A computer program may be stored on a storage medium or device (e.g., CD-ROM, hard disk, or magnetic diskette) that is readable by a general or special purpose programmable computer for configuring and operating the computer when the storage medium or device is read by the computer. Processing may also be implemented as a machine-readable storage medium, configured with a computer program, where upon execution, instructions in the computer program cause the computer to operate.","Processing may be performed by one or more programmable processors executing one or more computer programs to perform the functions of the system. All or part of the system may be implemented as, special purpose logic circuitry (e.g., an FPGA (field programmable gate array) and\/or an ASIC (application-specific integrated circuit)).","Having described exemplary embodiments of the invention, it will now become apparent to one of ordinary skill in the art that other embodiments incorporating their concepts may also be used. The embodiments contained herein should not be limited to disclosed embodiments but rather should be limited only by the spirit and scope of the appended claims. All publications and references cited herein are expressly incorporated herein by reference in their entirety."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing features of this invention, as well as the invention itself, may be more fully understood from the following description of the drawings in which:",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 1A","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 1B","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
