---
title: Unified policy management for extensible virtual switches
abstract: Systems, methods, and computer storage media are described herein that configure a switch extension associated with a virtual switch with one or more settings. In response to the configuring, the systems, methods, and computer storage media persist the one or more settings and apply the persisted one or more settings to a target switch extension of a target virtual switch. The systems, methods, and computer storage media receive the settings through a management interface. Also, the systems, methods, and computer storage media receive requests for information associated with the switch extension and provide the switch extension information in response.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08797914&OS=08797914&RS=08797914
owner: Microsoft Corporation
number: 08797914
owner_city: Redmond
owner_country: US
publication_date: 20110912
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["With the advent of the Internet and other data networks, the importance of mechanisms enabling communication has grown significantly. Computing devices are typically equipped with network stacks for managing the sending and receiving of network packets, and these stacks are often organized in accordance with one or more protocols. For example, network stacks may conform to the Open Systems Interconnection (OSI) model and include interfaces linking the layers of the OSI model. One example of such interfaces is provided by the Network Driver Interface Specification (NDIS) logical link control. An NDIS logical link control forms the upper sublayer of the OSI data link layer and provides an interface between the data link layer of the OSI model and the network layer of the OSI model.","The NDIS logical link control often includes filter modules, such as NDIS lightweight filters, that act as filters on traffic through the network stack. For example, a filter module of the NDIS logical link control may provide firewall functionality by blocking transmission through the network stack of data packets associated with a specific Internet Protocol (IP) address.","Also, as computing devices have advanced, the use of virtualization has become more prevalent. Many computer systems utilize virtual machines in order to host multiple operating systems on the same device and provide a virtual machine manager (VMM) or hypervisor to act as an interface between the virtual machines of a device and the device's hardware. The VMM or hypervisor often implements a virtual switch to provide networking between virtual machines on the device and between those virtual machines and other devices. In Hyper-V, for example, a parent partition (or root virtual machine) implements the virtual switch and a hypervisor acts as an interface between the device hardware and the virtual machines.","When networking with a device using virtualization, however, the above-described filter modules can only be implemented in the network stack associated with the device drivers of the network interface hardware of the device. Filter modules, such as NDIS lightweight filters, are not designed to be implemented in a virtual stack of a virtual switch or of a virtual network interface. Thus, traditional filter modules can only filter traffic to or from the device, but not intra-device traffic from one virtual machine to another.","To enable filtering by a virtual switch and other configurations of a virtual switch, the virtual stack of the virtual switch may be enhanced with switch extensions. These switch extensions may be provided by third party application developers, but may lack mechanisms to receive settings or to persist those settings for purposes of live migration, repair, or back-up. To provide these mechanisms, a management interface, serializer\/deserializer component of a VMM service, and a virtual switch of a root virtual machine are configured to receive settings, transform those settings, and provide the transformed settings to the switch extensions. Upon successful configuration of the switch extensions, the root virtual machine persists the settings in a configuration file. During live migration, repair, or back-up, the configuration file is applied to a target virtual switch, providing the switch extensions of the target switch with the persisted settings.","In addition to enabling application of settings to target virtual switches, the components of the root virtual machine are also configured to receive requests for information associated with switch extensions, to provide those requests to switch extensions, and to answer the requests with information received from the switch extensions. Such information may include settings and performance metrics of the switch extensions.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Described herein are techniques for configuring switch extensions of virtual switches with settings, persisting those settings, and applying the persisted settings to switch extensions of target virtual machines. These techniques are implemented by a root virtual machine, such as the parent partition in Hyper-V. The switch extensions include filter modules implemented in the virtual stack of the virtual switch to filter traffic to or from a virtual machine of the host device. A management interface of the root virtual machine, such as a Windows Management Instrumentation (WMI) interface, receives the settings and may also be configured to receive requests for information associated with switch extensions. Such information could include settings or performance metrics. The management interface provides the settings or request in the form of an object, such as a WMI object, to a serializer\/deserializer component of a VMM service. The object may include an identification of a schema, such as a Managed Object Format (MOF) file, that is associated with the switch extension that the settings or request are intended for. The serializer\/deserializer component generates a binary representation of the settings or an empty binary representation of the request and provides the binary representation or empty binary representation, along with attributes derived from the schema, to a driver of a virtual switch implemented in the root virtual machine. In some embodiments, the binary representation\/empty binary representation and attributes are provided using a device input\/output control (IOCTL) call to the driver. The driver then packs the binary representation\/empty binary representation and attributes into a structure, such as a C structure, a NDIS structure, or some other data structure, and provides the structure to the switch extension. In some embodiments, the structure is provided using an object identifier (OID) request.","In various embodiments, when the provided structure includes a binary representation of settings and the switch extension indicates that it has been successfully configured with the settings, the VMM service or another component of the root virtual machine persists the settings in a configuration file, such as a virtual machine configuration file. The configuration file is then used in subsequent operations, such as live migrations, repairs, or back-ups, to configure a switch extension of a target virtual switch.","In further embodiments, when the provided structure includes an empty binary structure that corresponds to a request, the switch extension may populate the empty binary structure with the requested information and return a structure including the populated binary representation to the driver of the virtual switch. The driver of the virtual switch then unpacks the populated binary representation and attributes and provides them to the serializer\/deserializer component. The serializer\/deserializer component then deserializes the populated binary representation into an object and provides the object to the management interface. The management interface then answers the request for information based on the contents of the object.","Example Overview",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 1"],"b":["102","104","106","106","104","108","104","110","112","110","110","114","110","114","116","116","116","102","118","102","120","122"]},"In various embodiments, the host device may be any sort of computing device or computing devices. For example, the host device may be or include a personal computer (PC), a laptop computer, a server or server farm, a mainframe, a tablet computer, a work station, a telecommunication device, a personal digital assistant (PDA), or any other sort of device or devices. In one implementation, the host device represents a plurality of computing devices working in communication, such as a cloud computing network of nodes. When implemented on multiple computing devices, the computing device  may distribute the root virtual machine  on one or more of the devices and other virtual machines among others of the multiple devices. An example host device is illustrated in  and is described below in greater detail with reference to that figure.","In some implementations, a network or networks may connect multiple devices represented by the host device, as mentioned above. The network or networks may also connect the host device to one or more other devices. The network or networks may be any one or more networks, such as wide area networks (WANs), local area networks (LANs), or the Internet. Also, the network or networks may be public, private, or include both public and private networks. Further, the network or networks may be wired, wireless, or include both wired and wireless networks. The network or networks may utilize any one or more protocols for communication, such as the Transmission Control Protocol\/Internet Protocol (TCP\/IP), other packet based protocols, or other protocols.","In various embodiments, as mentioned above, the root virtual machine  is a parent partition in Hyper-V. As shown in , the root virtual machine  includes the management interface , schema repository , serializer\/deserializer component , VMM service , virtual switch , switch extension , and configuration file . The root virtual machine  may also include other components, such as a virtual network interface, virtual device drivers, etc. In one embodiment, the operator  may also be implemented in the root virtual machine .","In some embodiments, some components of the root virtual machine  are associated with a user mode , while others are associated with kernel mode . As shown in , the management interface , schema repository , serializer\/deserializer component , VMM service , and configuration file are associated with the user mode , and the virtual switch  and switch extension  are associated with the kernel mode . The user mode  and kernel mode  may be associated with different protection domains. In one embodiment, the user mode  may be associated with a least privileged protection domain and the kernel mode  may be associated with a most privileged protection domain.","In various embodiments, the management interface  may be or include an application programming interface (API), such as the API of a WMI interface. The management interface  enables an operator  to provide settings for the switch extension  and to request information associated with the switch extension . Settings may be provided by invoking a specific function of the management interface  and by identifying a schema stored in the schema repository . In one embodiment, the same function may be invoked to provide settings of any kind for any switch extension , with the identified schema providing particulars of the switch extension . In other embodiments, the management interface  may include multiple functions to provide settings, each of which may be specific to a group or type of switch extensions  or to a particular switch extension . The output of these one or more functions is an object, such as a WMI object, that includes the provided settings and an identifier of the schema. In one embodiment, the settings are specified in a Common Information Model (CIM) MOF syntax and associated with a specific base class that is defined by the root virtual machine  for providing settings. These specified settings may be received by the management interface  through shell or command-line entry, through a form or other user interface, or through a file, such as a text or extensible markup language (XML) file. Such a shell or interface may be provided by the management interface , by the operator , or by another component.","In some embodiments, the management interface  may provide one or more functions for retrieving information associated with the switch extension . The one or more functions may comprise a single function for retrieving all information associated with the switch extension  (e.g., settings and performance metrics), a single function or group of functions that enable the operator  to specify the type of information requested through a request identifier or request type, or functions specific to one or more items of switch extension information. In one embodiment, the request may specify a schema associated with the switch extension  to enable the root virtual machine  to determine which switch extension  the request is directed to. In such an embodiment, the schema identifier serves as a switch extension identifier. Upon receiving the request, the management interface  generates an empty object, such as a WMI object, that includes the identifier of the schema\/switch extension .","Also, in some embodiments, the management interface  may receive answers to the requests at one or more functions from the serializer\/deserializer component . The answers may be provided as WMI objects populated with the requested information. Responsive to receiving the answers, the management interface  may provide answers to the responses. Such answers may be provided to an application, file, or user associated with or included in the operator .","In various embodiments, the operator  represents any source of input to the management interfaces . The operator  may include one or more modules implemented in a virtual machine of the host device, either in the root virtual machine  or in another virtual machine. The operator  may also or instead include one or more modules implemented on another device. These modules of the operator  enable a user or device to specify the settings or request in the manner described above. They may, for example, provide a command-line, shell, or other user interface. The operator  may also include one or more files specifying the settings or a data store of such files to select from and provide to the management interface . Further, the operator  may include an application that seeks to configure and monitor switch extensions. For example, the operator  could include a security program that monitors data connections and traffic of one of the virtual machines of the host device, and the switch extension could be a filter associated with that security program. Such a program could provide settings (e.g., permissible IP addresses to communicate with) and request performance metrics (e.g., number of connections blocked by the switch extension).","In some embodiments, as mentioned above, the settings or requests provided by the operator  include an identification of a schema associated with a switch extension , and that schema identifier may also serve as an identifier of the switch extension . The schema identifiers identify schemas, such as MOF files, stored in the schema repository  of the root virtual machine . This schema repository  may be an example of a MOF file repository or a WMI repository. The schema repository  may be any sort of data store, such as a relational database. In one embodiment, the schema repository  may instead be located on another virtual machine or device. The schema repository  may include at least one schema for each switch extension , the schema or schemas defining attributes of the switch extension  for which setting values may be provided. The schema or schemas may also specify other metadata of its\/their associated switch extension . Schemas may be registered in and stored in the schema repository  prior to, concurrent with, or after installation of their associated switch extensions .","In various embodiments, the object generated by the management interface , such as a WMI object, is provided by the management interface  to a serializer\/deserializer component  of a VMM service . While the serializer\/deserializer component  is shown as a single component, the serializer\/deserializer component  may comprise separate serializer and deserializer components. Upon receiving an object, such as a WMI object including settings or an empty WMI object, the serializer\/deserializer component  determines if the object is associated with a specific base class, that base class indicating that the object is a settings object or a request. The serializer\/deserializer component  then serializes the object into a binary representation. This process may include, for example, mapping strings and other value types into bit patterns. In one embodiment, the mapping is based at least partly on information included in the schema that is identified by the object. For empty objects, the serializing may simply involving utilizing a default binary representation. The serializer\/deserializer component  then provides the binary representation and attributes derived from the schema to the driver of the switch extension  via a device IOCTL call or through some other communication type or message.","The serializer\/deserializer component  also receives binary representations and attributes from the driver of the virtual switch . These binary representations and attributes may also be provided via a device IOCTL call and may correspond to a request, representing the information provided in answer to the request. Upon receiving the binary representation and attributes, the serializer\/deserializer component  deserializes the binary representation into an object, such as a WMI object. This process may include mapping bit patterns to strings and other value types and may be based at least in part on the attributes or on the schema corresponding to the attributes. Upon generating the object from the binary representation, the serializer\/deserializer component  provides the object to the management interface  by, for example, invoking a function of the management interface .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["110","110","202","204","202","206","208","110","208","204","110","206","208","206","202","110","208","204"]},"Referring again to , the VMM service  is a component of the root virtual machine  that handles one or more management operations of the root virtual machine . As shown, the VMM services  may include the serializer\/deserializer component . The VMM service  may also include other components to manage or interact with other aspects of the virtual switch , with a virtual network interface of the root virtual machine , or with one or more other administrative or platform processes. In one embodiment, the VMM service  persists the one or more received switch extension setting in response to being notified that configuration of the switch extension  was successful. The VMM service  persists the settings by updating the virtual machine configuration file  to reflect the current settings of the root virtual machine , which include settings of the virtual switch  and the switch extension . This snapshot of the settings comprising the configuration file  may be stored in a database, in a file, or in any sort of data structure. In other embodiments, a different component of the root virtual machine  persists the one or more settings in the configuration file .","In some embodiments, as mentioned above, a driver of the virtual switch  receives binary representations and attributes from the serializer\/deserializer component  via device IOCTL calls and provides binary representations and attributes to the serializer\/deserializer component  via device IOCTL calls. The driver may act as an interface to the virtual switch  for other components of the root virtual machine  and other systems. The virtual switch  may be any sort of virtual switch, such as the virtual switch of the parent partition utilized in Hyper-V. Such a virtual switch  may enable communication between virtual machines on a same host device and between any of those virtual machine and other devices. The virtual switch  may also include a virtual stack and an interface enabling application developers to provide switch extensions  that plug into the virtual stack as filter modules. In response to an invocation of that interface, an application developer (which could include operator ) or some other party may provide the switch extension . In one embodiment, the interface also enables the application developer to provide a schema, such as a MOF file, which is stored in the schema repository. In other embodiments, the schema is provided separately without involvement of the interface of the virtual switch .","The driver of the virtual switch  is also configured to pack received binary representations and attributes into a structure, such as a C structure, NDIS structure, or other data structure, and provide the structure to a switch extension . In one embodiment, the attributes identify which switch extension  that the structure should be provided to. The driver provides the structure to the switch extension  by means of a request, such as an OID request. If the provided structure represents a request for information from a switch extension , the attributes packed in the structure may identify the type of request or the type of information requested.","In addition to providing a structure to a switch extension , the driver of the virtual switch  also receives structures from switch extensions. Such a structure may be provided through an OID response to an OID request when the structure provided through the OID request represents a request for information from a switch extension . In response to receiving a structure, the driver unpacks the binary representation and attributes and provides the binary representation and, optionally, the attributes, to the serializer\/deserializer component  through a device IOCTL call.","As shown in , that figure illustrates an example of inputs and outputs pairs received and generated by the operations of the driver of the virtual switch . For example, the driver may receive a binary representation  and attributes  as an input pair and pack the binary representation  and attributes  into a structure  as an output to be provided to the switch extension  via an OID request. The driver may also receive the structure  as an input via an OID response and unpack the binary representation  and attributes  from the structure  to provide as an output pair to the serializer\/deserializer component . Also, as mentioned above, in some embodiments, the driver only provides the binary representation  to the serializer\/deserializer component  as an output.","Returning again to , the switch extension  is a filter module implemented in the virtual stack of the virtual switch  to filter traffic to or from a virtual machine of the host device. As mentioned above, the switch extension  may be provided through an interface, such as an interface of the virtual switch , or through some other interface of the root virtual machine . In some embodiments, switch extensions  may have many characteristics of NDIS lightweight filters and may occupy the upper sublayer of the data link layer of the virtual stack, just as NDIS lightweight filters occupy the analogous layer of the network stack. Each switch extension  may have zero, one, or more settings that may be configured by the switch extension  responsive to receiving an OID request that includes the settings. The switch extension  may also be configured to respond to requests for information. The information provided in response may include one or both of settings and performance metrics. Such performance metrics could include, for example, a count of connections blocked by the switch extension . In responding to the request, the switch extension  populates a binary representation part of a structure with the requested information.","Example Operations",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIGS. 3-5"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 3","FIG. 4"],"b":"302"},"At block , in response to configuring the switch extension with the one or more settings, the root virtual machine persists the one or more settings. In some embodiments, a VMM service or other component of the root virtual machine persists the one or more settings by storing the one or more settings in a virtual machine configuration file.","At block , the persisted one or more settings are applied to a target switch extension of a target virtual switch. In some embodiments, the settings are applied as part of a configuration file during a live migration, repair, or back-up operation.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":"402"},"At block , the management interface provides the settings as a WMI object to a serializer component that serializes the WMI object into a binary format. In some embodiments, the serializing is based on the MOF file schema. In some embodiments, the serializer component is configured to serialize received objects associated with a specific base class. At block , the serializer component then provides the binary representation and attributes derived from the MOF file schema to driver of the virtual switch. The binary representation and attributes may be provided using a device IOCTL call.","At block , the virtual switch driver receives the binary representation of the settings and the attributes and packs them in a structure, such as a C structure, a NDIS structure, or another type of data structure. At block , upon packing the binary representation and the attributes in the structure, the virtual switch driver provides the structure to the switch extension. In some embodiments, the virtual switch driver provides the structure by making an OID request of the switch extension.","At decision block , the root virtual machine determines if the switch extension has been successfully configured with the settings. The root virtual machine may make the determination based on a response from the switch extension indicating success or failure. At block , if the response indicates success, a VMM service or other component of the root virtual machine persists the settings in the manner shown in  and described above with reference to that figure. If the response indicates failure, the operator providing the settings may be notified of the failure via the management interface, and the operator may retry providing the settings, as described above with reference to block .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 5","b":["502","504"]},"At block , the serializer component generates an empty binary representation corresponding to the empty WMI object and sends the empty binary representation to a driver of the virtual switch. In one embodiment, the binary representation is provided to the driver via a device IOCTL call.","At block , the virtual switch driver creates an empty structure, such as an empty C structure, NDIS structure, or other data structure and provides the structure to the switch extension via an OID request.","At block , the virtual switch driver receives a structure in response to the OID request populated by the switch extension with the requested information in a binary representation. At block , the virtual switch driver unpacks the binary representation from the structure and also unpacks attributes associated with the switch extension. The attributes may have been derived from the schema or provided by the switch extension. The virtual switch driver then returns the unpacked binary representation and attributes to a deserializer component via a device IOCTL call.","At block , the deserializer component deserializes the binary representation, in some embodiments based on the attributes, generating a WMI object that includes the request information. The deserializer component then provides the WMI object to the management interface.","At block , the management interface responds to the request with the information based on the contents of the WMI object.","Example System Architecture",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 6","b":["102","600","602","102","604","606","102","604","606","600","102","604"]},"Memory  may store program instructions that are loadable and executable on the processor(s)  (described further below), as well as data generated during the execution of these programs. Depending on the configuration and type of computing device, memory  may be volatile (such as random access memory (RAM)) and\/or non-volatile (such as read-only memory (ROM), flash memory, etc.). The computing device or server may also include additional removable storage  and\/or non-removable storage  including, but not limited to, magnetic storage, optical disks, and\/or tape storage. The disk drives and their associated computer-readable media may provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for the computing devices. In some implementations, the memory  may include multiple different types of memory, such as static random access memory (SRAM), dynamic random access memory (DRAM), or ROM.","Computer-readable media includes, at least, two types of computer-readable media, namely computer storage media and communications media.","Computer storage media includes volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, erasable programmable read-only memory (EEPROM), flash memory or other memory technology, compact disc read-only memory (CD-ROM), digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other non-transmission medium that can be used to store information for access by a computing device.","In contrast, communication media may embody computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave, or other transmission mechanism. As defined herein, computer storage media does not include communication media.","The host computing device  may also include one or more processing units (or processor(s)) . The processor(s)  may be implemented as appropriate in hardware, software, firmware, or combinations thereof. Software or firmware implementations of the processor(s)  may include computer-executable or machine-executable instructions written in any suitable programming language to perform the various functions described. Processor(s)  may also or alternatively include one or more graphic processing units (GPUs).","The host computing device  may further contain communications connection(s)  that allow the host computing device  to communicate with a stored database, another computing device or server, user terminals, and\/or other devices on a network. The host computing device  may also include input device(s) , such as a keyboard, mouse, pen, voice input device, touch input device, etc., and output device(s) , such as a display, speakers, printer, etc.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description is set forth with reference to the accompanying figures, in which the left-most digit of a reference number identifies the figure in which the reference number first appears. The use of the same reference numbers in different figures indicates similar or identical items or features.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
