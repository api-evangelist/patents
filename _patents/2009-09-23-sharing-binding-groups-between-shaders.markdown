---
title: Sharing binding groups between shaders
abstract: A system and method for sharing binding groups between shaders allows for efficient use of shader state data storage resources. In contrast with conventional graphics processors and Application Programming Interfaces that specify a set of binding points for each shader that are exclusive to that shader, two or more shaders may reference the same binding group that includes multiple binding points. As the number and variety of different shaders increases, the number of binding groups may increase at a slower rate since some binding groups may be shared between different shaders.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08749562&OS=08749562&RS=08749562
owner: NVIDIA Corporation
number: 08749562
owner_city: Santa Clara
owner_country: US
publication_date: 20090923
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","System Overview","Processing Cluster Array Overview","Graphics Pipeline Architecture","Sharing a Binding Group Between Shaders"],"p":["1. Field of the Invention","The present invention generally relates to binding groups that store shader state data and more specifically to sharing binding groups between shader programs.","2. Description of the Related Art","In conventional graphics systems a binding point that references shader state data used to process graphics data is defined and referenced by each shader program. Specifically, there is a one-to-one pairing between binding points and shader programs. In current systems a limited number of binding points are available for use by shaders since the shader state data occupies a significant amount of memory. As the number of shaders increases, the amount of memory needed to store the shader state data referenced by each binding point also increases as does the memory bandwidth that is consumed to access the shader state data.","Accordingly, what is needed in the art is a system and method for sharing binding points between two or more shaders.","A system and method for sharing binding points organized in binding groups between shaders allows for efficient use of shader state data storage resources. In contrast with conventional graphics processors and Application Programming Interfaces that specify a collection of binding points for each shader, two or more shaders may reference the same binding points that are organized as a binding group. As the number and variety of different shaders increases, the number of binding groups may increase at a slower rate since some binding groups may be shared between different shaders. When one or more binding points in a binding group are changed, the changed binding point(s) is seen by all shaders that reference the binding group.","Various embodiments of a method of the invention for sharing binding groups include generating a first binding group of shader state data and configuring a first shader program to reference the first binding group. A second shader program is also configured to reference the first binding group and graphics data is processed by executing the first shader program and the second shader program to produce processed graphics data that is stored in a memory or displayed on a display device.","Various embodiments of the invention include a system for sharing binding groups. The system includes a processor that is configured to generate a first binding group of shader state data and configure a first shader program to reference the first binding group. A second shader program is also configured to reference the first binding group and graphics data is processed by executing the first shader program and the second shader program to produce processed graphics data that is stored in a memory or displayed on a display device.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the present invention. However, it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the present invention.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","100","102","104","105","105","102","105","102","105","106","107","107","108","102","106","105","112","105","113","112","110","114","107","116","107","118","120","121","107"]},"In one embodiment, the parallel processing subsystem  incorporates circuitry optimized for graphics and video processing, including, for example, video output circuitry, and constitutes a graphics processing unit (GPU). In another embodiment, the parallel processing subsystem  incorporates circuitry optimized for general purpose processing, while preserving the underlying computational architecture, described in greater detail herein. In yet another embodiment, the parallel processing subsystem  may be integrated with one or more other system elements, such as the memory bridge , CPU , and I\/O bridge  to form a system on chip (SoC).","It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology, including the number and arrangement of bridges, may be modified as desired. For instance, in some embodiments, system memory  is connected to CPU  directly rather than through a bridge, and other devices communicate with system memory  via memory bridge  and CPU . In other alternative topologies, parallel processing subsystem  is connected to I\/O bridge  or directly to CPU , rather than to memory bridge . In still other embodiments, one or more of CPU , I\/O bridge , parallel processing subsystem , and memory bridge  may be integrated into one or more chips. The particular components shown herein are optional; for instance, any number of add-in cards or peripheral devices might be supported. In some embodiments, switch  is eliminated, and network adapter  and add-in cards ,  connect directly to I\/O bridge .",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["112","112","202","204","202","204"]},"Referring again to , in some embodiments, some or all of PPUs  in parallel processing subsystem  are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU  and\/or system memory , interacting with local parallel processing memory  (which can be used as graphics memory including, e.g., a conventional frame buffer) to store and update pixel data, delivering pixel data to display device , and the like. In some embodiments, parallel processing subsystem  may include one or more PPUs  that operate as graphics processors and one or more other PPUs  that are used for general-purpose computations. The PPUs may be identical or different, and each PPU may have its own dedicated parallel processing memory device(s) or no dedicated parallel processing memory device(s). One or more PPUs  may output data to display device  or each PPU  may output data to one or more display devices .","In operation, CPU  is the master processor of computer system , controlling and coordinating operations of other system components. In particular, CPU  issues commands that control the operation of PPUs . In some embodiments, CPU  writes a stream of commands for each PPU  to a command buffer (not explicitly shown in either  or ) that may be located in system memory , parallel processing memory , or another storage location accessible to both CPU  and PPU . PPU  reads the command stream from the command buffer and then executes commands asynchronously relative to the operation of CPU . CPU  may also create data buffers that PPUs  may read in response to commands in the command buffer. Each command and data buffer may be read by each of PPUs .","Referring back now to , each PPU  includes an I\/O (input\/output) unit  that communicates with the rest of computer system  via communication path , which connects to memory bridge  (or, in one alternative embodiment, directly to CPU ). The connection of PPU  to the rest of computer system  may also be varied. In some embodiments, parallel processing subsystem  is implemented as an add-in card that can be inserted into an expansion slot of computer system . In other embodiments, a PPU  can be integrated on a single chip with a bus bridge, such as memory bridge  or I\/O bridge . In still other embodiments, some or all elements of PPU  may be integrated on a single chip with CPU .","In one embodiment, communication path  is a PCI-Express link, in which dedicated lanes are allocated to each PPU , as is known in the art. Other communication paths may also be used. An I\/O unit  generates packets (or other signals) for transmission on communication path  and also receives all incoming packets (or other signals) from communication path , directing the incoming packets to appropriate components of PPU . For example, commands related to processing tasks may be directed to a host interface , while commands related to memory operations (e.g., reading from or writing to parallel processing memory ) may be directed to a memory crossbar unit . Host interface  reads each command buffer and outputs the work specified by the command buffer to a front end .","Each PPU  advantageously implements a highly parallel processing architecture. As shown in detail, PPU () includes a processing cluster array  that includes a number C of general processing clusters (GPCs) , where C\u22671. Each GPC  is capable of executing a large number (e.g., hundreds or thousands) of threads concurrently, where each thread is an instance of a program. In various applications, different GPCs  may be allocated for processing different types of programs or for performing different types of computations. For example, in a graphics application, a first set of GPCs  may be allocated to perform tessellation operations and to produce primitive topologies for patches, and a second set of GPCs  may be allocated to perform tessellation shading to evaluate patch parameters for the primitive topologies and to determine vertex positions and other per-vertex attributes. The allocation of GPCs  may vary depending on the workload arising for each type of program or computation. Alternatively, GPCs  may be allocated to perform processing tasks using a time-slice scheme to switch between different processing tasks.","GPCs  receive processing tasks to be executed via a work distribution unit , which receives commands defining processing tasks from front end unit . Processing tasks include pointers to data to be processed, e.g., surface (patch) data, primitive data, vertex data, and\/or pixel data, as well as state parameters and commands defining how the data is to be processed (e.g., what program is to be executed). Work distribution unit  may be configured to fetch the pointers corresponding to the processing tasks, may receive the pointers from front end , or may receive the data directly from front end . In some embodiments, indices specify the location of the data in an array. Front end  ensures that GPCs  are configured to a valid state before the processing specified by the command buffers is initiated.","When PPU  is used for graphics processing, for example, the processing workload for each patch is divided into approximately equal sized tasks to enable distribution of the tessellation processing to multiple GPCs . A work distribution unit  may be configured to output tasks at a frequency capable of providing tasks to multiple GPCs  for processing. In some embodiments of the present invention, portions of GPCs  are configured to perform different types of processing. For example a first portion may be configured to perform vertex shading and topology generation, a second portion may be configured to perform tessellation and geometry shading, and a third portion may be configured to perform pixel shading in screen space to produce a rendered image. The ability to allocate portions of GPCs  for performing different types of processing tasks efficiently accommodates any expansion and contraction of data produced by those different types of processing tasks. Intermediate data produced by GPCs  may be buffered to allow the intermediate data to be transmitted between GPCs  with minimal stalling in cases where the rate at which data is accepted by a downstream GPC  lags the rate at which data is produced by an upstream GPC .","Memory interface  may be partitioned into a number D of memory partition units that are each coupled to a portion of parallel processing memory , where D\u22671. Each portion of parallel processing memory  generally includes one or more memory devices (e.g DRAM ). Persons skilled in the art will appreciate that DRAM  may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets, such as frame buffers or texture maps may be stored across DRAMs , allowing partition units  to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .","Any one of GPCs  may process data to be written to any of the DRAMs  within parallel processing memory . Crossbar unit  is configured to route the output of each GPC  to the input of any partition unit  or to another GPC  for further processing. GPCs  communicate with memory interface  through crossbar unit  to read from or write to various external memory devices. In one embodiment, crossbar unit  has a connection to memory interface  to communicate with I\/O unit , as well as a connection to local parallel processing memory , thereby enabling the processing cores within the different GPCs  to communicate with system memory  or other memory that is not local to PPU . Crossbar unit  may use virtual channels to separate traffic streams between the GPCs  and partition units .","Again, GPCs  can be programmed to execute processing tasks relating to a wide variety of applications, including but not limited to, linear and nonlinear data transforms, filtering of video and\/or audio data, modeling operations (e.g., applying laws of physics to determine position, velocity and other attributes of objects), image rendering operations (e.g., tessellation shader, vertex shader, geometry shader, and\/or pixel shader programs), and so on. PPUs  may transfer data from system memory  and\/or local parallel processing memories  into internal (on-chip) memory, process the data, and write result data back to system memory  and\/or local parallel processing memories , where such data can be accessed by other system components, including CPU  or another parallel processing subsystem .","A PPU  may be provided with any amount of local parallel processing memory , including no local memory, and may use local memory and system memory in any combination. For instance, a PPU  can be a graphics processor in a unified memory architecture (UMA) embodiment. In such embodiments, little or no dedicated graphics (parallel processing) memory would be provided, and PPU  would use system memory exclusively or almost exclusively. In UMA embodiments, a PPU  may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high-speed link (e.g., PCI-Express) connecting the PPU  to system memory via a bridge chip or other communication means.","As noted above, any number of PPUs  can be included in a parallel processing subsystem . For instance, multiple PPUs  can be provided on a single add-in card, or multiple add-in cards can be connected to communication path , or one or more PPUs  can be integrated into a bridge chip. PPUs  in a multi-PPU system may be identical to or different from one another. For instance, different PPUs  might have different numbers of processing cores, different amounts of local parallel processing memory, and so on. Where multiple PPUs  are present, those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs  may be implemented in a variety of configurations and form factors, including desktop, laptop, or handheld personal computers, servers, workstations, game consoles, embedded systems, and the like.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 3A","FIG. 2"],"b":["208","202","208","208"]},"In graphics applications, a GPC  may be configured to implement a primitive engine for performing screen space graphics processing functions that may include, but are not limited to primitive setup, rasterization, and z culling. The primitive engine receives a processing task from work distribution unit , and when the processing task does not require the operations performed by primitive engine, the processing task is passed through the primitive engine to a pipeline manager . Operation of GPC  is advantageously controlled via a pipeline manager  that distributes processing tasks to streaming multiprocessors (SPMs) . Pipeline manager  may also be configured to control a work distribution crossbar  by specifying destinations for processed data output by SPMs .","Also, each SPM  advantageously includes an identical set of functional units (e.g., arithmetic logic units, etc.) that may be pipelined, allowing a new instruction to be issued before a previous instruction has finished, as is known in the art. Any combination of functional units may be provided. In one embodiment, the functional units support a variety of operations including integer and floating point arithmetic (e.g., addition and multiplication), comparison operations, Boolean operations (AND, OR, XOR), bit-shifting, and computation of various algebraic functions (e.g., planar interpolation, trigonometric, exponential, and logarithmic functions, etc.); and the same functional-unit hardware can be leveraged to perform different operations.","In one embodiment, each GPC  includes a number M of SPMs , where each SPM  configured to process one or more thread groups. The series of instructions transmitted to a particular GPC  constitutes a thread, as previously defined herein, and the collection of a certain number of concurrently executing threads across the parallel processing engines (not shown) within an SPM  is referred to herein as a \u201cthread group.\u201d As used herein, a \u201cthread group\u201d refers to a group of threads concurrently executing the same program on different input data, with each thread of the group being assigned to a different processing engine within an SPM . A thread group may include fewer threads than the number of processing engines within the SPM , in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SPM , in which case processing will take place over multiple clock cycles. Since each SPM  can support up to G thread groups concurrently, it follows that up to G\u00d7M thread groups can be executing in GPC  at any given time.","Additionally, a plurality of related thread groups may be active (in different phases of execution) at the same time within an SPM . This collection of thread groups is referred to herein as a \u201ccooperative thread array\u201d (\u201cCTA\u201d). The size of a particular CTA is equal to m*k, where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SPM , and m is the number of thread groups simultaneously active within the SPM . The size of a CTA is generally determined by the programmer and the amount of hardware resources, such as memory or registers, available to the CTA.","An exclusive local address space is available to each thread, and a shared per-CTA address space is used to pass data between threads within a CTA. Data stored in the per-thread local address space and per-CTA address space is stored in L1 cache , and an eviction policy may be used to favor keeping the data in L1 cache . Each SPM  uses space in a corresponding L1 cache  that is used to perform load and store operations. Each SPM  also has access to L2 caches within the partition units  that are shared among all GPCs  and may be used to transfer data between threads. Finally, SPMs  also have access to off-chip \u201cglobal\u201d memory, which can include, e.g., parallel processing memory  and\/or system memory . An L2 cache may be used to store data that is written to and read from global memory. It is to be understood that any memory external to PPU  may be used as global memory.","In graphics applications, a GPC  may be configured such that each SPM  is coupled to a texture unit  for performing texture mapping operations, e.g., determining texture sample positions, reading texture data, and filtering the texture data. Texture data is read via memory interface  and is fetched from an L2 cache, parallel processing memory , or system memory , as needed. Texture unit  may be configured to store the texture data in an internal cache. In some embodiments, texture unit  is coupled to L1 cache , and texture data is stored in L1 cache . Each SPM  outputs processed tasks to work distribution crossbar  in order to provide the processed task to another GPC  for further processing or to store the processed task in an L2 cache, parallel processing memory , or system memory  via crossbar unit . A preROP (pre-raster operations)  is configured to receive data from SPM , direct data to ROP units within partition units , and perform optimizations for color blending, organize pixel color data, and perform address translations.","A binding group is configured to store shader state information that is specific to a particular shader program and is used to process the graphics data. Examples of shader state information include texture headers, texture samplers, and constant buffers. Texture headers each identify a particular texture map, texture map dimensions, mipmap levels, texel format, and the like. Texture samplers each specify sampling modes that are used to access and filter the texture data, such as a multisample pattern, bi-linear, tri-linear, and the like. The constant buffers are sets of constant values. A pointer to a binding group may be stored in a GPC  and the shader state information may be stored in one or more of the L1 cache , the L2 cache, parallel processing memory , or system memory .","It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing engines, e.g., primitive engines , SPMs , texture units , or preROPs  may be included within a GPC . Further, while only one GPC  is shown, a PPU  may include any number of GPCs  that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC  receives a particular processing task. Further, each GPC  advantageously operates independently of other GPCs  using separate and distinct processing engines, L1 caches , and so on.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 3B","FIG. 2"],"b":["215","202","215","350","355","360","350","210","360","350","355","355","355","220","220"]},"In graphics applications, ROP  is a processing unit that performs raster operations, such as stencil, z test, blending, and the like, and outputs pixel data as processed graphics data for storage in graphics memory. In some embodiments of the present invention, ROP  is included within each GPC  instead of partition unit , and pixel read and write requests are transmitted over crossbar unit  instead of pixel fragment data.","The processed graphics data may be displayed on display device  or routed for further processing by CPU  or by one of the processing entities within parallel processing subsystem . Each partition unit  includes a ROP  in order to distribute processing of the raster operations. In some embodiments, ROP  may be configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.","Persons skilled in the art will understand that the architecture described in , , A and B in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit, including, without limitation, one or more CPUs, one or more multi-core CPUs, one or more PPUs , one or more GPCs , one or more graphics or special purpose processing units, or the like, without departing the scope of the present invention.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 4","FIG. 2"],"b":["400","202","310","415","425","460","410","420","455","465","208","215","400"]},"Data assembler  processing unit collects vertex data for high-order surfaces, primitives, and the like, and outputs the vertex data, including the vertex attributes, to vertex processing unit . Vertex processing unit  is a programmable execution unit that is configured to execute vertex shader programs, lighting and transforming vertex data as specified by the vertex shader programs. For example, vertex processing unit  may be programmed to transform the vertex data from an object-based coordinate representation (object space) to an alternatively based coordinate system such as world space or normalized device coordinates (NDC) space. Vertex processing unit  may read data that is stored in L1 cache , parallel processing memory , or system memory  by data assembler  for use in processing the vertex data.","Primitive assembler  receives vertex attributes from vertex processing unit , reading stored vertex attributes, as needed, and constructs graphics primitives for processing by geometry processing unit . Graphics primitives include triangles, line segments, points, and the like. Geometry processing unit  is a programmable execution unit that is configured to execute geometry shader programs, transforming graphics primitives received from primitive assembler  as specified by the geometry shader programs. For example, geometry processing unit  may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters, such as plane equation coefficients, that are used to rasterize the new graphics primitives.","In some embodiments, geometry processing unit  may also add or delete elements in the geometry stream. Geometry processing unit  outputs the parameters and vertices specifying new graphics primitives to a viewport scale, cull, and clip unit . Geometry processing unit  may read data that is stored in parallel processing memory  or system memory  for use in processing the geometry data. Viewport scale, cull, and clip unit  performs clipping, culling, and viewport scaling and outputs processed graphics primitives to a rasterizer .","Rasterizer  scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Additionally, rasterizer  may be configured to perform z culling and other z-based optimizations.","Fragment processing unit  is a programmable execution unit that is configured to execute fragment shader programs, transforming fragments received from rasterizer , as specified by the fragment shader programs. For example, fragment processing unit  may be programmed to perform operations such as perspective correction, texture mapping, shading, blending, and the like, to produce shaded fragments that are output to raster operations unit . Fragment processing unit  may read data that is stored in parallel processing memory  or system memory  for use in processing the fragment data. Fragments may be shaded at pixel, sample, or other granularity, depending on the programmed sampling rate.","Raster operations unit  is a processing unit that performs raster operations, such as stencil, z test, blending, and the like, and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in graphics memory, e.g., parallel processing memory , and\/or system memory , for display on display device  or for further processing by CPU  or parallel processing subsystem . In some embodiments of the present invention, raster operations unit  is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.","Each shader program uses many bind points for various binding state information that is used by the shader program, e.g., textures, samplers, and constant buffers. The binding state information constitutes a large amount of data associated with each shader program. Setting and maintaining the binding state information consumes memory resources and memory bandwidth. In conventional systems a limited number of binding points are available and are not shared between shaders. When two shaders need to use one binding point a copy of the binding point is defined, stored and maintained so that each of the two shaders has a separate version of the binding point. Consequently, changes to the binding point must be made to both versions of the binding point. In contrast with the conventional approach, the binding points are organized into binding groups and two or more shader programs may share a binding group, i.e., set of binding points. As the number of different shader programs increases due to changes in the Application Programming Interface, the number of binding groups may increase at a slower rate since a binding group may be shared between two or more shader programs. It is advantageous to have shader programs share a binding group compared with having each shader reference one or more separate, possibly identical binding points.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 5A","b":["501","502","505","503","510","208","208","505","510","500","505","520","505","525","510","525","510","526","525","208","208","525","526","208","208","526"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 5B","b":["530","535","545","530","532","530","534","535","536","103","535","538","103","545","540","532","534","536","538","540"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 5C","b":["550","555","572","572","555","575","558","550","570","558","578"]},"In contrast with a conventional graphics processor and\/or Application Programming Interface, as the number and\/or variety of shader programs increases, the number of binding groups does not increase to maintain a one-to-one correspondence between shader programs and binding groups. Instead, multiple shader programs may reference the same binding group.","An Application Programming Interface may be used to set a pointer to the binding group. In some cases, the number of binding groups may be limited by the amount of storage provided within a particular graphics processor. A pointer to a texture sampler binding slot is set for a binding group using the code shown in TABLE 1. The number of texture sampler binding slots is set by SetBindingControl[].Texture.MaxActiveSamplers and each texture sampler binding slot specifies one of a maximum of number of texture samplers, where the maximum number of texture samplers is set by SetTexSamplerPoolC.MaximumIndex.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"method TextureSampler action {"},{"entry":"\u2003field Valid TYPEDEF_1BIT_FALSE_TRUE;"},{"entry":"\u2003field SamplerSlot U08;"},{"entry":"\u2003field Index U13;"},{"entry":"\u2003if ( SamplerSlot > MAX_SAMPLER_SLOT )"},{"entry":"\u2003\u2003throw ErrorInvalidValue;"},{"entry":"\u2003if ( ((U20)Index) > SetTexSamplerPoolC.MaximumIndex )"},{"entry":"\u2003\u2003throw ErrorInvalidValue;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The actual binding operation is performed by storing the value from a field index into the sampler binding table for the binding group_mgi (method group index) at the location specified by the field SamplerSlot. The field Index is relative to the base address set by the SetTexSamplerPool methods, and all shaders share this space of indices. Field Valid indicates whether the SamplerSlot is bound. When Valid is TRUE, the specified SamplerSlot is bound to the Index'ed sampler in the TexSamplerPool. When Valid is FALSE, the specified SamplerSlot is unbound","A pointer to a texture header binding slot is set for a binding group using the code shown in TABLE 2. The maximum number of texture header binding slots is set by SetBindingControl[].Texture.MaxActiveHeaders and each texture header binding slot specifies one of a maximum of number of texture headers, where the maximum number of texture headers is set by SetTexHeaderPoolC.MaximumIndex.",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"method TextureHeader action {"},{"entry":"\u2003field Valid TYPEDEF_1BIT_FALSE_TRUE;"},{"entry":"\u2003field TextureSlot U08;"},{"entry":"\u2003field Index U22;"},{"entry":"\u2003if( TextureSlot > MAX_TEXTURE_SLOT )"},{"entry":"\u2003\u2003throw ErrorInvalidValue;"},{"entry":"\u2003if( Index > SetTexHeaderPoolC.MaximumIndex )"},{"entry":"\u2003\u2003throw ErrorInvalidValue;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A pointer to a driver private texture sampler binding slot is set for a binding group using the code shown in TABLE 3.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"method ExtraTextureSampler action {"},{"entry":"\u2003field Valid TYPEDEF_1BIT_FALSE_TRUE;"},{"entry":"\u2003field SamplerSlot U08;"},{"entry":"\u2003field Index U13;"},{"entry":"\u2003if ( SamplerSlot > MAX_EXTRA_SAMPLER_SLOT )"},{"entry":"\u2003\u2003throw ErrorInvalidValue;"},{"entry":"\u2003if ( ((U20)Index) > SetTexSamplerPoolC.MaximumIndex )"},{"entry":"\u2003\u2003throw ErrorInvalidValue;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A pointer to a driver private texture header binding slot is set for a binding group using the code shown in TABLE 4.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"method ExtraTextureHeader action {"},{"entry":"\u2003field Valid TYPEDEF_1BIT_FALSE_TRUE;"},{"entry":"\u2003field TextureSlot U08;"},{"entry":"\u2003field Index U22;"},{"entry":"\u2003if( TextureSlot > MAX_EXTRA_TEXTURE_SLOT )"},{"entry":"\u2003\u2003throw ErrorInvalidValue;"},{"entry":"\u2003if( Index > SetTexHeaderPoolC.MaximumIndex )"},{"entry":"\u2003\u2003throw ErrorInvalidValue;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A pointer to a constant buffer binding slot is set for a binding group using the code shown in TABLE 5. The constant buffer table is stored and managed by each GPC .",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"method ConstantBuffer action {"},{"entry":"\u2003field Valid TYPEDEF_1BIT_FALSE_TRUE;"},{"entry":"\u2003field ShaderSlot U05;"},{"entry":"\u2003if (ShaderSlot > MAX_CONSTANT_BUFFER_SHADER_SLOT )"},{"entry":"\u2003\u2003throw ErrorInvalidValue;"},{"entry":"\u2003if ((Valid == TRUE) && (constant_buffer_selected == FALSE)) throw"},{"entry":"\u2003\u2003ErrorInvalidOperation;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"To cause a bind to occur, field Valid must be set to TRUE, and field ShaderSlot selects one of the binding slots. The constant buffer selected by the SetConstantBufferSelector[ABC] methods is then bound to the slot selected by ShaderSlot. To perform an unbind, field Valid must be set to FALSE, and field ShaderSlot selects one of the binding slots. When a shader program performs a read operation from an unbound constant buffer slot, a zero value is always returned to the shader.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 6","b":["600","605","610","208","615","208","620","208","625","208"]},"A system and method for sharing binding groups between shaders allows for efficient use of shader state data storage resources. In contrast with conventional graphics processors and Application Programming Interfaces that specify only one binding group for each shader, two or more shaders may reference the same binding group. As the number and variety of different shaders increases, the number of binding groups may increase at a different rate since some binding groups may be shared between different shaders. The binding group data may be stored in a cache within each GPC , within a shared storage resource within a PPU , and\/or in graphics memory. The binding group pointer referenced by a particular shader program may be stored within the GPC  that is configured to execute the particular shader program.","One embodiment of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored.","The invention has been described above with reference to specific embodiments. Persons skilled in the art, however, will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 3A","FIG. 2"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 3B","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
