---
title: Host agnostic integration and interoperation system
abstract: A host agnostic integration and interoperation system. The host agnostic integration and interoperation system includes an open platform interface and the associated conventions that define the roles of and direct operations between a host and a service application running on an external application server and allow the host to discover and integrate the functionality provided by the service application. The open platform interface employs a limited number of easily implemented semantic methods allowing a host to expose and integrate the ability to view, edit, or otherwise manipulate a document using the host supported functionality of the service application from a standard user agent. The host agnostic integration and interoperation system handles user authentication at the host using an access token and establishes a trust relationship between the host and the external application server using a lightweight but secure proof key system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09319469&OS=09319469&RS=09319469
owner: Microsoft Technology Licensing, LLC
number: 09319469
owner_city: Redmond
owner_country: US
publication_date: 20111219
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/539,975, filed Sep. 27, 2011, the disclosure of which is hereby incorporated by reference in its entirety.","Enterprises often maintain various types of documents that are stored in different places for different purposes. In many cases, such documents are created and stored according to a variety of different software applications and storage systems. For example, documents may be generated using word processing applications, spreadsheet applications, presentation applications, note applications, graphic design applications, photographic applications, and the like. Meaningful access to a particular type of document has historically required a local installation of an application supporting that document type, even to simply view the document.","With the widespread use of mobile computing and web based hosts, such as web mail servers and content servers, the need to access a document from a computing device lacking a local installation of the supporting application has become increasingly common. In response, attempts to provide support for selected document types through the web based host so as to avoid the need for a local installation of the supporting application have been made. Typically, this has been approached in one of two ways. First, some web based hosts natively support viewing widely used document types through embedded applications. Full support including document editing is not offered by the embedded applications. Second, external applications designed to integrate with web based hosts have been developed. Integration of an external application and a host generally requires each of these two programs to have specific knowledge of the application programming interface of the other. The external applications designed for integration with a particular host are generally required to participate in the authentication scheme(s) used by the host. Moreover, because the external application is generally given broad access to the host content, a two-way certificate exchange is commonly used to establish a trust relationship between the host and the external applications. As a result, external applications are not portable or useful with a significant number of hosts. Use of the external application is limited to a specific host, and support for various document types is limited to the available external applications designed for a particular host. It is with respect to these and other considerations that the present invention has been made.","The following Brief Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Brief Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","In the various embodiments, the host agnostic integration and interoperation system includes an open platform interface and the associated conventions that define the roles of and direct operations between a host and a service application running on an external application server and allow the host to discover and integrate the functionality provided by the service application. The open platform interface employs a limited number of easily implemented semantic methods allowing a host to expose and integrate the ability to view, edit, or otherwise manipulate a document using the host supported functionality of the service application from a standard user agent. The host agnostic integration and interoperation system handles user authentication at the host using an access token and establishes a trust relationship between the host and the external application server using a lightweight but secure proof key system.","A user accesses a host via a user agent from a client computing device. An external application server runs one or more web based service applications enabling the user to access, view, edit, and, optionally, perform other actions on content (i.e., a file or document) and perform folder (i.e., directory) management over the network from the client computing device without requiring a local installation of the appropriate application(s) needed to work with a particular document type. The host learns about and integrates the functionality that is provided by the external application server through a discovery process. After completing the discovery process, the behavior of the host changes based on the availability and functionality of the external application server. The external application server uses the open platform interface to integrate and communicate with the host. Through a service application, the external application server provides the necessary actions and functionality to work with a document of a selected file type.","The open platform interface is built on basic communication mechanisms that are well-established and common to most, if not all, platforms and operating systems. The fundamental communication mechanism utilized by the open platform interface for virtually all communications is a basic request-response protocol. Transactions are implemented as a standard HTTP or HTTPS request against a uniform resource locator (URL) with a host generated access token appended for authentication. All of the calling information is enveloped in the URL, the headers, and, as necessary, the body of the request. A request sent by the open platform interface client (i.e., the external application server) includes a proof header used by the open platform interface host to verify the identity of the requester. All of the reply information is contained in the URL, the headers, and, as necessary, the body of the response.","The basic format for a request or a response typically includes one or more request headers for carrying general and\/or method specific information and an optional request body when needed for carrying data. Additionally, the response returns a status code indicates either the success of the operation or indicates one of possibly several different error conditions. The request is posted to the address of an entry point or an endpoint of either the host or the external application server together with any required and optional parameters associated with the request. The following discussion describes one exemplary embodiment of the open platform interface. This example is not intended to limit the features and functionality provided by the open platform interface in any manner.","The headers used by open platform interface include the standard request headers, the standard response headers, and the error response headers. Additionally, the open platform interface includes specific additional headers for selected methods. The standard request headers, the standard response headers, and the error headers are used to handle diagnostic functions and communicate interface level information not specific to the request (i.e., general information). The error response headers are used in conjunction with the status code returned by the response. The status code provides a standard value defined by the open platform interface that indicates whether or not the request succeeded, and, if not, identifies the type of error encountered by the request. The body contains either metadata or binary data or is empty depending upon the request. The caller (i.e., the external application server or service application) interprets the data in the response body based on the request made by the caller. A basic data interchange or markup format serves as the fundamental data transport mechanism for metadata.","Communications between the external application server and the host are considered trusted because the host always initiates the transaction on behalf of the user. The host agnostic interface and interoperability system employs an optional proof system that allows the host to verify the identity of the requester and add an additional layer of trust. The proof system uses requests (i.e., calls) that carry proof of the identity of the caller. To implement the proof system, the host must obtain a cryptographic key (i.e., the proof key) specific to the external application server. The proof key provides the host with a mechanism by which to verify that a request was, in fact, made by the trusted external application server. The host uses its copy of the proof key to confirm that the cryptographic signature was generated using the corresponding private key.","The open platform interface uses an access token to uniquely identify a transaction. Moreover, the access token provides an authentication mechanism for the communications related to that transaction and eliminates the need for the external application server (i.e., the open platform interface client) to participate in a particular authentication scheme generally used by the host. The access token is a token that is unique to the user\/document pair that the host endpoint uses to authenticate the user and authorize access to the document. In various embodiments, the access token is a hash of one or more of the user identifier, the time stamp, and the document identifier and is encrypted with a secret known to the host.","The use of host initiated transactions allows the host agnostic interface and interoperability system to rely on host side authentication and avoids the need for the external application server to natively authenticate the user. In other words, the user always does some action (e.g., a user interface action or gesture) on the host that indicates the user wants to start interacting with a document in a particular way (e.g., editing, mobile viewing, etc.). The host always has an opportunity to contemporaneously generate an access token that is bound to the user and the document, has a relatively short lifespan, and can be subsequently validated by the host. The open platform interface does not require the host to use a particular scheme to generate the access token, and the host can use any of a variety of known access token generation schemes or a new one for this purpose. The service application does not need to know anything about the access token except that it exists and that is optionally associated with a particular object (i.e., it is likely tied to a particular user and file). The actual contents of the access token are entirely opaque to the service application. The service application simply includes the access token in communications with the host involving the associated transaction. Because the host does not have to make the access token intelligible to the external application server, the host is able to use any information to tie the access token to the particular user and file and to ensure that the access token is not valid indefinitely.","The methods supported by the host agnostic interface and interoperation system are defined by the open platform interface and the associated conventions. Each method is called using a HTTP request directed to the URL associated with the verb and includes a resource identifier uniquely identifying the target resource of the method and, optionally, the access token as a request parameter. The external application server advertises the availability of the methods in the form of a list of functional sets. Each functional set is declared by string and promises the implementation a set of methods supported by the open platform interface. In turn, the host advertises which functional sets it supports. Accordingly, the external application server knows whether to provide certain functionality based on the capabilities of the host. More specifically, if the host does not advertise support for specific functionality, the service application suppresses any features that require the unsupported functionality.","The declaration, implementation, and consumption of functional sets serve as the primary extensibility mechanism of the open platform interface. A functional set is made up from one or more verbs describing a method supported by the interface. Each verb defines the format and content of the requests and responses between the host and the external application server for a particular method of the interface. In general, the definition of each verb describes the format (i.e., the URL structure) of the request, the request headers, any information that is required or optionally included in the request body, the status codes, the error response headers, the response headers, and any information that is included in the response body.","The host agnostic integration and interoperation system takes advantage of selected service oriented architecture principles and methodologies that contribute to a high level of cross-version compatibility between the versions of the open platform interface implemented by the open platform interface host and clients. Various embodiments of the host agnostic integration and interoperation system adhere to the service oriented architecture principles of \u201cignore what you weren't expecting\u201d and \u201cuse default values for data you were expecting but didn't get.\u201d Specifically, the metadata object notation is constructed in such a way that it is acceptable for the response body to include objects that are not recognized by the recipient. In other words, if the response body includes more data than the recipient was expecting, the unexpected data is ignored. Alternatively, if the response body omits data that the recipient expects, default values for the missing data are used. Further, some embodiments of the open platform interface adopt the semantic of \u201cdefault values must result in acceptable behavior.\u201d In this instance, the open platform interface treats misconfigured, invalid, unusable, or otherwise non-functional default values as unexpected data and ignores them.","A host agnostic integration and interoperation system is described herein and illustrated in the accompanying figures. The host agnostic integration and interoperation system includes an open platform interface and the associated conventions that define the roles of and direct operations between a host and a service application running on an external application server and allow the host to discover and integrate the functionality provided by the service application. The open platform interface employs a limited number of easily implemented semantic methods allowing a host to expose and integrate the ability to view, edit, or otherwise manipulate a document using the host supported functionality of the service application from a standard user agent. The host agnostic integration and interoperation system handles user authentication at the host using an access token and establishes a trust relationship between the host and the external application server using a lightweight but secure proof key system.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["102","104","106","102","108","110","102","126","106","102","112","112","114","112","116","126","102","104","106","102","104","106","104","102","104","102","120","104","102","104","102","104","104"]},"The external application server  runs one or more web based service applications  enabling the user  to access, view, edit, and, optionally, perform other actions on content (i.e., a file or document) and perform folder (i.e., directory) management over the network from the client computing device  without requiring a local installation of the appropriate application(s) needed to work with a particular document type. The action and output of the external application server  is not specific to the host  that invokes the functionality of the external application server. Each service application  generally runs as a service on the external application server . The external application server  uses the open platform interface to integrate and communicate with the host . Through a service application , the external application server  provides the necessary actions and functionality to work with a document of a selected file type. Examples of the service applications  handling various document types include the web based companions to the standard (i.e., locally installed) applications for working with word processing documents, spreadsheets, notes, and presentations. The actions provided by each service application  are typically specific to a selected file type or related to folder management. The core actions provided by the service application  include viewing and editing documents. In various embodiments, the service application  provides one or more additional actions including, but not limited to, reformatting a document for viewing on a mobile device, creating a new document, converting a document, embedding a document, and broadcasting a document.","The host  is an online server application capable of being accessed over a network using a user agent , such as a web browser from the client computing device . The functionality provided by the external application server  are consumed by the host  and made available to the user . Examples of suitable host systems include, but are not limited to, mail systems allowing web based access (e.g., Microsoft Exchange Server\u00ae), unified communication systems (e.g., IBM Lotus Sametime\u00ae, Microsoft Lync\u00ae, and Unison\u00ae), and content and\/or document management systems (e.g., IBM Lotus Quickr\u00ae and Microsoft SharePoint\u00ae). As a content server, the host  stores the user's data (i.e., documents) and initiates scenarios involving the external application server  to view, edit, or otherwise manipulate the user's data. Under the open platform interface, the host  handles file system operations at the requested of the external application server . Other responsibilities of the host  typically include handling access control to documents at the user level and license enforcement for the external application server .","The host  implements the service application wrapper  displayed in the user agent on the client computing device . The service application wrapper  is a web page and\/or frame (e.g., an inline frame) generated by the host  that serves as a viewport for the output (i.e., the web based user interface) of the service application . The service application wrapper  optionally includes an inner application frame  that displays the user interface pages of the service application  while the service application wrapper  optionally presents host chrome (i.e., a host provided look and feel) and navigation control(s).","When the user  selects an action for a particular document, that action is invoked by a request made to a service application entry URL for the service application supporting that document type. The service application entry URL points to an address for a service application on the external application server . The base of the service application entry URL is, most typically, the address of the external application server . The host , typically through the service application wrapper , generates and appends the parameters associated with the selected action to the service application entry URL. The parameters specify the task (e.g., embedded edit using the spreadsheet application) and the required data to accomplish the requested task.","The host  also implements and exposes the host endpoint  for receiving communications from the external application server. The host endpoint  is a web service that understands requests made using the open platform interface. Some embodiments of the open platform interface exclusively use a secure transport protocol (e.g., HTTPS) for communications with the host endpoint  in order to protect the access token and the content of the document. In one embodiment, the URL of the host endpoint  is created by appending the location of the host endpoint web service to the domain name of the host.","While it is entirely possible and acceptable to manually configure the host  for integration with the external application server , various embodiments of the open platform interface provides an automated external application server discovery process to accomplish this task. Prior to beginning the external application server discovery process, the host  is not required to have any knowledge of the availability or functionality of an external application server . To participate in the external application server discovery process, the host  must understand the open platform interface and the discovery conventions. After completing the external application server discovery process, the behavior of the host  changes based on the availability and functionality of the external application server .","During the discovery process, the host  learns the file formats and the open interface protocol methods (i.e., verbs) that are supported by the external application server . The discovery process begins with the host  issuing a discovery request and receiving a discovery response message containing the discovery metadata describing the functionality supported by the external application server (i.e., the properties of the external application server). The discovery metadata is formatted according to and contains information specified by the conventions of the open interface protocol. In various embodiments, the discovery metadata contains information such as an identifier for the external application, a description of the external application, a file extension, an action associated with the file extension, any open interface protocol implementation requirements for the host (e.g., functional sets), the location of the external application responsible for handling the actions, and\/or a mime type for the documents associated with the file extension, and a copy of the public proof key for participating in the security scheme. In one embodiment, a human and machine readable identifier (e.g., a string value) for the supporting application is associated with each file type\/action pair. The host  consumes the discovery metadata and registers the functionality of the external application server  as part of the host configuration.","Each action is defined by the conventions of the open interface protocol. The host  chooses to make use of or ignore individual actions based on the conventions of the open protocol interface understood by the host  at the time. In one embodiment, the host  verifies that it supports the requirements for the action before registering the paired file type and action. If the host  does not support the action and\/or meet the hosting requirements, the paired file type and action is not registered. More specifically, in some embodiments, the host uses the \u201crequires\u201d attribute, which specifies the open interface protocol implementation requirements, to filter out actions the host cannot support. In other words, if the host does not recognize or understand all the fields listed in the \u201crequires\u201d attribute value or chooses not to support that convention of the open interface protocol, the host does not register (i.e., implement) the paired file type and action and does not offer that functionality to the user.","The configuration, functionality, and level of implementation of the open platform interface and the associated conventions by the host determine the effective functionality of external application server available to the user . If the host  does not fully implement the open platform interface or does not meet the requirements for certain functionality of the external application server , that functionality is not available to the user . More specifically, if the host  does not advertise support for specific functionality, the external application server  suppresses any features that the host cannot support. For example, the external application server  should not allow the user  to edit a document when the host  is not capable of saving an updated copy of the document.","Additionally, the discovery metadata describes the parameters used in the external application entry URL associated with each action. As with actions, the service application entry URL parameters are specified by convention in the open interface protocol. Some parameters are required and others are optional. If the host does not understand a required parameter, the host does not register the action. Conversely, when an optional parameter is not understood, the host may choose to register the action. In such case, the functionality associated with the optional parameter is simply lost, but the host is still able to provide the action with as much functionality as the host understands.","Handling the discovery of actions and parameters in this manner provides the basis for the robust cross-version compatibility enjoyed by the open platform interface. Even if an upgrade of the external application server provides new functionality that is not supported or understood by the host, the host continues to work with the upgraded external application server. The host simply continues to provide support for the functionality it understands and ignores any functionality it does not understand.","The open platform interface is built on basic communication mechanisms that are well-established and common to most, if not all, platforms and operating systems. The fundamental communication mechanism utilized by the open platform interface for virtually all communications is a basic request-response protocol, such as hypertext transport protocol (HTTP) or hypertext transport protocol secure (HTTPS). A transaction is generally implemented as a standard HTTP request against a uniform resource locator (URL) with a host generated access token appended for authentication. All of the calling information is contained in the URL, the headers, and, as necessary, the body of the request. In other words, the request envelopes a bunch of information such as the object to operate on, the operation to perform, the optional proof provided by the caller, and various other bits of metadata. Some requests also contain a body enveloping data in the exchange format associated with the operation. When present, the data in the body represents payload of the operation described in the envelope. Accordingly, requests that happen to carry a payload must continue to present the required envelope information in the query-string\/http headers and cannot use the body of the request as an alternate transport mechanism. The same is true of responses, though there are more payloads, as some responses match metadata payloads with requests that have no payload and file contents are always transferred as payloads in the response body A request sent by the open platform interface client (i.e., the external application server) optionally includes a proof header used by the open platform interface host to verify the identity of the requester. All of the reply information is contained in the URL, the headers, and, as necessary, the body of the response. This eliminates the need for a very specific metadata exchange beforehand required by some prior art interfaces.","The basic format for a request or a response typically includes one or more request headers for carrying general and\/or method specific information and an optional request body when need for carrying data. Additionally, the response returns a status code that whether or not the request was successful. The request is posted to the address of an entry point or an endpoint of either the host or the external application server together with any required and optional parameters associated with the request. The following discussion describes one exemplary embodiment of the open platform interface. This example is not intended to limit the features and functionality provided by the open platform interface in any manner.","The headers used by open platform interface include the standard request headers, the standard response headers, and the error response headers. Additionally, the open platform interface includes specific additional headers for selected methods. The standard request headers, the standard response headers, and the error headers are used to handle diagnostic functions and communicate interface level information not specific to the request (i.e., general information). The error response headers are used in conjunction with the status code returned by the response. The status code provides a standard value defined by the open platform interface that indicates whether or not the request succeeded, and, if not, identifies the type of error encountered by the request.","The standard request headers specify the interface version of the external application server (i.e., the caller or the interface client), the machine name of the external application server, and the correlation identifier used to synchronize the logs from the client with the logs from the host for logging and\/or debugging purposes and allow the external application server to request a performance trace from the host (i.e., the responder or the interface server). The standard response headers specify the interface version of the host, the machine name of the host, and, if requested, the output of the performance trace. The response codes defined by the open platform interface include code 200 indicating success\/no error, code 404 indicating that the file is unknown or the user is unauthorized, code 409 indicating that the resource lock is mismatched, the resource is locked by another interface, or the filename specified in the PutRelativeFile request is in use and the overwrite behavior is not required, code 412 indicating that the file is larger than the maximum expected size, code 413 indicating that the file is too large, code 500 indicating a server error, and code 501 indicating that the verb is not implemented by the server\/host. The response error headers include a server error header to describe the server error when code 500 is returned and, when code 409 is returned, either a lock header specifying the unique identifier of the lock created using the open platform interface, or a locked by another interface flag indicating that the lock on the target resource was not created using the open platform interface.","The open platform interface recognizes two different content types in the body of a request or a response. Depending on the request, the body contains either metadata or binary data. The content type of the response body depends on the request made. The caller (i.e., the external application server or service application) interprets the data in the response body based on the request made by the caller. A basic data interchange or markup format serves as the fundamental data transport mechanism for metadata. In most embodiments, the basic data interchange or markup format is both machine readable and human readable. One suitable object notation format used by various embodiments of the open platform interface for the data transport mechanism is JavaScript Object Notation (JSON); however, other object notation formats may be used without departing from the scope and spirit of the present invention.","The host begins a transaction (i.e., invokes an action) by making an HTTP GET request to the service application wrapper against the service application entry URL. When initiating a transaction, the host provides a metadata URL (i.e., the callback URL or source URL). All subsequent communications in the transaction are initiated by the external application server. The metadata URL is a reference to the host endpoint, which is the address that the service application uses when making an HTTP request to the host. The HTTP requests are used to call a host side method for performing a resource related function.","The open platform interface defines a limited number of easily implemented and widely supported semantic methods for performing some or all of the following functions including, but not limited to: get file metadata (CheckFileInfo), get folder metadata (CheckFolderInfo), get the binary content of a file (GetFile), save the binary content of a file (PutFile), save a copy of the binary content of a file (PutRelativeFile), lock a file (Lock), unlock a file (Unlock), renew the lock on a file (RefreshLock), unlock and relock a file (UnlockAndRelock), execute a local virtual application (ExecuteCobaltRequest), execute a remote virtual application (ExecuteCobaltRelativeRequest), enumerate the contents of a folder (EnumerateChildren), and delete a file (DeleteFile). The method for getting the metadata associated with a document and a method for getting the document content are considered the core methods of the open platform interface. Each method is called using an HTTP request to the service application wrapper (typically, the inner frame) against the metadata URL or another host endpoint URL and includes a resource identifier uniquely identifying the target resource (e.g., the file or folder) of the method and, optionally, the access token as a request parameter. In most cases, the callback URL is either the metadata URL or the content URL for the target resource type.","The CheckFileInfo request is a GET request made against the file metadata URL and supports the standard request headers. The CheckFileInfo request supports inclusion of the access token as an optional parameter. The CheckFileInfo request body is empty or omitted. The supported CheckFileInfo error codes are code 200, code 404, and code 500. The CheckFileInfo response supports the standard response headers, and the CheckFileInfo response body contains the file metadata in an object notation format.","The core file metadata includes, but is not limited to, one or more of the file version specifying a unique and non-repeating value that changes when the file changes, the base filename specifying the filename including the extension but without the path, the owner identifier specifying a unique identifier for the owner of the resource (used for throttling and consistent hashing), the file size of the current version of the file, and the file hash code containing a Base64 encoded SHA256Hash of the document content used for cache management (SHA256Hash). The optional file metadata includes, but is not limited to, one or more of the client URL specifying the address used by the external application server to access the resource, the download URL specifying the address triggering the native download function of the user agent, the close URL specifying the target address for the service application wrapper when the resource is closed, the full screen URL specifying the address of the host provided full screen view page, the host view URL specifying the address of the host provided view page, the host edit URL specifying the address of the host provided edit page, the host embedded view URL specifying the address of the host's embedded viewer for the document type (if different from the host view URL), the host embedded edit URL specifying the address of the host's embedded editor for the document type (if different from the host edit URL), the user write permission flag indicating whether or not the user has write permissions for the resource, the read only flag indicating whether or not the resource is read only for all users, the public flag indicating whether or not the resource is accessible to all users, the hide formulas flag indicating whether or not spreadsheet formulas are visible to the user, the update support flag indicating whether or not the host supports file save operations, the lock support flag indicating whether or not the host supports file lock operations, the virtual application support flag indicating whether or not the host supports virtual applications (e.g., Cobalt applications), the container support flag indicating whether or not the host supports file system operations (list contents of a folder, delete files, etc.), the delete flag indicating whether or not the host supports file system delete operations, the file URL specifying the address for directly accessing the content of the file (i.e., without using the host endpoint content URL), the privacy URL specifying the address for displaying the host's privacy policy, and the terms of use URL specifying the address for displaying the host's terms of use.","The CheckFolderInfo request is a GET request made against the folder metadata URL and supports the standard request headers. The CheckFolderInfo request supports inclusion of the access token as an optional parameter. The CheckFolderInfo request body is empty or omitted. The supported CheckFolderInfo error codes are code 200, code 404, code 500, and code 501. The CheckFolderInfo response supports the standard response headers and the response body contains the folder metadata in an object notation format.","The core folder metadata includes, but is not limited to, one or more of the folder name specifying the folder name without the path, and the owner identifier. The optional file metadata includes, but is not limited to, one or more of the client URL, the close URL, the file hierarchy support flag indicating that the folder is a container, the delete flag, the user write permission flag, the public flag, the update support flag, the lock support flag, the virtual application support flag, the container support flag, the host view URL, the host edit URL, the host embedded view URL, the host embedded edit URL, the privacy URL, and the terms of use URL.","The GetFile content request is a GET request made against the file content URL. The GetFile content request supports the standard request headers and an optional extended request header specifying the expected maximum size of the file. The GetFile content request supports inclusion of the access token as an optional parameter. The GetFile content request body is empty or omitted. The supported GetFile error codes are code 200, code 404, code 412, and code 500. The GetFile response supports the standard response headers and an extended response header specifying the version (in the same form as the one returned by CheckFileInfo) of the file actually returned in the response. The GetFile response body contains the file content in a binary format.","The PutFile request is a POST request made against the file content URL. The PutFile request supports the standard request headers and additional headers specifying the size of the file (required), an override identifier (e.g., \u201cPUT\u201d) to differentiate the various POST operations made to the same URL, and, optionally, the unique identifier for the file lock used during the save operation. The PutFile request supports inclusion of the access token as an optional parameter. The PutFile content request body contains the file content in a binary format. The supported PutFile error codes are code 200, code 404, code 409, code 413, code 500, and code 501. The PutFile response supports the standard response headers. The PutFile response body is empty or omitted.","The PutRelativeFile request is a POST request made against the file metadata URL. The PutRelativeFile request supports the standard request headers and additional headers specifying the size of the file, an override identifier (e.g., \u201cPUT_RELATIVE\u201d), the filename for the file copy, and whether or not overwriting the target file is permitted. The PutRelativeFile request supports inclusion of the access token as an optional parameter. The PutRelativeFile request body contains the file content in a binary format. The supported PutRelativeFile error codes are code 200, code 404, code 413, code 500, and code 501. The PutRelativeFile response supports the standard response headers. The PutRelativeFile response body contains the file metadata for the copy in an object notation format. If the file is successfully created, the file metadata includes, but is not limited to, the file metadata URL for the file copy, the host view URL for the file copy, and, optionally, the host edit URL for the file copy. If the file is not successfully created, the file metadata includes, but is not limited to, the suggested filename specifying an alternate file copy filename, a file exists flag indicating whether or not a file with the file copy filename supplied in the PutRelativeFile request already exists, and the illegal filename flag indicating whether or not the file copy filename supplied in the PutRelativeFile request is a legal filename.","The LockFile request is a POST request made against the file metadata URL. The LockFile request supports the standard request headers and additional headers specifying an override identifier (e.g., \u201cLOCK\u201d) and the unique identifier for the file lock to be created. The LockFile request supports inclusion of the access token as an optional parameter. The lock file request body is empty or omitted. The LockFile error codes are code 200, code 404, code 409, code 500, and code 501. The LockFile response supports the standard response headers and an additional header specifying an existing lock. The LockFile response body is empty or omitted. The UnlockAndRelock request is a variant of the LockFile request that simply includes an additional parameter specifying the unique identifier of the file lock to be removed.","The UnlockFile request is a POST request made against the file metadata URL. The UnlockFile request supports the standard request headers and additional headers specifying an override identifier (\u201cUNLOCK\u201d) and the unique identifier of the file lock to be removed. The UnlockFile request supports inclusion of the access token as an optional parameter. The UnlockFile request body is empty or omitted. The unlock file error codes are code 200, code 404, code 409, code 500, and code 501. The UnlockFile response supports the standard response headers. The UnlockFile response body is empty or omitted.","The RefreshLock request is a POST request made against the file metadata URL. The RefreshLock request supports the standard request headers and additional header specifying an override identifier (e.g., \u201cREFRESH_LOCK\u201d) and the unique identifier of the file lock to be refreshed. The RefreshLock request supports inclusion of the access token as an optional parameter. The RefreshLock request body is empty or omitted. The RefreshLock error codes are code 200, code 404, code 409, code 500, and code 501. The RefreshLock response supports the standard response headers. The RefreshLock response body is empty or omitted.","The ExecuteCobaltRequest and ExecuteCobaltRelativeRequest requests are POST requests made against the file metadata URL. The ExecuteCobaltRequest and ExecuteCobaltRelativeRequest requests support the standard request headers and additional headers specifying the size of the file content, and an override identifier (e.g., \u201cCOBALT\u201d). In the case of the ExecuteCobaltRelativeRequest request, an additional header specifying the relative target is supported. The ExecuteCobaltRequest and ExecuteCobaltRelativeRequest requests support inclusion of the access token as an optional parameter. The ExecuteCobaltRequest and ExecuteCobaltRelativeRequest request bodies carry the file content in Cobalt format. The supported error codes for the ExecuteCobaltRequest and ExecuteCobaltRelativeRequest requests are code 200, code 409, code 500, and code 501. The ExecuteCobaltRequest and ExecuteCobaltRelativeRequest responses support the standard response headers. The ExecuteCobaltRequest and ExecuteCobaltRelativeRequest response bodies carry the output of the virtual application in binary format. The ExecuteCobaltRequest and ExecuteCobaltRelativeRequest requests illustrate how the open platform interface includes enveloping functionality that allows arbitrary data protocols to be incorporated into the open platform interface as needed. The open platform interface identifies the object and provides the access to the object, but allows the object to utilize the arbitrary data exchange format that are understood by the both the client and the host. The open platform interface is not required to understand the arbitrary data exchange format. The enveloped object simply makes use of a different override header and declares itself as available in Check.","The EnumerateChildren request is a POST request made against the folder metadata URL. The EnumerateChildren request supports the standard request headers and the inclusion of the access token as an optional parameter. The EnumerateChildren request body is empty or omitted. The supported EnumerateChildren error codes are code 200, code 404, code 500, and code 501. The EnumerateChildren response supports the standard response headers. The EnumerateChildren response body contains a collection of resource metadata in object notation format. The resource metadata includes, but is not limited to, the metadata URL for the resource, the base filename or folder name, and the version of the resource (if a file).","The DeleteFile request is a POST request made to the file metadata URL. The DeleteFile request supports the standard request headers and an additional header specifying an override identifier (e.g., \u201cDELETE\u201d). The DeleteFile request supports inclusion of the access token as an optional parameter. The DeleteFile request body is empty or omitted. The DeleteFile error codes are code 200, code 404, code 409, code 500, and code 501. The DeleteFile response supports the standard response headers. The DeleteFile response body is empty or omitted.","The open platform interface incorporates information rights management (IRM) into the external service application for viewing only to allow user to open documents with information rights management restrictions through the use of the access token and the proof system. An easily understood scenario focuses on sending company confidential information to a large group. In this scenario, the sender needs to communicate the sensitive information to the employees of his or her organization but wants to ensure that they do not forward the document. The external service application serves as an excellent viewing option for this scenario as the user does not need to download the document to open it. In addition, the caching mechanism in the external service application will make this fast. However, without information rights management support the scenario is broken and users will receive an error dialog.","The open platform interface allows a user to retrieve a protected document from the host. All communication between the client, the host, and the external service application is recommended to be over a cryptographic communication protocol such as SSL or TLS to prevent an attacker from acquiring the user's authorization token. In order to support information rights management in the external service application, the CheckFileInfo incorporates three additional parameters: a protected file flag that indicates that a given file needs to be protected in browser and an optional IRM Template identifier specifying a name for and a description of a template that is displayed to the user. To prevent the user from retrieving unencrypted copies of documents the user has access to, requests include portions signed with a private key that only the external service application knows and the host can choose to reject any requests that do not provide proof as expected. The providing of proof keys at discovery time is a promise by the external application server to sign all requests. The host can choose to not initiate IRM sessions with an external application server that does not provide proof at discovery time. The external service application signs the request with both the current and old private keys. The host will accept the request only if one of these two signatures can be validated with its copies of the external service application's current or old public keys.","The host agnostic integration and interoperation system takes advantage of selected service oriented architecture principles and methodologies that contribute to a high level of cross-version compatibility between the versions of the open platform interface implemented by the open platform interface host and clients. Various embodiments of the host agnostic integration and interoperation system adhere to the service oriented architecture principles of \u201cignore what you weren't expecting\u201d and \u201cuse default values for data you were expecting but didn't get.\u201d Specifically, the metadata object notation is constructed in such a way that it is acceptable for the response body to include objects that are not recognized by the recipient. In other words, if the response body includes more data than the recipient was expecting, the unexpected data is ignored. Alternatively, if the response body omits data that the recipient expects, default values for the missing data are used. For example, Boolean values default to \u201cfalse\u201d and all string values default to \u201cempty\u201d and integer values default to zero. Any other data type with a clear default value could be introduced by convention. Further, some embodiments of the open platform interface adopt the semantic of \u201cdefault values must result in acceptable behavior.\u201d","Communications between the external application server and the host are considered trusted because the host always initiates the transaction on behalf of the user in the host agnostic interface and interoperability system. Moreover, the requests are all actions that the host would allow the user to do. When the action is not something that the user should be able to do (i.e., get a protected file), the host agnostic interface and interoperability system should require proof keys. The host agnostic interface and interoperability system employs an optional proof system that allows the host to verify the identity of the requester and add an additional layer of trust to the transaction. The proof system uses requests (i.e., calls) that carry proof of the identity of the caller. To implement the proof system, the host must obtain a cryptographic key (i.e., the proof key) specific to the external application server. The proof key provides the host with a mechanism by which to verify that a request was, in fact, made by the trusted external application server. In various embodiments, the host obtains the cryptographic key overs a HTTPS connection to ensure that the host is communicating with the external application server with which the host expects to be communicating. In one embodiment relying on a public-key cryptographic system such as RSA, the proof key is a public key corresponding to a private key held by the external application server. The external application signs portions of subsequent communications using a private key corresponding to the public key to create a cryptographic signature. In the various embodiments, the portions that are signed include the timestamp, the URL, the access token, and a hash of one or more these pieces of information. More specifically, a timestamp is added to the header and included in the signature, and the URL to which the external application server is initiating the request is included in the signature. In various embodiments, the request from the external application server includes a proof header that carries the cryptographic signature. The host uses the proof key to confirm that the cryptographic signature was generated using the corresponding private key. In some embodiments, the host uses the timestamp to verify that the cryptographic signature is within acceptable temporal limits.","While many applications will benefit from the additional layer of trust offered by the proof system, the proof system is an optional component of the host agnostic interface and interoperability system. The host has the option of enforcing or requiring proof of identity. If the service application does not supply a proof header when required by the host, the host simply ignores the request or, alternatively, returns an error message indicating that the request is unauthorized. In some embodiments, the host advertises that a proof header is required to the external application server so the service application will know to include the proof header in all requests. When proof of identity is not required, the host may choose to ignore the proof header in the request.","In the host agnostic interface and interoperability system, the host initiates the relationship with the external application server and obtains the proof key from the external application server at that time. In various embodiments, the proof key is provided to the host as part of the discovery metadata returned during the discovery process or as part of an initial callback to the host. The host also expects future communications to come from the external application server. Because the external application server provided the proof key when the host initiated the trust relationship, the host can rely on the fact that a cryptographic signature validated using the proof key was generated by the same external application server that originally provided the proof key and not spoofed by a third party.","The open platform interface uses an access token to uniquely identify a transaction. Moreover, the access token provides an authentication mechanism for the communications related to that transaction and eliminates the need for the external application server (i.e., the open platform interface client) to participate in a particular authentication scheme generally used by the host. The access token is a token that is unique to the user\/document pair that the host endpoint  uses to authenticate the user  and authorize access to the document. In various embodiments, the access token includes a hash of one or more of the user identifier, the time stamp, and the document identifier and is encrypted with a secret known to the host.","The use of host initiated transactions allows the host agnostic interface and interoperability system to rely on host side authentication and avoids the need for the external application server to natively authenticate the user. In other words, the user always does some action (e.g., a user interface action or gesture) on the host that indicates the user wants to start interacting with a document in a particular way (e.g., editing, mobile viewing, etc.). The host always has an opportunity to contemporaneously generate an access token that is optionally bound to the user and the document, has a relatively short lifespan, and can be subsequently validated by the host. The open platform interface does not require the host to use a particular scheme to generate the access token, and the host can use any of a variety of known access token generation schemes or a new one for this purpose. The service application does not need to know anything about the access token except that it exists and that is associated with a particular transaction (i.e., it identifies a particular user and file). The actual contents of the access token are entirely opaque to the service application. The service application simply includes the access token in communications with the host involving the associated transaction. Because the host does not have to make the access token intelligible to the external application server, the host is able to use any information to guarantee that the access token is tied to the particular user and file and that the access token is not valid indefinitely.","The conventions of the open platform interface strongly encourage the host to link the access token to a specific user and a specific resource (e.g., a specific file or document) as part of recommended security practices. When so linked, even if the access token were to be compromised, the attacker would only obtain access to the specific file and only have the rights granted to the specific user rather than general permission for everything that user could do in a given system. Because of the types and amount of information embedded in the URLs used by the open interface protocol (e.g., the access token or the document content), use of a secure channel (e.g., HTTPS) is recommended, although not required, on all inbound and outbound calls in the open platform interface.","The metadata URL refers to the file and the access token refers to a specific access time by a specific user to that file. For example, if two users were editing the same document at the same time, both users be given the same metadata URL, but each user would have different access tokens allowing the host and\/or the service application to separately track the actions (i.e., transactions) of each user. However, the service application is not required to identify or distinguish between the two users. All that is required of the service application is to simply include the access token in the request so the host can identify the user and perform any necessary user level authentication of the request.","If the transaction requires the service application to learn about additional resources, the conventions of the open platform interface specify that the host should provide a new access token for each additional resource. In other words, anytime the external application makes a call under the open platform interface to learn about a different resource, the host provides the metadata URL and an access token for that resource, so the service application can interact with that resource on behalf of the user. If the service application needs to know anything else about the user (e.g., the user's name or what permissions the user has on a file), the host provides that information when the service application makes the first call to the host. The service application accepts the access token as identification and authorization to perform the transaction without having to independently and natively authenticate the user under whatever authentication scheme is used by the host. In other words, the access token allows the service application to completely trust the host to handle the user side of things.","Because the service application relies entirely on the access token and does not authenticate the user in any way, shape, or form, the open platform interface allows applications (e.g., the host application) to provide programmatic functionality to initiate requests for the service applications. The host directly issues a HTTP GET request to the service application wrapper against the appropriate service application entry URL using the open interface protocol, and the body of the response from the external application server to the host only contains data indicating the result of the task. This functionality is made possible by the use of the access token, which eliminates the need for the user agent to navigate to the external application server directly to gain authentication information and is not available in the prior art requiring native authentication of the user.","For example, the host can request a document conversion without requiring interaction by the user. In such a case, the host sends a request directly to external application initiating the convert action and specifying the target file and the access token. In response, the service application calls the host endpoint, gets the files, performs the conversion, and returns the converted document to the host directly. In another example, the external application provides a teaser service that takes a document (e.g., a word processing or presentation document) and extracts selected bits of information (e.g., highlighted portions). The extracted information can then be shown in a news feed or other outlet. As the open platform interface allows the host to get that data directly without having the user having to be involved in the process at the time. Basically, the host just wakes up and asks external application server to provide a teaser for a document. The user is not required to be present when the host makes the request. Moreover, the service application starts the call directly (i.e., programmatically) rather than loading code into a webpage. As long as the call provides the required information (e.g., the file identifier and the access token), the external application performs the request and returns the requested data directly to the host rather than sending it to a browser instance.","In addition to the two core methods (i.e., getting metadata and getting binary data), various embodiments of the open platform interface define additional methods. The additional methods are defined by the open platform interface and the associated conventions. The external application server advertises the availability of the additional methods in the form of a list of functional sets. Each functional set is declared by string (e.g., Cobalt, Locking, Update), and promises the implementation a set of methods supported by the open platform interface. In turn, the host advertises which functional sets it supports. Accordingly, the external application server knows whether to provide certain functionality based on the capabilities of the host. More specifically, if the host does not advertise support for specific functionality, the service application suppresses any features that require the unsupported functionality. For example, the service application should not allow the user to edit a document when the host is not capable of saving an updated copy of the file.","The declaration, implementation, and consumption of functional sets serve as the primary extensibility mechanism of the open platform interface. The open platform interface does not allow a generic (i.e., fully open) metadata exchange mechanism, such as is used by the Simple Object Access Protocol (SOAP), to describe available functionality. In other words, the functional sets available for a host to implement are limited to those provided by the open platform interface and the associated conventions. By tying the available functional sets to conventions, the open protocol interface is freed of the burden of attempting to fully describe the functionality. Instead, each convention is simply declared, and only used if both sides believe they know what the convention means. The only time a convention blocks action is when the service application claims a convention is required and the host does not understand that requirement.","A functional set is made up from one or more verbs describing a method supported by the interface. Each verb defines the format and content of the requests and responses between the host and the external application server for a particular method of the interface. In general, the definition of each verb describes the format (i.e., the URL structure) of the request, the supported headers associated with the request, any information that is required or optionally included in the request body, the supported error codes, any supported headers providing additional information about the error codes, the supported headers associated with the response, and any information that is included in the response body. The following discussion describes one exemplary embodiment of the interface. This example is not intended to limit the features and functionality provided by the interface in any manner.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIGS. 2A to 2E","b":["102","118","106","100","102","104","104","104"]},"The user  accesses the host  via the user agent on the client computing device  and requests (step ) content from the host . The host  recognizes (step ) that the requested content includes a reference to a stored document. In the exemplary embodiment, the content is an e-mail message containing the attached word processing document. The host  consults (step ) the discovery metadata to determine if the document type is supported. For documents of a type supported by the external application server , the host  determines (step ) the actions associated with that document type that are supported by the external application server . The host  selectively generates (step ) an action link for each action supported by the external application server  and associates the action link with the document. The host  then provides (step ) the content and the associated action links. The user agent displays (step ) the content, including the action links, provided by the host. Transmitting (step ) the action link in the host-provided content indicates that the user  desires to perform the selected action on the associated document referenced in the host-provided content. In this scenario, the user  clicks the view link in the e-mail message for the attachment to view the document content.","As previously mentioned, the host  manages the user access rights for the document and licenses for each supported service application provided by the external application server. The host optionally considers user level permissions, external application server\/service application licensing, administrative restrictions, and context-based restrictions at various points during the document access process before offering the functionality to the user or allowing the user to invoke the action. In various embodiments, the selectively considers whether or not access should be restricted due to insufficient user permissions\/access rights for the desired access to the document, lack of a valid license to use the associated service application\/external application server, administrative restrictions in the host configuration that prevent the host from retrieving or saving the selected document type, and\/or the action being inappropriate in the context of the content being delivered (e.g., the host may restrict editing a document when attached to an incoming e-mail but otherwise allow the user to edit that document in other contexts). Other criteria may be used in other embodiments without departing from the scope and spirit of the present invention. In the illustrated embodiment, when the user  clicks on the action link, the host  verifies (step ) that the user  has permission to access the document and\/or has the necessary license to use the supporting service application\/external application server . When the host  determines that the action is restricted, the host  does not invoke (step ) a restricted action. If the action is not restricted, the host  contacts the external application server  to invoke the action.","Once an action has been invoked, the host opens (step ) and the user agent displays (step ) the service application wrapper that contains the service application user interface (i.e., the output) of the external application server . The host  generates the service application entry URL used to call the external application server  and invoke the selected action. The host  consults (step ) the discovery metadata for the selected action and document type to obtain the parameters and the format of the service application entry URL. The base of service application entry URL is the address of the external application server appended with additional path information for the appropriate service application and any required or optional parameters. The parameters include, but are not limited to, a URL pointing to an address within the host endpoint, an identifier or locator for the resource that is the target of the selected action, and, optionally, the access token for the user  based on the authentication scheme used by the host. The host  already knows the identity of the user  based on the authentication scheme used by the host  and also knows the identity of the document because the host  is providing it. In various embodiments, the resource identifier is combined with a selected address within the host endpoint URL to create a metadata URL for the document.","Under the open platform interface, the metadata URL is used to manipulate the resource metadata or properties of the resource (e.g., locking the file or identifying the owner of the file). By convention, the metadata URL has a defined structure and the open platform interface derives the other URLs that are used by the open platform interface from the metadata URL. In the various embodiments, the URLs for additional actions are obtained by making substitutions in the metadata URL or appending paths to the metadata URL. In one embodiment, the metadata URL path has the form \\\\<host address>\\wopi\\<collection type>\\<resource ID> where <host address> is the domain name of the host, <collection type> refers to the type of resource (e.g., files or folders), and <resource ID> identifies that target resource within that collection.","Next, the host  generates (step ) the access token linking the user  and the document. The host combines (step ) the parameters with the base URL of the external application server  to construct the service application entry URL. In some embodiments, the service application wrapper is responsible for generating the parameters and constructing the service application entry URL. The host  then directs the user agent  to navigate (step ) to the service application  running at the service application entry URL. The external application server  parses (step ) the service application entry URL and extracts the metadata URL and the access token. The external application server  also posts (step ) the service application user interface, which contains the service application user interface and the document content, to the service application wrapper. The service application user interface is viewable (step ) via the user agent on the client computing device .","Once an action against a document has been invoked by the host , the external application server  initiates all further communications with the host  (e.g., accessing a document stored on the host or performing other file system actions) through requests sent to the host endpoint . In the illustrated embodiment, obtaining the document from the host  occurs in multiple steps. The external application server  sends (step ) a document metadata request that includes the access token and the file identifier, to the metadata URL of the host endpoint  in order to learn about the document (i.e., to get the document metadata\/properties). In some embodiments, the document metadata request includes a proof header including the cryptographic signature, and the host examines (step ) the cryptographic signature before returning the information about the document to the service application . The host  optionally validates the access token (step ) before returning the document metadata. If the host  cannot verify the cryptographic signature using the proof key or validate the access token, the host denies (step ) the document metadata request. Otherwise, the host returns (step ) the document metadata that is relevant to the request to the external application server in the body of the response, which is consumed (step ) by the external application server .","Next, the external application server sends (step ) a second request, which also includes the access token and the file identifier to the file access URL to obtain the binary contents of the document. In various embodiments, the file access URL is a modified version of the metadata URL generated according to a formula or patent established by the conventions of the open platform interface and does not need to be provided in the document metadata. In one embodiment, the file access URL is generated by appending \u201c\\content\u201d to the metadata URL (i.e., by adding a subpath\/folder\/directory). As with the document metadata request, some embodiments of the document content request include a proof header including the cryptographic signature, and the host optionally examines (step ) the cryptographic signature before returning the document content to the service application . The host  also optionally validates the access token (step ) before returning the binary content of the document. If the host  cannot verify the cryptographic signature using the proof key or validate the access token, the host ignores or denies (step ) the document content request. Otherwise, the host returns (step ) the document content in the body of the document content response, which is consumed (step ) by the external application server . Alternatively, the file access URL provided in the document metadata is a direct access URL, which is a direct link to the document content. The use of a direct access URL is beneficial when a content storage system (i.e., the host) maintains the document metadata on one set of servers and the actual document content on a different set of servers. Using the direct access URL eliminates the need for the host to serve as a middle man to get the document content stored on a separate server. In several embodiments, a request to the direct access URL does not use the proof system and is not decorated with the normal open platform interface headers.","As the document content is received, the external application server  updates (step ) the service application user interface to include the document content, which allows the user  to access the document. The service application wrapper  provided by the host  displays (step ) the updated service application user interface. The user  interacts (step ) with service application user interface via the user agent to manipulate the document. The external application server  processes (step ) the interaction by the user  and manipulates the document content as required. The steps of updating (step ), displaying (step ), interacting with (step ), and processing (step ) the service application user interface repeat as necessary until the service application determines (step ) that the user  is finished interacting with the document.","After all interaction with the document concludes, the external application server  requests (step ) that the host  commit any changes made to the document and closes (step ) the service application session. The host  responds by saving the document (step ), if necessary, and closing the document (step ).","As previously indicated,  represent one embodiment of the process and should not be construed as limiting the process to any particular set or sequence of steps. Other embodiments of the process may include additional steps, omit steps, combine steps, and alter the order of the steps. Examples of alternate embodiments of the process are described below. In some embodiments, the host also checks restrictions prior to or at the time of generating an action link or a dynamic user interface controls (e.g., a context menu) used to access to the functionality provided by the external application server. If the action is restricted for that document type, the host does not generate\/display the action link or the command in the dynamic user interface control. Such preliminary verification prevents the user  from being offered the opportunity to perform actions on the document only to be denied after selecting the action link. In another embodiment, the host  predetermines the format of the service application entry URLs at the time the host consults the discovery metadata to determine the actions on the document supported by the external application server , effectively combining step  and step .","As described herein, an open platform interface system allowing host agnostic integration between a host and an external application server using common protocols is provided. Under the open platform interface system, authentication, security, and file system operations are solely the responsibility of the host. The external application server does not include the complexity and overhead associated with network access, user authentication, file storage, network and file security, and other administrative tasks normally handled by other servers within a network and often specific to a particular enterprise. Omitting such features and focusing the external application server on handling document actions through the open interface protocol allows the external application server to be used in a wide range of enterprise network scenarios. It should be appreciated that an external application server performing as described herein and assuming additional roles and responsibilities normally handled by other servers on the enterprise network falls within the scope and spirit of the present invention.","The embodiments and functionalities described herein may operate via a multitude of computing systems such as the host , and the external application server , and the client computing device  described above with reference to , including wired and wireless computing systems, mobile computing systems (e.g., mobile telephones, tablet or slate type computers, laptop computers, etc.). In addition, the embodiments and functionalities described herein may operate over distributed systems (e.g., cloud-based computing systems), where application functionality, memory, data storage and retrieval and various processing functions may be operated remotely from each other over a distributed computing network, such as the Internet or an intranet. User interfaces and information of various types may be displayed via on-board computing device displays or via remote display units associated with one or more computing devices. For example user interfaces and information of various types may be displayed and interacted with on a wall surface onto which user interfaces and information of various types are projected. Interaction with the multitude of computing systems with which embodiments of the invention may be practiced include, keystroke entry, touch screen entry, voice or other audio entry, gesture entry where an associated computing device is equipped with detection (e.g., camera) functionality for capturing and interpreting user gestures for controlling the functionality of the computing device, and the like.  and the associated descriptions provide a discussion of a variety of operating environments in which embodiments of the invention may be practiced. However, the devices and systems illustrated and discussed with respect to  are for purposes of example and illustration and are not limiting of a vast number of computing device configurations that may be utilized for practicing embodiments of the invention, described herein.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["300","102","104","110","300","302","304","304","304","305","306","320","108","112","118","305","300","308","300","300","309","310"]},"As stated above, a number of program modules and data files may be stored in the system memory . While executing on the processing unit , the programming modules , such as the user agent , the host application , or the service application  may perform processes including, for example, one or more of the stages of the method shown in . The aforementioned process is an example, and the processing unit  may perform other processes. Other programming modules that may be used in accordance with embodiments of the present invention may include electronic mail and contacts applications, word processing applications, spreadsheet applications, database applications, slide presentation applications, drawing or computer-aided application programs, etc.","Generally, consistent with embodiments of the invention, program modules may include routines, programs, components, data structures, and other types of structures that may perform particular tasks or that may implement particular abstract data types. Moreover, embodiments of the invention may be practiced with other computer system configurations, including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","Furthermore, embodiments of the invention may be practiced in an electrical circuit comprising discrete electronic elements, packaged or integrated electronic chips containing logic gates, a circuit utilizing a microprocessor, or on a single chip containing electronic elements or microprocessors. For example, embodiments of the invention may be practiced via a system-on-a-chip (SOC) where each or many of the components illustrated in  may be integrated onto a single integrated circuit. Such an SOC device may include one or more processing units, graphics units, communications units, system virtualization units and various application functionality all of which are integrated (or \u201cburned\u201d) onto the chip substrate as a single integrated circuit. When operating via an SOC, the functionality, described herein, with respect to the user agent , the host application , or the service application  may be operated via application-specific logic integrated with other components of the computing device  on the single integrated circuit (chip). Embodiments of the invention may also be practiced using other technologies capable of performing logical operations such as, for example, AND, OR, and NOT, including but not limited to mechanical, optical, fluidic, and quantum technologies. In addition, embodiments of the invention may be practiced within a general purpose computer or in any other circuits or systems.","Embodiments of the invention, for example, may be implemented as a computer process (method), a computing system, or as an article of manufacture, such as a computer program product or computer readable media. The computer program product may be a computer storage media readable by a computer system and encoding a computer program of instructions for executing a computer process.","The term computer readable media as used herein may include computer storage media. Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. The system memory , the removable storage device , and the non-removable storage device  are all computer storage media examples (i.e., memory storage.) Computer storage media may include, but is not limited to, RAM, ROM, electrically erasable read-only memory (EEPROM), flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store information and which can be accessed by the computing device . Any such computer storage media may be part of the computing device . The computing device  may also have one or more input device(s)  such as a keyboard, a mouse, a pen, a sound input device, a touch input device, etc. The output device(s)  such as a display, speakers, a printer, etc. may also be included. The aforementioned devices are examples and others may be used.","The term computer readable media as used herein may also include communication media. Communication media may be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d may describe a signal that has one or more characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media may include wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, radio frequency (RF), infrared, and other wireless media. The computing device  may include one or more communication connections  allowing communications with other computing devices . Examples of suitable communication connections  include, but are not limited to, RF transmitter, receiver, and\/or transceiver circuitry; universal serial bus (USB), parallel, or serial ports, and other connections appropriate for use with the applicable computer readable media.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIGS. 4A and 4B","FIG. 4A"],"b":["400","400","400","400","405","410","400","405","400","415","415","400","405","400","400","435","435","405","420","425","400","400"]},"Although described herein in combination with the mobile computing device , in alternative embodiments the invention is used in combination with any number of computer systems, such as in desktop environments, laptop or notebook computer systems, multiprocessor systems, micro-processor based or programmable consumer electronics, network PCs, mini computers, main frame computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network in a distributed computing environment; programs may be located in both local and remote memory storage devices. To summarize, any computer system having a plurality of environment sensors, a plurality of output elements to provide notifications to a user and a plurality of notification event types may incorporate embodiments of the present invention.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 4B","b":["400","402","402","402"]},"One or more application programs  may be loaded into the memory  and run on or in association with the operating system . Examples of the application programs include phone dialer programs, e-mail programs, personal information management (PIM) programs, word processing programs, spreadsheet programs, Internet browser programs, messaging programs, and so forth. The system  also includes a non-volatile storage area  within the memory . The non-volatile storage area  may be used to store persistent information that should not be lost if the system  is powered down. The application programs  may use and store information in the non-volatile storage area , such as e-mail or other messages used by an e-mail application, and the like. A synchronization application (not shown) also resides on the system  and is programmed to interact with a corresponding synchronization application resident on a host computer to keep the information stored in the non-volatile storage area  synchronized with corresponding information stored at the host computer. As should be appreciated, other applications may be loaded into the memory  and run on the mobile computing device , including the user agent , the host application , or the service application , described herein.","The system  has a power supply , which may be implemented as one or more batteries. The power supply  might further include an external power source, such as an AC adapter or a powered docking cradle that supplements or recharges the batteries.","The system  may also include a radio  that performs the function of transmitting and receiving radio frequency communications. The radio  facilitates wireless connectivity between the system  and the \u201coutside world\u201d, via a communications carrier or service provider. Transmissions to and from the radio  are conducted under control of the operating system . In other words, communications received by the radio  may be disseminated to the application programs  via the operating system , and vice versa.","The radio  allows the system  to communicate with other computing devices, such as over a network. The radio  is one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.","This embodiment of the system  provides notifications using the visual indicator  that can be used to provide visual notifications and\/or an audio interface  producing audible notifications via the audio transducer . In the illustrated embodiment, the visual indicator  is a light emitting diode (LED) and the audio transducer  is a speaker. These devices may be directly coupled to the power supply  so that when activated, they remain on for a duration dictated by the notification mechanism even though the processor  and other components might shut down for conserving battery power. The LED may be programmed to remain on indefinitely until the user takes action to indicate the powered-on status of the device. The audio interface  is used to provide audible signals to and receive audible signals from the user. For example, in addition to being coupled to the audio transducer , the audio interface  may also be coupled to a microphone to receive audible input, such as to facilitate a telephone conversation. In accordance with embodiments of the present invention, the microphone may also serve as an audio sensor to facilitate control of notifications, as will be described below. The system  may further include a video interface  that enables an operation of an on-board camera  to record still images, video stream, and the like.","A mobile computing device  implementing the system  may have additional features or functionality. For example, the mobile computing device  may also include additional data storage devices (removable and\/or non-removable) such as, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by the non-volatile storage area . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data.","Data\/information generated or captured by the mobile computing device  and stored via the system  may be stored locally on the mobile computing device , as described above, or the data may be stored on any number of storage media that may be accessed by the device via the radio  or via a wired connection between the mobile computing device  and a separate computing device associated with the mobile computing device , for example, a server computer in a distributed computing network, such as the Internet. As should be appreciated such data\/information may be accessed via the mobile computing device  via the radio  or via a distributed computing network. Similarly, such data\/information may be readily transferred between computing devices for storage and use according to well-known data\/information transfer and storage means, including electronic mail and collaborative data\/information sharing systems.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 5","b":["108","112","118","112","118","522","524","526","528","530","112","118","520","112","118","520","112","118","520","112","118","515","110","300","110","110","110","110","516"],"i":["a","b ","c "]},"Embodiments of the present invention, for example, are described above with reference to block diagrams and\/or operational illustrations of methods, systems, and computer program products according to embodiments of the invention. The functions\/acts noted in the blocks may occur out of the order as shown in any flowchart. For example, two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order, depending upon the functionality\/acts involved.","While certain embodiments of the invention have been described, other embodiments may exist. Furthermore, although embodiments of the present invention have been described as being associated with data stored in memory and other storage mediums, data can also be stored on or read from other types of computer-readable media, such as secondary storage devices, like hard disks, floppy disks, or a CD-ROM, a carrier wave from the Internet, or other forms of RAM or ROM. Further, the disclosed methods' stages may be modified in any manner, including by reordering stages and\/or inserting or deleting stages, without departing from the invention.","In various embodiments, the types of networks used for communication between the computing devices that make up the present invention include, but are not limited to, an internet, an intranet, wide area networks (WAN), local area networks (LAN), and virtual private networks (VPN). In the present application, the networks include the enterprise network and the network through which the client computing device accesses the enterprise network (i.e., the client network). In one embodiment, the client network is part of the enterprise network. In another embodiment, the client network is a separate network accessing the enterprise network through externally available entry points, such as a gateway, a remote access protocol, or a public or private internet address.","The description and illustration of one or more embodiments provided in this application are not intended to limit or restrict the scope of the invention as claimed in any way. The embodiments, examples, and details provided in this application are considered sufficient to convey possession and enable others to make and use the best mode of claimed invention. The claimed invention should not be construed as being limited to any embodiment, example, or detail provided in this application. Regardless of whether shown and described in combination or separately, the various features (both structural and methodological) are intended to be selectively included or omitted to produce an embodiment with a particular set of features. Having been provided with the description and illustration of the present application, one skilled in the art may envision variations, modifications, and alternate embodiments falling within the spirit of the broader aspects of the claimed invention and the general inventive concept embodied in this application that do not depart from the broader scope."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Further features, aspects, and advantages of the present disclosure will become better understood by reference to the following detailed description, appended claims, and accompanying figures, wherein elements are not to scale so as to more clearly show the details, wherein like reference numbers indicate like elements throughout the several views, and wherein:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 2A to 2E"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
