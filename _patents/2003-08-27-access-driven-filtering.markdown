---
title: Access driven filtering
abstract: A test domain configuration module generates graphical user interfaces for identifying information about desired tests such as data types and domain configurations, and collects information used by other modules to generate tests. The identified information may include, for example, an abstract syntax, a static semantic, max counts on instances of data types, or costs of field accesses or data types for max path costs or max expression costs. A test input generator, generates test input for the identified and configured data types. In one case, the generated test inputs are generated as tree data structures. A predicate determines whether a generated test input follows semantic conditions. A test input evaluator counts instances of data types in, sums paths through, or sums total costs of, the generated test inputs. A test acceptance module saves test inputs acceptable to the predicate and the test input evaluator.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07444622&OS=07444622&RS=07444622
owner: Microsoft Corporation
number: 07444622
owner_city: Redmond
owner_country: US
publication_date: 20030827
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","COPYRIGHT AUTHORIZATION","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION","Overview of Technology","OVERVIEW OF AN EXEMPLARY LANGUAGE UNDER TEST","Exemplary Abstract Syntax","Exemplary Expression Generation","Exemplary Static Semantic","Exemplary Access Vector","Exemplary Cycle Management","Exemplary Limit on Data Types","Exemplary Costs Affecting Tree Behavior","Exemplary Variations for Bounding Trees","Exemplary Cost Assigning Functions","Expanding Language Requirements","Exemplary Test Generation Scenario","Exemplary System of Test Input Generation","Exemplary Method of Test Generation","Exemplary Configuration of a Data Domain Using a Graphical User Interface to Provide Domain Configuration Information","Computing Environment","Alternatives"],"p":["The technical field relates to methods and systems for testing and verification of computer programs. More particularly, the field relates to managing inputs created for testing and verification of computer programs.","A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","Reliability is of key importance to success of any software in the market. Users are easily deterred by a faulty software program. Thus, software developers expend a significant amount of resources to ensure their software is reliable. However, continued pressure on software developers to shorten software development cycles has placed on them an increased demand for making the process of software testing and verification more accurate and less time consuming. Furthermore, costs related to testing and verification has grown to represent a significant portion (50% by some estimates) of the overall cost of developing a piece of software. Thus, automation tools for testing and verification have grown to be more and more sophisticated over time.","One aspect of testing and verification of software (regardless of the type of automation) that is particularly challenging is the ability of a testing tool used to create input data to be used in testing. For instance, if a program accepts integer data as input, one method of testing might be to exhaustively test the software by applying virtually an infinite number of different integers. However, that is not only costly and time consuming but it also may be meaningless or impossible, since the complete set of integers is infinite. Thus, a tester may generate a more meaningful set of integers that would represent a thorough test without testing all integers. For instance, if Age is a field of the type integer then a meaningful domain for such a data member may be limited to integers ranging from 1-100. Such finitization is applicable to virtually any type of data. Thus, the process of testing can be vastly improved by managing the inputs used to manage testing of software programs.","However, manually identifying the various elements of a program and the data types they use and manually configuring inputs for testing can be time consuming, if not impossible. Thus, there is a need to automate the process of identifying the various data structure elements of a program to generate a meaningful set of data for testing and verification.","Furthermore, programs generally don't use data devoid of any context or relationship to other data. For example, most programming languages allow for defining data types and these data type definitions may be further used in defining particular data members such as data fields, and parameters of a program. For example, a person data type may include fields of name, height, weight, and date of birth. Thus, weight may appear not only as a data member of a class, but also as inputs to a method defined in a person class. In a program of any meaningful size there may be literally thousands, if not more, of such relationships and these relationships may also be more complex than the simple example provided above. Thus, there is a need for methods and systems that automate the process of creating inputs used for testing and verification of program and method behaviors.","The described technologies provide methods and systems for generating tests for testing computerized methods such as programs, APIs or compilers.","One example of the described technology provides a framework for defining data types, assigning costs, and configuring domains. A test developer then selects a test generation icon to create the tests for input to the language methods or a compiler of the language. A method recursively generates trees, and then calls a predicate with the tree as input, and the predicate returns true or false for the tree. An access vector is used to determine the point of failure, costs are summed, and data type uses are counted as the tree is built. Trees failed for any reason, are changed and built up recursively by varying data types. In one example, this continues until no enumerations exist that have not failed based on costs, counted instances, or the predicate. An access vector is checked to determine the focus of change.","In another example, one or more programs utilize described components or modules to create input for testing other programs. In one example, a test domain configuration module generates graphical user interfaces for identifying information about desired tests such as data types and domain configurations, and collects information used by other modules to generate tests. The identified information may include, for example, an abstract syntax, a static semantic, max counts on instances of data types, or costs of field accesses or data types for max path costs or max expression costs. An expression generator, generates expressions of the identified and configured data types. In one case, the generated expressions are generated as tree data structures. A static semantic determines whether a generated expression follows semantic conditions. An access monitor creates a vector of data accesses made by the static semantic in a generated expression. An expression evaluator counts instances of data types in, sums paths through, or sums total costs of, the generated expression. A test acceptance module saves expressions acceptable to the static semantic and the expression evaluator.","Additional features and advantages will be made apparent from the following detailed description, which proceeds with reference to the accompanying drawings.","Generating test cases for an Application Programming Interface (API), involves finding interesting parameters (inputs) for each method and parameters are currently generated manually. In one respect, the described technology is an improved method for testing APIs that makes automatic test case generation possible. The overall size of the inputs is restricted for improved efficiency and a Boolean condition (the predicate) finds test cases that meet certain bounds.","The described technologies systematically search the input space of a method for interesting input parameters. API testing is one of the core problems of testing in general. The technology also finds parameters for language testing when source code or bytecode is viewed as parameters (input) to a compiler or interpreter (method) under test. In the compiler arts, a string of language constructs (e.g., source code) is received in serial form and parsed into a graph or tree. In one example, the technology creates strings for inputs to test such a language compiler or interpreter. In such a case, a string is the interesting input parameters created for language verification.","In one example, the technology generates strings for a compiler, or parameters for a method via a tree generator and a static semantic. The tree generator creates a tree that is tested for semantic conditions by the static semantic. After a tree tests positive on the static semantic, the input is serialized as input for testing a method or compiler under test.","Note that an input to a static semantic (predicate) can be an arbitrary object graph or tree. The object graph or tree can consist of instances of several data types. For example, compilers for new languages can be systematically tested using the described technologies. Compiler testing requires the generation of language inputs. Today, most test cases are either written by hand or are randomly generated. Instead, the described technologies are able to exhaustively find test cases that are accepted by a boolean predicate condition within certain bounds.","The concept of automatic testing based on predicates is not new. See Boyapati, et al., \u201cKorat: Automated Testing Based on Java Predicates,\u201d MIT Laboratory for Computer Sciences, presented at the International Symposium on Software Testing and Analysis, on Jul. 23, 2002, in Rome, Italy (hereafter \u201cKorat\u201d). However, Korat fails to describe certain enhancements that make automatic test case generation feasible.","In its abstract, Korat states that given \u201ca predicate and a bound on the size of its inputs, Korat generates all (nonisomorphic) inputs for which the predicate returns true.\u201dIn Korat, the inputs (i.e. the parameters) are bounded by restricting the number of instances of each possible data type in the inputs.","In one example, the technology restricts a potentially infinite search space for generating testing input. In one example, a tree generator constructs a tree of tree of data elements as an input to a program, such as a method, an API or a compiler. If the method is a compiler, the tree is language constructs that are parsed into a tree or graph data structure. Starting from the root of the graph or tree inputs, a method assigns costs to the links of the graph. A test developer sets a maximum cost as input to the method, and the costs of data elements are summed as the graph is built. In another example, a method monitors the predicate as it accesses data elements, and sums the costs of elements accessed by the predicate. In one example, the method sums the costs of a path through the element. In another example, the method sums the costs for plural paths through the tree. In one example, the global bound is enforced by a module monitoring the execution of the predicate and recording data accesses made by the predicate. As the data nodes of the tree are traversed by the predicate via the links, the global costs are summed for each node. The global bound on costs effectively allows restricting overall size of the inputs, in addition to, or instead of, restricting the number of instances of particular data types.","Additionally, Korat only deals efficiently with object graphs, but not trees (i.e., connected, non-cyclic graphs). In order to specify a tree in Korat, a user has to code the non-cyclic-check himself as part of the predicate. In Korat, the condition that the graph must be a tree must be encoded in the context sensitive predicate. Thus, a significant effort and resources monitoring the predicates execution is now concerned with the tree check in Korat.","Instead, the technology described herein provides non-cyclic graphs (trees), by adding only not-seen-before instances of a data type to an existing tree, thereby providing that no new cycles are introduced.","Korat dictates that each generated graph may only include a certain number of instances of each data type. Although this prevents an infinite search space, the combinations of graphs grows exponentially with the number of data types. However, limiting data types or instances may unnecessarily preclude the generation of certain input expressions.","Additionally, the technology described herein distinguishes two categories of complex data types, namely, classes and structures. The technology starts with an initial input. In one example, this initial input is defined by the test developer. In another example, this initial input is constructed by considering non-recursive data types where possible. Then the technology varies this initial input by varying the fields of the instances that are already part of the previously generated input. In one example, when an expression generator varies a field of an already generated expression, a class or a structure can be introduced in place of the field. If a class is selected, an already used instance of a class may be introduced in its place. If an already used instance of a class is introduced (e.g., a node already in the generated tree), this may introduce a cycle between instances of classes. Whereas, if the expression generator introduces a new, not yet used instance of a class into the graph, then no cycles are introduced, and the graph is extended by another node. As with classes, if the expression generator, generates a new, not used instance of a structure, then no new cycles are introduced. In this way, non-cyclic expressions are created.","Korat works for generating test data for object-oriented base class libraries (BCLs). Typical features of BCLs are that the inheritance hierarchy is shallow, BCLs don't use many abstractions, and BCLs can typically be tested with a small number of different objects (since they don't rely on existing infrastructure).","However for language models these constraints do not hold. The definition of abstract syntax trees (ASTs) typically results in a large number of \u201cclasses\u201d, all related by inheritance. For generating reasonable ASTs, many different nodes are often needed, along with ASTs that not only vary in depth but also in breadth.","However the main data structure for programming language semantics are ASTs, for which isomorphism checks can be performed much faster than for arbitrary object graphs. Finally, semantics live on a higher abstraction level than BCLs. For example, semantics deal with sets of bound and free variables, or with environments that map names to locations.","The described technologies extend Korat in several ways. For example, the technology limits the search space by not only putting bounds on the number of instances of a data type used, but also on the maximal number of field accesses. Fields which are accessed after the limit has been reached are no longer varied. As a consequence, the technology generates more variations in program breadth, which works particularly well for language testing. In another example, the technology distinguishes object graphs from trees, and detects isomorphism of trees in an efficient way.","The semantics of modem languages is often split into phases. The first phase of the static semantics is typically name resolution, in which names are bound to definitions. Next comes type-checking, which makes sure that operations are only applied on correctly typed values, and finally the AST is compiled. The dynamic semantics is often given as an interpreter working on the fully resolved and type-correct AST. Thus, the described technology first generates syntactically correct parameters and programs (as inputs), which exposes all name-resolution errors distinguished by the specification. Next, parameters or programs which pass name resolution process are checked by the semantics to expose type errors.","A careful look at static and dynamic semantics, determines that it is the structure of the semantics that distinguishes correct from incorrect programs. For instance, when the types of two operands of a binary operator are not of the required type, the type checking semantics will generate an error. However, if the required types agree, another execution path is taken. Test case generation thus becomes a path sensitizing problem. In one case, if 100% branch coverage of the specification is reached, test case generation terminates.","Preferably, the semantics from which test cases should be generated, is given in the Abstract State Machine Language (AsmL). AsmL is a model-based executable specification language. Since the described technology does not require any specific language, ASML will be used in the following discussion.","This technology generates inputs for methods as text in strings, or as trees. A compiler takes programs as input and decides whether the program syntax and semantics are correct or not, and then reduces the program to executable or bytecode. So generating language inputs is useful for testing the correctness of compilers.","For example, this technology is useful for XPATH which is a language used to navigate through nodes in an XML tree. XPATH provides the ability to move back and forth between nodes of an XML tree, and provides contra-structures for altering tree traversal. Thus, this technology is useful for generating trees that are submitted directly to XPATH to make sure XPATH processes the tree inputs as expected.","In general, given a description of a grammar, it is desirable generate all the possible trees of the grammar for testing. However, not all possible trees are desirable. This technology introduces a \u201cfiltering\u201d process that generates only those trees desirable according to a definable situation. Thus, desirable trees are described by a filter predicate, and further governed by other factors such as summing the costs to reach nodes of a tree. Additionally, by building trees recursively based on number of data types, and global costs, the number of unacceptable trees built is reduced. The described technology allows filtering as trees are built instead of building all possible trees and throwing away unacceptable trees.","The following describes how to automatically generate test cases using the technology by means of an example called Tiny Language (TL). Tiny Language is a relatively simple language for describing arithmetic expressions. The test cases generated are expressions of this language.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 2","FIG. 1"],"b":["200","202","100","102","204","104","206","106","102","104"]},"For example, a language may require all input expressions to be closed. In this example, closed means that every identifier must be defined before it is used. Under this expression requirement, only the first and last expressions ,  would qualify as closed expressions. If input expressions were limited to expressions that meet the closed requirement, then the first and last expression would be context correct while the other expressions would contain context errors. For example, the second expression  is not closed because \u201ca\u201d is not an assigned identifier (i.e., it has no value assigned to it). Similarly, the third expression and the fourth expression have no values assigned to identifiers a and b, respectively. Context conditions are best described as attribute grammars or in more general terms as predicates over the abstract syntax of a language.","Thus, when using this technology for generating inputs for testing, in one example, instead of generating thousands or millions of potentially illegal expressions (e.g., program string method calls, etc.), test generation may proceed differently. First, an abstract syntax (e.g., ) of the language is provided to test as an abstract data type. Using this abstract syntax, an expression generator will generate instances (e.g., trees) of this data type (e.g., as discussed in relation to ). Second, a static semantic (i.e., a predicate) of the language (e.g., ) is used to test whether a generated expression follows some semantic condition (e.g., testing whether an expression is closed). In one example, the expression is generated in memory as a tree. Additionally, in one example, the predicate is instrumented with binary code, so as the predicate accesses the nodes of the tree (i.e., the bounded data types and fields), the instrumented binary code counts the bounded data type accesses and\/or sums costs assigned to graph edges. Thus, while the predicate checks the tree in order to determine whether the it is formed according to the predicate, data accesses are checked in order to determine whether the tree meets the set domain requirements such as maximum data type instances or the maximum total costs for each edge path through summed edges. Third, an exemplary printing method (e.g., ) is shown for printing the abstract data type according to the concrete syntax of well formed expressions , . This exemplary method  can also be used once a well formed expression is created, to return the generated input expression into source code (e.g. a file) as a valid test case for input to a compiler (i.e. to serialize the generated trees as normal strings of the concrete syntax). Additionally, an interpreter method (i.e., a dynamic semantic) is provided (e.g., ) for evaluating an expression if desirable. Finally, an interface (e.g., ) is provided for describing an input domain, for example, how many instances of a particular data type\/field should be maximally generated, along with semantic choices for the semantic carrying terminals and nodes that appear in the abstract syntax tree, and for assigning costs to edges between nodes of the tree for summing costs (e.g., ).",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 3","b":["100","300"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 7","b":["700","702","704","706","708","302","304","314","306","308","310","312","300"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 8","b":["800","802","804"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 9","b":["900","500","400"]},"In one example, an expression generation method builds a tree one node at a time and then calls the predicate with each tree to see if the tree is closed. For an orderly exploration of expressions, data types of an expression set  are assigned an enumerated order  (i.e. Exp (Any=0, Const=1, . . . Let=4) and Op(Any=0, Add=1, Sub=2)). The enumerated order can be used to keep track of an orderly exploration of an expression space. Since an expression  starts with a Const, Var, Bin, or Let data type -, if a node is presently at Const, an increment of one through the enumerated data types will next test a Var node.","In one example, a expression generation method starts with an unacceptable data type called \u201cAny\u201d . Since \u201cAny\u201d is not an acceptable case for the exemplary expression  it is not expected by the predicate. Thus, \u201cAny\u201d provides a start state that verifies a failure case.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 10","b":["0","912","906","1002","500","1002","502","1002","1","908","914","1004","500","1004","502","1004","400","1004","0","1","11"]},"The tree generation method then increments the enumeration, Exp() ,  and obtains the Var data type for a new tree . The test generation method then invokes the predicate  with the new tree expression . In this case, the predicate is able to match  the \u201cVar\u201d data type , and the predicate returns the Boolean value of the expression \u201cn in ns\u201d . Notice that in this predicate, the bounded name set called \u201cns\u201d , starts out as empty \u201c{ }\u201d , and variable names are only added (i.e., ns+{n})  in the second \u201cClosed( )\u201d call  of a \u201cLet\u201d match . Thus, in this case, since \u201cy\u201d is not in \u201cns\u201d, the Boolean statement returns false, and this tree is not added to the test list.","The tree generation method then increments the enumeration to Exp(), and obtains the Bin data type for a new tree . In this case, the Bin node has field pointers to other data type nodes in the fields \u201cop,\u201d \u201cleft,\u201d and \u201cright.\u201d Since the \u201cop\u201dfield of the Bin points to operator data types, the test generation creates an Op node . The Op node possible values  are enumerated  to help simply orderly test generation. In this example tree, the Op node  is assigned the Op() enumeration value which is the \u201cAdd\u201d value. Here it is assumed that the Op node has already enumerated the Op() value of \u201cAny\u201d and failed by the predicate. Additionally, since the left and right fields of the Bin node  can point to any Exp data types , these data types are each tested accordingly for each field. In this example, the node pointed to by the left field of the Bin node  has enumerated through the Exp()=\u201cAny\u201dnode to the present Exp()=Const node  now shown. It is also assumed that the node pointed to by the right field of the Bin node  has enumerated through the Exp()=\u201cAny\u201d, Exp()=\u201cConst\u201d, Exp()=\u201cVar\u201d, Exp()=\u201cBin\u201d, to arrive at the present data type node of Exp()=\u201cLet\u201d . To develop a visual understanding of the recursive nature of an exemplary language expression abstract syntax , the \u201cLet\u201dnode  is shown with exemplary nodes pointed to by its \u201cname\u201d , \u201cdef\u201d , and \u201cbody\u201d  fields. Note that since the \u201cdef\u201d and \u201cbody\u201d fields of the Bin node are defined as expressions themselves, the possible set of trees is infinite.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 11","b":["918","920","1100","1102","1100"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 5","b":["500","502","502"]},"The exemplary static semantic  recursively walks over the input expression, examines the tree branches, collects bound names, and verifies that all variables used in an expression have been previously bound. As the static semantic recursively accesses the tree, a data structure (e.g., an access vector, list, table, etc.) is maintained as nodes of the tree are accessed by the static semantic.","Knowing the last node or leaf of the tree that was accessed is valuable for several reasons. For example, the last access identifies where the tree needs to be changed if a failure occurred. Given the node or leaf that failed the tree, that input can be changed to see if another input would make the tree acceptable. (e.g., check to see if the next enumeration defined for that type makes the tree acceptable). Additionally, if the tree is acceptable, it is still desirable to check whether enumerations of the field that was accessed last are also acceptable.","An access vector is an order of data types of the tree visited by the static semantic. For example, given an expression \u201c(let x=9 in x)\u201d, formed according to the Tiny Language grammar, an exemplary abstract representation of the statement is Let(\u201cx\u201d, Const(), Var(\u201cx\u201d)). According to the abstract structure of an expression , for the Let data type , the name field is assigned \u201cx,\u201d the def field is assigned Const(), and the body field is assigned Var(\u201cx\u201d). Although many variations are possible, in one example, a tree generator generates this exemplary statement as shown in . Assuming the static semantic (i.e., predicate) is designed to receive a tree as input, the tree would be accessed in a certain pattern. The pattern of access would vary according to how the predicate is written and implemented to traverse a tree. However, so long as the same traversal method is used (e.g., depth-first, breadth-first, etc), between tree iterations, the access vector will contain relevant information.","Thus, the exemplary tree  is accessed by the predicate. Initially, the Closed method is called with the entire tree . The closed method  accesses the \u201cLet\u201dnode  in order to read the \u201cLet\u201d value for the match statement . Thus the first access in the access vector is called \u201c(a)\u201d and represents this \u201cLet\u201d access. Next, because of the match on Let , the closed method calls itself twice . In order to make the two calls , the method has to access the fields of the Let data type in order to name the fields \u201cn,\u201d \u201cd,\u201d and \u201cb,\u201d as shown in the two calls . Thus, the second access in the access vector is called \u201c(b)\u201d and represents this access to \u201cx\u201d  required for assignment to the \u201cn\u201d parameter . The third access in the access vector is called \u201c(c)\u201d and represents the access to \u201cConst\u201d  required for assignment to the \u201cd\u201d parameter . The fourth access in the access vector is called \u201c(d)\u201d and represents the access to \u201cVar\u201d  required for assignment to the \u201cb\u201d parameter . Once the assignments are made to the input parameters, the two recursive calls are made as shown .","The first recursive call to \u201cClosed(d, { })\u201d contains the d parameter which is assigned the \u201cConst\u201d node . The method accesses the \u201cConst\u201d node again in order to match Const . This would represent the fifth access to the tree, and could be recorded on the access vector if desirable. However, in this example, since this portion of the tree was already accessed, adding this second access would provide no additional information about acceptability, so it is not added to the access vector. Additionally, since this static semantic does not care about the value of the Const parameter Const (i.e. Const(_)), the \u201c9\u201d  is not accessed, and thus, not added to the access vector.","The second recursive call to \u201cClosed(b, ns+{n})  contains the \u201cb\u201d parameter and the \u201cn\u201d parameters. The access to \u201cn\u201d could be recorded on the access vector if desirable. However, in this example, this portion of the tree was already accessed, adding this further access would provide no additional information about acceptability, so it is not added to the access vector. The method accesses the \u201cVar\u201dnode  again in order to match Var . This would represent the sixth access to the tree, and could be recorded on the access vector if desirable. However, in this example, since this portion of the tree was already accessed, adding this second access would provide no additional information about acceptability, so it is not added to the access vector. However, the match on \u201cVar\u201d  checks to see whether or not \u201cx\u201d is bounded (i.e., \u201cn in ns\u201d), and this accesses the value  of Var to see if it is in \u201cns.\u201d Since \u201cn\u201dwas placed in \u201cns\u201d above , the statement returns true . Thus, this access is recorded in the access vector as \u201c(e)\u201d and represents the \u201cx\u201d access .","In this example, the access vector represents the following accesses: [(a)=\u201cLet,\u201d (b)=\u201c\u201cx\u201d,\u201d (c)=\u201cConst,\u201d (d)=\u201cVar,\u201d and (e)=\u201cx\u201d].","If the tree is going to fail by being rejected by the predicate, it is desirable to fail early, preferably even before the whole tree is generated. This is why it is desirable to build the tree one node at a time. In this case, the predicate returned true because the tree was well formed. However, if \u201cVar\u201d had been assigned the value \u201cy\u201d (e.g., Var(\u201cy\u201d)) in the example tree , then the final access (e) would have failed, and \u201cy\u201dcould be varied. Through enumerating through data types or assignments, \u201cy\u201d would eventually be replaced with \u201cx,\u201d thereby rendering an acceptable tree.","In general, it is desirable to focus on the last access, because when it fails, any sub-trees that exist lower in the tree from the failure can be ignored. In this way, by recursively building acceptable trees, a potentially infinite input space is reduced to a manageable size. Until a branch of a tree is acceptable (e.g., ) it is not relevant or effective to generate inputs (e.g., ) lower in the tree. Rather as each node of the tree is verified, the size of the tree is incrementally built (e.g., ). This avoids generating sub-trees that will never be reached because they have an unacceptable node above them in the tree.","Thus, tree generation starts by enumerating through assignable data types, and stops on failure, and makes enumerated changes at the point of a last access in an access vector. Additionally, for acceptable trees, the last access is varied to the next possible value, in order to find other acceptable variations of an acceptable tree. Nodes or leaves that are acceptable are saved for test, and provide a basis for finding additional trees. Nodes or leaves that are unacceptable, provide a focus of change for finding an acceptable variation. The access vector is useful in focusing on a point of input change, and enumerating is a way to determine a next assignment for change.","In Korat, a predicate was used to discover cycles in a generated tree. Thus, the predicate must check the entire tree for cycles before other predicate conditions are examined. This results in an access vector which contains already possible fields in no particular order. Thus there is no focus for further variation. Given the number of trees in contention, this solution is resource intensive and therefore prohibitive.","Instead, in this technology a tree is represented in structures and tree generation does not create cycles that are possibly introduced by reusing objects. In this technology, tree generation proceeds with selecting new structures, instead of pointing back into an existing graph.","However, it may be desirable to have cycles in a graph. In one example, cycles are allowed when desirable for a graph generation. Using the technology described herein, during configuration, a flag is set that represents that a data type is class and\/or should allow cycles during graph generation. Additionally, if cycles are not allowed, then a cycle detection method is provided by a test designer. Such cycle test methods are known in the arts, and generally involve traversing links in a graph and marking nodes already visited.","Korat provided for limiting the number of instances of objects in method parameters generated for tests. This limit provided a way to assure mixes of objects for method parameter inputs. However, for languages with many object types, the number of test cases quickly explodes. However, a limit on the number of instances of data types may still provide value in some contexts.","Using Tiny Language as an example, a tree generation could be limited to 10 instances of Bin, 5 instances of Let, 7 instances of Const, and 3 instances of Var for each tree generated. This domain restriction test configuration information could be obtained from a test developer via a GUI, file, or other input method. This technique may also be referred to as \u201clocal bounds.\u201d",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 13","b":["1300","1302","1304","1306","1308","1310","1312","1314","1316","1318","5","1320","1322","1324","1322","1326"]},"In one example, the search space is restricted by cost bounds. A cost is assigned to the edges of the object graph, and a bound can be given on the maximally accumulated cost (\u201cMaxCost\u201d) along each path. In one example, this maximum bound is enforced by closely monitoring the execution of the predicate and recording every data access. MaxCost restricts the overall size of the inputs, rather than just the number of instances of particular data types (or both restrictions can be simultaneously in place).","In the example graph , what is called global cost is actually a sum of costs down each path of the graph. In this example, path cost sum  should not exceed . MaxCost is helpful, for example, to create tress that are relatively uniform in nature.","In another example, in may be desirable to allow a tree to be long in one area, and short in other areas. This can be accomplished in a number of ways. For example, the global costs could be a bound placed on the sum of all paths, thereby allowing a tree to generate deep in one area, and short in others. In this case, a global cost is a cost of all paths through the tree. Of course, in some cases, it may be valuable to assign a maximum-path-cost and a maximum sum of all paths cost. The first could limit path sizes while the second limits overall tree size.","Depending on the way the predicate is written, it will access some node (the \u201croot\u201d) of the graph first, and then it may access other nodes by following the fields of the instance represented by the root node until the global costs for each path or sum of paths has been reached.","Additionally, it may be desirable to assign zero costs to certain nodes or leaves. This would be helpful, for example, in allowing a tree to add any missing leaves even after a local or global sum has been reached.","By applying different costs to trees via test configuration information, an arbitrary line that cuts off the tree growth is created. For example, costs might avoid trees that are heavy on one side or the other, if desirable. For example, with recursive data types such as Bin or Let, by assigning higher costs to expressions assigned to one side of a binary operator, a tree generation can be forced into one direction (e.g., Cost(Bin.left, [ Bin=5, Let=5, Const=1, Var-1 ]) and Cost(Bin.right, [Bin=1, Let=1, Const=1, Var=1]). By assigning higher costs to the left direction, the path MaxCost is quickly reached on left branches. This can be useful in cases, where allowing trees to grow in both directions produces symmetric behavior that adds nothing more to the test cases. Thus, by assigning Bin=1 as a cost to the right side of Bin data types, the tree can grow inexpensively to the right. But since growth to the left is expensive, trees that vary only by symmetry can all be built on one side.","In another case, costs may \u201cprogressively\u201d be assigned to certain data types or fields to weight their aggregate appearance in trees. For example, the first ten Bin data types built into a tree are free, but then each additional Bin data type increments progressively\u2014the eleventh Bin costs , the twelfth Bin costs , the thirteenth costs , and etc.","As previously stated, a predicate function may sum or count data types in conjunction with testing conditions of the static semantics. However, the summing costs of or counting of data types may also be done by the tree generation method while the tree is created or before the predicate is called on the created tree. Additionally, the predicate can be instrumented (e.g., injected with executable instructions) that monitor data accesses, count data types, and sum path and or total tree costs. Variations on the context of modules performing these techniques are within the scope of thought.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 14","b":"1400"},"Starting from the root, the predicate inspects the nodes through field accesses in a certain order. According to this order, costs accumulate (starting at zero) along the directed edges. When the MaxCost of the method is exceeded, the method cuts off the generation of the graph when a next access would exceed MaxCost. This global maximum for each graph path access, greatly reduces the search space. A sum of all paths may be computed instead of, or in addition to, a maximum path cost.","In addition to the other uses, distributed computing friendly languages require customized language interpreters and compilers for verifying traversing XML databases and schemas. These languages often have many varied language constructs comprising many different and varied data types and expression semantics. As the number of data types increase, the number of test cases explodes. Limiting the number of instances of each data type will create trees of mixed data types, but trees can still become very deep. By placing path cost sums on the tree, a tree fails sooner based on costs, thereby causing it to enumerate through other data types because of the failures. After the tree fails in one area (for any reason including costs) and enumerates through variations at the failed area using the access vector to focus change, enumeration eventually moves the focus to another part of the tree. For example, in , an exemplary enumeration focuses on the right most field in the Bin data type, and then enumerates one data type in the field to its left before returning to focus on the right field to enumerate through each data type in the right field enumerations. Requiring success in one part of the tree before building the tree larger eliminates building many trees that would never be acceptable.","Using the described technologies, these languages can be created and tested for very specific schemas or XML databases. A language developer (e.g., via test information configuration) generates a grammar, creates an abstract syntax, creates a predicate, assigns costs, creates trees, and serializes the trees for input for testing the compiler or interpreter created for the new language, or for testing inputs to methods of an API.","A tester writes the data types and configures the data types with a domain of input values for exploration. The described technologies provide the framework for defining a test domain such as data types, assigning costs, and configuring domains. The tester then selects a test generation icon to create the tests for input to the language methods or a compiler of the language. The test generator starts by creating a very small tree (possibly just one node, or possibly a user defined acceptable start tree). The test generation technique then calls the predicate with the tree as input, and the predicate returns true or false for the tree. An access vector is used to determine the point of failure, costs are summed, and instance uses are counted. Trees failed for any reason, are changed and built up recursively by varying data types. In, one example, this continues until no enumerations exist that have not failed based on costs, counted instances, or the predicate. The access vector is checked to determine the focus of change whether after a success or failure.","As shown in , a computer system  includes a hard drive memory , one or more processors , and main memory . The processor(s)  execute programs which include instructions data and\/or state. One or more programs execute modules - that create input  for testing other programs. A module is a function method component, thread, or process that performs a described service. In one example, a test domain configuration module  generates graphical user interfaces for identifying information about desired tests such as data types and domain configurations, and collects information used by other modules to generate tests. The identified information comprising an API, an abstract syntax, a static semantic, max counts on instances of data types, or costs of field accesses or data types for max path costs or max expression costs. An expression generator  generates expressions of the identified and configured data types. In one case, the generated expressions are generated as graph data structures. In another case, the graph data structures are tree data structures. However, the generated input could also be in strings. A static semantic  determines whether a generated expression follows semantic conditions. An access monitor  creates a vector of data accesses made by the static semantic in a generated expression. An expression evaluator  counts instances of data types in, sums paths through, or sums total costs of, the generated expression. A test acceptance module  saves expressions acceptable to the static semantic and the expression evaluator.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 16","b":"1600"},"At , a graphical component receives test domain information. In one example, the test domain configuration information includes an API or language under test along with data type assignments. In another example, the information includes data types and domain configurations, and information used to generate tests. The identified information could include an API, an abstract syntax, a static semantic, max counts on instances of data types, or costs of field accesses or data types for max path costs or max expression costs.","At , an expression is created according to the test domain information. In one example, the expression is created as a tree data structure, in another example, the expression is a string.","At , a next data element of the expression is accessed.","At , the data element access is recorded in a data structure (e.g., an access vector).","At , a static semantic is used to verify a semantic of an accessed data element. If the static semantic does not fail on a data element, then the costs of the data element are considered . If the static semantic fails a data element, then the method proceeds to enumerate on the last recorded access .","At , a data element is counted. If the count exceeds allowed instances of the element, the method proceeds to enumerate . If costs of access path is monitored the data element is added to the path costs, and checked against allowable path costs. If total expression costs are monitored, the data element costs is added to total expression costs. If any costs exceeds allowable costs, the expression return for enumeration . If counts and or costs are acceptable, the expression is checked for a next data element .","At , an expression is checked for more data elements. If the expression includes another data element, the method returns to access the data element . If the expression is empty, then last data element was acceptable to both the static semantic  and any cost conditions . Since the expression is an acceptable expression, the method saves the expression .","At , the expression is saved for testing a program. After the expression is saved, the method returns to enumerate .","At , the method enumerates to a next data type identified by enumerating on the last access recorded in an access record. If a next enumeration exists for the configured domain, then the method returns to generate a next expression  based on the previous expression with an enumeration. If no enumerated variation of the prior expression exists, then test generation is completed .","The configuration of the data domains for the data type Exp () and its component elements (e.g., its methods and fields) with the use of a user interface to provide the domain configuration information.  illustrates a definition of a data type of Exp (expression) . It is an abstract data type comprising of several sub-types Const , Bin , Let , and Var . Each of the sub-types , , , and  have their own fields. The sub-type Const  has the field val  which is of the data type Integer. The sub-type Bin  comprises of the fields op  of the data type Op, left  of the data type Exp, and right  of the data type Exp. The sub-type Let  comprises of the fields name  of the data type Name, def  of the data type Exp and body  of the data type Exp. Lastly, the sub-type Var  has a single field of name  of the data type Name. The data types Op and Name are defined at  and  respectively. Since the fields of some of the sub-types of data type Exp are themselves of the data type Exp this data type is a recursive case. A data type definition such as the one at  may be provided in a program's code.","A test tool reads a reflection of program code (e.g., data types, abstract syntax, or etc.) to generate a user interface element such as the one show in . As shown in , the user interface provides a list data types, sub-types, methods, fields, parameters and other data structure available for configuring their data domains. Using the user interface , the data structure elements may be chosen for configuring their data domains. In this case only the data type Exp  and its sub-types (, ,  and ) have been selected for domain configuration.","Another user interface element such as  in  may be used to specify the domain configuration information to be used to produce a data domain for the selected data structure elements. For instance, the user interface element  indicates that it is receiving user input for configuring the data domain for the sub-type Bin . The selector window  may be used to select various properties that may be associated with a Bin data type. For example, the Bin data type may include per instance costs, maximum allowable instances of Bin, or costs of different types of field assignments for different data types for Bin field accesses. Once the domain configuration information is entered the \u2018OK\u2019 button  may be selected.","In , at , the data domain of the sub-types Bin , Const , Let  and Var  are now indicated as being configured to be produced by the selected generation techniques.","The data type Exp  is a complex data type comprising of multiple sub-types Bin , Const , Let  and Var . Thus, there are no values as such for the data type Exp other than the values of the sub-types Bin , Const , Let  and Var .","Besides configuring the data domains of the types whether they are data types or related sub-types the domains for the fields may be configured as well. For instance, the sub-types Const , Bin , Let  and Var  all have fields that whose data domains need to be configured. For instance, the field val at  can inherit the data domain of its type the Integer, the fields name at  and  may inherit from the domain of the Name type and the field op  from the domain of the Op type. The domain for the Op type is limited by the declaration at  to be limited to \u2018Add\u2019 and \u2018Sub\u2019. However, the data domains for the Name and Integer types have not been configured. Thus, the data domains for the atomic types Name and integer may be specified expressly by choosing the \u201cUse definition\u201d button  and then entering an expression in the text box . The expression can be any expression which enumerates a set of values whose elements are of the desired type. For Integers it has to be an enumeration of integers and for Name it has to be an enumeration of a strings. Using an expression to configure the data domain of atomic types Integer and Name may result in a domain configuration illustrated in . Here the data domain for the type Integer is configured expressly to be [, , ] at  and the domain for the type Name is configured expressly to be [\u201ca\u201d, \u201cb\u201d] at .","Once the domain configuration information is entered as shown using the exemplary user interfaces the information may be used to produce the data domains. An exemplary data domain for the data type Exp produced according to the data configuration information provided is shown in .",{"@attributes":{"id":"p-0119","num":"0118"},"figref":"FIG. 23"},"With reference to , an exemplary system for implementation includes a conventional computer  (such as personal computers, laptops, servers, mainframes, and other variety computers) includes a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit may be any of various commercially available processors, including Intel x86, Pentium and compatible microprocessors from Intel and others, including Cyrix, AMD and Nexgen; Alpha from Digital; MIPS from MIPS Technology, NEC, IDT, Siemens, and others; and the PowerPC from IBM and Motorola. Dual microprocessors and other multi-processor architectures also can be used as the processing unit .","The system bus may be any of several types of bus structure including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as PCI, VESA, AGP, Microchannel, ISA and EISA, to name a few. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM .","The computer  further includes a hard disk drive , a magnetic disk drive , e.g., to read from or write to a removable disk , and an optical disk drive , e.g., for reading a CD-ROM disk  or to read from or write to other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the computer . Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored in the drives and RAM , including an operating system , one or more application programs , other program modules , and program data ; in addition to the described technologies .","A user may enter commands and information into the computer  through a keyboard  and pointing device, such as a mouse . These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, computers typically include other peripheral output devices (not shown), such as speakers and printers.","The computer  operates in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a server, a router, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although only a memory storage device  has been illustrated. The logical connections depicted include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications (e.g., via the LAN  and a gateway or proxy server ) over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Having described and illustrated the principles of our invention with reference to the illustrated embodiments, it will be recognized that the illustrated embodiments can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, modules, processes, or methods described herein are not related or limited to any particular type of computer apparatus. Various types of general purpose or specialized computer apparatus may be used with or perform operations in accordance with the teachings described herein. Actions described herein can be achieved by computer-readable media comprising computer-executable instructions for performing such actions. Elements of the technology described as software may be implemented in hardware and vice versa. In view of the many possible embodiments to which the principles of our invention may be applied, it should be recognized that the details are illustrative only and should not be taken as limiting the scope of the technology. Rather, we claim as our invention all such technology as may come within the scope and spirit of the following claims and equivalents thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 23"}]},"DETDESC":[{},{}]}
