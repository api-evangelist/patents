---
title: Method and system for monitoring performance on a mobile device
abstract: A method and system are provided for implementing performance monitoring of an application on a mobile device. An instrumentation tool is provided allowing a user to view the entities in an application file for a mobile device and selecting those entities for which performance monitoring is to be implemented. The instrumentation tool adds performance monitoring methods to the application file and generates a new instrumented application file that is transferred to the mobile device. When the instrumented application file is executed on the mobile device, the performance monitoring methods instrumented into the file execute generating data in a performance log file that is stored on the mobile device. This performance log file may be transferred to a remote device for further analysis in addition to viewing the performance log file on the mobile device. The user selected entities for performance monitoring in the application file may be saved to a configuration file that can later be loaded and modified by the user to facilitate further performance monitoring of an application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07788644&OS=07788644&RS=07788644
owner: SAP AG
number: 07788644
owner_city: Walldorf
owner_country: DE
publication_date: 20050324
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTICE","FIELD OF THE INVENTION","BACKGROUND","DETAILED DESCRIPTION"],"p":["A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or patent disclosure as it appears in the Patent and Trademark Office, patent file or records, but otherwise reserves all copyright rights whatsoever.","The present invention relates to a method and system for monitoring performance in an application where a user can select what entities in an application file are monitored and the monitoring commands are incorporated into a new version of the application file according to one embodiment of the present invention.","Many performance measurement tools exist in the commercial market each having its own specific capabilities. The most common of these systems perform full code instrumentation (i.e., brute force instrumentation) where performance monitoring is instrumented for all methods of an application. This can be particularly advantageous because it may capture all the calls made by the application during runtime. For example, calls are dynamic and are not part of the static hierarchy of an application program. During application runtime a call may or may not be made. Using the following pseudo-code as an example illustrates why a method call in an application may or may not occur during runtime.",{"@attributes":{"id":"p-0005","num":"0004"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if x . . . {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"method_left"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"method_right"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the above pseudo-code, either method_left or method_right is executed depending on the value of variable x. Full code instrumentation provides performance monitoring of all the calls including those to both method_left and method_right and may include monitoring of variable values such as variable x. For this and other reasons, full code instrumentation for performance monitoring is common in conventional systems such as IBM's Rational PurifyPlus (formerly Visual Quantify) and Compuware Corp.'s DevPartner Studio (formerly NuMega).","Applications for mobile devices (mobile applications) present a particular challenge to performance monitoring in that the greater the instrumentation of the application code to be monitored the greater the overhead placed on the application and the limited resources of the mobile device. The limited processor capability and memory\/storage for mobile devices such as, for example, personal digital assistants (PDAs) and mobile phones, means that greater instrumentation may result in greater execution times for the application as well as increased memory\/storage usage on the mobile device. This may be sufficient to cause the application to fail to execute on the mobile device or the mobile device to crash rather than just a degradation in performance. In addition, the limited memory\/storage of most mobile devices prevents extensive logging of the performance monitoring data. The greater the amount of application code instrumented, the greater the amount of memory or storage needed by a performance log file on the mobile device to store the performance monitoring data. Because mobile devices are not always connected to a network, reliance on a server or other remote device to store the logging data may not be adequate to capture the necessary performance monitoring data. In addition, the greater the degree of instrumentation of the application code, the greater the extent to which the performance measurements are skewed by the resource requirements of the performance monitoring. For example, the performance monitoring instrumentation code may be measuring its own resource consumption and impact on the application program.","The present invention presents an innovative method for addressing the challenges of performance monitoring in resource limited environments such as for an application running on a mobile device.","A method and system are provided for implementing performance monitoring of an application on a mobile device. According to one embodiment of the present invention an instrumentation tool is provided allowing a user to view the entities in an application file for a mobile device and selecting those entities for which performance monitoring is to be implemented. The instrumentation tool adds performance monitoring methods to the application file and generates a new instrumented application file that is transferred to the mobile device. When the instrumented application file is executed on the mobile device, the performance monitoring methods instrumented into the file execute generating data in a performance log file that is stored on the mobile device. This performance log file may be transferred to a remote device for further analysis in addition to viewing the performance log file on the mobile device according to one embodiment of the present invention. The user selected entities for performance monitoring in the application file may be saved to a configuration file that can later be loaded and modified by the user to facilitate further performance monitoring of an application.","Performance monitoring refers to any profiling operation that measures the runtime behavior of an application on a mobile device. For example, memory consumption is a runtime behavior of an application that may be profiled or monitored. Any measurable runtime behavior to include, for example, method or function calls made by the entity may be profiled or monitored according to the present invention. Performance monitoring is implemented on an entity basis as discussed below providing particular details on how selected entities in the application are performing. The terms performance monitoring and profiling are used interchangeable throughout this specification. Though the example embodiment discussed above relates to a mobile device, the present invention may be applied to any processor based device in other embodiments of the present invention.","According to one embodiment of the present invention, the instrumentation\u2014the addition of performance monitoring methods or functions in an application file\u2014is not a brute force monitoring of the application as conventionally known where the performance of the entire application is monitored. Instead, the performance monitoring is tailored to user selected entities in the application allowing for focused monitoring and\/or reduced resource requirements facilitating the implementation of performance monitoring on mobile devices. Entities may be any element of an application and may include an entire application file such as an archive file, a package, a module, a method, a class, a function, a block of code, and\/or a line of code. The instrumentation tool determines the entities available and presents those entities to the user according to one embodiment of the present invention. The instrumentation tool may be constructed in a way to use particular entities suited to the platform or programming environment for which it is written. For example, an instrumentation tool for Java\u2122 applications may allow the instrumentation of performance monitoring for entities such as, for example, Java\u2122 ARchive (JAR) files, classes, and methods.","The instrumentation of an application file may be performed for a source code file, an intermediate file (e.g., a Java\u2122 bytecode file), or a binary file. For example, if a source code file is being used, a source code parser may be used by the instrumentation tool to determine the entities to be presented to the user to select for performance monitoring. Some programming languages such as Java\u2122 have an intermediate step between source code and executable code. In Java\u2122, source code is compiled into intermediate bytecode that contains abstract machine-independent instructions that are later interpreted by a Java\u2122 virtual machine application (in the Java\u2122 platform) into machine-specific executable code. Even binary code contains symbolic information that can be used to determine parts of the code such as entities. For example, a compiler debugger may use this type of symbolic information. In the example embodiment of the present invention illustrated below, instrumentation occurs at the intermediate Java\u2122 bytecode level though in other embodiments instrumentation may occur at the source code or binary code levels.","The result of the instrumentation of an application file is the collecting of performance monitoring data on the mobile device. During the performance monitoring or profiling on the mobile device, this data is collected and stored in a file. This file is generally stored on the mobile device because the mobile device will at times not be connected to any other device. However, the file may be transferred to a remote device during periods of mobile device connectivity according to this embodiment. For example, when a mobile device is connected to another device over a wireless connection such as an IEEE 802.11g wireless network, Bluetooth or other wireless connection, the file may be transferred to the remote device (e.g., a personal computer or workstation) releasing the storage space used on the mobile device. It is undesirable to transfer the data to any device, therefore, in one embodiment the mobile device or the instrumented file transferred to the mobile device may need to be affiliated or otherwise registered with the remote device to which the performance monitoring data will be transferred. This affiliation may occur automatically during the instrumentation process by incorporating affiliation information during the instrumentation of the performance monitoring methods or may occur during the transfer of the instrumented file to the mobile device. Alternatively, the affiliation may require user specification in a manual or semi-automated process in other various embodiments of the present invention. The transfer of the performance monitoring data to a remote device may also allow for greater processing analysis of the data than may otherwise be possible on the mobile device.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["101","102","103","104","102","112","103","113","104","114"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2","b":["200","201","202","203","201","204","205","206","207","208","209","201","210","211"]},"As previously stated the user interacts with the instrumentation tool through a graphical user interface . In a Java\u2122 environment, standard graphical user interface components are found in Java Foundation Classes and in particular the Swing set  of components in one such class library. Java\u2122 Swing includes features providing user interface components such as frames, trees, and tables in addition to buttons, list boxes, combo boxes, and checkboxes. A window or frame is created and used as the main interface for accessing the instrumentation tool according to this embodiment. The user starts the instrumentation tool in a conventional manner such as, for example, clicking on an associated startup.bat file.  is a screen shot of the instrumentation tool according to one embodiment of the present invention. The screen shot shown in  is similar to the initially displayed frame except that the left-side panel  displaying the hierarchical tree structure of the application file  (e.g., JAR file), the top right-side panel  displaying the path  of the application file (e.g., JAR file), and the bottom right-side panel  displaying a list (a list box) of the names of the methods  selected by the user for instrumentation to implement performance monitoring are all initially empty. The left-side panel  does not contain any packages, classes, methods, or entities because the user has not yet chosen an application file for instrumentation. For this same reason, the upper right-side panel  is also empty. The lower right-side panel  is similarly empty because methods are not available to be selected. Some of the drop-down menu  items may also be disabled because they can not be implemented at the moment. For example, if no file is open then a Save menu item may be disabled in the File menu . Disabled menu items may be displayed in a shadowed or faded format in one embodiment though any method to differentiate disabled menu items including temporarily removing them from the menus may be used in various embodiments of the present invention. Alternatively, the menu items may not be disabled and an error or other message may be provided if these menu items are executed at an inappropriate time. Once the user initiates the instrumentation tool, the user may open a file to be profiled (instrumented) using any of the available means to do so. For example, a file may be opened by selecting the Open option in the File drop-down menu  or by selecting an appropriate shortcut key combination such as CTRL+O where available.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 4","FIG. 4"],"b":["400","401","402","403"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 5","FIG. 5","FIG. 5"],"b":["501","502","504","510","516","520","526","530","535"]},"The instrumentation process  is illustrated using Java\u2122 in the following example according to one embodiment of the present invention. Java\u2122 programs are those written in the Java\u2122 programming language using class files that are compiled into bytecode for the Java\u2122 virtual machine (JVM) of the Java\u2122 platform. Bytecode is machine independent code generated by the Java\u2122 compiler and executed by the Java\u2122 interpreter. The Java\u2122 interpreter decodes and executes bytecode for the Java\u2122 virtual machine\u2014an execution engine that executes the bytecode commands in the Java\u2122 class files on a microprocessor.  is a diagram illustrating the Java\u2122 source code to executable code model as interpreted for one embodiment of the present invention. The program illustrated  is a simple program that displays the message \u201cHello World\u201d. The Java\u2122 programming language  source code class file  is compiled  by the Java\u2122 compiler into a class file containing Java\u2122 bytecode  that is interpreted  for execution using other class files as necessary by the Java\u2122 interpreter of the Java\u2122 virtual machine . The instrumentation process adds instructions to the existing programs by engineering the bytecode using, for example, Apache Software Foundation's Byte Code Engineering Library (BCEL) according to this embodiment of the present invention. BCEL provides a framework to manipulate Java\u2122 class files with the framework used to insert the performance monitoring methods necessary for the instrumentation of the application file. This embodiment is only one example of how the instrumentation of the programming code can be implemented and other methods may be used in other embodiments of the present invention.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 7","FIG. 7","FIG. 8","FIG. 7"],"b":["700","700","701","702","703","704","705","707","706","706","708","709"]},"At least one performance monitoring (profiling) method needs to be added to the application file to implement the instrumentation of the performance measurements according to this embodiment of the present invention. This embodiment uses the BCEL provided Java\u2122 API to create a method object for the at least one performance monitoring method. In particular MethodGen of BCEL may be used in this process. A new Java\u2122 class is created and defined according to the current class but also modified with the at least one profiling (performance monitoring) method. The result is a Java\u2122 class incorporating the instrumentation methods that allow for performance monitoring.  is a diagram illustrating the instrumentation of Java\u2122 source code for a class using the instrumentation tool according to one embodiment of the present invention. The original Java\u2122 class source code  is shown before being acted on by the instrumentation tool . The resulting source code  contains the additional profiling method calls ,  that provide for the performance monitoring according to this embodiment of the present invention.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 10","b":["1001","1000","1002","1003","1004","1005","1005","1006","1005","1004","1006"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 11","b":["1100","1101","1102","1103","1100"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 12","b":["1101","1101","1201","1202","1203","1204","1205","1201","1201","1202","1201"]},"The MainGui class  is responsible for displaying the user interface to include displaying the tree structure of the entities from one or more application files selected by the user. For example, the MainGui class  may display the tree structure of a Java\u2122 Archive (JAR) file selected by the user. According to the embodiment shown in , a CheckRenderer class  is called by the MainGui class  to assist in the display of the tree structure with the CheckRender class  in turn triggering the TreeLabel class . The CheckRenderer  and TreeLabel  classes help display the entities in a tree structure with a check box at each node to allow selection of the associated entity at that node of the tree. The CheckNode class  is the class for each displayed node of the tree. If a node in the tree is selected\/deselected by a user, the CheckNode class  selects\/deselects all the subordinate nodes for that node as well. For example, if a class is selected all the methods of that class will also be selected. A selected class may be shown by a check in the check box according to this embodiment of the present invention. Selecting an already selected node (a node with a check in the check box) deselects that node (clears the check from the check box) as well as all subordinate nodes. This facilitates the selection process by allowing group selection\/deselection instead of requiring individual selection\/deselection of each entity.","The NodeSelectionListener  handles node selection events and may populate a list box  in the user interface with these selections. Events include the interaction between the user and the graphical user interface and are handled using graphical user interface (GUI) components. For example in Java\u2122, components from the Abstract Window Toolkit (AWT)\u2014a collection of GUI components using native platform versions of the components\u2014or the Swing Set\u2014a code name for a collection of GUI components that run uniformly on any native platform that supports the Java\u2122 virtual machine\u2014may be used to communicate these interactions with a Java\u2122 program. is a diagram illustrating a simplified abstract model of event handling in Java\u2122. The event source  is the object generating the event in question. For example for a click event on a button in the user interface, the event source is the button clicked on. The event object  contains the information related to the event. For example clicking on a button causes an object to be created containing the information associated with the event such as event type, etc. The event listener  is an object registered with the event source  and having a method for event handling. The event object  is passed to the event listener  according to the abstract model shown in . is a diagram illustrating an example of event processing in the instrumentation tool according to one embodiment of the present invention. According to this example, the JTree object \u2014the tree structure of the application file in the instrumentation tool\u2014is the event source . The NodeSelectionListener  is the class for the event listener  registered with the JTree object . When the user clicks on a node in the tree structure (the JTree object ), a click or select event is initiated with the event information contained in an event object . The event object  is passed to the NodeSelectionListener  which generally calls at least one method to handle the event.","The JarParser class  in  verifies that a file selected by the user is a valid Java\u2122 archive (JAR) file and if so creates a hierarchical tree structure of its contents. The user interface layer  communicates with command collection layer  and the processing layer  using the interfaces - which are described later in this specification.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 14","b":["1102","1102","1210","1401","1211","1402","1403","1404","1210","1101","1102","1101","1102","1210","1401","1211","1211","1101","1102","1103","1402","1211","1403","1404"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 15","b":["1103","1103","1208","1501","1209","1502","1211","1403","1504","1505","1503","1208","1103","1101","316","1501","1209","1103","1101","1502","1211","1403","1502","1504","1504","1504","1505","1505","1505","1503"]},"Once the instrumented application file is generated, it may be deployed (transferred) to the mobile device or it may first be further processed before being deployed. In the example embodiment above, the instrumented JAR file is deployed to the mobile device where it can begin generating performance measurements. In another embodiment of the present invention, a new JAR file (application file) is not created by the instrumentation tool process and only a Config (configuration or instrumentation) file is created containing the measuring points and methods for instrumentation. According to this embodiment, both the original JAR file and the Config file are deployed to the mobile device. In this embodiment the Java\u2122 class loader may need to be modified in order to perform the bytecode instrumentation at runtime. The Java\u2122 class loader loads both the JAR file and the Config file classes while performing the instrumentation on the fly. According to this embodiment, no code enhancement of the application file is made and instrumentation occurs only at runtime without changing the underlying application file (e.g., JAR file). This is particularly beneficial in a case where an application file is enhanced by either an additional certificate or authentication in order to provide application security. Under these circumstances, performing the instrumentation of the application file entities at runtime may be easier than performing code enhancement (instrumentation) before the certificate or authentication is generated for the application file (which is generally prior to deploying the application file to the mobile device) which would otherwise be necessary.","Otherwise restated, in one embodiment of the present invention a code enhancement of the application file (e.g., the JAR file) may be performed and the enhanced (i.e., instrumented) application file may be loaded into memory during execution of the application and executed on the mobile device (or other resource limited device). In an alternative embodiment, the code enhancement (instrumentation) information is stored in a separate instrumentation file and this instrumentation file and the original unaltered application file are deployed to the mobile device or other resource limited device. Both files are loaded into memory during the execution of the application and the instrumentation of the application occurs at runtime. This alternative embodiment is particularly advantageous where the deployed application file (e.g., the JAR file) is controlled to prevent changes through some certification mechanism. The certification of the file may fail if the application file is modified after certification occurs. Therefore, the certified application file must be deployed unchanged to the mobile device, loaded into memory and the appropriate certification checks performed prior to code enhancement or instrumentation (the details of which are provided in an instrumentation file) of the entities in the application file.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 16","b":["1600","1601","1602","1603","1604","1605","1606","1607","1608","1609","1610","1611","1612","1613","1614","1615","1606","1607","1608","1609"]}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 13","i":"a "},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13","i":"b "},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
