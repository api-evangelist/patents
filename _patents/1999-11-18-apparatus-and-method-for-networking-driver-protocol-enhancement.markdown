---
title: Apparatus and method for networking driver protocol enhancement
abstract: Application Programming Interface, methods and apparatus are disclosed for enhancing data network communication. In a network including a first and a second network interface, each interface has an associated MAC address, and each network interface has a driver storing the MAC address for its associated interface. Under certain circumstances, such as in a fail-over condition, or to improve throughput, the second driver is conditionally directed to replace its stored MAC address with the MAC address of the first network interface. Thus, the second network interface can process network traffic as if it were the first network interface. Disclosed are several features and advantages resulting from such MAC reassignment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06874147&OS=06874147&RS=06874147
owner: Intel Corporation
number: 06874147
owner_city: Santa Clara
owner_country: US
publication_date: 19991118
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The invention generally relates to networking, and more particularly to runtime manipulation of networking drivers.","Since the advent of computers, various techniques have been used to allow computers to communicate. The common term for such communication is \u201cnetworking\u201d and many different models have been developed to describe the communication process. A well-known approach to representing networking communication is through use of the Open Systems Interconnection (OSI) Reference Model, which is a seven-layer model put forth by the International Standards Organization (ISO) in 1983.","The seven layers are the physical, data link, network, transport, session, presentation, and application layers; each layer represents a successive level of complexity and data-abstraction for an underlying raw data stream. That is, the physical layer (part of a network interface card (NIC)) is generally responsible for transmitting and receiving raw data (bits) from a network medium or interface. The physical layer does not maintain or require any particular structure to the data. The data link layer, however, abstracts the raw data stream into a series of frames, or chunks of raw data, allowing this layer to be generally responsible for ensuring that data is correct (e.g., all data received is correct). The network layer concerns properly routing data to and from appropriate sources and destinations. Each remaining layer is similarly responsible for providing further abstraction and integrity to a data stream. (For further information regarding the OSI model, see Computer Networks by Andrew Tanenbaum, Prentice Hall (2d. Ed. 1989).)","In order to distinguish one NIC from another, the NICs each have a unique identifier, commonly referred to as a Media Access Control (MAC) identifier. Communication protocols are bound to one or more NICs, allowing data utilizing the protocol to be routed over bound NICs. Commonly used protocols include connection-oriented protocols such as Transmission Control Protocol (TCP) and Sequenced Packet Exchange (SPX), as well as connectionless protocols such as Internet Protocol (IP), Internetwork Packet Exchange (IPX), and User Datagram Protocol (UDP).","Binding a NIC with a protocol is normally an operating-system boot-time event. For networking, after a machine performs its power-on self test (POST), and the operating system begins to load, control is passed to networking drivers which bind an instance of themselves to each NIC, and to one or more protocol stacks. The drivers also request its associated NIC to provide the NIC's MAC address. This address is stored in a memory reserved for the driver, and is also stored in the NIC's receive address filtering hardware. Once all NIC drivers have been initialized, data can be routed to and from each NIC.","Unfortunately, as will become clear in the following detailed description, once the Protocol stacks are bound to NICs using their drivers, there is no way to handle a NIC failure. If a particular NIC is used in a communication session between a source and a destination computer, and the NIC fails, current networking software does not allow silent replacement of the failed NIC with an operative NIC. Instead, a communication error occurs, preventing the application programs from being able to continue communication.","Some attempts have been made to overcome NIC failure issue. One solution is to overcome NIC failure by using standard functions to identify routing changes. If a NIC changes, a broadcast of a routing change is made to all clients, indicating that they need to switch to a new destination address (e.g., the replacement NIC). This solution, however, lacks transparency. Another alternate, as discussed in U.S. Pat. No. 5,661,719, is to provide NICs with programmable MAC addresses. This allows a new NIC to emulate the failed NIC, but it is a solution lacking flexibility.","One aspect of the invention is an application programming interface (API) for enhancing data network communication. The API includes an identify address function including programming instructions for identifying a stored node address stored by a base driver for a network interface associated with the base driver. The API also includes an update node address function including programming instructions for directing the base driver to update the stored node address with a new node address in a configuration storage of the base driver, and in a receive address filtering table for the network interface.",{"@attributes":{"id":"P-00018","num":"00018"},"figref":"FIG. 1","b":["100","102","100","102","104","108","104","116"]},"In the illustrated configuration, the intermediary  appears to the stack  as a multiplexer to the different base drivers. The stack and base drivers are bound to the intermediary, resulting in network data received by the protocol stack being routed to the intermediary. The intermediary then becomes responsible for forwarding the network data on to an appropriate base driver - which is then responsible for transfer of the data to the NIC hardware - for delivery over a network connection .","On data reception over the network , all NICs see the data, but only the NIC hardware with the appropriate matching MAC filter responds to the incoming data. If a NIC accepts network data, it is forwarded to its driver, which in turn forwards it to the intermediary layer which multiplexes the data to an appropriate protocol stack.","The intermediary layer is capable of accepting many upper-layer protocol stacks, in addition to multiple drivers below it. Although not provided by present networking environments, this ability provides an opportunity for allowing transparent fail-over, load-balancing, and support for new network protocols and features, without changing existing base drivers - for current network interfaces -.","In order to present a concrete example of how the intermediary layer  can be used to transparently extend the capabilities of existing network configurations, it will be assumed that a standard Novell Open Data-link Interface (ODI) based network is being extended. The ODI environment is a well known network configuration which does not provide for transparent logical replacement of a failed or failing NIC, nor support for features not natively supported by NIC networking software (e.g., the NIC drivers -). It will be clear to one skilled in the art how to implement the invention in other network environments, e.g., Windows 9\u00d7\/NT, Macintosh, Unix\/Linux, etc., as each environment uses an intermediary layer.",{"@attributes":{"id":"P-00023","num":"00023"},"figref":"FIG. 2","b":["200","202"]},"Shown are the seven OSI layers -, and the corresponding ODI layers - that are different from the OSI model. The protocol stack (PS)  represents each protocol implementation (e.g., SPX, AppleTalk, etc.) available within a computer.","The Multiple Link Interface Drivers (MLIDs)  are device drivers which send and receive packets to and from the physical layer (or logical topology) , . MLIDs have three portions, a Media Support Module (MSM), a Topology Specific Module (TSM), and a Hardware Specific Module (HSM). The HSM portion of MLIDs append or strip frame headers from data received over the physical layer, but they do not interpret packet data. Instead, received packets are passed on to the TSM and MSM for packet type classifying and then forwarded to Link Support Layer (LSL)  to be multiplexed to the appropriate protocol stack based on the contents of Event Control Blocks (ECBs).","ECBs are NetWare buffers that are used to send, receive and manage packet data. Generally an ECB contains information set by a protocol containing a block (e.g., 1500 bytes) of data. Such information includes the protocol originating the data, the NIC to which the data is to be sent, context information for the data, as well as other housekeeping information maintained by the protocol. The LSL effectively operates as a router, and coordinates communication between protocol stacks and MLIDs.","Traditionally, when data is transmitted, a protocol stack  receives data from an application program . The PS  determines whether to split the data into fragments, and also determines the size of the fragments. The PS adds a protocol header to the data, destination MAC address and logical board through which packet will be transmitted are placed in the ECB, and sends the data to the LSL . The LSL routes the data to an appropriate MLID . The MLID adds a MAC header to the data, and hands the data to the appropriate NIC (LAN adapter). Recall that the source MAC address added to the MAC header was read from the NIC during network initializabon; this value is retained by the MLID for later use. (It is too time consuming to query each NIC for its MAC address each time data needed is transmitted or received\u2014hence this determination is supposed to be only performed once.) NIC  adds a packet preamble and places the data on the wire (alternatively, the medium may be wireless).","Receipt of transmitted data operates conversely. On data receipt, the NIC strips the packet preamble from received data. Only packets which meet the NIC's stored MAC address passes the NIC's receive filter. The MLID strips the MAC header from the data, places various fields in an ECB and forwards the data pointed by the ECB to the LSL. The LSL routes the packet to the appropriate PS, and the PS removes the protocol header and transfers the data to the application.","Unfortunately, as noted above, in a traditional communication model, transmission and receipt breaks down if the NIC fails. Failure can happen by hardware failure, disconnected cable, or other communication breakdown. That is, since the data stream is hard-wired to travel to a particular NIC, a failed NIC will cause communication to fail.",{"@attributes":{"id":"P-00030","num":"00030"},"figref":["FIG. 3","FIG. 1","FIG. 2","FIG. 1"],"b":["300","100","302","304","306"]},"In a traditional communication configuration, the LSL routes communication data to MLIDs - according to MLID identifiers (usually a logical board number) embedded within such communication which correspond to stored within the PS, the LSL and the MLID for corresponding. Instead, here, the protocol stack  is bound to the virtual MLID . Other protocols can be similarly bound. The virtual MLID appears to the LSL as a real adapter card's MLID driver. Consequently, network data  originating from the protocol stack  is routed by the LSL  to the virtual MLID  as normal. As discussed above with respect to , after this data is received at the virtual MLID, it may be repackaged as if originating from a different protocol stack .","This configuration allows the data  to be repackaged in a protocol format entirely different from the original protocol's format. Recall that the underlying philosophy to the OSI \/ODI  models is that each higher layer provides extra functionality and\/or features to a communication stream, such as data integrity checks, reliability checks, out-of-order packet re-ordering, etc. Thus, the virtual protocol may retransmit the data  in a specialized encryption format (e.g., IPsec), or in a virtual LAN format, or other format. (See also )","Further, the repackaged data can be addressed so that it is directed towards any of the MLIDs -, allowing dynamic alteration of which MLID will be used for communication. The virtual MLID maintains a correspondence between originating protocol stack  for a particular data stream , and the MLID  to which the data stream was delivered. When a transmit response is received by MLID , the LSL  routes the response back to the \u201coriginating PS\u201d, i.e., virtual PS . Internally, this response is stripped off any additional protocol features added to the outgoing data stream, and is presented back to the LSL  as if just received by the virtual MLID . The LSL then routes this response back to the real originating protocol stack , with the protocol stack  and LSL  being unaware of the data indirection.","One method for effecting the data repackaging is to copy and modify ECBs. In Novell networking, each transmitted data stream includes an Event Control Block (ECB) along with pointers to an ECB data payload (pointers within the ECB point to data buffers containing the payload). While redirecting the data , the ECB for this data is copied into a second ECB (per networking conventions, the first ECB should not be modified). The second ECB's payload pointers (e.g., FragmentOffset, FragmentSize) remain directed at the first ECB's payload data buffers. To track the copy, the second ECB is adjusted to back-reference the original ECB. This can be accomplished through an entry in the copied ECB's ProtocolWorkspace portion. This second ECB is also adjusted to direct the data towards a MLID of interest. Similar header copying and adjustment may be used for other networking environments (e.g., Linux\/Unix, Macintosh, Microsoft Windows 9\u00d7\/NT, etc.). By creating copies of the ECBs, one can control the format and destination of data originally received from the protocol stack .","Shown is a control line  (e.g., data pathway) in communication with each MLID -. The control line  can be implemented using the Driver Management Input\/Output Control (IOCTL) method defined in ODI Lan Driver specification, where a formatted management ECB is sent to a base driver. A command\/query communication data structure can be defined using a standard NetWare ECB buffer used in the Novell driver management API. This command\/query ECB will be filled with appropriate command and related parameters, and then be handed to an MLID base driver by calling the Ctl14_DriverManagement API. The base driver will act according to the command field in this buffer and fill a response result and parameters in the same buffer. In particular, an MLID can be directed to replace its stored MAC address with a different value, thus replacing the value obtained when initializing the networking hardware - and software (usually occurring at base driver load time). The MLID stores the new MAC address in the NIC's address filtering hardware as well as in the MLID's configuration table. Another care is taken to update the TSM's source MAC address field it adds to every transmitted packet, with the new updated MAC address.","Once a MLID can be instructed to revise its stored MAC address, multiple NICs can be installed in a machine, but where only one NIC  is actively communicating through its MLID , and the others \/, \/ are left \u201cdisabled\u201d for fail-over purposes. In one embodiment, an Adapter Fault Tolerance (AFT) mode is provided, where a fail over NIC waits for failure of an active NIC. (See also ) If the active NIC  suffers a hardware failure or its link is off, a fail over NIC  can be brought on line by having its associated MLID  revise its stored MAC address  with the MAC address  from the failed NIC.","Similarly, in one embodiment, load balancing may be effected by directing plural MLIDs - to store an identical MAC address. The virtual PS  can then monitor data traffic flow to identify a least-busy NIC and direct the LSL  to route data  to that NIC. (The LSL does not route data to MLIDs based on the stored MAC address.) In this embodiment, an Adaptive Load Balancing (ALB) mode, and Link Aggregation mode is provided, where all NICs are active, until one fails, causing the failed NIC to be removed from load balancing until it is repaired.","Each NIC -, unaware of the MAC address stored in its associated MLID driver, receives the data stamped in the source address field by its MLID with the stored MAC address and submits it to the wire  for delivery.","Upon receipt of end of transmit response, the NIC presents the response to its MLID. The MLID passes the response to the LSL which routes it back to the virtual PS . Recall that the virtual PS  and MLID  have maintained a concordance between data received from an originating protocol stack  and the MLID to which the data was ultimately forwarded. Based on this, the data can be returned to the originating protocol stack .",{"@attributes":{"id":"P-00040","num":"00040"},"figref":"FIG. 4","b":["400","402","404","408"]},"The identified  secondary NIC is set  to utilize the MAC for the failed primary NIC. When asynchronously polling NICs, replacement of the failed NIC occurs before a sender of data receives a time out or other communication error from attempting communication through the failed NIC. In an alternate embodiment, NIC testing is performed along with data transmission, such that the base driver is polled  and evaluated  before data transferred  to a NIC.",{"@attributes":{"id":"P-00042","num":"00042"},"figref":"FIG. 5","b":["400","410","4","404","412","414","406"]},"Note that in an alternate embodiment, testing  a NIC, identifying  its health, and selecting a fail over NIC ,  can be performed asynchronously (e.g., in parallel) to regular network traffic processing. In this alternate embodiment, data is received  and processing continues directly with checking  whether a new protocol of feature is being used. A database, run-time variable, or other memory is used to store a MAC (or other identifier) address for a current primary adapter (e.g., the NIC presently in-use) to be used for network transfers. In parallel to processing received data, a separate process performs the testing ,  and fail-over selection ,  of a replacement NIC.",{"@attributes":{"id":"P-00044","num":"00044"},"figref":["FIG. 6","FIG. 3"],"b":"322"},"In an API configuration, the control interface  is based on a master slave protocol, where the virtual PS  and MLID  are the master, and the base drivers - are the slave. The slave drivers are polled at a predetermined polling period, e.g., 100 to 400 milliseconds or other period depending on data response requirements. As an alternative to polling, one can generate events from a base driver through the Novell Event Bus (NEB), with the virtual PS and MLID registered to receive events. However, for simplicity in presentation, it has been assumed that polling is utilized, and that the MLID base drivers respond to control messages immediately.","Starting on , a first API command is IdentifyYourself 500. This command requests a base driver (a MLID in a Novell networking context) to identify itself. This should be the first command sent to a base driver to allow verification that the base driver knows the virtual PS communication protocol. Passed as calling parameters to each API call are a VendorID , and CommRevision . The VendorID identifies the requestor to the base driver receiving the command, and allows the base driver to perform validation of the request. The CommRevision identifies the revision number of the API used to query the base driver, and allows the driver to ensure it responds appropriately to the API (e.g., different API versions may have different data expectations).","In response to the identity check, the base driver should return the following fields: CommRevision , which indicates the driver's communication interface revision number; VendorID , which indicates a vendor ID value of base driver; ResponseCode , which embodies a response, if any, to commands sent to the base driver; and CopyrightString , a protected statement returned by a driver to indicate that the driver is authorized to be communicating with the virtual PS. For example, to ensure that only licensed vendors are using the virtual PS to repackage network communication in a new (e.g., previously unsupported) format, the driver can be required to return a copyrighted string before the virtual PS will communicate with that driver. Since the string is protected under copyright (and other applicable regulations), to be compatible with the virtual PS environment, one would have to seek proper authorization, or illicitly use the string. In this latter context, such illicit use may subject one to significant liability.","Another API command is ReportNodeAddress . This command is used to identify a base drivers stored MAC address. As discussed above, this value can be determined by returned value from the driver. Or, alternatively, the address can be determined by inspecting the configuration table of the driver.","Another API command is UpdateNodeAddress . This command is used to tell a driver to override its MAC address with a new MAC address  passed as a calling parameter. As discussed above, this command can be used at fail over time for fault tolerance, or when load balancing (e.g., link aggregation mode for aggregated bandwidth) where all underlying NICs use the same MAC address. As a result of this command, a base driver should update its MAC address in its configuration table, MSM (under Novell) shared data space, and in its hardware receive filtering table. If the driver (or its NIC) is not ECB aware, then the new address should be written on every packet the base driver delivers to the NIC (e.g., in the DriverSend routine). Writing the new address overcomes a limitation in the ODI specification and the way MSM and EtherTSM are implemented.","Note that fail over can be used to allow uninterrupted network communication during hot plug removal of a NIC, such as in a PCI environment. When a card is removed, the base driver will report (in response to the ReportStatus request) the removed card. If card was the primary adapter (e.g., in use), network communication will fail over to a secondary adapter with the secondary NIC getting the MAC address of the primary adapter. If it is desirable to maintain separate MAC addresses when the removed card is returned, the primary and secondary cards can be instructed to swap MAC addresses. The driver representing the card in hot plug event will be called to update its MAC address even though the NIC is not present. When the card is reinserted, the driver should use the swapped address. This function can also be used in fail over conditions during Adaptive Load Balancing (ALB) (ALB balances outgoing server traffic among multiple NICs, providing scalable bandwidth as well as automatic backup links through fault tolerance).","Another API command is ReportStatus . This command is used to ask a base driver to report its running status. In response, a base driver can report operating conditions such as link change , line speed , duplex , hardware failure condition , hot plug PCI event (card removal)  or other results as desired. As discussed above, status will be polled at a predetermined interval (e.g., 100-400 400 msec) according to required response times.","Continuing on to , another API command is ReportCapabilibes . This command is used to ask a base driver to report supported capabilities. Such capabilities can include support for ECB out of band information , e.g., the use of an ECB to pass advanced data features on a per packet basis to and from a base driver, virtual LAN , IP encryption , etc. Note that some results, such as indicating virtual LAN capability , necessarily imply other results, such as support for the out of band information .","Another API command is ReportVlanCapabilities . If virtual LAN support is present, this command can be used to ask a base driver to report what VLAN standards  it supports, whether VLAN mode can be enabled or disabled , and whether the base driver supports VLAN RX filtering  (this support, if performed in hardware, will offload from a system's PCI bus any VLAN traffic not destined for the system).","Another API command is VLanControl . This command is used to ask a base driver to change VLAN modes , if changing modes is supported (depends on the supported standards ), or to set the VLAN filtering mode (if supported).","Another API command is SetControl . This command is used to ask a base driver to revise basic functionality. This is an opened function and depends on functionality required of the base driver and\/or NIC. This command can be used, for example, to enable or disable ECB out of band mode . (At unbind time, original driver settings will be restored.)","Another API command is BD_Disconnect . This command notifies a base driver that this new advanced contol communication with the driver has been terminated. This provides opportunity for the driver to recover, if necessary, or make adjustments due to the termination of communication.","FIG.  and the following discussion are intended to provide a brief, general description of a suitable computing environment in which the claimed invention may be practiced. The invention may be described by reference to different high-level program modules and\/or low-level hardware contexts. Those skilled in the art will realize that program module references can be interchanged with low-level hardware instructions.","Program modules include procedures, functions, programs, components, data structures, and the like, that perform particular tasks or implement particular abstract data types. The modules may be incorporated into single and multi-processor computing systems, as well as hand-held devices and controllable consumer devices. It is understood that modules may be implemented on a single computing device, or processed over a distributed network environment, where modules can be located in both local and remote memory storage devices.","An exemplary system for implementing the invention includes a computing device  having system bus  for coupling together various components within the computing device. The system bus  may be any of several types of bus structure including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as PCI, AGP, VESA, Microchannel, ISA and EISA, to name a few. Note that only a single bus is illustrated, although plural buses typically achieve performance benefits. Typically, attached to the bus  are at least one processor , memory , storage device (e.g., fixed , removable , optical\/laser ), video interface , input\/output interface port , and network interface .","The processor  may be any of various commercially available processors, including Intel processors, or the DEC Alpha, PowerPC, programmable gate arrays, signal processors, or the like. Dual, quad processors, and other multi-processor architectures also can be used. The system memory includes random access memory (RAM) , and static or re-programmable read only memory (ROM) . A basic input\/output system (BIOS), stored in ROM, flash ROM, cached to RAM or the like, contains routines for information transfer between device  components or device initialization.","The fixed storage  generally refers to hard drive and other semi-permanently attached media, whereas removable storage  generally refers to a device-bay into which removable media such as a floppy diskette is removably inserted. The optical\/laser storage  include devices based on CD-ROM, DVD, or CD-RW technology, and are usually coupled to the system bus  through a device interface , , . The storage systems and associated computer-readable media provide storage of data and executable instructions for the computing device . Note that other storage options include magnetic cassettes, tapes, flash memory cards, memory sticks, digital video disks, and the like.","The exemplary computing device  can store and execute a number of program modules within the RAM , ROM , and storage devices , , . Typical program modules include an operating system , application programs  (e.g., a web browser or network application program), etc., and application data . Program module or other system output can be processed by the video system  (e.g., a 2D and\/or D graphics rendering device), which is coupled to the system bus  and an output device . Typical output devices include monitors, flat-panels displays, liquid-crystal displays, and recording devices such as video-cassette recorders.","A user of the computing device  is typically a person interacting with the computing device through manipulation of an input device . Common input devices include a keyboard, mouse, tablet, touch-sensitive surface, digital pen, joystick, microphone, game pad, satellite dish, etc. One can also provide input through manipulation of a virtual reality environment, or through processing the output from a data file or another computing device.","The computing device  is expected to operate in a networked environment using logical connections to one or more remote computing devices. One such remote computing device  may be a web server or other program module utilizing a network application protocol (e.g., HTTP, File Transfer Protocol (FTP), Gopher, Wide Area Information Server (WAIS)), a router, a peer device or other common network node, and typically includes many or all of the elements discussed for the computing device . To provide NIC fail over, the computing device  has plural network interfaces  (e.g., an Ethernet card) as described above, having updateable MAC address. These interfaces  are coupled to the system bus , allowing communication with the remote device . Both the local computing device  and the remote computing device  can be communicatively coupled to a network  such as a WAN, LAN, Gateway, Internet, or other public or private data-pathway. It will be appreciated that other communication links between the computing devices, such as through a modem  coupled to an interface port , may also be used.","In accordance with the practices of persons skilled in the art of computer hardware and software programming, the present invention is described with reference to acts and symbolic representations of operations that are sometimes referred to as being computer-executed. It will be appreciated that the acts and symbolically represented operations include the manipulation by the processor  of electrical signals representing data bits which causes a resulting transformation or reduction of the electrical signal representation, and the maintenance of data bits at memory locations in the memory  and storage systems , , , so as to reconfigure or otherwise alter the computer system's operation and\/or processing of signals. The memory locations where data bits are maintained are physical locations having particular electrical, magnetic, or optical properties corresponding to the data bits.","Having described and illustrated the principles of the invention with reference to illustrated embodiments, it will be recognized that the illustrated embodiments can be modified in arrangement and detail without departing from such principles. For example, while the foregoing description focused\u2014for expository convenience\u2014on the Novell networking\/ODI API environment, it will be recognized that the same techniques and analyses can be applied to different networking configurations, such as certain Macintosh, Microsoft (NTx Win9x and the like) and Unix environments. In addition, even though description or claim language may speak to only one or two network interfaces, it will be appreciated that the invention is applicable to devices simultaneously utilizing many network interfaces.","And, even though the foregoing discussion has focused on particular embodiments, it is understood that other configurations are contemplated. In particular, even though the expressions \u201cin one embodiment\u201d or \u201cin another embodiment\u201d are used herein, these phrases are meant to generally reference embodiment possibilities, and are not intended to limit the invention to those particular embodiment configurations. These terms may reference the same or different embodiments, and unless indicated otherwise, are combinable into aggregate embodiments.","Consequently, in view of the wide variety of possible networking environments, the detailed embodiments are intended to be illustrative only, and should not be taken as limiting the scope of the invention. Rather, what is claimed as the invention, is all such modifications as may come within the scope and spirit of the following claims and equivalents thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Features and advantages of the invention will become apparent to one skilled in the art to which the invention pertains from review of the following detailed description and claimed embodiments of the invention, in conjunction with the drawings in which:",{"@attributes":{"id":"P-00011","num":"00011"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00012","num":"00012"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00013","num":"00013"},"figref":["FIG. 3","FIG. 1","FIG. 2"]},{"@attributes":{"id":"P-00014","num":"00014"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00015","num":"00015"},"figref":"FIG. 5"},{"@attributes":{"id":"P-00016","num":"00016"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00017","num":"00017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
