---
title: System for creation and distribution of software applications usable on multiple mobile device platforms
abstract: The present invention provides a mobile application ecosystem comprising a mobile application development kit and store, both of which are implemented as web-based services such that creation, testing, and distribution of mobile applications, as well as discovery, investigation, and delivery of same, can all be performed using a standard web browser. The mobile application development kit offers common capabilities across all target mobile device brand and brand groups, allowing the same application construct to work unmodified on all, while building the application in a manner that is native to each, thereby avoiding any requirement to embed a separate common runtime or virtual machine on every mobile device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08719776&OS=08719776&RS=08719776
owner: Foneclay, Inc.
number: 08719776
owner_city: Rancho Santa Fe
owner_country: US
publication_date: 20091230
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention pertains in general to creation and distribution of mobile application software. The present invention pertains in particular to a system that enables both professionals and novices to create software applications which are executable without modification on multiple mobile device platforms, and to distribute such applications across a broad customer base in a significantly simpler and more widely applicable manner than is currently available.","There exists today a wide variety of small, typically handheld, electronic appliances known generally as mobile internet devices, including in particular the vast array of products commonly known as mobile phones. Nearly all such devices now provide a mechanism for obtaining and executing mobile applications, also known as mobile apps, which are software modules that impart new functionality to a mobile device, such as games and other entertainments, information management tools, business tools, and a multitude of others. Mobile applications are generally distributed via an online \u201cstore,\u201d which is typically implemented as a specialized combination of interne website and mobile application designed to present an environment for discovering, investigating, purchasing, and downloading mobile applications that did not come preloaded on the mobile device. In today's business environment and at the current level of technology maturity, each manufacturer or distributor of a particular mobile device brand provides a store dedicated to that brand. Popular examples include Apple's iPhone App Store, RIM's Blackberry App World, Nokia's Ovi, and Palm's webOS App Catalog.","Also associated with each brand of mobile device is a development kit, which is a set of tools used by software developers to create mobile applications and offer the created mobile applications for distribution via the corresponding online store. While many development kits use certain common technologies rooted in standards, such as the Java or C programming languages, XML-based data description formats, and the Eclipse-based tool framework, the variety of combinations is quite large and it is rare for mobile device brands to share enough of the tools in their respective development kits for applications written on one to work without modification on another. Of particular interest in this area are the groups of device brands that share a software layer known as an operating system, or OS. For example, multiple device manufacturers incorporate Microsoft's Windows Mobile or some form of Linux, thereby achieving significant commonality of development kit. However, in this architecture pattern each device brand adds device-specific components such as hardware drivers and presentation styles on top of the OS, such that all but the simplest applications built for one device brand remain unusable on another, even within the same OS group.","In addition to the device-specific and OS-specific development kits described in the foregoing, generic development kits have begun to emerge that attempt to offer an abstract device model, typically through an API that is implemented with identical semantics and identical syntax on multiple device brands or multiple operating systems. Such tools ease somewhat the application developer's burden, by allowing the same software source code to be used for an application that will be built and deployed on multiple device brands and potentially multiple operating systems. However, so far as they exist today these tools still force the developer to use the various device-specific development kits for the final steps of packaging and deploying the corresponding device-specific application versions. Further, the generic-model development kits that exist today, including for example Appcelerator and Antenna Mobility Platform, do not achieve the status of device or OS brands known to end users, and therefore cannot successfully offer a corresponding store, or distribution environment.","Thus, in general an application developer who wishes to make a particular mobile application available on multiple mobile device brands must develop and test that application in multiple development kits, and submit each finished product separately to the corresponding online store. When a new brand emerges with its own unique development kit and store, the application must be created, or at least built and tested, yet again if it is to be available for users of mobile devices under that brand.","The complexity of existing development kits, whether device-specific, OS-specific, or generic, creates a further constraint on the current art. Specifically, the text-based programming languages and computer-like software architectures that form the basis of today's mobile application infrastructure have created a situation in which the skills and knowledge required to create a mobile application tend to exist primarily among professional programmers and prodigies, whose abstract mathematical abilities and logical thought processes have been honed through education, inspired by innate talent, or both. This creates a challenging barrier for creative people whose talents lie in other areas or whose education has not advanced so far, who also have ideas for unique mobile applications that may be interesting or useful to themselves and others. The vast majority of mobile device users, who may for example be children or parents, teachers or students, nurses or patients, and workers, professionals, managers, or retirees in any number of fields, are not professional programmers or mathematical prodigies and have no means today of expressing their ideas and embodying their ideas in mobile applications, much less of sharing those applications with others who could use or enjoy them. In the domain of personal computers it has been known for decades that children, for example, can create interesting software using such tools as Logo and, more recently, Scratch and Alice. No such breakthrough has yet been achieved in the domain of mobile devices, although at this writing a version of Scratch for mobile devices is being developed (http:\/\/llk.media.mit.edu\/projects.php?id=1974).","In addition to the difficulty of mobile application development, there is the further complexity of verification testing. Programming specialists will generally execute a significant number of behavioral and performance tests to ensure that a mobile application does what it is meant to do in the presence of intended conditions and stimuli (positive behavior test cases), does something sensible in the presence of unintended conditions or stimuli (negative behavior test cases), and in any case performs with appropriate user responsiveness (performance test cases). A novice programmer or non-specialist, on the other hand, may be able to identify and execute a subset of the appropriate positive behavior test cases, but will generally not be able even to recognize the need for the remainder of the desired test cases.","The mobile application developer is not the only party on which a testing burden falls. The proprietor of each mobile application store, being a device manufacturer, distributor, or service provider, has an interest in ensuring that users of the corresponding devices receive a consistent experience and are not harmed by ill-designed or even malicious mobile applications. In general, to provide such a user experience drives each store to be backed by a staff of testing specialists who examine each submitted mobile application prior to making it available for widespread distribution. These specialists are no doubt equipped with various tools that facilitate and simplify the process of verifying whether a mobile application's behavior and performance conform to the store's norms. Tools which may be applied in this situation, well known to those skilled in the art, include malware scanners, device emulators, and automated test execution environments that work with test cases submitted by the developer along with the application. The intervention of specialists to apply these tools and determine whether a mobile application is suitable for distribution introduces delay and uncertainty between developer and customer, and features the potential for human error that could allow inappropriate applications through or block applications unnecessarily.","What is needed, then, is a system whereby mobile device users who are not programming specialists may create mobile applications and offer the created applications for distribution to others, without regard for any specific device's brand, model, OS, dedicated development kit, or dedicated application store. Such a system will preferably automate the testing of individual mobile applications for any and all device brands, models, and operating systems, both to verify the application's conformance to user experience rules and to assist the application's creator in achieving the intended behaviors. Such a system, further, will preferably enable communication and interaction between and among application creators, end users, and other interested persons, so as to facilitate creation, distribution, discovery, investigation, provision, customization, utilization, and improvement of interesting, entertaining, and useful mobile applications. Such a system will also preferably permit new applications to be created through attribute customization of existing applications, incorporation of various existing application components, and even incorporation of entire existing applications, with a minimum of effort and detailed technical knowledge by application creators.","It is thus the principal aim of the present invention to create a mobile application ecosystem that is simpler than existing options for all of its participants regardless of their role or business model. Accordingly, it is an advantage of the present invention that a mobile application development kit and store are provided as a web-based service such that creation, testing, and distribution of mobile applications, as well as discovery, investigation, and delivery of same, can all be performed using a standard web browser. It is a further advantage that the mobile application development kit according to the present invention offers common capabilities across all target mobile device brands, allowing the same application construct to work unmodified on all of target mobile devices while building the application in a manner that is native to each mobile device brand or brand group, thereby avoiding any requirement to embed a separate common runtime or virtual machine on mobile devices of every brand or brand group. It is a further advantage that the mobile application store according to the present invention is also not specific to any mobile device brand or brand group. It is a further advantage of the present invention that the web-based mobile application development kit and store are integrated with one another such that creation of new mobile applications can be accelerated by incorporation or customization of existing mobile applications or components thereof.","A further advantage of the present invention is the aspect of automatic verification, such that intervention of human specialists is not required to determine whether a particular mobile application is suitable for distribution according to such factors as rules of user experience conformity, performance expectations, and appropriate interactions with other applications; whereby both skilled and unskilled developers may benefit from the execution of thorough test suites covering all positive behavior, negative behavior, and performance aspects of a mobile application's intended purpose; and whereby the functionality and performance of a mobile application may be automatically verified on all capable devices of every brand or brand group.","An additional advantage of the present invention is the aspect of the web-based mobile application development kit, which incorporates a tool for creating and embodying logic, interfaces, and data, whereby it can be used intuitively by all people, including children and adults who are not skilled software developers, while, at the same time offering compatible advanced capabilities to those who are so skilled. Yet another advantage of the present invention is its ability to facilitate communication, interaction, community, and sharing among and between mobile application creators, users, and other interested parties.","The above and other advantages of the present invention are carried out in one form by a system of cooperating elements, each of which is described in detail below.","The high-level diagram of  depicts the primary elements of the present invention, including the main system, its major subsystems and primary internal elements, and the primary external elements with which it interacts. In the diagram, Mobile Application Factory System  embodies the functionality as outlined in the Summary section above and detailed in the subsystem descriptions that follow. The functions of Mobile Application Factory System  are allocated among four major subsystems, with interactions among the four major subsystems as shown. In addition, four primary internal elements are shown, which embody the reason for existence of Mobile Application Factory System  in the first place.","The first primary internal element is the set of one or more Mobile Device Applications  which are produced, managed, and distributed using Application Factory System . Each Application  is a package of logic and data created by a developer to perform one or more particular functions upon execution by a mobile device. By way of example, but without limitation, an Application  may display a sequence of images, take a photograph or capture a location and share it with others, or play a complex game involving one or more people. Note that while  depicts just four Applications , in a preferred embodiment the actual number is essentially unlimited.","In addition to Mobile Device Applications , developers may create a set of one or more Mobile Device Application Components . Each Application Component  is a package of logic and data encapsulating a set of related functionality that may be useful in numerous Applications . In general Application Components  do not stand alone, but may be combined with additional logic and perhaps other Application Components  in order to form an Application . Note that while  depicts just four Application Components , in a preferred embodiment the actual number is essentially unlimited.","Application Factory System  incorporates a single abstraction of a mobile device that all Applications  and Application Components  will execute on. This Generic Mobile Device Model  is used as a common platform for development, testing, simulation, and demonstration of any Application . Having a common target ensures consistency of performance across multiple real target mobile devices and multiple Applications , and cases the learning process for novice developers. Generic Mobile Device Model  embodies a superset of the features and capabilities found in real mobile devices and well known to those skilled in the art, including without limitation modules for wireless connectivity with a cellular network, Wifi hot spots, and Bluetooth devices; support for communication modes such as signalling, circuit calls, and packet transmission and reception; ports for wired connectivity with nearby devices such as a headphone jack and a USB connector; various human interface devices including primary and optional secondary video display screens, a numeric or alphabetic keypad that may be optionally backlit, miscellaneous buttons that activate functions such as speaker volume control and others, a touchpad or multitouch gesture input pad, speakers, and microphones; environment sensors and effectors such as an accelerometer or motion and orientation sensor, a camera or light sensor, a Global Positioning System (GPS) receiver or other location sensor, a mechanical vibration generator or other haptic effector, and a thermometer or other temperator sensor. Generic Mobile Device Model  features a common operating system and application programming interface supporting access to all included capabilities by Applications .","While Generic Mobile Device Model  supports commonality of feature behavior across multiple Applications , it is also desirable for Application Factory System  to support the specific hardware and software associated with real mobile devices, so that developers may ensure their Applications  and Application Components  work in one or more actual devices, or even to target development specifically to only one actual device. To that end, Application Factory System  incorporates as the fourth and final primary internal element an extensible set of one or more Specific Mobile Device Models , each of which embodies the specific features and capabilities of a real mobile device type. To the extent possible each Specific Mobile Device Model  is a specialization of Generic Mobile Device Model , but in general platform details such as the real software operating system\u2014Symbian, Windows, Linux, WebOS, and so forth\u2014and real device programming interfaces are included. As well, visual elements such as a graphical representation of the actual mobile device, and behavior elements such as an execution simulator, are provided in each Specific Mobile Device Model . In a preferred embodiment, most aspects of a Specific Mobile Device Model  are incorporated in Application Factory System  by embedding or providing programmatic access to the features of the real device's actual software development toolkit, thereby ensuring the most accurate possible representation.","The first major subsystem, Composition Studio , embodies the functions associated, with a development environment, providing the ability to develop Applications  and Application Components . Composition Studio  supports multiple programming paradigms, natively including at least a novice mode suitable for Novice Developer  in which features are constrained and logical elements are represented visually, and an expert mode suitable for Expert Developer  in which all features are available and logical elements are represented textually. Non-native programming modes may also be supported by importing all features into Composition Studio . For example, a mode that uses the Scratch programming language from MIT or the Alice programming language from CMU may be included as an option for Novice Developer , while a mode that uses an Eclipse-based Java development environment may be included as an option for Expert Developer . For ease of use, the various available modes may be presented to a user as a progression of selectable levels with increasing complexity or capability. For example, level 0 would be the simplest and easiest to use, with each data, logic, and graphic object visible only when it is usable, and with every option available via intuitive mouse gestures such as rolling over a label or clicking and dragging an icon. In a preferred embodiment Level 0 is the default for Novice Developer . A simplified Scratch-like mode may be available as Level 1, which in a preferred embodiment may be selected as an alternative programming mode over Level 0. Scratch itself might be available as Level 2, while an Eclipse-like mode with multiple graphical and textual windows might be available as Level 3. In a preferred embodiment, such a Level 3 is the default for Expert Developer . Levels may also be accessed and utilized flexibly through toggling preference items that enable different feature sets, as an alternative to accessing levels as sequentially numbered monolithic feature sets. Additional detail on the features and presentation of different programming modes is provided in the descriptions of  and .","A user of Composition Studio  accesses its capabilities using a computer workstation or personal computer, as is typical of such tools and well-known to those skilled in the art. In , Novice Developer  employs Computer  for this purpose, while Expert Developer  employs Computer  similarly. In either case, the actual implementation of Composition Studio  is itself a software program executing in a computer.","Two execution modes are possible in a preferred embodiment, the service mode and the application mode. In the service mode, Composition Studio  executes in a centralized server computer and presents its user interface to Novice Developer  and Expert Developer  through any of several standard and well-known web browser programs running in, respectively, Computers  and . The interactions between Composition Studio  and Computers  and  in the service mode take place using standard protocols, well known to those skilled in the art, such as IP, HTTP, and HTML, represented in  by Network Connections  and  respectively. In the application mode, Composition Studio  is packaged as a computer software application that executes directly in Computers  and  after being downloaded and installed via well-known means represented in  by Embedments  and  respectively. Programming technology well-known to those skilled in the art, such as Adobe Air or Google Gears, is used in the preferred embodiment to create a single program that supports both service and application execution modes, thereby enabling either users or system administrators to determine which execution mode is appropriate without having had to develop two separate programs.","More detail regarding Composition Studio  is provided in the description of .","The second major subsystem, Distribution Center , embodies the functions associated with an application repository, often called an \u201capp store\u201d in common usage. Distribution Center  supports discovery of, education on, demonstration of, experimentation with, and finally acquisition of Applications  and Application Components , for any of the Specific Mobile Device Models  supported by Application Factory System . Acquisition of a selected Application  or Application Component  may follow collection of a payment if said selected Application  or Application Component  has an associated price; certain Applications  and Application Components  may also be offered free of charge. Distribution Center  provides the aforementioned capabilities to customers, represented in  by Internet Customer  and Mobile Customer .","Internet Customer  accesses the capabilities of Distribution Center  using a computer workstation or personal computer, as is typical of \u201capp stores\u201d and well-known to those skilled in the art, employing Computer  for this purpose. The actual implementation of Distribution Center  is itself a software program executing in a centralized server computer that presents its user interface to Internet Customer  through any of several standard and well-known web browser programs running in Computer . The interactions between Distribution Center  and Computer  take place using standard protocols, well known to those skilled in the art, such as IP, HTTP, and HTML, represented in  by Network Connection . Upon selecting an Application  for acquisition, whether for a price or free of charge, a copy of said selected Application  is transferred into Mobile Device  belonging to Internet Customer  using Application Download . In a preferred embodiment, Application Download  occurs directly into Mobile Device  via the wireless network to which Mobile Device  normally attaches, using over-the-air transmission techniques well known to those skilled in the art. Alternatively, Application Download  may occur over Network Connection  into Computer , and thence under the control of Internet Customer  into Mobile Device  via a wired connection and driver software, neither of which is shown in , that are typical of most mobile device models and well known to those skilled in the art.","Mobile Customer  accesses the capabilities of Distribution Center  directly using Mobile Device , employing either of two techniques typical of \u201capp stores\u201d and well known to those skilled in the art, both of which provide equivalent functionality as previously described, including ultimately the acquisition of Applications  using Application Download . Application Download  is similar to Application Download ; it may occur directly into Mobile Device  via the associated wireless network using over-the-air transmission, or via an inferred Computer  that is not shown in . In the first \u201capp store\u201d technique, Mobile Customer  activates a general-purpose web browser software program similar to that used by Internet Customer , which in turn interacts with Distribution Center  via Network Connection  using the same standard protocols as those found in Network Connection . In the second technique, a purpose-built software program dedicated to accessing Distribution Center  and itself effectively implementing the user interface aspects of Distribution Center  directly, is installed in Mobile Device  as Embedment . Embedment  is typically implemented upon manufacture of Mobile Device  as a portion of its embedded operating software. Alternatively, Embedment  may occur as a specific Application  acquired from Distribution Center  using Network Connection  and downloaded using Application Download . In a preferred embodiment, both \u201capp store\u201d techniques are provided and both implementations of Embedment  are supported.","In addition to supporting ordinary customers such as Internet Customer  and Mobile Customer  via their respective connections as described above, Distribution Center  provides the aforementioned capabilities to application developer customers, such as Novice Developer  and Expert Developer , for the purpose of embedding existing Applications  or Application Components  in their own new Applications  or Application Components . Interaction  between Distribution Center  and Composition Studio  provides the mechanism whereby developers utilize Distribution Center  through Composition Studio  for this purpose. Interaction  also allows a developer using Composition Studio  to offer a completed Application  or Application Component  for distribution via Distribution Center , including the ability to establish the price ordinary customers or developer customers will pay to use or embed, respectively, the offered Application  or Application Component . In a preferred embodiment, pricing is also subject to policies enforced by the proprietor of Application Factory System .","In support of its discovery and education functions in particular, Distribution Center  provides its ordinary and developer customers with mechanisms for rating and reviewing applications, as well as sharing their impressions, recommendations, and warnings with one another. These information and communication facilities take common internet shopping and social networking forms well known to those skilled in the art, such as customer ratings, blogs, reviews, comments, short messages, seller reputations, friends, buddy lists, and so forth. As is common in such systems today, Distribution Center  uses the data acquired in the course of providing these social networking and shopping services to propose purchases and present advertisements to individual customers, as well as to track market behavior on behalf of mobile device manufacturers and application developers, again using techniques that are well known to those skilled in the art.","More detail regarding Distribution Center  is provided in the description of .","The third major subsystem, Build Engine , provides compilation and linking services to the other subsystems. Build Engine  takes a source code package created by Composition Studio  or stored in Distribution Center , and turns the source code into executable objects embodying a particular Application  or Application Component  for the Generic Mobile Device Model  and the supported Specific Mobile Device Models .","The actual implementation of Build Engine  is itself a software program executing in a computer. Two execution modes exist in a preferred embodiment, the application mode and the service mode. The application mode of Build Engine  is similar to the application mode of Composition Studio , and is used in the same circumstances. That is, when Composition Studio  is packaged as a software application to run in a developer's computer directly, Build Engine  is also included in the same application package via Embedment . The Build Engine  operating in application mode serves primarily the Composition Studio  with which it is packaged.","In the service mode, Build Engine  executes in a centralized server computer and operates upon request from its various peers, according to protocols built upon standard techniques well known to those skilled in the art, such as SOAP. Service Interaction  allows Composition Studio  to request build services of Build Engine , and receive the resulting objects, during the application development process. Service Interaction  allows Distribution Center  to build a specific Application  for a specific Mobile Device  or Mobile Device , which conforms to one of the supported Specific Mobile Device Models , but for which Distribution Center  does not have an executable version; this supports situations in which a developer provides builds of Application  for only a subset of Specific Mobile Device Models , or in which a new Specific Mobile Device Model  comes into existence after creation and initial distribution of Application .","In a preferred embodiment, the service mode of Build Engine  exists and operates regardless of whether the application mode exists, so as to support interactions with and provide services to other centralized subsystems. Further, the service mode of Build Engine  provides access to compilation and linking for Specific Mobile Device Models  which may have been added to Application Factory System  since packaging a particular instantiation or version of the Build Engine  and Composition Studio  application mode, thereby ensuring that developers are not stranded.","More detail regarding Build Engine  is provided in the description of .","The fourth and final major subsystem of Mobile Application Factory System  is Verification Engine , which provides mobile device simulation and testing capabilities used by developers and the other subsystems. During development of an Application  or Application Component , Novice Developer  or Expert Developer  will reach a point at which simulated execution of the developed software is appropriate in order to ascertain proper behavior. Verification Engine  presents a user interface by which the developer may step through the various inputs, computations, and outputs of the application and examine the results, much as a traditional software developer might do with a traditional debugger. In the preferred embodiment, simulations for both Generic Mobile Device Model  and multiple Specific Mobile Device Models  are provided, allowing the application developer not only to verify correct execution on the widest possible selection of supported Specific Mobile Device Models , but also to assure a high probability of success on other Specific Mobile Device Models  that may be added to Application Factory System  at a later date through verification on the Generic Mobile Device Model . Further, in the preferred embodiment Verification Engine  also provides a library of test cases suitable for use in testing various classes of Applications  and Application Components , as well as an automated testing environment in which multiple test cases can be selected and executed without developer interaction.","The actual implementation of Verification Engine  is itself a software program executing in a computer. Two execution modes exist in a preferred embodiment, the application mode and the service mode. The application mode of Verification Engine  is similar to the application mode of Composition Studio , and is used in the same circumstances. That is, when Composition Studio  is packaged as a software application to run in a developer's computer directly, Verification Engine  is also included in the same application package via Embedment . The Verification Engine  operating in application mode serves primarily the Composition Studio  with which it is packaged.","In the service mode, Verification Engine  executes in a centralized server computer and operates upon request from its various peers, according to protocols built upon standard techniques well known to those skilled in the art, such as SOAP. Service Interaction  allows Composition Studio  to operate testing and simulation services of Verification Engine  interactively during the application development process. Service Interaction  allows Distribution Center  to request automatic verification of a specific Application  for a specific Mobile Device  or Mobile Device , which conforms to one of the supported Specific Mobile Device Models , but for which Distribution Center  does not have an verified version; this supports situations in which a developer provides verified builds of Application  for only a subset of Specific Mobile Device Models , or in which a new Specific Mobile Device Model  comes into existence after creation and initial distribution of Application . Similarly, Service Interaction  allows Build Engine  to request automatic verification of a specific Application  for multiple Specific Mobile Device Models . This supports a scenario or use case in which a developer tests Application  only against the Generic Mobile Device Model  or a single Specific Mobile Device Model , then submits a bulk build request for the remainder of supported Specific Mobile Device Models ; Build Engine  would in turn request bulk automatic verification of Application  for all supported Specific Mobile Device Models .","In a preferred embodiment, the service mode of Verification Engine  exists and operates regardless of whether the application mode exists, so as to support interactions with and provide services to other centralized subsystems. Further, the service mode of Verification Engine  provides access to testing and simulation for Specific Mobile Device Models  which may have been added to Application Factory System  since packaging a particular instantiation or version of the Verification Engine  and Composition Studio  application mode, thereby ensuring that developers are not stranded.","More detail regarding Verification Engine  is provided in the description of .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 2","FIG. 1","FIG. 1","FIG. 2","FIG. 1"],"b":["120","120","130","140","150","132","142","152","124","125","160","170","162","172","126","127"]},"Starting at the bottom of the diagram are fundamental modules typically found in any modern software program. Network Communication Support Module  provides connectivity with other subsystems of Application Factory System , and contains such common and well known components as an inter-process message-passing software bus, message structure parsing toolkits, a TCP\/IP protocol stack implementation, and networking hardware drivers appropriate for the computer hardware on which Composition Studio  runs. User Interface Support Module  provides tools for presenting information visually to a user of Composition Studio , such as Novice Developer . In a preferred embodiment, User Interface Support Module  takes the form of a portable and generic application programming interface (API), well known to those skilled in the art, by which the other software components of Composition Studio  may create visual elements such as text, lines, polygons, animations, and so forth. The use of programming technology such as Adobe Air, supporting both service and application execution modes as described in the context of , is a significant aspect of User Interface Support Module . This allows the remainder of the modules in Composition Studio  to ignore the execution mode and the details of producing graphics, whether directly on an attached screen in application execution mode, or via a markup language and network protocol as in service execution mode. Those skilled in the art will notice that Network Communication Support Module  and User Interface Support Module  are but a subset of the capabilities found in typical computer operating system software.","Fundamental to Composition Studio , as an environment for creation of Applications , is the Visual and XML-Based Representation Language . This Visual and XML-Based Representation  is the language in which developers will express the logical, structural, temporal, graphical, and other elements of their ideas for an Application  or Application Component . A visual representation is provided for those, such as Novice Developer , who prefer or understand better via such a representation. A formal textual representation, formulated using the well known Extensible Markup Language (XML), is provided both for those, such as Expert Developer , who prefer or understand better via such a representation, and for use by the software modules of Composition Studio  and its peer subsystems in algorithmically transforming the developer's expressed ideas into a tested Mobile Device Application  or Mobile Device Application Component .","In the present invention the specific visual representation is a flexible item, evolving over time as developers interact with Composition Studio  and provide feedback regarding the effectiveness of Language . Similarly, the specific XML-based textual representation is flexible as well, evolving alongside the visual representation and adapting to match it.","To begin, the visual representation part of Language  may incorporate elements from several existing visual programming languages, including Scratch, Alice, Mindstorms, LabView, and VPL, as well as potentially novel elements and elements borrowed from unrelated domains. As developer feedback drives tuning of the visual representation, it may incorporate additional elements not present in any of those progenitors. It may also grow to incorporate one or more of elements entirely, or nearly so, as well as other visual representations that are less graphical and more textual, or that use ideation modes not yet conceived, via the Level technique described in the context of . Each Level may be sufficiently complete that it can be used as a semi-independent mode of the visual representation within Language , or the various Levels may provide various subsets of the expressive power of Language , depending on how the representations evolve as driven by developer feedback and other research.","The XML-based textual representation part of Language  is generally readily derivable from the visual representation part by one skilled in the art. It is necessarily mathematically homogeneous and completely lossless with respect to the totality of the visual representation, such that any visually expressed configuration of ideas can be captured entirely in the XML-based representation, stored during a hiatus of the Composition Studio  by the developer, and subsequently reproduced exactly upon restoration, through any number of such cycles. In addition, the detailed elements of the XML-based textual representation part of Language  are to a large degree independent, for any particular concept, of the specific visual representation that a particular developer may prefer for that particular concept, except to the extent that it may also identify exactly which specific visual representation is being used. This allows a developer to switch between one Level and another if desired, using the different visual representations to express the same ideas without loss of generality. The detailed elements of the XML-based textual representation part of Language  also enables and simplifies the various algorithmic transformations which are needed to turn the developer's expression into a running Application  and which are embodied in various modules throughout Application Factory System .","Thus, Visual and XML-Based Representation Language  underlies and interlaces all the modules of Composition Studio, as the general form in which are expressed all the various aspects of any Mobile Device Application  or Mobile Device Application Component .","To enable the expression of a developer's ideas using Language , Composition Studio  incorporates Visual Programming Design Toolkit  and Multimedia User Interface (UI) Design Toolkit  as major modules. Each of these modules supports placement of elements from various palettes onto a corresponding canvas, following a metaphor derived from the practice of art, and used widely in computer software applications intended for expression of various types of creative ideas due to its simplicity and culturally independent comprehensibility.","Within Visual Programming Design Toolkit , Data and Logic Canvas  offers a multidimensional placeholder for the expression of data, data flows, data manipulation logic, events, event response logic, and other related aspects of a particular Application  or Application Component  under development. Data and Logic Canvas  may be configured to appear as a single workspace, or as multiple linked workspaces, according to the needs and preferences of the particular developer as well as the complexity of the ideas being expressed. Elements may be arranged within the workspaces of Canvas  to form scripts that specify behavior, layouts that specify data structure, networks that specify data flow, and so forth as will be readily apparent to those skilled in the art. Formalized advanced concepts, such as entity relationship diagrams, state transition diagrams, message sequence charts, and others, may be incorporated as well. These more advanced elements would be associated with the higher of the Levels, or the additional separately-enabled feature sets, previously described, such that Level 0 presents primarily the most basic of elements suitable for Novice Developer .","In general, specific logic and data elements are dragged onto Canvas  from various palettes, and then specific attributes are established through controls such as menus, buttons, and pointer gestures. For example, upon dragging a graphical icon representing a control loop logic element onto Canvas , the developer may click the pointer on a box in the icon and then type digits indicating the number of times to repeat the loop. The developer may then drag additional logic elements onto the control loop logic element to establish the behavior to execute repeatedly inside the loop. As another example, the developer may drag a graphical icon representing a data input source such as a keyboard onto Canvas , followed by another graphical icon representing a data output destination such as a Short Message Service (SMS) recipient. The developer might then click the pointer in a box on the SMS icon, then type a phone number to identify the destination of a message. The developer might further click the pointer on an outward-directed arrow icon within the keyboard icon, drag the pointer over to an inward-directed arrow on the SMS icon, and release the pointer, thereby expressing that what the end user of this Application  types will be sent to via SMS to the destination. These are but two examples, but it will be plain to those skilled in the art that innumerable expressions would be possible using various combinations of elements on such a Canvas .","The elements that may be placed on Data and Logic Canvas  come from a variety of palettes within Visual Programming Design Toolkit . Event Palette  offers icons representing asynchronous occurrences such as, without limitation, application activation and shutdown or key presses, as well as programmable event-generating elements such as menus and buttons, any of which can be used as script starting points. Logic Palette  offers icons representing control structures such as, without limitation, the well known IF\/THEN\/ELSE, DO\/WHILE, FOR\/DO, and SELECT, as well as commands such as DISPLAY SCREEN or STOP\/EXIT. Data Palette  offers icons representing data structures such as, without limitation, numbers, character strings, lists, arrays, and compound objects. Data Palette  may also offer tools supporting the advanced elements described above, such as flow and relationship connectors. Math Palette  offers icons representing mathematical operations, such as, without limitation, the usual arithmetic operators found on a calculator, Boolean operators, and complex functions such as might be seen in a standard spreadsheet program. Finally, Service Palette  offers icons representing specific features of a mobile device, such as its communication and sensing capabilities. In a sense, Service Palette  embodies visually what would in a traditional programming environment be called the Application Programming Interface (API) for specific device functions. Example elements to be found in Service Palette , representing capabilities typically available in most mobile devices, include without limitation, communication channel tools that provide access to information transfer services such as SMS and MMS, E-mail, RSS, Telephony, Wifi and Bluetooth links, various Instant Messenger (IM) and Voice over Internet Protocol (VoIP) clients such as GTalk or Skype, and various complex clients for social network services such as Facebook or Twitter; location information tools such as a GPS receiver or location sensor, an accelerometer or motion sensor, and interactive map databases; time and date tools such as a clock, a calendar, and various alarms; and information\/productivity tools such as a memo pad or personal note composer and database, a sketch pad or personal drawing composer and database, an address book or contact list database, an agenda or personal calendar event database, and a conversation record or message composer and database. Specific functions and data offered by each of the Service Palette  elements listed above is dependent on the service provided, but will be readily evident to one skilled in the art upon reflection, investigation of the cited services, and examination of typical feature sets found in devices on the market today.","Within Multimedia UI Design Toolkit , Multimedia UI Canvas  offers a multidimensional placeholder for the expression of screen presentations, audio input and output, text input and output, and other related user interaction aspects of a particular Application  or Application Component  under development. Multimedia UI Canvas  may be configured to appear as a single workspace, or as multiple linked workspaces, according to the needs and preferences of the particular developer as well as the complexity of the ideas being expressed. Elements may be arranged within the workspaces of Canvas  to form screen layouts, animations, and so forth as will be readily apparent to those skilled in the art.","In general, specific user interaction elements are dragged onto Canvas  from various palettes, and then specific attributes are established through controls such as menus, buttons, and pointer gestures. For example, upon dragging a graphical icon representing a new screen element onto Canvas , the developer may then drag additional graphic elements onto the screen element to establish the visual content of that screen, and use a menu to assign an animation behavior to one or more of the graphic objects on that screen. This is but one example, but it will be plain to those skilled in the art that innumerable expressions would be possible using various combinations of elements on such a Canvas .","The elements that may be placed on Multimedia UI Canvas  come from a variety of palettes within Multimedia UI Design Toolkit . Graphic Palette  offers icons representing graphic objects to be drawn on the Canvas , such as, without limitation, line segments, polygons, complex predefined shapes, and freehand shapes. Widget Palette  offers icons representing information input and output, including without limitation buttons, text boxes, list boxes, drop-down lists, and so forth. Audio\/Video Palette  offers icons representing sounds, movies, photos, or other audible and visible entities that may be detected (input) or played (output), and tools for manipulating or altering such items that may be produced or encountered within an Application . Examples of manipulation or alteration elements that may be offered on Audio\/Video Palette  include, without limitation, a speech recognition capability or speech to text translator, and a text reading capability or text to speech translator. Haptic Palette  offers icons representing mechanical vibrations, feedback forces, or gestures that may be detected or played, and tools for manipulating or altering such items that may be produced or encountered within an Application .","As previously mentioned in the context of , a developer may choose to target a Specific Mobile Device Model  for a particular Application  or Application Component , rather than developing for the Generic Mobile Device Model . This choice is expressed in Composition Studio  through Specific Mobile Device Selector . In a preferred embodiment, Specific Mobile Device Selection  may present to the developer a list of supported Specific Mobile Device Models , which may include both individual devices and device families or brands, and allow one or more to be selected. When a Specific Mobile Device Model  is selected as the target for a particular development project for a particular Application  or Application Component , the items available in the various Palettes of Toolkits  and  are constrained such that primarily those pertinent to features present in the Specific Mobile Device Model  selected via Specific Mobile Device Selector  may be used. For example, if a selected Specific Mobile Device Model  does not have a motion sensor or accelerometer, the corresponding capabilities would be disabled or not even visible within Service Palette . Similarly, if a selected Specific Mobile Device Model  does not have the ability to apply vibrations or force feedback in response to touch-screen events, the corresponding capabilities would be disabled or invisible within Haptic Palette . Other constraints will be readily evident, following from this principle, to one skilled in the art.","Visual Programming Design Toolkit  and Multimedia UI Design Toolkit  are interconnected within Composition Studio  such that elements assigned to the Canvas of one may have related manifestations in the Canvas of the other. For example, if a new screen element is created within Multimedia UI Canvas , it will become possible for the DISPLAY SCREEN command in Logic Palette  to identify the new screen element as the one to be displayed. If a programmable button element is created on Data and Logic Canvas , it will become possible to link it with a graphic element on a screen on Multimedia UI Canvas , such that when an end user of the corresponding Application  points at that area of the that screen, the programmed event is triggered. More complex examples can be constructed using the capabilities of Composition Studio , as will be readily apparent to those skilled in the art.","In a preferred embodiment, all palettes within both Design Toolkits  and  are designed to be extensible so that elements can be added and changed easily as the Language  evolves. The specific elements presented in each palette may also be filtered, or have complex parameters set to reasonable and perhaps unchangeable defaults, according to the programming Level in which the Composition Studio  is operating at any particular moment. New palettes may be defined as well. Further, each palette can be extended to incorporate Application Components , and even embeddable Applications , of the corresponding semantic class. Design Toolkits  and  may discover automatically, or support developers in their interactive discovery of, Application Components  and embeddable Applications  that are available in Distribution Center . Distribution Center Library Client  provides the mechanism implementing the Composition Studio  end of Service Interaction  with Distribution Center , in support of this capability.","Default palette elements, as well as discovered Application Components  and embeddable Applications  retrieved from Distribution Center  by Distribution Center Library Client , are cached within local repositories at Composition Studio  for use by Design Toolkits  and . Default multimedia elements and semantically related Application Components  are kept in UI Object Library Cache . Default logic and data elements, including event, math, and service elements, and semantically related Application Components , are kept in Service Object Library Cache . Applications  that can be incorporate whole into other Applications , or which include pieces which may be incorporated separately from the whole, are kept in Embeddable App Library Cache . In a preferred embodiment, Library Caches , , and  are implemented as separate database instances of identical structure for simplicity.","When a developer has expressed enough ideas to form something usable as a mobile application or mobile application component, it should be tested using the capabilities of Visual Verification Toolkit . The elements on Data and Logic Canvas  can be executed, and the elements on Multimedia UI Canvas  can be presented, individually or together as a whole according to the preferences and needs of the developer, in a high fidelity simulation environment essentially identical to that which will exist on any target Mobile Device  or .","Locally within Composition Studio , Visual Verification Toolkit  provides testing in the environment of the Generic Mobile Device Model . The portion of Generic Mobile Device Model  that is relevant for testing, in particular the runtime executive but not the compilation tools, is incorporated in Visual Verification Toolkit  as Generic Mobile Device Model Testing Module . In addition, so that the developer may interactively observe the execution of expressed elements, two additional modules are desirable.","Generic Mobile Device Interface Simulator  provides linkages between physical devices on the developer's Computer  or , and logical devices of Generic Mobile Device Model Testing Module . For example, Computers  and  are likely to have a microphone and speakers, perhaps a camera, and certainly a screen and keyboard. Interface Simulator  links these devices with corresponding devices in the Generic Model Testing Module . Most Computers  and  are likely to be able to play arbitrary sound files and video files as well, allowing Interface Simulator  to superimpose those media streams on corresponding simulated inputs and outputs as appropriate for testing, or in place of corresponding real input or output devices. Most Computers  and  will have a touchpad or a mouse, either of which can be mapped by Interface Simulator  onto a touchpad of Generic Model Testing Module . Some Computers  or  may have a multitouch pad or screen, which Interface Simulator  can map onto a multitouch pad of Generic Model Testing Module . Most Computers  and  will have Internet connections, and many will have access to Internet-based email, instant messaging, and voice calling services. Interface Simulator  can map these services onto wireless communication links and corresponding communication service interfaces within Generic Model Testing Module .","Generic Mobile Device Capability Simulator  provides simulations of certain Generic Mobile Device Model Testing Module  capabilities that would not normally be available on any Computer  or . For example, the GPS receiver and accelerometer of many real mobile devices, which are modeled in Generic Model Testing Module , have no physical counterpart on the typical Computer  or . Therefore, Capability Simulator  may provide a visual simulation of location, whereby an icon representing the modeled mobile device is shown superimposed on a map at a developer-selected location, and Generic Model Testing Module  is given inputs such that its simulated GPS receiver reports the selected location to logic and data elements using it. The developer may click on the device icon and drag it to a new location, or select a mode in which the simulated device is propagated along a selected path at a particular velocity, and the simulated GPS receiver will report, again to those logic and data elements using it, the location as it changes while moving. Similarly, a fine-scale motion simulation may be provided by Capability Simulator , whereby the developer may select a mode similar to a three-dimensional fly-around display in which the simulated device may be shaken or placed in different orientations by clicking and moving the mouse of Computer  or . In this mode, the simulated accelerometer in Generic Model Testing Module  will report, to those logic and data elements using it, corresponding fine motion changes.","In some situations, the developer will not be satisfied with testing against only the Generic Mobile Device Model Testing Module . If an Application  under development relies upon unique features of a Specific Mobile Device Model , or if for any reason the developer wishes to be absolutely certain of the behavior on a particular model, Visual Verification Toolkit  has the ability to access any and all Specific Mobile Device Models  for testing. This is accomplished by utilizing Verification Engine  through Verification Engine Client , which implements the Composition Studio  end of Service Interaction . Noting that Verification Engine  may also be incorporated into Composition Studio  via Embedment  when operating in application execution mode, it is also possible for Visual Verification Toolkit  to interact with the developer's own real Mobile Device  for testing purposes. In either case, prior to executing the Application  under development on a real Mobile Device  or Specific Mobile Device Model , it will be desirable to compile the expressed design into an actual executable suitable for the target. This is accomplished by Build Engine , through Build Engine Client , which implements the Composition Studio  end of Service Interaction .","In general, a complete and tested Application  or Application Component  may be submitted to Distribution Center  for consideration. Distribution Center Submission Client  provides the ability to do so, implementing the submission aspects of the Composition Studio  end of Service Interaction . Relevant aspects include, without limitation, identifying and transmitting the submitted Application , identifying the submitting developer as a specific user of Distribution Center , and setting a price (which may be zero) for others to use it.","A thorough developer will generally build and test the completed Application  or Application Component  on multiple real Mobile Devices  or Specific Mobile Device Models . To ease this process, Build Engine Client  and Verification Engine Client  provide the ability to submit the Application  or Application Component , as expressed in Language , to Build Engine  for builds on multiple Specific Mobile Device Models , and then to Verification Engine  for automatic verification using a detailed test plan on multiple, or even all, Specific Mobile Device Models . More information on these bulk build and verification modes is provided in the descriptions of , respectively.","Tying together all the user-facing functionality of Composition Studio  is Graphical User Interface . This is a design module that provides graphical and interactional support for each of the functions already described. It is implemented, using techniques well known to those skilled in the art, in a manner that integrates with the functional modules and relies upon the features of User Interface Support Module . An example layout that may be used for User Interface  in a preferred embodiment of the present invention is shown in .",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 3","FIG. 1","FIG. 1","FIG. 3","FIG. 1"],"b":["130","130","120","140","150","132","143","153","180","183","180","191","193","139","108","109"]},"Starting at the bottom of the diagram are fundamental modules typically found in any modern software program. Network Communication Support Module  provides connectivity with other subsystems of Application Factory System , and contains such common and well known components as an inter-process message-passing software bus, message structure parsing toolkits, a TCP\/IP protocol stack implementation, and networking hardware drivers appropriate for the computer hardware on which Distribution Center  runs. User Interface Support Module  provides tools for presenting information visually to a user of Distribution Center , such as Internet Customer  or Mobile Customer . In a preferred embodiment, User Interface Support Module  takes the form of a portable and generic application programming interface (API), well known to those skilled in the art, by which the other software components of Distribution Center  may create visual elements such as text, lines, polygons, animations, and so forth. The use of programming technology such as Adobe Air, supporting both the web service implementation and the mobile application embedment implementation of the user interface as described in the context of , is a significant aspect of User Interface Support Module . This allows the remainder of the modules in Distribution Center  to ignore the execution site of User Interface Support Module  and the details of producing graphics, whether directly on an attached screen in the mobile application embedment implementation, or via a markup language and network protocol as in the web service implementation. Those skilled in the art will notice that Network Communication Support Module  and User Interface Support Module  are but a subset of the capabilities found in typical computer operating system software. Though important in that Distribution Center  could not exist at all without them, the bulk of operating system functionality is left unshown and implicit to the implementation because it does not differentiate any novel aspects of the present invention.","At the next layer of abstraction up the functional stack of Distribution Center , User Database Module  provides the fundamental representation and storage of profile information for customers, including those similar to Internet Customer  and those similar to Mobile Customer , as well as developers including those similar to Novice Developer  and those similar to Expert Developer . In a preferred embodiment, User Database Module  is implemented as a specialization of an off-the-shelf database system, such as the popular open source database MySQL.","Another fundamental middleware module of Distribution Center  is Web Application Server . This module provides the environment in which the major functional elements execute, providing transparent session management, high performance multiprocessing, and high availability services. In a preferred embodiment, Web Application Server  is implemented as a specialization of an off-the-shelf web server system, such as the popular open source web application suite often referred to as LAMP, comprising Apache coupled with MySQL and PHP, all running on Linux.","At the core of Distribution Center  in its role as an \u201capp store\u201d is the ability to store Applications , Application Components , and information or metadata about each one. Library Services module  embodies this set of functions. Search Toolkit  offers users the ability to browse and search for specific items in the various repositories, using various attributes of the stored items as search keys. App (application) Repository  stores all the Mobile Device Applications  that are present in Distribution Center , including those that are embeddable in other Applications  by developers using Composition Studio . SO (service object) Repository  stores all the Mobile Device Application Components  which represent complex device functionality suitable for use in the Visual Programming Design Toolkit  of Composition Studio , and which are known as service objects or SOs. UO (user interface object) Repository  stores all the Mobile Device Application Components  which represent multimedia user interface functionality suitable for use in the Multimedia UI Design Toolkit  of Composition Studio , and which are known as user interface objects or UOs. In a preferred embodiment, Repositories , , and  may be implemented as separate database instances of identical structure, or as a single database instance containing all three repositories, for simplicity. Also in a preferred embodiment, Library Services module  is implemented as a specialization of the file management feature set of an off-the-shelf web-services content management system (CMS), such as the popular open source social networking and publishing platform Elgg.","Also central to the \u201capp store\u201d role of Distribution Center  is On-Demand Download Service . This module provides functions associated with acquiring an item stored in Library Services module . When a customer selects a particular Application  for acquisition and download to a Mobile Device  or , which is of a supported Specific Mobile Device Model , On-Demand Download Service  may determine which Specific Mobile Device Model  is desired. Specific Mobile Device Selector  makes this determination by looking in the customer's user profile as stored in User Database Module . If the information is not there, Specific Mobile Device Selector  prompts the customer for this information by presenting a menu of supported Specific Mobile Device Models . In the special case of the mobile application embedment implementation, Selector  may also query User Interface Support Module  for information about the Mobile Device  in which it is running, and mapping that information to the Specific Mobile Device Model . For example, the International Mobile Equipment Identifier (IMEI) generally identifies the manufacturer and model code of Mobile Device , and the software version string generally provides enough information to identify the exact operating system release. Together, these codes may be used to select the correct Specific Mobile Device Model  desired for the requested acquisition and download. Selector  may also, upon discovering the customer's Specific Mobile Device Model , record it in the customer's profile via User Database Module .","With the pertinent Specific Mobile Device Model  known, On-Demand Download Service  next determines whether a compatible executable version of the selected Application  exists in Distribution Center , submitting a query for that information to App Repository  via Search Toolkit . If no such version exists, Download Service  creates one by submitting the source code of Application  as expressed in Language  to Build Engine  via Build Engine Client , which implements the Distribution Center  end of Service Interaction . Upon receipt at Build Engine Client  of the executable Application  version as compiled for the selected Specific Mobile Device Model , Download Service  stores it in App Repository .","With the desired executable Application  version in hand, Download Service  examines the price of Application  as stored in the metadata that accompanies it in App Repository . If the price of Application  is not zero, Download Service  may enter E-Commerce Engine  to take payment. Payment arrangements may be stored in the customer's profile at User Database Module , or collected at purchase time via customer input. E-Commerce Engine  is responsible for making the corresponding determinations, collecting the necessary information, and interacting with external payment clearinghouses such as credit card networks and PayPal, via standard interfaces not shown in  as they are well known to those skilled in the art. E-Commerce Engine  is also responsible for allocating the proceeds of the customer's purchase to the various parties owed money in the transaction. These include, without limitation, the developer of the delivered Application , along with the developers of any Application Components  and embedded Applications  incorporated within the delivered Application  and licensed on a per-instance basis, as well as the proprietor of Distribution Center  and, if such business arrangements exist, the proprietors of other facilities used during the transaction such as Network Connection .","Finally, Mobile Device OTA (Over The Air) Delivery Module  provides the procedures and interfaces desirable to execute Application Download , thereby pushing the acquired Application  executable out to Mobile Device  over Network Connection . Alternatively, in the event the destination is an Internet Customer's Mobile Device , OTA Delivery Module  may execute Application Download , thereby pushing the acquired Application  executable out to Internet Customer's Computer  over Network Connection , from whence Internet Customer  (shown in  but omitted from  due to space constraints) would be responsible for the further movement of Application  into Mobile Device . In general, OTA Delivery Module  may be cognizant of different protocols for each Specific Mobile Device Model , and would select the correct one to use for each download transaction.","Where Library Services  and Download Service  are concerned with storing, finding, and delivering Applications , the problem of educating customers about Applications  has not yet been addressed fully. While descriptive metadata, associated with each Application  and available in Repository , are useful and informative, they are static and alone would be considered incomplete by today's standards of online product information. Distribution Center  therefore provides an additional means of self-education and, as has become typical of online marketplaces, a cooperative means of mutual peer education among customers.","Mobile Application Demonstrator  provides the additional means of self education by offering a mechanism whereby customers may interact with Applications  in live simulations of the Generic Mobile Device Model  and Specific Mobile Device Models . Demonstrator  is similar in many respects to the simulation environment provided by Visual Verification Toolkit , and is implemented using identical technical capabilities except that it is constrained to presenting each Application  whole. By default, Demonstrator  offers Generic Mobile Device Model Demonstrator , which is the demonstration-only subset of Generic Mobile Device Model . At the request of a customer, Demonstrator  may also offer Specific Mobile Device Selector and Simulators , which allows the customer to choose which Specific Mobile Device Model  to simulate while demonstrating Application .","Cooperative education among customers is supported by User Interaction Services module . Various toolkits provide customer to customer, customer to developer, and developer to developer connections and information flows patterned after models that have become typical of modern, so-called \u201cWeb 2.0\u201d services. Social Networking Toolkit  offers the typical capabilities related to forming and presenting an online persona, such as profile information collection and avatars, as well as forming and recording connections among friends and acquaintances, thereby allowing customers and developers to keep one another apprised of what Applications  and Application Components  they are using, as well as sharing what they think of each one. Reputation Toolkit  offers the ability to collect, present, and track customer and developer reviews, opinions, and ratings of Applications , Application Components , and one another. Communication Toolkit  offers such communication media as blogs, forums, private messages, groups messages, public messages, and so forth. Those skilled in the art will readily identify additional features not named here that would typically be, and in the preferred embodiment of the present invention are, included in the toolkits of User Interaction Services module . In addition, User Interaction Services module  may offer features that are built upon a combination of its component toolkits' capabilities. For example, User Interaction Services module  may provide a feature that permits a customer to post a request, either openly or directed to a specific developer, for development of an Application  with particular attributes as described by the customer. User Interaction Services module  may also provide a corresponding feature that permits a developer to identify an Application  as being submitted in response to such a customer request, and which in turn notifies the requesting customer that the requested Application  has become available. In a preferred embodiment, User Interaction Services module  is implemented as a specialization of an off-the shelf web-services content management system (CMS) such as the popular open source social networking and publishing platform Elgg.","Astute readers will have noticed that both Library Services module  and User Interaction Services module  are built upon the Elgg platform in a preferred embodiment. While not previously mentioned, Download Service  and Demonstrator  may also be integrated with the Elgg platform via plug-ins in a preferred embodiment. Sharing the platform in this manner enables various synergies to arise. For example, when two customers identify one another as friends via Social Networking Toolkit , they may exchange opinions, tracked by Reputation Toolkit , about a group of Applications . If one of the friends expresses a favorable view of one Application  in the group, while the other has not used it, the first may choose to send a copy to the second via Download Service . E-Commerce Engine  may be configured in this situation to charge the sender instead of the recipient, and to charge a discounted price as a reward for the favorable opinion. Alternatively, E-Commerce Engine  may be configured in this situation to charge full price to the recipient, after recipient has received and used Application  for a certain period of time and agrees to keep it, and distribute a portion of the payment to the sender as a reward for the favorable opinion and a commission on the subsequent sale. In another example scenario, if a customer is trying out an Application  in Demonstrator , and if the developer of Application  happens to be logged into Distribution Center  at the same time, Communication Toolkit  may detect this coincidence and offer both customer and developer the option to communicate directly, allowing the customer to ask questions that the developer may answer, and collecting those exchanges automatically into a Frequently Asked Questions file associated with either the Application  or the developer's public profile depending on context and content. Some such synergetic examples will be readily apparent to those skilled in the art, while others that are not obvious may become the subject of subsequent inventions.","The aspects of Distribution Center  so far described have been focused upon the services it provides to external users which exist outside Application Factory System . Service Interaction , whereby Composition Studio  accesses the services of Distribution Center , is handled by Distribution Service , which acts as the counterpart within Distribution Center  to Distribution Center Clients  and  within Composition Studio , connecting developers to the capabilities of Distribution Center  while using Composition Studio . In particular, Composer Submission Service Module  connects to Distribution Center Submission Client , thereby allowing developers to submit, edit metadata, and establish prices for Applications  and Application Components . Library Access Service Module  connects to Distribution Center Library Client , thereby allowing developers to access Library Services , including the entirety of Repositories , , and . Distribution Service  also provides the ability for all of Distribution Center  to embed itself in Composition Studio  via Service Interaction , allowing developers to participate in developer-oriented features of User Interaction Services  and access developer-specific business information captured by Download Service . For example, through Service Interaction  developers would be able to communicate with customers, receive advice from and offer advice to other developers, track opinions and ratings and sales statistics of the developer's Applications  and Application Components , and provide direction regarding disposition of payments received by purchasers of the developer's Applications  and Application Components . Finally, Distribution Service  also incorporates a Verification Engine Client , which handles the Distribution Center  end of Service Interaction  with Verification Engine , thereby enabling Distribution Service  to ensure submitted Applications  and Application Components  are tested thoroughly and do not perform damaging behaviors prior to including Applications  and Application Components  in the appropriate Repository , , or .","Tying together all the user-facing functionality of Distribution Center  is Graphical User Interface . This is a design module that provides graphical and interactional support for each of the functions already described. The Distribution Center  is implemented, using techniques well known to those skilled in the art, in a manner that integrates with the functional modules and relies upon the features of User Interface Support Module . In a preferred embodiment, the layout of Graphical User Interface  will vary dynamically according to the preferences of customers and developers, and may in general resemble a combination of the features typically found in social networking, app store, and development project support systems that are in common use.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":["FIG. 4","FIG. 1","FIG. 1","FIG. 4","FIG. 1"],"b":["140","140","120","130","150","142","143","154","124"]},"Starting at the bottom of the diagram are fundamental modules typically found in any modern server software program. Network Communication Support Module  provides connectivity with other subsystems of Application Factory System , and contains such common and well known components as an inter-process message-passing software bus, message structure parsing toolkits, a TCP\/IP protocol stack implementation, and networking hardware drivers appropriate for the computer hardware on which Build Engine  runs. As a background service, Build Engine  does not have a user interface support module comparable to those in Composition Studio  and Distribution Center . Instead, Build Engine  incorporates a Computation Resource Management Module  that provides tools for scheduling compilation transactions across the available computing resources. This module is essential for the service execution mode, in which Build Engine  is shared among potentially a very large number of simultaneous transactions on behalf of Composition Studio  and Distribution Center . Computation Resource Management Module  is also somewhat useful for the application execution mode, in which Build Engine  coexists with user-facing interactive tasks as part of Composition Studio . In either case, the computation intensity required for an individual compilation transaction is very high, necessitating the resource management capability. Those skilled in the art will notice that Network Communication Support Module  and Computation Resource Management Module  are but a subset of the capabilities found in typical computer operating system software. Though important in that Build Engine  could not exist at all without them, the bulk of operating system functionality is left unshown and implicit to the implementation because it does not differentiate any novel aspects of the present invention.","As a background service, the fundamental module of Build Engine  is the Build Service , which orchestrates compilation transactions requested by other subsystems of Application Factory System . Within Build Service module , Service Responder Module  is responsible for receiving compilation requests from Build Engine Client  of Distribution Center  and Build Engine Client  of Compilation Studio  via Service Interactions  and , respectively, and returning results to them. In certain circumstances, such as the inclusion within the requested compilation of references to embedded Applications  or Application Components , Distribution Center Library Client Module  is responsible for retrieving the appropriate compilable or linkable versions of the referenced items from Distribution Center , specifically Library Access Service Module , via Service Interaction . Build Service module  also incorporates a Verification Engine Client , which is a substantially identical copy of Verification Engine Clients  and  in Distribution Center  and Composition Studio , respectively, for the purpose of submitting a compiled Application  to Verification Engine , via Service Interaction , so that it can be tested for inappropriate or malicious behavior prior to returning it to the requesting Build Engine Client  or . Thus, Build Service module  handles the Build Engine  end of all three Service Interactions , , and  with Composition Studio , Distribution Center , and Verification Engine , respectively.","A compilation request submitted to Build Engine  may contain one or more objects to be compiled. Each object is the expression of an Application  or Application Component , produced with the aid of Composition Studio . Once any additional objects referenced by the expression but not included in the request as submitted are retrieved by Build Service  using Library Client  as described above, the entire group forms a Compilation Set  comprising Service Objects, UI Objects, and Application expressions. This unit of compilation can then be handled by Service Adaptation Framework  as part of turning it into an executable Application  or linkable Application Component .","At the heart of Build Engine , Service Adaptation Framework  embodies the fundamental algorithms that transform a portable expression from Composition Studio  into source code targeting a Specific Mobile Device Model . Each module of Service Adaptation Framework  provides a desired step in, or an abstraction effectuating, that transformation. The following paragraphs describe each of those modules in turn.","Visual and XML-Based Representation Language  is an abstraction that defines the syntax and semantics of expressions produced by Composition Studio . The Visual and XML-Based Representation Language  is substantially identical to that subsystem's Visual and XML-Based Representation Language , except that here the visual aspect is present but not relevant to the compilation transaction. That is, only the XML-based textual representation is used in transforming Compilation Set .","The semantics of the expressed Application  or Application Component  as it emerges from Composition Studio  exist in the context of Generic Mobile Device Model . For compilation, the expression may be combined with common code associated with Generic Mobile Device Model , as embodied in the Generic Mobile Device Model Build Toolkit  abstraction. For one skilled in the art, this abstraction can be considered as being analogous to a middleware package and API that present a uniform syntax and semantic for services defined differently by every hardware and operating system software platform. During the compilation transaction, then, Service Adaptation Framework  adds the Build Toolkit  middleware to Compilation Set , and runs the combination through XML-Based Representation Language Interpreter .","Interpreter  is responsible for parsing each expression in the combined Compilation Set  and Build Toolkit  middleware, driving its translation using syntactic analysis and compiler techniques well known to those skilled in the art, in conjunction with a Target Device-Specific Language Code Generator  selected by Specific Mobile Device Selector , which identifies the target Specific Mobile Device Model  and chooses the appropriate translator from among all Target Device-Specific Language Code Generators . Together, Interpreter  and Code Generator  produce a new expression of Compilation Set  in the form of source code native to the target Specific Mobile Device Model . This new expression is in turn combined with Precompiled Component Objects  as needed and as available, and run through the compiler and linker associated with target Specific Mobile Device Model  selected from Target Device-Specific Software Development Kits and Tool Chains . The selected Tool Chain  produces a Target Device-Specific Executable  that embodies Application  for the selected target Specific Mobile Device Model . If not already present among Precompiled Component Objects , Service Objects and UI Objects that had to be translated and compiled for this transaction are added so they can be used without recompiling in future transactions.","As previously mentioned, Build Service  can submit Executable  to Verification Engine  using Verification Engine Client  in order to ascertain whether the embodied Application  performs any inappropriate or malicious behaviors in its final form. In a preferred embodiment of the present invention, Build Service  may also submit the uncompiled Compilation Set  to Verification Engine  for the same purpose, prior to beginning translation. Each verification run, both before and after compilation, has the ability to detect different types of inappropriate or malicious behaviors.","Because any given compilation transaction may take the form of a \u201cbulk\u201d build that requests multiple builds corresponding to multiple target Specific Mobile Device Models , Build Service  may drive each Compilation Set  through Service Adaptation Framework  and several Tool Chains  multiple times, producing a separate Executable  each time. All Executables  that are produced due to a single request are returned, though not necessarily in a single response; the use of multiple responses facilitates parallelism between Build Engine  and the requestor such that Executables  that are ready to be handled at the requestor may be.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":["FIG. 5","FIG. 1","FIG. 1","FIG. 5","FIG. 1"],"b":["150","150","120","130","140","152","153","154","125"]},"Starting at the bottom of the diagram are fundamental modules typically found in any modern server software program. Network Communication Support Module  provides connectivity with other subsystems of Application Factory System , and contains such common and well known components as an inter-process message-passing software bus, message structure parsing toolkits, a TCP\/IP protocol stack implementation, and networking hardware drivers appropriate for the computer hardware on which Verification Engine  runs. As a background service, Verification Engine  does not have a user interface support module comparable to those in Composition Studio  and Distribution Center . Instead, Verification Engine  incorporates a Computation Resource Management Module  that provides tools for scheduling verification transactions across the available computing resources. This module is essential for the service execution mode, in which Verification Engine  is shared among potentially a very large number of simultaneous transactions on behalf of Composition Studio , Distribution Center , and Build Engine . Computation Resource Management Module  is also somewhat useful for the application execution mode, in which Verification Engine  coexists with user-facing interactive tasks as part of Composition Studio . In either case, the computation intensity required for an individual verification transaction is very high, necessitating the resource management capability. Those skilled in the art will notice that Network Communication Support Module  and Computation Resource Management Module  are but a subset of the capabilities found in typical computer operating system software. Though important in that Verification Engine  could not exist at all without them, the bulk of operating system functionality is left unshown and implicit to the implementation because it does not differentiate any novel aspects of the present invention.","As a background service, the fundamental module of Verification Engine  is the Verification Service , which orchestrates verification transactions requested by other subsystems of Application Factory System . Within Verification Service module , Service Responder Module  is responsible for receiving verification requests from Verification Engine Client  of Build Engine , Verification Engine Client  of Distribution Center , and Verification Engine Client  of Compilation Studio , via Service Interactions , , and  respectively, and returning results to them. Thus, Verification Service module  handles the Verification Engine  end of all three Service Interactions , , and  with Composition Studio , Distribution Center , and Build Engine , respectively.","Depending on the requestor and the specific request, Verification Service  may operate in either interactive mode or automated mode. Interactive Verification Service  exposes Interactive Verification Framework  to developers using Composition Studio , via Service Interaction . This mode is particularly useful when Verification Engine  is incorporated directly in Composition Studio  via Embedment , supporting local testing of Applications  and Application Components  that are in development. Interactive mode can also be useful when executing as a service, allowing a developer using Composition Studio  to access server-side testing capabilities such as simulators or even actual devices for Specific Mobile Device Models  that are not included in Composition Studio . Automated Verification Service  handles true background, and in particular \u201cbulk\u201d or multiple verification requests, and uses primarily Automatic Verification Framework  to accomplish its tasks. In either case, Verification Service  bundles the request parameters into a data item shown in  as Objects to be Verified , which represents the Applications  and\/or Application Components  that are to be processed in any particular verification transaction handled by Service Responder Module . Objects to be Verified  is in essence an identifier and state placeholder for each verification transaction.","As already mentioned, Interactive Verification Framework  is exposed by Interactive Verification Service  to developers using Composition Studio , in order to support live testing of Objects to be Verified  in the context of devices supported by Verification Engine . Because it is driven interactively by a human developer, the major function of Interactive Verification Framework  is to provide a conduit for user interface inputs and outputs between the developer at Composition Studio  and a Specific Mobile Device Model  being used for the interactive verification transaction. Test Device Interface module  provides this function. In addition, Interactive Verification Framework  supports essential testing features such as single-stepping control, capture of execution traces, and perhaps most valuable, capture of developer-driven sequences of inputs and corresponding outputs via Sequence Recorder module . Sequences captured by Sequence Recorder  may be edited by the developer to create test cases associated with Applications  or Application Components  in Objects to be Verified .","Test sequences captured by Sequence Recorder , or created by external means, are held in Test Plan Database . This repository stores test cases in a formal language that, for any particular test sequence, provides a specification of the inputs to drive and the outputs to expect at each step. In a preferred embodiment, the test case specification language may be one or more of numerous such languages available in the prior art, including in particular the well known Tool Command Language (Tcl). Test Plan Database  also stores test plans as lists of test cases that may be associated with one another due to various factors, such as being part of a usage scenario or exercising a certain class of hardware. The configurations to which a test case or test plan may be applied, and the factors that unite the test cases in a particular test plan, are also held in Test Plan Database  as metadata so as to facilitate test sequence selection.","Test Plan Database  comprises a number of partitions, each holding a particular subset of the potential universe of test cases and test plans. Included, without limitation, among these partitions are Specific Mobile Device Test Cases , which are associated with Specific Mobile Device Models ; Developer-Supplied Application\/Component Tests , which are associated with Applications  and Application Components , and which may have been created externally or captured explicitly by Sequence Recorder ; and Service Adaptation Framework Tests , which are associated with the implementation of Service Adapation Framework  and may be applied to any Application , Application Component , Specific Mobile Device Model . Beyond those partitions shown in  and described in the immediate foregoing, a preferred embodiment will provide a mechanism for extending Test Plan Database  to include additional partitions.","Where Interactive Verification Framework  provides live developer-driven testing, Automatic Verification Framework , as its name implies, automatically tests Objects to be Verified  against a Specific Mobile Device Model , operating in the context of transactions managed by Automatic Verification Service  and in response to requests from Verification Engine Clients , , and  in Composition Studio , Distribution Center , and Build Engine  respectively.","Automatic Verification Framework  includes, without limitation, a Test Device Interface , similar to Test Device Interface  of Interactive Verification Framework . However, where Test Device Interface  acts primarily as a conduit between device and developer, Test Device Interface  provides controlled access to well-defined test cases executed automatically by Automatic Verification Framework . This difference is subtle but significant: no analysis is required within Interactive Verification Framework , while Automatic Verification Framework  may select, execute, and analyze the results of test cases. Test Device Interface  provides therefore not only the raw user interface data stream but also synchronization services and context information such as timestamps so that Framework  may keep the event flow coordinated correctly.","Within Automatic Verification Framework , Test Case Execution Driver  is responsible for selecting and executing specific test sequences through Test Device Interface , while Test Case Success Analyzer  is responsible for observing the result of each step in a test sequence to determine whether it is correct. Test Plan Database , described earlier, provides the raw material for Driver  and Analyzer , storing for any particular test sequence a specification of the inputs Driver  should execute and the outputs Analyzer  should expect at each step. Automatic Verification Framework  may select the sequences it will perform for any specific verification transaction by extracting from Test Plan Database  all those test cases and test plans associated with any element of the Objects to be Verified  for the transaction. That is, sequences in Device Test Cases  that are associated with the Specific Mobile Device Models  in Objects to be Verified , sequences in Application\/Component Tests  that are associated with Applications  or Application Components  in Objects to be Verified , and sequences in Service Adapation Framework Tests  that are common to all Applications , Application Components , or Specific Mobile Device Models , or that are specific to the build process for any of them, may be selected for execution by Automatic Verification Framework . In a preferred embodiment, Automatic Verification Framework  may execute independent test sequences consecutively or in parallel, depending on the resources available at the time of the transaction and according to the priorities of Computation Resource Management Module .","Both Interactive Verification Framework  and Automatic Verification Framework  exercise one or more devices under test, as requested in Objects to be Verified , via their respective Test Device Interfaces  and . In either case, the device under test is provided by Test Device Library , which contains simulations of every Specific Mobile Device Model  supported in Application Factory System , as well as actual instances of whatever subset of those Specific Mobile Device Models  may be economic at a given time in the life of Application Factory System .","Within the Test Device Library  may be found numerous testable device models. First, Generic Mobile Device Model Simulator  provides the executable simulation aspects of Generic Mobile Device Model , allowing Verification Engine  to support testing of any Application  or Application Component  in the common-denominator feature set that model represents. Next, Specific Mobile Device Selector  offers a mechanism whereby a particular Specific Mobile Device Model  may be chosen for testing via one of the Specific Mobile Device Simulators  which embody the corresponding executable simulation aspects. In a preferred embodiment, Specific Mobile Device Simulators  may be incorporated from the software development tools provided by manufacturers of Specific Mobile Device Models , and likely are components of the same toolkits which also provide the compilers and linkers of Target Device Specific Software Development Kits and Tool Chains .","Finally, Test Device Library  may be configured to access Specific Actual Mobile Devices  via dedicated device-specific cabling and driver software. Such access would offer the highest fidelity of device execution during a verification transaction, potentially including actual access to the device's native wireless service. As a physical device, however, this resource would be among the most precious of all in Application Factory System , so the proprietor of System  may choose to charge a fee for verification transactions that use it. In any case, in a preferred embodiment usage of the resources in Specific Actual Mobile Devices  would be carefully managed by Computation Resource Management Module .","Turning now to , a user interface is shown for Composition Studio . Composition Studio Graphical User Interface (or GUI)  expands upon the same element depicted without detail in . GUI  presents a screen subdivided into several regions, each representing a specific function of Composition Studio . Control Area  provides a central grouping for elements that are common to the entirety of Composition Studio . Space is allocated for a graphic Logo , which would in a preferred embodiment contain a symbol, probably a trademark, identifying the Application Factory System , the Composition Studio , and possibly their proprietor. Studio-Level Control Elements area  allocates space for buttons, menus, and tabs common to the entire Composition Studio , including without limitation project information commands, import and export commands, option setting commands, and other similar commands as will be readily apparent to those skilled in the art.","At the center and right side of GUI , spaces are allocated for displaying the three major toolkits of Composition Studio . Visual Programming Design Toolkit  and in particular Data and Logic Canvas , Multimedia UI Design Toolkit  and in particular Multimedia UI Canvas , and Visual Verification Toolkit  are, one to each, displayed within the Primary, Secondary, and Tertiary Toolkit Areas , , and . The spaces allocated for Toolkit Areas , , and  are all of roughly the same proportions, or aspect ratio, though of different sizes. The proportions selected and shown in GUI  correspond roughly to those of a typical mobile device display screen, such that the developer may perform screen design in Multimedia UI Design Toolkit  upon Multimedia UI Canvas  using an accurate representation of the target device's screen. Similarly, testing in Visual Verification Toolkit  is facilitated by the presentation of the selected device simulator's user interface aspects, whether Generic Mobile Device Interface Simulator  or a Specific Mobile Device Simulator , again using an accurate representation of the target device's screen. In a preferred embodiment, the actual proportions of Toolkit Areas , , and  may be set to mimic exactly the display screen of a Specific Mobile Device Model  as selected by the developer.","Which Toolkit , , or  is displayed in which Toolkit Area , , or  upon initially entering Composition Studio  would, in a preferred embodiment, be set according to developer preferences; such preference commands would be found via one of the common controls in Studio-Level Control Elements . In order to control which Toolkit , , or  is in each Toolkit Area , , or  at any subsequent time, the two Swap Buttons  and  are provided. When activated using a pointer device, each Swap Button  or  causes the Toolkit , , or  currently displayed within the corresponding Toolkit Area  or  to be displayed instead in the larger Primary Toolkit Area , and causes the Toolkit , , or  formerly displayed in Primary Toolkit Area  to be displayed instead in the smaller Toolkit Area  or , respectively according to which of the two Swap Buttons  or  was activated. Primary Toolkit Area  is rather larger than Secondary and Tertiary Toolkit Areas  and ; one skilled in the art would surmise that most of the developer's activities should take place within Primary Toolkit Area . While Primary Toolkit Area  is larger for exactly this reason, nevertheless any function available in Toolkit , , or  when displayed in Primary Toolkit Area  may also be performed when displayed in either Secondary Toolkit Area  or Tertiary Toolkit Area .","Within each Toolkit Area , , and  are corresponding sub-areas, Toolkit-Level Control Elements , , and  respectively, which are shown in the figure abbreviated as Toolkit Controls  and  when part of the smaller Secondary and Tertiary Toolkit Areas  and . Toolkit Controls areas , , and  respectively allocate space to present buttons, tabs, and menus associated with the Toolkit , , or  displayed in each Toolkit Area , , and . To the extent that such controls are different for each Toolkit , , or , the corresponding Toolkit Controls areas , , and  will display different buttons, tabs, and menus.","On the left side of the screen presented by GUI , Palette Area  allocates space to present the various Palettes , , , , , , , , and  found in Design Toolkits  and , as well as any that may be added throughout the life of Application Factory System . To the extent that buttons, tabs, or menus may be desired for manipulating a particular Palette or the Palettes in general, a Palette Controls area  is allocated within Palette Area . In addition, a Palette Selector Area  is provided for buttons, tabs, menus, or other means for selecting exactly which Palette's items should be displayed at any particular moment. However, the bulk of the space in Palette Area  will be occupied by icons representing the various items available from the selected Palette , , , , , , , , or , or other Palette as many be added from time to time during the life of Application Factory System .","It may be noticed that the graphic forms of Palette items and control elements are left unspecified here. In the present invention, various graphic forms may be provided according to the preferences of particular developers, with defaults chosen by the proprietor of Application Factory System . In a preferred embodiment, graphic forms are dependent upon the programming mode or level in which a particular developer is comfortable, and may take on the appearance of corresponding items in Scratch, Alice, Mindstorms, LabView, VPL, or other unrelated domains according to the visual representation of the programming mode or level. As developer feedback drives tuning of the visual representation, these specific graphic forms may evolve over the life of Application Factory System . The specific graphic forms may also be instantiated differently by different proprietors of different instances of Application Factory System . For these reasons, the specific graphic forms of Palette items and control elements are considered peripheral to the present invention, and the present invention is intended to enable the use of, as well as to incorporate, any and all possible configurations of such graphic forms.","The GUI  described here is an example. As is well known to those skilled in the art, multiple graphical forms may be used to accomplish the same ends and provide user access to the same set of functionality. Therefore, GUI  as shown here represents a preferred embodiment that enables execution of the present invention, and may at this writing be considered the best mode, yet multiple alternate embodiments are possible within, anticipated by, and not precluded by the present invention. Other examples may omit the Swap Buttons  and , and lock each Toolkit ,  and  into specific Toolkit Areas , , and ; allocate spaces to each Toolkit Area , , and  that have different sizes or different aspect ratios from those shown, including allocating the same sized space to each; allocate only one or two Toolkit Area spaces and provide other means than those previously described for selecting which Toolkits are displayed when, such as tabs; place the Toolkit Control areas , , and  in sections of their corresponding Toolkit Areas , , and  other than at the top; place the Palette Area  and Palette Selector Area  on the right, across the top, or across the bottom of the screen instead of on the left; or any of numerous other possibilities.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 7","FIG. 1","FIG. 1","FIG. 1"],"b":["100","110","100","165","175","185","160","170","180","195","181","191"]},"Server Farm  and Computers , , and  used by developers and customers are all connected via high data rate Network Access Links , , , and , respectively, to the Internet , as is typical in distributed systems today and well understood by those skilled in the art. Internet  is in turn connected to Cellular Data Network , via high data rate Peer Network Link , so that Mobile Devices  and , attached to Cellular Data Network  via Cellular Data Access Links  and  respectively, may also reach Server Farm  and the services of Application Factory System . Multiple technologies are available for use in implementing Access Links , , , , , and , and are well known to those skilled in the art. As will also be readily evident to those skilled in the art, myriad additional developer and customer computers similar to Computers , , and , as well as multiple additional cellular data networks similar to Cellular Data Network , may be connected to Internet . Further, myriad additional mobile devices similar to Mobile Devices  and  may be connected to Cellular Data Network  and other cellular data networks like it. These extensions enable scaling of the present invention to encompass every possible developer, customer, and mobile device in the world.","In a preferred embodiment, Server Farm  consists of multiple copies of a replicable Server Rack , each containing multiple management, computing, data storage, and interconnection resources. Server Rack  is divided into several major equipment groups for the purpose of this description, but may be implemented using other layouts and physical resource proportions according to the specific needs of a particular Application Factory System  proprietor, as will be readily evident to one skilled in the art.","Starting at the bottom of the view depicting Server Rack , External Connectivity Equipment Group  incorporates common network routing and switching gear that provides, as the name implies, high data rate Internet Protocol connectivity to other instances of Server Rack  within Server Farm  and to networks outside Server Farm . In a preferred embodiment, External Connectivity Equipment Group  is implemented using off the shelf components well known to those skilled in the art, including high capacity redundant router-switches supporting so-called 10 Gigabit Ethernet links.","Next up the stack in Server Rack  is a Computing Shelf , which provides multiple slots for high-performance Computer Blades  that may be added according to capacity requirements, along with a pair of slots for redundant Shelf Connectivity Switches  that provide 10 Gigabit Ethernet links among the Blades  in Shelf  and similar links to other equipment groups within Server Rack . Shelf  also includes, without limitation, a Shelf Management Controller  that provides health and status, problem detection and recovery, and other related functionality. The figure depicts but one of multiple possible form factors for Shelf  and its subcomponents, which are preferably implemented using off the shelf components well known to those skilled in the art. Server Rack  may incorporate, as shown in the figure, a second Computing Shelf , along with its corresponding Computer Blades , Shelf Connectivity Switches , and Shelf Management Controller , if required for capacity.","In the middle of Server Rack  as shown, although not necessarily required to be in that position, is Data Storage Equipment Group , which comprises a scalable number of high-volume data storage resources such as multi-terabyte hard disk drives or multi-gigabyte solid-state drives that may be replicated according to capacity requirements. Here again, Data Storage Equipment Group  is implemented in a preferred embodiment using off the shelf components well known to those skilled in the art, and interconnected internally to the other equipment groups within Server Rack  using multiple 10 Gigabit Ethernet links.","Server Farm  then comprises a number of Server Racks  arranged as shown and as described here. In a preferred embodiment, each of the major functions of Application Factory System  is assigned to run in one or more Server Racks . Composition Studio  executes and keeps its data in Composition Studio Server ; Distribution Center  executes and keeps its data in Distribution Center Server ; Build Engine  executes and keeps its data in Build Engine Servers and interconnected by one or more 10 Gigabit Ethernet links shown as Intraconnect ; and Verification Engine  executes and keeps its data in Verification Engine Servers and interconnected by one or more 10 Gigabit Ethernet links shown as Intraconnect . All the dedicated-function Server Racks  in Server Farm  are pairwise interconnected in a redundant fully-connected mesh network by Interconnects , each of which is implemented as one or more 10 Gigabit Ethernet links. Finally, Composition Studio Server  and Distribution Center Server , being hosts for front-end services Composition Studio  and Distribution Center , provide the endpoints within Server Farm  for connections to Internet  via high data rate Network Access Links . Note that each is shown with its own Links , and each is provided with redundant Links , so that no single route failure takes the Server Farm  and consequently Application Factory System  out of service.","In an alternate embodiment, the various functional subsystems or Application Factory System  are not assigned to dedicated Server Racks  within Server Farm , but instead are allocated to computation and data storage resources dynamically according to transaction traffic. The fully-connected mesh network of multiple 10 Gigabit Ethernet links is retained in this alternate embodiment, and Network Access Links  may be terminated on any or all Server Racks . In any case, the specific arrangement of servers and interconnects is subject to site engineering, using practices well known to those skilled in the art, according to the capacity requirements of Application Factory System .","The invention has been described above with reference to preferred embodiments. It is not intended that the invention be limited to the specific embodiments shown and described, but that the invention be limited in scope only by the claims appended hereto. It will be evident to those skilled in the art that various substitutions, modifications, and extensions may be made to the embodiments as well as to various technologies which are utilized in the embodiments. It will also be appreciated by those skilled in the art that such substitutions, modifications, and extensions fall within the spirit and scope of the invention, and it is intended that the invention as set forth in the claims appended hereto includes all such substitutions, modifications, and extensions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be better understood from a reading of the following detailed description in conjunction with the drawing figures, in which like reference designators are used to identify like elements and in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
