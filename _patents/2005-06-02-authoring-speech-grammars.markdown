---
title: Authoring speech grammars
abstract: A method and apparatus are provided for automatically forming a grammar. Example text strings are received and N-grams are formed based on the text strings. A rule in the grammar is then generated automatically based in part on the n-grams.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07617093&OS=07617093&RS=07617093
owner: Microsoft Corporation
number: 07617093
owner_city: Redmond
owner_country: US
publication_date: 20050602
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["In speech recognition, a speech signal is converted into a text string and in some systems a set of semantic tags that correspond to the semantic meaning of portions of the text string. To improve recognition accuracy, it is common to limit the recognizer to finding text strings that have been defined in a grammar.","An example of such a grammar is a context free grammar (CFG). In context free grammars, possible text sequences are defined as rules, where one rule may reference another rule. For example, the rule for setting up a meeting could be defined as \u201cset up a meeting on <ruleref name=\u201cdate\u201d>\u201d, where <ruleref name=\u201cdate\u201d> is a reference to a date rule that defines text strings that can represent a date.","While a CFG provides a straightforward structure for a grammar, it is difficult to construct an efficient CFG that provides high recognition accuracy. One reason for this is that in order to match a rule, the user must speak at least one of the word sequences anticipated by the author of the rule. To overcome this limitation, grammars have been developed that convert a context free grammar into an N-gram language model. The N-gram language model is constructed by identifying sequences of N words and\/or rule references in the CFG and constructing a probability of each N-gram. Backoff probabilities for bigrams and unigrams can then be determined. Such grammars are often referred to as unified grammars and have the advantage that the user does not need to provide speech that exactly matches the sentences anticipated by the developer. Even if the user's speech includes words in a different order or omits certain words, the unified grammar can still provide a match.","Unified grammars are difficult for application developers to design. They require a large amount of knowledge in order to construct them well. In particular, the application developer must learn the scripting tags of the grammar format, understand how their construction of the CFG affects the ability of a unified grammar to identify speech, how to compute the backoff weights and how the grammar will interact with existing library grammars. This extra required knowledge represents a barrier to implementing speech recognition in everyday applications.","A method and apparatus are provided for automatically forming a grammar. Example text strings are received and n-grams are formed based on the text strings. A rule in the grammar is then generated automatically based in part on the n-grams.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":["100","100","100","100"]},"Embodiments of the invention are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well-known computing systems, environments, and\/or configurations that may be suitable for use with embodiments of the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, telephony systems, distributed computing environments that include any of the above systems or devices, and the like.","Embodiments of the invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Embodiments of the invention are designed to be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules are located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing embodiments of the invention includes a general-purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies.","A user may enter commands and information into the computer  through input devices such as a keyboard , a microphone , and a pointing device , such as a mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  is operated in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a hand-held device, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["200","200","202","204","206","208","210"]},"Memory  is implemented as non-volatile electronic memory such as random access memory (RAM) with a battery back-up module (not shown) such that information stored in memory  is not lost when the general power to mobile device  is shut down. A portion of memory  is preferably allocated as addressable memory for program execution, while another portion of memory  is preferably used for storage, such as to simulate storage on a disk drive.","Memory  includes an operating system , application programs  as well as an object store . During operation, operating system  is preferably executed by processor  from memory . Operating system , in one preferred embodiment, is a WINDOWS\u00ae CE brand operating system commercially available from Microsoft Corporation. Operating system  is preferably designed for mobile devices, and implements database features that can be utilized by applications  through a set of exposed application programming interfaces and methods. The objects in object store  are maintained by applications  and operating system , at least partially in response to calls to the exposed application programming interfaces and methods.","Communication interface  represents numerous devices and technologies that allow mobile device  to send and receive information. The devices include wired and wireless modems, satellite receivers and broadcast tuners to name a few. Mobile device  can also be directly connected to a computer to exchange data therewith. In such cases, communication interface  can be an infrared transceiver or a serial or parallel communication connection, all of which are capable of transmitting streaming information.","Input\/output components  include a variety of input devices such as a touch-sensitive screen, buttons, rollers, and a microphone as well as ea variety of output devices including an audio generator, a vibrating device, and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition, other input\/output devices may be attached to or found with mobile device  within the scope of the present invention.","Embodiments of the present invention provides a user interface  and an application programming interface (API)  that enable speech grammars  to be constructed automatically based on information provided by an application developer . API  provides an interface that includes an AddSynonym method , AddSemanticVariable method , ProcessSentence method  and Output method .","AddSynonym method  allows developer  to associate a word or a string of words with a semantic class. Multiple words or strings of words may be associated with the same semantic class by using separate calls to AddSynonym method .","Under one embodiment, a call to AddSynonym method  is made with the following arguments:","AddSynonym (string synonym, string Semantic_Class, double weight, bool isIndicator) where \u201csynonym\u201d is the word or word string to be assigned to the semantic class, \u201cSemantic_Class\u201d is the semantic class, \u201cweight\u201d is a relative weight that should be assigned to the word within the semantic class, and \u201cisIndicator\u201d indicates whether the semantic class acts as an indicator for other semantic classes. An indicator class is a semantic class that further defines the semantic class that follows it. For example, a class of \u201csource\u201d can be an indicator class that indicates the type of a \u201ccity\u201d class that follows it. Thus, in the sentence \u201cI want to fly from Seattle\u201d, the word \u201cfrom\u201d can be a member of the \u201csource\u201d class which is an indicator for the word \u201cSeattle\u201d which is a member of the \u201ccity\u201d class. Thus, using the indicator, \u201cSeattle\u201d is defined as a \u201csource city\u201d.","The AddSemanticVariable method allows the developer to specify how semantic variables are used, which can improve the construction of the underlying grammar. In the method call, the developer specifies the following:","AddSemanticVariable(string Main_Semantic_Class, string Indicator_Semantic_Class, bool is Active)","where Main_Semantic_Class indicates a semantic class for the current grammar or a reference to a semantic class stored in an external grammar such as external grammars . The reference to an external grammar will include the name of the external grammar and the name of the rule for the semantic class in the external grammar. The Indicator_Semantic_Class indicates a second semantic class that is combined with the main semantic class to form a hybrid class when the indicator semantic class is found next to and before the main semantic class. For example, if \u201cCity\u201d is a main semantic class and \u201cgoal\u201d is an indicator semantic class, when the \u201cgoal\u201d semantic class precedes the \u201ccity\u201d semantic class, the two semantic classes will be combined to form a single \u201cgoal city\u201d semantic class. The \u201cis Active\u201d value indicates whether this hybrid class should be used instead of the main semantic class when the main semantic class appears without an indicator class next to it.","ProcessSentence method  allows the developer to provide example sentences that are expected to be received from the user. Each call to the method is made as follows:","ProcessSentence(string sentence, double weight)","where \u201csentence\u201d is one or more words and \u201cweight\u201d indicates the likelihood of the sentence occurring.","Output method  allows the developer to designate an output file and output format for the grammar. The method call is made as:","Output(string filename, string grammarType)","where \u201cfilename\u201d is the name and path of the file that will contain the grammar, and \u201cgrammarType\u201d is the output format for the grammar such as SAPI5.0, SAPI6.0, and GRXML. Calling this method causes API  to produce grammar  based on the sentences and semantic classes that were received through the AddSynonym, AddSemanticVariable and ProcessSentence methods.","The methods of API  may be called directly by developer  or indirectly using user interface (UI) .  provides a screen shot of one embodiment of a user interface under the present invention.","In , two dialog boxes  and  are provided in an application window . Dialog box  includes system question box  and response box . The developer inserts the question that is to be posed by the system during the dialog turn associated with dialog box  in system question box . The developer then lists possible responses that the user may provide in response box . Main semantic class pull-down box  and indicator semantic class pull-down box  are also provided in dialog box . The developer sets values in these boxes to indicate a default semantic class or hybrid semantic class that the responses in response box  should be associated with if no other semantic class can be associated with the input. For example, in box , the responses by the user will default to being associated with the hybrid semantic class \u201cGoal_City\u201d.","Similarly, dialog box  includes system question box , response box , main semantic class pull-down box  and indicator semantic class pull-down box .","Generate buttons  and  of dialog boxes  and , respectively, cause the respective sentence lists in the dialog boxes to be submitted through the use of the ProcessSentence method, where each sentence is submitted with a separate ProcessSentence method call.","The interface of  also includes three semantic class definition boxes ,  and . Each semantic class box includes a semantic class name box and a terminal list box. For example, semantic class box  includes semantic class name box  and terminal list box . The developer places the name of the semantic class in semantic class name box  and lists the strings that are to be associated with that semantic class in terminal list box . Thus, the strings Boston, Seattle, New York and Denver are the terminal nodes for the semantic class CITY.","The user interface of  also includes a generate button  that executes code when the button is activated to cause the grammar to be generated based on the sentences and semantic information provided through the user interface. This is performed by using the Output method of API  to generate grammar . User interface  then issues a command to speech recognition engine  to load grammar  into recognition engine  for speech recognition.","Speech recognition engine  uses the loaded grammar to decode speech signals  into text and semantic classes  by converting the speech signal into feature vectors and applying the feature vectors to acoustic models of the words in the grammar. The words and semantic classes along the most likely path through the rules defined in the grammar are returned as text and semantic classes . As those skilled in the art will recognize, speech recognition engine  will often compile the grammar into a binary format when it is loaded.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 4","FIG. 3"],"b":["302","402","302","330","308","334","332","310","336","312"]},"At step  of , output method  selects one of the sentences from sentences  and at step  selects a grouping of words from the sentence. At step , the selected grouping is applied to each of the grammar classes, including external grammar classes, that were listed using the AddSynonym method. Applying a grouping involves determining if the grouping exactly matches one of the text strings that are listed for the semantic class. If a grammar class is found that has a text string that exactly matches the grouping, the grammar class and the span of the grouping are stored.","At step , the method determines if there are other groupings of words that can be formed for the sentence. If there is another grouping of words that can be formed, the next grouping of words is selected at step  and this grouping is then applied to each of the grammar classes to identifying semantic classes that match the grouping. Steps ,  and  are repeated until every possible grouping of contiguous words in the sentence, including individual words, has been applied against the grammar classes.","After there are no more groupings at step , the process continues at step  where the minimum number of classes that span as many words as possible is selected. Thus, different combinations of classes are examined to find the combination of classes that spans as many words as possible in the sentence. If more than one combination of classes spans the same number of words, the set of classes that has the minimum number of classes is selected.","At step , if there are more sentences in sentences , the next sentence is selected at step  and steps , ,  and  are repeated for the new sentence.","When all of the sentences in sentences  have been processed, the method continues at step  where tags for the classes are used in place of the words that the classes span in each of the sentences to form modified sentences. For example, the sentence \u201cFlight to Seattle\u201d would become \u201cFlight to <City>\u201d. An N-gram backbone is then produced by grouping the class tags and words that were not replaced by class tags into n-grams of various orders (unigrams, bigrams, etc. up to N-grams), where the order of an n-gram is the number of words n in the n-gram. For example, the sentence \u201cI want to fly to Boston\u201d where Boston is in the semantic class <City> results in the identification of unigrams \u201cI\u201d, \u201cwant\u201d, \u201cto\u201d, \u201cfly\u201d, \u201c<City>\u201d, bigrams \u201cI want\u201d, \u201cwant to\u201d, \u201cto fly\u201d, \u201cfly to\u201d, \u201cto <City>\u201d, and trigrams \u201cI want to\u201d, \u201cwant to fly\u201d, \u201cto fly to\u201d, \u201cfly to <City>\u201d. In addition, words and classes that can start a sentence or end a sentence are identified.","For each specific n-gram, such as the bigram \u201cfly to\u201d or the trigram \u201cwant to fly\u201d, a probability is calculated by counting the number of times the n-gram appears in the sentences and dividing that count by the number of times that the history portion of the n-gram appears in the sentences, where the history portion consists of the first n\u22121 words or classes of the n-gram. In addition, backoff probabilities are calculated by smoothing the n-gram probabilities to provide at least some probability for unseen n-grams. Such smoothing techniques are well known in the art and can include Katz smoothing or Good-Turing smoothing.","For each semantic class, the probability of each word string associated with the class is determined from the sentences. In one particular embodiment, the probability is determined by dividing the number of times the word string appears in the sentences by the number of times any word string in the class appears in the sentences.","At step , the N-gram backbone and the probabilities are used to generate grammar rules in the chosen grammar format set through the Output method.  provides a flow diagram of one method for generating the output grammar from the N-gram backbone and the probabilities. The method of  is discussed below with reference to an example output grammar shown below. The example grammar was constructed for the sentences:","\u201cI want to fly to Boston\u201d","\u201cSeattle\u201d","\u201cDenver please\u201d","\u201cplease book a ticket from Boston to Seattle\u201d","where Seattle, Boston, and Denver are members of the class <CLASSDEF_CITY>.","The grammar is written in SAPI6.0 format and has a set of outer <Grammar> tags that define the grammar and provide an identifier for the grammar. Each rule of the grammar is defined between <Rule> tags that have a Name attribute that identifies the rule. <List> tags are used to designate sets of alternative paths through the rule, with each path being defined between <P> tags. Each path has an associated weight attribute that indicates the probability of following the path given the rule. Within a path, other rules are referenced using a <Ruleref> tag with the NAME attribute set to the name of the rule. Sequences of individual words or <Ruleref> tags form the paths within the path <P> tags.","In step  of , a top level rule is generated that represents the possible beginning of a sentence. An example of such a top level rule is shown below as \u201cSENTENCE_TOP_NODE\u201d rule. The rule is designated as being the top level rule by setting the TOPLEVEL attribute to ACTIVE. The top level rule consists of a list of unigrams that were observed at the beginning of the sentence and a backoff option for any unigram in the sentences. The backoff option is given a small probability and the remaining probability is divided among the observed unigrams based on the number of times each unigram appears at the start of a sentence. For example, in the rule \u201cSENTENCE_TOP_NODE\u201d below, 0.0005 of the probability mass has been assigned to the backoff. The remaining 0.9995 has been divided among the unigrams for \u201cI\u201d, \u201cCLASSDEF_CITY\u201d, and \u201cplease\u201d. Since \u201cCLASSDEF_CITY\u201d appears at the beginning of two sentences and \u201cI\u201d and \u201cplease\u201d each appear at the beginning of one sentence, the 0.9995 probability mass is divided into four parts, with one part (0.2498) being assigned to \u201cI\u201d, one part (0.2498) being assigned to \u201cplease\u201d and two parts (0.4996) being assigned to \u201cCLASSDEF_CITY\u201d.","At step , leaf node rules are written for each class and each word that is not assigned to a class. A leaf rule for a class lists all of the text strings that were assigned to the class using the AddSynonym method. Each string is placed within separate <p> tags and assigned a weight that is determined by dividing the number of times the text string appeared in the sentences by the number of times any text string of the class appeared in the sentences. Leaf rules for words, contain the text string for the word with a weight of 1.000.","At step , a generic rule to cover all unigrams and generic rules for n-grams (bigrams to N-grams) are constructed. The generic rule for the unigrams provides a list of all possible unigrams, with each unigram receiving a weight that is equal to the probability of the word or class appearing in the sentences. The generic rules for the n-grams consists of a separate rule for each n\u22121 history portion of each n-gram. For example, for the bigrams \u201cto fly\u201d and \u201cto Boston\u201d, a generic bigram rule is created as \u201cTo_Bigram\u201d for the history \u201cto\u201d. Each generic rule for the n-grams provides a list of specific n-grams of the same order with the same n\u22121 history in the sentences and a backoff to all unigrams. The probability of specific n-grams is determined by dividing the non-backoff probability among the specific n-grams according to how often each specific n-gram is observed in the sentences. Examples of generic bigrams can be found below in rules such as \u201cI_BIGRAMS\u201d and \u201cWANT_BIGRAMS\u201d. Examples of generic trigrams can be found below in rules such as \u201cI_WANT_TRIGRAMS\u201d and \u201cBOOK_A_TRIGRAMS\u201d.","At step , one of the observed n-grams (unigram to N-gram) is selected. At step , the n-gram's position in the sentences is examined to determine if it ever ends a sentence. If it does not end a sentence, a rule is generated for the specific n-gram at step . In the rule, an entry is provided that references the last word or class of the n-gram followed by a generic extension of the n-gram. For n-grams less than order N, the generic extension is an n+1 extension. For example, in the grammar below, rule \u201cWANT_TO\u201d was generated for the specific bigram \u201cwant to\u201d. In the rule, a path is defined that includes a reference to the leaf rule for \u201cto\u201d by a reference to the generic trigram \u201cWANT_TO_TRIGRAMS\u201d. For N-grams, the extension is of order N. Thus, a specific trigram will include an entry consisting of a reference to the leaf of the last word or class in the N-gram followed by a reference to a generic N-gram that starts with the last N\u22121 words or classes of the current N-gram.","The rule constructed at step  also includes a backoff entry for the last word or class of the n-gram occurring at the end of the utterance. This backoff entry is given a low probability and is written as a reference to the leaf rule of the last word or class of the n-gram.","If the selected n-gram does appear at the end of at least one sentence, the process continues at step  where the n-gram's positions are examined to determine if it ever occurs in a position other than at the end of a sentence. If it does not appear at a position other than the end of a sentence, the process generates a rule for the n-gram at step . The rule generated at step  includes a termination entry that references the leaf rule for the last word or class in the n-gram and a low probability backoff entry that references the leaf rule of for the last word of the n-gram followed by a reference to the generic unigram rule. For n-grams of greater order than a unigram, the backoff entry can instead take the form of a reference to the unigram rule for the last word of the n-gram.","If the selected n-gram appears at both the end of a sentence and a position other than the end of a sentence, the process generates a rule for the n-gram at step . The rule generated at step  includes a backoff entry that includes a reference to the leaf rule of the last word or class in the n-gram followed by a reference to the generic unigram rule. The probability that is not assigned to the backoff probability is split between an entry for the n-gram being in the last position of the sentence and an entry for a generic extension of n-gram. The entry for the last position in a sentence includes a reference to the leaf rule of the last word or class of the n-gram. The entry for the generic extension is similar to the generic extensions discussed above for step . The non-backoff probability is divided between the entry for n-gram ending an utterance and the entry for the generic extension by counting how often the n-gram ends a sentence and dividing the count by the number of times the n-gram is observed.","After a rule has been constructed for the selected n-gram at step ,  or , the process continues at step  where it determines if there are more n-grams in the N-gram backbone to be processed. If there are more n-grams, the next n-gram gram is selected by returning to step . Steps , , , , , , and  are repeated until all of the n-grams have had rules constructed for them. The process then ends at step .","Example Grammar",{"@attributes":{"id":"p-0066","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["<GRAMMAR LANGID=\u201c409\u201d>\n    \n    ","<!---Leaf Rules>\n    \n    ","<!---Unigram rules--->\n    \n    ","<!--Bigram Rules>\n    \n    ","<!--Trigram Rules>\n    \n    ","<\/GRAMMAR>"]}},"Although the present invention has been described with reference to particular embodiments, workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
