---
title: Stack-based access control using code and executor identifiers
abstract: A system regulates access to resources requested by an operation executing on a computer. The operation invokes a plurality of methods that operate upon code during execution. The system includes a policy file, a call stack, and an execution unit. The policy file stores permissions for each of the resources. The permissions authorize particular types of access to the resource based on a source of the code and an executor of the code. The call stack stores representations of the methods and executors in an order of invocation by the operation. The execution unit grants access to the resource when the types of access authorized by the permissions of all of the methods and executors on the call stack encompass the access requested by the operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06934758&OS=06934758&RS=06934758
owner: Sun Microsystems, Inc.
number: 06934758
owner_city: Santa Clara
owner_country: US
publication_date: 20020513
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Overview of the Distributed System","Functional Overview","Trusted and Untrusted Sources","Trusted and Untrusted Executors","Exemplary Security Mechanism","Protection Domains and Permissions","Policies","Implied Permissions","Policy Implementing Objects","Exemplary Call Stack","Method\/Permission Relationships","Exemplary Access Controller","Determining Whether an Action is Authorized","Privileged Methods","Enabling Invocations","Conclusion"],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/537,746, filed Mar. 30, 2000, now U.S. Pat. No. 6,389,540, which is a continuation of U.S. patent application Ser. No. 09\/044,915, filed Mar. 20, 1998, now U.S. Pat. No. 6,138,238, which is a continuation-in-part of U.S. patent application Ser. No. 08\/988,431, filed Dec. 11, 1997, now U.S. Pat. No. 6,192,476, and also claims the benefit of U.S. Provisional Application No. 60\/076,048, filed Feb. 26, 1998, all of which are incorporated herein by reference.","U.S. patent application entitled \u201cLayer-Independent Security for Communication Channels,\u201d filed on Jun. 26, 1997, and accorded Ser. No. 08\/883,636.","Provisional U.S. patent application Ser. No. 60\/076,048, entitled \u201cDistributed Computing System\u201d filed on Feb. 26, 1998.","U.S. patent application Ser. No. 09\/044,923, entitled \u201cMethod and System for Leasing Storage,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 08\/044,838, entitled \u201cMethod, Apparatus, and Product for Leasing of Delegation Certificates in a Distributed System,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,834, entitled \u201cMethod, Apparatus and Product for Leasing of Group Membership in a Distributed System,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,916, entitled \u201cLeasing for Failure Detection,\u201d bearing attorney docket no. 06502.0011-04000, and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,933, entitled \u201cMethod for Transporting Behavior in Event Based System,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,919, entitled \u201cDeferred Reconstruction of Objects and Remote Loading for Event Notification in a Distributed System,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,938, entitled \u201cMethods and Apparatus for Remote Method Invocation,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,652, entitled \u201cMethod and System for Deterministic Hashes to Identify Remote Methods,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,790, entitled \u201cMethod and Apparatus for Determining Status of Remote Objects in a Distributed System,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,930, entitled \u201cDownloadable Smart Proxies for Performing Processing Associated with a Remote Procedure Call in a Distributed System\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,917, entitled \u201cSuspension and Continuation of Remote Methods,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,835, entitled \u201cMethod and System for Multi-Entry and Multi-Template Matching in a Database,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,839, entitled \u201cMethod and System for In-Place Modifications in a Database,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,945, entitled \u201cMethod and System for Typesafe Attribute Matching in a Database,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,931, entitled \u201cDynamic Lookup Service in a Distributed System,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,939, entitled \u201cApparatus and Method for Providing Downloadable Code for Use in Communicating with a Device in a Distributed System.\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,826, entitled \u201cMethod and System for Facilitating Access to a Lookup Service,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,932, entitled \u201cApparatus and Method for Dynamically Verifying Information in a Distributed System,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/030,840, entitled \u201cMethod and Apparatus for Dynamic Distributed Computing Over a Network\u201d and filed on Feb. 26, 1998.","U.S. patent application Ser. No. 09\/044,936, entitled \u201cAn Interactive Design Tool for Persistent Shared Memory Spaces\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,934, entitled \u201cPolymorphic Token-Based Control,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,944, entitled \u201cStack-Based Security Requirements,\u201d and filed on the same date herewith.","U.S. patent application Ser. No. 09\/044,837, entitled \u201cPer-Method Designation of Security Requirements,\u201d and filed on the same date herewith.","The present invention is directed to security measures in a computer system and, more particularly, to systems and methods that control access to a resource based on the source of the code and the identity of the principal on whose behalf the code is being executed.","As the use of computer systems grows, organizations are becoming increasingly reliant upon them. A malfunction in the computer system can severely hamper the operation of such organizations. Thus, organizations that use computer systems are vulnerable to users who may intentionally or unintentionally cause the computer system to malfunction.","One way to compromise the security of a computer system is to cause the computer system to execute software that performs harmful actions on the computer.system. There are various types of security measures that may be used to prevent a computer system from executing harmful software. One example is to check all software executed by the computer system with a \u201cvirus\u201d checker. However, virus checkers only search for very specific software instructions. Therefore, many software-tampering mechanisms go undetected by a virus checker.","Another very common measure used to prevent the execution of software that tampers with a computer's resources is the \u201ctrusted developers approach.\u201d According to the trusted developers approach, system administrators limit the software that a computer system can access to only software developed by trusted software developers. Such trusted developers may include, for example, well known vendors or in-house developers.","Fundamental to the trusted developers approach is the idea that computer programs are created by developers, and that some developers can be trusted to produce software that does not compromise security. Also fundamental to the trusted developers approach is the notion that a computer system executes only programs that are stored at locations that are under control of the system administrators.","Recently developed methods of running applications involve the automatic and immediate execution of software code loaded from remote sources over a network. When the network includes remote sources that are outside the control of system administrators, the trusted developers approach does not work.","One conventional attempt to adapt the trusted developers approach to systems that can execute code from remote sources is referred to as the trusted source approach. An important concept of the trusted source approach is the notion that the location from which a program is received (i.e., the \u201csource\u201d of the program) identifies the developer of the program. Consequently, the source of the program may be used to determine whether the program is from a trusted developer. If the source is associated with a trusted developer, then the source is considered to be a \u201ctrusted source\u201d and execution of the code is allowed.","One implementation of the trusted source approach is referred to as the sand box method. The sand box method allows all code to be executed, but places restrictions on remote code. Specifically, the sand box method permits all trusted code full access to a computer system's resources and all remote code limited access to the resources. Trusted code is usually stored locally on the computer system under the direct control of the owners or administrators of the computer system, who are accountable for the security of the trusted code.","One drawback of the sand box approach is that the approach is not very flexible because it restricts access by remote code to the same limited set of resources. Conflicts can then arise when remote code from several sources attempt to access the same resources. As a result, conventional systems often limit access by remote code from one source to one set of computer resources, while limiting access by remote code from another source to a different set of computer resources. For example, a system may limit access by remote code loaded over a network from a source associated with a first computer to one set of files, and similarly limit access by remote code loaded over the network from a source associated with a second computer to another set of files.","Providing security measures that allow more flexibility than the sand box method involves establishing a complex set of relationships between principals and permissions. A \u201cprincipal\u201d is an entity in the computer system to which permissions are granted. Examples of principals include users, organizations, processes, objects, and threads. A \u201cpermission\u201d is an authorization by the computer system that allows a principal to perform a particular action or function.","The task of assigning permissions to principals is complicated by the fact that sophisticated processes may involve the interaction of code from multiple sources. For example, code from a trusted first source being executed by a principal (e.g., a thread) may cause the execution of code from a trusted second source, and then cause execution of code from an untrusted third source.","Even though the principal remains the same when the code from the trusted second source and code from the untrusted third source are executed, the access privileges appropriate for the principal when code from the trusted second source is executed likely differ from access privileges appropriate for the principal when the code from the untrusted third source is being executed. Thus, access privileges appropriate for a principal may change dynamically as the source of the code being executed by the principal changes.","Access privileges may also change dynamically as the principal on whose behalf the code is being executed changes. Sometimes one principal executes code on behalf of another principal. For example, when a principal on one computer requests access to a resource on a remote computer, the request causes a \u201cremote\u201d principal to be invoked on the remote computer to handle the request. Handling of the request by the remote principal may involve the execution of code from trusted and untrusted sources. In these situations, conventional systems continue to base code access privileges on the source of the code without regard to the principal on whose behalf the code is executed. By failing to consider the principal on whose behalf the code is being executed, conventional systems ignore a possible breach in security.","Based on the foregoing, it is clearly desirable to develop a security mechanism that determines the appropriate code access privileges.","Systems and methods consistent with the principles of the present invention address this need by determining access control to code based on the source of the code and the principal on whose behalf the code is being executed. By regulating code access based on either or both of these factors, the security in computer systems can be enhanced.","A system consistent with the principles of the present invention regulates access to resources requested by an operation executing on a computer. The operation invokes a plurality of methods that operate upon code during execution. The system includes a policy file, a call stack, and an execution unit. The policy file stores permissions for the resource. The permissions authorize particular types of access to the resource based on a source of the code and an executor of the code. The call stack stores representations of the methods and executors in an order of invocation by the operation. The execution unit grants access to the resource when the types of access authorized by the permissions of all of the methods and executors on the call stack encompass the access requested by the operation.","The following detailed description of the invention refers to the accompanying drawings. The same reference numbers in different drawings identify the same or similar elements. Also, the following detailed description does not limit the invention. Instead, the scope of the invention is defined by the appended claims.","Systems and methods consistent with the principles of the present invention increase security by providing flexible designation of access privileges to code. The systems and methods not only base the access privileges on the source of the code (i.e., whether the code is trusted or untrusted), but also on the identity of the principal on whose behalf the code is being executed (i.e., whether the principal requesting the code execution is trusted or untrusted).","Methods and systems consistent with the present invention operate in a distributed system (\u201cthe exemplary distributed system\u201d) with various components, including both hardware and software. The exemplary distributed system (1) allows users of the system to share services and resources over a network of many devices; (2) provides programmers with tools and programming patterns that allow development of robust, secured distributed systems; and (3) simplifies the task of administering the distributed system. To accomplish these goals, the exemplary distributed system utilizes the Java\u2122 programming environment to allow both code and data to be moved from device to device in a seamless manner. Accordingly, the exemplary distributed system is layered on top of the Java programming environment and exploits the characteristics of this environment, including the security offered by it and the strong typing provided by it. The Java programming environment is more clearly described in Jaworski, 1.1 , Sams.net, 1997, which is incorporated herein by reference.","In the exemplary distributed system, different computers and devices are federated into what appears to the user to be a single system. By appearing as a single system, the exemplary distributed system provides the simplicity of access and the power of sharing that can be provided by a single system without giving up the flexibility and personalized response of a personal computer or workstation. The exemplary distributed system may contain thousands of devices operated by users who are geographically disperse, but who agree on basic notions of trust, administration, and policy.","Within the exemplary distributed system are various logical groupings of services provided by one or more devices, and each such logical grouping is known as a Djinn. A \u201cservice\u201d refers to a resource, data, or functionality that can be accessed by a user, program, device, or another service and that can be computational, storage related, communication related, or related to providing access to another user. Examples of services provided as part of a Djinn include devices, such as printers, displays, and disks; software, such as applications or utilities; information, such as databases and files; and users of the system.","Both users and devices may join a Djinn. When joining a Djinn, the user or device adds zero or more services to the Djinn and may access, subject to security constraints, any one of the services it contains. Thus, devices and users federate into a Djinn to share access to its services. The services of the Djinn appear programmatically as objects of the Java programming environment, which may include other objects, software components written in different programming languages, or hardware devices. A service has an interface defining the operations that can be requested of that service, and the type of the service determines the interfaces that make up that service.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 1","b":["1000","1100","1200","1300","1400","1100","1200","1100","1200"]},"The device  may be any of a number of devices, such as a printer, fax machine, storage device, computer, or other devices. The network  may be a local area network, wide area network, or the Internet. Although only two computers and one device are depicted as comprising the exemplary distributed system , one skilled in the art will appreciate that the exemplary distributed system  may include additional computers or devices.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 2","b":["1100","1000","1200","1300","1100","2100","2200","2300","2400","2500","2100","2110","2120","2130","2130","2140","2150","2200","2210"]},"As mentioned above, the exemplary distributed system  is based on the Java programming environment and thus makes use of the Java runtime system . The Java runtime system  includes the Java\u2122 application programming interface (API), allowing programs running on top of the Java runtime system to access, in a platform-independent manner, various system functions, including windowing capabilities and networking capabilities of the host operating system. Since the Java API provides a single common API across all operating systems to which the Java runtime system  is ported, the programs running on top of a Java runtime system run in a platform-independent manner, regardless of the operating system or hardware configuration of the host platform. The Java runtime system  is provided as part of the Java\u2122 software development kit available from Sun Microsystems of Mountain View, Calif.","The JVM  also facilitates platform independence. The JVM  acts like an abstract computing machine, receiving instructions from programs in the form of byte codes and interpreting these byte codes by dynamically converting them into a form for execution, such as object code, and executing them. RMI  facilitates remote method invocation by allowing objects executing on one computer or device to invoke methods of an object on another computer or device. The RMI may be located within the JVM, and both the RMI and the JVM are provided as part of the Java software development kit.","The lookup service  defines the services that are available for a particular Djinn. That is, there may be more than one Djinn and, consequently, more than one lookup service within the exemplary distributed system . The lookup service  contains one object for each service within the Djinn, and each object contains various methods that facilitate access to the corresponding service. The lookup service  and its access are described in greater detail in co-pending U.S. patent application Ser. No. 09\/044,837, entitled \u201cMethod and System for Facilitating Access to a Lookup Service,\u201d which has previously been incorporated by reference.","The discovery server  detects when a new device is added to the exemplary distributed system  during a process known as boot and join or discovery, and when such a new device is detected, the discovery server passes a reference to the lookup service  to the new device, so that the new device may register its services with the lookup service and become a member of the Djinn. After registration, the new device becomes a member of the Djinn, and as a result, it may access all the services contained in the lookup service . The process of boot and join is described in greater detail in co-pending U.S. patent application Ser. No. 09\/044,939, entitled \u201cApparatus and Method for providing Downloadable Code for Use in Communicating with a Device in a Distributed System,\u201d which has previously been incorporated by reference.","The Java space  is an object repository used by programs within the exemplary distributed system  to store objects. Programs use the Java space  to store objects persistently as well as to make them accessible to other devices within the exemplary distributed system. Java spaces are described in greater detail in co-pending U.S. patent application Ser. No. 08\/971,529, entitled \u201cDatabase System Employing Polymorphic Entry and Entry Matching,\u201d assigned to a common assignee, filed on Nov. 17, 1997, which is incorporated herein by reference. One skilled in the art will appreciate that the exemplary distributed system  may contain many lookup services, discovery servers, and Java spaces.","A security enforcement mechanism is provided in which the access permissions of a thread are allowed to vary over time based on the source and executor of the code currently being executed. The source of the code indicates whether the code is from a trusted or untrusted source. The executor indicates the principal on whose behalf the code is being executed. For example, the executor may be a particular user or a particular organization on whose behalf the process or program is operating on a client computer.","When a routine that arrives from a trusted source is executing, the thread executing the routine is typically allowed greater access to resources. Similarly, a trusted executor may be given greater access to resources.","When a routine calls another routine, the thread executing the routines is associated with permissions common to both routines. Thus, the thread is restricted to a level of access that is less than or equal to the level of access allowed for either routine.","The mechanism allows certain routines to be \u201cprivileged.\u201d When determining whether a thread is able to perform an action, only the permissions associated with the privileged routine and the routines above the privileged routine in the calling hierarchy of the thread are inspected.","According to an implementation consistent with the present invention, the security mechanism described herein uses permission objects and protection domain objects to store information that models the security policy of a system. The nature and use of these objects, as well as the techniques for dynamically determining the time-variant access privileges of a thread, are described hereafter in greater detail.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 3","b":["3100","1100","2","3100","3200","2150","3300","3400","3300","3400","1100"]},"Because untrusted code is considered to pose a high security risk, the set of computer resources that untrusted code may access is usually restricted to those which do not pose security threats. Code from a trusted source is code usually developed by trusted developers. Trusted code is considered to be reliable and poses much less security risk than untrusted code.","Software code which is loaded over the network from a remote source and immediately executed is herein referred to as remote code. Typically, a remote source is a computer system of a separate organization or individual. The remote source is often connected to the Internet.","Normally untrusted code is remote code. However, code from sources local to computer  may pose a high security risk. Code from such local sources may be deemed to be untrusted code from an untrusted source. Likewise, code from a particular remote source may be considered to be reliable and to pose relatively little risk, and thus may be deemed to be trusted code from a trusted resource.","According to an implementation consistent with the present invention, a security mechanism is used to implement security policies that allow trusted code to access more resources than untrusted code, even when the trusted and untrusted code are executed by the same principal. A security policy determines what actions code execution element  will allow the code within code stream  to perform. The use of permissions and protection domains allows policies that go beyond a simple trusted\/untrusted dichotomy by allowing relatively complex permission groupings and relationships.","Protection domains and policies that may be used in conjunction with typed permissions will be described in greater detail with reference to FIG. .","The user or organization on whose behalf a computer program is operating (or in some circumstances, the program itself) is known as the \u201cexecutor\u201d (i.e., the principal on whose behalf resources will be accessed). The executor for a program on the computer  (a \u201cclient executor\u201d), for example, may be different than the executor for a program on the computer  (a \u201cserver executor\u201d).","Code execution element  receives the request on behalf of a client executor via the RMI  (FIG. ). In response, code execution element  executes an operation, such as a thread, to handle the request. The thread is responsible for obtaining the appropriate code and\/or resources to satisfy the request, and the thread will, in general, be permitted to operate on behalf of either or both of the server executor and the client executor.","Code execution element  permits authorized executors, or \u201ctrusted executors,\u201d greater access to computer resources because the trusted executors are not considered to pose a high security risk. Trusted executors may include system operators that need greater access to the computer resources to handle system updates and the like. Unauthorized executors, or \u201cuntrusted executors,\u201d are treated differently. Untrusted executors are considered to pose a high security risk and, therefore, are given limited access to the computer resources.","According to an implementation consistent with the present invention, a security mechanism is used to implement security policies that allow trusted executors to access more resources than untrusted executors, even when the trusted and untrusted executors request code from a single source. A security policy determines what actions code execution element  will allow. The use of permissions and protection domains allows policies that go beyond a simple trusted\/untrusted dichotomy by allowing relatively complex permission groupings and relationships.","Protection domains and policies that may be used in conjunction with typed permissions shall now be described in greater detail with reference to FIG. .","An exemplary security mechanism illustrating the use of protection domains is shown in FIG. . The exemplary security mechanism includes a policy file , a policy object , a domain mapper object , and one or more protection domain objects . The security mechanism is implemented using the code execution element  (FIG. ).","Code execution element  executes the code it receives from code stream  (FIG. ). For the purpose of explanation, it shall be assumed that the code from code stream  is object-oriented software. Consequently, the code is in the form of methods associated with objects that belong to classes. In response to instructions embodied by code executed by code execution element , code execution element  creates one or more objects . An object is a data structure containing data combined with the procedures or functions that manipulate the data. All objects belong to a class, such as class . Each object belonging to a class has the same fields (\u201cattributes\u201d) and the same methods. The methods are the procedures, functions, or routines used to manipulate the object. An object is said to be an \u201cinstance\u201d of the class to which the object belongs.","One or more class definitions are contained in the code from code stream . The fields and methods of the objects belonging to a class are defined by a class definition. These class definitions are used by code execution element  to create objects which are instances of the classes defined by the class definitions.","These class definitions are generated from source code written by a programmer. For example, a programmer using a Java development kit enters source code that conforms to the Java programming language into a source file. The source code embodies class definitions and other instructions which are used to generate byte codes that control the execution of the code execution element . Techniques for defining classes and generating code executed by a code execution element, such as a Java virtual machine, are well known to those skilled in the art.","Each class defined by a class definition from code stream  is associated with a class name  and a code identifier . Code execution element  maintains an association between a class  and its class name  and code identifier . The code identifier  represents a source of the code.","A \u201csource of code\u201d is an entity from which computer instructions are received. Examples of sources of code include a file or persistent object stored on a data server connected over a network, a Flash EPROM reader that reads instructions stored on a Flash EPROM, or a set of system libraries.","In an implementation consistent with the present invention, the code identifier  is a composite record containing a uniform resource locator (\u201cURL\u201d)  and a set of public cryptographic keys . A URL identifies a particular source. The URL  is a string used to uniquely identify any server connected to the Internet. The URL  may also be used to designate sources local to computer . Typically, the URL  includes a designation of the file and the directory of the file that is the source of the code stream that a server is providing.","A public cryptographic key, herein referred to as a \u201ckey,\u201d is used to validate the digital signature which may be included in a file used to transport related code and data. Public cryptographic keys and digital signatures are described in further detail in Schneier, , 1996. The keys  may be contained in the file, contained in a database associating keys with sources (e.g., URLs), or accessible using alternative techniques.","A class may be associated with the digital signature included in the file used to transport code defining the class, or the class definition of the class may be specifically associated with a digital signature. A class that is associated with a valid digital signature is referred to as being signed. Valid digital signatures are digital signatures that can be verified by known keys stored in a database. If a class is associated with a digital signature that cannot be verified, or the class is not associated with any digital signature, the class is referred to as being unsigned. Unsigned classes may be associated with a default key. A key may be associated with a name that may be used to look up the key in a database.","While one code identifier format has been described as including data indicating a source (i.e., cryptographic key and URL), alternate formats are possible. Other information indicating the source of the code, or combinations thereof, may be used to represent code identifiers.","An executor identifier  represents the executor of code. An \u201cexecutor of code\u201d is a principal (e.g., a user or organization) on whose behalf the code is being executed. An example of an executor might include a person, like \u201cJohn T. Smith,\u201d or an organization, like \u201cSun Microsystems, Inc.\u201d An \u201cexecutor identifier\u201d is, therefore, some form of identifier that represents the executor. Examples of possible executor identifiers include string names, computer system login names, and employee numbers. When a server receives a request from a client via the RMI, the server may require authentication of the client executor as proof that the client program is executing on behalf of the client executor.","According to an implementation consistent with the present invention, protection domains are used to enforce security within computer systems. A protection domain can be viewed as a set of permissions granted to one or more executors when code from one or more sources is being executed on their behalf. A permission is an authorization by the computer system that allows a principal to execute a particular action or function. Typically, permissions involve an authorization to perform an access to a computer resource in a particular manner. An example of an authorization is an authorization to \u201cwrite\u201d to a particular directory in a file system (e.g., \/home).","A permission can be represented in numerous ways in a computer system. For example, a data structure containing text instructions can represent permissions. An instruction such as \u201cpermission executor write\/somedirectory\/somefile\u201d denotes a permission to write to file \u201csomefile\u201d in the directory \u201c\/somedirectory\u201d on behalf of the principal \u201cexecutor.\u201d The instruction denotes which particular action is authorized, the executor authorized to perform the action, and the computer resource upon which that particular action is authorized. In this example, the particular action authorized is to \u201cwrite\u201d on behalf of the principal \u201cexecutor.\u201d The computer resources upon which the particular action is authorized is a file \u201c\/somedirectory\/somefile\u201d in a file system of computer . In the example, the file and the directory in which the file is contained are expressed in a conventional form recognized by those skilled in the art.","Permissions can also be represented by objects, herein referred to as permission objects. Attributes of the object represent a particular permission. For example, an object can contain an action attribute of \u201cwrite,\u201d and a target resource attribute of \u201c\/somedirectory.\u201d A permission object may have one or more permission validation methods which determine whether a requested permission is authorized by the particular permission represented by the permission object.","The correlation between permissions, executors, and code sources constitutes the security policy of the system. The policy of the system may be represented by one or more files containing instructions. Each instruction establishes a mapping between a particular access identifier and a particular authorized permission. An access identifier is composed of an executor identifier and a code identifier. The permission specified in an instruction applies to all objects that belong to classes that are associated with the code identifier specified in the access identifier of the instruction, when those objects are operated on behalf of the executor specified by the executor identifier in the access identifier of the instruction.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 5","b":["4100","4","4100"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["<\u201cpermission\u201d><executor><URL><key name><action><target>\n\nThe <executor> identifies the executor of the code; the combination of the <URL> and the key that corresponds to <key name> constitute a code source; and the <action> and <target> represent a permission. The key is associated with a key name. The key and the corresponding key name are stored together in a key database. The key name can be used to find the key in the key database. For example, consider the following instruction:\n","permission executor1 file:\/\/somesource somekey write\/tmp\/*\n\nThe above instruction represents an authorization of a permission for executor \u201cexecutor1\u201d to write to any file in \u201c\/tmp\/*\u201d by an object that belongs to the class associated with the code source \u201cfile:\/\/somesource\u201d-\u201csomekey\u201d (i.e., URL-key name).\n"]}}}},"One permission does not have to exactly match another permission to be considered \u201cencompassed\u201d by the other permission. When a first permission encompasses a second permission without matching the second permission, the first permission is said to \u201cimply\u201d the second permission. For example, a permission to write to any file in a directory, such as \u201cc:\/,\u201d implies a permission to write to any specific file in the directory, such as \u201cc:\/thisfile.\u201d As another example, a permission to read the file \u201cd:\/log\u201d granted to \u201call current employees of Sun Microsystems, Inc.\u201d implies a permission to read the file \u201cd:\/log\u201d granted to a specific employee of that same organization.","If a permission is represented by a permission object, the validation method for the permission object contains code for determining whether one permission is implied by another. For example, a permission to write to any file in a directory implies a permission to write to any specific file in that directory, and a permission to read from any file in a directory implies a permission to read from any specific file in that directory. However, a permission to write does not imply a permission to read.","A variety of objects may be used to implement the policy represented by the access identifiers to permissions mapping contained in policy file . According to the implementation illustrated in , in order to efficiently and conveniently implement the policy, policy object , domain mapper object , one or more protection domain objects , and one or more access identifiers  are provided.","Policy object  is an object for storing the policy information obtained, for example, from policy file . Specifically, policy object  provides a mapping of access identifiers to permissions, and is constructed based on the instructions within policy file . Within the policy object , the access identifiers and their associated authorized permissions may be represented by data structures or objects.","Protection domain objects  are created on demand when new access identifiers  are encountered by domain mapper object . When an access identifier  is received, domain mapper object  determines whether a protection domain object  is already associated with the access identifier . The domain mapper object  maintains data indicating which protection domain objects have been created and the access identifiers associated with the protection domain objects. If a protection domain object is already associated with the access identifier, the domain mapper object  adds a mapping of the access identifier and protection domain object to a mapping of access identifiers and protection domain objects maintained by the domain mapper object .","If a protection domain object is not associated with the access identifier, a new protection domain object is created and populated with permissions. The protection domain object is populated with those permissions that are mapped to the access identifier based on the mapping of access identifiers to permissions in the policy object . Finally, the domain mapper object  adds a mapping of the access identifier and protection domain object to the mapping of access identifiers and protection domain objects as previously described.","In other implementations consistent with the present invention, instead of storing the mapping of access identifiers to protection domain objects in a domain mapper object, the mapping is stored as static fields in the protection domain class. The protection domain class is the class to which protection domain objects  belong. There is only one instance of a static field for a class no matter how many objects belong to the class. The data indicating which protection domain objects have been created and the access identifiers associated with the protection domain objects is stored in static fields of the protection domain class.","Static methods are used to access and update the static data mentioned above. Static methods are invoked on behalf of the entire class, and may be invoked without referencing a specific object.","The permission objects, protection domain objects, and policy objects described above are used to determine access rights of a thread. According to an implementation consistent with the present invention, such access rights vary over time based on what code the thread is currently executing, and on which executor's behalf the thread is currently executing. The sequence of calls that resulted in execution of the currently executing code of a thread is reflected in the call stack of the thread. Reference to an exemplary call stack shall be made to explain the operation of a security mechanism that enforces access rights in a way that allows the rights to vary over time.",{"@attributes":{"id":"p-0107","num":"0108"},"figref":"FIG. 6","b":["6100","6200","6300","1","4500","1","6300","2","4500","2","6300","3","4500","3","6400","6500"]},"Thread  is a thread executing on computer . Call stack  is a stack data structure representing a calling hierarchy of the methods invoked by thread  at any given instance. At the instance illustrated in , call stack  contains a frame (e.g., frame -) for each method executed by thread , but not yet completed.","Each frame corresponds to the method that has been called but not completed by thread . The relative positions of the frames on the call stack  reflect the invocation order of the methods that correspond to the frames. When a method completes, the frame that corresponds to the method is removed from the top of the call stack . When a method is invoked, a frame corresponding to the method is added to the top of the call stack .","Each frame contains information about the method and the object that correspond to the frame. From this information, the class of the method can be determined by invoking a \u201cget class\u201d method provided for every object by the code execution element . The code identifier of this class can then be determined from the association maintained by the code execution element . Each frame also contains the executor identifier (e.g., executor identifier -) of the executor on whose behalf the thread is executing. The executor identifier and code identifier can then be composed into an access identifier (e.g., access identifier -). From the mapping in domain mapper object , the protection domain object associated with the access identifier for a given frame can be determined.","For example, assume thread  invokes method -. While executing method -, thread  invokes method -. While executing method -, thread  invokes method -. While executing method -, thread  invokes method . At this point, call stack  represents the calling hierarchy of methods as shown in FIG. . Frame - corresponds to method , frame - to method -, frame - to method -, and frame - to method -. When thread  completes method , frame - is removed from the call stack .","Each frame on the call stack  is associated with a set of permissions. The set of permissions for a given frame is determined by the protection domain object associated with the source from which the code for the given method was received and the principal on whose behalf the code is being executed. The relationship between frames, protection domains, and permissions shall now be described with continued reference to FIG. .","Protection domain object - is mapped from the access identifier - formed by the executor identifier - and the code identifier of the class of object -. Method - of object - invokes method - of object - on behalf of executor identifier -. Protection domain object - is mapped from the access identifier - formed by the executor identifier - and the code identifier of the class of object -. Method - of object - invokes method - of object - on behalf of executor identifier -. Protection domain object - is mapped from the access identifier - formed by the executor identifier - and the code identifier of the class of object -.","While protection domain objects are used to organize and determine the access rights of a particular executor and code source, some mechanism must be provided to determine the access rights of a thread having a call stack with multiple methods whose code arrived from multiple sources or whose code is requested to be executed on behalf of multiple principals. According to an implementation consistent with the present invention, this determination is performed by an access controller object, as shall be described in greater detail hereafter.","According to an implementation consistent with the present invention, an access controller object is used to determine whether a particular action may be performed by a thread. Specifically, before a resource management object accesses a resource, the resource management object (e.g., object -) invokes a check permission method  of an access controller object .","In the illustrated example, the resource management method - invokes a check permission method  of the access controller object  to determine whether access to the resource is authorized. To make this determination, the check permission method  of the access controller object  performs the steps that shall be described with reference to FIG. .","According to an implementation consistent with the present invention, an action is authorized if the permission required to perform the action is included in each protection domain object associated with the thread at the time when a request to determine the authorization is made. A permission is said to be included in a protection domain object if that permission is encompassed by one or more permissions associated with the protection domain object. For example, if an action requires permission to write to a file in the \u201ce:\/tmp\u201d directory on behalf of the principal \u201cBob,\u201d then that required permission would be included in protection domain object - if the protection domain object - explicitly contains or implies that permission.","Assume that thread  is executing method - when thread  makes a request for a determination of whether an action is authorized by invoking the check permission method . Assume further that thread  has invoked method -, method -, and method - and these methods have not completed when thread  invoked method . The protection domain objects associated with thread  when the request for a determination of authorization is made are represented by protection domain objects -, -, and -.","Given the calling hierarchy present in the current example, the required permission to perform an action of writing to file \u201cd:\/sys\/pwd\u201d on behalf of \u201cBob\u201d is not authorized for thread  because the required permission is not encompassed by any permission included in protection domain object -, if the only permission contained therein is \u201cwrite to e:\/tmp.\u201d","Sometimes the need arises to authorize an action that a method performs irrespective of the protection domain objects associated with the methods that precede the method in the calling hierarchy of a thread. Updating a password is an example of when such a need arises.","Specifically, because the security of a password file is critical, the permissions required to update the password file are limited to very few specialized protection domain objects. Typically, such protection domain objects are associated with methods of objects from trusted code and trusted executors that provide their own security mechanisms. For example, a method for updating a password may require the old password of a user before updating the new password for that user. The method may also require authentication of the principal on whose behalf the update is being requested, and permit updating of the password for only authorized principals.","Because permissions to update passwords are limited to code from specific sources and to code executed on behalf of specific authorized principals, code from all other sources or principals will not be allowed to update the passwords. This is true even in a situation such as that shown in , where code from a remote source (method -) attempts to change the password by invoking trusted code (method -) which has permission to update the password. Access is denied in this situation because at least one method in the calling hierarchy (method -) does not have the necessary permission.","According to an implementation consistent with the present invention, a privilege mechanism is provided to allow methods that do not themselves have the permission to perform actions to nevertheless cause the actions to be performed by calling special \u201cprivileged\u201d methods that do have the permissions. This result is achieved by limiting the protection domain objects that are considered to be \u201cassociated with a thread\u201d to only those protection domain objects that are associated with a \u201cprivileged\u201d method and those methods that are subsequent to the privileged method in the calling hierarchy.","A method may cause itself to be privileged (i.e., enable the privilege mechanism) by invoking a method of a privilege object called for example, beginPrivilege. A method may cause itself to become not privileged (i.e., disable the privilege mechanism) by invoking another method of the privilege object called, for example, endPrivilege. The following code example illustrates one technique for invoking methods that enable or disable the privilege mechanism. Although the code example may resemble the Java programming language by Sun Microsystems Inc., the example is for illustrative purposes only and is not meant to be representative of an actual code implementation.",{"@attributes":{"id":"p-0125","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Privileged p = new Privileged();"},{"entry":"p.beginPrivilege();"},{"entry":"try {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"[sensitive code]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"} finally {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"p.endPrivilege();"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The first line of the code example creates a privilege object. The second line invokes a beginPrivilege method of the privilege object that enables the privilege mechanism. The \u201ctry finally\u201d statement ensures that the block of code following the \u201cfinally\u201d is executed regardless of what happens during execution of the block between the \u201ctry\u201d and the \u201cfinally.\u201d Thus, the privilege disabling method of the privilege object (\u201cp.endPrivilege( )\u201d) is always invoked.","The above code can be used, for example, to bound the portion of method - that actually accesses the password file. The portion that accesses the password file would be contained in the block designated as \u201c[sensitive code].\u201d The technique illustrated by the above code example explicitly places the responsibility for enabling and disabling the privilege mechanism upon the programmer.","Often, while executing a privileged method, a thread may invoke subsequent methods associated with other protection domain objects that do not include permissions included in the privileged protection domain object. When a thread is executing a subsequent method, an action requested by the thread is only authorized if the required permission is encompassed in the protection domain objects associated with the subsequent method and any methods in the calling hierarchy between the subsequent method and privileged method, inclusively. The advantage of limiting the privilege mechanism in this manner is to prevent methods of untrusted code and of untrusted executors from effectively \u201cborrowing\u201d the permissions associated with privileged methods of trusted code and trusted executors when the methods of the untrusted code and untrusted executors are invoked by the privileged methods.","In an alternate implementation consistent with the present invention, a method causes itself to be privileged or not privileged by invoking static methods of the access controller class. The access controller class is the class to which access controller objects belong. As demonstrated in the following code example, using static methods that are associated with the access controller class avoids the need of having to create a privilege object in order to enable the privilege mechanism.","The following code example illustrates one technique for invoking methods that enable or disable the privilege mechanism. Assume for the purpose of illustration that the access controller class name is AccessControl. Although the code example may resemble the Java programming language by Sun Microsystems Inc., the example is for illustrative purposes only and is not meant to be representative of an actual code implementation.",{"@attributes":{"id":"p-0131","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"AccessControl.beginPrivilege();"},{"entry":"try {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"[sensitive code]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"} finally {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"AccessControl.endPrivilege();"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"A thread may invoke the same method at different levels in a calling hierarchy. For example, a method X may call a method Y which may call the method X. Consequently, a method, such as method -, that is invoked as a privileged method could be invoked a second time without enabling the privilege mechanism in the second invocation. To properly determine the protection domain objects associated with a thread while the privilege mechanism is enabled, a mechanism is provided to track which invocation of the privileged method enabled the privilege mechanism. The invocation in which a thread enables the privilege mechanism is referred to as an \u201cenabling invocation.\u201d","One technique to track which invocations of a particular method are enabling invocations is to set a flag in the frame corresponding to each enabling invocation. This may be accomplished by setting the privilege flag  in the frame corresponding to each enabling invocation, when the privilege enabling method of each privilege enabling object is invoked during execution of a method.","According to an implementation consistent with the present invention, each frame has a privilege flag value. When any frame is added to the call stack , the initial value of the privilege flag indicates that the corresponding method is not privileged. The privilege flag of any frame is only set to a value indicating the corresponding method is privileged when the corresponding method enables the privilege.","After a method that enables the privilege mechanism completes, the value of the privilege flag  will not carry over to the next invocation of the method. The value will not carry over because when the new frame corresponding to the method is added to the call stack , the initial value of the privilege flag is set to indicate that the corresponding method is not privileged. Maintaining the value of the privilege flag in this manner disables the privilege mechanism when a privileged method completes regardless of whether the privilege mechanism is explicitly disabled by the programmer.",{"@attributes":{"id":"p-0136","num":"0137"},"figref":["FIG. 7","FIG. 6"],"b":["6400","6","6200","6300","1","6300","1","6200","6300","2","6300","3","6300","2"]},"In step , when a resource management object receives a request to access an object, the check permission method  is invoked to determine whether the requested action is authorized. In , the method - makes the request to access an object by invoking the check permission method  of the access controller object , and passing to it as a parameter the permission required to perform the action.","Steps  through  define a loop in which permissions associated with the frames in the call stack are checked. The loop continues until a privileged method is encountered, or all of the frames in the call stack have been checked. For the purpose of explanation, the frame whose privileges are currently being checked is referred to as the \u201cselected frame,\u201d and the method associated with that frame is referred to as the \u201cselected method.\u201d","In step , a determination is made as to whether one of the permissions associated with the selected frame encompasses the permission required. The permissions associated with a frame are the permissions of the protection domain object that is associated with the frame. If the determination made in step  is that a permission associated with the selected frame encompasses the permission required, control passes to step .","During the first iteration of the loop, the frame that immediately precedes the frame associated with the check permission method of the access controller object is inspected. In the example, the frame associated with the check permission method  is frame -. The frame that immediately precedes frame - is frame -. Consequently, during the first iteration of the loop, frame - will be inspected. Frame - is associated with protection domain object -. If a permission associated with protection domain object - encompasses the permission required, control passes to step .","In step , a determination is made of whether invocation of the selected method represents the enabling invocation. This determination is based on the privilege flag of the frame corresponding to the selected method. If the determination is that the invocation of the selected method does not represent the enabling invocation, control passes to step . In this example, the privilege status of frame - is not set to indicate that the frame represents the enabling invocation, thus control passes to step .","In step , the next frame is selected. The next frame is the frame below the current frame based on the calling hierarchy represented by call stack . In this example, the frame below the current frame - is frame -. The method corresponding to frame - is method -.","In step , a determination is made of whether a frame was selected in step . If a frame was selected, control reverts to step . In the current example, control passes to step  because frame - was selected. In step , the determination that is made is that the protection domain object associated with frame - (protection domain object -) includes a permission encompassing the permission required because in the example a permission associated with protection domain object - explicitly encompasses the permission required. Control then passes to step .","In step , the determination that is made is that the invocation of a selected method represents the enabling invocation because the privilege flag  indicates that the invocation corresponding to frame - is an enabling invocation. A message is transmitted indicating that the permission request is valid. Then, the permission check ends.","By exiting the permission check at step  when the selected method represents the enabling invocation, authorization of the requested action is based on the privileged protection domain object and any protection domain objects associated with methods invoked after the enabling invocation.","Now assume that the privilege mechanism was never invoked in the current example. Thus in step , the determination that is made is that invocation of the selected method does not represent the enabling invocation because the privilege flag  indicates that the invocation corresponding to frame - is not an enabling invocation.","In step , the next frame selected is frame - because the frame below the current frame - is frame -, and the method corresponding to frame - is method -. In step , the determination that is made is that a next frame was selected in step . Thus, control reverts to step  again.","In step , the determination that is made is that the protection domain object associated with frame - (protection domain object -) does not include the permission required because no permission associated with protection domain object - in the example encompasses the permission required. Control then passes to step .","In step , a message indicating that the requested action is not authorized is transmitted. In an implementation consistent with the present invention, the message is transmitted by throwing an Exception error.","When at least one protection domain object associated with a thread does not include a permission encompassing the permission required, the requested action is not authorized. An action is authorized only when all the protection domain objects associated with a thread include the permission required at the time that the request is made for a determination of whether the action is authorized.","In an implementation consistent with the present invention, when a thread (\u201cparent thread\u201d) causes the spawning of another thread (\u201cchild thread\u201d), the protection domain objects associated with the parent thread are \u201cinherited\u201d by the child thread. The protection domain objects may be inherited by, for example, retaining the call stack of a parent thread when the child thread is created. When the steps shown in  are executed to determine whether an action is authorized, the call stack that is traversed is treated as if it included the call stack of the parent thread.","In another implementation consistent with the present invention, a child thread does not inherit the protection domain objects of the parent thread. In this case, the call stack that is traversed is treated as if it did not include the parent's call stack.","One advantage of basing the authorization of a thread to perform an action on the protection domain objects associated with the thread is that the permissions can be based on the source of the code the thread is executing and the principal on whose behalf the code is being executed.","As mentioned earlier, objects are created from class definitions in code received by code execution element . The source of code a thread is executing is the source of code of the method. The source of code of a method is the source of the class definition used to define the class to which the method's object belongs. The executor of the code is the principal on whose behalf the code is being executed. This may include the executor of a process or program operating on a client system.","Because the protection domain objects are associated with the source and executor of code of a method, as described previously, the permissions authorized for a thread can be based on the source and executor of the code of each method invoked by a thread. Thus, it can be organized so that code from a particular source or code executed on behalf of a particular principal is associated with the permissions appropriate for security purposes.","An advantage of the privilege mechanism described above is that performance of sensitive operations in which security is critical can be limited to methods from trusted sources and methods executed on behalf of trusted executors. Furthermore, these operations can be performed on behalf of methods based on less secure code. Methods performing sensitive operations typically rely on their own security mechanisms (e.g., password authentication methods). When a thread invokes the privilege mechanism, the scope of the permissions of the privileged domain, which typically entail a high security risk, are limited to the enabling invocation. This prevents a method invoked within the privileged method, such as a method based on untrusted code or an untrusted executor, from acquiring the capability to perform operations posing a high security risk.","While one method of tracking which invocations are enabling invocations is described above, various alternative methods of tracking enabling invocations are possible. Therefore, it is understood that the present invention is not limited to any specific method for tracking enabling invocations.","Systems and methods consistent with the principles of the present invention provide a security enforcement mechanism in which access permissions of a thread vary over time based on the source and executor of the code being executed.","The foregoing description of exemplary embodiments of the present invention provides illustration and description, but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. The scope of the invention is defined by the claims and their equivalents.","Although systems and methods consistent with the present invention are described as operating in the exemplary distributed system and the Java programming environment, one skilled in the art will appreciate that the present invention can be practiced in other systems and other programming environments. Additionally, although aspects of the present invention are described as being stored in memory, one skilled in the art will appreciate that these aspects can also be stored on or read from other types of computer-readable media, such as secondary storage devices, like hard disks, floppy disks, or CD-ROM; a carrier wave from the Internet; or other forms of RAM or ROM. Sun, Sun Microsystems, the Sun logo, Java, and Java-based trademarks are trademarks or registered trademarks of Sun Microsystems Inc. in the United States and other countries."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate an embodiment of the invention and, together with the description, explain the objects, advantages, and principles of the invention. In the drawings:",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 7","FIG. 6"]}]},"DETDESC":[{},{}]}
