---
title: Policy engine to control the servicing of requests received by a storage server
abstract: Certain tasks are outsourced from a filer to a remote policy engine. The policy engine implements various defined policies to control the filer's servicing of client requests. For example, the policy engine can be used to implement policies to control various storage-related operations relating to data managed by a filer, such as creation, deletion, modification, opening, closing, renaming and/or changing attributes of files or directories managed by the filer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07778981&OS=07778981&RS=07778981
owner: NetApp, Inc.
number: 07778981
owner_city: Sunnyvale
owner_country: US
publication_date: 20040211
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This is a continuation-in-part of U.S. patent application Ser. No. 10\/010,959 of M. Muhlestein, filed on Nov. 30, 2001 and entitled, \u201cDecentralized Virus Scanning for Stored Data\u201d (hereinafter \u201cMuhlestein\u201d), which is a continuation-in-part of U.S. patent application Ser. No. 09\/728,701 filed on Dec. 1, 2000 and entitled, \u201cDecentralized Appliance Virus Scanning,\u201d both of which are incorporated herein by reference.","At least one embodiment of the present invention pertains to data storage systems, and more particularly, to a policy engine to control the servicing of requests received by a storage server.","Modern computing systems often employ various types of storage servers. Storage servers are used for a variety of purposes, such as to provide multiple users with access to shared data and to back up mission critical data. A file server, for example, is a type of storage server which operates on behalf of one or more clients to store and manage shared files in a set of mass storage devices, such as magnetic or optical storage based disks or tapes. The mass storage devices are typically organized into one or more volumes of Redundant Array of Independent (or Inexpensive) Disks (RAID).","One configuration in which a file server can be used is a network attached storage (NAS) configuration. In a NAS configuration, a file server can be implemented in the form of an appliance, called a filer, that attaches to a network, such as a local area network (LAN) or a corporate intranet. An example of such an appliance is any of the Filer products made by Network Appliance, Inc. in Sunnyvale, Calif.","A storage server can also be employed in a storage area network (SAN) environment. A SAN is a highly efficient network of interconnected, shared storage devices. One difference between NAS and SAN is that in a SAN, the storage server (which may be an appliance) provides a remote host with block-level access to stored data, whereas in a NAS configuration, the storage server provides clients with file-level access to stored data. Some storage servers, such as certain Filers from Network Appliance, are capable of operating in either a NAS mode or a SAN mode or even both modes at the same time. Such dual-use devices are sometimes referred to as \u201cunified storage\u201d devices.","It is desirable to allow third parties software developers to develop applications that can access and\/or control processes that run on a filer. Doing so can enhance and add value to such devices. However, development of such applications by third parties can be costly and complicated and risk having an unintended negative impact on other processes of the storage server. As a result, relatively few third party applications are available at present. It is desirable, therefore, to facilitate the development of such third party applications, without requiring that all such applications be developed by one company, while reducing the risk of a negative impact on the storage server.","The present invention includes a method of operating a storage server. The storage server receives from a client a request to perform a storage-related operation relating to a set of data. If the first request satisfies a defined criterion, the storage server invokes a policy engine configured to determine a disposition of the request. The storage server then receives a response from the policy engine indicating a disposition of the request and responds to the request in accordance with the response from the policy engine.","Another aspect of the invention is a method of operating a policy engine. The policy engine receives a first request and information relating to a set of data from a storage server. The first request is in response to a storage-related client request received by the storage server from a client and relating to the set of data. The policy engine applies a defined policy using the information relating to a set of data and then sends a first response to the storage server to indicate a result of applying the defined policy. The first response is to cause the storage server to send a second response to the client in accordance with the first response.","Other aspects of the invention will be apparent from the accompanying figures and from the detailed description which follows.","A method and apparatus for controlling the servicing of requests received by a storage server are described. Note that in this description, references to \u201cone embodiment\u201d or \u201can embodiment\u201d mean that the feature being referred to is included in at least one embodiment of the present invention. Further, separate references to \u201cone embodiment\u201d or \u201can embodiment\u201d in this description do not necessarily refer to the same embodiment; however, such embodiments are also not mutually exclusive unless so stated, and except as will be readily apparent to those skilled in the art from the description. For example, a feature, structure, act, etc. described in one embodiment may also be included in other embodiments. Thus, the present invention can include a variety of combinations and\/or integrations of the embodiments described herein.","It is desirable to increase the number and capability of applications that enhance the functionality of a filer, without requiring that all such applications be developed by one company. To accomplish this, an interface that allows independent software developers to create applications that access and control processes that run on a filer is needed. Such an interface allows isolation of development and features to reduce any negative impact on the filer, while still allowing control of significant features in the filer, thus allowing third parties to add value to the filer.","In this regard, note that Muhlestein (referenced in full above) describes a technique for \u201coutsourcing\u201d from a filer various tasks, such as virus scanning, data compression\/decompression, encryption\/detection, database compaction, data translation, or any of various other CPU intensive tasks. In particular, Muhlestein describes the use of a \u201ccluster device\u201d to perform such tasks on behalf of a filer. As described further below, the technique described in Muhlestein can be extended, modified and\/or generalized advantageously to achieve the above-noted goal.","Described herein is a technique for outsourcing certain tasks from a filer to a policy engine (which can be a device similar to a cluster device such as described in Muhlestein). The policy engine is, in certain embodiments, a dedicated application server used to implement various defined policies to control a filer's servicing of client requests. For example, the policy engine can be used to implement policies to control various storage-related operations relating to data managed by the filer. The controlled operations may include, for example, creation, deletion, modification, opening, closing, renaming and\/or changing attributes of files or directories managed by the filer.","A simple example of a networked storage system is illustrated in . The storage system includes a filer  coupled locally to a set of mass storage devices , and to a set of clients  through an interconnect . The filer  receives various read and write requests from the clients  and accesses the mass storage devices  to service those requests. Each of the clients  may be, for example, a conventional personal computer (PC), workstation, or the like. The mass storage devices  may be, for example, conventional magnetic tapes or disks, optical disks such as CD-ROM or DVD based storage, magneto-optical (MO) storage, or any other type of non-volatile storage devices suitable for storing large quantities of data.","The filer  is capable of operating in either a NAS mode or a SAN mode, or both; that is, the filer to can provide either file-level access or block-level access to stored data. The filer  implements a number of different storage protocols, such as the common Internet file system (CIFS), network file system (NFS), hypertext transport protocol (HTTP), simple network management protocol (SNMP), etc., and selectively uses these protocols as needed.","In a NAS implementation, the interconnect  may be essentially any type of computer network, such as a local area network (LAN), a wide area network (WAN), metropolitan area network (MAN) or the Internet, and may implement the Internet Protocol (IP). In a SAN implementation, the interconnect  may be, for example, a Fibre Channel switching fabric which implements the Fibre Channel Protocol (FCP).","The storage system also includes a remote policy engine , which is connected to the filer through an interconnect  (which can be the same interconnect as interconnect ). Interconnect  may be, for example, a conventional computer network, such as a LAN or a corporate intranet. The term \u201cremote\u201d, in this context, means that the policy engine  is external to the filer  and is connected to the filer  only indirectly, such as through a network. However, the term \u201cremote\u201d does not imply that the actual physical separation between the filer  and the policy engine  must be large; in fact, the physical separation between these devices can be quite small. Furthermore, it should be noted that the operations described herein as being performed by the policy engine  could instead be implemented internally to the filer.","In general terms, the role of the policy engine  is to control the servicing of certain requests received by the filer  from clients , by implementing various predefined policies. The operating system in the filer  includes an application programming interface (API) that allows the filer  to interface with the policy engine , as described further below. The policy engine  and the associated API in the filer  allow third party control of various processes of the filer . For example, the policy engine  can be used to implement policies to control various storage-related operations on files by the filer , such as creating, opening, closing, deleting, modifying, renaming and\/or changing attributes of files.","Each policy can be implemented in the policy engine  in the form of a simple software algorithm. A few examples of policies that can be implemented in a policy engine  are:","block creation of files of a particular file type","deny a particular user access to data stored in a particular disk or volume","limit certain users' access to a particular file, disk or volume to a specified number of times per day","apply a load balancing procedure to any data accessed more than a specified number of times in a specified period of time.","The policies may be defined\/installed or enabled within the policy engine  by a network administrator during a configuration process, via a separate management console (not shown). Similarly, the filer  can also be configured\/managed via a separate management console.","It might be desirable to block the creation of certain types of files, at least under certain conditions. For example, MP3 files tend to consume large amounts of storage space, such that it may be desirable not to give users unlimited freedom to store such files on the storage system. Consequently, a policy can be defined and implemented in the policy engine  to cause the policy engine  to block creation of MP3 files (or any other specified type of file), either unconditionally or under specified conditions. A policy may be applied only to certain users or to certain client machines or groups of user\/clients, for example, or only during certain times of today, etc.","Thus, the policy engine  can be used to implement policies to control essentially any storage-related operation of the filer , based on any of various criteria, such as filename, file type (e.g., file extension), the user or client which initiated the request, disk usage, specified quotas, etc., or any combination thereof. Further, the policy engine  can be used to collect and maintain summaries of attributes of data, such as keeping and running track of directory usage. The summarized data can be used by heuristics which implement the policies within the policy engine .","At startup, the policy engine  gets the name of the filer(s)  it will be serving from a command line interface or some other invocation interface. The policy engine  communicates with the filer  using a named pipe and registers itself with the filer  as a policy engine . The policy engine  then tells the filer  which communication method it will be using and which file operation(s) to screen. Separate named pipes are created for communications from the filer  to the policy engine  (\u201cscreen requests\u201d) and for communications from the policy engine  to the filer  (\u201cscreen responses\u201d).","As part of the registration process, the policy engine  causes the filer  to store a set of criteria for each policy the policy engine  will implement. The criteria, when satisfied by a client request, will trigger the filer  to invoke the policy engine  with a \u201cscreen request\u201d. When a client-initiated request received by the filer  meets any such set of criteria, the filer  defers to the policy engine  for disposition of the request, rather than immediately attempting to satisfy the request. For example, a set of criteria which the policy engine  registers with the filer  might essentially tell the filer , \u201cNotify me (the policy engine ) before servicing any request to create an MP3 file.\u201d When the criteria are met, the filer  sends no response to the requesting client until the policy engine  has provided a response to the filer ; hence, the policy engine's servicing of screen requests from the filer  is synchronous with the filer's servicing of client requests. If a negative response is received from the policy engine  or if the response time exceeds a predefined limit, the request from the client  will be denied.","In one embodiment, the criteria examined for purposes of generating screen requests are implemented as filters. In this embodiment, the filer  sends a screen request only if a certain feature of a file is matched (or not matched). The filer  in this embodiment acts to filter out request that are not relevant to the policy on the policy engine , reducing the communication required between the filer  and policy engine . For example, the filer  can send screen requests based on filters on file extensions, metadata attributes (e.g., an \u201coffline\u201d bit), or file attributes (file size, file age, etc.).",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["2","6","201","2","1","2","202","2","6","6","207","2","6","6","2","6","203","6","6"]},"With the screen request, the filer  also sends to the policy engine  information relating to the file, such as metadata of the file, e.g., canonical names for the file, the file extension of the file, the access type, user name of the requesting user, etc. The policy engine  may also set or modify such metadata of files managed by the filer , for later use. The information sent to the policy engine  with a particular screen request will depend upon which set of criteria the client request matched, and the criteria depend upon the policy with which they are associated. For example, if the matched criteria are based on the underlying policy of blocking creation of MP3 files, the filer  may include the MP3 file extension in the screen request.","In another example, the policy engine  is used to provide functionality that dynamically modifies information that is displayed to a client application based on a user credential or process ID. The filer  transfers to the policy engine , the identity of the client, process ID, or other user-centric attribute when a file is accessed. The file transformation is then carried out by the policy engine  or systems called by it. This functionality takes advantage of the synchronous nature of filer-to-policy-engine communication.","The policy engine  receives the screen request and the information relating to the file from the filer . At  the policy engine  applies the appropriate one or more of its defined policies to the received information. The result of applying the policy may be a decision by the policy engine  to approve or deny the request. To simplify description, it is generally assumed herein that the result of applying the policy is either approval or denial of the client request. Note, however, that the result of applying the policy can be something other than approval or denial of the request; in other words, the policy engine  can perform, or can cause the filer  or some other device to perform, some other predetermined action.","After applying the policy (or multiple policies), the policy engine  sends a screen response by RPC to the filer  at  to indicate the result. At  the filer  sends a response in accordance with the screen response to the client  which made the original request. For example, if the screen response was to approve the client request, the filer  satisfies the client request (in the current example, the filer  would allow creation of the file per the client request). If the screen response was to deny the request, the filer  sends the client a message indicating that the request was denied.","A policy engine  such as described herein can be used to control operations of multiple storage servers (e.g., multiple filers ), as illustrated in . Accordingly, a policy implemented by the policy engine  can be defined to be specific to a certain filer or filers . Similarly, the outcome of applying a policy in the policy engine  for a particular screen request may depend upon which particular filer  sent the screen request. For example, policies may be defined to apply a quota to a particular filer or group of filers , or users or clients  associated with a particular filer or filers . In this regard the information sent by a filer to a policy engine with a screen request may include an identifier of the filer. In a similar manner, the policy engine  can be used to provide secure access to certain data. For example, certain filers (and, hence, their associated users) may be permitted to access certain data while other filers (and, hence, their associated users) are denied access to the same data.","A policy engine  such as described herein can be implemented as a cluster device within a cluster, as described in Muhlestein, or the policy engine  can be implemented as a cluster. The cluster device or a policy engine  within a cluster can be selected by the filer  in a round robin manner, for example. Also, as illustrated , multiple independent policy engines  can be used as described above to control operations of multiple filers . In some implementations, each filer  may be statically assigned to a particular policy engine . In other implementations, the policy engine  which responds to a particular screen request may be determined dynamically based on any of various criteria, such as load balancing considerations, or it may be selected in a round robin manner by the requesting filer .","In certain embodiments, multiple policies are implemented in a logic AND fashion to implement an overall policy. In certain embodiments, policies can be linked in a more complex policy expression, for example by ORing or XORing two or more policies to create a more complex expression.","The policy engine  can be distributed amongst multiple nodes (e.g., multiple physical machines\/platforms). Accordingly, a particular policy may be distributed amongst multiple nodes. Each node may implement different policies and\/or each node may implement a portion of a total policy. Additionally, information from intermediate policy engines can be used as inputs to systems for evaluation and enforcement","In the case of a multiple-node policy engine, for example, one part of the policy engine can reside in the filer , while the other part or parts reside externally to the filer . In that case the portion of the policy engine  residing in the filer  may still be external to all other processes of the filer, in that such portion of the policy engine is not linked into any executables of the filer , either statically or dynamically.","The distribution of policies is advantageous in that it can reduce necessary bandwidth between nodes and reduce the complexity of each node. In certain embodiments, a two-node policy engine is used to distribute implementation of a policy asymmetrically. The portion of the policy engine  which resides on the filer  can be relatively simple, providing high-performance decisions regarding the file system and\/or filtering \u201cuninteresting\u201d events, while the off-filer part of the policy engine  would deal with more complex decisions and\/or multiple-filer views.","The above-described communications between a filer  and a policy engine  can be implemented with the help of interface definition language (IDL) files, which are platform-independent representations of data as exchanged between two machines. Certain embodiments of the invention employ two IDLs, referred to as fprequest.idl and fpcompletion.idl. Fprequest.idl describes the RPC calls made by the filer  to the policy engine , i.e., the screen request RPCs.","Screen Request RPCs","In certain embodiments of the invention, the following calls are implemented by the policy engine ; they are initiated from a filer  at the time screening of the file operation is requested:",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FP_ScreenRequest( )","Send data concerning a proposed file access to"]},{"entry":[{},"the policy engine for filtering."]},{"entry":["[in] handle_t FilerHandle","Opaque RPC binding handle furnished during the"]},{"entry":[{},"registration process."]},{"entry":["[in] DWORD FilerID","Integer ID assigned by policy engine during"]},{"entry":[{},"registration process"]},{"entry":["[in] DWORD RequestID","Filer's request ID"]},{"entry":["[in, string] wchar_t* ClientIP","IP address of client attempting to access the file"]},{"entry":["[in, string] wchar_t* UserSid","SID of the client attempting to access the file."]},{"entry":[{},"SID uses the notation: S-R-I-S-S ... In this"]},{"entry":[{},"notation, S identifies the series of digits as an"]},{"entry":[{},"SID, R is the revision level, I is the identifier-"]},{"entry":[{},"authority value, S is subauthority value(s)."]},{"entry":[{},"An SID could be written in this notation as"]},{"entry":[{},"follows: S-1-5-32-544"]},{"entry":[{},"In this example, the SID has a revision level of 1,"]},{"entry":[{},"an identifier-authority value of 5, first subauthority"]},{"entry":[{},"value of 32, second subauthority value of 544."]},{"entry":[{},"Note that the above SID represents the local"]},{"entry":[{},"Administrators group."]},{"entry":["[in] DWORD ClientOperation","Operation being attempted on file."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Operation"]},{"entry":[{},"Symbol value","Code","type"]},{"entry":[{},"FS_OP_OPEN","0x0001","File opens"]},{"entry":[{},"FS_OP_CREATE","0x0002","File creates"]},{"entry":[{},"FS_OP_RENAME","0x0004","File"]},{"entry":[{},{},{},"renames"]},{"entry":[{},"FS_OP_CLOSE","0x0008","File closes"]},{"entry":[{},{},{},"(CIFS only)"]},{"entry":[{},"FS_OP_DELETE","0x0010","File deletes"]},{"entry":[{},"FS_OP_RMDIR","0x0020","Directory"]},{"entry":[{},{},{},"deletes"]},{"entry":[{},"FS_OP_RENAME_DIR","0x0040","Directory"]},{"entry":[{},{},{},"renames"]},{"entry":[{},"FS_OP_ALL_OPS","0x007F","All"]},{"entry":[{},{},{},"operations"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["[in] DWORD ClientOperation","Operation being attempted on file."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Operation"]},{"entry":[{},"Symbol value","Code","type"]},{"entry":[{},"FS_OP_OPEN","0x0001","File opens"]},{"entry":[{},"FS_OP_CREATE","0x0002","File creates"]},{"entry":[{},"FS_OP_RENAME","0x0004","File renames"]},{"entry":[{},"FS_OP_CLOSE","0x0008","File closes"]},{"entry":[{},{},{},"(CIFS only)"]},{"entry":[{},"FS_OP_DELETE","0x0010","File deletes"]},{"entry":[{},"FS_OP_RMDIR","0x0020","Directory"]},{"entry":[{},{},{},"deletes"]},{"entry":[{},"FS_OP_RENAME_DIR","0x0040","Directory"]},{"entry":[{},{},{},"renames"]},{"entry":[{},"FS_OP_ALL_OPS","0x007F","All operations"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["[in] DWORD UID","This fields sends the process or user ID in it as an aid"]},{"entry":[{},"to detecting \u201crunaway processes\u201d."]},{"entry":["[in] DWORD AccessValid","Non-zero if DesiredAccess is filled in."]},{"entry":["[in] DWORD DesiredAccess","Requested access mode, as passed into the"]},{"entry":[{},"CreateFile( ) Win32 API, e.g. GENERIC_READ,"]},{"entry":[{},"GENERIC_WRITE."]},{"entry":["[in]","Non-zero if CreateDisposition is filled in."]},{"entry":"DWORD DispositionValid"},{"entry":["[in] DWORD","Requested create mode, as passed into the"]},{"entry":["CreateDisposition","CreateFile( ) Win32 API by the originating client, e.g."]},{"entry":[{},"CREATE_NEW, OPEN_EXISTING, etc."]},{"entry":["[in, string]","UNC path to file (e.g. \\\\filer\\home\\smc\\doc\\my.doc)."]},{"entry":"wchar_t* DisplayPath"},{"entry":["[in, string]","Path to the file on the filer (e.g."]},{"entry":["wchar_t* AccessPath","\\\\filer\\ONTAP_ADMIN$\\vol\\vol0\\"]},{"entry":[{},"home\\smc\\doc\\my.doc)."]},{"entry":[{},"Use this path to open the file for inspection or"]},{"entry":[{},"stat'ing during a screen request."]},{"entry":["[in, string]","Proposed new name for file during a rename, suitable"]},{"entry":["wchar_t* RenameDisplayPath","for display to a client, as in DisplayPath. Meaningless"]},{"entry":[{},"except for rename operations."]},{"entry":["[in, string] wchar_t*","Proposed new name for file during a rename, suitable"]},{"entry":["RenamePath","for opening by server, as in AccessPath. Meaningless"]},{"entry":[{},"except for rename operations."]},{"entry":["FP_ServerStatus ( )","Find out whether a policy engine is alive and well. If it"]},{"entry":[{},"is not, or if there is no reply to this RPC, the filer will"]},{"entry":[{},"automatically remove the policy engine from the list of"]},{"entry":[{},"policy engines."]},{"entry":["[in] handle_t FilerHandle","As above."]},{"entry":"[in] DWORD FilerID"},{"entry":["FP_RequestStatus ( )","Get status on an individual request. If the policy"]},{"entry":[{},"engine is working on it, OK, but otherwise, try sending"]},{"entry":[{},"the request to another policy engine if one is"]},{"entry":[{},"available. Otherwise, follow the policy set by"]},{"entry":[{},"\u201cFpolicy\u2009\u2122 options required\u201d. If \u201crequired\u201d is true,"]},{"entry":[{},"fail the request, otherwise allow it."]},{"entry":["[in] handle_t FilerHandle,","All fields match the values in the original request that"]},{"entry":["[in] DWORD FilerID,","is being checked on. A return value of zero means"]},{"entry":["[in] DWORD RequestID,","that no progress has been made. Anything else"]},{"entry":["[in, string] wchar_t*","means \u201cstill working on it\u201d."]},{"entry":"AccessPath,"},{"entry":"[out]"},{"entry":"DWORD* RequestStatus"},{"entry":["FP_ShutdownCP( )","Shut down operations. This RPC is normally issued"]},{"entry":[{},"before CIFS is terminated."]},{"entry":["[in] handle_t FilerHandle","As above."]},{"entry":"[in] DWORD FilerID"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The following APIs are implemented on the filer, and are called by the policy engine.",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FP_ScreenCompletion( )","Tell the filer whether or not to allow access to the file."]},{"entry":["[in] handle_t FilerHandle","The policy engine returns status back to the filer."]},{"entry":["[in] DWORD RequestID","You should return standard NT error codes, such"]},{"entry":["[in] DWORD Status","as 0x05 for Access Denied, or zero for success."]},{"entry":["[in, string] wchar_t* AccessPath","In the event that the policy engine fails the"]},{"entry":["[in, string] wchar_t* StatusStr","request, a human readable explanation, suitable"]},{"entry":[{},"for the filer logs, of why the access failed should"]},{"entry":[{},"be returned in the StatusStr field."]},{"entry":["FP_Registration ( )","Register self with a filer as an available policy engine."]},{"entry":["[in] handle_t FilerHandle","Opaque handle to filer gotten during initial RPC binding"]},{"entry":[{},"process."]},{"entry":["[in] DWORD FilerID","Filer ID, created by policy engine. This allows convenient"]},{"entry":[{},"identification of which filer is sending the request,"]},{"entry":[{},"if the policy engine has registered with more than"]},{"entry":[{},"one filer."]},{"entry":["[in] DWORD ServerType","Currently SCANTYPE_fscreen is the only allowed"]},{"entry":[{},"value here (see scantype.h)"]},{"entry":["[in] DWORD OpsToScreen","OR'ed combination of FP_OP_OPEN,"]},{"entry":[{},"FP_OP_RENAME, etc. (see fpserver.h). This"]},{"entry":[{},"tells the filer which operations the policy engine"]},{"entry":[{},"wishes to screen. Note that if one policy engine"]},{"entry":[{},"registers to screen ops A and B, while another"]},{"entry":[{},"registers to screen C, the filer will select the"]},{"entry":[{},"appropriate server depending on which operation"]},{"entry":[{},"comes in from a client."]},{"entry":["[in] DWORD Reserved","Currently unused"]},{"entry":["[in, string] wchar_t* PolicyName","Whatever policy name is declared on the filer"]},{"entry":[{},"that the server is going to serve for (\u201cdefault\u201d, for example)"]},{"entry":["[in, string]","Currently unused"]},{"entry":"wchar_t* OptionalParams"},{"entry":["FP_OpsToScreen ( )","Tell the filer which operations (e.g., open,"]},{"entry":[{},"rename and\/or create) to screen"]},{"entry":["[in] handle_t FilerHandle,","Set OpsToScreen to an OR'ed combination of"]},{"entry":["[in] DWORD OpsToScreen,","FP_OP_OPEN, FP_OP_RENAME, etc. (see"]},{"entry":["[in] DWORD Reserved","fpserver.h)"]},{"entry":["FP_ShutdownRQ( )","Ask for permission to no longer scan for files. If"]},{"entry":[{},"you simply disconnect without asking permission,"]},{"entry":[{},"one or more files which the filer has decided your"]},{"entry":[{},"policy engine should process may not be screened."]},{"entry":[{},"Waiting until this RPC completes"]},{"entry":[{},"means the filer has emptied the queue for this"]},{"entry":[{},"policy engine and done the right things."]},{"entry":"[in] handle_t FilerHandle"},{"entry":["FP_FilerStatus( )","Find out if the filer is alive and well. In the event"]},{"entry":[{},"of a reboot or takeover event, it is necessary to"]},{"entry":[{},"register again, so pinging this interface when no interaction"]},{"entry":[{},"has taken place for some time is prudent."]},{"entry":"[in] handle_t FilerHandle"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In certain situations it may be desirable to store some files (or other data) managed by a filer  remotely from the filer , such as in a separate nearline storage device, instead of in the filer's local storage. Where a file is stored may be determined by a separate data backup application. A policy engine  such as described above can be advantageous in situations where files managed by a filer  are stored remotely from the filer , as will now be described.","In certain embodiments, remotely stored files are replaced in the filer  by a \u201cstub\u201d (e.g., a header), and the inode of such a file includes a flag (e.g., an \u201coffline\u201d bit) indicating that the file is actually stored remotely. When the filer  receives a request relating to such a file, the filer  detects this flag in the inode of the file and responds by sending a corresponding notification to the policy engine . In response to this notification, the policy engine  obtains the file from the remote storage (if appropriate after applying any applicable policies), and provides the file to the filer . The filer  then uses the file as appropriate to satisfy the client request.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 4","b":["2","6","40","21","42","43","43","43"]},"The processor  is the central processing unit (CPU) of the processing system  and, thus, controls the overall operation of the processing system . In certain embodiments, the processor  accomplishes this by executing software stored in memory . The processor  may be, or may include, one or more programmable general-purpose or special-purpose microprocessors, digital signal processors (DSPs), programmable controllers, application specific integrated circuits (ASICs), programmable logic devices (PLDs), or the like, or a combination of such devices.","The memory  represents any form of random access memory (RAM), read-only memory (ROM), flash memory, or a combination thereof. Memory  stores, among other things, the operating system of the processing system , in which techniques of the present invention can be implemented.","Also connected to the processor  through the bus system  are (optionally) a mass storage device , a network adapter  and (at least in the case of a filer) a storage adapter . Mass storage device  may be or include any conventional medium for storing large volumes of data in a non-volatile manner, such as one or more disks. The network adapter  provides the processing system  with the ability to communicate with remote devices, such as clients and\/or a filer, over a network and may be, for example, an Ethernet adapter. The storage adapter  allows a filer to access external mass storage devices and may be, for example, a Fibre Channel adapter or SCSI adapter.","Thus, a method and apparatus for controlling the servicing of requests received by a storage server have been described. Although the present invention has been described with reference to specific exemplary embodiments, it will be recognized that the invention is not limited to the embodiments described, but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly, the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense."],"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["One or more embodiments of the present invention are illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
