---
title: Automatic synchronous-to-asynchronous software application converter
abstract: A computer-implemented method of generating output computer code, for an application executable via a server running application logic in communication with a client running a presentation layer for the application, from input computer code of a synchronous application in which logic and presentation layers run locally on a single computer. The output code runs asynchronously.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08607206&OS=08607206&RS=08607206
owner: GROUP Business Software AG
number: 08607206
owner_city: New York
owner_country: US
publication_date: 20110926
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND ART","SUMMARY OF EMBODIMENTS","DETAILED DESCRIPTION OF SPECIFIC EMBODIMENTS","Boundary Identification","Source Code Parsing and Destination Code Generation","Examples of Translations"],"p":["This application claims the benefit of U.S. Provisional Patent Application No. 61\/386,298, filed Sep. 24, 2010, titled \u201cAutomatic Converter of a Synchronous Application in which Logic and Presentation Software Run Locally on a Single Computer,\u201d the entire contents of which are hereby incorporated by reference herein, for all purposes.","The present invention relates to a software application converter (translator) and, more particularly, to a translator that parses a synchronous software application program and automatically generates a semantically equivalent asynchronous software application program.","A typical computer application program performs three functionally distinct types of operations (presentation, application processing and data management), although operations of these types may be intermingled within the program. Presentation includes inputting data values from a user and\/or providing outputs to the user, typically via a user interface. Application processing (sometimes called application logic or business logic) involves executing one or more algorithms that may use the user input values, and possibly data obtained from a data manager, to generate the outputs provided to the user and\/or outputs that are then stored by the data manager. The data manager reads and\/or writes persistent data stored on a storage device, manages files and the like.","Typical computer programming languages include instructions for performing each of these types of operations. Generalized examples include: GET and PUT (presentation); +, \u2212, *, \/, IF, WHILE and GOTO (application processing); and OPEN, CLOSE, SELECT, READ, WRITE and COMMIT (data management). Some statements may involve instructions of two or more of these three types. For example: \u201cIF EXISTS MyFile.txt (ECHO The file already exists)\u201d requires the data manager to ascertain whether a file named \u201cMyFile.txt\u201d exists before the IF instructions conditionally causes the ECHO instruction to display a message on a user interface.","Many application programs, which we here call \u201clegacy applications,\u201d have been written in a way that requires executing application logic and presentation instructions of the application on a single computer, i.e., a way that prevents splitting application logic and presentation between two separate computers or between two separately scheduled processes on a single computer (for simplicity, collectively herein referred to as two separate computers). A legacy application may access data stored on a separate server. However, a legacy application is typically written to be executed synchronously, because the application logic and the presentation are executed by a single computer. Consequently, the application logic must stall waiting for user input. \u201cSynchronous\u201d in the context of these legacy applications means that the application logic processing stalls while waiting for user input. Thus, a typical flow of control includes: (1) application logic processing (such as initialization); (2) a stall waiting for a user input; (3) application logic processing of data input by the user; (4) another stall waiting for a subsequent user input; (5) application logic processing of the subsequent data input by the user; etc., possibly ending with a transfer of control (loop) back to an earlier portion of application logic. A more general definition of synchronous is presented below. Examples of legacy applications include applications written in Lotus Notes, Microsoft Office and some programs written in Visual Basic, etc.","Modern applications have been written using a different model in which a presentation layer is executed by one computer, typically a client, and application logic is executed by another computer, such a server. Sometimes the server also acts as a data management server to the application; sometimes a separate server performs the data management function.","The application logic on the server often simultaneously serves several users, each user having an associated client, and each user potentially being at a different stage in the application logic processing. However, while waiting for input from one of the users, the application logic cannot stall the other users' application logic processing. Thus, modern applications are often written according to an asynchronous model, in that the application logic does not stall while waiting for user input. Instead, the application logic is written as a series of routines, and each routine handles a single user input. Each routine is invoked after its corresponding user input becomes available. While waiting for user input, context information particular to the user or the user's \u201csession\u201d is stored. When the user input becomes available, this context information is restored, and the appropriate routine begins executing.","Writing asynchronous applications is considered by many practitioners to be considerably more difficult than writing synchronous applications. Converting a legacy synchronous applications to an asynchronous application typically requires a manual rewriting of the legacy application by a highly skilled programmer.","An embodiment of the present invention provides a computer-implemented method of generating asynchronous application program output computer code from input computer code of a synchronous application. The input computer code is automatically parsed to develop an original syntax tree. A translated syntax tree is automatically developed from the original syntax tree. The translated syntax tree is semantically equivalent to the original syntax tree. At least one of the original syntax tree and the translated syntax tree is automatically analyzed to identify a plurality of nodes. Each node represents a respective instruction that potentially might not be executed as a result of a respective logical contingency. A boundary is automatically defined in the translated syntax tree, logically prior to each identified node. A plurality of asynchronous output computer code segments is automatically generated. Each generated segment corresponds to one of the defined boundaries. Each generated segment contains output computer code generated from a portion of the translated syntax tree. For each generated segment, at least a portion of the generated output computer code depends on a result of the respective logical contingency. Each generated segment contains no output computer code that implements the respective logical contingency.","Optionally, the plurality of asynchronous output computer code segments may be generated, such that for each generated segment a logically earlier segment does contain output computer code that implements the respective logical contingency.","The logical contingency may include at least one of: a user interface instruction; a transfer of control instruction; an external entry point; and a reference to a loosely-defined variable type.","The input computer code of the synchronous application may be of a first computer programming language, and the translated syntax tree may be developed according to a second computer programming language different than the first computer programming language.","The input computer code of the synchronous application may include logic and presentation layers that run locally on a single computer.","The plurality of asynchronous output computer code segments may be generated, such that the generated plurality of asynchronous output computer code segments: are executable via a server; and comprise an application logic layer configured to communicate with a client executing a presentation layer for the synchronous application.","The at least one of the original syntax tree and the translated syntax tree may be analyzed to identify user-interface function calls and nodes of the at least one of the original syntax tree and the translated syntax tree that are dependent on such function calls. The translated syntax tree may be developed, such that the user interface calls are mapped to corresponding translated calls in a client user interface; and each node dependent on a given call is mapped to follow the translated call corresponding to the given call. The plurality of asynchronous output computer code segments may be generated, such that the generated plurality of asynchronous output computer code segments implements an asynchronous client-server model. Before generating the output code, the syntax tree may be remapped according to a dependent program flow.","The asynchronous client-server model may include processes for each user interface function call. These processes may include a process serving a presentation screen to the client. The process may be configured to enable the client to notify the server in the event of a client request for a presentation layer action. These processes may include a process running logical processes until client input is required and storing a callback function and sending to the client a response to the client request. These processes may also include receiving from the client a message asking whether additional user input is required and sending to the client a response message indicating whether additional user input is required. If additional user input is required, these processes may include receiving from the client a request for a presentation characterization by which the additional user input can be obtained. In addition, the presentation characterization may be generated, the presentation characterization may be sent to the client, the additional user input may be received, and the callback function may be run.","Optionally, the foregoing processes may be repeated, beginning at the point of storing the callback function, until no further user input is required.","The input code may be written in a language, and the output code may be written in the same language. The input code may be written in a first language and the output code may be written in a second language that is different from the first language. For example, the language may be JavaScript or Java. For example, the first language may be @Formula and the second language may be JavaScript, or the first language may be LotusScript and the second language may be Java, or the first language may be LotusScript and the second language may be Java, or the first language may be Visual Basic and the second language may be C#, the first language may be Visual Basic and the second language may be Java.","Another embodiment of the present invention provides a computer-implemented system for automatically generating asynchronous application program output computer code from input computer code of a synchronous application. A parser is configured to automatically parse the input computer code to develop an original syntax tree. A syntax tree transformer is configured to automatically develop, from the original syntax tree, a translated syntax tree that is semantically equivalent to the original syntax tree. An analyzer is configured to automatically analyze at least one of the original syntax tree and the translated syntax tree to identify a plurality of nodes. Each identified node represents a respective instruction that potentially might not be executed as a result of a respective logical contingency. A boundary is automatically defined in the translated syntax tree logically prior to each identified node. A code generator is configured to automatically generate a plurality of asynchronous output computer code segments. Each generated segment corresponds to one of the defined boundaries. Each generated segment contains output computer code generated from a portion of the translated syntax tree. For each generated segment, at least a portion of the generated output computer code depends on a result of the respective logical contingency. However, each generated segment contains no output computer code that implements the respective logical contingency.","Optionally, the code generator is configured to generate the plurality of asynchronous output computer code segments, such that for each generated segment a logically earlier segment does contain output computer code that implements the respective logical contingency.","Optionally, the logical contingency comprises at least one of a user interface instruction; a transfer of control instruction; an external entry point; and a reference to a loosely-defined variable type.","Optionally, the input computer code of the synchronous application is of a first computer programming language, and the syntax tree transformer is configured to develop the translated syntax tree according to a second computer programming language different than the first computer programming language.","Yet another embodiment of the present invention provides a computer-implemented method of generating output computer code, for an application executable via a server running application logic in communication with a client running presentation software for the application, from input computer code of a synchronous application in which logic and presentation software run locally on a single computer. The method of this embodiment includes computer processes performing operations, including parsing the input computer code to develop an original syntax tree and analyzing the original syntax tree to identify user-interface function calls and nodes of the tree that are dependent on such function calls. A translated syntax tree is developed from the original syntax tree, wherein the user interface calls are mapped to corresponding translated calls in a client user interface. In addition, each node dependent on a given call is mapped to follow the translated call corresponding to the given call. Output code is generated from the translated syntax tree. The generated output code implements an asynchronous client-server model.","In a further related embodiment, the method further includes: before generating output code, remapping the syntax tree according to a dependent program flow.","Alternatively or in addition, the asynchronous client-server model includes processes, for each user interface function call, including: serving to the client a presentation screen, configured to enable the client to notify the server in the event of a client request for a presentation layer action; running logical processes until client input is required; storing a callback function and sending to the client a response to the client request; receiving from the client a message asking whether additional user input is required; sending to the client a response message indicating whether additional user input is required; if additional user input is required, receiving from the client a request for a presentation characterization by which the additional user input can be obtained; generating the presentation characterization; sending the presentation characterization to the client; receiving the additional user input; and running the callback function.","In a further embodiment, the method further includes repeating the foregoing processes, beginning at the point of storing the callback function, until no further user input is required.","Optionally, the input code is written in a language and the output code is written in the same language. The language may, for example, be JavaScript or Java.","Alternatively, the input code is written in a first language and the output code is written in a second language that is different from the first language. For example, the first language may be @Formula and the second language may be JavaScript. Alternatively, the first language may be LotusScript and the second language may be Java. In yet another related embodiment, the first language may be Visual Basic and the second language may be C#. Alternatively, the first language may be Visual Basic and the second language may be Java.","An embodiment of the present invention provides a computer-implemented method of generating asynchronous application program output computer code from input computer code of a synchronous application, the method comprises automatically parsing the input computer code to develop an original syntax tree, automatically developing, from the original syntax tree, a translated syntax tree that is semantically equivalent to the original syntax tree, automatically analyzing at least one of the original syntax tree and the translated syntax tree to identify a plurality of nodes, each node representing a respective instruction that potentially might not be executed as a result of a respective logical contingency, automatically defining a boundary in the translated syntax tree logically prior to each identified node; and automatically generating a plurality of asynchronous output computer code segments. Each generated segment contains output computer code generated from a portion of the translated syntax tree between two consecutive boundaries. At least a portion of the generated output computer code of each generated segment depends on a result of the respective logical contingency. Each segment contains no output computer code that implements the respective logical contingency.","The automatic generation of the boundaries allows transforming the translated syntax tree of the input computer code into asynchronous computer code segments.","The beginning and the ending of the asynchronous application program output computer code may form a respective first and last boundary.","In a further related embodiment, the method comprises generating the plurality of asynchronous output computer code segments, such that for each generated segment, a logically earlier segment does contain output computer code that implements the respective logical contingency.","In a manner similar to that of ,  show input Formula code and AST (), translated Formula AST (), generated Formula code () and generated SSJS code () of two blocking expressions, according to embodiments of the present invention.","In a manner similar to that of ,  show input Formula code and AST (), translated Formula AST and generated Formula code () and generated SSJS code () of a blocking @if condition, according to embodiments of the present invention.","In a manner similar to that of ,  show input Formula code and AST (), translated Formula AST and generated Formula code () and generated SSJS code () of a blocking @If \u2018then\u2019 expression, according to embodiments of the present invention.","Definitions. As used in this description and the accompanying claims, the following terms shall have the meanings indicated, unless the context otherwise requires:","A \u201csingle computer\u201d is an individual computer for use by an individual user. When logic and presentation software run locally on a single computer, the single computer might still access data, stored on a server, that may be shared with other users.","A \u201ccomputer\u201d includes a desktop machine, smartphone, tablet device, or personal digital assistant.","A described \u201cprocess\u201d is the performance of a described function in a computer using computer hardware (such as a processor, field-programmable gate array or other electronic combinatorial logic, or similar device), which may be operating under control of software or firmware or a combination of any of these or operating outside control of any of the foregoing. All or part of the described function may be performed by active or passive electronic components, such as transistors or resistors. In using the term \u201cprocess\u201d we do not necessarily require a schedulable entity, although, in some embodiments, a process may be implemented by such a schedulable entity. Furthermore, unless the context otherwise requires, a \u201cprocess\u201d may be implemented using more than one processor or more than one (single- or multi-processor) computer.","Embodiments of the present invention automatically translate (convert) a synchronous application program into a semantically equivalent asynchronous application program. That is, the synchronous application program code is parsed, and new asynchronous application program code, functionally equivalent to the parsed code, is emitted, as schematically illustrated in . The parsed synchronous application program  includes application logic  and presentation software . The synchronous application program  is executed by a single computer . The synchronous application program  may communicate, such as via a computer network , with a server , which serves data  to the synchronous application program . The server  may serve the data  to other application programs (not shown). That is, the data  may be shared by several application programs (not shown).","The new asynchronous application program code includes a presentation layer , executed by a client computer , and an application logic layer , executed by a server . The presentation layer  may be implemented as a conventional browser. Thus, no actual new computer code may need to be generated for the presentation layer . The presentation layer  and the application logic layer  may communicate with each other via a computer network . As described above, the server  may serve data  to the application logic layer , or another server (not shown) may serve data (not shown) to the application logic layer .","As indicated by arrow , embodiments of the present invention translate the synchronous application program  into a semantically equivalent asynchronous application program that includes the application logic layer  and, optionally, the presentation layer . The left portion of  is a schematic block diagram of a hypothetical synchronous application program , which may be an example of the synchronous application program  shown in .","The hypothetical synchronous application program  performs several illustrative operations. Each operation may include one or more program statements and\/or instructions. At , the synchronous application program  may, for example, include program code to initialize variables, etc. Next, at , the synchronous program  may prompt a user for input and at  receive the user's input. At , the synchronous program  may process the received user's input. At , data may be read from a remote database, and at  the read data may be processed. At  the synchronous application  may execute a conditional branch, such as a conditional branch based on results of the processing of the data read from the database and\/or based on the user's input. At , the application program  may include an entry point (such as a location represented by a global or universal label), by which an external program (not shown) may call or transfer control to a routine in the synchronous application . At , the synchronous application program  may call or transfer control to an external routine in another application program, library, service routine, application programming interface (API), operating system routine or the like (not shown). At , the synchronous application program may conditionally or unconditionally loop back to the beginning of the application program  or to another point within the application program . As noted, each of the operations - may be represented by one or more program statements and\/or instructions. Furthermore, a single program statement may combine several of the operations -. For example, the statement \u201cIF EXISTS MyFile.txt (ECHO The file already exists)\u201d includes obtaining information from a data manager and then conditionally performing a user output operation, based on the obtained information.","In order to generate a semantically equivalent asynchronous application program, embodiments of the present invention automatically parse the synchronous program  to identify boundaries, beyond which logical flow potentially might not proceed, i.e., boundaries beyond which a processor potentially might not execute instructions, depending on an external event, as described in more detail below. A situation where logical flow potentially might not proceed is referred to as a logical contingency. For example, a function that collects user input might not complete, because the user might not provide the input. In another example, a branch in a conditional instruction might not be executed, because the condition is not satisfied. Likewise, a global entry point might not be transferred to from an external routine.","These embodiments automatically generate a set of asynchronous application program segments - (collectively ), shown on the right side of . In addition, there may be an initial and\/or final asynchronous application program segment. Each asynchronous application program segment  corresponds to one of the boundaries. The asynchronous application program segment includes instructions that perform processing semantically equivalent to processing performed by a (not necessarily continuous) corresponding portion of the instructions in the synchronous application program , up to the boundary. However, the instructions in the generated asynchronous application program segments  may not be in the same order as the corresponding instructions in the synchronous application program . In addition, the asynchronous application program segments  may be generated using a different programming language than the synchronous application program . For illustration, boundaries - are shown by dashed lines between respective adjacent pairs of asynchronous application program segments . No corresponding boundaries are shown in the synchronous application program , because these boundaries may lie within some single program statements, as well as between single program statements, depending on the coding of the synchronous application program . The asynchronous application program segments  are generally executed in sequence. However, they may be executed out of sequence, and some of the segments  may be skipped, based on control flow logic, user inputs, errors, etc. For example, the last segment  may include an error handling routine that is invoked in case of an error, such as an attempted division by zero or a subscript (index) out-of-bound condition. The error handler may return control to one of the other segments, such as after resolving the error.","As noted, boundaries are defined, such that beyond each boundary, logical flow potentially may not proceed, i.e., a processor potentially may not be able to execute instructions beyond the boundary, depending on an external event. All instructions that depend on the event are moved to below the boundary. For example, user input is received at  in the synchronous application program . The first instruction that relies on this user input cannot be executed until after the user's input has been received. Thus, a boundary is defined logically before this instruction. This instruction in the synchronous application program , and subsequent instructions in the synchronous application program , is blocked until the user input has been received. It is possible that the user never provides the input, in which case the blocked instruction is never unblocked. In any case, human input time scales are much longer than instruction execution time scales. Thus, even if the user provides the input quickly (relative to the human time scale), the instruction must be blocked for a long time (relative to the instruction execution time scale).","The synchronous application program  may include program code that can execute before the user input is received. For example, after the user has been prompted at , but before the user input has been received at , the synchronous application program  may perform various calculations, etc. that do not depend on the user's input. An asynchronous application program segment (assume segment ) is generated that includes semantically equivalent instructions that perform these calculations, etc. However, the program segment  may include semantically equivalent instructions that perform logical processing that is performed after the user's input has been received in the corresponding logic processing of the synchronous application program , as long as these instructions do not rely, directly or indirectly, on the user's input. In other words, embodiments of the present invention may, when generating asynchronous application program segments , rearrange the application logic of the synchronous application program . Some processing logic may be moved to before or after other processing logic, and specifically to positions within the asynchronous application program segment  before or after instructions that correspond to instructions in the synchronous application program  that may be blocked. However, as noted, instructions are not moved to positions before all their respective required data are available.","Selecting which application logic of the synchronous application program  may be safely rearranged is a form of optimization, similar to optimizations performed by modern computer language compilers. Techniques for identifying candidate instructions in the synchronous application program  for such optimization and implementing the optimizations are within the capabilities of ordinarily skilled practitioners in the art of optimizing compiler design.","The example given above, of defining a boundary before an instruction that depends on user input, is an example of a general class of instruction known as a blocking instruction. Thus, a boundary should be defined before any instruction that potentially may be blocked from execution, pending an external event. A non-exhaustive list of exemplary potentially blocking instructions includes: input\/output instructions that impact a user interface, instructions that request performance by a data manager, particularly if the data manager is remote from the server on which the asynchronous application program segments are executed or if performance by the data manager involves an input\/output operation from\/to a mechanical peripheral, such as a spinning disk drive; network communications instructions; and timer instructions, such as SLEEP or WAIT.","This process of defining boundaries and generating corresponding asynchronous application program segments  continues until all the application logic of the synchronous application program  is included in the set  of generated asynchronous application program segments. Each asynchronous application program segment  ends with an instruction that causes a display on the user interface, a request for a user input or some other blocking instruction. (As will be discussed below, an asynchronous application program segment  may end with another type of instruction or begin with a labeled entry point. However, for simplicity of explanation, for the moment we limit the description to blocking instructions.)","Referring back to , when the generated asynchronous application executes, the application logic layer  performs functions defined in the generated asynchronous application program segments , and the presentation layer  provides the user interface. For example, the first asynchronous application program segment  is executed by the server , which may initialize variables, etc., and end by commanding the presentation layer to prompt the user. The presentation layer  may be implemented by a conventional browser, and the asynchronous application program segments  may send conventional markups, such as in HTML, XML or JSON, to the presentation layer  to cause the presentation layer  to render the user interface and collect user inputs and return the inputs to the application logic layer .","Once the user has been prompted, the presentation layer  notifies the application logic layer , which then invokes the next logical asynchronous application program segment . For the sake of this example, assume the next segment  performs some arithmetic operations and ends by commanding the presentation layer to solicit a user input in response to the previously displayed prompt. Once the presentation layer  has collected the user input and sent it to the application logic layer , the application logic layer  invokes the next logical asynchronous application segment , and so on.","Thus, control passes back and forth between the application logic layer  and the presentation layer , and a chain of asynchronous application program segments  is executed. The sequence of instructions collectively executed by the application logic layer , i.e., the chain of asynchronous application program segments , (and optionally the presentation layer ) may be thought of as a session dedicated to the user. As noted, the application logic layer  may simultaneously (or at least apparently simultaneously, as implemented by a time-shared scheduler\/operating system) service many users, each with her own session. Thus, context information for each session must be stored, at least between executions of successive asynchronous application program segments, such as between segments  and .","Each asynchronous application program segment  may store context information that will enable the next logical segment to execute. This context information is preferably stored on the server . For example, one embodiment is implemented using the well-known JavaServer Faces (JSF) web application framework, which stores session context information on the server. However, optionally or alternatively, the context information may be passed to the presentation layer , and the presentation layer  may subsequently return the context information to the application logic layer , once the user input has been received (or the blocking event has been resolved, as the case may be). For example, when an asynchronous application program segment  ends by invoking the presentation layer, the asynchronous application program segment  may include an address of a callback routine in the invocation (and parameters representing the context information to be passed to the callback routine).","The callback routine address may be the address of the next asynchronous application program segment  to be executed, and the parameters may include the context information. After the user input has been collected, the presentation layer  may invoke the callback function. Optionally or alternatively, a dispatcher in the application logic layer  may use the address of the callback routine (or some other portion of the context information) to invoke the appropriate asynchronous application program segment  and pass the parameters to the invoked program segment. Other well-known techniques, such as co-routines or lightweight processes, may be used as alternatives to callback routines. In some embodiments, a Java Virtual Machine (JVM) is used for each user session. In these cases, context information may be saved within the JVM, such as while awaiting user input.","As noted, an external event may merely delay execution, i.e., delay unblocking, of an instruction until the blocking situation is resolved. However, it should be recognized that the external event may never be complete. For example, a user may cancel an operation, rather than provide an input. In this case, the blocked-for user input is never provided. The asynchronous application program should, therefore, be generated with a timeout or other mechanism for handling unresolved external events. For example, such a timeout mechanism may be provided by a web server framework that serves the application program.","Boundaries are, therefore, defined for each potentially blocking instruction. In addition, a boundary should be defined for each potential entry point. For example, at  (), the application program  includes an entry point (such as a location represented by a global or universal label or symbol), by which an external program (not shown) may call or transfer control to a routine in the synchronous application . A boundary should be defined logically before such an entry point, because the entry point may never be called (analogous to a blocked-for user input never being received). Furthermore, execution beginning at the entry point should not depend on any event (logically earlier in the logic flow) that has not already occurred. In addition, it is not necessarily possible to predict variable data values upon a transfer of control to the entry point.","Although this example involves a potential transfer of control in from an external routine or program, a boundary should be defined for any potential transfer of control in, even from other portions of the same application program. Thus, any potential conditional or unconditional transfer of control, including IF, GOTO, DO, WHILE, UNTIL, NEXT, CALL, RESUME or ON ERROR GOTO, should have a boundary that corresponds to each potential destination. Thus, for example, a boundary should be defined for each loop in the synchronous application program . In the case of a call or transfer from another routine or program, all necessary context should be passed to the entry point, such as via parameters of a CALL instruction.","Optionally, but preferably, a boundary should also be defined for each potential transfer of control out of, or to another location within, an asynchronous application program segment , such as via a GOTO or CALL instruction.","In addition, a boundary should be defined for each reference to a variable having a loosely defined type, such as a VARIANT data type, because loosely defined variable types may not have behaviors that are fully determined at compile time. For example, evaluation of a VARIANT data typed variable may involve a function call, which is a transfer of control out of the current control flow.","As noted, some statements (such as complex IF statements, particularly IF statements that reference user inputs) in a synchronous application program  () may involve two or more layers of nesting, with potential blocking instructions or control transfer instructions included at each layer. For example, \u201cIF EXISTS MyFile.txt (ECHO the file already exists)\u201d is nested in that existence of a file named MyFile.txt must be ascertained before the conditional (IF) is executed, and the condition must be evaluated before the ECHO can be executed. These statements should be parsed, from the inner most layer toward the outer most layer, and converted into a series of unary statements. A unary statement can contain at most one instruction that may cause a boundary to be identified. Once such a complex statement is broken down into a series of unary statements (or, equivalently, corresponding nodes in a tree, as described below), the unary statements (or nodes) may be analyzed for placement of boundaries.","As a further note, in many cases, the generated asynchronous application program segments  are generated in a language (referred to herein as a \u201cdestination language\u201d) different than the language of the synchronous application program . Thus, statements in the generated language essentially emulate statements in the synchronous application program  (referred to herein as a \u201csource language\u201d). This emulation should include emulation of idiosyncrasies of the source language and error conditions. For example, a conditional (ex. IF) statement in the synchronous application program  may involve a comparison of two variables, and these variables may be of different data types (ex., string and integer). Depending on the source language, one of these variables may be automatically converted to the type of the other variable to facilitate the comparison. However if, for example, the string variable contains a string (such as \u201cFred\u201d) that does not convert into a numeric value, an error may be thrown within the synchronous application program . Consequently, the corresponding generated asynchronous application program segment should emulate the behavior of the synchronous application program , even if the destination language does not automatically convert data types. Furthermore, since such a converted conditional statement may generate an error, a boundary should be defined in association with the possibility that control will change as a result of the error occurring.","In general, the asynchronous application program segments  are generated by parsing the program code of the synchronous application program  (exemplified by program ) to generate an abstract syntax tree (AST). The AST is then analyzed to locate boundaries, and the asynchronous application program segments  are generated according to the boundaries. Operations involved in generating the asynchronous application program segments  are summarized in a flowchart shown in . At , the synchronous application program code is parsed to generate a first abstract syntax tree (AST). A conventional tool, such as ANTLR (ANother Tool for Language Recognition), may be used for this purpose. ANTLR takes as input a grammar that specifies a language and generates as output source code for a recognizer for that language. If a grammar for the source language is not available, defining such a grammar is within the capabilities of an ordinarily skilled practitioner in the field of computer language design and analysis or compiler design. ANTLR allows generating parsers, lexers, tree parsers and combined lexer-parsers. Parsers can automatically generate abstract syntax trees, which can be further processed with tree parsers. ANTLR provides a single consistent notation for specifying lexers, parsers and tree parsers.","At , the first AST is analyzed to identify boundaries and nodes that depend on external events (such as user inputs that are obtained by other nodes in the tree), definite and potential transfers of control, references to VARIANT data types, etc., as described above. At , a translated syntax tree is developed. The translated syntax tree includes nodes, such that the translated syntax tree is semantically equivalent to the first AST tree. The translated syntax tree is constructed according to the destination language. However, as discussed above, operations may be performed in a different order, according to the translated tree, than according to the first AST. At , generated asynchronous application program output code is generated from the translated syntax tree. As noted, the generated code is in the form of asynchronous application program segments, according to the identified boundaries.","Lotus Notes provides an example of a context in which converting synchronous to asynchronous application programs is particularly valuable. Organizations using Lotus Notes applications have decades of investment in a proprietary technology with weak documentation and poor standards support for manipulation of application behavior. Modernizing these applications, whether to account for new client platforms, update design or extend features, involves expensive and delicate manual changes through IBM's proprietary platform, when accomplished according to the prior art. However, automatic conversion using techniques described herein greatly simplify and reduce the cost of such efforts.","One implemented embodiment of the present invention is called Domino Application Translator (DAT), which has been used successfully to convert Lotus Notes synchronous applications to asynchronous applications, as will now be described. DXL (Domino Extensible Language) is a specific version of Extensible Markup Language (XML) for Lotus Domino data. DXL can be used to export a complete user interface and business logic specification of a Lotus Notes application to a defined XML schema. DAT reads an existing Lotus Notes application and generates an XML tree of constituent nodes. DAT analyzes the nodes and maps each node to a corresponding node in Xpages. Xpages is an implementation of the Oracle JavaServer Faces specification for web application servers. The Xpages nodes are recombined to match the original application's tree, creating a new application that is semantically equal to the original application, but based on up-to-date technology.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 4"},"In , the input code can be a Lotus Notes application . The Lotus Notes application  may be, for example, written in @Formula or in LotusScript, or a combination thereof. An export format, namely DXL, is available for use in the Lotus Notes environment in which the Lotus Notes application  is parsed into an XML syntax tree  representing structure of the application, with respect to the user interface and control logic.","The Domino Application Translator (DAT)  operates on the XML tree  to develop, from that tree, a translated syntax tree, shown here as XPages (XPS)  having special properties. Namely, (a) the user interface calls and other instructions that cause identification of boundaries in the input computer code are mapped to corresponding translated calls and (b) each node dependent on a given call is mapped to follow the translated call corresponding to the given call. The XPages document  defines a specification for a web application server that runs the resulting output code. Accordingly the XPages document  is used to generate Java source code . The Domino Application Translator , in appropriate circumstances (for example, when the input code includes synchronous LotusScript) also translates some of the input code into Java source code. The Java source code in turn is compiled into executable code .",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 5","b":["500","502","500","500"]},"The AST tree  is analyzed to identify boundaries. As noted, signatures for boundaries include user interface function calls (exemplified by X and C in , although such calls may be at any level of the AST ), as well dynamic program flow control (such as a \u201cGOTO\u201d) and other constructs, as described above.","Next a translated syntax tree  is developed, shown on the right hand side of . In the translated syntax tree , the function call X has been promoted (moved higher in the hierarchy of the tree), so it can be referenced by nodes lower in tree. Although the function call C is blocking, the function call represents a stand-alone statement; function call C is not promoted out of a complex statement, i.e., one that uses a temporary variable while waiting for the blocking situation to be resolved. The translated syntax tree  defines an asynchronous pattern, which is used to generate the code of the asynchronous application program. For example, boundaries  and  delimit three respective program segments ,  and .","Function calls X and C may, for example, request user input which, as discussed, would in a synchronous context be blocking. However, in the translated syntax tree , function calls X and C are made the last function calls in their respective synchronous application program segments  and . Thus, once these function calls are made, the session context is stored, and the segment execution ends. References to the user inputs appear only in synchronous application program segments subsequent to the segments in which the function calls X and C appear. For example, Node Xref  refers to user input that is sought by function call X.","Promotion is a standard tree pruning operation known in the field of computer science. A promoted node and all its child nodes are moved to become a preceding child of the containing statement block. It should be noted that, at least when dealing with complex syntax, nested statements may exist in a single AST. Promotion should be performed in a way that preserves the syntactic meaning an order of operations, i.e., statements should not be arbitrarily evaluated if their evaluation was not previously dependent on one or more conditional statements. To ascertain what constitutes blocking and boundary nodes, embodiments of the present invention perform operations listed in Table 1.",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1. ","Perform a left-order tree traversal to determine data types of nodes "]},{"entry":[{},"using a registry"]},{"entry":["2. ","Perform a right-order traversal of the tree to identify and promote "]},{"entry":[{},"blocking and boundary elements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 6","FIG. 6"],"b":["603","605","608","610","615","618","620","623","625","628"]},"As noted, a synchronous application program is analyzed to generate a series of asynchronous application program segments. The analysis lexical analysis of the synchronous application program, i.e., generation of tokens, based on a grammar for the computer language in which the synchronous application program was written. A lexer (i.e., a lexical analyzer or tokener) may use a standard ANTLR grammar to lexically analyze the synchronous application program. Similarly, a standard ANTLR grammar may be used to read the tokens and generate a corresponding concrete syntax tree. The concrete syntax tree may be converted to a custom Formula (for example) abstract syntax tree (AST), based on an Eclipse Modeling Framework (EMF) model, another suitable model or a grammar processing tool, such as String Templates. The AST may then be analyzed, bottom-up, to mark functions as being blocking or non-blocking, based on definitions of the functions stored in a configuration file or other store. Code block that are reachable by GOTO constructs (if supported by the source langue) are marked. Each expression may then be marked as blocking or non-blocking, based on whether its children are blocking. The AST may then be transformed to emit a modified AST.","Statements containing blocking function calls are expanded, and the blocking functions are promoted to unary statements to provide a clear boundary between blocking and non-blocking statements, as well as to prevent nested blocking function calls. Complex expressions that contain blocking function calls are simplified until they contain nothing except blocking unary function calls or assignment expressions. Some Flow Control constructs may be incompatible between the source language (for example, LotusScript) and the target language (for example, Java). The AST is modified to ensure clear boundaries exist between callable statement blocks, in addition to the above processes. Optionally, optimizations may then be performed on the AST to remove redundancy.","Statements containing blocking function calls are expanded and the blocking functions are promoted to unary statements to provide a clear boundary between blocking and non-blocking statements as well as prevent nested blocking function calls. If a statement has one or more arguments which are blocking it will be simplified. All non-primitive arguments, up to and including the blocking statements, are promoted to temporary assignment expressions to prevent side-effects. For example, if the source language is LotusScript and the code contains:\n\n",{"@attributes":{"id":"p-0091","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"t1 =ws.DialogBox(\u201cdialogForm\u201d, ...)"]},{"entry":[{},{},"If t1 Then"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Examples of such transformations are presented next.","A function that has one or more arguments that are blocking is simplified. All arguments, up to and including the blocking ones, are promoted to temporary assignment expressions.","Complex expressions that contain blocking functions are simplified, until they contain nothing except blocking unary or assignment expressions. An expression is considered complex if it contains one or more blocking functions and is not in one of the two following forms:",{"@attributes":{"id":"p-0095","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"@Blocking( ) ; or"]},{"entry":[{},{},"x := @Blocking( ) ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"For complex expressions, all primitive expressions up to and including the blocking ones are promoted to temporary assignment expressions, and the original expression is replaced with one that refers to the temporary variables.","Some Flow Control constructs may be incompatible between the source language (LotusScript) and the target language (Java). The AST is modified to ensure clear boundaries between callable statement blocks, in addition to the above processes. Examples of incompatible flow control construct are the following LotusScript constructs: GOTO, ON ERROR GOTO and RESUME. Code Appendix B, which is hereby incorporated herein, contains an example of flow control conversion.","Various optimizations may then be performed on the AST to remove redundancy. An example of this type of optimization is redundant nested statement blocks, with no side-effects or conditional execution. These would be rolled-up into a single statement block.",{"@attributes":{"id":"p-0099","num":"0099"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0100","num":"0100"},"figref":["FIG. 8","FIG. 7","FIG. 8","FIG. 8","FIG. 7","FIG. 8","FIG. 8","FIG. 5"]},"In the first generated code segment, the value of the variable named \u201cy\u201d is stored in a temporary location named \u201ctmp0,\u201d and the @Prompt function is invoked. The first code segment execution then ends. Once the user has clicked on one of the buttons, the value returned by the @Prompt function is stored in a variable named \u201ctmp1,\u201d and second code segment begins executing. The second code segment adds the values stored in the temporary variables tmp0 and tmp1 and the value stored in \u201cz\u201d and stores the sum in the variable named \u201cx.\u201d","Similarly,  shows semantically equivalent Server-Side JavaScript (SSJS) code that may be automatically generated in a similar manner, according to embodiments of the present invention, as discussed above with respect to .","Nested @Do expressions are reduced to a single @Do or a sequence of expressions. In cases of an @Do which is a direct child of an @Do or a Formula then inner @Do is removed. For example:",{"@attributes":{"id":"p-0104","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"@Do("]},{"entry":[{},{},"x := 1 ;"]},{"entry":[{},{},"@Do("]},{"entry":[{},{},"a := 1 ;"]},{"entry":[{},{},"b := 2 ;"]},{"entry":[{},{},") ;"]},{"entry":[{},{},"y := 2"]},{"entry":[{},{},") ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0105","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"@Do("]},{"entry":[{},{},"x := 1 ;"]},{"entry":[{},{},"a := 1 ;"]},{"entry":[{},{},"b := 2 ;"]},{"entry":[{},{},"y := 2"]},{"entry":[{},{},") ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In a manner similar to that of ,  show input Formula code and AST (), translated Formula AST (), generated Formula code () and generated SSJS code () of two blocking expressions.","In a manner similar to that of ,  show input Formula code and AST (), translated Formula AST and generated Formula code () and generated SSJS code () of a blocking @if condition. The @if function has the following syntax:",{"@attributes":{"id":"p-0108","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"@If( <Condition>; <Result_If_True>; [<ElseIf_Condition>;"]},{"entry":[{},"<Result_If_True>;]* <Result_If_False>);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In a manner similar to that of ,  show input Formula code and AST (), translated Formula AST and generated Formula code () and generated SSJS code () of a blocking @If \u2018then\u2019 expression. The \u201c@Prompt\u201d function call need not be promoted, because the function call is within its own statement block, which needs to be conditionally executed, i.e., the value of the function call cannot be assigned to a temporary variable above (i.e., earlier than) the \u201cIf\u201d instructions.","In a manner similar to that of , Code Appendix A, which is hereby incorporated herein, contains four additional examples of automatic translations. These examples assume LotusScript source language and Java Interface destination language.","The systems and methods for automatic converting a synchronous application, in which logic and presentation software may run locally on a single computer, to an asynchronous application, described above, may be implemented as computer instructions stored in a memory and executed by a processor. The memory may be random access memory (RAM), read-only memory (ROM), flash memory or any other memory, or combination thereof, suitable for storing control software or other instructions and data. Some of the functions performed by the system have been described with reference to flowcharts and\/or block diagrams. Those skilled in the art should readily appreciate that functions, operations, decisions, etc. of all or a portion of each block, or a combination of blocks, of the flowcharts or block diagrams may be implemented as computer program instructions, software, hardware, firmware or combinations thereof. Those skilled in the art should also readily appreciate that instructions or programs defining the functions of the present invention may be delivered to a processor in many forms, including, but not limited to, information permanently stored on non-writable storage media (e.g. read-only memory devices within a computer, such as ROM, or devices readable by a computer I\/O attachment, such as CD-ROM or DVD disks), information alterably stored on writable storage media (e.g. floppy disks, removable flash memory and hard drives) or information conveyed to a computer through communication media, including wired or wireless computer networks. In addition, while the invention may be embodied in software, the functions necessary to implement the invention may optionally or alternatively be embodied in part or in whole using firmware and\/or hardware components, such as combinatorial logic, Application Specific Integrated Circuits (ASICs), Field-Programmable Gate Arrays (FPGAs) or other hardware or some combination of hardware, software and\/or firmware components.","While the invention is described through the above-described exemplary embodiments, it will be understood by those of ordinary skill in the art that modifications to, and variations of, the illustrated embodiments may be made without departing from the inventive concepts disclosed herein. For example, although some aspects of system have been described with reference to a flowchart, those skilled in the art should readily appreciate that functions, operations, decisions, etc. of all or a portion of each block, or a combination of blocks, of the flowchart may be combined, separated into separate operations or performed in other orders. Moreover, while the embodiments are described in connection with various illustrative data structures, one skilled in the art will recognize that the system may be embodied using a variety of data structures. Furthermore, disclosed aspects, or portions of these aspects, may be combined in ways not listed above. Accordingly, the invention should not be viewed as being limited to the disclosed embodiment(s)."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be more fully understood by referring to the following Detailed Description of Specific Embodiments in conjunction with the Drawings, of which:",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 8","FIG. 7","FIG. 8"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 9","FIG. 8"]}]},"DETDESC":[{},{}]}
