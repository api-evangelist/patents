---
title: Systems and methods for self-intersection avoidance in ray tracing
abstract: Aspects include systems, methods, and media for implementing methods relating to detection of invalid intersections during ray tracing. Invalid intersections can arise from imprecision in computer-based number representation, causing ray origins to be located inappropriately. In some aspects, a ray can be associated with information relating to an expected angle between the ray's direction and a normal for a to-be-identified primitive intersected by that ray. If the angle between the ray's direction and the normal of an intersected primitive is within expectations, then that information can be used in predicting whether the intersection is valid. Such expectation information can be presented as a single bit determined by a shader performing a dot product of the ray and a normal of a primitive intersected by a parent ray, or can be obtained as a by-product of ray/primitive intersection testing. Such information also can be based on whether the shader is emitting to have reflection or refraction type ray behavior.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08441482&OS=08441482&RS=08441482
owner: Caustic Graphics, Inc.
number: 08441482
owner_city: San Francisco
owner_country: US
publication_date: 20090921
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field","The following relates generally to ray tracing systems that can be used, for example, in rendering 2-D representations of 3-D scenes, and more specifically to handling self-intersection effects due to limited precision calculations.","2. Related Art","Rendering photo-realistic 2-D images from 3-D scene descriptions with ray tracing is well-known in the computer graphics arts. Ray tracing usually involves obtaining a scene description composed of geometric shapes, which describe surfaces of structures in the scene, and can be called primitives. A common primitive shape is a triangle.","Virtual rays of light are traced into the scene from a view point (\u201ca camera\u201d); each ray is issued to travel through a respective pixel of the 2-D representation, on which that ray can have an effect. The rays are tested for intersection with scene primitives to identify a closest intersected primitive for each ray, if any.","After identifying an intersection for a given ray, a shader associated with that primitive determines what happens next. For example, if the primitive is part of a mirror, then a reflection ray is issued to determine whether light is hitting the intersected point from a luminaire, or in more complicated situations, subsurface reflection, and scattering can be modeled, which may cause issuance of different rays to be intersection tested. By further example, if a surface of an object were rough, not smooth, then a shader for that object may issue rays to model a diffuse reflection on that surface. As such, finding an intersection between a ray and a primitive is a step in determining whether and what kind of light energy may reach a pixel by virtue of a given ray, since what light is hitting that primitive still needs to be determined.","When a primitive has been found to be intersected by a ray, and the shader for that intersection is to be executed, an intersection point of the ray is defined based on where the intersection on the primitive was found. This intersection point is to serve as the origin for child rays that a shader may cast when shading this intersection.","This origin is usually implemented as a floating point tuplet of a certain precision, such as single precision or double precision. Primitives and other objects that generally can be intersected in a scene are smooth surfaces, which also \u201cexist\u201d at points in 3-space. Therefore, these scene surfaces exist at points in the scene that cannot be precisely represented by a number of a given precision. This is true whether single or double precision floating point is used (or even some more precise number interpretation), as computers are expected to have a capability to represent numbers only to a finite precision. This is true also for at least the practical reason that the more precise a number representation is to be, the more data is required to represent that number.","Therefore, the intersection point (origin for child rays) in the abstract represents a point on a surface determined to have been intersected by a ray, and ideally would serve as the exact origin for new rays resulting from shading. However, that point can only be expressed to a finite precision, and thus, the data describing the point, as it is stored, can have, and quite often does have, errors that place the intersection point off the surface of the scene that was intersected.","One problem that results is that child rays can have false intersections with the same primitive that their parent ray intersected. Another problem is that rays can fail to intersect a primitive that they were supposed to intersect. These intersection errors can result in rendering errors, such as gaps between portions of an object.","Currently, there are two known approaches to this problem, which is often called the \u201cself-intersection\u201d problem. One approach is to define a sphere of small radius around the intersection point (origin for child rays), and when a potential intersection is identified, a determination is made whether that intersection is outside of that sphere. This approach thus is directed to the situation where a child ray hits the same primitive as its parent.","Another approach to this problem has been to tag each child ray with information that identifies the origin primitive of that ray (i.e., the primitive whose shader spawned the child ray). Then, when a potential intersection for that child ray is identified, the potentially intersected primitive is compared with the origin primitive, and if they match, the intersection is rejected. A practical solution that uses this approach often can require further processing, such as an adjacent face rejection decision in which all vertices of a hit primitive are checked to see whether any of those vertices are in common with those of the origin primitive, and then the angle of incidence for the child ray is compared with that of the parent ray. Given that billions of intersection tests need to be performed in high quality ray tracing-based rendering, it is desirable to avoid these tests, which are relatively expensive to implement. These tests also do not necessarily give perfect results, as they are heuristic in nature.","As introduced above, some aspects of the present disclosure are for ray tracing a 3-D scene while handling inaccuracies caused by imprecision of number representation in computers. The following summary describes example aspects within the scope of the claims and disclosure.","A ray can be described with a direction vector and an origin. At the point of intersection between a ray and the surface, there is a normal direction. Where the surface is composed of primitives, such as triangles, the normal direction can be included with the definition for the primitive intersected.","One example aspect includes a method which comprises identifying an intersection between a child ray and a surface in the 3-D scene. The child ray can be emitted during shading of an intersection involving a parent ray.","The method comprises characterizing an angle between the child ray and the normal of the surface at the child ray intersection. The method also comprises categorizing the child ray intersection as a potentially valid or as a potentially invalid intersection based on the characterization of the angle and on information characterizing the direction of the child ray compared with a normal of the surface at the intersection involving the parent ray.","Thus, the child ray direction is compared both with the normal of a surface intersected by a ray, for which shading of an intersection resulted in the child ray, and with the normal of a surface intersected by the child ray itself. In some cases, an invalid intersection can be where the child ray was found to intersect the same surface as the parent ray. Typically, such an invalid circumstance can result where due to numerical imprecision, an origin of the child ray is placed on one side of the surface intersected by the parent ray or the other.","In one aspect, a dot product between the child ray direction and each of the surface normals is taken, and the sign resulting from each dot product is compared with the other. In some aspects, the sign of the dot product between the child ray direction and the normal for the surface intersected by the parent ray can be stored as a bit in a data structure representative of the child ray. Other ways to obtain information equivalent to the described dot product sign can be provided, including using a information resulting from performing a three half-plane intersection test algorithm to implement the intersection testing, for example.","Further tests for intersection validity can include checking how far from an origin of the child ray, in the normal direction, the surface intersected by the child ray is. A further check, or a substitute check along the direction of ray travel also can be made.","Such methods can be implemented by systems. Such systems can be implemented with computer executable code used to configure processing resources; functional modules of code, custom logic, and the like can be used to implement such systems.","Further aspects include provision of an application programming interface that can be used by shaders (code executing responsive to identified intersections) to emit child rays for intersection testing. The application programming interface can include run time code for calculating a sign of the dot product between the child ray and the surface normal for the parent ray intersection. Data, such as the vector for that surface normal can be stored in data structures in a memory accessible to the shader run time code.","Still further aspects can include systems and computer executable code for implementing a scene processor that assigns normals or otherwise modify a scene description to make better usage of the described methods and systems.","The following primarily relates to using ray tracing as a mechanism to render 2-D representations of 3-D scenes. The 3-D scenes to be rendered often are created (specified) by artists who are designing content, such as a video game, a motion picture, an animated advertisement, industrial models, architectural features, such as buildings, and so on. An artist can be a person, or a person using authoring tools, or even can itself be primarily driven by software. To produce content descriptive of a 3-D scene, an artist contends with a number of challenges. For one thing, an artist describes the physical boundaries (surfaces) of the scene and the objects in it. The description of such physical boundaries can be detailed. For example, a useful model of a car being designed using Computer Aided Design (CAD) requires precise specification of the components of the car as well as their spatial relation to each other.","The artist also describes how the surfaces of the scene objects should look and behave. For example, an accurate model of the car would represent window glass differently from a headlight glass, differently from a painted surface. For example, in a video game, the artist would model a skin surface differently from a hair surface, and so on.","Thus, one construct employed in the field of rendering is to provide a physical scene model, and associate surface information with different parts of the scene model. For example, a scene model can contain objects including a person, an automobile, and a building. The physical model of the scene would describe the surfaces of these objects, for example, as a wire frame model, which can include a large number of primitive shapes interconnected with each other to describe boundaries of the surfaces. This physical model generally lacks information about the visual appearance of the objects' surfaces. Then, information and programming is associated with particular surfaces, and\/or portions of particular surfaces that describe their appearance. Such information can include textures for the surfaces, while programming associated with the surfaces often is intended to model what effect the surface has on light hitting the surface. For example, programming allows modeling of glass, a shiny surface, a bumpy surface and so on. Such programming and information thus is bound or otherwise associated with portions of the physical model descriptive of those surfaces. For example, programming can be associated with or bound to a particular primitive. Such programming and other description, or portions thereof, for a particular primitive or scene object can be referred to generally as a \u201cshader\u201d for that primitive or object.","The following description, for clarity, primarily uses examples where scene objects being rendered are represented by meshes of simple planar shapes, such as triangles. In the context of such planar primitives, a normal direction to the planar surface can generally be predetermined and assigned. However, objects for which intersection testing can be performed can be described with other methodologies, such as parametric methodologies, such as B\u00e9zier patches. In these contexts, a surface does not necessarily have a single normal direction. Rather, upon identifying an intersection point between the surface and a given ray, a normal of the surface at that intersection point can be identified. Thus, a normal vector in the following description encompasses both a normal for an entirety of a planar surface and a normal vector identified for a particular intersection point on a planar or non-planar surface.","Computers represent real numbers with finite precision, and when implementing these models, inaccuracies and visual artifacts can be caused by imprecision.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 1A","FIG. 1B","FIG. 1B"],"b":["105","106","105","106","105","104","120","125","130","135","107","108","109","110","111","116","106","105","108"]},"Such an intersection can be determined by using any of a variety of intersection tests, such as the barycentric coordinate test, or the Moller-Trombore algorithm. In addition to determining whether there was an intersection between ray  and primitive , such testing also usually determines the intersection point on primitive . Such tests usually are conducted in floating point. All floating point calculations have a finite precision, and can only represent certain numbers. Thus, regardless of the precision used in the floating point tests, inaccuracies in representing results are inevitable. In the case of ray intersection testing, one inaccuracy that results is that the hit point between a ray and a primitive can be slightly inaccurate.","With reference to , true intersection point  represents where on primitive  the ray should be represented to have hit. However, that number is not representable in the system as presenting constructed, causing the intersection point to be located at clamped origin . In this case, the representable hit point is called clamped origin , because it serves as an origin for a child ray to be emitted during shading. Such child rays can include rays that are for testing reflection or refraction behavior.  depicts a reflection ray, outbound ray . As can be discerned from , clamped origin  is on the wrong side of surface , in that it should have been on the surface, such that ray  would start from the left surface of primitive  and travel in the scene in the direction depicted. However, due to the inaccuracy depicted, ray  will first intersect with primitive  again, before it ends up on the correct side of surface . To allow for a more intuitive understanding of the description, in some places, the terms \u201creflection\u201d and \u201crefraction\u201d have been used to describe intended ray behaviors and are not intended to be limiting of types of rays that may exhibit such behaviors. For example, where an intended behavior of a ray is to have the ray \u201cbounce\u201d from an intersection point, that intended behavior can be called reflection behavior, while where intended ray behavior is to have a ray transmit through an intersected surface, that behavior can be called refraction behavior. The intended behavior of a given ray typically is determined by code that emits the ray, which is conveniently called a \u201cshader\u201d herein.","This intersection thus is an invalid self-intersection. One approach to detecting such intersections is depicted in , which depicts in greater detail a portion of . In particular,  depicts that an epsilon  can be applied along the direction of travel of ray , and if a distance  to a detected intersection (false intersection ) from origin  is within that epsilon, then it is considered an invalid intersection. Although this approach helps reject some false intersections, the selection of the epsilon  is a heuristic, and even when it is selected to be comparatively small, it still does not reject all false intersections, and further setting it too large also can cause rejections of valid intersections, even while still allowing invalid intersections. If more precision were used in number representation, the problem would continue to exist, with smaller numbers. As also discussed, an approach that separately tracks an identity for a primitive intersected by a parent ray (here, primitive ) can be maintained with ray , but that approach would consume a lot of memory if many rays were in flight at the same time, and it also presents some difficulties with adaptive geometry approaches, where a given primitive may be adaptively tessellated into multiple primitives, such that the original primitive may not exist in the form that it was previously when child rays are tested.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 3A","FIG. 3A"],"b":["315","316","301","316","302","302","316","304","303"]},"If clamped origin  were the numerically represented origin, then a child ray with a given direction would be as depicted by actual ray , while if clamped origin  were the numerically represented origin, then a ray with that same direction would be as actual ray  in , while the desired ray should have traveled as intended ray  depicts. For example, a ray of such direction could be emitted to test reflection on the intersection point. However, because the origin of that ray can vary, in some cases, the closest primitive intersected by such a ray may not be a valid intersection. In the particular situation depicted in , primitive  will be intersected first if the origin was at , causing an invalid intersection.","In a first example, when the intended ray  is emitted (e.g., when the direction of the ray is defined, and it is to originate at the origin determined based on the hit point\u2014as it can be numerically represented), information about an angle between the normal of primitive  (the primitive intersected by incoming ray ) and the direction of ray  is determined. Such information can include calculating at least the sign of an inner product between normal vector  for primitive  and a direction vector for ray  (ray  is identified, although it would be understood that the direction is being discussed, while the exact path of travel also depends on the origin, which can vary). In these disclosures, numerical representation of a direction also suffers from imprecision of numerical representation, and these disclosures also can address such imprecision. In many figures, both an actual and an intended ray path are depicted. It would be understood that the actual path represents the ray as it would travel, while the intended ray path shows a hypothetical path under \u201cideal\u201d conditions. However, for purposes of discussion, either ray can be identified as representing a direction of travel for the actual ray.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 3B","FIG. 3A","FIG. 3B"],"b":["342","322","311","311","315","315","301","316","322","311","322","311","322"]},"The assigned epsilons herein preferably are assigned based on an expected reasonable range of the scene. Such assignment is done based on the nature of floating point arithmetic, where larger numbers have lower precision, such that an epsilon that works well for \u201ccloser in\u201d (to an origin) positions would not be expected to work well at \u201cvery far out\u201d points. So, the epsilons are selected to balance the competing needs of precision, while handling variations in available precision for the useful portion of a scene being ray tracing.","In one approach, an epsilon to be used in analyzing a given intersection can be selected dynamically. In one example of a dynamically-selected epsilon, an intersection can be identified by a set of vertices, such as a set of vertices of a primitive intersected (e.g., 3 vertices). Each vertex can be specified by a tuple of floating point numbers, specifying a point in space. In one preferred example, an epsilon is selected based on a largest exponent of the set of vertices for a given identified ray\/primitive intersection, or, stated more generally, a largest exponent of a set of floating point numbers specifying an intersection between a ray and a surface. The epsilon can be modified based on a bias or other allocation of available bits in the floating point system being used. The epsilon also can be set based on leaving some guardband for accumulated error.","The number obtained based on the largest exponent, however, is to be clamped to a minimum in situations where the obtained number is small compared with an exponent of the normal vector in the number system being used. Thus, the epsilon preferably is set to be no smaller than a number based on an exponent associated with a unit length vector in the number system used, and larger, as the intersection is farther away from the origin, using the largest exponent of those vertices defining the surface that was intersected. For a IEEE single precision floating point implementation, an error accumulation guardband of four or five bits is acceptable. For IEEE single precision, a minimum epsilon preferably is set to no less than about 108, such as 108, 109, 110, 111, and 112.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 3C","FIG. 3C"],"b":["315","322","331","349","322","331","315","322","331"]},"Where triangular primitives are used in composing screen objects, the triangles are typically represented by vertex data. Vertex data for triangles can be expressed as a triangle strip, a first triangle in a strip is defined by three vertexes, but then each additional triangle can be expressed by addition of another vertex to the strip, and using two other vertices already part of the strip. Typically, a winding order for the vertices is used to determine normals for the triangles of the strip. In such a case, alternating triangles would have alternating normals (if using the same winding order for all triangles); thus, it is expected that the normals of alternating triangles would be reversed. After such reversal, adjacent triangles generally would have normals pointing in the same direction. This issue of convention regarding normal direction can be handled at a variety of points, including at either scene setup or during a self-intersection detection\/prevention process, for example.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 4A","FIG. 4A","FIG. 4A"],"b":["403","401","407","401","421","401","402","405","401","403","408","404","406","408","402","404","406","402"]},"In a first approach to detecting these invalid intersections, a ray is emitted, such as from a shader for a detected intersection. That emitted ray has a direction, which is compared with a normal of the primitive from which the ray was supposed to originate (in , for intended ray , the primitive is primitive , and thus the normal is normal ). In one example, at least a sign of a dot product between normal  and a direction vector representative of the direction of ray  (equivalently ray ) (for simplicity, direction of ray ) is obtained. The sign bit thus represents whether the angle between the direction of ray  and normal  is greater or less than 90 degrees. As will be described below, this information can be used in a comparison with a dot product between the direction of ray  and a normal of a primitive intersected by the ray as actually emitted (in , primitive ). In the example of , a sign of a dot product between direction of ray  and normal  is calculated (generally, the directions of the rays as actually emitted and as intended to be emitted\u2014i.e., ray  versus ray , will be the same).","In the refraction ray example of , a sign of a dot product between normal  and direction of ray  would be negative. Similarly, a sign of a dot product between normal  and that direction also would be negative, as both of these normals form obtuse angles with a vector of that direction. Since both of these signs are the same (i.e., both would be negative, absent further processing or other manipulation or sign convention), it can be concluded that the intersection with primitive  may be invalid.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 4B","b":["422","405","405","404","402","422","422"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 4B","b":["426","404","402","406","426"]},"The epsilons depicted in the figures identify what distance quantity will be compared with the epsilon value (or components of a vector, with a multiplier (preferably less than 1) of the epsilon; therefore, the bracket for each epsilon does not imply a value for the epsilon, but rather the distance value to be compared against it.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 5","FIG. 5"],"b":["510","520"]},"More general than obtaining a dot product, or even explicitly calculating a sign bit of a dot product of the identified vectors, a bit that can be used in methods according to this disclosure can be produced as a result of intersecting testing, itself. For example, in a case where triangular primitives are used in defining scene objects, the three half plane ray\/triangle intersection test produces a bit that can be used in these methods, in that information resulting from this test provides an indication whether the ray hit a front side or a back side of the tested primitive, where a normal direction convention determines which side is the front and which is the back.","That bit can then be provided () for use in verifying potential intersections involving the child ray, as explained below.  depicts that a data structure for the child ray may contain a field for storage of the bit, and fields for an origin and a direction.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 6","b":"605"},"If the sign bit calculated agrees (i.e., it is the same sign), then it is expected that the intersected is more likely to be invalid. If the sign bits disagree then the intersection is more likely to be valid. This analysis can be summarized as a comparison that indicates whether the difference between these sign bits is or is not within an expectation (). Such a description comprehends situations where further bit changes can be made, resulting in a different sign convention.","The above description provides examples of methods and systems that can implement disclosed heuristics to identify potentially invalid intersections between rays and surfaces. Because the detection of self-intersections (or the lack thereof) is heuristic, further testing can be done (either before or after the usage of any of the disclosed heuristics) to further develop a final decision about whether to consider a particular intersection valid or invalid. Such further testing is exemplified by the remainder of the method of .","The method of  also may implement a distance determination first along a normal direction of the primitive intersected by the ray, and if the distance between the ray origin and the plane in which the intersected primitive exists along that normal direction (see e.g., ) is closer than a determined epsilon, then the intersection is determined more likely to be invalid (). Implementations also can provide a distance check in the direction of the ray itself (), as depicted, for example, in , with epsilon .","Still further implementations can provide a distance check along one or more components of the vector describing the ray direction (likewise, in the normal direction, for that test). For example, an epsilon against which a distance is compared can be defined, and rather than performing a precise distance check, the distance check can be approximated by comparing each component vector with some fractional multiplier of the epsilon. In still further examples, an epsilon can be defined with components for each component of the space, and in such examples, the distance check can be done component-by-component.","The method of  depicts three tests that each can be used to develop information about whether a given intersection is more or less likely to be invalid or valid. The method of  depicts an example where a flow for a method presumes validity, and then testing can result in a finding of invalidity. Conversely, a method flow can begin from a presumption of invalidity, and testing can prove validity. The testing would be adjusted accordingly. Also, the depicted method showed a linear progression of tests. However, each of the tests can be conducted concurrently. Also, the examples were to a preferred approach where the normal test was conducted first, followed by one or more epsilon tests. However, the order of such testing can be different, or not all of the epsilon tests need be done. In a preferred approach, all tests need to result in a finding of potential invalidity to invalidate a given intersection. However, in other implementations, a vote among the tests can be conducted, with majority dictating the outcome; such voting can be weighted, preferably to favor the normal test. Other approaches, based on these examples, can be provided.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 8","FIG. 8","FIG. 3A","FIG. 8","FIG. 8"],"b":["316","311","316","321","805","311","321","311","706","705"]},"Ray  can then be intersection tested (), and is found to intersect with primitive , which has normal . Normal  and ray  can then be used in a dot product to produce a sign bit that is compared (). Based on the comparison, a finding of validity can result (e.g., if the signs mismatch, as expected in an example sign convention); further testing also can be conducted (), if the comparison indicates a possibility of invalid intersection. Further testing can be conducted in either case. One aspect of further testing is the epsilon in the primitive normal direction (). Validity can be confirmed based on this additional testing, or more testing can be done (), or even in both cases, if desired. Such further testing can include testing a distance epsilon in the direction of ray travel (). In one implementation, if the signs match, and the distances are within their respective epsilons, then the intersection can be invalidated.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIGS. 9 and 10","FIG. 9","FIG. 10"],"b":["905","921","906","922","905","906","910","921","925","913","932","921","925","912","911","912","930","911","933"]},"Considering the refraction ray example of , assigning the normals as described helps determine that ray  intersecting primitive  is a valid intersection, for a refraction ray coming through primitive . In particular, it was discussed that where sign bits for the dot products of the normal of the primitive intersected by the parent ray and that intersected by the child ray match, that tends towards rejecting that intersection for the child ray. In particular, referring to , it can be understood that an angle between normal  and ray  is greater than 90 degrees, and hence would have a negative-signed dot product. If ray  were then to hit primitive , and primitive  had a normal on the left side, then a dot product of that normal and ray  also would be negative. However, in this case, primitive  should not be rejected as an invalid intersection based on the normal test, because ray  was a refraction ray and genuinely could hit primitive .","Considered from a complementary perspective, the disclosed methods and systems can use normal information for an intersected primitive to determine whether the ray is inside or outside a volume of a scene shape composed of primitives (or alternatively viewed, whether the ray hit an outside or an inside of a given surface), and determine whether the ray should be inside or outside of that volume. Thus, there are four combinations, two of which can be viewed as valid intersections and two of which can b viewed as invalid intersections. The valid intersections are (1) the ray hit from inside and should be inside, and (2) ray hit from outside, and should be outside, while the others are (3) where the ray should have been inside and hit from outside, and (4) should have been outside and hit from inside. Many rays (\u201cchild rays\u201d) are emitted to shade intersections involving other rays (\u201cparent rays\u201d). Information concerning whether a child ray should be outside of or inside of a given shape can be derived from information about whether its parent ray was inside or outside of the surface and what the child ray was intended to do (e.g., reflect or refract). In one example, both these items of information can be expressed as a bit derived from information about a difference between the normal of the surface intersected by the parent ray and the direction of the child ray.","Thus, returning to , normal  for primitive  points so that such a refraction ray would form an acute angle with it. Thus, the signs of the dot products for normal  and for normal  would be different, which in this convention indicates that the intersection is more likely to be valid. Similarly, however, normal  should not be on the same side as normal , or else false results may be generated when testing reflection rays from primitive . In this particular example, if normal  pointed in the opposite direction, then a refraction ray would form a negatively signed dot product with that normal, which would match the sign of the dot product of that ray and normal . However, because the intersection with primitive  is potentially valid in this instance, it can be preferable for the dot product signs to be unequal, to preserve the sign convention described as being applicable for reflection rays.","However, maintaining this normal convention is not mandatory. For example, more than one bit can be included that describes the nature of a ray, such that the sign convention can change depending on whether the ray is a reflection ray or a refraction ray.","Still further, the above explanation described how surface normals can be used in determining orientations of surfaces with respect to a ray. For example, a surface normal can be used in a dot product calculation with a direction vector for a ray incident on the surface to determine a magnitude of an angle (represented by a sign of the dot product). In other implementations, an orientation of a surface at a given intersection point can be described instead with a vector in a plane tangent to a surface at an intersection point. Other ways to represent surface orientations can be provided, and these disclosures serve as examples.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 11","FIG. 11","FIG. 12","FIG. 12"],"b":["1104","1235"]},"The instructions comprised in a shader for a given intersection can use API calls to emit rays for further intersection testing (e.g., the reflection and refraction rays discussed above). These calls can include a call  to emit a bundle of rays and a call  to emit a ray. Call  can specify some attributes to be shared among the rays emitted and some attributes that are unique for each ray. Each of call  and  can provide the capability to attach other data, such as pointers to code, or executable code that will be performed upon completion of intersection testing or of shading of the ray emitted in that call.","These calls are serviced by API  that may comprise computer executable code configuring a core illustrated in . One aspect of the API includes code  for calculating the flag bits, and attaching such calculated bits to a datastructure storing data for the ray(s). In one example, rays are associated with a parent ray, which resulted in their emission during shading of an intersection involving the parent ray. API  can access an association between that parent ray and the primitive that was intersected by the parent ray during calculations . Such primitive identification information also can be provided in calls  and . In other examples, normal direction information can be provided in calls  and , maintained by, or accessible by, API . Data descriptive of origin(s) and direction(s) for the ray(s) emitted, with the calculated bits can then be provided for intersection testing , which contains intersection avoidance component .","These aspects identified as implemented in API  can be implemented as a run-time environment that makes available services that can be used by shaders. Such run-time environment can include code attached by a compiler to a shader code provided from a shader author. Such code also can be run as a part of a procedure called by shaders.","Intersection avoidance component  can operate according to the examples described above, using the calculated bits, and epsilon information. In some cases, the epsilon information can be globally fixed for all rays being tested, and in other situations, the epsilon can be made variable for a ray or for a type of ray. In some cases, the epsilons can be calculated based on a hit point of the parent ray on its primitive.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 12","b":["1200","400","1200","1202","1202","1201","1202","1202","1201","1215","1202","1202","1202","1202","1225","1235","1225","1240","1225","1245","1200","1230","1201","1235","1210","1210","1202","1202","1201"],"i":["a","n","a","n ","a","n","a","n ","a","n "]},"In some cases, it may be preferable to store rays currently being tested for intersection in cache , while fetching primitives for testing from RAM  when required.","Shaders can be stored in RAM , along with texture data. Each core -may be assigned to perform intersection testing or shading, or in some cases, may perform a combination of intersection and shading operations.","API  can be stored in storage , and loaded into RAM  (or a combination of RAM  and cache ) with a rendering application, such as a video game, a computer aided design or animation package, and so on. API  also can access code and\/or hardware appropriate to the particular system implementation, to implement the calls described above.","In sum, any of the functions, features, and other logic described herein can be implemented with a variety of computing resources. A computing resource can be a thread, a core, a processor, a fixed function processing element, and the like. Also, other functions, which are not primarily the focus of this description, can be provided or implemented as a process, thread or task that can be localized to one computing resource or distributed among a plurality of computing resources (e.g., a plurality of threads distributed among a plurality of physical compute resources).","Likewise, computing resources being used for intersection test can also host other processes, such as shading processes that are used to shade intersections detected. By further example, if a core can support multiple threads, then a thread can be dedicated to shading while another thread can be dedicated to intersection processing.","Code for any method can be stored in computer readable media, such as solid-state drives, hard drives, CD-ROMs and other optical storage means, and transiently in volatile memories, such as DRAM.","Computer-executable instructions comprise, for example, instructions and data which cause or otherwise configure a general purpose computer, special purpose computer, or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be, for example, binaries, intermediate format instructions such as assembly language, or source code. Some aspects of the API described herein can be implemented as procedures, functions, or calls to such procedures and functions. This description implies no limitation as to a programming methodology that can be used to implement or provide the functionality described as being available through these procedures or functions, so long as software, hardware or a mixture thereof provides a programmer with an ability to access such functionality through an interface provided therefore. Various names were provided for particular coding concepts. These names imply no requirement as to what code performing these functions need to called in an implementation, and imply no restriction on how these concepts are implemented.","The various examples described above are provided by way of illustration only and should not be construed as limiting. For example, only a limited example of ray tracing behavior was presented, and it would be understood that practical implementations involve many more rays, and often more concurrent processing thereof. The disclosures herein can be adapted and understood from that perspective. In addition, separate boxes or illustrated separation of functional elements of illustrated systems implies no required physical separation of such functions, as communications between such elements can occur by way of messaging, function calls, shared memory space, and so on, without any such physical separation. More generally, a person of ordinary skill would be able to adapt the disclosures relating to the programming semantic to a variety of other ray tracing\/ray shading implementations, and no implied limitation as to its application exists from the systems, methods, and other disclosure used to explain examples thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 3A-3C"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 4A-B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 9 and 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
