---
title: Federated services to dynamically switch features in applications
abstract: An application binary is received at an intermediate federated service layer before deployment of the application binary at the application store. At the intermediate federated service layer multiple copies of application binaries are generated concurrently. At the intermediate service layer, program code of the copies of application binaries is concurrently parsed and features of copies of application binaries are matched with features of operating system. If the features match, corresponding program codes are flagged to switch off, and re-generated as custom application binary and deployed in application store. The custom application binary and a container along with features corresponding to operating system of a mobile device are downloaded to a mobile device. A request to access a set of features is received from the custom application binary at the container. If the set of features match the features of the operating system request is allowed through the container else it's blocked.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268561&OS=09268561&RS=09268561
owner: SAP SE
number: 09268561
owner_city: Walldorf
owner_country: DE
publication_date: 20141210
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Mobile applications are developed to execute on different kinds of client devices such as mobile phones, electronic tablets, portable computers, etc. Typically, the mobile applications are developed for specific versions of operating system or platform. The development effort is directly proportional to the number of versions of operating systems. If an application is developed for a latest version of an operating system, the application may support or be compatible with one or more earlier versions of the operating system, however, for the application to be compatible with a complete set of earlier versions of the operating systems, the application may have to be developed for the individual earlier versions of the operating systems. It is challenging to develop an operating system version agnostic application that is compatible across operating systems versions or platforms.","Embodiments of techniques for federated services to dynamically switch features in applications are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of the embodiments. A person of ordinary skill in the relevant art will recognize, however, that the embodiments can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In some instances, well-known structures, materials, or operations are not shown or described in detail.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":["100","105","110","105","105","115","110","115","105","120","115"]},"For example, displaying direction in a digital map may be a function. An individual function in the \u2018application 1\u2019  may correspond to a feature or a number of features. The features may be hardware-based such as a magnetometer sensor, software-based such as application widgets, based on the version of operating system, etc. For example, the displaying direction in a digital map function may correspond to a feature of accessing or reading data to and from a magnetometer sensor available in a client device such as a mobile device, where the magnetometer sensor is used to identify cardinal directions.","Various techniques of parsing the program code for features and\/or functionalities may be used. One such technique is static analysis, where the program code is scanned line by line, and keywords corresponding to features are used to identify features in the program code. For example, various keywords such as sensor type magnetic field, magnetic field calibrated, magnetic north, etc., can be used to identify the feature magnetometer sensor in the program code of \u2018application 1\u2019  binary. \u2018Application 1\u2019  may be a three dimension compass application that uses data from the underlying magnetometer sensor in the mobile device. Similarly, \u2018application 1\u2019  may use various other features such as gyroscope sensor, microphone, speaker, etc., of the mobile device to execute the application effectively.","\u2018Application 1\u2019  binary may be deployed in application store  corresponding to various versions of operating systems. The various versions of operating systems may include major versions such as major version increments like \u2018version 1.0\u2019, \u2018version 2.0\u2019, etc., and minor versions such as minor version increments like \u2018version 1.1\u2019, \u2018version 1.2\u2019, etc. The various versions of operating systems may also include operating systems from various vendors and platforms such as Android\u00ae, iOS\u00ae, Microsoft Windows\u00ae, BlackBerry\u00ae, etc. Individual versions of the operating systems support certain sets of features, for example, versions of operating systems such as Android 4.0 and Android 2.3 support gyroscope sensor whereas, the versions of operating systems Android 2.2 and Android 1.5 do not support gyroscope sensor.","While the code scan service  in the intermediate federated service layer  concurrently parses or scans the program code in the individual copies of the \u2018application 1\u2019 binary, switch features service  in the intermediate federated service layer  compares the features of copies of the \u2018application 1\u2019 binary with features of the corresponding versions of operating systems. A custom switch in the form of a label or flag may be injected and defined with two states, \u2018ON\u2019 and \u2018OFF\u2019, in the copies of the \u2018application 1\u2019 binary. The injection or code injection of a custom switch may use any form of custom code injection techniques. Code may also be injected to perform other functions such as add a missing function call, exception handling, etc. When the features of the copies of the \u2018application 1\u2019 binary do not match with features of the corresponding versions of operating systems, switch features service , identifies portions of program code in functions corresponding to the features not matched. Switch flags are injected and sets to \u2018OFF\u2019 at the start of identified portions of program code in the copies of the \u2018application 1\u2019 binary, to disable the features that are not matched. Setting the switch flags to \u2018OFF\u2019 indicates disabling the portions of program code in the copies of the \u2018application 1\u2019 binary that are not matched or not supported by the corresponding versions of operating systems. Disabled portions of program code remains unexecuted until enabled again by setting the switch flags to \u2018ON\u2019.","When the features of copies of the \u2018application 1\u2019 binary match with features of the corresponding versions of operating systems, switch features service , identifies portions of program code in functions corresponding to the matched features. Switch flags are injected and set to \u2018ON\u2019 at the start of the identified portions of program code in the copies of the \u2018application 1\u2019 binary that are matched or supported by the corresponding versions of operating systems. Setting the switch flags to \u2018ON\u2019 indicate enabling the portions of program code in the copies of \u2018application 1\u2019 binaries. In some cases the portions of program code are enabled by default and setting the switch flags to \u2018ON\u2019 may be optional. The portions of program code that are enabled are executed in the copies of the \u2018application 1\u2019 binary. After the switch features service  sets the switch flags to \u2018ON\u2019 and \u2018OFF\u2019 in the copies of the \u2018application 1\u2019 binary, they are re-generated as custom application binaries that are compliant or compatible with the corresponding versions of operating systems. For example, a copy of \u2018application 1\u2019  binary is re-generated as a \u2018first custom application 1\u2019  binary that is compliant or compatible with the \u2018operating system 1\u2019  version. The \u2018first custom application 1\u2019  binary is automatically deployed in the application store  corresponding to \u2018operating system 1\u2019  version.","Similarly, another copy of \u2018application 1\u2019  binary is re-generated as \u2018second custom application 1\u2019  binary that is compliant\/compatible with the \u2018operating system N\u2019  version. The \u2018second custom application 1\u2019  binary is automatically deployed in the application store  corresponding to version \u2018operating system N\u2019 . Similarly, \u2018application N\u2019  can be automatically deployed as a \u2018first custom application N\u2019  corresponding to \u2018operating system 1\u2019  and can be automatically deployed as a \u2018second custom application N\u2019  corresponding to \u2018operating system N\u2019 .","In one embodiment, a new application binary may be developed for a latest version of operating system, and using intermediate federated service layer , the new application binary can be deployed in corresponding lower versions of operating systems. While the code scan service  concurrently parses or scans the program code of copies of the new application binary, switch features service , compares the features of the copies of the new application binary with the features of corresponding lower versions of operating systems. When the features in the copies of the new application binary do not match with features of the corresponding lower versions of operating systems, switch features service  identifies portions of program code in functions corresponding to the features not matched. Switch flags are injected and set to \u2018OFF\u2019 at the start of the identified portions of program code in the copies of the new application binary. The copies of the new application binary is re-generated as new custom application binaries that are compliant\/compatible with lower versions of operating systems and deployed in the application store .","In one embodiment, a new application binary may be developed with future enhancements features but the future enhancements features may be disabled in a specific version of the new application binary. Using intermediate federated service layer  the new application binary can be deployed in corresponding versions of operating systems. While the code scan service  concurrently parses or scans the program code of copies of the new application binary, switch features service  in the intermediate federated service layer , compares the disabled future enhancements features with the features of corresponding versions of operating systems. When the disabled future enhancements features match with the features of the corresponding versions of operating systems, switch features service  identifies portions of program code in functions corresponding to disabled future enhancements features. Switch flags are injected and set to \u2018ON\u2019 at the start of the identified portions of program code to enable the disabled future enhancements features in the copies of the new application binary. The copies of the new application binary are re-generated as new custom application binaries that are compliant\/compatible with corresponding versions of operating systems and deployed in the application store .","In one embodiment, a new version of application such as a major version or a minor version may be deployed corresponding to various versions of operating systems in the application store . For example, a new version of \u2018application 1\u2019 binary such as \u2018application 1.1\u2019 may be ready for deployment that may include updates i.e., additional features, bug fixes, etc., in comparison to the prior version of \u2018application 1\u2019 binary. While the code scan service  concurrently parses or scans the program code of copies of the \u2018application 1.1\u2019 binary, switch features service , compares the features of copies of the \u2018application 1.1\u2019 binary with the features of corresponding versions of operating systems. When the features of copies of the \u2018application 1.1\u2019 binary match the features of the corresponding versions of operating systems, switch features service , identifies portions of program code in functions corresponding to matched features. Switch flags are injected and set to \u2018ON\u2019 at the start of the identified portions of program code. When the features in the copies of \u2018application 1.1\u2019 binaries do not match with features of the corresponding versions of operating systems, switch features service  identifies portions of program code in functions corresponding to the features that are not matched. Switch flags are injected and set to \u2018OFF\u2019 at the start of identified portions of program code in the copies of \u2018application 1.1\u2019 binaries. The \u2018application 1.1\u2019 binaries are re-generated as custom \u2018application 1.1\u2019 binaries that are compliant\/compatible with corresponding versions of operating systems and deployed in the application store .","In one embodiment, new versions of operating systems may be available. Database update service  may be a lookup service that looks up for new versions of operating systems release from various sources, and updates the master database . For example, database update service  may use Rich Site Summary (RSS) to subscribe to various other sites to retrieve features corresponding to new versions of operation systems as RSS feeds, and the RSS feeds are updated in the master database . In one embodiment, manual update of master database  may be used to manually enter the features corresponding to new versions of operating systems. The master database  has updates of different versions of operating systems and their corresponding features. When a new version of \u2018operating system 1\u2019 is available such as \u2018operating system 1.1\u2019, features corresponding to \u2018operating system 1.1\u2019 are updated in the master database . \u2018Application 1\u2019  is to be deployed corresponding to the \u2018operating system 1.1\u2019 in the application store . Code scan service  is used to scan the program code corresponding to a copy of \u2018application 1\u2019 binary. Switch features service  sets switch flags to \u2018ON\u2019 and \u2018OFF\u2019 corresponding to features in the program code in the copy of \u2018application 1\u2019 binary supported by the \u2018operating system 1.1\u2019. The copy of \u2018application 1\u2019 binary is re-generated as a custom \u2018application 1\u2019 binary that is compliant\/compatible with the \u2018operating system 1.1\u2019 version. The custom \u2018application 1\u2019 binary is deployed in the application store  corresponding to \u2018operating system 1.1\u2019 version. Similarly, other applications are re-generated as custom application binaries and deployed corresponding to \u2018operating system 1.1\u2019 version.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["200","205","210","215","220","225","210","205","215","205","220","205","225","205"]},"The \u2018application 1\u2019  binary is to be deployed corresponding to various versions of operating systems such as \u2018operating system 1\u2019 , \u2018operating system 2\u2019 , \u2018operating system N\u2019 , etc. \u2018Operating system 1\u2019  supports various features such as \u2018feature B\u2019, \u2018feature N\u2019, etc. The \u2018application 1\u2019  binary is received at an intermediate federated service layer  prior to deployment at the application store . At the intermediate federated service layer , multiple copies of the \u2018application 1\u2019 binary corresponding to various versions of operating systems are generated concurrently. Code scan service  in the intermediate federated service layer  concurrently and\/or consecutively parses or scans the program code in the individual copies of the \u2018application 1\u2019 binary. When the code scan service  parses the program code in a copy of the \u2018application 1\u2019 binary, the features supported by the copy of the \u2018application 1\u2019 binary such as \u2018feature A\u2019, \u2018feature B\u2019, \u2018feature C\u2019 and \u2018feature N\u2019 are compared with the features corresponding to the \u2018operating system 1\u2019  such as \u2018feature B\u2019 and \u2018feature N\u2019.","\u2018Feature A\u2019 and \u2018feature C\u2019 of the copy of the \u2018application 1\u2019 binary does not match with the features of the \u2018operating system 1\u2019 , and the switch features service  identifies portion of program code in function A  and portion of program code in function C  and injects switch flags and sets the switch flags to \u2018OFF\u2019. The copy of the \u2018application 1\u2019 binary is re-generated as a \u2018custom application 1\u2019  binary. The \u2018custom application 1\u2019  binary is deployed in the application store , corresponding to the \u2018operating system 1\u2019 . Similarly, \u2018custom application 1\u2019  binary and \u2018custom application 1\u2019  binary are concurrently re-generated, and deployed for the available version of the operating systems \u2018operating system 2\u2019  and \u2018operating system N\u2019  respectively in the application store .",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3","b":["300","305","310","315","320","325"]},"Upon determining that features associated with the copies of the application binary do not match features corresponding to versions of the operating systems, at , portions of program code in functions corresponding to the features not matched are identified. Switch flags are injected and concurrently set to \u2018OFF\u2019 at the start of identified portions of program code corresponding to the features in the corresponding copies of the application binary. At , custom application binaries corresponding to the copies of the application binary are dynamically re-generated. At , the re-generated custom application binaries are automatically deployed in corresponding versions of operating systems in the application store. Process steps  to  may be performed in the intermediate federated service layer.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 4"],"b":["400","405","410","415","420","425","425","430","435","440","430","435","440","445","450","450"]},"For example, consider a scenario where a request is received from mobile device  to download \u2018application 1\u2019 , \u2018application 3\u2019  and \u2018application N\u2019  from the application store . When a request is received from a client device such as a mobile device  to download applications from the application store , the application store  determines that \u2018container 1\u2019  is supported by \u2018operating system 1\u2019  executing in the mobile device . A notification to download and install \u2018container 1\u2019  is displayed in the mobile device . The user may choose to download \u2018container 1\u2019  and install in the mobile device . Alternatively, the user may choose to download and install \u2018container 1\u2019  at a later point of time. The \u2018container 1\u2019  is downloaded and installed once for the first time, and that may be an automatic download or a manually initiated download. Whenever \u2018container 1\u2019  is updated to a new version, the new version of \u2018container 1\u2019  can be updated automatically from the application store . The applications application 1\u2019 , \u2018application 3\u2019  and \u2018application N\u2019  along with \u2018container 1\u2019  are downloaded to the mobile device  from the application store . The \u2018container 1\u2019  may be downloaded in parallel with the applications application 1\u2019 , \u2018application 3\u2019  and \u2018application N\u2019 , or, the applications may be downloaded immediately following the download of the \u2018container 1\u2019 . The downloaded applications are executed within the \u2018container 1\u2019  on the mobile device .","The \u2018container 1\u2019  in the application store  retrieves features corresponding to \u2018operating system 1\u2019  from the master database . The applications, \u2018application 1\u2019 , \u2018application 3\u2019  and \u2018application N\u2019  execute within the \u2018container 1\u2019  in the mobile device . During execution or running of the applications, the \u2018container 1\u2019  intermediates the interactions between the applications \u2018application 1\u2019 , \u2018application 3\u2019  and \u2018application N\u2019  and the \u2018operating system 1\u2019 . The \u2018container 1\u2019  handles function calls from the applications and determines whether to delegate the function calls to the \u2018operating system 1\u2019  or not. The applications \u2018application 1\u2019 , \u2018application 3\u2019  and \u2018application N\u2019  may have a certain set of features and the applications may request access to corresponding set of features in the \u2018operating system 1\u2019  via the \u2018container 1\u2019 . The \u2018container 1\u2019  intercepts the requests received from the applications, and compares the set of features of the applications with the features corresponding to the \u2018operating system 1\u2019 . The requests may be in the form of a function call such as API call. When the set of features of the applications matches with the features of the \u2018operating system 1\u2019 , the requests to access are allowed through the \u2018container 1\u2019  and delegated to the \u2018operating system 1\u2019 . When the set of features of the applications does not match with the features of the \u2018operating system 1\u2019 , the requests to access are not allowed through the \u2018container 1\u2019  and the requests are blocked at the \u2018container 1\u2019 . The allowing and blocking of requests to access occurs at runtime when the applications are executing or running within the \u2018container 1\u2019  in the mobile device .","In one embodiment, when the user downloads \u2018container 1\u2019  and installs in the mobile device , the user may choose to set the \u2018container 1\u2019  as a \u2018default container\u2019 for the applications currently installed in the mobile device . When the \u2018container 1\u2019  is set as a default container, the previously installed applications and the applications that may be installed in the future may execute within \u2018container 1\u2019  as explained above. In another embodiment, when the user may not choose to set the \u2018container 1\u2019  as a default container, the applications installed along with the \u2018container 1\u2019  or the applications selected by the user may execute within the \u2018container 1\u2019 . In this scenario, the applications not selected execute outside the \u2018container 1\u2019 . Individual applications can be selected and configured to execute within the \u2018container 1\u2019 based on a customizable \u2018user setting\u2019.","In one embodiment, the \u2018operating system 1\u2019  in the mobile device can be updated or upgraded to a newer version such as \u2018operating system 2.1\u2019. The database update service  determines the new \u2018operating system 2.1\u2019 availability, and updates the master database  with the \u2018operating system 2.1\u2019 corresponding features. When the \u2018operating system 1\u2019  is updated to \u2018operating system 2.1\u2019 in the mobile device , the update service  requests the master database  to receive updated features corresponding to \u2018operating system 2.1\u2019 from the master database . The update service  updates the \u2018container 1\u2019  with updated features corresponding to \u2018operating system 2.1\u2019 in the mobile device . The \u2018container 1\u2019  intercepts the request received from the applications, and compares the set of features of the applications with the updated features corresponding to the \u2018operating system 2.1\u2019. When the set of features of the applications matches the updated features of the \u2018operating system 2.1\u2019, the request to access is allowed through the \u2018container 1\u2019  to the \u2018operating system 2.1\u2019 at runtime. When the set of features of the application does not match the updated features of the \u2018operating system 2.1\u2019, the request to access is not allowed through the \u2018container 1\u2019  and the request is blocked at the \u2018container 1\u2019  at runtime.","In one embodiment, the applications such as \u2018application 1\u2019 , \u2018application 3\u2019  and \u2018application N\u2019  can be updated or upgraded to newer versions with additional features. For example, if \u2018application 1\u2019  is updated to a new version such as \u2018application 1.1\u2019, the new version \u2018application 1.1\u2019 is downloaded and executed within the \u2018container 1\u2019 . The \u2018container 1\u2019  intercepts the request received from the \u2018application 1.1\u2019, and compares the set of features of the \u2018application 1.1\u2019 with the features corresponding to the \u2018operating system 1\u2019 . When the set of features of the \u2018application 1.1\u2019 matches the features of the \u2018operating system 1\u2019 , the request to access is allowed through the \u2018container 1\u2019  to the \u2018operating system 1\u2019  at runtime. When the set of features of the \u2018application 1.1\u2019 does not match the features of the \u2018operating system 1\u2019 , the request to access is not allowed through the \u2018container 1\u2019  and the request is blocked at the \u2018container 1\u2019  at runtime.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5","b":["500","505","510","515","520","525","505","530","525","535","540","540","505","515","520","525","525","535","545","535","550","540","535","505","515","520","525","540"]},"For example, when a request is received from \u2018application 1\u2019  in the form of an application programming interface (API) call to access \u2018feature B\u2019 in the \u2018operating system 1\u2019 , the \u2018container 1\u2019  intercepts the received API call and compares \u2018feature B\u2019 of \u2018application 1\u2019  with the features corresponding to \u2018operating system 1\u2019 such as \u2018feature A\u2019, \u2018 feature B\u2019, \u2018feature C\u2019, \u2018feature D\u2019 and \u2018feature N\u2019 in the \u2018container 1\u2019 . The \u2018feature B\u2019 of \u2018application 1\u2019  matches the \u2018feature B\u2019 associated with the \u2018operating system 1\u2019 , and the API call is allowed through the \u2018container 1\u2019  to the \u2018operating system 1\u2019  at runtime. When a request is received from \u2018application 1\u2019  in the form of an API call to access \u2018feature F\u2019 associated with the \u2018operating system 1\u2019 , \u2018feature F\u2019 of \u2018application 1\u2019  is compared with the features of the \u2018operating system 1\u2019  in the \u2018container 1\u2019 . The \u2018feature F\u2019 of \u2018application 1\u2019  does not match the features of the \u2018operating system 1\u2019 , and the API call is blocked at the \u2018container 1\u2019  at runtime. In one embodiment, the database update service  receives updates of operating systems and updates the master database . The update service  requests the master database  to receive updates of operating systems to the \u2018container 1\u2019  as explained in detail with reference to .",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 6","b":["605","610","615","620","625","630","635"]},"In one embodiment, federated services to dynamically switch features in applications in a combination of deploy time and run time is explained below. Consider a scenario where a \u2018game application\u2019 binary is to be deployed corresponding to various versions of operating systems such as \u2018android 1.5\u2019, \u2018android 2.3\u2019 and \u2018android 4.0\u2019 in an application store. \u2018Game application\u2019 supports features such as \u2018gyroscope sensor\u2019, \u2018ambient light sensor\u2019, etc. The operating system \u2018android 2.3\u2019 supports features such as \u2018gyroscope sensor\u2019, \u2018accessing multiple cameras\u2019, etc., \u2018android 4.0\u2019 supports features such as \u2018gyroscope sensor\u2019, \u2018Wi-Fi P2P\u2019, etc. The \u2018game application\u2019 binary is received at an intermediate federated service layer prior to deployment at the application store. At the intermediate federated service layer, multiple copies of the \u2018game application\u2019 binaries are generated concurrently. While \u2018code scan service\u2019 scans or parses the program code in a first copy of the application binary, the \u2018switch features service\u2019 identifies that the feature in the first copy of \u2018game application\u2019 binary such as \u2018ambient light sensor\u2019 does not match with the features \u2018gyroscope sensor\u2019 and \u2018Wi-Fi P2P\u2019 of the \u2018android 4.0\u2019 operating system, and switch flags are set to \u2018OFF\u2019 at the start of portions of program code in the first copy of \u2018game application\u2019 binary. The first copy of game application binary is packaged and re-generated as a \u2018first custom game application binary\u2019 and is deployed in the application store corresponding to \u2018android 4.0\u2019 operating system.","The application store also includes a container supported by Android operating system to provide a runtime execution environment for the \u2018game application\u2019. A request is received from a mobile device to download \u2018first custom game application\u2019 binary from the application store. Based on the request received from the mobile application, the application store determines the container supported by the Android\u00ae operating system executing in the mobile device. The container in the application store retrieves features of \u2018android 1.5\u2019 operating system such as \u2018auto-pairing\u2019, \u2018live folders\u2019, etc., from the master database. In response to the received request from the mobile device, the container with the features \u2018auto-pairing\u2019, \u2018live folders\u2019 of operating system \u2018android 1.5\u2019 along with \u2018first custom game application\u2019 binary is downloaded to the mobile device from the application store. When an API function call to access \u2018gyroscope sensor\u2019 is received from the \u2018first custom game application\u2019 binary executing in the container in the mobile device, the container intercepts the received API call and matches feature \u2018gyroscope sensor\u2019 of the \u2018first custom game application\u2019 binary with the features \u2018auto-pairing\u2019, \u2018live folders\u2019 of operating system \u2018android 1.5\u2019. The feature \u2018gyroscope sensor\u2019 of the \u2018first custom game application\u2019 does not match with the features of \u2018android 1.5\u2019 operating system, and accordingly the API function call to access \u2018gyroscope sensor\u2019 is blocked at the container.","The various embodiments described above have a number of advantages. With the federated services to dynamically switch features in applications in both deployment time and runtime, applications can be developed to be compatible with one version of operating system, and during deploy time and\/or runtime implementations described above the applications can be made compatible with any version of operating system automatically without additional effort or human intervention. There is no additional development effort required by application developers to develop separate applications compatible with individual versions of operating systems. The federated services to dynamically switch features in applications are compatible with different platforms or versions of operating systems.","Some embodiments may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. Examples of computer readable storage media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (ASICs), programmable logic devices (PLDs) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 7","b":["700","705","755","700","740","755","710","715","710","715","705","715","700","725","730","700","725","730","700","735","700","750","750","700","745","700","720","760","760","760","750","760"]},"A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a markup language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as, Open Data Base Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize, however that the embodiments can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in detail.","Although the processes illustrated and described herein include series of steps, it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps, as some steps may occur in different orders, some concurrently with other steps apart from that shown and described herein. In addition, not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover, it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.","The above descriptions and illustrations of embodiments, including what is described in the Abstract, is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of, and examples for, the one or more embodiments are described herein for illustrative purposes, various equivalent modifications are possible within the scope, as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather, the scope is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments with particularity. The embodiments are illustrated by way of examples and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. Various embodiments, together with their advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
