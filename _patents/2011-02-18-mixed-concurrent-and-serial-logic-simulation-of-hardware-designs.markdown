---
title: Mixed concurrent and serial logic simulation of hardware designs
abstract: A method of simulating a design described in HDL is provided. In this method, modules of the design can be partitioned into first modules for simulation by a serial simulation engine and second modules for simulation by a concurrent simulation engine. The first and second modules can be prioritized for simulation based on classes of events consistent with an execution model of the HDL. Simulations of the serial and concurrent simulation engines can be synchronized for each class of events. Synchronizing can include transferring updated interface variable values, which are shared by the second modules and at least a subset of the first modules, between the serial simulation engine and the concurrent simulation engine. This transferring can include translating representations of the updated interface variable values.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08738350&OS=08738350&RS=08738350
owner: Synopsys, Inc.
number: 08738350
owner_city: Mountain View
owner_country: US
publication_date: 20110218
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE DRAWINGS"],"p":["This application claims priority from U.S. Provisional Patent Application 61\/339,391, entitled \u201cMIXED CONCURRENT AND SERIAL LOGIC SIMULATION OF HARDWARE DESIGNS WITH BEHAVIORAL CHARACTERISTICS\u201d, which was filed on Mar. 4, 2010, and is incorporated by reference herein.","1. Field of the Invention","The present invention relates to logic simulation and in particular to an integrated logic simulator including a serial simulation engine and a concurrent simulation engine.","2. Related Art","Logic simulation is an essential step in the design flow of electronic circuits. Logic simulation is usually performed with Electronic Design Automation (EDA) software tools referred to as logic simulators, which process hardware designs typically provided in the form of Hardware Description Language (HDL) code. Hardware designers perform extensive logic simulations to verify that a hardware design complies with its specifications, before committing the hardware design to the physical implementation phase that produces the actual electronic circuit. In a typical hardware design flow, a functional verification process is carried out along with the design process in order to minimize the risk of producing a circuit that is not compliant with its specifications. A logic simulation typically generates as its results the waveforms of a set of circuit signals the user is interested in observing. The user can analyze and visualize the generated waveforms to verify that the hardware design operates correctly. Logic simulators also support simulating hardware designs with embedded assertions, which use the values of the circuit signals to detect conditions resulting in circuit malfunctioning. A logic simulator evaluates such assertions while simulating the circuit, and reports their violations to the user. Based on these violation reports, the user can uncover and fix design errors in the hardware design.","A method of simulating a design specified through a hardware description language (HDL) is provided. In this method, an integrated logic simulator can be run. This integrated logic simulator can include a serial simulation engine and a concurrent simulation engine. The serial simulation engine can perform one simulation at a time, whereas the concurrent simulation engine can perform multiple, concurrent simulations. Using a computer, simulations of the serial simulation engine and the concurrent simulation engine can be synchronized based on the classes of events defined by an execution model of the HDL.","The design can be partitioned into two groups of modules executed by the integrated logic simulator. A first group of modules can execute on the serial simulation engine, and a second group of modules can execute on the concurrent simulation engine. In one embodiment, the partitioning is done based upon the capabilities of the serial simulation engine and\/or capabilities of the concurrent simulation engine to achieve a desirable level of simulation performance. In another embodiment, the partitioning can be done manually by a user.","Either the serial simulation engine or the concurrent simulation engine can be designated a primary simulation engine of the integrated logic simulator, wherein the other simulation engine is then designated a secondary simulation engine. In one embodiment, the serial simulation engine is the primary simulation engine and the concurrent simulation engine is the secondary simulation engine. In another embodiment, the concurrent simulation engine is the primary simulation engine and the serial simulation engine is the secondary simulation engine. The primary simulation engine invokes the secondary simulation engine at synchronization points. In one embodiment, the synchronization points are before queue evaluations as defined by the execution model of the HDL. In another embodiment, the synchronization points are after queue evaluations as defined by the execution model of the HDL.","Note that partitioning of the design can be done with the design hierarchy taken into account. For example, in one embodiment, a first module being simulated by the secondary simulation engine implies that all sub-modules instantiated deeper within the design hierarchy under the first module are also simulated by the secondary simulation engine. In another embodiment, if the first module (simulated by the secondary simulation engine) instantiates a second module, then the second module can be simulated by the primary simulation engine.","In accordance with the method, certain variables in the secondary simulation engine modules can be identified as interface variables for communicating with the primary simulation engine. Values of these interface variables can be stored in both the serial simulation engine and the concurrent simulation engine.","The interface variable values can be transferred to the secondary simulation engine prior to evaluating events in the secondary simulation engine at the synchronization points. During this transfer, the interface variable values can be translated from a primary simulation engine storage representation to a secondary simulation engine storage representation. In one embodiment, only changed interface variable values are transferred at the synchronization points.","The interface variable values can also be transferred to the primary simulation engine after evaluating events in the secondary simulation engine at the synchronization points. During this transfer, the interface variable values can be translated from the secondary simulation engine storage representation to the primary simulation engine storage representation. In one embodiment, only changed interface variable values are transferred at the synchronization points.","Note that synchronization points in the execution model can be established through an industry standard application programming interface. Exemplary industry standard application programming interfaces include, but are not limited to, the Programming Language Interface (PLI) and the Verification Procedural Interface (VPI). In another embodiment, the synchronization points can be established through proprietary interfaces.","Notably, the secondary simulation engine module can be represented by a stub module in the primary simulation engine. This stub module includes the interface variables for a corresponding secondary simulation engine module. The stub module does not include a HDL of the corresponding secondary simulation engine module.","Another method of simulating a design described in HDL is provided. In this method, modules of the design can be partitioned into first modules for simulation by a serial simulation engine and second modules for simulation by a concurrent simulation engine. The first and second modules can be prioritized for simulation based on classes of events consistent with an execution model of the HDL. Using a computer, simulation of the serial simulation engine and the concurrent simulation engine can be synchronized for each class of events.","Synchronizing can include transferring updated interface variable values, which are shared by the second modules and at least a subset of the first modules, between the serial simulation engine and the concurrent simulation engine. This transferring can include translating representations of the updated interface variable values.","Each second module can be represented as a stub module in the serial simulation engine, wherein the stub module is one of the first modules. Values for an interface variable in the concurrent simulation engine can be stored in a word, wherein these values are associated with multiple instances of that stub module in the serial simulation engine.","Synchronizing can further include finishing the evaluation of one class of events in the serial simulation engine, and then transferring the updated interface variable values to the concurrent simulation engine for evaluation of that same class of events. Synchronizing can yet further include finishing the evaluation of the one class of events in the concurrent simulation engine, and then transferring the updated interface variable values to the serial simulation engine for evaluation of (1) that same class of events when new events in that class were generated by the concurrent simulation engine or (2) a next class of events, if present, in accordance with the execution model of the HDL.","In one embodiment, the HDL is Verilog and the one class of events is one of active events, inactive events, and non-blocking assignment update events. In one embodiment, synchronizing can includes progressing through all classes of events using the serial simulation engine and the concurrent simulation engine based on priorities of the classes of events specified by the HDL.","A conventional logic simulator executes one simulation at a time in a technique referred to herein as a \u201cserial simulation engine\u201d. In order to achieve adequate performance, a serial simulation engine is designed to execute each simulation as quickly as possible. Pending U.S. patent application Ser. No. 12\/586,724, entitled \u201cConcurrent Simulation Of Hardware Designs With Behavioral Characteristics\u201d, filed on Sep. 24, 2009, and incorporated by reference herein, describes a technique for efficiently performing concurrent simulations of a hardware design, herein referred to as a \u201cconcurrent simulation engine\u201d. Concurrent simulation engines achieve performance by executing several simulations at once.","Depending on the implementations of the serial and concurrent simulation engines as well as the particular characteristics of the hardware design being simulated, it may be desirable to execute certain parts of the hardware design using a serial simulation engine and certain other parts of the hardware design using a concurrent simulation engine. A software-based technique for integrating a concurrent simulation engine and a serial simulation engine into a single integrated logic simulator is described below. A logic simulator resulting from this integration is hereafter referred to as an \u201cintegrated logic simulator\u201d.","Note that logic simulators implement a particular execution model, as dictated by the Hardware Description Language (HDL). For purposes of describing the integrated logic simulator, the Verilog HDL will be used. However, the integrated logic simulator can be applied to other HDLs and the execution models associated with those HDLs.","The Verilog HDL is interpreted according to an underlying discrete event execution model. Several event queues are defined from which events execute. Events are (1) generated as the simulation progresses, (2) placed on a particular queue, (3) removed from the queue at a particular point in time during the simulation as dictated by the execution model, and (4) executed. Executing events, in turn, may generate additional events that are placed on a queue for later execution. This sequence involving events continues until no more events are generated, at which point the simulation terminates.","Typically, a hardware design to be simulated is expressed as multiple modules in the Verilog HDL. Often there is a correspondence between Verilog modules and actual hardware subcomponents, but this does not necessarily need to be the case (e.g. a Verilog module may represent abstract functionality or behavior that is not implemented by a single hardware subcomponent). Verilog modules are arranged in a hierarchy, with an instance of a module said to be \u201cembedded\u201d in another module. For example, a module for a microprocessor might be decomposed into various arithmetic modules, logic modules, control modules, and storage modules. Within the microprocessor module, there are embedded instances of each constituent module organized in a hierarchy.","Each instantiated Verilog module generates events for execution by the logic simulator according to the specification of the Verilog HDL execution model. Verilog HDL logic simulators should adhere to the execution model, whether they are implemented using only a serial simulation engine, only a concurrent simulation engine, or a combination of a serial simulation engine and a concurrent simulation engine (the latter being the integrated logic simulator described herein).","For example,  shows a subset of the queues specified by the Verilog HDL execution model. The Verilog HDL execution model requires that all active events  from the active event queue of the logic simulator be executed before any inactive events  from the inactive event queue of the logic simulator are executed. Once the active and inactive event queues are exhausted, then non-blocking assignment (NBA) update events  from the NBA update event queue are executed. Note that there are other queues in the Verilog HDL execution model beyond those shown in  with established rules for advancing from one queue to another as the simulation progresses.","In an integrated logic simulator using both a serial simulation engine and a concurrent simulation engine, the HDL program describing the hardware design can be partitioned into two groups of modules. One group of modules is executed by a serial simulation engine and another group of modules is executed by a concurrent simulation engine. Advancing from one queue to another queue in the integrated logic simulator must be coordinated across the serial simulation engine and the concurrent simulation engine, so that the integrated logic simulator does not violate the Verilog HDL execution model (e.g. that NBA update events are not executed while there are still active events and inactive events to execute in either the serial simulation engine or the concurrent simulation engine).","Verilog modules interact with each other through input\/output port variables. A Verilog module can also read and write directly to internal variables in other module instances through a facility known as cross-module references (the mechanics of which are known to those skilled in the art and therefore are not described herein). These internal variables, which are used in inter-module interactions, can be identified and are referred to as \u201cinterface variables\u201d for a module.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 2","FIG. 2"],"b":["202","201","202","201","202","1","2","201","202","1","202","201"]},"Notably, when a module assigned to the serial simulation engine interfaces with a module assigned to the concurrent simulation engine, the serial simulation engine module can interact with a stub module that serves as a placeholder for the concurrent simulation engine module. This stub module can contain all the interface variables of the embedded module. Referring back to the design shown in , the top-level module can be assigned to the serial simulation engine and the adder module can be assigned to the concurrent simulation engine. In this case, instead of seeing the adder module RTL, the serial simulation sees a stub module for the adder.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 3A","FIG. 2","FIG. 3B","FIGS. 4A and 4B"],"b":["300","200","310","310"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIGS. 4A and 4B","FIG. 4A","FIG. 2","FIG. 4B"],"b":["201","202","401","402","202","402","401","202"]},"In the configuration shown in , serial simulation engine  can have its own storage  allocated for each interface variable (one shown). Values can be written into the interface variables that act as inputs to stub module A, and values are read from the interface variables that act as outputs to stub module A. Likewise, concurrent simulation engine  can have its own storage  allocated for each interface variable (one shown). Values can be read from the interface variables that act as inputs to the concurrent simulation engine module, i.e. adder module , and values can be written into the interface variables that act as outputs to adder module . As indicated above, value changes of the interface variables in adder module  will be reflected in stub module A, thereby ensuring proper functioning of top module . Similarly, value changes of the interface variable in stub module A will be reflected in adder module  to ensure its proper functioning.","Note that variables that are not interface variables are stored in either serial simulation engine  or concurrent simulation engine , but not both. In other words, the shared state between serial simulation engine  and concurrent simulation engine  in the integrated logic simulator is limited to interface variables.","Notably, the serial simulation engine and the concurrent simulation engine can utilize different representations for storing variable values. In one embodiment, the serial simulation engine can use a representation in which multiple values for the variable are stored, one for each simulation. For example, referring to a serial simulation engine  shown in , consider a variable value representation for an eight-bit variable V that has values for four different simulations: simulation , simulation , simulation , and simulation . Each simulation for variable V stores eight bits. In contrast, referring to a concurrent simulation engine  shown in , the values of the four simulations are stored in multiple four-bit words. Specifically, there are eight such words allocated, one for each bit in the variable V (i.e. V[]-V[]). Boxes  and  in , respectively, illustrate how values for a single bit across multiple simulations are organized in serial simulation engine  and concurrent simulation engine  (see, e.g. bits A, B, C, and D).","Because there are two copies of the interface variables, i.e. one in the serial simulation engine and one in the concurrent simulation engine, these two copies must remain synchronized when updated so that the integrated logic simulator keeps a consistent view of the entire simulation state. In some embodiments, interface variable values are synchronized at the beginning and at the end of queue evaluations. Synchronizing the interface variable values requires translating between the serial simulation engine representation (see, e.g. ) and the concurrent simulation engine representation (see, e.g. ) for storing variable values.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 6A","b":["600","600","600","601","611","601","600","600"]},"In step , the port interface variable values for the concurrent simulation engine module are transferred from serial simulation engine A to translate and synchronize function . This translate and synchronize function  includes translating from the storage representation used by serial simulation engine A to that used by concurrent simulation engine B (e.g. from the storage representation shown in  to that shown in ). In step , active events  are executed in concurrent simulation engine B based on the translated, transferred port interface variable values. In step , the port interface variable values for the concurrent simulation engine module are transferred to serial simulation engine A via translate and synchronize function . In this direction, translate and synchronize function  includes a translation from the storage representation used by concurrent simulation engine B to that used by serial simulation engine A.","Note that translate and synchronize function  forms part of glue logic . This glue logic provides both compile time functions and runtime functions. The compile time functions include ensuring that when serial simulation engine A is given a source code for all modules, the concurrent simulation engine B is provided the definitions of modules assigned to it, while the serial simulation engine A is provided stub definitions for the same modules. The runtime functions include ensuring that once the simulator begins to run and generate events, a translation of the interface variables between the serial and concurrent simulation engines is provided. The runtime functions also include ensuring the proper synchronizing of simulations in both serial simulation engine A and concurrent simulation engine B, so that execution of the queues in serial simulation engine A conforms to Verilog HDL execution model. Thus, translate and synchronize function  forms part of the runtime functions of glue logic .","Note that executing active events  in concurrent simulation engine B may have generated additional active events  in serial simulation engine A, which is indicated by step  (synchronized using translate and synchronize function ). These new events are then executed per the Verilog HDL execution model, and then steps , , , and  are repeated using translate and synchronize function . When there are no active events  in serial simulation engine A (based on additional active events generated by concurrent simulation engine B or active events already queued in serial simulation engine A), then inactive events  from the inactive event queue of serial simulation engine A can be executed according to the Verilog HDL execution model.","The synchronization described in reference to the active queue in  can be extended to other queue evaluations in the Verilog HDL execution model. For example,  illustrates an exemplary extension including the active event queues (active events  and ), the inactive event queues (inactive events  and ), and the NBA update event queues (NBA update events  and ) for serial simulation engine A and concurrent simulation engine B. The active, inactive, and NBA update queues between serial simulation engine A and concurrent simulation engine B are synchronized using translate and synchronize functions , , and , respectively (which form part of glue logic ).","After a queue is evaluated in serial simulation engine A, the interface variable values are transferred to concurrent simulation engine B. The events are then executed from the corresponding queue in concurrent simulation engine B. The interface variable values containing the results of the event executions are then transferred back to serial simulation engine A, which in turn progresses from queue to queue according to the Verilog HDL execution model. Note that, as indicated in , any event executed in either serial simulation engine A of concurrent simulation engine B may generate one or more events of either higher or lower priority. In general, the translate and synchronize function is notified whenever any new event is generated by concurrent simulation engine B, wherein that new event is then placed in the appropriate queue of serial simulation engine A.","Note that exemplary queues based on the Verilog HDL are described above, including active events, inactive events, and NBA update events. However, an integrated logic simulator can advantageously apply to other HDLs and the execution models associated with those HDLs. Therefore, in general, the integrated logic simulator can work with all classes of events provided by a specific HDL. Moreover, each specific HDL can have different queue transition rules, which can be honored by the integrated logic simulator.","For example,  illustrates the simulation execution order of exemplary queues in a VHDL (very high speed integrated circuit (VHSIC) HDL) model. Note that in the VHDL model, the order of execution progresses through signal update events, function evaluation events, and process evaluation events with control also flowing in this direction until reaching the end of process execution, at which point control returns to signal update. As described above, each execution transition between serial simulation engine A and concurrent simulation engine B can be facilitated using glue logic , which includes translate and synchronize functions , , and .","Consider an example below in which related active events and NBA update events are executed in an integrated logic simulator. These events come from three assignments (wherein a Verilog assignment includes writing a computed, variable value to a memory location): two assignments in a module simulated by the serial simulation engine and one assignment from a module simulated by the concurrent simulation engine:","Serial Simulation Engine",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Active event."]},{"entry":[{},"always @(posedge CLK)"]},{"entry":[{},"A = B + 1;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/","NBA update event."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"always @(posedge CLK)"]},{"entry":[{},"C <= D;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Active event."]},{"entry":[{},"always @(A)"]},{"entry":[{},"B = A + 2;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the above example, when a CLK triggers at a positive edge, two events are generated. One event is placed in the serial simulation engine active event queue and another event is placed in the serial simulation engine NBA update event queue. In accordance with the priority sequence described for , the active event executes first according to the Verilog HDL execution model, after which the serial simulation active event queue is empty. This empty state causes the integrated logic simulator to synchronize with the concurrent simulation engine according to the four-step process described in reference to . Specifically,","The value for variable A is transferred from the serial simulation engine to the concurrent simulation engine.","Active events are executed in the concurrent simulation engine.","The updated value for variable B is transferred from the concurrent simulation engine to the serial simulation engine.","Because of active events executed in the concurrent simulation, there may be additional work to do (i.e. new active events) in the serial simulation engine before progressing to the next queue evaluation. Therefore, the process returns to the active event queue in the serial simulation engine.","At this point, there are no more active events in the serial simulation engine to execute. Moreover, there are no inactive events, either in the serial simulation engine or in the concurrent simulation engine (the latter point being determined after synchronizing with the concurrent simulation engine on the inactive event queue in a manner outlined in ), meaning that the serial simulation can execute the pending NBA update event, which writes to variable C.","In one embodiment, only the modified interface variables (or, alternatively, only the modified bits in the interface variables) are synchronized at queue evaluation points in order to reduce the amount of work that needs to be done. In other embodiments, only the simulations with modified interface variables are synchronized at queue evaluation points. A queue evaluation point can occur when all events in a specific queue in one simulation engine have been finished. In one embodiment, a queue evaluation point can trigger synchronization, i.e. the glue logic transferring any updated interface variables to the corresponding queue for execution in the other simulation engine. However, in other embodiments, a change in one or more interface variables can trigger synchronization. Thus, synchronization can occur (in whole or in part) before queue evaluations, after queue evaluations, or both before and after queue evaluations.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 7","b":["701","700","712","700","701","702","702","702","702","702","702","700","712","700"]},"Advantageously, this aspect provides significant leverage for the integrated logic simulator. Specifically, each stub module in serial simulator engine A can have separate storage for each interface variable, whereas the corresponding module in concurrent simulation engine B can have one word capable of storing multiple values, thereby allowing that word to store the interface variable values associated with multiple stub modules. For example, in , stub adder modules A-D can have storage A-D, respectively, for each interface variable. In contrast, adder module  in concurrent simulation engine B needs only one word  to store those interface variables from each of stub adder modules A-D.","Assuming the values stored in storage A-D are one-bit values (e.g. a clk value), then each bit of word  can correspond to a value stored by a specific stub module (i.e. A\u21c4A\u2032, B\u21c4B\u2032, C\u21c4C\u2032, D\u21c4D\u2032). Thus, if the interface variable value in storage C in the serial simulation engine A has changed during execution of an event, then that value will be transferred to bit C\u2032 in the concurrent simulation engine B during synchronization. Note that this transfer includes the same translation described in reference to . Further note that other embodiments may have multi-bit values stored in serial simulation engine A, which can be transferred as multi-bit values to positions of one word of concurrent simulation engine B. This storage configuration allows concurrent simulation engine B to perform multiple (i.e. 4) concurrent simulations with multiple (i.e. 4) values in adder module .","Advantageously, many computers used for logic simulation have extended word values, e.g. registers of 32, 64, or 128 bits. Thus, the concurrent simulation engine of an integrated logic simulator can concurrently apply the same operation to a considerable amount of data stored in one word.","In the above-described embodiment, the serial simulation engine can be the primary simulation engine of the integrated logic simulator, in the sense that it is the serial simulation engine that invokes the concurrent simulation engine at the synchronization points. In other embodiment, the reverse configuration is also possible, i.e. in which the concurrent simulation engine is the primary simulation engine, advancing from queue to queue according to the Verilog HDL execution model and invoking the serial simulation engine at the appropriate synchronization points. In one embodiment, the synchronization points in the execution model can be established through an industry standard application programming interface, such as the Programming Language Interface (PLI) or the Verification Procedural Interface (VPI), which are used to implement user-defined extensions to the Verilog simulation. In another embodiment, the synchronization points in the execution model can be established through one or more proprietary interfaces.","In one embodiment, the partitioning of the design to determine which modules can be instantiated as stub modules (and with associated concurrent simulation performed in the concurrent simulation engine) can be performed manually by a user. In another embodiment, this partitioning can be performed automatically by the simulation tool based on the number of potential instances (i.e. the greater the number of instances, the greater the leverage achievable by the concurrent simulation engine). In yet another embodiment, partitioning can be done based upon the capabilities of the serial simulation engine and\/or capabilities of the concurrent simulation engine to achieve a desirable level of simulation performance. For example, if a module makes extensive calls to user-defined C functions through a PLI (Programming Language Interface), then that module may be better suited for execution by a serial simulation engine because the user-defined function was mostly likely written without the ability to take advantage of the value representation of the concurrent simulation engine.","Note that partitioning of the design can be done with the design hierarchy taken into account. For example, in one embodiment, a first module being simulated by the secondary simulation engine implies that all sub-modules instantiated deeper within the design hierarchy under the first module are also simulated by the secondary simulation engine. In another embodiment, if the first module (simulated by the secondary simulation engine) instantiates a second module, then the second module can be simulated by the primary simulation engine. As noted above, the primary simulation engine can be the serial simulation engine and the second simulation engine can be the concurrent simulation engine (and vice versa).","For example, the following code provides an exemplary case of the flexibility inherent in the integrated logic simulator.",{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Original Verilog"]},{"entry":[{},"module top_module;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"reg clk;"]},{"entry":[{},"reg [7:0] input1;"]},{"entry":[{},"reg [7:0] input2;"]},{"entry":[{},"wire [7:0] sum;"]},{"entry":[{},"wire [7:0] product;"]},{"entry":[{},"adder_and_mult am(.clk(clk),"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},".a(input1),"]},{"entry":[{},".b(input2),"]},{"entry":[{},".sum(sum),"]},{"entry":[{},".product(product));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endmodule"]},{"entry":[{},"module adder_and_mult(clk, a, b, sum, product);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"input clk;"]},{"entry":[{},"input [7:0] a;"]},{"entry":[{},"input [7:0] b;"]},{"entry":[{},"output [7:0] sum;"]},{"entry":[{},"output [7:0] product;"]},{"entry":[{},"always @(posedge clk)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sum = a + b;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"multiplier mult(.clk(clk),"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},".a(a),"]},{"entry":[{},".b(b),"]},{"entry":[{},".product(product));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endmodule"]},{"entry":[{},"module multiplier(clk, a, b, product);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"input clk;"]},{"entry":[{},"input [7:0] a;"]},{"entry":[{},"input [7:0] b;"]},{"entry":[{},"output [7:0] product;"]},{"entry":[{},"always @(posedge clk)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"product = a * b;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endmodule"]},{"entry":[{},"\/\/ Verilog + stub modules simulated by the serial simulation"]},{"entry":[{},"engine."]},{"entry":[{},"\/\/ To be simulated by the serial simulation engine."]},{"entry":[{},"module top_module;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"reg clk;"]},{"entry":[{},"reg [7:0] input1;"]},{"entry":[{},"reg [7:0] input2;"]},{"entry":[{},"wire [7:0] sum;"]},{"entry":[{},"wire [7:0] product;"]},{"entry":[{},"adder_and_mult am(.clk(clk),"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},".a(input1),"]},{"entry":[{},".b(input2),"]},{"entry":[{},".sum(sum),"]},{"entry":[{},".product(product));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endmodule"]},{"entry":[{},"\/\/ To be simulated by the concurrent simulation engine."]},{"entry":[{},"module adder_and_mult(clk, a, b, sum, product);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"input clk;"]},{"entry":[{},"input [7:0] a;"]},{"entry":[{},"input [7:0] b;"]},{"entry":[{},"output [7:0] sum;"]},{"entry":[{},"output [7:0] product;"]},{"entry":[{},"multiplier mult(.clk(clk),"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},".a(a),"]},{"entry":[{},".b(b),"]},{"entry":[{},".product(product));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endmodule"]},{"entry":[{},"\/\/ To be simulated by the serial simulation engine."]},{"entry":[{},"module multiplier(clk, a, b, product);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"input clk;"]},{"entry":[{},"input [7:0] a;"]},{"entry":[{},"input [7:0] b;"]},{"entry":[{},"output [7:0] product;"]},{"entry":[{},"always @(posedge clk)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"product = a * b;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endmodule"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Note that  illustrates a block diagram representing the above code. In this embodiment, serial simulation engine  is made responsible for a top module , which includes stub adder and multiplier module A. A concurrent simulation engine  is made responsible for an embedded adder and multiplier module . In this case, the actual adder HDL can be simulated by concurrent simulation engine  and concurrent simulation engine  can interact with stub module A for the embedded multiplier module. In this embodiment, adder and multiplier module  includes a stub multiplier module A, which interacts with multiplier module  in serial simulation engine . In other words, any sub-modules (any module directed to perform the simulation from a stub module) instantiated deeper within a design hierarchy under a module can be structured to be done by either serial simulation engine  or concurrent simulation engine . Note that in general, this transfer of simulation responsibility between serial simulation engine  and concurrent simulation engine  can be performed any number of times and can be structured to optimize system resources.","Note that although the concurrent simulation engine has been described above as executing events for an adder module, which is embedded in the top module, an integrated logic simulation is equally applicable to other types of top\/embedded modules. For example, another embedded module can include a device under test (DUT), which can be represented in the serial simulation engine as a stub module. In this case, the top module can include a test bench.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 9","b":["900","910","940","950","960","970"]},"The EDA software design process (step ) is actually composed of a number of steps -, shown in linear fashion for simplicity. In an actual ASIC design process, the particular design might have to go back through steps until certain tests are passed. Similarly, in any actual design process, these steps may occur in different orders and combinations. This description is therefore provided by way of context and general explanation rather than as a specific, or recommended, design flow for a particular ASIC.","A brief description of the components steps of the EDA software design process (step ) will now be provided:","System design (step ): The designers describe the functionality that they want to implement, they can perform what-if planning to refine functionality, check costs, etc. Hardware-software architecture partitioning can occur at this stage. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include Model Architect, Saber, System Studio, and DesignWare\u00ae products.","Logic design and functional verification (step ): At this stage, the VHDL or Verilog code for modules in the system is written and the design is checked for functional accuracy. More specifically, the design is checked to ensure that it produces the correct outputs. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include VCS, VERA, DesignWare\u00ae, Magellan, Formality, ESP and LEDA products. In one embodiment, the above-described integrated logic simulator can be implemented during logic design and functional verification step .","Synthesis and design for test (step ): Here, the VHDL\/Verilog is translated to a netlist. The netlist can be optimized for the target technology. Additionally, the design and implementation of tests to permit checking of the finished chip occurs. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include Design Compiler\u00ae, Power Compiler, DFTMAX, TetraMAX, and DesignWare\u00ae products.","Netlist verification (step ): At this step, the netlist is checked for compliance with timing constraints and for correspondence with the VHDL\/Verilog source code. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include Formality, PrimeTime, and VCS products.","Design planning (step ): Here, an overall floorplan for the chip is constructed and analyzed for timing and top-level routing. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include Astro and IC Compiler products.","Physical implementation (step ): The placement (positioning of circuit elements) and routing (connection of the same) occurs at this step. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include the Astro and IC Compiler products.","Analysis and extraction (step ): At this step, the circuit function is verified at a transistor level, this in turn permits what-if refinement. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include AstroRail, PrimeRail, Primetime, and Star RC\/XT products.","Physical verification (step ): At this step various checking functions are performed to ensure correctness for: manufacturing, electrical issues, lithographic issues, and circuitry. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include the Hercules product.","Resolution enhancement (step ): This step involves geometric manipulations of the layout to improve manufacturability of the design. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include Proteus, ProteusAF, and PSMGen products.","Mask data preparation (step ): This step provides the \u201ctape-out\u201d data for production of masks for lithographic use to produce finished chips. Exemplary EDA software products from Synopsys, Inc. that can be used at this step include the CATS(R) family of products.","The integrated logic simulator described above can be run using one or more computer programs that execute on a programmable system including at least one programmable processor coupled to receive data and instructions from, and to transmit data and instructions to, a data storage system, at least one input device, and at least one output device. Each computer program can be implemented in a high-level procedural or object-oriented programming language, or in assembly or machine language if desired; and in any case, the language can be a compiled or interpreted language. Suitable processors include, by way of example, both general and special purpose microprocessors, as well as other types of micro-controllers. Generally, a processor will receive instructions and data from a read-only memory and\/or a random access memory. Generally, a computer will include one or more mass storage devices for storing data files; such devices include magnetic disks, such as internal hard disks and removable disks, magneto-optical disks, and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, such as EPROM, EEPROM, and flash memory devices, magnetic disks such as internal hard disks and removable disks, magneto-optical disks, and CDROM disks. Any of the foregoing can be supplemented by, or incorporated in, application-specific integrated circuits (ASICs).","A detailed description of one or more embodiments of the invention is provided above along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments, but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives, modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity, technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
