---
title: Algorithm for localization of a JAVA application using reflection API and a custom class loader
abstract: A method and corresponding apparatus for localization of a JAVA® application using a reflection API and a custom class loader use specifics of JAVA® language to provide localization of certain data elements, i.e., variables, of the application during class loading. The method and corresponding apparatus for localization reduce complexity of the JAVA® application by eliminating the function code dedicated to localization. In addition, the method and apparatus for localization increase productivity of engineers who write language-independent code, and reduce memory consumption of classes that use localized strings. Since all localization is accomplished when the class is loaded and since the code that uses localization is independent of the code performing localization, the method and apparatus for localization ensure better performance of the application and afford better code reusability.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06944846&OS=06944846&RS=06944846
owner: Hewlett-Packard Development Company, L.P.
number: 06944846
owner_city: Houston
owner_country: US
publication_date: 20011214
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The technical field relates to JAVA\u00ae applications, and, in particular, to JAVA\u00ae applications whose user interfaces support multiple human languages. (JAVA is a trademark of Sun Microsystems, Inc.)","Localization is a process of adding support of another human language (referred to as target language) to an application. Localization can be divided into two parts: localization of user interface data and localization of other data. User interface data includes a limited number of data elements, which are defined during application development. User interface data elements can be defined in text, graphics or other form.","User interfaces of many applications can be localized if an environment supports the target language. The term \u201cenvironment\u201d includes operating system, programming language and application libraries, fonts and character tables. If the environment supports the target language, the localized version of the application for the target language can be created using the following \u201cstraightforward\u201d method: take source or binary code of the application and replace string constants with corresponding string constants in the target language. The straightforward method is expensive for large applications because: a) the localization process must be repeated for every new version of the application; and b) the personnel that perform the localization must deal with the application source or binary code.","A widely known solution to the problems of the straightforward method is to keep language-specific data in resource files, because multi-language support in application architecture can reduce cost of localization. The resource files contain key-value pairs, and the application locates data elements in the resource files by finding a value corresponding to a certain key. However, this approach also has a disadvantage: the programmer has to write a function call for every localized string, which results in large amount of function code dedicated to localization, for example, to retrieve localized strings for a current language.","The JAVA\u00ae programming language simplifies the implementation of resource file-based solution by providing java.util.ResourceBundle class in the standard library. This class provides support for human language-specific resource files. However, if the programmer uses class ResourceBundle directly, the amount of code dedicated to localization still remains large. In addition, localization-specific code is typically spread all over the application code, making it difficult to read and maintain.","A method for localization of a JAVA\u00ae application includes locating a plurality of localizable variables of a class using a custom class loader, finding a corresponding resource file for a current language for each localizable variable, and calculating a key for each localizable variable. The method further includes finding a localized string in the resource file corresponding to each key, and assigning the localized string to the corresponding localizable variable of the class. Accordingly, the custom class loader provides localization of the class during class loading.","The method and corresponding apparatus for localization reduce complexity of the JAVA\u00ae application by eliminating the function code dedicated to localization. In addition, the method and apparatus for localization increase productivity of engineers who write language-independent code, and reduce memory consumption of classes that use localized strings. Since all localization is accomplished when the class is loaded and since the code that uses localization is independent of the code performing localization, the method and apparatus for localization ensure better performance of the application and afford better code reusability.","Many applications need to provide multi-language support in the user interfaces. For example, an application may support English and Japanese. A user may choose the language during an installation or when the application starts. In some cases an application determines the language based on the operating system's default language. After the user specifies the language the application will communicate with the user in the specified language. For example, if the user selects \u201cJapanese\u201d, the application will display its messages in Japanese.","The user interface of the application typically contains characters, words, phrases and sentences in the user's language. These characters, words, phrases and sentences are usually defined as \u201cstrings\u201d in the application. These strings can be located in the application code and\/or in resource files transferred together with the application.","A method and corresponding apparatus for localization of a JAVA\u00ae application using a reflection API and a custom class loader use specifics of JAVA\u00ae language to provide localization of certain data elements, i.e., variables, of the application during class loading. The method and apparatus for localization provide a technique to localize static class variables, so that the data elements of a particular class are localized when the class loader loads that class. The method and apparatus typically apply to localization of user interface data elements defined as text.","The method and apparatus for localization reduce complexity of the JAVA\u00ae application by eliminating the function code dedicated to localization. The custom class loader is added to the application to support localization by inspecting the application code loaded from a storage device, such as a disk or Network, together with the application. The custom class loader may be added during code transferring process to inspect the code and convert all strings of the application to localized strings. As a result, the application may become less complicated, because many programmatic errors may be eliminated during the process.","In addition, the method and apparatus for localization increase productivity of engineers who write language-independent code, and reduce memory consumption of classes that use localized strings. Since all localization is accomplished when the class is loaded and since the code that uses localization is independent of the code performing localization, the method and apparatus for localization ensure better performance of the application and afford better code reusability.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["115","110","120","120","115","125","130","130","130","120","130"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 2","FIG. 1"],"b":["210","125","120","210","210","215","110","215","210","230","220","210","225","130","230","220","210","240","210","240","240","220","210","120","220","230","240","220","130","240"]},"The following rules are defined for an exemplary implementation of the method and apparatus for localization. Rule 1 is for distinguishing a plurality of localizable variables from all other variables by a variable name, whereas Rule 2 is for locating a resource string in the resource files  by a class name and the variable name. A localizable variable is a class variable that, for example, belongs to a public class, is a public static but not final variable, and has type java.lang.String. Rules 1 and 2 may be documented so that application developers can use the rules for defining the localizable variables and specifying keys in the resource files .",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 3","FIG. 3"],"b":["210","210","215","110","305","230","310","210","215","320","215"]},"Next, the custom class loader  calculates a key for each localizable variable according to Rule 2 by, for example, deleting the prefix and combining the class name and variable name (block ). Then, the custom class loader  finds a localized string in the resource file  corresponding to each key (block ). This step may be easily implemented by a skilled JAVA\u00ae programmer. Finally, the custom class loader  assigns the localized string to the corresponding localizable variable, if the string is found (block ). If more localizable variables exist (block ), blocks - repeat.","Another embodiment of the method for localization generates resource files  for a default language (for example, English) using the same principles as the steps described above. The resource files  may serve as documentation for developers that create resource files  for other languages. This process utilizes initial values of the localizable variables. The following Listing 1 shows a class with localizable variables that have default values.",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"package com.hp.sgmgr.tree;"},{"entry":"public class Strings {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public static String LOC_OBJECT_MANAGER = \u201cObject"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Manager\u201d;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public static String LOC_CLUSTERS = \u201cAll Clusters\u201d;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, following block  of the algorithm in , if the key exists in the resource files , the process goes to block  (block ). If not, the custom class loader  appends the key and the value of the localizable variable to the resource file  (block ). This process may be invoked once after all localizable variables are defined in the application.","After the custom class loader  is implemented, the launcher  may be created with a method, such as a main method of the launcher , i.e., main (String [ ]). The launcher  loads and runs the application startup class  using the custom class loader . The launcher  typically calls only one method of the application startup class , which runs the application. The name of the application startup class , the name and signature of the main method of the application startup class  may be application-specific. The launcher  may also pass parameters that are passed to the launcher's main method to the application's main method.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 2","FIG. 4"],"b":["220","220","220","210","410","220","240","210","420","210","240","422","240","220","210","240","130","220","210","220","240","230","430"]},"All classes of the application loaded by the custom class loader  may access the localizable variables, which may contain strings in the target human language at run time. As a result, the method and apparatus for localization allows a JAVA\u00ae application to use a single human language during execution. The target language can be specified either to the launcher  in the command line, or determined by the custom class loader  based on the default environment setting, or by any another method that is convenient for the implementation.","The following illustrates an exemplary implementation of the method for localization using a reflection API and a custom class loader. In this example, the rules are identified as follows:\n\n","The resource file name for the target language is constructed by passing the base name and JAVA\u00ae Locale object to java.util.ResourceBundle class. The ResourceBundle class adds a postfix to the file name for locating the resource file  for specified human language. The resource file  is located in the same directory as the class file containing the variable. A key is constructed by concatenating the class name with variable name minus \u201cLOG_\u201d prefix, adding a dot (\u201c.\u201d) between the class name and variable name.","Listing 2 shows an example of a class with localizable variables.",{"@attributes":{"id":"p-0034","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package com.hp.sgmgr.tree;"]},{"entry":[{},"public class Strings {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static String LOC_OBJECT_MANAGER;"]},{"entry":[{},"public static String LOC_CLUSTERS;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"According to Rule 1, the class in Listing 2 contains two variables: \u201cLOC_OBJECT_MANAGER\u201d and \u201cLOC_CLUSTERS\u201d.","According to Rule 2, the base path\/file name of resource file  corresponding to both variables in this class is \u201ccom\/hp\/sgmgr\/tree\/localize.properties\u201d. The keys corresponding to these variables are \u201cStrings.OBJECT_MANAGER\u201d and \u201cStrings.CLUSTERS\u201d.","Listing 3 shows the resource file containing the values of localizable variables for the class from Listing 2 for English language.",{"@attributes":{"id":"p-0038","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Strings.OBJECT_MANAGER=Object Manager"]},{"entry":[{},"Strings.CLUSTERS=All Clusters"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Referring to Listing 3, class ResourceBundle, which is used in the exemplary implementation, supports this format of resource files . In this format, each line in the resource files  contains one key-value pair, where both the key and value are strings, and are divided by the \u201c=\u201d character.","In this example, the implementation of the custom class loader  uses class ResourceBundle for retrieving localized strings by keys. The custom class loader  accepts the target language code as a parameter to its constructor, and passes the target language code to ResoucreBundle, which locates resource files  corresponding to the target language. The constructor is a method or procedure that is invoked when an object is created in order to initialize the variables of the object. A class may have more than one constructors, and the JAVA\u00ae virtual machine  has rules that define which constructor to call. Finally, the launcher  reads a configuration file containing the target language specified at the time of installation, and passes the code of target language to the custom class loader  to create the custom class loader . Alternatively, the custom class loader  may also read the configuration file. As a further alternative, the target language is passed as a parameter to the launcher  by a user.",{"@attributes":{"id":"p-0041","num":"0042"},"figref":"FIG. 5","b":["500","500","518","500","502","512","514","516","510","508"]},"The memory  may include random access memory (RAM) or similar types of memory. The secondary storage device  may include a hard disk drive, floppy disk drive, CD-ROM drive, or other types of non-volatile data storage, and may correspond with various databases or other resources. The processor  may execute information stored in the memory , the secondary storage , or received from the Internet or other network . The input device  may include any device for entering data into the computer , such as a keyboard, keypad, cursor-control device, touch-screen (possibly with a stylus), or microphone. The display device  may include any type of device for presenting visual image, such as, for example, a computer monitor, flat-screen display, or display panel. The output device  may include any type of device for presenting data in hard copy format, such as a printer, and other types of output devices including speakers or any device for providing data in audio form. The computer  can possibly include multiple input devices, output devices, and display devices.","Although the computer  is depicted with various components, one skilled in the art will appreciate that the computer  can contain additional or different components. In addition, although aspects of an implementation consistent with the present invention are described as being stored in memory, one skilled in the art will appreciate that these aspects can also be stored on or read from other types of computer program products or computer-readable media, such as secondary storage devices, including hard disks, floppy disks, or CD-ROM; a carrier wave from the Internet or other network; or other forms of RAM or ROM. The computer-readable media may include instructions for controlling the computer  to perform a particular method.","While the method and apparatus for localization using a reflection API and a custom class loader have been described in connection with an exemplary embodiment, those skilled in the art will understand that many modifications in light of these teachings are possible, and this application is intended to cover any variations thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":["The preferred embodiments of a method and apparatus for localization using a reflection application programming interface (API) and a custom class loader will be described in detail with reference to the following figures, in which like numerals refer to like elements, and wherein:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
