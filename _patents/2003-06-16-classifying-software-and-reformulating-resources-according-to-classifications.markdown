---
title: Classifying software and reformulating resources according to classifications
abstract: Historically, resources (e.g., dynamic link libraries) were organized based on factors including the expertise of development teams. Unfortunately, this creates shared resources of much greater functionality than required by any one client application. By reformulating shared resources according to nodes reachable by classified applications, reformulated resources reduce the over-inclusive nature of shared resources formed based on the expertise of development teams. Further, layering resources for lower order classified applications also reduces memory requirements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07308684&OS=07308684&RS=07308684
owner: Microsoft Corporation
number: 07308684
owner_city: Redmond
owner_country: US
publication_date: 20030616
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","COPYRIGHT AUTHORIZATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","EXAMPLE 1","System Overview","EXAMPLE 2","Architectural Overview","EXAMPLE 3","Exemplary Method for Regrouping Resources","EXAMPLE 4","Exemplary Universe of Software Programs and Share Resources","EXAMPLE 5","Exemplary Method for Prioritizing Applications and Reorganizing Dynamic Link Libraries","EXAMPLE 6","Exemplary Qualities of New Resources","EXAMPLE 7","Exemplary Method for Obtaining Entry Points into Resources","EXAMPLE 8","Exemplary Method for Obtaining Applications and Associated Class","EXAMPLE 9","Exemplary Method for Coloring Entry Points into Resources","EXAMPLE 10","Exemplary Method for Creating Distribution List","EXAMPLE 11","Exemplary Method for Creating a Distribution List Including Reachable Nodes","EXAMPLE 12","Exemplary Resource Reformulation Method","EXAMPLE 13","Exemplary Coloring Method","EXAMPLE 14","Exemplary New Resources","EXAMPLE 15","Exemplary Features and Benefits","EXAMPLE 16","Exemplary Table Mapping Runtime","EXAMPLE 17","Exemplary Selections of Functionality","EXAMPLE 18","Computing Environment","ALTERNATIVES"],"p":["This application is related to U.S. application Ser. No.10\/463,480, filed Jun. 16, 2003, entitled \u201cReformulating Resources with Nodes Reachable from Defined Entry Points,\u201d which is incorporated herein by reference.","This invention relates generally to creating optimized resources, and more particularly to reformulating resources to contain nodes reachable by classified applications.","A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","Modern structured development creates software functionality delivered as a set of executable files instead of single monolithic programs. Many of these files are resources such as dynamic linked libraries (e.g. DLLs). Grouping functionality into such resources allows building software that shares the functionality. This allows defined groups of programmers to specialize in providing well-defined functionality quickly and correctly.","The boundaries that separate one DLL from another range from software engineering practices, abstraction and information hiding, domains of programmers expertise, or developer group dynamics. For the sake of completeness, more functionality is often implemented in a shared resource library, than is used by any one client application.","The described technologies provide methods and systems for reformulating shared resources to contain nodes reachable from a set of entry points.","One example of a method or system provides a distribution list of classified entry points, and new resource names. A classified entry point is traversed to find nodes reachable from the entry point, and the new resource is created containing the reachable nodes.","In another example, software (e.g., application(s)) is classified, and imports in the classified software are examined to determine resources on which the software depends. The resources are traversed in order to identify nodes reachable by the software from the imports. Nodes reachable from the imports are placed in a new resource. The new resource contains nodes reachable from classified application(s). By reformulating resources based on reachable nodes, the methods and systems provide memory and execution efficiencies.","In a further example, plural new resources are created according to software classified from higher to lower order classifications. Lower order classifications depend on higher order classifications in a one way dependency.","Additional features and advantages will be made apparent from the following detailed description, which proceeds with reference to the accompanying drawings.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1","b":["100","102","112","102","114","118","120","124","102","114","108","108","120","112","108","108","112","114","102","110","110","108","102","114","118","108","112","120","124","108","112","108","110","112"]},"Each programming team develops their respective library -, and exposes entry points to application programs -, so application programmers can use the respective functionality. This delegation of human resources, based on functionality, allows application programmers to rely on services provided by experts in respective library groupings -. Further, library developers are able to rely on functionality provided by other libraries -. In this example, multiple applications -, utilize various functionality provided by the respective libraries -. In this example, when an application  is loaded into memory for execution, the application is examined to determine what resources it may rely on. In order to execute that application, these resources are typically loaded into virtual memory and made available in case the application - requests corresponding services -. With this arrangement, exit points - from an application  require loading multiple libraries - into memory. Additional memory is required to hold these resources - in memory for the application . Further, the entire resource  is loaded into memory even though the application  may only require a small percentage of the services supported by the resource . Similarly, other resources - are loaded into memory to support the application , even though only a small percentage of the services in the resources may be utilized. In practice, it is not unusual to find that the combined services reachable by the application within all libraries - is smaller than the size of any individual library .",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 2","FIG. 3"],"b":["200","108","112","202","206","204","208","102","106","108","112","222","218","220","218","222","202","102","106","302","306","302","302","102","104","302","202","302","306","302","306"]},"Additionally, the system  receives as input two or more resources -. Starting with the one or more applications in the first classification , the node identifier  walks the control flow graph for each of the exit points - to the resources - respectively. For example, the node identifier  determines from an exit point  into a resource  a node within the resource  called by the software file . Often, the call  includes an identification of the resource and of the node within the resource . A node (e.g., basic block, procedure, object, etc.) is one or more instructions and\/or data to the processor to perform services. The node identifier continues to walk the control flow from node to node from the exit point , through the resource  identifying any nodes within the resource  reachable from that exit point . Further, if any node within the resource , calls a node -, the node identifier walks through any such resource identifying reachable nodes. Additionally, the node identifier  identifies other nodes in other resources - reachable - in the control flow graph.","The node identifier  identifies nodes reachable from the application  through any of the control flow paths accessed through the exit points - to the resources -. Additionally, the node identifier identifies any nodes reachable by any node reachable within the control flow in any of the resources -. Thus, the node identifier identifies any of the nodes which could potentially be accessed when executing the application .","The resource reformulator  assembles all of the reachable nodes in a new resource . With this arrangement , the one or more applications in the first classification , have a number of exit points  into a resource  that includes the universe of nodes reachable by those one or more applications . Assembling these services represented by the nodes in the new resource , makes them available from the single source . This way a highest order application has the services it may require available in one resource .","Finally, the dependency redirector  redirects the exit points  to the single resource  and redirects the edges between the nodes within the resource . Thus, nodes that directed edges to other resources now direct those edges to the nodes within the same resource .","The system  continues with the second highest one or more applications . For example, if a second application  was categorized in the second classification  the exit points from that application , , , are traversed by the node identifier . As before with the first class, all of the nodes reachable from the one or more second class applications are identified by the node identifier . Of course, the node identifier  by identifying all the nodes accessible by the one or more second class applications  may include nodes accessible by the first class one or more applications . The resource reformulator  determines which nodes are already located in the first resource , and places only nodes accessible by the second class one or more applications , that are not also accessible by the one or more first class applications , into the second resource . Thus, the first resource includes nodes accessible or reachable by the one or more first class applications . The second resource , includes nodes accessible by the one or more second class applications  that have not already been placed in the new first resource . This results in the condition that all nodes reachable by the second class one or more applications  are located at either the first resource  or the second resource . The dependency redirector  then redirects the entry points ,  to the resource -, respectively, where the corresponding nodes are located. Additionally, the dependency redirector  redirects  any of the nodes in the second resource , to nodes in the first resource , if they so depend. This results in a condition where a second class one or more application  requires only two resources , , in order to provide all of the services that are reachable by that one or more second class application . Finally, for a last classification for one or more applications , the exit points from those one or more applications are walked in order to determine the nodes reachable by those one or more applications. As before, the resource reformulator , reformulates any of the nodes reachable by the last class one or more applications , into a last resource , if those nodes are not already located in a higher order resource -.","Finally, the dependency redirector  redirects the edges of the reachable nodes according to the new dependency locations of the resources -. With the described system , applications with a highest order classification can execute with the fewest required number of resources in memory. Yet for lower frequency or less desirable applications the lower ordered resources -, are available and loaded into memory at such times when they are less frequently needed.","Using the described scenario of classified applications, and nodes organized in new resources according to the classifications, three new resources have been produced -. However, as previously discussed, the original resources - often contain more functionality than is required by any one application. In fact, it is not unusual to have nodes in the original resources -, that have not been reachable by any of the classified applications -.","Thus, if a non-classified application requests node(s) that were not reachable by the classified applications, those nodes are not available in the new resources -.","Optionally, another new resource  is created to contain nodes unreachable by the classified applications. As later discussed with respect to , DLLs have export tables which include symbols representing entry points in the DLL. From these entry points in the original resources -, the node identifier identifies nodes reachable from these entry points. For each entry point, the reachable nodes are located by the node identifier , and are checked by the reformulator , to see if they are already in an existing new resource -. If the reachable nodes are not already in a new resource, they are placed in the heretofore unreachable node new resource . The dependency redirector  then redirects the edges of the unreachable nodes, according to the reachability from the entry points not accessed by the classified applications. For example, if a node reachable from an entry point not imported by a classified application reaches a node in a prior reachable resource -, the edges are redirected to those reachable nodes , , . Further edges between unreachable nodes are maintained within the new resource .","Since, at the time of formulating this new unreachable resource , there is no known application requiring a change to its import table, forwarder DLLs are created to resolve the new location of the entry points not requested by classified applications (e.g., see the following discussions about forwarder DLLs). Thus, if an entry point into the new resource is later requested by an unclassified or unknown application, the forwarder DLL (not shown) will resolve the location of the entry point and its reachability graph, starting at the new resource .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4","b":"400"},"At , the method begins by classifying software. The classifications include at least a high order classification and a low order classification, and potentially multiple classifications ranking from higher to lower order classifications where each classification includes one or more software programs -, where a software program could be an application program, or other software that uses a resource - such as a dynamic link library. For example, a shared resource could be a dynamic link library that is linked into the software program to provide shared resources to the software program.","At  the method identifies reachable nodes within the resources -. For example, for a classified software program, the program has several exit points into services provided by the resources represented by nodes within those resources. When a software program calls a resource to obtain services, the call to that node within the resource is the beginning of a graph of potential nodes reachable through various control flow paths through the resources, and the method at  traces the call chain paths from the software program to the nodes within one or more of the resources, and creates a graph of nodes and edges. By chasing that call chain through the resources, nodes reachable through any path within the resources are identified. For example, as shown in , a software program  has two nodes - that requests services from the resources -. For example, a node  within an application , requests a service  within a resource . Because the service  is in resource  separate from the application , specifically a shared resource, a call chain is in this case supported by an import  in the application  and an export  in the resource . The node  requesting the service  calls  a local import  in order to resolve  the resource location , within the resource . The export  is used to resolve  the location of the service . In this example, another node  within the application  requests services from another node  at another resource . Additionally, the node  provides the service utilizing another node,  at the resource . Finally, that node  provides the service  with help from two other possible nodes  and . Thus, when an application requests services, a call chain is walked to determine nodes within the resources - that provide services to the application . In this example, by walking the exit points in the application  it is determined that services are provided by nodes within three resources -.","At step , the reachable nodes are grouped into a single resource.","For example, from the import , of the application , a call chain is walked to identify nodes in the resources -. These reachable nodes are then placed in a new resource as shown in . Thus, nodes from three old resources - are regrouped into a new resource .","In , the application  is the only application in the highest order classification. However, if multiple applications (not shown) were traversed in order to determine reachable nodes for all such multiple highest order classified applications, the nodes reachable by any of the highest order applications would be grouped into the new resource . The new single resource  could be a dynamic link library containing the nodes reachable by the highest order classified software programs.","Continuing with this example, in the new resource  we see the nodes reachable in the call chain as shown in .","Finally at , the edges between nodes are redirected in order to reflect the change in node dependencies within the single resource . Thus, the application is directed to receive the resources via a redirected call chain to nodes that have been regrouped in the new single resource .","As shown in , when the application  and the single resource  are later loaded into memory  for execution, depending on an implementation linking the application with the resource, the imports and exports may be de-referenced into direct memory links, if desirable -.","The method at  would continue by selecting an application from the next lowest order classification and identifying nodes reachable from that application. Additionally, if two or more applications were in the second level classification the method  would identify reachable nodes from all one or more applications in the second classification and place those in a new resource (not shown). Any nodes that were already reached in the first classification analysis would already be in the first resource . Thus, the second resource would only contain those nodes reachable by the second order applications not already contained in the first resource. Similarly, for a third level classification the one or more applications are traversed in order to determine the nodes reachable. Nodes reachable by the third order applications would be placed in a third resource unless they have already been placed in the first resource or the second resource.","At , the call graph created to determine reachable nodes is used to redirect edges to the new node locations, thereby preserving the reachability relationships between nodes regardless of what new resource they are placed within. These relationships are understood with reference to . In , at , one or more first order applications rely on services in a first resource . Additionally, we see one or more applications  in the second order classification relying on services represented by nodes in the second resource , however, the nodes reachable by the second order application that were already regrouped in the first resource , are obtained by the second order applications directly , or indirectly , according to the reachability graph from the second order reachability analysis. This creates a condition where first order applications  have the services they need in the first resource , and the second order applications  have the resources they need in the first and second resources -. Finally, the one or more applications in the final order classification  obtains the services it needs from a new resource  containing all the nodes reachable by the one or more applications in the last classification. As before, if any of the nodes reachable from the applications in the last classification , are contained in resources of higher order classification -, the edges of those nodes are redirected , , , , , to the nodes in those higher order resources -. Interestingly, this regrouping of services into new resources -, creates a condition where a first order application  requires a single resource  containing the services it may request, whereas the second order application , requires the second order resource  and possibly the first resource , and a third order application , requires the third order resource, and possibly the second and\/or first resources -. In an example that prioritizes applications in classifications according to frequency of use, when first order applications are executing, fewer resources need to be maintained in memory, and the services within those resources are more tightly coupled and more likely to result in lower page thrashing and better memory optimization. Further, since lower order applications - are executing at a lower frequency, the requirements of multiple resources in memory at the same time - is reduced because of this lower frequency.","The resource arrangement of , requires multiple resources in memory even though very few services are used within any given resource -. Whereas in , services from multiple resources have been grouped into a single resource, thereby reducing memory requirements for high order applications.","Software programs could be classified as first order applications based on other criteria. For example, a company could decide for marketing reasons that three or four of its applications are the most valuable in terms of sales volume, and place the services required by those applications, into a single resource. This would allow for efficient utilization of memory for programs most desirable to the company. Similarly, applications with lower sales volume may be classified lower.","Finally, the method , could be shipped in software with the programs and resources, and execute periodically in order to determine frequency of application use at a particular client site. Based on frequency of use or other factors, the programs that are most valuable to a specific client, are periodically determined at the client site transparent to the user. After a periodic determination, resources are regrouped to provide services within resources based on the clients' use. Of course, the method could also be used by development teams before the software is shipped in order to regroup services into resources based on classification rather than the original grouping of resources that was based on development team functionality.","Finally, the method could be used to examine source code in order to create a make file that directs a build to contain dynamic link libraries built according to the method. The nodes would be grouped according to reachability in the source code instead of the binary code and the redirect dependencies step , would not be necessary since the build would create the DLLs originally in the desired format. Thus, the method is useful pre-build, post-build, and post-release.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 8","b":["800","802","806","804","808","810","812","800","814","814","800","814","810","816"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 9","b":["900","900"]},"At , the method gets the entry points from each of the dynamic link libraries in the input. For example, as shown in , dynamic link libraries  within the input  are considered. The method collects the entry points from each of the dynamic link libraries and assembles them. The notches on the left side of the oval  represents the assembly of the entry points of the dynamic link libraries contained in the input . For example, each of the dashes representing an entry point on the left side of the oval  is stored in a data structure holding an identification of a dynamic link library for that entry point and an entry point within the dynamic link library.","At , the method determines or receives applications within the input . The method  then classifies the applications within the input. For example, a graphical interface displays a list or icons of programs available for prioritization. Using such a provided interface, the user could select the input universe of applications for prioritization . Further, using a graphical user interface the user could classify the selected applications in a priority order. As shown in  one or more applications  are classified as a Class A or highest priority application, one or more applications are classified  as a Class B or second order priority application, and finally one or more applications are classified  as a Class C or third order priority application . Thus, in the method , applications are selected and classified for resource prioritization.","At , the method colors the entry points to the dynamic link libraries in the input universe . For example, for the one or more applications classified in high order , if the application has an import, corresponding  to an export in the input universe, that export is colored with the high order classification (e.g., A). As shown, the Class A application  has an import corresponding to an export  in the input universe corresponding with an export in a DLL . Thus, the entry point  is colored with the high order classification \u201cA\u201d as shown. Additionally, since the application  has an import corresponding to another export  that export is colored with the high order classification \u201cA\u201d. Finally, as shown the application  has an import  to a DLL not in the input universe and, thus, has no corresponding export in the input universe. Once all applications in the Class A classification , have had entry points colored with Class A, the method  begins with the classification B applications . In this example, the Class B classification  contains two applications , . As before, for imports with a corresponding export in the input universe, an entry point is colored - with the second order classification B. Notice that an import from classification \u201cA\u201d  and an import from classification \u201cB\u201d  both correspond to an entry point in the input universe. In such cases when a high order classification and lower order classification both have imports corresponding to an export in the import universe , , the high order classification colors the export. In this case, the export is marked with the \u201cA\u201d classification. Finally, the lowest ordered classification are applications colored with the low order classification C -. As before since an export has a corresponding import from two classifications -, the high order classification colors that entry point (e.g., B). Thus, the method  colors the entry points in the input universe , according to the classifications of the applications that have imports corresponding to the exports in the input universe.","At  the method emits a distribution list. For example, as shown in , a distribution list  includes the names of the new binary files (e.g., DLLs) -. In this example, a keyword  signals the name of the new resources. The keyword signals that the highest order resource  is named V0.DLL, the second highest order  new resource is named V1.DLL and the third and last resource  is named V2.DLL. In the highest order, resource , two entry points were identified , , the first in a DLL  called DOG.DLL. In this example, the export is know within the DOG.DLL with a unique symbol . The second entry point is from a DLL , called CAT.DLL, and contains the unique symbol . In this example, the second highest order new resource will be named V1.DLL . The second highest order application(s)  had four imports -. However, one of those imports  was in common with the higher order new resource . Since that entry point is in the higher classification it will not also be in the V1.DLL resource. Thus, the second highest order new resource will contain three exports, two from one DLL  and another from one DLL . This is reflected in the distribution list with the DLL names and unique symbols -. Finally, the lowest order new resource DLL named V2.DLL , contains the exports from two DLLS in the input universe , . The first DLL  is named RAN.DLL and contains the unique symbol  as an import and second DLL , named CAR.DLL contains the unique symbol  for the export. Again, we see that an export  from a higher order resource  is in common with the export  from a lower order resource, so that export  is contained in the higher order resource . Thus, the method  has created a distribution list showing the names of the new resource DLLs - and the entry points into those DLLs -.","At , for each new resource , , , a reformulator is run to determine the nodes reachable for the corresponding exported entry points into the original DLLs , , , , , , . For example, the new resource V0.DLL , will contain all nodes reachable from the exported entry point into the DOG.DLL , and all nodes reachable from the exported entry points into the CAT.DLL . For example, as shown with reference to , the export from the DOG.DLL , is shown as an entry  into the DOG.DLL . From this entry point into DOG.DLL , all nodes reachable from the entry point are traced through the DLLs and identified. In this case, control flow starting at one node in DOG.DLL and going to a second node in DOG.DLL and exiting DOG.DLL and entering another DLL  called FAR, and entering a third node. Thus, these three nodes , , and  (and the accompanying path(s) through the control flow), will be included in the new resource V0.DLL . Additionally, from the identified unique export into the CAT.DLL , we see an entry point into the CAT.DLL  in  at . In this example, only one node is reached. Thus, the new V0.DLL , contains the nodes encircled as shown in  at . Next, for the second classification resource V1.DLL , the trace beings at three entry points , , and . The first entry point  includes one node, and the second entry point , includes two nodes that are reachable. The first is in the HOW.DLL , which imports a node from the NOW.DLL , which is shown as \u201c4\u201d in the NOW.DLL. The third entry point , includes the node shown as \u201c3\u201d in the CAR.DLL . The new resource V1.DLL , will include the four nodes reachable as shown encircled . Finally, in the lowest order classification V2.DLL , two nodes are reachable from the entry point , the first in CAR.DLL  marked as \u201c1\u201d and the second in NOW.DLL , marked as \u201c2\u201d. From the second entry point , two nodes are reachable in the RAN.DLL , marked \u201c3\u201d and \u201c4\u201d. Thus, the new resource V2.DLL , contains the encircled nodes .","During reformulation , the method collects reachable nodes according to imports of the classified applications. Reformulation  completes by outputting DLLs with the regrouped nodes. The new V0.DLL resource  contains the nodes encircled by , the new V1.DLL resource , contains the nodes encircled by , and the new V2.DLL resource , contains the nodes encircled by .","At , if the reformulator can move entry points , then an output of the reformulator, can include a changed distribution list showing the final destination of entry points. For example, with reference to , a DLL entry point  may first be classified as an export in a lower classification (e.g., B or C). However, during traversing the reachable nodes from a higher order entry point , a call chain of reachability , , may determine that the entry point  is reachable by the high order classification entry point . In such an example, it is desirable to have the entry point of the lower order , included in the new resource of the higher order. For a reformulator  that can move entry points, the lower order entry point  is moved into the higher order resource, along with the nodes  reachable by that entry point . For example, if  represented an admitted distribution list according to step , a reformulator output could include an output distribution list indicating that an entry point (e.g., one or more entry points, ), was moved to a higher order resource , such as V0.DLL . Thus, if a reformulator can move entry points , then the method  would output the final resting point or destination of that moved entry point.","At , the method redirects imports of the application to the final destination of entry points. For example, as shown with reference to , an application  shows a node within that application  requesting a resource  via an import table . The import table indicates an identifier of a new source DLL  and a unique symbol identifiable within that new resource DLL. When the application is loaded into memory the linker locates the DLL , and loads the DLL  into memory. The unique identifier  is identifiable  in the export table , and identifies the corresponding location  within the new resource DLL  where the service is located . Of course, the particular import and export table and linking mechanism will vary according to the operating system and linker. So this is only exemplary in nature.","At , the method determines whether the reformulator created forwarder DLLs. For example, as shown in , a CAT.DLL , contains the original unique symbol for the entry point , and also the corresponding new resource DLL and entry point into that new resource . A forwarder DLL is useful for many purposes. For example, in , an example was shown where an application  had its import table updated to reflect the new location of the service within a resource -. However, if the import tables of an application are not updated, the forwarder DLL  would be obtained by the operating system at link time since it would still be the reference from the import table of an unchanged application. In such an example, the reference to the new resource  would be used to obtain the location of the service within that resource. However, forwarders  have other purposes. For example, with respect to , two applications  were not in the input universe . In such a case, one of those applications , may still refer to a DLL called CAT.DLL even though its services have been dispersed into new resources. In such a case, even though other applications within the universe  have had their import tables  changed to reflect the new imports , , the applications that have not been so changed  will still reference resources by the pre-reformulation names (e.g., , , , etc.). Thus, forwarder DLLs  can be used to redirect imports for applications within the input universe , without changing their import tables.","They may also be used by applications outside the input universe that still refer to the reformulated resources according to their pre-reformulation names. Thus, at  the determination is made whether a specific example of a reformulator  created forwarder DLLs . If the reformulator created forwarded DLLs, then the method exits, however, if the reformulator had not created forwarded DLLs, then at , the forwarder DLLs are created as required.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 11","b":["1102","1104","1106","1102","1","2","3","4","1102","1102","1104","1106","834","866","865"]},"The CAT.DLL , has a node reachable from the entry point , marked as 4. However, the new resources combined , , , contain none of the other nodes reachable in the CAT.DLL . In another example, the reformulator could trace all of the entry points into the CAT.DLL , in order to identify all of the nodes reachable by those entry points, even though none of the classified applications access those entry points. In one example, the reformulator could put all of the reachable nodes that were not already in the previous new resources into a final new resource in case an application that was not in the input universe later tries to access one of those entry points. Thus, the reformulator would have resources including the entry points into the DLLs from the classified applications and another new resource for entry points not accessed by the classified applications. This would be another way of maintaining all of the nodes in the DLLs even if they are not accessed by classified applications. If a non-classified application is later added to the system or already exists in the system, if it needed any of these unused nodes, it would access that additional new resource containing the unused nodes. This would be an alternative example of a reformulator that saves the uncolored nodes instead of throwing them away.","While the reachability trees are created from the starting entry points into the DLLs, the edges in that reachability tree are kept during reformulation, so that the edges in the new resource follow the same reachability tree. For example, in , a reachability tree spanning three DLLs , ,  is reformulated into a reachability tree with the same edges in a new resource DLL .","As shown in , the first order classification applications  have all of the services they need  in a single resource . Notice also that a second ordered classification application , has entry points  into a second order new resource . That second order resource  may also have an entry point into the higher order resource as shown in  at , and  at . Thus, the second new resource  includes entry points into DLLs and the nodes reachable there from in a reachability tree, or graph. However, notice also that if while traversing that second classification reachability graph, a node is reached  that was reachable from a first order classification entry point, the edge from the second order classification graph refers to the node in the first order classification graph. Thus, nodes in the first classification resource  may also receive edges from lower order classifications , , but notice that none of the first order classification reachable nodes have edges into a lower order classification. This creates the dependency conditions evident in , wherein graph edges go from lower order classifications to higher order classification but not vice versa. Thus, while traversing a lower order reachability graph, if a node is reached that is already classified or colored in a higher order classification, an edge is produced into the higher order resource. Thus, the reformulator tracks these relationships while traversing the reachability graphs. Later, it will be shown how import and export tables are created between the new resources , , , in order to reflect these one-way dependencies. Finally, for clarification purposes, if a node from a low order classification enters a higher order classification and that node or a subsequent node in that reachability chain accesses a node in a lower order classification, all nodes reachable from that higher order node are already in the reachability graph of the higher order classification and would therefore appear in the higher order resource.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 15","b":"1500"},"At , the method obtains a first DLL in the input universe, and reads the DLL in order to determine entry points into the DLL. For example, a DLL includes an export table which includes unique symbols representing entry points in the DLL and associated with each unique symbol, a location in the DLL where the entry point node begins.","At , the method associates each discovered entry point with the DLL it is contained in and saves the association.","At , the method continues associating entry points within the DLL with that DLL in pairs, so long as there are additional entry points.","At , once the entry points have been determined and associated within the DLL, the method obtains another DLL in the input universe and begins again to read that DLL to obtain its entry points. Once all of the entry points in each DLL have been associated with that DLL, and once entry points have been determined for DLLs in the input universe, the method exits. Thus, a data structure or other format for holding data is created that associates each entry point with its associated DLL.","For example, the method  is one example of a way to perform step  in .",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 16","b":"1600"},"At , an application is identified in the input universe. For example, the input universe could be received as a textural file input listing applications and classifications. In another example, a graphical user interface could display a list of applications or icons identifying applications that may be selected for the input universe.","At , applications are assigned a classification. For example, an input file could identify a classification for applications in the input universe, or a graphical user interface could display an application in the input universe, and display a graphical feature for selecting a classification for the application.","At , the method continues until all of the applications in the input universe have been determined and classified.","At , the applications are sorted based on their classification. In another example, the method runs periodically and automatically on a workstation, or on a network. In one such example, the method measures the frequency of application use over the period and at the end of the period, applications are selected automatically , if they are used for some threshold determination of time. Further, in such an example, applications can be assigned classes , based on the length or frequency of use of the application during the period. In such a case, the workstation or network automatically classifies applications on a periodic basis. Then the classified applications are input into a method of reformulating the resources according to the classifications. This creates an ongoing, dynamic, and specific reformulation of resources.","Thus, the method  can be used statically through a file input or graphical interface, or dynamically and transparent to workstation operators in order to reorganize resources.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 16","FIG. 9"],"b":"904"},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 17","b":["1700","1002","1004","1006"]},"At , the method sorts applications into order of classification. Each classification can have one or more applications and applications with the same classification are ordered together in that classification.","At , the method reads the application imports.","At , the method determines whether or not an import entry is for a DLL in the input universe. If a DLL is in the input universe, at  the method checks to determine whether or not that entry point has already been colored or classified earlier in a higher order classification.","At , if that entry point has not been colored by a higher order classification, then it is colored with the classification of this application.","If the entry is not in the universe , is already colored by a higher order classification , or is colored with the classification of this application , the method continues at .","At , if there is another application import, the method returns to read that imports at . Once imports in all applications have been checked, the method  is completed.","Once the method is complete , all imports in the applications in the input universe have been checked to determine whether or not they correspond to entry points into resources in the input universe. Entry points into DDLs in the input universe are colored with the classification of the application containing the import. If an import is included in two or more applications, that import is given the classification of the highest order application.","The method , represents an example way of performing the functionality discussed in  at step .",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 18","b":"1800"},"At , the colored or classified entry points are sorted into classes.","At , a header is output into the distribution list for the highest order class. The header, for example, identifies a name for the new resource (e.g., V0.DLL), and optionally, a preferred starting address for the DLL in memory (not shown). This address if present will be the preferred address when the new resource is loaded into main memory for execution.","At , under the header for the new resource V0.DLL, the entry points for the first order classification are listed. For example, the list would include the name or symbol identifying the DLL of the old resource and then the name or symbol of reentry point into that old resource. So long as there remains more entry points , those entry points are added to the list . This completes the entry points that will go into the V0.DLL new resource.","At , if another classification exists, the method returns to output a header , for that additional classification. As before, the entry points into the old resources are listed under the header  so long as more entry points  exist. The method continues outputting a new classification and listing the entry points  until all classes have been added to the distribution list.","At , once all classified or colored entry points are included in the distribution list, any entry points remaining in the input universe, regardless of the original source DLL, are listed under a final class . Thus, all classified entry points are created in the new resources and unclassified entry points in the input universe are included in a final class at . Optionally, unclassified entry points are discarded.","At , since all classified and unclassified entry points are included in the distribution list, the distribution list is output and can be used by a reformulator.","This distribution list created with the method  assumes that a reformulator can walk the entry points to determine the reachability graphs for the multiple new resources. Thus, this distribution list includes the starting points for the reachability graphs. For example, a first classification entry point includes the starting point of a reachability graph for the first classification and the reformulator walks from that entry point down the reachability path to all reachable nodes, thereby building a graph of reachability. All reachable nodes from first order entry points are included in the first order resource. Of course, the name of the resources could be changed so long as there is an understanding of which is the first order resource (e.g., V0.DLL, V1.DLL is not required).","However, in another example, the reformulator requires all the nodes reachable from each entry point as input and thus those reachable nodes will be listed in the distribution list. Such a reformulator will then handle the task of creating the new resource, since the distribution list will include a list of the reachable nodes.",{"@attributes":{"id":"p-0110","num":"0109"},"figref":["FIG. 18","FIG. 9"],"b":"908"},{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 19","b":"1900"},"At , the method sorts the entry points according to the color classification of that entry point.","At , a header is output for the high order classification. For example, the header could include a key word (e.g., \u201cnewslice\u201d, \u201cnewdll\u201d, etc.) identifying the name of the new resource and the corresponding name for the new resource (e.g., V0.DLL).","At , for each entry point colored with the classification for that header, that entry point is listed under the header. For example, the listing for that entry point includes the name or symbol of the old DLL containing the entry point, and the name or symbol identifying that entry point uniquely within the DLL.","At , if the reformulator is able to create the reachability graphs, then the distribution list only needs to contain the entry points for the new resource. In that case, as long as there is another entry point in the present classification , the method continues to add those entry points under the classification . Once all entry points have been entered under the header for a given classification and there are no remaining entry points , then the method  determines whether there are any other classifications for the distribution list. If there is another classification , the method returns to add another header line for that classification , for example, V1.DLL. Again, the header may also include a key word signaling that the new resource name is for a new resource. As before, the new header may also include a requested or recommended memory address for the new resource. As before, for this new header, each of the entry points  identifying entry points into the old DLLs, are listed. Once all entry points  for each class , have been added to the distribution list, the method continues at .","At , any entry points in the input universe of DLLs, not yet included in the distribution lists, are listed under a final or last class . As before, the last class includes a header  and each of the listed entry points where they can be obtained in the old resource including an identifiable symbol . At this point , all classes have been added to the distribution list along with entry points into the old resources.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 19","FIG. 9"],"b":"908"},{"@attributes":{"id":"p-0118","num":"0117"},"figref":"FIG. 19"},"At , since the reformulator is unable to walk the dependency graph, that information is determined as follows.","At , the symbol or name for the code or data block that is the entry point is obtained from the entry point , and it is pushed onto a pending list at . In this case, since a symbol was just pushed onto the pending list, there are more symbols , in the pending list.","At , the symbol on the pending list is put below the header for the classification currently in processing.","At , all symbols for all code or data directly reachable from the symbol is put into the pending list.","At , so long as there are other entry points for this class, those entry points are placed under the header information  for this class . Further, the symbol is obtained  and pushed onto the pending list . So long as more symbols appear in the pending list , those symbols are added to the distribution list  and the symbols reachable by those symbols are pushed onto the pending list . Thus, all entry points are put under the classification header  for this class , and all symbols reachable there from continue to be pushed onto the pending list , in order to obtain all reachable nodes from reachable nodes. Once there are no more entry points in this class , and no more nodes reachable there from in the pending list , then there are no more nodes reachable from entry points within this class.","At , the method determines whether there is another class, and the method continues for the next class to omit a header and entry points ,  and then to obtain the symbols for reachable nodes and push them onto the pending list . As each symbol is pulled from the pending list  and placed in the distribution list, it is checked to see that all nodes reachable there from are added to the pending list  until all entry points in this class , have been covered and all nodes reachable there from have been added  to the distribution list under the header for this class .","At , once all classified entry points and nodes reachable there from have been added to the distribution lists, the method determines whether there are any entry points in the universe of input DLLs that have not yet been listed in one of the earlier classifications. If such entry points do exist , then a final class is created  a header is output  and all entry points reachable there from  along with nodes reachable there from -, are included in the distribution lists.","At , the distribution list is output.",{"@attributes":{"id":"p-0127","num":"0126"},"figref":["FIG. 19","FIG. 9"],"b":"908"},{"@attributes":{"id":"p-0128","num":"0127"},"figref":"FIG. 20","b":"2000"},"At , the method receives a distribution list and saves it in memory.","At , consume and convert the table mapping runtime into an internal representation (IR). The table mapping runtime is a procedure that is put into each new resource that has imports . When the new resource is loaded into memory to support an application, the table mapping runtime, maps the imports to the corresponding DLLs, upon which the DLL depends. Converting the runtime into an IR, means to create a data structure graph of the basic blocks inside the table mapping runtime, so those basic blocks can be injected into each new resource with imports.","At , convert the DLLs in the input universe into an internal representation (IR). Again, an internal representation is a data structure holding information about the DLL, such as nodes and edges. For example, a data structure graph identifying the basic blocks and control flow through basic blocks is created. This step  is performed for every DLL in the input universe.","At , the method merges all of the IRs  into one big integrated internal representation (IR). The graphs of the DLLs created at step  are integrated to create one big graph that resolves the dependencies between individuals DLLs. Thus, all the imports and exports are internally resolved in memory for the integrated graph. For example, if a DLL had a call or branch into another DLL, it would now be represented as an explicit call instead of a call through an import and export table. The integrated graph becomes one giant graph with explicit dependencies. At this point, the table mapping runtime is not called by any nodes, and it does not call any nodes in the other DLLs of the integrated graph. However, it needs to be included in the integrated internal representation, so it can be injected later into each new resource  that has an import table. The table mapping runtime is desirable because it matches the import tables to export tables for the one way dependencies discussed with reference to  at , , and .","At , the method associates each basic block in the integrated IR with the new DLL it is to be injected in according to the distribution list. For example, the method starts with entry points listed in the distribution list, and walks the integrated IR and colors each basic block reachable from that entry point.","For basic blocks that are not reached, there are two options. The first option would make sense, for example, when all applications on a system are in the input universe. In that case, since you have all the basic blocks needed within the DLLs by the applications in the system, all the relevant dependencies are resolved so the unreachable basic blocks are discarded. The second option is to just create a final and lowest order DLL to hold all of the presently non-reachable basic blocks. This option would be helpful if an application is later added to the system that reaches these nodes.","Once reachable nodes are colored according to the classification of their associated entry point, the coloring process is complete.","At , the integrated colored IR is saved temporarily in memory. A data structure holds all the pieces of the integrated IR so that the nodes and edges can be injected into the new resources.","At , an initial new resource place holder is created to receive the basic blocks and edges for the first order classification reachable nodes. A DLL not only has the basic blocks of instructions and data that are required, but also initial headers and system information to know how to load it, to indicate that it is a DLL and not an EXE, and to create holders for names, etc. This creates a new resource ready to receive the basic blocks.","At , the method then walks the saved integrated and colored IR , and places the graph of nodes reachable for this classification of colored nodes into the new resource place holder. The new resource is given the indicated name for this classification new resource, and the preferred loading address if desirable. The reachable basic blocks and associated edge relationships are copied or injected into the new resource.","At , the method checks the saved integrated and colored IR to see if any basic blocks therein depend on the basic blocks in the new resource created at . If lower order new resources contain nodes that depend on the nodes in this new resource, then those dependencies require an export table.","At , since one or more lower order new resources depend on this new resource , the method creates and injects an import table into this new resource.","At , if a new resource contains nodes that depend on nodes within a higher order new resource, the method creates and injects imports into the new resource , and injects a copy of the table mapping runtime IR  into the new resource. Additionally, since the basic blocks in the new resource had explicit links to the imported basic blocks in the saved integrated and colored IR, those links are resolved instead to the injected import table.","At , if more new resources are indicated by the distribution list, a new resource placeholder  is created to hold the basic blocks for this new classification.","At , the basic blocks colored with this new resource classification are injected to create the new resource. As before, if lower order new resources depend on this new resource , exports are created and injected , and if this new resource depends on a higher order new resource , then imports and the table mapping runtime are injected -, and links to imported basic blocks are resolved to the imports .","At , once all new resources are created, the method outputs the reformulated DLLs.","Optionally, uncolored nodes can be placed in a final order DLL, with a corresponding import table  and runtime .","Notice that the method accounts for the one way dependencies using import and export tables, which are mapped at runtime by the table mapping runtime , which is injected into each DLL that depends on other DLLs. Notice also that the highest order new resource contains an export table (if any lower order resources depend on it), but no import table, and that the lowest order resource contains an import table (if it depends on any higher order DLLs), but no export table. When an application requiring a lower order resource is later loaded for processing, the table mapping runtime obtains the corresponding exports for the imports and resolves the links when the new resource DLLs are linked to the process address space.","Historically, during the build process, the compiler would have created the import-export tables in a way that the linker was designed to support. Since in this example, the new resources are created post-build, the table mapping runtime is injected to resolve the post-build imports.",{"@attributes":{"id":"p-0148","num":"0147"},"figref":["FIG. 20","FIG. 9"],"b":"910"},{"@attributes":{"id":"p-0149","num":"0148"},"figref":"FIG. 21","b":"2100"},"At , the method receives the integrated IR and the distribution list.","At , so long as more entry points exist in the distribution list, the method continues to color nodes reachable from entry points with the classification of that entry point in the distribution list. Once all entry points have been walked and colored, the method outputs a colored integrated IR .","At , since another entry point exists , the method fetches the basic block identified by the entry point.","At , the method determines whether the basic block identifiable by the entry point has already been colored. This would happen, for example, if while walking the integrated IR from a previous entry point, this entry point had been called from a basic block. In that case, this entry point would already be colored with the classification of that previous entry point. In that case, this entry point is transferred to the classification distribution list for that higher order new resource. For example, as shown in , if one or more entry points - reach a lower order entry point - during reachability analysis, that reached entry point is moved  to the higher order classification.","At , if the entry point is already colored , it is transferred to the already colored higher order classification.","At , if the entry point basic block is not already colored, the entry point basic block is colored with the classification of the present (\u201cthis\u201d) entry point.","At , the method pushes all the directly reachable basic blocks (\u201cdescendants\u201d) of this basic block onto a pending list.","At , since this (entry point) basic block was already colored , the method next checks the integrated IR  to see if any basic blocks will depend on this basic block. If so, this basic block is marked as requiring an export, and the block referencing this basic block is marked as requiring an import -. In other cases, where this basic block is from the pending list , it is less likely to be already colored .","At , if a basic block is not already colored, it is colored , with the classification of the present entry point that is being walked .","At , if there are no more basic blocks on the pending list  to process, the method returns to obtain another entry point from the distribution list . If another basic block is on the pending list , that basic block is obtained from the pending list .","At , the method pushes any descendants of the basic block  onto the pending list.","At , the method determines whether this basic block  has already been colored. This could be the case, for example, if this basic block had already been reached from a previous entry point. Notice that if a block is not already reached, it stays in this color classification and requires only coloring  and no import or export -. However, if, while traversing blocks reachable from this entry point, a block is already colored, that indicates a control transfer to a higher order resource requiring associated import and export. Thus, the method  supports the one-way dependency layering from lower order into higher order.","After the pending list is empty , and there are no more entry points to process, the colored integrated IR is complete .",{"@attributes":{"id":"p-0163","num":"0162"},"figref":["FIG. 21","FIG. 20"],"b":"2010"},{"@attributes":{"id":"p-0164","num":"0163"},"figref":"FIG. 22","b":["2202","2206","2202","2204","2206","2208","2214","2216","2222","2224"]},"Similarly, exports of the second order applications were obtained - and traversed, and reachable nodes not already placed in the highest order resource, were placed into the second new resource Q.DLL, as shown -. Additionally, imports to the higher order resource , and exports to the lower order resource were created .","Finally, imports to the lowest order application(s) were traverse and nodes not already in the highest or second order resource, are placed in the lowest order resource R.DLL . Additionally, imports to higher order resources were created . The created imports and exports , , , , support the one-way dependency relations.","Allowing creation of customized DLLs without requiring changes to source code or make-file build arrangements creates new possibilities. For example, it allows various embedded versions of system resources. Resources can be stacked in various configurations based on various needs and memory restraints. Users can reconfigure general library resources for purposes such as processing requirements and embedded memory limitations.","Additionally, the method allows DLL creation based on functional expertise of development teams, yet functional specificity at the point of deployment so unused functionality is not wasting memory. Thus, allowing formulation based on actual usage requirements based on usage frequency or importance of functionality. This results in lower memory requirements and fewer disk accesses.","Many DLLs have spaghetti dependencies requiring many other DLLs to be loaded even when only small portions are utilized. Saner componentization based on reachability reduces DLL and memory requirements.","Further, the reachability of nodes within one DLL for a time sensitive or highest priority application further enables other optimizations that arrange blocks within a single DLL resource to increase efficiency.",{"@attributes":{"id":"p-0171","num":"0170"},"figref":"FIG. 20","b":["2006","2008"]},"Table A shows an exemplary grammar for a distribution list format.",{"@attributes":{"id":"p-0173","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[slicebinaries]"]},{"entry":[{},"\u2003\u2003newslice <slice name> [<preferred address>]"]},{"entry":[{},"\u2003\u2003\u2003\u2003<source binary> (<export name>|<ordinal>)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"\u201cSlicebinaries\u201d is a keyword indicating that this is a distribution list with new resource names, old resource names, and entry point identifiers. \u201cNewslice\u201d is a keyword signaling that a new resource name called \u201cslicename\u201d follows. Optionally, a preferred load address follows the new resource name. Each entry point for the new resource is listed as the old resource \u201csource binary\u201d and an entry point into the old resource which can be an \u201cexport name\u201d symbol or an \u201cordinal\u201d entry point into the old resource.","Along with an output of reformulated DLLs, a number of optional features may be output if useful for a given situation. For example, the binary code for the basic blocks can be reversed compiled, and assembly language code representing the assembly language is output, as associated with basic blocks, if so desired. Further, a basic block map is output, which is helpful in debugging. Additionally, a library definition file is output that is used by the library manager to link the new resources. Further, if the method and systems described herein use program debug files (.pdb) as a resource to create the IRs, that information can be carried forward with the reformulated basic blocks, and output as associated with the corresponding new resources.","As discussed earlier, a table mapping runtime is injected into each new resource with imports (e.g., as discussed at , ).","An export has a memory location that contains the address of the exported object (i.e., code or data). This is the loaded address of the object, which is not necessarily the address of the object at link time, since DLLs may be loaded at an address different from the link address.","An import also has a memory location that is to contain the final address of the exported object. Thus, the table mapping runtime performs the steps discussed in Table B.",{"@attributes":{"id":"p-0179","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE B"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Get name of exporting DLL from import."},{"entry":"Load exporting DLL."},{"entry":"\u2003\u2003Load virtual address different from link time address if necessary"},{"entry":"\u2003\u2003to fit into the virtual address space of importing process. Patch"},{"entry":"\u2003\u2003tables to point to final address of exported objects."},{"entry":"Get name or ordinal of export from import."},{"entry":"Find matching name or ordinal from exporting object."},{"entry":"Copy final address of exported object to import."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"While classifications can be created to serve the resource needs of existing applications, the technologies described herein do not require creating new resources in view of the imports of existing applications.","For example, product architects may simply draw up lists of application programming interfaces (i.e., APIs), that support different levels of functionality. In such an example, the APIs represent a subset of the APIs into the old resources, and are used as entry points into the new resources. These entry points are assembled into a distribution list and submitted as input to the technologies described herein.","For example, the classifier  described in  would generate a list of APIs or entry points into the available resources, and a user could select from the list. These entry points represent a distribution list of one or more classifications. After a user selects and\/or classifies entry points using the classifier , the reformulator , the node identifier , and the dependency redirector , perform as described earlier. Forwarders would be used if the applications calling these new resources did not have their import tables changed.","Similarly, in , the classify step  would involve selecting APIs or entry points as opposed to examining imports in classified applications, and identifying reachable nodes , would use the selected entry points to begin identifying reachable nodes.","Additionally, this document and accompanying drawings discuss throughout, how to proceed once a distribution list is created. Thus, a product designer can select and create APIs representing entry points, and the described technologies will convert those entry points into new resources.","Product designers can use selections of functionality to provide different levels of functionality, for example, to create product-differentiation. For example, a product line may have a standard level, a moderate level, or an advanced level of functionality. This sort of product-differentiation allows the sale of economic versions producing revenue from additional sources, such as business, home, or academia.","This feature is also helpful in limited memory situations such as PDAs or embedded systems. By selecting APIs and entry points and creating new resources containing nodes reachable therefrom, products with limited memory capability can be managed more efficiently. In such cases, a device may require only one new resource containing the nodes reachable from the selected entry points. By allowing choices based on device memory and product design considerations, this selection feature brings great value to product design.",{"@attributes":{"id":"p-0187","num":"0186"},"figref":"FIG. 23"},"With reference to , an exemplary system for implementation includes a conventional computer  (such as personal computers, laptops, servers, mainframes, and other variety computers) includes a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit may be any of various commercially available processors, including Intel x86, Pentium and compatible microprocessors from Intel and others, including Cyrix, AMD and Nexgen; Alpha from Digital; MIPS from MIPS Technology, NEC, IDT, Siemens, and others; and the PowerPC from IBM and Motorola. Dual microprocessors and other multi-processor architectures also can be used as the processing unit .","The system bus may be any of several types of bus structure including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as PCI, VESA, AGP, Microchannel, ISA and EISA, to name a few. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM .","The computer  further includes a hard disk drive , a magnetic disk drive , e.g., to read from or write to a removable disk , and an optical disk drive , e.g., for reading a CD-ROM disk  or to read from or write to other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the computer . Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored in the drives and RAM , including an operating system , one or more application programs , other program modules , and program data ; in addition to an implementation .","A user may enter commands and information into the computer  through a keyboard  and pointing device, such as a mouse . These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, computers typically include other peripheral output devices (not shown), such as speakers and printers.","The computer  operates in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a server, a router, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although only a memory storage device  has been illustrated. The logical connections depicted include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications (e.g., via the LAN  and a gateway or proxy server ) over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Having described and illustrated the principles of our invention with reference to an illustrated examples, it will be recognized that the examples can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computer apparatus, unless indicated otherwise. Various types of general purpose or specialized computer apparatus may be used with or perform operations in accordance with the teachings described herein. Elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa. Techniques from one example can be incorporated into any of the other examples.","In view of the many possible embodiments to which the principles of our invention may be applied, it should be recognized that the details are illustrative only and should not be taken as limiting the scope of our invention. Rather, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 23"}]},"DETDESC":[{},{}]}
