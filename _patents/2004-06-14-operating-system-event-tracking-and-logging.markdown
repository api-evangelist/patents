---
title: Operating system event tracking and logging
abstract: A system and method for logging events processed by an operating system is provided. The events logged can include interrupt and non-interrupt events, and can include user-defined events. Information concerning the interrupt events is initially written, during event handling time, into a first buffer while information concerning non-interrupt events is initially written, during event handling time, into a second buffer. Information from the two buffers is then written to a third buffer not during event handling time. Separating the interrupt event buffer from the non-interrupt event buffer rather than having one buffer, and writing relatively small amounts of data during event handling time to memory, rather than transporting data to slower non-memory mapped devices allows the event logger to be less intrusive and facilitates greater accuracy in event logging. Data stored in the third buffer can be accessed by a viewing component, which facilitates displaying data in a manner useful to diagnose operating systems.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07818754&OS=07818754&RS=07818754
owner: Microsoft Corporation
number: 07818754
owner_city: Redmond
owner_country: US
publication_date: 20040614
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation of U.S. application Ser. No. 09\/726,907, filed Nov. 30, 2000, now U.S. Pat. No. 6,785,893 entitled OPERATING SYSTEM EVENT TRACKER HAVING SEPARATE STORAGE FOR INTERRUPT AND NON-INTERRUPT EVENTS AND FLUSHING THE THIRD MEMORY WHEN TIMEOUT AND MEMORY FULL OCCURS, the disclosure of which is hereby incorporated by reference as if fully set forth herein.","The present invention relates generally to computer programming and more particularly to a system and method for tracking events handled by an operating system kernel.","As operating systems have become more sophisticated, and as the environments with which operating systems operate have become more complex, it has become important to monitor the actions taken by an operating system in response to events the operating system is tasked to handle. In particular, visibility into the internal workings of an operating system kernel can be important to activities including, but not limited to, developing, debugging, and\/or diagnosing an operating system. For example, tracking the number and type of events that an operating system handles can be important to diagnosing system problems, bottlenecks, malfunctioning equipment and\/or component, and capacity problems.","Conventionally, monitoring operating system events has been difficult to achieve. Even if possible to log events handled by an operating system, such logging negatively impacted the ability of the operating system to handle events. For example, when an operating system experienced a problem, support personnel may have considered monitoring the events handled by the operating system to diagnose the problem. But the processing required to log an event may have taken more time to perform than handling the event, and thus the operating system could not be monitored under conditions that produced the problem, thus reducing the relevance of the monitoring. Similarly, when testing an operating system, test conditions that stress the operating system to a point where bugs appear can overwhelm a conventional monitor, and events may not be logged or requests may not be handled and thus the problem may remain undiagnosed. Further, contemporaneously logging interrupt events and non-interrupt events frequently lead to interrupt data interfering with non-interrupt data, and thus accurate monitoring was difficult. Thus, the monitoring may not have been performed and operating system improvements may not have been achieved.","Even if operating system monitoring is performed, it can be difficult to understand complex interactions between entities including, but not limited to, threads, processes, mutexs, locks, events, device drivers and applications. The value of operating system monitoring can be limited if the data produced during such monitoring is difficult to understand.","Thus there remains a need for a minimally intrusive system and method to accurately monitor events handled by an operating system, where the data produced by such monitoring is viewable and facilitates understanding the running of the operating system.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key\/critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The present invention relates to a system and method for logging events processed by an operating system. The events can include both interrupt and non-interrupt data. When an event is logged, the present invention stores data associated with interrupts in an interrupt buffer and stores data associated with non-interrupt events in a non-interrupt buffer. By writing small amounts of data to separate memories and by not attempting to transport data concerning the event to other processes (e.g. data viewer, disk log, network) during the event handling process, the logging of the events is less intrusive, and less likely to corrupt nearly simultaneous events, thus mitigating problems associated with conventional monitoring systems.","Both the interrupt buffer and the non-interrupt buffer can be flushed to a secondary buffer during non-event handling time. The interrupt buffer can be flushed upon completion of the interrupt handling process and the non-interrupt buffer can be flushed upon completion of the execution of the event-handler and\/or upon the non-interrupt buffer becoming substantially full. One or more processes (e.g. a viewer) can access the secondary buffer. The secondary buffer can also be flushed to one or more devices and\/or processes (e.g. a viewer, data communication devices, disk) when the secondary buffer becomes substantially full and\/or when a timeout condition occurs.","In one aspect of the present invention, the interrupt buffer, the non-interrupt buffer and the secondary buffer are located in memory associated with the computer running the operating system being monitored. In an alternative aspect of the present invention, the interrupt buffer, the non-interrupt buffer and the secondary buffer are located in memory associated with a separate hardware probe. When the buffers are located in memory associated with computer running the operating system being monitored, flushing the buffers may be accomplished under software control. But when the buffers are located in memory associated with a separate hardware probe, then flushing the buffers may be accomplished under hardware and\/or software control.","By logging operating system kernel events, visibility into the internals of the operating system kernel is achieved. Such visibility facilitates actions including, but not limited to, debugging, programming and maintaining operating systems, hardware components, software components and\/or applications. By employing the triple buffering method described above, acquiring such visibility is less intrusive to the operating system being monitored. Initially storing the data associated with interrupt events and the data associated with non-interrupt events in separate buffers mitigates problems associated with interrupt data corrupting non-interrupt data. Subsequently merging the interrupt data and the non-interrupt data during non-event handling time reduces the impact of the monitor on the operating system event handling performance and facilitates chronologically ordering the interrupt data and non-interrupt data in the secondary buffer. To facilitate such chronological ordering, when the flushing of the buffers is under software control, a time stamp can be associated with events as they are written to the buffers. The time stamp can then be used to arrange events in chronological order, and to ascertain the amount of time spent processing one or more events.","Monitoring an operating system may be undertaken for many reasons. For example, an operating system can be monitored to determine the effect of adding a new piece of hardware, the effect of adding a new software component, and\/or to determine the amount of operating system resources being allocated to handle certain events. Thus, a plurality of events can be logged by the present invention to facilitate customizing monitoring an operating system. A user interface provides means for an administrator to select events that are to be logged by the monitor. An Application Programming Interface (API) similarly provides means for processes to select events that are to be logged by the monitor. Since users may be interested in events not defined by the present invention, users may define events that are to be logged, and thus the present invention provides means for defining such events, which can then be selected via the UI or API.","The value of monitoring an operating system can be increased if the data produced by such monitoring is viewable in a manner that facilitates understanding the running of the operating system. Thus, the present invention includes a component and method for runtime display of monitoring data. Such a runtime display of monitoring data facilitates visualizing time based thread interactions, and system events associated with the interacting threads. The runtime display facilitates viewing items including, but not limited to, process states, thread states, process events, thread events, process switching, thread switching, events, changing states of semaphores, changing states of mutexs, entering\/leaving a critical section, and the occurrence of user defined events. Since numerous items can be viewed, the present invention provides for filtering the events that can be viewed. For example, an administrator may desire to view events associated with entering\/leaving a critical section, and may not desire to view other events. The ability to view such events facilitates diagnosing problems associated with programs including, but not limited to, operating systems, device drivers and\/or applications. Problems whose diagnosis can be facilitated include, but are not limited to, deadlocks, and missed real time deadlines. The ability to filter events to be viewed facilitates viewing a smaller and\/or more focused set of data, which can improve the ability to diagnose such problems.","Since an operating system can be monitored for different reasons, in an exemplary aspect of the present invention, the component and method for runtime display of monitoring data includes a User Interface (UI) to facilitate searching the monitoring data for items including, but not limited to, processes, threads, process states, thread states, process events, thread events and categories of events. For example, a first person examining monitoring data may desire to see a category of events, (e.g. interrupt events) associated with all processes, while a second person examining monitoring data may desire to see data associated with events associated with a particular process.","An operating system can be monitored for different reasons at different times. Thus, in an exemplary aspect of the present invention, the component and method for runtime display of monitoring can be run in one of at least three different modes: a real time mode, a system log of a previous run mode and a limited buffer mode. The different modes facilitate monitoring an operating system for different reasons at different times.","In accordance with an aspect of the present invention, a system for logging operating system events is provided, the system comprising: a first memory for storing first data associated with an interrupt event; a second memory for storing second data associated with a non-interrupt event; one or more components for storing data in the first memory and second memory; one or more components for moving the first data from the first memory to a third memory and the second data from the second memory to the third memory; and a first flushing component for flushing data from the third memory upon at least one of the third memory becoming substantially full and a timeout condition occurring.","Another aspect of the present invention provides a system for logging operating system events is provided, the system comprising: a first memory for storing first data associated with an interrupt event; a second memory for storing second data associated with a non-interrupt event; one or more components for storing data in the first memory and second memory; one or more components for moving the first data from the first memory to a third memory and the second data from the second memory to the third memory; and a first flushing component for flushing data from the third memory upon at least one of the third memory becoming substantially full and a timeout condition occurring, wherein at least one of the first data in the first memory and the second data in the second memory includes a time stamp associated with when the event occurred.","Yet another aspect of the present invention provides a system for logging operating system events is provided, the system comprising: a first memory for storing first data associated with an interrupt event; a second memory for storing second data associated with a non-interrupt event; one or more components for storing data in the first memory and second memory; one or more components for moving the first data from the first memory to a third memory and the second data from the second memory to the third memory; and a first flushing component for flushing data from the third memory upon at least one of the third memory becoming substantially full and a timeout condition occurring, wherein the non-interrupt events include user-defined events.","Yet another aspect of the present invention provides a user interface, the user interface operable to facilitate selecting one or more events to be logged.","Still yet another aspect of the present invention provides an Application Programming Interface (API) operable to facilitate selecting one or more events to be logged.","Another aspect of the present invention provides a method for logging operating system kernel events, comprising: storing interrupt data associated with interrupt events in an interrupt buffer; storing non-interrupt data associated with non-interrupt events in a non-interrupt buffer; flushing the interrupt data to a secondary buffer; and flushing the non-interrupt data to the secondary buffer.","Yet another aspect of the present invention provides a method for logging operating system kernel events, comprising: storing interrupt data associated with interrupt events in an interrupt buffer; storing non-interrupt data associated with non-interrupt events in a non-interrupt buffer; flushing the interrupt data to a secondary buffer; and flushing the non-interrupt data to the secondary buffer, wherein the interrupt and non-interrupt events to log are determined by at least one of choices made in response to a User Interface (UI) and one or more calls made to an Application Programming Interface (API).","Yet another aspect of the present invention provides a method for logging operating system kernel events, comprising: storing interrupt data associated with interrupt events in an interrupt buffer; storing non-interrupt data associated with non-interrupt events in a non-interrupt buffer; flushing the interrupt data to a secondary buffer; and flushing the non-interrupt data to the secondary buffer, wherein flushing the non-interrupt data to the secondary buffer further comprises re-flushing the non-interrupt data to the secondary buffer upon a determination that the flushing did not complete.","Still yet another aspect of the present invention provides a computer readable medium storing computer executable components of a system for triple buffering information associated with events handled by an operating system kernel, comprising: one or more computer executable components for storing first data associated with interrupt events in a first memory; one or more computer executable components for storing second data associated with non-interrupt events in a second memory; one or more components for moving the first data from the first memory to the third memory and the second data from the second memory to a third memory; and a flushing component for flushing data from the third memory upon at least one of the third memory becoming substantially full and a timeout condition occurring, the flushing not occurring during interrupt handling time.","Still yet another aspect of the present invention provides a computer readable medium storing computer executable components operable to execute a method for logging operating system kernel events, the method comprising: storing interrupt data associated with interrupt events in an interrupt buffer; storing non-interrupt data associated with non-interrupt events in a non-interrupt buffer; flushing the interrupt data to a secondary buffer, the flushing not occurring during interrupt handling time; and flushing the non-interrupt data to the secondary buffer, the flushing not occurring during interrupt handling time.","Another aspect of the present invention provides a data packet adapted to be transmitted from a first system to a second system, the data packet comprising data used in logging operating system events.","Another aspect of the present invention provides a system for logging operating system kernel events, comprising: means for logging interrupt events to an interrupt buffer; means for logging non-interrupt events to a non-interrupt buffer; means for copying data in the interrupt buffer to a secondary buffer; and means for copying data in the non-interrupt buffer to the secondary buffer.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative, however, of but a few of the various ways in which the principles of the invention may be employed and the present invention is intended to include all such aspects and their equivalents. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The present invention is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident, however, to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate description of the present invention.","As used in this application, the term \u201ccomponent\u201d is intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and a computer. By way of illustration, both an application running on a server and the server can be components.","Turning initially to , a system  for triple buffering information concerning events handled by an operating system  and\/or an operating system kernel  is illustrated. An operating system kernel  can be tasked to handle interrupt events and\/or non-interrupt events. Information concerning events handled by the kernel  can be logged by an event logger . The event logger  includes a first memory , a second memory  and a third memory  that are employed in triple buffering information concerning events handled by the kernel . The first memory , the second memory  and the third memory  can be of any suitable memory type, including, but not limited to, cache memory, stack memory, and\/or random access memory.","During interrupt event handling, a writing  of information concerning an interrupt event can be made to the first memory . Interrupt events can include, but are not limited to, memory, scheduling, communications and device interrupts. The writing  can be of variable length, but is intended to be of a size minimally intrusive to the event handling. For example, if the interrupt event handling will consume X processing cycles, X being an integer, then in one example aspect of the present invention, the writing  should consume at most Y processing cycles, Y being an integer less than X.","With continuing reference to , a writing  of information concerning non-interrupt events can be made to the second memory . The non-interrupt events can include, but are not limited to, reads\/writes from a designated memory area, database queries and Web page accesses. The writing  can be of variable length, but is intended to be of a size minimally intrusive to the event handling. For example, if the non-interrupt event handling will consume M processing cycles, M being an integer, then in one example aspect of the present invention, the writing  should consume at most N processing cycles, N being an integer less than M. By writing relatively small amounts of data to memory, rather than attempting to transport data to subsequent processes and\/or devices, the event logging of the present invention is less intrusive than conventional event logging systems, and thus performance problems associated with such conventional event logging systems are mitigated.","Since the non-interrupt event handling can be interrupted by interrupt handling, separating writing interrupt information associated with interrupt events from writing non-interrupt information associated with non-interrupt events facilitates accurate logging of both interrupt and non-interrupt events, thus mitigating corruption problems associated with conventional event logging systems. Thus, the first memory  receives interrupt information while the second memory  receives non-interrupt information facilitating more accurate logging than can be achieved via conventional event logging systems.","With further reference to , the data stored in the first memory  and the data stored in the second memory  can be written to the third memory . In one example aspect of the present invention, writing the interrupt event data stored in the first memory  occurs when event handling associated with the interrupt for which interrupt event data was stored in the first memory  completes. By moving the interrupt event data stored in the first memory  to the third memory  upon completion of interrupt event handling, the interrupt event data can be arranged in chronological order in the third memory . In one example aspect of the present invention, writing the non-interrupt event data stored in the second memory  occurs either when the event handling associated with the event for which the non-interrupt event data was stored in the second memory  completes and\/or the second memory  becomes substantially full.","The data located in the third memory  can thus include both data associated with interrupt events and non-interrupt events. The data located in the third memory  can be made available to one or more subsequent processes  (e.g. data viewing, data communications, data logging processes). In one example aspect of the present invention, the data located in the third memory  can be flushed when the third memory  becomes substantially full and\/or upon the occurrence of a timeout condition. For example, if the third memory  reaches a pre-determined threshold of fullness, then the third memory  may be flushed. Such flushing can include, but is not limited to, resetting read and\/or write pointers associated with the third memory , overwriting the third memory , and transporting the contents of the third memory  to other components (e.g. data communications devices, processes, disk). By way of further illustration, if a timeout condition occurs, (e.g. a pre-determined amount of time has passed since the third memory  has been flushed) then the third memory  can be flushed by methods including, but not limited to, resetting read and\/or write pointers associated with the third memory , overwriting the third memory  and transporting the contents of the third memory  to other components. It is to be appreciated by one skilled in the art that although two methods are described for flushing the third memory , that any suitable flushing method can be employed to flush the third memory .","It is to be further appreciated by one skilled in the art that although the subsequent processes  are illustrated receiving data from the third memory , that the subsequent processes  may access the third memory  without the third memory  being written to the subsequent processes . For example, the third memory  may have one or more processes writing the data from the first memory  to the third memory  and one or more processes writing the data from the second memory  to the third memory  contemporaneously with one or more subsequent processes  reading data from the third memory . Techniques well known in the art, for example time-sharing, can be employed to provide such contemporaneous writing and reading from the third memory .","Turning now to , the system  for triple buffering information concerning events handled by an operating system  and\/or an operating system kernel  () is further illustrated. The operating system  can be tasked with handling interrupt events  and non-interrupt events . Interrupt data  associated with the interrupt events  can be moved from the operating system  to the first memory  in the event logger  by one or more first moving components . Similarly, non-interrupt data  associated with the non-interrupt events  can be moved from the operating system  to the second memory  in the event logger  by the one or more first moving components . It is to be appreciated by one skilled in the art that the one or more first moving components  can include, but are not limited to, hardware, software, a combination of hardware and software, and\/or software in execution. In one exemplary aspect of the present invention, the first moving components  can include separate components for moving the interrupt data  and the non-interrupt data , while in another exemplary aspect, the first moving components  can include components that move both the interrupt data  and the non-interrupt data . While a plurality of first moving components  are described, it is to be appreciated by one skilled in the art that any suitable number of components, including a single component, may be employed in association with the present invention.","The first moving components  can generate the write  of the interrupt data  and the write  of the non-interrupt data . Thus, the first moving components  are associated with providing the interrupt data  to the first memory  and with providing the non-interrupt data  to the second memory .","With further reference to , the event logger  can include one or more second moving components . It is to be appreciated by one skilled in the art that the one or more second moving components  can include, but are not limited to, hardware, software, a combination of hardware and software, and\/or software in execution. The second moving components  move an interrupt data  from the first memory  to the third memory  and move a non-interrupt data  from the second memory  to the third memory . In an exemplary aspect of the present invention, the second moving components  can include separate components for moving the interrupt data  and the non-interrupt data , while in another exemplary aspect, the second moving components  can include components that move both the interrupt data  and the non-interrupt data . In an example aspect of the present invention, the second moving components  move the interrupt data  from the first memory  to the third memory  when the event handling associated with the interrupt event  for which interrupt data  was written to the first memory  is completed. In an example aspect of the present invention, the second moving components  move the non-interrupt data  from the second memory  to the third memory  when the event handling associated with the non-interrupt event  for which the non-interrupt data  was written to the second memory  is completed and\/or when the second memory  becomes substantially full.","The event logger  can include a flushing component . The flushing component  can flush data from the third memory . In an example aspect of the present invention, the flushing component  can flush the data located in the third memory  when the third memory  becomes substantially full and\/or upon the occurrence of a timeout condition. For example, if the flushing component  determines that the third memory  has reached a pre-determined threshold of fullness, (e.g. 75% full) the flushing component  can flush the third memory . Such flushing can include, but is not limited to, resetting read and\/or write pointers associated with the third memory , overwriting the third memory , and transporting the contents of the third memory  to data communications devices, subsequent processes and\/or to disk. By way of further illustration, if a timeout condition occurs, the flushing component  can flush the third memory . For example, if a pre-determined amount of time has passed since the third memory  has been flushed (e.g. 100,000 CPU cycles), then the flushing component  can flush the third memory . It is to be appreciated by one skilled in the art that although two methods are described for the flushing component  to flush the third memory , that any suitable flushing method can be employed to flush the third memory .","Turning now to , two example aspects of the event logging system  () are illustrated. In a first example aspect of the present invention, a system  is illustrated. The system  includes an operating system  to be monitored and an event logger . In the first example aspect of the system , the operating system  and the event logger  run on the same physical hardware. For example, a handheld computer can be loaded with the operating system  (e.g. Windows CE). The handheld computer can also be loaded with the event logger . Thus, the handheld computer is running both the operating system  and the event logger .","In a second example aspect of the present invention, a system  is illustrated. The system  can be referred to as a hardware probe. In the system , the third memory  () is not located in the physical machine running the operating system . Thus, to monitor the operating system , a physical connection between the machine running the operating system  and the system  may be required. By way of illustration, to monitor the operating system , a bus analyzing component  operatively connected to the hardware probe  may be connected to a first bus on a machine  running the operating system , the first bus operatively connected to an interrupt data port  and a non-interrupt data port . The bus analyzing component  can capture data associated with interrupt events to from the interrupt data port  and data associated with non-interrupt events from the non-interrupt data port , the data ports being located in the machine  on which the operating system  is running. The bus analyzing component  may then deposit the interrupt data and the non-interrupt data in a secondary buffer .","In an alternative second example aspect of the present invention, the system  can include the hardware interrupt data port  to receive data associated with interrupt events. Similarly, the system  can include the hardware non-interrupt port  to receive data associated with non-interrupt events. In this alternative second example aspect of the system , data received in the interrupt port  and the non-interrupt port  can be transported under hardware control to a secondary buffer .","The system  can contain a processor  that moves the data from the first memory  () (e.g. the interrupt port ) to the third memory  () (e.g. secondary buffer ) and that moves the data from the second memory  () (e.g. the non-interrupt port ) to the third memory  () (e.g. secondary buffer ). Thus, in the example aspect of the present invention illustrated by the system , problems associated with processing overhead allocated to the event logging are mitigated, since the processing is not undertaken by the same processor running the operating system .","Turning now to , a system associating a time stamp with events handled by an operating system kernel is illustrated. When an interrupt event  occurs, a timer  can be employed to selectively associate a time stamp with the interrupt event  as data concerning the interrupt event  is written to a first memory . Alternatively, the timer  can be employed to selectively associate a time stamp with the data concerning the interrupt event  as it is moved from the first memory  to a third memory . Similarly, when a non-interrupt event  occurs, the timer  can be employed to selectively associate a time stamp with the non-interrupt event  as data concerning the non-interrupt event  is written to a second memory . Alternatively, the timer  can be employed to selectively associate a time stamp with the data concerning the non-interrupt event  as it is moved from the second memory  to the third memory . Whether a time stamp is associated with data associated with an interrupt event  and\/or a non-interrupt event  can be controlled by the present invention. By way of illustration, a user interface can present an administrator configuring event logging with an option for deciding whether to associate time stamps with events. By way of further illustration, one or more calls can be made to an Application Programming Interface (API) to turn on and turn off associating time stamps with event data. A time stamp can include, but is not limited to, a bit count, a time of day indicator, a real time count, an absolute time count, a relative time count, and\/or an epoch counter. It is to be appreciated by one skilled in the art that any suitable time stamp may be employed in accordance with the present invention.","Turning now to , an Application Programming Interface (API)  and a User Interface  (UI) employed to facilitate creating user-defined events  is illustrated. In an example aspect of the present invention, a list  of events to be logged can include both pre-defined interrupt events  and pre-defined non-interrupt events . But the present invention may not have anticipated all the events that an administrator may desire to log. Thus, the API  and the UI  are provided to facilitate creating user-defined events  that can be added to the list  of events to be logged. Monitoring an operating system may be undertaken for many reasons. For example, an operating system can be monitored to determine the effect of adding a new piece of hardware, the effect of adding a new software component, and\/or to determine the amount of operating system resources being allocated to handle certain events. But it is difficult to anticipate all the reasons for which an operating system may be monitored. Thus the API  and\/or the UI  provide means for defining new events, for example, an event occurring when an application accesses a database.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 6","b":["400","402","404","404","404","404","404","400","402","400","402","404","406","400","402"]},"In an example aspect of the present invention, the user interface  is operably connected to an Application Programming Interface  (API). Interactions with the user interface  (e.g. picking an event to log) can generate one or more calls to the API . The API  can update the list of events  to be logged based on the one or more calls.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 7","b":["410","412","402","404","404","404","410","406","404","404","410","412","406","404","410","412","406","404","410","412","406"]},"By providing the API  to processes , which API  facilitates selecting events to be logged from a list  of events, a smaller and\/or more precise set of events to be monitored by the event logger  can be selected, thus facilitating minimizing the intrusiveness of monitoring the operating system and thereby mitigating problems associated with conventional event logging systems.","Turning now to , a data flow diagram illustrating a data flow through a system for triple buffering information concerning events handled by an operating system kernel is illustrated. One or more interrupting processes  can generate interrupt event data  that can be stored in an interrupt event data store . By way of illustration, the interrupt event data  can include information concerning the type of interrupt that was generated and the device causing the interrupt. One or more non-interrupting processes  can generate non-interrupt event data  that can be stored in a non-interrupt event data store . By way of illustration, the non-interrupt event data  can include information concerning the type of the non-interrupt event and the application causing the event. It is to be appreciated by one skilled in the art that although type and device\/application information is discussed in connection with the interrupt event data  and the non-interrupt event data , that other information can be provided in accordance with the present invention.","Moving the non-interrupt event data  to the non-interrupt event data store  can be interrupted by the interrupting processes . Similarly, moving the non-interrupt event data  from the non-interrupt event data store  to an event data store  can be interrupted by the interrupting processes . Since the data flow from the non-interrupting processes  can be interrupted, the present invention includes a method to determine whether the data flow from the non-interrupting processes  was interrupted, and if so, to retry writing the non-interrupt event data  and\/or the non-interrupt event data .","One or more moving processes  can receive interrupt event data  from the interrupt event data store . The one or more moving processes  can move the interrupt event data  to the event data store . Similarly, the one or more moving processes  can receive non-interrupt event data  from the non-interrupt event data store . The one or more moving processes  can move the non-interrupt event data  to the event data store . In an example aspect of the present invention, the interrupt event data  and the non-interrupt event data , as they are moved by the moving processes  can be treated similarly as event data .",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 8","b":["500","510","500","502","510","512","504","514"]},"By separating the moving processes  from the initial writing of interrupt event data  to the interrupt event data store  and from the initial writing of the non-interrupt event data  to the non-interrupt event data store , so that moving data from the interrupt event data store  and moving data from the non-interrupt data store  is handled during non-event-handling processing time mitigates intrusiveness problems in conventional event logging systems by reducing the amount of processing undertaken during event-handling time.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 8","b":["540","542","504","502","514","512","542","522","524","522","524","532"]},"In view of the exemplary systems shown and described above, methodologies, which may be implemented in accordance with the present invention, will be better appreciated with reference to the flow diagrams of , B,  and . While, for purposes of simplicity of explanation, the methodologies of , ,  and  are shown and described as a series of steps, it is to be understood and appreciated that the present invention is not limited by the order of the steps, as some steps may, in accordance with the present invention, occur in different orders and\/or concurrently with other steps from that shown and described herein. Moreover, not all illustrated steps may be required to implement a methodology in accordance with the present invention.","Turning now to , a method for triple buffering information concerning events handled by an operating system and\/or operating system kernel is flow-charted. At step  general initializations are performed. For example, initializations including, but not limited to, clearing memories associated with storing interrupt and non-interrupt event data, resetting counters and timers, and preparing data communications devices can be undertaken. At step , the method waits for an event to occur.","At step , a determination is made concerning whether the event received by the process after waiting at step  is an interrupt event or a non-interrupt event. If the determination at step  is that the event of step  is an interrupt event, then at step  a determination is made concerning whether a time stamp is desired for the data that will be written to a first memory. If the determination at step  is YES, then at step  a time stamp is added to the data that will be written to the first memory in step . At step , information concerning the interrupt event can be written to a first memory. At step , the method waits for the event handler that is handling the event of step  to complete, after which, at step , the information written in step  can be written to a third memory and\/or made available for transporting to other processes and\/or devices. If the determination at step  was that the event of step  was a non-interrupt event, then at step  a determination is made concerning whether a time stamp is desired for the data that will be written to a second memory. If the determination at step  is YES, then at step  a time stamp is added to the data that will be written to the second memory in step . At step  information concerning the non-interrupt event can be written to a second memory. At step , the method waits for the event handler that is handling the event of step  to complete. At step  a determination is made concerning whether the second memory is substantially full. If the determination at step  is YES, then at step  the second memory can be written to the third memory. It is to be appreciated by one skilled in the art that although one method for determining when to write the first memory to the third memory is illustrated, the method waiting for the event handling to complete, that other methods of determining when to write the first memory to the third memory can be employed in accordance with the present invention. It is to be similarly appreciated that although one method for determining when to write the second memory to the third memory is illustrated that other methods of determining when to write the second memory to the third memory can be employed in accordance with the present invention.","At step  a determination is made concerning whether the monitoring method has completed. If the determination at step  is YES, then the monitoring method concludes, otherwise the method continues processing by returning to step  to await the next event. By removing processing from event-handling time, the method is less intrusive than methods that perform more processing associated with the logging during event handling time.","Turning now to , a method for triple buffering information concerning events handled by an operating system and\/or operating system kernel is flow-charted. The method described in  can be associated with a hardware probe, for example. At step  general initializations are performed. For example, initializations including, but not limited to, clearing memories associated with storing interrupt and non-interrupt event data, resetting counters and timers, and preparing data communications devices can be undertaken. At step , the method waits for an event to occur.","At step , a determination is made concerning whether the event received by the process after waiting at step  is an interrupt event or a non-interrupt event. If the determination at step  is that the event of step  is an interrupt event, then at step , information concerning the interrupt event can be written to a first memory. The first memory can be, for example, a hardware port. At step , the information written in step  can be written to a third memory under hardware control. If the determination at step  was that the event of step  was a non-interrupt event, then at step  information concerning the non-interrupt event can be written to a second memory. At step , the information written in step  can be written to a third memory under hardware control. At step , a time stamp can be added to the information being written to the third memory, such time stamp being produced under hardware control.","At step  a determination is made concerning whether the monitoring method has completed. If the determination at step  is YES, then the monitoring method concludes, otherwise the method continues processing by returning to step  to await the next event. By removing processing from the machine running the operating system being monitored, the method is less intrusive than methods that perform more processing on the machine running the operating system being monitored.","Turning now to , a method for selecting events to be logged by a system for triple buffering information concerning events handled by an operating system kernel is flow-charted. At step  a list of the events that can be logged can be displayed, for example, via a User Interface (UI). At step , the events to be logged can be selected. For example, the list of events may include R interrupt events, R being an integer, S non-interrupt events, S being an integer, and T user-defined events, T being an integer. From the set of R+S+T events that potentially could be logged, a subset R\u2032+S\u2032+T\u2032 can be selected. Thus, a more focused set of events can be logged, which facilitates making the present invention less intrusive, and thus mitigates problems with conventional logging methods. In an example aspect of the present invention, the UI is displayed before monitoring begins to facilitate an initial selection of events to be logged. It is to be appreciated by one skilled in the art that events could also be selected from the UI while the event logger is running.","At step  a determination can be made concerning whether any Application Programming Interface (API) calls have been received, where such API calls can dynamically change the list of events to be logged. For example, from the R+S+T set of step , a set R\u2033+S\u2033+T\u2033 can be selected. Thus, the events to be logged can be updated dynamically during the processing of the method. If the determination at step  is YES, then at step  the list of events to be logged is changed. For example, interrupts events may be added to the list of events to log, while non-interrupt events and user-defined events may be deleted from the list of events to log. It is to be appreciated by one skilled in the art that API calls may arrive during the monitoring process, and that steps  and  are intended to facilitate changing the list of events to be logged while the monitor is running. At step  a determination is made concerning whether any events have occurred that need to be logged. If the determination at step  is YES, then at step , the event can be processed. At step  a determination is made concerning whether monitoring is to conclude. If the determination at step  is YES, then monitoring concludes, otherwise the method returns to step .","Turning now to , a method for restricting (e.g. throttling) input to an event logger is flow-charted. At step  a determination is made concerning whether a secondary buffer, containing information associated with interrupt and\/or non-interrupt data is substantially full (e.g. 80%). The secondary buffer may, for example, be located on an external hardware probe. If the determination at step  is YES, then at step  a determination is made concerning whether feedback control has been initiated. If the determination at step  is YES, then at step  a determination is made concerning the type of feedback control that has been initiated. If the determination at step  is that a throttling interrupt is unmasked, then at step  a \u201csecondary buffer full\u201d interrupt can be generated. Such an interrupt may be processed by an external hardware probe, for example. The interrupt may also be handled by an operating system interrupt service routine operable to produce busy looping until an indication that processing may resume is received. If the determination at step  is that a throttling interrupt is masked, then at step  a signal can be sent to a flushing process that can, for example, flush the secondary buffer. After sending the signal at step , the method can wait for a return signal from the flushing process, indicative of the flushing process having freed a portion of the secondary buffer, thus facilitating receiving and processing more events. Although two feedback control techniques have been discussed in association with step , it is to be appreciated by one skilled in the art that a greater or lesser number of techniques may be employed in accordance with the present invention and that other suitable feedback control techniques may be employed. Furthermore, although a determination is indicated at step , masking and\/or unmasking the \u201csecondary buffer full\u201d interrupt can operate to remove the determination at step .","At step  a determination is made concerning whether throttling monitoring is complete. If the determination is YES, then throttling monitoring concludes, otherwise processing returns to step .","In order to provide additional context for various aspects of the present invention,  and the following discussion are intended to provide a brief, general description of a suitable computing environment  in which the various aspects of the present invention may be implemented. While the invention has been described above in the general context of computer-executable instructions that may run on one or more computers, those skilled in the art will recognize that the invention also may be implemented in combination with other program modules and\/or as a combination of hardware and software. Generally, program modules include routines, programs, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, minicomputers, mainframe computers, as well as personal computers, hand-held computing devices, microprocessor-based or programmable consumer electronics, and the like, each of which may be operatively coupled to one or more associated devices. The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary environment  for implementing various aspects of the invention includes a computer , including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit  may be any of various commercially available processors. Dual microprocessors and other multi-processor architectures also can be used as the processing unit .","The system bus  may be any of several types of bus structure including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as PCI, VESA, Microchannel, ISA, and EISA, to name a few. The computer  memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM .","The computer  further includes a hard disk drive , a magnetic disk drive , e.g., to read from or write to a removable disk , and an optical disk drive , e.g., for reading a CD-ROM disk  or to read from or write to other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the computer , including for the storage of broadcast programming in a suitable digital format. Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as zip drives, magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, and the like, may also be used in the exemplary operating environment, and further that any such media may contain computer-executable instructions for performing the methods of the present invention.","A number of program modules may be stored in the drives and RAM , including an operating system , one or more application programs , other program modules , and program non-interrupt data . The operating system  in the illustrated computer is, for example, the \u201cMicrosoft\u00ae Windows\u00ae NT\u00ae\u201d operating system, although it is to be appreciated that the present invention may be implemented with other operating systems or combinations of operating systems, such as UNIX\u00ae, LINUX\u00ae, etc.","A user may enter commands and information into the computer  through a keyboard  and a pointing device, such as a mouse . Other input devices (not shown) may include a microphone, an IR remote control, a joystick, a game pad, a satellite dish, a scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus , but may be connected by other interfaces, such as a parallel port, a game port, a universal serial bus (\u201cUSB\u201d), an IR interface, etc. A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, a computer typically includes other peripheral output devices (not shown), such as speakers, printers etc.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer(s) . The remote computer(s)  may be a workstation, a server computer, a router, a personal computer, microprocessor based entertainment appliance (e.g., a WebTV\u00ae client system), a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory storage device  is illustrated. The logical connections depicted include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem , or is connected to a communications server on the LAN, or has other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Turning now to , a screen shot  of the output from a process for viewing information gathered by the system  () is provided. The screen shot  illustrates a log area , a legend area , and a process pane . The log area  facilitates understanding the running of the operating system being monitored. For example, a horizontal line can be associated with a process, and attributes including, but not limited to the size, shape, color, location, and presence of icons can be associated with the horizontal line. Such visual indicators facilitate understanding the data gathered by the operating system and thus facilitate understanding the running of the operating system being monitored. By way of illustration, the visual indicators can facilitate visualization of time-based thread interactions, and system events that occur in the running system. It is to be appreciated by one skilled in the art that different visual indicators can be associated with the horizontal line to convey information about a process in accordance with the present invention.","One or more threads can be associated with a process. The interactions between threads may be important to diagnosing operating system, device driver and\/or application program problems. Thus, the present invention facilitates displaying the one or more threads associated with a process. The process pane  facilitates selecting which threads and\/or processes to display in the log area . For example, a process may be associated with five threads. By expanding the process in the process pane , the example five threads can be viewed in the log area . In an exemplary aspect of the present invention, the log area  facilitates viewing items including, but not limited to, process states, thread states, process events, thread events, process switching, thread switching, events, changing states of semaphores, changing states of mutexs, entering\/leaving a critical section, and the occurrence of user defined events.","Tracking processes and\/or threads can be important to diagnosing problems associated with programs including, but not limited to, operating systems, device drivers, and\/or applications. Thus, the present invention facilitates viewing information concerning processes and\/or threads. Information collected concerning a process can be used to graphically display the process as being in one of at least three states, for example, running, not running and not alive. The running state indicates that at least one thread within the process is in the running state. The not running state indicates that no threads within the process are actively running. A process in the not running state can be in one of two sub-states, the ready to run sub-state and the not ready to run sub-state. In the ready to run sub-state, at least one thread is ready to run, but no threads are running. In the not ready to run sub-state no threads are ready to run (e.g. blocked, sleeping). The not alive state indicates that the process has not been created, or is no longer alive.","Information collected concerning a thread can be used to graphically display the thread as being in one of at least five states, for example, running, ready, blocked, sleeping, and not alive. In the running state, the thread is active and has possession of the CPU. In the ready state the thread is ready to run, but is not currently running. In the blocked state the thread is unable to run until an event such as a mutex becomes available. In the sleeping state the thread has voluntarily gone to sleep for a set duration while in the not alive state the thread has exited.","Since the system  may be run at different times for different reasons, an exemplary aspect of the present invention facilitates viewing the data gathered by the system  in one of at least three different modes: a real time mode; a system log of a previous run mode, and a limited buffer mode. The different modes facilitate monitoring an operating system for different reasons at different times. The real time mode displays data gathered by the system  () in the log area  in near real time. Thus, the real time mode facilitates analyzing operating system problems substantially as they occur. The system log mode displays data gathered by the system  () in the log area  from a file in which such data was stored. Thus, the system log mode facilitates monitoring an operating system at a first time, and then viewing the data gathered by such monitoring at a second, later time. The limited buffer mode also displays gathered by the system  () in the log area  from a file in which such data was stored. But the limited buffer mode is employed to gather data for a specified time period from a longer monitoring session. For example, an administrator may desire to perform a series of stress tests against an operating system. The stress test may run for twenty-four hours, for example. But the administrator may only be interested in the first ten minutes of data and the last  minutes of data. Thus, the limited buffer mode is provided to facilitate selecting such discrete intervals of time for which monitoring data should be gathered and\/or displayed. By way of further illustration, an administrator may desire to view data upon the occurrence of triggering events, and\/or at scheduled intervals. For example, the administrator may desire to view data when a semaphore is changed, and\/or every ten minutes, for five seconds. The limited buffer mode facilitates selecting such types of data to view for such periods of time.","Viewing data gathered by the system  () facilitates diagnosing problems including, but not limited to, deadlocks, and missed real time deadlines. By way of illustration, a deadlock problem can exist if a first thread is waiting for a resource held by a second thread, and the second thread is waiting for a resource held by a first thread. Examining data displayed in the log area  facilitates locating a resource that is blocking a thread, or a low priority thread holding a resource that is blocking a higher priority thread. Once the resource is located, then data associated with the resource can be searched to locate the thread holding the resource. Thus, threads creating deadlock conditions can be located which facilitates diagnosing deadlock problems.","By way of further illustration, real time deadlines can be missed when two periodic threads are running. A periodic thread is a thread that runs at a specified repeating time interval and that should complete within its time period. A first periodic process may run frequently (e.g. once per second) but require little time (e.g. one millisecond) to complete. A second periodic process may run infrequently (e.g. once per hour) but may require a long time (e.g. ten seconds) to complete. If both threads have the same priority, then it is possible that the first periodic thread will not be able to run according to its periodic schedule while the second periodic thread is running. Viewing data associated with the two periodic threads in the log area  can facilitate diagnosing problems with such competing periodic threads.","By way of further illustration of missed real time deadlines, a process may be required to display thirty frames of data per second to facilitate viewing a video image without gaps in the video display. But such a video display process may miss a real time deadline if threads of equal or higher priority are running. Determining which threads and\/or processes are responsible for missed real time deadlines can facilitate diagnosing and resolving thread interaction problems.","In an exemplary aspect of the present invention, data collected for threads monitored by the system  will be represented in one or more horizontal lines. Icons may be placed on the horizontal lines to represent data associated with events that happened at that point in time. Information associated with the event represented by the icon can, for example, pop-up when a pointer passes over the icon. For example, information including, but not limited to: what event occurred; when an event occurred; which processes were affected; which threads were affected, and which objects were affected can be displayed.","Turning now to , a screen shot  of a user interface that facilitates searching for events in data gathered by the system  () is provided. Monitoring an operating system can produce data associated with processes and\/or threads and events associated with the processes and\/or threads. But an administrator may only be interested in a particular process and\/or thread and\/or event. Thus, the user interface displayed in the screen shot  provides a method for selecting a particular process via a process field . Similarly, the user interface displayed in the screen shot  provides a method for selecting a particular thread via a thread field . Similarly, the user interface displayed in the screen shot  provides a method for selecting a particular event via an event field . Restricting the data to be displayed to data associated with a particular process and\/or thread and\/or event can reduce the amount of processing time required to view the data, thus making the present invention less intrusive than conventional monitoring systems.","Turning now to , a screen shot  of a user interface that facilitates selecting a subset of data to view from data gathered by the system  () is provided. Since an operating system can be monitored for different reasons, in an exemplary aspect of the present invention, the component and method for runtime display of monitoring data includes the user interface depicted in the screen shot  to facilitate selecting data to be viewed. The user interface includes a synchronization tab  that can facilitate choosing to display data associated with events associated with synchronization. For example, events listed in an event chooser  can include, but are not limited to: entering\/leaving a critical section; creating\/releasing a semaphore; pulse events, and wait for multiple object events. Processes, for example applications, may generate events that are not pre-defined in the system  (). Thus, the user interface can also include a user defined event tab  that can facilitate choosing to display data associated with user-defined events. Restricting the data to be displayed to data associated with particular events can reduce the amount of processing time required to view the data, thus making the present invention less intrusive than conventional monitoring systems.","Turning now to , a screen shot  of a user interface for selecting a limited size for a buffer in which data gathered by the system  () can be stored is provided. As mentioned above, the present invention facilitates viewing data collected by the system  () in near real time and from a file. The user interface depicted in screen shot  facilitates setting the maximum size of the file to which event data can be written, and from which the event data can subsequently be viewed. An administrator may desire to save, for example, fifty megabytes of data. Thus, the user interface provides a file size selection area , operable to select the number of megabytes of data that will be saved. Restricting the amount of data to be collected can reduce the amount of memory, disk and processing time required to collect the data, thus making the present invention less intrusive than conventional monitoring systems.","What has been described above includes examples of the present invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly, the present invention is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
