---
title: Method and system for improving startup performance and interoperability of a virtual application
abstract: A data structure including simple and complex objects. Each simple object includes a content type indicator, a size indicator, and one or more simple data types. Each complex object includes a content type indicator, a size indicator, and one or more child objects. The complex objects include a layer object having first and second child objects. The first child object is a collection of complex objects storing information for configuring a virtual filesystem of a virtual application at application startup. The second child object is a collection of complex objects storing information for configuring a virtual registry of the virtual application at application startup. Reading of selected simple and complex objects may be deferred at startup based on the content type indicator. Deferred objects may be read after startup when access to information stored by the deferred object is request by the virtual application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09229748&OS=09229748&RS=09229748
owner: CODE SYSTEMS CORPORATION
number: 09229748
owner_city: Seattle
owner_country: US
publication_date: 20100129
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Deferred Expansion","Forward and Backward Compatibility"],"p":["1. Field of the Invention","The present invention is directed generally to file formats and data structures used to implement application virtualization.","2. Description of the Related Art","A virtual application is a virtual machine image pre-configured with all of the files, registry data, settings, components, runtimes, and other dependencies required for a specific application to execute immediately and without installation on a host computing device. The virtual application is partially isolated from other applications implemented on a host computing device and partially isolated from an underlying host operating system installed and executing on the host computing device. The virtual application is encapsulated from the host operating system by a virtual runtime environment, which includes a virtual operating system, that receives operations performed by the virtualized application and redirects them to one or more virtualized locations (e.g., a virtual filesystem, virtual registry, and the like).","Thus, the virtual application may be conceptualized as including two components: a virtualization runtime and a virtual application configuration. The virtualization runtime implements the virtual runtime environment, which implements various operating system application programming interfaces (\u201cAPIs\u201d) in such a way that allows the executing virtual application to access and interact with items that may not be present on the host computer. The virtual application configuration includes data necessary to implement the virtual application within the virtualization runtime.","The virtual application is stored in and implemented by one or more data files and\/or executable files. Depending upon the implementation details, the one or more data files and\/or executable files storing and implementing the virtual application may include blocks of data corresponding to each application file of a natively installed version of the application. Herein, these blocks of data will be referred to as \u201cvirtual application files.\u201d The one or more data files and\/or executable files storing and implementing the virtual application also include configuration information.","The data files and\/or executable files are configured to execute within a virtual runtime environment that is provided at least in part by the virtual operating system. When the virtual application is executed within the virtual runtime engine, the configuration information is used to configure the virtual operating system to execute the virtual application. For example, the configuration information may contain information related to the virtual application files, virtual registry entries, environment variables, services, and the like. The virtual operating system is configured to communicate with the host operating system as required to execute the virtual application on the host computing device.","As is apparent to those of ordinary skill in the art, to execute the virtual application, the virtual runtime engine reads the configuration information and the virtual application files stored in the data file(s) and\/or executable file(s). Thus, an amount of time required to execute the virtual application is determined at least in part by how efficiently the reader can access data stored in the data file(s) and\/or executable file(s). File formats that enable efficient data access by the reader of the virtual runtime engine are desirable. To reduce an amount of time required to startup a virtual application, a need exists for a file format configured to identify portions that may be skipped initially and read at a later time. Further, compatibility of a particular virtual application with a particular version of the virtual runtime engine is determined at least in part by the format of the data file(s) and\/or executable file(s). Therefore, a need exists for file formats configured to provide forward and\/or backward compatibility. The present application provides these and other advantages as will be apparent from the following detailed description and accompanying figures.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 1","FIG. 1"],"b":["22","35","126","128","130","140","22","35","35"]},"In , the virtualized application file  includes components necessary to implement a virtual operating system  configured to execute in the host operating system  and a virtual application  configured to execute in the virtual operating system . In the embodiment illustrated a single virtual application file is used to implement both the virtual operating system  and the virtual application . However, those of ordinary skill in the art appreciate that more than one virtual application file may be used to implement the virtual operating system  and the virtual application .","The virtual operating system  includes a virtual filesystem , virtual registry , and a virtual process environment and threading subsystems component . The virtual application  interacts with the virtual filesystem , virtual registry , and virtual process environment and threading subsystems component , instead of interacting directly with the host filesystem , the host registry , and the process environment and threading subsystems component  of the host operating system . The virtual operating system  is configured to communicate with the host operating system  as required to execute the virtual application .","The virtual application  executes inside a virtual runtime environment provided at least in part by the virtual operating system . Some virtual applications require one or more additional runtime environments to execute. For example, to execute a Flash application, the Flash runtime engine must also be installed. Therefore, to virtualize a Flash application, both the Flash application and Flash runtime engine must be included in the virtualized application file  and configured to execute in the portions of the virtual runtime environment provided by the virtual operating system . Collectively, all runtime components necessary to execute the virtual application  will be referred to as a virtual runtime engine. However, those of ordinary skill in the art appreciate that the virtual runtime engine may include only the virtual operating system  and components of other additional runtime engines (e.g., the Flash runtime engine) required to execute the virtual application  may be loaded separately by the virtual operating system . When executed, the virtual runtime engine generates, at least in part, the virtual runtime environment in which the virtual application  executes.","A natively installed version of an application is configured to execute within a runtime environment provided at least in part by the host operating system . Typically, to execute within the runtime environment provided at least in part by the host operating system , a natively installed version of an application modifies the configuration and settings of the host operating system . For example, the natively installed version may install dynamic link libraries or change registry settings of the host operating system . In contrast, a virtual version of the same application may be executed on the host operating system  without installation on the host operating system . Thus, the virtual application  does not modify the configuration or settings of the host operating system . For example, to execute the virtual application , dynamic link libraries (\u201cdlls\u201d), data files, registry settings, environment variables, and the like need not be modified on to the host operating system .","The virtualized application file  includes virtualized application files A-C corresponding to application files A-C of a natively installed version of the same application. The virtualized application files A-C are stored as blocks of data inside a configuration data block . During execution, the virtualized application files A-C are accessed via the virtual filesystem . The virtualized application files A-C include one or more startup executables. The virtualized application file  identifies one or more startup executables that are executed when the virtual application  is first executed. The startup executables may be identified in the configuration data block .","When the virtualized application file  is executed, the configuration data block  is used to configure the virtual operating system  to execute the virtual application. For example, the configuration data block  may contain configuration information related to the files in the virtual filesystem  (e.g., the virtualized application files A-C), entries in the virtual registry , environment variables, services, and the like. The configuration data block  may also include basic application metadata and settings such as the application name, application version, and sandbox location. Further, the configuration data block  may provide isolation information to the virtual operating system . This information indicates which virtualized application files A-C, virtual registry keys, virtual registry values, environment variables, and services are to be isolated from the host operating system .","The configuration data block  may also include one or more virtual layers. Each virtual layer may identify files, registry entries, environment variables, and services. As the virtual layers are read, the corresponding files, registry entries, environment variables, and services are added to appropriate runtime data-structures. If the virtualized application file  is configured to execute on more than one host operating system, the configuration data block  may include a virtual layer for each operating system. In such an embodiment, each virtual layer includes information necessary to configure the virtual runtime environment to execute on a particular operating system. Further, the configuration data block  may include a virtual layer that includes configuration information common to the other virtual layers (e.g., a \u201cdefault\u201d virtual layer).","To execute the virtual application , an initialization process is first performed. During this process, the virtual operation system  is launched and configured by the configuration data block . A component of the virtual runtime engine referred to as a \u201creader\u201d reads data stored in the configuration data block  and uses that data to configure the virtual runtime environment. For example, the reader reads the virtual layer for the host operating system  and any other applicable virtual layers and uses the information read to configure the virtual operation system  (and in some implementations, other components of the virtual runtime environment) to execute the virtual application  on the host operating system . The virtual filesystem  may be configured to mirror a host filesystem configured to execute a natively installed version of the application. Similarly, the virtual registry  may be configured to mirror a host registry configured to execute a natively installed version of the application.","After the initialization process has completed, the appropriate startup executable(s) is\/are launched inside the virtual operating system . The virtual operating system  intercepts calls to the host operating system  and routes them to corresponding components of the virtual operating system . For example, when the virtual application  requests to access an application file using a path of a natively installed version of the application, the virtual operating system  intercepts the request and routes the request to one of the virtualized application files A-C corresponding to the application file requested. The virtual operating system  may also route some requests and actions to the host operating system  for processing.","The virtualized application file  is read-only and when executed, cannot be modified by the virtual application  or components of the virtual runtime engine. Therefore, modifications to the data stored in the configuration data block  (e.g., modifications to the virtualized application files A-C, modifications to the registry keys of the virtual registry , and the like) are written to a readable and writable memory location referred to herein as a sandbox . The sandbox  is a location on the host filesystem , a network share, a removable storage device, and the like whereat files may be created, modified, and deleted by the virtual application  at runtime. For example, when the virtual operating system  needs to create, modify, or delete a virtualized application file, the virtual operating system does so in the sandbox . Similarly, if the virtual application  modifies a virtual registry value, the virtual registry value is changed in the sandbox . The virtual operating system  may also route some requests and actions to the host operating system  for processing.","U.S. patent application Ser. No. 12\/188,155, filed on Aug. 7, 2008, now pending; U.S. patent application Ser. No. 12\/188,161 filed on Aug. 7, 2008, now pending; and U.S. patent application Ser. No. 12\/685,576 filed on Jan. 11, 2010, now pending; all of which are incorporated herein by reference in their entireties, disclose systems that may be used to create and configure the virtualized application file . As described in greater detail in 20 U.S. patent application Ser. Nos. 12\/188,155, 12\/188,161, and 12\/685,576, the virtualized application file  may be created by a virtual application executable constructor or authoring tool  using an application template that includes copies of files, such as a configuration file , application files A-C, and the like, used to configure the virtualized application file . However, the template is not a requirement. Instead, to build the virtualized application file , the authoring tool  needs only the configuration file  and copies of any applications files A-C necessary for a natively installed version of the application to execute. The applications files A-C, and the configuration file  are referred to collectively as an application configuration .","The authoring tool  combines the application configuration  and the components of the virtual runtime engine (e.g., the virtual operating system ) into the executable virtualized application file . Sometimes multiple virtual applications share a common set of virtual machine configuration settings or virtual runtime engine components. By way of a non-limiting example, multiple Flash applications may be configured to be executed by the same Flash runtime engine. Further, system administrators may want to share a common set of configuration options (e.g., browser bookmarks, application settings, etc.) across a department or enterprise. These settings may be stored in a file, referred to as an xlayer file , and incorporated into one or more virtual application files at runtime by the virtual runtime engine. Depending upon the implementation details, the authoring tool  may be used to create the xlayer file .","The xlayer file  cannot be executed directly from the host operating system  and instead requires the virtual runtime environment supplied at least in part by the virtual operating system . Like the configuration data block , the xlayer file  may be read by the reader of the virtual runtime engine at runtime. The information stored within the xlayer file  may be made available to a virtual application (e.g., the virtual application ) via the virtual filesystem  and virtual registry  of the virtual operating system  at runtime. By way of a non-limiting example, the configuration data block  may specify a location on the host filesystem  whereat the virtual runtime engine (e.g., the virtual operating system ) is configured to look for xlayer files. If an xlayer file is located in the specified location, the xlayer file  may be read automatically by the reader of the virtual runtime environment. Alternatively, the virtual runtime engine may be configured to look for xlayer files in a particular location each time the virtual application  is executed.","The xlayer file  may be shared between users and used to supply virtual machine settings to multiple virtual applications. The xlayer file  may include all virtual registry and virtual filesystem information associated with a particular software component (e.g., a virtual runtime engine component), allowing the component to be fully installed in the virtual runtime environment. The xlayer file  may be implemented as a binary file. The data in the xlayer file  may be organized in one or more virtual layers substantially similar to the virtual layers of the configuration data block  described above.","As is apparent to those of ordinary skill in the art, the number of files and registry keys needed to implement a virtual application (such as the virtual application ) and\/or a component encoded in the xlayer file  can be very large. For example, it is not uncommon for the number of files and registry keys needed to implement a virtual application to total in the tens of thousands. Therefore, the performance characteristics of the configuration data block  and the xlayer file  can affect the performance of the virtual application  significantly. In other words, the performance characteristics of the configuration data block  and\/or the xlayer file  can increase or decrease the startup time for the virtual application .","As is apparent to those of ordinary skill in the art, the configuration data block  and the xlayer file  store similar data and therefore, can be formatted in accordance with a common format.  illustrates a file format  that may be used to configure the configuration data block  portion of the executable virtualized application file  and\/or the xlayer file .","Typically, as operating systems are updated, new operating system features need to be virtualized to support new classes of applications. In other words, the virtual operating system  may be updated to support new applications. When this occurs, the file format  may need to be reconfigured to execute within the updated virtual operating system. Therefore, the file format  illustrated in  is configured to be readily reconfigurable.","It may be desirable to avoid modifying the file format  after it has been created to avoid forward and backward incompatibility issues with newer and older versions of the virtual runtime engine. In other words, the file format  should be compatible with the virtual operating system  despite modifications made to the file format . Additionally, it may be advantageous to separate the components implementing the virtualization runtime environment (e.g., the components of the virtual operating system ) from the data stored in the file format . This separation allows updates to be made to the virtualization runtime environment without also requiring a re-build of the virtualized application file  and\/or the xlayer file .","Sometimes, a user may wish to execute or load multiple virtualized application files and\/or xlayer files in one virtualization runtime environment to allow multiple virtual applications to interact or interoperate with one another. Therefore, the file format  may be configured to be parsed quickly and to be forward and backward compatible with different versions of the virtualization runtime environment. For example, the file format  may include strongly-typed data and size encoding to improve performance and interoperability between virtual applications.","The file format  includes a signature value , a version stamp , a size indicator , an error checking section , and a body section . The data in file format  is ordered with the signature value  being first followed by the version stamp , which is followed by the size indicator , which is followed by the error checking section , which is followed by the body section . The body section  may include any number of child objects .","The signature value  is a value used to authenticate the information stored in a file. The signature value  may be implemented as a block of six bytes of data. The value stored in the signature value  may be generated using any method and the present teachings are not limited to use with a signature value generated by any particular method.","The version stamp  may include a major version identifier  and a minor version identifier . The major version identifier  should be modified if a change is made to the file format  that would make the file incompatible with a previous version of the virtual runtime engine. The minor version identifier  may be incremented for informational purposes when a new content type is added to the file format , or for other minor modifications to the file format . Each of the major and minor version identifiers  and  may be implemented as 32-bit integers.","The size indicator  identifies a location in memory that corresponds to the end of a file having the file format . The location in memory to which the size indicator  refers is identified in  by a curved arrow \u201cA.\u201d By way of a non-limiting example, the size indicator  may be implemented as a 32-bit integer.","By way of a non-limiting example, the error checking section  may be implemented using a cyclic redundancy check (\u201cCRC\u201d) method. In such an embodiment, the error checking section  may include a CRC code  and a CRC size indicator . Each of the CRC code  and the CRC size indicator  may be implemented as 32-bit integers.","The CRC code  may be created using a simple XOR based CRC function. The CRC size indicator  may indicate on how many bytes the CRC function is performed. By way of a non-limiting example, the CRC function may be performed on a number of bytes specified by the CRC size indicator  starting with the bytes of the CRC size indicator . By performing the CRC function on fewer than all of the bytes following the CRC size indicator , error checking may be performed on more sensitive data stored nearer the beginning of the virtualized application file  or the xlayer file . For example, if a child object named \u201cObject-\u201d stores licensing data, it may be desirable for that data to be tamper resistant. However, subsequent data (e.g., the data stored in a child object named \u201cObject-N\u201d) may be less sensitive to tampering. Therefore, performance may be improved by limiting error checking to only data sensitive to errors. In other words, this technique may be used to reduce initial costs (e.g., processor time) associated with validating the data stored in the virtualized application file  and\/or the xlayer file .","The body section  includes a number of child objects . Each of the child objects  has a simple format  (illustrated in ), a complex format  (illustrated in ), or a collection format  (illustrated in ). Referring to , an object having the simple format  is referred to as a \u201csimple object,\u201d and an object having the complex format  is referred to as a \u201ccomplex object.\u201d The collection format  is configured to store a collection of simple or complex objects.","Each of the simple, complex, and collection formats , , and  includes a content type indicator  and the size indicator . The content type indicator  is positioned first in each of the simple, complex, and collection formats , , and  and indicates whether an object has the simple format , the complex format , or the collection format . By way of a non-limiting example, an object may be identified as having the collection format  when a highest-order bit in the content type indicator  is set. In such an embodiment, if the highest-order bit is not set, the object has the simple format  or the complex format .","The content type indicator  identifies the type of data stored in the object. Further, the content type indicator  indicates which data items (other than the content type indicator  and the size indicator ) are included in the object. For example, as shown in , when the content type indicator  indicates the content type of an object is \u201cFile\u201d (see Table A below), the object has the simple format  configured to store seven data items other than the content type indicator  and the size indicator . This format is referred to as a \u201cFile simple format\u201d and has been identified in  by reference numeral A. On the other hand, as shown in , when the content type indicator  indicates the content type of an object is \u201cRegValue\u201d (see Table A below), the object has the simple format  configured to store four data items other than the content type indicator  and the size indicator . This format is referred to as a \u201cRegValue simple format\u201d and has been identified in  by reference numeral B.","Non-limiting examples of other types of content are provided in a leftmost column of Table A below. The rightmost column of Table A indicates in which format, the simple format  or the complex format , the content may be stored. By way of a non-limiting example, the content type indicator  may be implemented as a 32-bit integer.",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Content Type","Object Format"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ConfigBase","Simple"]},{"entry":[{},"Licensing","Simple"]},{"entry":[{},"AppMetadata","Simple"]},{"entry":[{},"Splash","Simple"]},{"entry":[{},"MessageStrings","Simple"]},{"entry":[{},"StartupFile","Simple"]},{"entry":[{},"ChildProcessException","Simple"]},{"entry":[{},"Layer","Complex"]},{"entry":[{},"LayerCondition","Simple"]},{"entry":[{},"Directory","Complex"]},{"entry":[{},"File","Simple"]},{"entry":[{},"RegKey","Complex"]},{"entry":[{},"RegValue","Simple"]},{"entry":[{},"ShortcutDir","Complex"]},{"entry":[{},"Shortcut","Simple"]},{"entry":[{},"ProgId","Complex"]},{"entry":[{},"Extension","Complex"]},{"entry":[{},"Verb","Simple"]},{"entry":[{},"Service","Simple"]},{"entry":[{},"EnvironmentVariable","Simple"]},{"entry":[{},"Font","Simple"]},{"entry":[{},"ShimInfo","Simple"]},{"entry":[{},"XLayersInfo","Simple"]},{"entry":[{},"SnapshotDirectory","Simple"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Each of the simple and complex formats  and  also includes the size indicator . The size indicator  identifies a location in memory that corresponds to the end of the object. By way of a non-limiting example, the size indicator  may be implemented as a 32-bit integer.","Turning to , the simple format  includes the content type indicator , the size indicator , and a predetermined sequence  of data items each having a simple data type. The term \u201csimple data type\u201d refers to basic data types such as integers, strings, flags, Booleans, byte arrays, and the like. In the embodiment illustrated, the data in a simple format  is ordered with the content type indicator  being first followed by the size indicator , which is followed by the predetermined sequence  of data items. The sequence  illustrated includes simple data types named \u201cDATA-,\u201d \u201cDATA-,\u201d . . . \u201cDATA-N.\u201d The location in memory to which the size indicator  refers is identified in  by a curved arrow \u201cA.\u201d","Referring to , the complex format  includes the content type indicator , the size indicator , a header section , and a body section . In the embodiment illustrated, the data in the complex format  is ordered with the content type indicator  being first followed by the size indicator , which is followed by the header section , which in turn is followed by the body section . The location in memory to which the size indicator  refers is identified in  by a curved arrow \u201cA.\u201d","The format of the header section  is similar to the simple format  but omits the content type indicator . Specifically, the header section  includes the size indicator  followed by a predetermined sequence  of data items each having a simple data type. The sequence  illustrated includes simple data types named \u201cDATA-,\u201d \u201cDATA-,\u201d . . . \u201cDATA-N.\u201d The location in memory to which the size indicator  in the header section  refers is identified in  by a curved arrow \u201cA.\u201d The header section  stores information related to the complex object itself.","The body section  includes any number of child objects . The child objects  illustrated include objects named \u201cCHILD OBJECT-,\u201d \u201cCHILD OBJECT-,\u201d . . . \u201cCHILD OBJECT-N.\u201d Each of the child objects  may have the simple format , the complex format , or the collection format . Therefore, each of the child objects  includes the content type indicator  and the size indicator .","Referring to , the collection format  includes the content type indicator , the size indicator , a count indicator , and a number of collection objects . In the embodiment illustrated, the data in the collection format  is ordered with the content type indicator  being first followed by the size indicator , which is followed by the count indicator , which is followed by the collection objects . The collection objects  illustrated include objects named \u201cOBJECT-,\u201d \u201cOBJECT-,\u201d . . . \u201cOBJECT-N.\u201d","As mentioned above, an object has the collection format  when the highest-order bit of the content type indicator  is set. When the highest-order bit of the content type indicator  is set, the lower order bits of the content type indicator  indicate the format of the data stored in the collection objects . For example, when the highest-order bit is set and the lower order bits indicate the content type of the collection object is \u201cFile\u201d (see Table A above), each of the objects in the collection objects  has the File simple format A illustrated in . Thus, each of the collection objects  has the content type identified by the content type indicator  of the collection.","The size indicator  refers to an address of the last object in the collection objects . The location in memory to which the size indicator  refers is identified in  by a curved arrow \u201cA.\u201d","The count indicator  indicates how many collection objects  are in a collection. By way of a non-limiting example, the count indicator  may be implemented as a 32-bit integer.","Each of the collection objects  has the simple format , the complex format , or the collection format . Therefore, each of the collection objects  includes the content type indicator  and the size indicator .","Referring to , the body section  of the file format  resembles the body section  (see ) of a complex format  and may include any number of child objects . Referring to , the child objects  of the file format  may have the simple format , the complex format , or the collection format . The minor version identifier  of the file format  may be incremented for informational purposes when a new simple element is added to the simple format  of a preexisting content type, a simple element is added to the header section  of the complex format  for a particular content type, or a new child object is added to the body section  of the complex format  for a particular content type.","As explained above, referring to , the data in the virtualized application file  and\/or the xlayer file  may include one or more virtual layers. As shown in Table A, when the content type indicator  indicates the content type is \u201cLayer,\u201d the object has the complex format  configured to store virtual layer data. This format is referred to as a \u201cLayer complex format\u201d and has been identified in  by reference numeral A.","By way of a non-limiting example, the virtualized application file  and\/or the xlayer file  may include a virtual layer for each different host operating system or host runtime environment on which the virtual application  is configured to be executed. Further, as explained above, the virtual application  may be implemented using one or more executable files and\/or xlayer files. Therefore, to execute a single virtual application, the reader of the virtual runtime engine may need to parse more than one complex object having the Layer complex format A.","The Layer complex format A stores information used to configure the virtual filesystem  and the virtual registry . In the header section , the layer format A has a name indicator  for storing the name of the virtual layer and a flags indicator . The flags indicator  indicates whether an object having the Layer complex format A is a \u201cSystem\u201d layer. A \u201cSystem\u201d layer includes items (such as a licensing module) used by the virtual runtime engine. These items may be created by the authoring tool . In particular implementations, the items are not authored by the authoring tool  and not by a user. In the body section , the Layer complex format A includes nine child objects .","A first child object  named \u201cCondition\u201d is a simple object of type \u201cLayerCondition\u201d (see Table A above). This object specifies a condition for including or excluding the content of the parent Layer complex object. For example, the condition may identify a particular operating system and whether to include or exclude the parent Layer complex object depending upon whether the host operating system  is the particular operating system specified.","A second child object  named \u201cFileSystem\u201d is a collection of objects having the content type \u201cDirectory\u201d (see Table A above). Objects having the content type \u201cDirectory\u201d are referred to herein as \u201cDirectory complex objects.\u201d As indicated in Table A above, an object having the content type \u201cDirectory\u201d has the complex format  (see ) configured to store directory information. This format is referred to as a \u201cDirectory complex format\u201d and has been identified in  by reference numeral B. Therefore, in the second child object , each of the child objects  has the Directory complex format B.","As is apparent to those of ordinary skill in the art, files and directories are organized in the virtual filesystem  in a hierarchical structure with a root directory (storing files and subdirectories) located at the base of the hierarchy and nodes (subdirectories) linked to the root directory. The collection of Directory complex objects of the second child object  stores subdirectories used to configure a root directory of the virtual filesystem . The collection of Directory complex objects may be configured to mirror the subdirectories stored in a root directory by a natively installed version of the application. If the virtual application  is executed using more than one virtual layer, each virtual layer may configure a portion of the same root directory. Alternatively, two or more of the virtual layers may configure subdirectories within the virtual filesystem . Referring to , each of the Directory complex objects of the second child object  (see ) corresponds to a subdirectory and has the Directory complex format B.","The Directory complex format B includes a flags indicator  and a name indicator  in the header section . The flags indicator  indicates one or more values assigned to properties of the subdirectory in the virtual filesystem . By way of non-limiting examples, the flags indicator  may include bits indicating which of the following flags have been set to \u201cTRUE:\u201d isolated, merged, empty, read-only, and hidden. When the flag \u201cisolated\u201d is set to \u201cTRUE,\u201d the directory is isolated from the host operating system . When the flag \u201cmerged\u201d is set to \u201cTRUE,\u201d the directory is merged with a corresponding directory on the host filesystem . When the flag \u201cempty\u201d is set to \u201cTRUE,\u201d the directory is empty (i.e., the directory does not include any files or subdirectories). When the flag \u201cread-only\u201d is set to \u201cTRUE,\u201d the contents of the directory are read-only. When the flag \u201chidden\u201d is set to \u201cTRUE,\u201d the directory is hidden. The flags indicator  may be implemented as a 32-bit integer.","The name indicator  indicates the name of the subdirectory to which the Directory complex object corresponds. The name indicator  may be implemented as a string.","In the body section , each of the Directory complex objects of the second child object  includes a collection  of simple objects of the type \u201cFile\u201d (\u201cFile simple objects\u201d) and a collection  of Directory complex objects.","Each of the File simple objects of the collection  corresponds to a file stored in the subdirectory to which its parent Directory complex object corresponds. Referring to , each of the File simple objects has a File simple format A that includes a flags indicator , a PayloadOffset indicator , a PayloadSize indicator , a FullSize indicator , a RandomSeed indicator , a name indicator , and a MD5 field .","The flags, PayloadOffset, PayloadSize, FullSize, and RandomSeed indicators , , , , and  may be implemented as 32-bit integers. The PayloadOffset indicator  indicates a location of the start of the block of data (or \u201cpayload\u201d) corresponding to a location in memory whereat the data stored in the File simple object begins. Thus, the PayloadOffset indicator  refers to an offset whereat bytes of file data begin. These bytes may be raw or compressed. The PayloadSize indicator  indicates the size of the payload starting at the location stored in the PayloadOffset indicator . The FullSize indicator  indicates an uncompressed size of the data stored in the File simple object. The value of the FullSize indicator  will be the same as value of the PayloadSize indicator  when the bytes of file data are not compressed.","The RandomSeed indicator  may be used to obfuscate the contents of the data stored in the File simple object. In this manner, files may be less recognizable within the virtualized application file  and\/or the xlayer file . The RandomSeed indicator  may be used to perform a function or transform (e.g., XOR) on the bytes of file data. For example, an XOR function may be used on the RandomSeed indicator  and the first byte of the file data. After each XOR operation, a result of the operation may be used to compute a new seed value (e.g., using a simple pseudo-random sequence generating function) that may be used on the next byte of file data.","The MD5 field  stores a hash value that may be used as a unique identifier for the data stored in the File simple object. By way of another non-limiting example, the MD5 field  may be used determine whether the data stored in the File simple object includes an error. The MD5 field  may be implemented as a blob (e.g., a blob of 16 bytes).","The name indicator  stores the name of the file. The name indicator  may be implemented as a string.","Returning to , subdirectories within the subdirectories of the root directory may be stored within one or more of the Directory complex objects stored within the collection  of Directory complex objects. In other words, the Directory complex objects used to configure the virtual filesystem  may be nested and used to configure a hierarchical directory structure.","Returning to , a third child object  is a collection of complex objects of type \u201cRegKey\u201d (\u201cRegKey complex objects). In the third child object , each of the child objects  is a RegKey complex object and has the RegKey complex format C illustrated in . As is apparent to those of ordinary skill in the art, key and key values are organized in the virtual registry  in a hierarchical structure have a root node storing keys at the base of the hierarchy. Sub-keys or sub-nodes are linked to the root node. The third child object  stores the keys used to configure the root node of the virtual registry . Each of the RegKey complex objects of the third child object  corresponds to a key. If the virtual application  is executed using more than one virtual layer, each virtual layer may configure a portion of the same root node of the virtual registry . Alternatively, two or more of the layers may configure different sub-nodes (or sub-keys) of the virtual registry .","Referring to , the RegKey complex format C includes a flags indicator  and a name indicator  in the header section . The flags indicator  may be substantially similar to the flags indicator  (see ). The flags indicator  indicates one or more values assigned to properties of the registry key in the virtual registry . By way of non-limiting examples, the flags indicator  may include bits indicating which of the following flags have been set to \u201cTRUE:\u201d isolated, merged, empty, read-only, and hidden. However, depending upon the implementation details, the flags indicator  may exclude the hidden flag. The flags indicator  may be implemented as a 32-bit integer.","The name indicator  indicates the name of the key to which the RegKey complex object corresponds. The name indicator  may be implemented as a string.","In the body section , each of the RegKey complex objects includes a collection  of simple objects of the type \u201cRegValue\u201d (see Table A above) and a collection  of RegKey complex objects.","Each of the RegValue simple objects of the collection  corresponds to a registry value stored in the sub-key to which its parent RegKey complex object corresponds. Each of the RegValue simple objects of the collection  corresponds to a key value.","Referring to , a RegValue simple object has a RegValue simple format B that includes a Name indicator , a NameTupleInfo indicator , a ValueType indicator , and a ValueData field . The Name indicator  may be implemented as a string. The NameTupleInfo indicator  may be implemented as an array of 16-bit integers. The ValueData field  may be implemented as a string, a 32-bit integer, a 64-bit integer, or a blob (e.g., a blob of 16 bytes). The ValueType indicator  indicates the type of the ValueData field  and may be implemented as a 16-bit integer.","Additional sub-keys within the sub-keys of the root node may be stored within one or more of the RegKey complex objects stored within the collection  of RegKey complex objects of . In other words, the RegKey complex objects used to configure the virtual registry  may be nested and used to configure a hierarchical registry key structure.","Returning to , a fourth child object  is a collection of simple objects of type \u201cService\u201d (\u201cService simple objects\u201d). Each of the Service simple objects stores configuration information for a virtual service (e.g., a virtual Windows service). For example, SQL Server is a Windows service. Thus, the Layer complex object may include a Service simple object for SQL Server.","A fifth child object  is a collection of simple objects of type \u201cEnvironmentVariable\u201d (\u201cEnvironmentVariable simple objects\u201d). Each of the EnvironmentVariable simple objects stores configuration information for a virtual environment variable (e.g., a virtual Windows environment variable). For example, \u201cPATH\u201d is an environment variable typically used by a Windows operating system. Thus, the Layer complex object may include an EnvironmentVariable simple objects for the \u201cPATH\u201d environment variable.","A sixth child object  is a collection of simple objects of type \u201cShortcutDir\u201d (\u201cShortcutDir complex objects\u201d). Each of the ShortcutDir complex objects stores configuration information for a virtual shortcut folder (e.g., a virtual Windows shortcut folder typically located in a start menu). Shortcut simple objects may be included as child objects  (see ) in a ShortcutDir complex object.","A seventh child object  is a collection of complex objects of type \u201cProgld\u201d (\u201cProgld complex objects\u201d). Each of the Progld complex objects stores a virtual program identifier (\u201cProgld\u201d), such as a virtual Windows Progld. An example of a virtual Windows Progld is Microsoft.Word.12. A Progld uniquely identifies an \u201capplication\u201d and is often used to associate an application with one or more file types and\/or actions provided by the application.","A eighth child object  is a collection of simple objects of type \u201cFont\u201d (\u201cFont simple objects\u201d). A font file is a special file that provides all information needed to render a particular font or style of print, such as Times New Roman. Each of the Font simple objects stores a font file. The Font simple object is substantially similar to the File simple object but includes an additional property needed to \u201cinitialize\u201d the font file at the startup of the virtual application.","A ninth child object  is a collection of simple objects of type \u201cSnapshotDirectory\u201d (\u201cSnapshotDirectory simple objects\u201d). Each of the SnapshotDirectory simple objects stores a path identifier and a folder identifier (such as an IdProgramFiles indicator). As is apparent to those of ordinary skill in the art, the authoring tool  (see ) may be used to create the virtualized application file  and\/or the xlayer file  on a first computing device. Then, these files may be executed a second different computing device. The path and folder identifiers are used to normalize any file path encountered at runtime that refers to a location on a computing device on which the virtual application  was configured (instead of a location on the second computing device). When such a path is encountered, it is replaced with a path on the second computing device using the path and folder identifiers of the SnapshotDirectory simple object.","Referring to , as explained above, each of the simple, complex, and collection formats , , and  includes the content type indicator , and the size indicator . The content type indicator  is used to identify which type of data is stored in the object. Using the content type indicator , the virtual runtime engine identifies which portions of the virtualized application file  and\/or the xlayer file  to expand and which portions to skip (or defer) for later expansion. In particular implementations, it may be beneficial to skip expansion of Directory complex objects and\/or RegKey complex objects.","The reader of the virtual runtime engine uses the size indicators  to skip one or more portions of data stored in the virtualized application file  and\/or the xlayer file . For example, some files (stored in File simple objects) and subdirectories (stored in Directory complex objects) of a Layer complex object, may be useful for desktop integration, but are not needed to execute the virtual application . During the virtual application startup routine, the reader may use the various size indicators  included in the simple, complex, and collection formats , , and  to skip over portions of the data useful for desktop integration.","Further, the size indicators  may be used to parse the portions of the virtualized application file  and\/or the xlayer file  used to configure the virtual filesystem  and\/or the virtual registry . For example, at initial startup, the Directory complex objects in the second child object  (i.e., the subdirectories) can be skipped, and offset placeholders stored for each Directory complex object that may be used later to expand skipped directories on demand. Further, the RegKey complex objects in the third child object  illustrated in  (i.e., the sub-keys) can be skipped, and offset placeholders stored for each RegKey complex object that may be used later to expand skipped sub-keys on demand. Only when the virtual application  actually needs to access the skipped subdirectories or sub-keys are those portions of the Layer complex object parsed. In this manner, expansion of nested subdirectories and sub-keys may be deferred at each level until the nested information is needed. This process may be characterized as a type of deferred recursion.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 11","FIG. 6","FIG. 6"],"b":["500","500","500","370","412","370","450"]},"In first block , the reader identifies a Layer complex object to read. In next block , the reader performs a method  described below to read or parse the Layer complex object identified in block . In decision block , the reader determines whether the Layer complex object identified in block  is the last Layer complex object to be read. If the Layer complex object is the last Layer complex object to be read, the decision in decision block  is \u201cYES.\u201d If the Layer complex object is not the last Layer complex object to be read, the decision in decision block  is \u201cNO.\u201d If the decision in decision block  is \u201cYES,\u201d the method  terminates. On the other hand, if the decision in decision block  is \u201cNO,\u201d in block , the reader identifies the next Layer complex object and returns to block .",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 12","b":["505","506","323","356","507","342","358"]},"In decision block , the reader determines whether the first child object is a collection having the collection format . If the first child object is a collection, the decision in decision block  is \u201cYES.\u201d If the first child object is not a collection, the decision in decision block  is \u201cNO.\u201d","If the decision in decision block  is \u201cNO,\u201d in decision block , the reader determines whether to read the first child object  or defer reading the first child object. A function named \u201cIsDeferredType\u201d may be used to determine whether the content type (e.g., \u201cDirectory\u201d) is to be deferred. If the function determines content of this type is to be deferred, the decision in decision block  is \u201cYES.\u201d If the function determines content of this type is to be read, the decision in decision block  is \u201cNO.\u201d","If the decision in decision block  is \u201cYES,\u201d in block , the reader determines the offset value and stores the offset value in an appropriate data structure so that the deferred portion may be expanded at a later time when needed. For example, if the deferred data is a Directory complex object (i.e., the data for configuring a subdirectory in the virtual filesystem ), the offset value may be stored in a subdirectory used as a placeholder in the virtual filesystem . The placeholder subdirectory may be empty except for the offset value and have the name indicated by the Name indicator  in the skipped Directory complex object. The offset value indicates where in the virtualized application file  or the xlayer file  the skipped data may be located when need. By way of another example, if the deferred data is a RegKey complex object (i.e., the data for configuring a sub-key in the virtual registry ), the offset value may be stored in a sub-key used as a placeholder in the virtual registry . The placeholder sub-key may be empty except for the offset value and have the name indicated by the Name indicator  in the skipped RegKey complex object. The offset value indicates where in the virtualized application file  or the xlayer file  the skipped data may be located when need.","In block , after storing the offset value, the reader advances in the data stream (e.g., the virtualized application file  or the xlayer file ) by the amount specified in the offset value.","When the virtual application  needs to access the data stored in a skipped subdirectory or a skipped sub-key, a method  (described below and illustrated in ) may be used.","Then, decision block  of  determines whether the current child object of the Layer complex object is the last child object. If the current child object is the last child object, the decision in decision block  is \u201cYES.\u201d If the current child object is not the last child object, the decision in decision block  is \u201cNO.\u201d","If the decision in decision block  is \u201cYES,\u201d the method  terminates. If the decision in decision block  is \u201cNO,\u201d in block , the reader reads the content type indicator  of the next child object of the Layer complex object and returns to decision block .","If the decision in decision block  is \u201cNO,\u201d in block , the reader reads the data in the child object and stores it in the appropriate data structure in the virtual runtime environment. For example, if the child object is a LayerCondition simple object (e.g., the first child object ), the environmental variable values are read from the EnvironmentVariable simple object and used to set the values of corresponding environmental variables in the virtual runtime environment. Then, the reader returns to decision block .","If the decision in decision block  is \u201cYES,\u201d in block , the reader performs a method  to read a collection of objects. Then, the reader advances to decision block .",{"@attributes":{"id":"p-0112","num":"0111"},"figref":"FIG. 13","b":["518","519","342","520","520","520"]},"If the decision in decision block  is \u201cYES,\u201d in block , the reader determines the offset value and stores the offset in an appropriate data structure so that the deferred portion may be expanded at a later time when needed. For example, if the deferred data is a Directory complex object (i.e., data for configuring a subdirectory in the virtual filesystem ), the offset value may be stored in a subdirectory used as a placeholder in the virtual filesystem . The placeholder subdirectory may be empty except for the offset value and have the name indicated by the Name indicator  in the skipped Directory complex object. The offset value indicates where in the virtualized application file  or the xlayer file  the skipped data may be located when need. By way of another example, if the deferred data is a RegKey complex object (i.e., data for configuring a sub-key in the virtual registry ), the offset value may be stored in a sub-key used as a placeholder in the virtual registry . The placeholder sub-key may be empty except for the offset value and have the name indicated by the Name indicator  in the skipped RegKey complex object. The offset value indicates where in the virtualized application file  or the xlayer file  the skipped data may be located when need.","When the virtual application  needs to access the data stored in a skipped subdirectory or a skipped sub-key, the method  (described below and illustrated in ) may be used.","Then, decision block  of  determines whether the current collection object of the collection is the last object in the collection. If the current object is the last object in the collection, the decision in decision block  is \u201cYES.\u201d If the current object is not the last object in the collection, the decision in decision block  is \u201cNO.\u201d","If the decision in decision block  is \u201cYES,\u201d the method  terminates. If the decision in decision block  is \u201cNO,\u201d in block , the reader reads the content type indicator  of the next object of the collection and returns to decision block .","If the decision in decision block  is \u201cNO,\u201d in block , the reader reads the data in the collection object and stores it in the appropriate data structure in the virtual runtime environment. For example, if the collection object is an EnvironmentVariable simple object, the environmental variable values are read from the EnvironmentVariable simple object and used to set the values of corresponding environmental variables in the virtual runtime environment. Then, the reader advances to decision block .","An exemplary implementation of the method  is provided in the following pseudocode. The pseudocode defines a function named \u201cExpandDeferredRegion.\u201d The \u201cExpandDeferredRegion\u201d function receives a single parameter, a structure named \u201cSChildDataForLayer\u201d having two members: an \u201cOwningLayer\u201d member and an \u201cOffset\u201d member may be used to store offset placeholders.",{"@attributes":{"id":"p-0119","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct SChildDataForLayer",{}]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003CComPtrConfigLayer","OwningLayer;"]},{"entry":[{},"\u2003\u2003ULONGLONG","Offset;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"As explained above, virtual applications can be implemented using more than one Layer complex object. The \u201cOwningLayer\u201d member identifies the particular Layer complex object being parsed. The \u201cOffset\u201d member identifies a start location of a collection of objects to be parsed. By way of a non-limiting example, the start location is the beginning of the size indicator  of a collection of objects.","In this example, the \u201cExpandDeferredRegion\u201d function reads binary data from the collection of objects, wherein the size indicator  is followed by the count indicator . The collection of objects may be the second child object  and\/or the third child object . Further, the collection of objects may be a Directory complex object nested inside the second child object  and\/or a RegKey complex object nested inside the third child object . In the pseudocode below, a BinaryReader class provided by .NET is used. The BinaryReader class provides a plurality of predefined read operations, such \u201cReadInt32,\u201d \u201cReadString,\u201d etc. The \u201cReadInt32\u201d function reads a four-byte signed integer from the current stream (i.e., the size indicator ) and advances the current position of the stream by four bytes.",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ExpandDeferredRegion(SChildDataForLayer data)"]},{"entry":[{},"\u2003childData.OwningLayer.SetCurrentPosition(data.Offset)"]},{"entry":[{},"\u2003BinaryReader reader(data.OwningLayer)"]},{"entry":[{},"\u2003collectionSize = reader.ReadInt32( )"]},{"entry":[{},"\u2003readEnd = data.Offset + collectionSize"]},{"entry":[{},"\u2003childCount = reader.ReadInt32( )"]},{"entry":[{},"\u2003For Each child 0 to childCount \u2212 1"]},{"entry":[{},"\u2003\u2003ReadChildHeaderInformation(reader)"]},{"entry":[{},"\u2003\u2003While reader.Position < readEnd"]},{"entry":[{},"\u2003\u2003\u2003type = reader.ReadInt32( )"]},{"entry":[{},"\u2003\u2003\u2003if (IsDeferredType(type))"]},{"entry":[{},"\u2003\u2003\u2003\u2003SChildDataForLayer childData"]},{"entry":[{},"\u2003\u2003\u2003\u2003currentPosition = reader.GetCurrentPosition( )"]},{"entry":[{},"\u2003\u2003\u2003\u2003skipSize = reader.ReadInt32( )"]},{"entry":[{},"\u2003\u2003\u2003\u2003childData.Offset = currentPosition"]},{"entry":[{},"\u2003\u2003\u2003\u2003childData.OwningLayer = data.OwningLayer"]},{"entry":[{},"\u2003\u2003\u2003\u2003StoreChildDataForDeferredExpansion(childData)"]},{"entry":[{},"\u2003\u2003\u2003\u2003reader.SetPosition(currentPosition + skipSize)"]},{"entry":[{},"\u2003\u2003\u2003Else"]},{"entry":[{},"\u2003\u2003\u2003\u2003ReadItemNormally(reader)"]},{"entry":[{},"\u2003\u2003\u2003End"]},{"entry":[{},"\u2003\u2003End"]},{"entry":[{},"\u2003End"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the pseudocode above, the reader reads the content type indicator  of each object of the collection (blocks  and ). The function named \u201cIsDeferredType\u201d determines whether data in a particular object in the collection is to be deferred based on the content type indicator  of the object (block ). The \u201cIsDeferredType\u201d function returns \u201cTRUE\u201d when data stored in a object is to be skipped (or deferred) and \u201cFALSE\u201d otherwise. If subdirectories and sub-keys are to be skipped, the \u201cIsDeferredType\u201d function returns \u201cTRUE\u201d when the content type indicator  of the object is \u201cDirectory\u201d or \u201cRegKey.\u201d In such an implementation, if the content type indicator  of the object is other than \u201cDirectory\u201d or \u201cRegKey,\u201d the \u201cIsDeferredType\u201d function returns \u201cFALSE.\u201d","When the \u201cIsDeferredType\u201d function returns \u201cTRUE,\u201d the \u201cExpandDeferredRegion\u201d function determines the current position of the reader in the object and stores the current position in a variable named \u201ccurrentPosition.\u201d Then, the \u201cExpandDeferredRegion\u201d function reads the size indicator  of the child object and stores it in a variable named \u201cskipSize.\u201d The value stored in \u201ccurrentPosition\u201d is stored in the \u201cOffset\u201d member of an instance of the SChildDataForLayer struct named \u201cchildData.\u201d A function named StoreChildDataForDeferredExpansion is called to store the value of the variable \u201ccurrentPosition\u201d (i.e., the value stored in the \u201cOffset\u201d member of the structure named \u201cchildData\u201d) in the data-structure being populated (e.g., a virtual directory or virtual registry key node) (block ). Then, the \u201cExpandDeferredRegion\u201d function sets the reader position to the end of the deferred child object (i.e., the location at a sum of the value of the variable named \u201ccurrentPosition\u201d and the value of the variable named \u201cskipSize\u201d). Thus, the data-structure being populated has the starting position from which to start reading when the skipped portion needs to be expanded.","When the \u201cIsDeferredType\u201d function returns \u201cFALSE,\u201d a function named \u201cReadItemNormally\u201d reads or expands the child object (block ).","With this deferred expansion of the data used to configure and populate the virtual filesystem  and the virtual registry , only those portions of the virtual filesystem and virtual registry actually accessed by the virtual application  need to be expanded, which may save a significant amount of time spent parsing the Layer complex object.",{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 14","b":["540","140","300","542","110","140","300","110","150","152","110","150"]},"In next block , the skipped portion of the virtualized application file  or the xlayer file  is identified. The skipped portion is stored within an object having either the simple format  (see ) or the complex format  (see ). Therefore, in block , the reader identifies a single object having either the simple format  or the complex format  stored inside a Layer complex object. However, the particular data requested may be stored within one or more objects nested inside the object identified. Therefore, to locate the requested data, the reader may have to parse several layers of nested objects.","When the virtual runtime engine encounters a skipped directory (e.g., the subdirectory named \u201cprogram\u201d), in block , the reader identifies the corresponding object by reading the information identifying the Layer complex object and the offset value stored in the skipped subdirectory in the virtual filesystem . The data structure named \u201cSChildDataForLayer\u201d may be used to store the start location of the skipped portion and to identify the Layer complex object in which the skipped portion resides.","Then, in decision block , the reader determines whether the skipped object is a complex object. The decision in decision block  is \u201cYES\u201d when the skipped object is a complex object. The decision in decision block  is \u201cNo\u201d when the skipped object is a simple object.","If the decision in decision block  is \u201cNO,\u201d in block , the reader reads the data in the simple object and then the method  terminates. On the other hand, if the decision in decision block  is \u201cYES,\u201d in block , the reader performs the method  of  to expand the complex object.","In decision block , the reader determines whether the requested data has been expanded. For example, at this point, the directory named \u201cprogram\u201d may have been expanded using the method . However, the subdirectories stored in the collection of directories associated with the Directory complex object corresponding to the directory named \u201cprogram\u201d would have been skipped when the method  of  was performed to expand the collection of Directory complex objects. Therefore, at this point, the requested data has not yet been expanded.","The decision in the decision block  is \u201cYES\u201d when the requested data has been expanded. On the other hand, the decision block  is \u201cNO\u201d when the requested data has not been expanded. If the decision in the decision block  is \u201cYES,\u201d the method  terminates. If the decision in the decision block  is \u201cNO,\u201d in block , the reader identifies a next object in a path to the requested data (e.g., the Directory complex object corresponding to the directory named \u201cfirst\u201d) and returns to the decision block .","Because each object incorporated in the file format  (see ) indicates its own size (via the size indicators ) and child objects are self-describing via the content type indicator , the code that implements the reader of the virtual runtime engine can be made tolerant of unfamiliar simple and complex object types. This allows older virtual machine runtimes to be made compatible with newer virtualized application files and\/or xlayer files, provided their major version identifiers are the same. Likewise, the code implementing the virtual runtime reader can be made tolerant of reading older virtualized application files and\/or xlayer files, in which certain simple and complex object types may not be found or in which the format of one or more the simple and\/or complex object types has changed.","Forward and backward compatibility may be provided at least in part by a SizeReader class that may used to read data from the Layer complex object. The SizeReader class may be derived from the BinaryReader class provided by the .NET framework offered by Microsoft Corporation. However, the SizeReader class differs from the BinaryReader class in that the SizeReader class knows how much data is stored in the object. If the reader tries to read past the end of the object, a default value is returned. Furthermore, when reading is finished, the underlying stream is taken to the end of the current object, even if all of the data has not yet been read. In other words, the reader jumps to the end of the object being read. If new data items are added after those of previously included in the format, when the reader jumps to the end of the object being read, the reader ignores the new data items with which the reader is unfamiliar.","As a derived class, the SizeReader class supports operations provided by the BinaryReader class such as ReadInt32, ReadString, etc. However, several functions may be modified or overridden. A portion of a basic class specification for the SizeReader class is provided below:",{"@attributes":{"id":"p-0137","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal class SizeReader : BinaryReader"]},{"entry":[{},"{"]},{"entry":[{},"\u2003BinaryReader _reader;"]},{"entry":[{},"\u2003long _lEndPosition;"]},{"entry":[{},"\u2003long _lInitialPosition;"]},{"entry":[{},"\u2003\/\/\/ <summary>"]},{"entry":[{},"\u2003\/\/\/ Main constructor"]},{"entry":[{},"\u2003\/\/\/ <\/summary>"]},{"entry":[{},"\u2003\/\/\/ <param name=\u201creader\u201d><\/param>"]},{"entry":[{},"\u2003\/\/\/ <param name=\u201cfAtSizeValue\u201d><\/param>"]},{"entry":[{},"\u2003public SizeReader (BinaryReader reader)"]},{"entry":[{},"\u2003\u2003\u2003\u2002: base (reader.BaseStream)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\u2003_reader = reader;"]},{"entry":[{},"\u2003\u2003\u2003_lEndPosition = long.MaxValue;"]},{"entry":[{},"\u2003\u2003\u2003_lInitialPosition = reader.BaseStream.Position;"]},{"entry":[{},"\u2003\u2003\u2003OnSizeValue ( );"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\/\/\/ <summary>"]},{"entry":[{},"\u2003\/\/\/ When defering the reading of size value"]},{"entry":[{},"\u2003\/\/\/ <\/summary>"]},{"entry":[{},"\u2003public void OnSizeValue ( )"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\u2003int cbSize = _reader.ReadInt32 ( );"]},{"entry":[{},"\u2003\u2003\u2003_lEndPosition = _lInitialPosition + cbSize;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\/\/\/ <summary>"]},{"entry":[{},"\u2003\/\/\/ Indictes if we've hit the end of the structure"]},{"entry":[{},"\u2003\/\/\/ <\/summary>"]},{"entry":[{},"\u2003\/\/\/ <returns><\/returns>"]},{"entry":[{},"\u2003public bool CanRead"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\u2003get"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return _reader.BaseStream.Position <"]},{"entry":[{},"_lEndPosition;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\/\/\/ <summary>"]},{"entry":[{},"\u2003\/\/\/ Called when done reading data"]},{"entry":[{},"\u2003\/\/\/ <\/summary>"]},{"entry":[{},"\u2003public void DoneReading ( )"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\u2003if (_lEndPosition != long.MaxValue)"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003_reader.BaseStream.Position = _lEndPosition;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003_lEndPosition = long.MaxValue;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Binary Reader overrides"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\u2003protected override void Dispose (bool disposing)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (disposing)"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003DoneReading ( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003public override byte[ ] ReadBytes (int count)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (CanRead)"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return _reader.ReadBytes (count);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return new byte[0];"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003public override int ReadInt32 ( )"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\u2003if (CanRead)"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return _reader.ReadInt32 ( );"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return 0;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003public override string ReadString ( )"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\u2003if (CanRead)"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return _reader.ReadString ( );"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return string.Empty;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For the sake of brevity, most of the BinaryReader methods have been omitted from the basic class specification provided above. However, three of the overridden functions, \u201cReadBytes,\u201d \u201cReadInt32,\u201d and \u201cReadString,\u201d have been provided as examples. As mentioned above, each of these functions has been modified to return a default value. The constructor to this class uses a function named \u201cOnSizeValue\u201d to determine an amount of data stored in an object. The amount of data stored in an object informs the reader as to how much data there is to be read in the child objects. A function named \u201cDispose\u201d is called when reading with respect to a particular object is finished. If the Boolean type variable named \u201cdisposing\u201d is \u201cTRUE,\u201d the \u201cDispose\u201d function calls a function named \u201cDoneReading,\u201d which sets the underlying stream to the end of the object.","An example of how the simple and complex formats  and  provide forward and backward compatibility will now be described.  illustrates a simple object  configured for a version \u201c1.0\u201d of the virtual runtime engine. Thus, the xlayer file  or the virtualized application file  in which the simple object  is stored has a format version \u201c1.0\u201d (i.e., the major version identifier  has a value of \u201c1\u201d and the minor version identifier  has a value of \u201c0\u201d). The content type indicator  identifies the simple object  as having type \u201cRegValue.\u201d As explained above, a RegValue simple object may be used to store a register key value. The simple object  has a format B-V1.0, which is identical to format B illustrated in . Thus, the simple object  includes the content type indicator , the size indicator , and four simple data items: the Name indicator  (e.g., a string), the NameTupleInfo indicator  (e.g., a 32-bit integer), the ValueType indicator  (e.g., a number of bytes or block of binary data), and the ValueData field .",{"@attributes":{"id":"p-0140","num":"0139"},"figref":["FIG. 16","FIG. 15"],"b":["592","590","592","326","327","590","592","326","342","592","336","590","592","336","336","342","323","472","474","476","478","336","596"]},"The dashed lines \u201cL\u201d and \u201cL\u201d above and below the RegValue simple objects  and  depicted in , respectively, indicate that the simple objects  and  may be located within the binary data of the Layer complex object (i.e., within the data stream read from the Layer complex object).","The following pseudocode demonstrates how the reader of the virtual runtime engine version 1.0 might read the simple object  illustrated in  configured for a version 1.1 of the virtual runtime engine.",{"@attributes":{"id":"p-0143","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ReadRegValueV10(BinaryReader reader)"]},{"entry":[{},"SizeReader sizeReader(reader)"]},{"entry":[{},"name = sizeReader.ReadString( )"]},{"entry":[{},"regType = sizeReader.ReadInt32( )"]},{"entry":[{},"regData = sizeReader.ReadBytes( )"]},{"entry":[{},"sizeReader.Dispose( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The last line in the pseudocode above jumps to the end of simple object  without having had read all of the simple data items. In other words, the \u201cDispose\u201d function skips the isolation indicator , with which the reader of the virtual runtime engine version 1.0 is unfamiliar.","The following pseudocode demonstrates how the virtual runtime engine version 1.1 might read the simple object  illustrated in  configured for a version 1.0 of the virtual runtime engine.",{"@attributes":{"id":"p-0146","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ReadRegValueV11(BinaryReader reader)"]},{"entry":[{},"SizeReader sizeReader(reader)"]},{"entry":[{},"name = sizeReader.ReadString( )"]},{"entry":[{},"regType = sizeReader.ReadInt32( )"]},{"entry":[{},"regData = sizeReader.ReadBytes( )"]},{"entry":[{},"isolation = sizeReader.ReadInt32( )"]},{"entry":[{},"sizeReader.Dispose( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the pseudocode above, the reader attempts to read the isolation indicator  that is not in 1.0 version of the RegValue simple object (i.e., simple object ). Thus, the reader may be described as having read past the end of the simple object . As discussed above, the reader knows the size of the simple object  and can determine the reader has read past the end of the simple object . When this occurs, a default value (e.g., a 32-bit integer value of zero) may be returned. Again, in the last line of the pseudocode above, the \u201cDispose\u201d function is called after all known data items have been read.","In both cases, the reading of the RegValue simple objects  and  proceeds without a problem. When a new data member is added to the simple or complex format for a particular content type, it is desirable to ensure that the SizeReader class is configured to provide a default value for the new data member that has the correct semantics for older versions of the object format. For example, when the reader for the virtual runtime engine version 1.1 reads the simple object  and obtains the default value (e.g., 32-bit integer value of zero) provided for the isolation indicator , the virtual runtime engine version 1.1 should respond in a manner substantially similar to the manner in which the reader for the virtual runtime engine version 1.0 reads would respond when reading the simple object .",{"@attributes":{"id":"p-0149","num":"0148"},"figref":["FIG. 17","FIG. 17"],"b":["140","300","170"]},"Moreover, those skilled in the art will appreciate that implementations may be practiced with other computer system configurations, including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. Implementations may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","The exemplary hardware and operating environment of  includes a general-purpose computing device in the form of a computing device . Each of the virtual application file , the xlayer file , the authoring tool , and\/or virtual runtime engine may be implemented using one or more computing devices like the computing device . By way of non-limiting example, the virtual application file , the xlayer file , the authoring tool , and\/or virtual runtime engine may be implemented on the computing device .","The computing device  includes the system memory , a processing unit , and a system bus  that operatively couples various system components, including the system memory , to the processing unit . There may be only one or there may be more than one processing unit , such that the processor of computing device  comprises a single central-processing unit (CPU), or a plurality of processing units, commonly referred to as a parallel processing environment. The computing device  may be a conventional computer, a distributed computer, or any other type of computer.","The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory may also be referred to as simply the memory, and includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the computing device , such as during start-up, is stored in ROM . The computing device  further includes a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM, DVD, or other optical media.","The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical disk drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer-readable instructions, data structures, program modules and other data for the computing device . It should be appreciated by those skilled in the art that any type of computer-readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, USB drives, digital video disks, Bernoulli cartridges, random access memories (RAMs), read only memories (ROMs), and the like, may be used in the exemplary operating environment. As is apparent to those of ordinary skill in the art, the hard disk drive  and other forms of computer-readable media (e.g., the removable magnetic disk , the removable optical disk , flash memory cards, USB drives, and the like) accessible by the processing unit  may be considered components of the system memory .","A number of program modules may be stored on the hard disk drive , magnetic disk , optical disk , ROM , or RAM , including an operating system , one or more application programs , other program modules , and program data . A user may enter commands and information into the computing device  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus , but may be connected by other interfaces, such as a parallel port, game port, or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, computers typically include other peripheral output devices (not shown), such as speakers and printers.","The computing device  may operate in a networked environment using logical connections to one or more remote computers, such as remote computer . These logical connections are achieved by a communication device coupled to or a part of the computing device  (as the local computer). Implementations are not limited to a particular type of communications device. The remote computer  may be another computer, a server, a router, a network PC, a client, a memory storage device, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computing device . The remote computer  may be connected to a memory storage device . The logical connections depicted in  include a local-area network (LAN)  and a wide-area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN-networking environment, the computing device  is connected to the local area network  through a network interface or adapter , which is one type of communications device. When used in a WAN-networking environment, the computing device  typically includes a modem , a type of communications device, or any other type of communications device for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computing device , or portions thereof, may be stored in the remote computer  and\/or the remote memory storage device . It is appreciated that the network connections shown are exemplary and other means of and communications devices for establishing a communications link between the computers may be used.","The computing device  and related components have been presented herein by way of particular example and also by abstraction in order to facilitate a high-level view of the concepts disclosed. The actual technical design and implementation may vary based on particular implementation while maintaining the overall nature of the concepts disclosed.","Returning to , the host operating system , the virtual application file , the xlayer file , the authoring tool , and\/or virtual runtime engine may be stored as computer executable components on the system memory . Each of the host operating system , the virtual application file , the xlayer file , the authoring tool , and\/or virtual runtime engine may be implemented using software components that are executable by the processing unit  and when executed perform the functions described above.","The foregoing described embodiments depict different components contained within, or connected with, different other components. It is to be understood that such depicted architectures are merely exemplary, and that in fact many other architectures can be implemented which achieve the same functionality. In a conceptual sense, any arrangement of components to achieve the same functionality is effectively \u201cassociated\u201d such that the desired functionality is achieved. Hence, any two components herein combined to achieve a particular functionality can be seen as \u201cassociated with\u201d each other such that the desired functionality is achieved, irrespective of architectures or intermedial components. Likewise, any two components so associated can also be viewed as being \u201coperably connected,\u201d or \u201coperably coupled,\u201d to each other to achieve the desired functionality.","While particular embodiments of the present invention have been shown and described, it will be obvious to those skilled in the art that, based upon the teachings herein, changes and modifications may be made without departing from this invention and its broader aspects and, therefore, the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore, it is to be understood that the invention is solely defined by the appended claims. It will be understood by those within the art that, in general, terms used herein, and especially in the appended claims (e.g., bodies of the appended claims) are generally intended as \u201copen\u201d terms (e.g., the term \u201cincluding\u201d should be interpreted as \u201cincluding but not limited to,\u201d the term \u201chaving\u201d should be interpreted as \u201chaving at least,\u201d the term \u201cincludes\u201d should be interpreted as \u201cincludes but is not limited to,\u201d etc.). It will be further understood by those within the art that if a specific number of an introduced claim recitation is intended, such an intent will be explicitly recited in the claim, and in the absence of such recitation no such intent is present. For example, as an aid to understanding, the following appended claims may contain usage of the introductory phrases \u201cat least one\u201d and \u201cone or more\u201d to introduce claim recitations. However, the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles \u201ca\u201d or \u201can\u201d limits any particular claim containing such introduced claim recitation to inventions containing only one such recitation, even when the same claim includes the introductory phrases \u201cone or more\u201d or \u201cat least one\u201d and indefinite articles such as \u201ca\u201d or \u201can\u201d (e.g., \u201ca\u201d and\/or \u201can\u201d should typically be interpreted to mean \u201cat least one\u201d or \u201cone or more\u201d); the same holds true for the use of definite articles used to introduce claim recitations. In addition, even if a specific number of an introduced claim recitation is explicitly recited, those skilled in the art will recognize that such recitation should typically be interpreted to mean at least the recited number (e.g., the bare recitation of \u201ctwo recitations,\u201d without other modifiers, typically means at least two recitations, or two or more recitations).","Accordingly, the invention is not limited except as by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING(S)","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 11","FIG. 6"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 12","FIG. 4"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 14","FIG. 12","FIG. 13"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 17","FIG. 1"]}]},"DETDESC":[{},{}]}
