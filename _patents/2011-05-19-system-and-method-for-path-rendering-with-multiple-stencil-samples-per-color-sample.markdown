---
title: System and method for path rendering with multiple stencil samples per color sample
abstract: One embodiment of the present invention sets forth a technique for improving path rendering on computer systems by efficiently representing and computing sub-pixel coverage for path objects. A stencil buffer is configured to store multiple stencil samples per pixel stored in an image buffer. The stencil samples undergo stencil testing to produce a set of Boolean values per pixel, which collectively define a geometric coverage percentage for the pixel. The coverage percentage is used to modulate a color value for the pixel. The modulated color value is then blended into the image buffer as an anti-aliased pixel. This technique advantageously enables efficient anti-aliasing for path rendering.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08704830&OS=08704830&RS=08704830
owner: Nvidia Corporation
number: 08704830
owner_city: Santa Clara
owner_country: US
publication_date: 20110519
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","System Overview","Processing Cluster Array Overview","Decomposing Path Objects","Baking Path Objects","Multi-Stencil Pixel Coverage"],"p":["This application claims priority benefit to U.S. provisional patent application titled, \u201cPath Rendering,\u201d filed on May 21, 2010 and having Ser. No. 61\/347,359. This related application is also hereby incorporated by reference in its entirety.","1. Field of the Invention","The present invention generally relates to graphics processing and more specifically to a system and method for path rendering with multiple stencil samples per color sample.","2. Description of the Related Art","Path rendering is a style of resolution-independent two-dimensional (2D) rendering that is the basis for a number of important rendering standards such as PostScript, Java 2D, Apple's Quartz 2D, OpenVG, PDF, TrueType fonts, OpenType fonts, PostScript fonts, Scalable Vector Graphics (SVG) web format, Microsoft's Silverlight and Adobe Flash for interactive web experiences, Open XML Paper Specification (OpenXPS), drawings in Office file formats including PowerPoint, Adobe Illustrator illustrations, and more.","In the context of path rendering, the term resolution-independent means that an image is described by paths without regard to the pixel resolution of a resulting rendered image or associated frame buffer. This is in contrast to the resolution-dependent nature of bitmapped graphics, which is tied to a particular 2D image resolution. Unlike images specified by using bitmapped graphics, images specified with path rendering can be rendered at arbitrary resolutions or arbitrarily transformed without blurring or pixilation typically associated with such operations when performed on a bitmapped image.","Sometimes the term vector graphics is used to mean path rendering, but path rendering refers to a specific approach for rendering an image. While vector graphics could be any computer graphics approach that represents resolution-independent objects (typically 2D), path rendering is a much more specific rendering model with salient features that include path filling, path stroking, dashing, path masking, compositing, and path segments specified as B\u00e8zier curves.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 1C","FIG. 1A"]},"Filling is similar to the way a child would \u201ccolor in between the lines\u201d of a coloring book. If a sub-path within a path is not closed when such a sub-path is filled, the standard practice is to force the sub-path closed by connecting its end and start points with an implicit line segment, thereby closing the sub-path, and then filling that resulting closed path. While the meaning of \u201cinside a path\u201d generally matches the intuitive meaning of this phrase, path rendering formalizes this notion with what is called a fill-rule. The intuitive sense of \u201cinside\u201d is sufficient as long as a closed sub-path does not self-intersect itself. However if a sub-path intersects itself or another sub-path or some sub-paths are fully contained within other sub-paths, what it means to be inside or outside the path needs to be better specified.","Stroking is distinct from filling and is analogous to tracing or outlining each sub-path comprising a path as if with a pen or marker defined by a certain width. Stroking operates on the perimeter or boundary defined by the path whereas filling operates on the path's interior. Unlike filling, there is no requirement for the sub-paths within a path to be closed for stroking. For example, the curve of a letter \u201cS\u201d could be stroked without having to be closed though the curve of the letter \u201cO\u201d could also be stroked.","A stroke for a path may be embellished using dashing that interrupts the stroke with gaps that are specified by a repeated pattern of on-off lengths, called a dash pattern. The dash pattern for a particular path may begin at an initial offset into the dash pattern other than zero; this offset is known as the dash offset. The dash offset essentially shifts the dash pattern up or down (if negative) the path. Each end of a dash may be specified by a certain form of cap, such as a flat or round cap. Dashing is common in technical illustration. Dashing is helpful in distinguishing different types of lines or connections. Artists also make use of dashing to accomplish various artistic effects.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 1D","FIG. 1B"]},"Dashing curved paths is challenging because it requires the computation of incremental arc lengths along a dashed path. Computing the length of a cubic B\u00e8zier segment or partial elliptical arc lacks a tractable closed form solution and is therefore extremely difficult. Closed form analytic equations for the arc lengths of cubic B\u00e8zier segments and arcs limited to elementary functions do not exist.","Graphics processing units (GPUs) conventionally include features to accelerate three-dimensional (3D) graphics and certain 2D bitmapped graphics functions. GPUs provide extremely high-throughput processing for certain classes of computations compared to a traditional central processing unit (CPU). In today's systems, however, nearly all path rendering is performed by the CPU via scan-line rendering with no acceleration by a GPU. GPUs do not conventionally render curved primitives as a native rendering operation, so path rendering primitives such as B\u00e8zier segments and partial elliptical arcs must be approximated by lots of tiny triangles for a GPU to render such curve primitives. Constructing the required tessellations of a path that is approximated by many short connected line segments. This process can create a substantial CPU burden. The triangles or other polygons resulting from tessellation are then rendered by the GPU. Because GPUs are so fast at rasterizing triangles, tessellating paths into polygons that can then be rendered by GPUs is an obvious approach to GPU-accelerating path rendering.","Tessellation is a fragile, often quite sequential, process that requires global inspection of the entire path. Tessellation depends on dynamic data structures to sort, search, and otherwise manipulate the incremental steps involved in generating a tessellation for a path. Path rendering makes this process considerably more difficult by permitting curved path segments as well as allowing path segments to self-intersect, form high genus topologies, and be unbounded in size. Performance burdens associated with complex CPU-based tessellation for GPU-based rendering can result in poor overall performance.","A general problem with using a GPU to render paths is unacceptably poor antialiasing quality when compared to standard CPU-based methods. The problem is that GPUs employ point sampling for rasterization of triangular primitives with only 1 to 8 samples (often 4) per pixel. CPU-based scan-line methods typically employ 16 or more samples per pixel and can accumulate coverage over horizontal spans for higher-quality antialiasing. Adding more samples per pixel based on conventional surface allocation techniques is not a scalable approach for GPU-based path rendering. Each additional sample typically incurs a cost of an additional eight bytes, with four of the eight bytes allocated to describe an additional sample color and four of the eight bytes allocated as a combined stencil and depth buffer to describe an additional stencil value. The combined stencil and depth buffer is typically structured to include a one byte stencil value and a three byte depth value. Additional color samples can have high secondary cost associated with memory bandwidth, processing burden, and power consumption for clearing, shading, blending, and down-sampling the additional color samples for display. Furthermore, path shading typically does not utilize a depth test, meaning each three-byte depth value goes unused. Therefore, conventionally adding more samples per pixel introduces a disproportionate memory bandwidth, memory utilization, and processing burden relative to potentially achieve quality benefits.","Animating or editing paths is costly because it requires re-tessellating the entire path since the tessellation is resolution and view dependent, and in general it is very difficult to prove a local edit to a path will not cause a global change in the tessellation of the path. Furthermore, when curved path segments are present and the scaling of the path with respect to pixel space changes appreciably (zooming in say), the curved path segments may need to be re-subdivided and re-tessellation is likely to be necessary.","Additionally, compositing in path rendering systems typically requires that pixels rasterized by a filled or stroked path are updated once-and-only-once per rasterization of the path. This requirement means non-overlapping tessellations are required. So for example, a cross cannot be tessellated as two overlapping rectangles but rather must be rendered by the outline of the cross, introducing additional vertices and primitives. In particular, this means the sub-paths of a path cannot be processed separately without first determining that no two sub-paths overlap. These requirements, combined with the generally fragile and sequential nature of tessellation algorithms make path tessellation particularly expensive. Because of the expense required in generating tessellations, it is very tempting and pragmatic to cache tessellations. Unfortunately such tessellations are much less compact than the original path representations, particularly when curved path segments are involved. Consequently, a greater amount of data must be stored to cache paths after tessellation compared with storing the paths prior to tessellation. Cached tessellations are also ineffective when paths are animated or rendered just once.","Conventional stroking can be performed by approximating paths into sub-pixel linear segments and then tracing the segments with a circle having a diameter equal to a stroke width. Offset curves are generated at the boundary of the stroked path. These offset curves are typically of much higher degree of complexity compared with the linear segments that are traced to generate the stroked path. Determining whether or not each pixel is inside or outside of a stroked path to generate a given stroke is mathematically complex. Identification of the pixels to be stroked is equivalent to identifying pixels that are within half of the stroke width of any point along the path to be stroked. More specifically, the pixels to be stroked are within half of the stroke width measured along a line that is perpendicular to the tangent of the path segment being stroked.","The tangent of a sub-path is not necessarily well-defined at junctions between path segments. So additional rules are needed to determine what happens at and in the vicinity of such junctions as well as what happens at the terminal (start and end) points of sub-paths. Therefore stroking specifies further stroking rules to handle these situations.","In standard path rendering systems, paths are specified as a sequence of cubic and quadratic (non-rational) B\u00e8zier curve segments, partial elliptical arcs, and line segments. While more mathematically complex path segments representations could be used to specify paths, in practice, existing standards limit themselves to the aforementioned path segment types.","Path filling and stroking use the same underlying path specification. For filling, this means the resulting piece-wise boundaries to be filled may be up to third-order (in the case of cubic B\u00e8zier segments) or rational second-order (in the case of partial elliptical arcs). Filling these curved boundaries of B\u00e8zier curves and arcs is clearly more complex than filling the standard polygonal primitives in conventional polygonal 2D or 3D rendering where the boundaries (edges) of the polygonal primitives (usually triangles) are all first-order, being linear segments, and often required to be convex. Filling and stroking operations on the curves and arcs are also more complex than conventional line and convex polygon rasterization because paths are unbounded in their complexity whereas line segments and triangles are defined by just 2 or 3 points respectively. A path may contain just a single path segment or it could contain thousands or more.","The boundaries of stroked paths are actually substantially higher order than the third-order segments. The offset curve of non-rational (second-order) quadratic and (third-order) B\u00e8zier curves are eighth- and tenth-order curves respectively. This high order makes exact determination and evaluation of the resulting offset curves for such B\u00e8zier segments intractable for use in direct rendering. In other words, it is quite unreasonable to try to determine exactly the boundary representation of such offset curves and then simply fill them. For this reason, various techniques have been developed to approximate offset curves with sequences of B\u00e8zier, arc, or line segments. These approximate stroke boundaries may then be filled using significantly less complex techniques.","GPU acceleration can provide a significant performance improvement for certain graphics applications, such as 3D rendering and 2D image processing. However, for the reasons described above, path rendering in the prior art does not benefit as significantly from GPU involvement. Accordingly, what is needed in the art is an improved system and method for path rendering with a GPU. In particular, the system and method should improve path rendering quality without disproportionately burdening memory bandwidth or utilization.","One embodiment of the present invention sets forth a method for rendering an image sample associated with a geometric primitive. The method includes selecting the image sample for rendering based on the image sample being at least partially covered by the geometric primitive, and performing a stencil test on each stencil sample covered by the geometric primitive included in a plurality of stencil samples associated with the image sample to generate a set of stencil test results, where each stencil test result comprises a Boolean value of either pass or fail. Based on the set of stencil test results, a coverage percentage that indicates how much of the image sample is covered by the geometric primitive object is then computed. The method also includes computing a color value based on a color shading operation associated with the geometric primitive, and computing a modulated color value for the image sample based on the color value and the coverage percentage.","One advantage of the disclosed technique is that a computer system implementing the technique better utilizes available computational resources in a GPU to achieve higher overall path rendering performance. Specifically, the technique enables high-quality, anti-aliased path object rendering within the GPU.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the present invention. However, it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the present invention.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 2A","FIG. 2A"],"b":["100","100","102","104","105","105","106","107","107","108","102","106","105","112","105","113","112","110","114","107","116","107","118","120","121","107"]},"In one embodiment, the parallel processing subsystem  incorporates circuitry optimized for graphics and video processing, including, for example, video output circuitry, and constitutes a graphics processing unit (GPU). In another embodiment, the parallel processing subsystem  incorporates circuitry optimized for general purpose processing, while preserving the underlying computational architecture, described in greater detail herein. In yet another embodiment, the parallel processing subsystem  may be integrated with one or more other system elements, such as the memory bridge , CPU , and I\/O bridge  to form a system on chip (SoC).","It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology, including the number and arrangement of bridges, the number of CPUs , and the number of parallel processing subsystems , may be modified as desired. For instance, in some embodiments, system memory  is connected to CPU  directly rather than through a bridge, and other devices communicate with system memory  via memory bridge  and CPU . In other alternative topologies, parallel processing subsystem  is connected to I\/O bridge  or directly to CPU , rather than to memory bridge . In still other embodiments, I\/O bridge  and memory bridge  might be integrated into a single chip. Large embodiments may include two or more CPUs  and two or more parallel processing systems . The particular components shown herein are optional; for instance, any number of add-in cards or peripheral devices might be supported. In some embodiments, switch  is eliminated, and network adapter  and add-in cards ,  connect directly to I\/O bridge .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 2B","b":["112","112","202","204","202","204"]},"Referring again to , in some embodiments, some or all of PPUs  in parallel processing subsystem  are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU  and\/or system memory  via memory bridge  and communications path , interacting with local parallel processing memory  (which can be used as graphics memory including, e.g., a conventional frame buffer) to store and update pixel data, delivering pixel data to display device , and the like. In some embodiments, parallel processing subsystem  may include one or more PPUs  that operate as graphics processors and one or more other PPUs  that are used for general-purpose computations. The PPUs may be identical or different, and each PPU may have its own dedicated parallel processing memory device(s) or no dedicated parallel processing memory device(s). One or more PPUs  may output data to display device  or each PPU  may output data to one or more display devices .","In operation, CPU  is the master processor of computer system , controlling and coordinating operations of other system components. In particular, CPU  issues commands that control the operation of PPUs . In some embodiments, CPU  writes a stream of commands for each PPU  to a pushbuffer (not explicitly shown in either  or ) that may be located in system memory , parallel processing memory , or another storage location accessible to both CPU  and PPU . PPU  reads the command stream from the pushbuffer and then executes commands asynchronously relative to the operation of CPU .","Referring back now to , each PPU  includes an I\/O (input\/output) unit  that communicates with the rest of computer system  via communication path , which connects to memory bridge  (or, in one alternative embodiment, directly to CPU ). The connection of PPU  to the rest of computer system  may also be varied. In some embodiments, parallel processing subsystem  is implemented as an add-in card that can be inserted into an expansion slot of computer system . In other embodiments, a PPU  can be integrated on a single chip with a bus bridge, such as memory bridge  or I\/O bridge . In still other embodiments, some or all elements of PPU  may be integrated on a single chip with CPU .","In one embodiment, communication path  is a PCI-EXPRESS link, in which dedicated lanes are allocated to each PPU , as is known in the art. Other communication paths may also be used. An I\/O unit  generates packets (or other signals) for transmission on communication path  and also receives all incoming packets (or other signals) from communication path , directing the incoming packets to appropriate components of PPU . For example, commands related to processing tasks may be directed to a host interface , while commands related to memory operations (e.g., reading from or writing to parallel processing memory ) may be directed to a memory crossbar unit . Host interface  reads each pushbuffer and outputs the work specified by the pushbuffer to a front end .","Each PPU  advantageously implements a highly parallel processing architecture. As shown in detail, PPU () includes a processing cluster array  that includes a number C of general processing clusters (GPCs) , where C\u22671. Each GPC  is capable of executing a large number (e.g., hundreds or thousands) of threads concurrently, where each thread is an instance of a program. In various applications, different GPCs  may be allocated for processing different types of programs or for performing different types of computations. For example, in a graphics application, a first set of GPCs  may be allocated to perform patch tessellation operations and to produce primitive topologies for patches, and a second set of GPCs  may be allocated to perform tessellation shading to evaluate patch parameters for the primitive topologies and to determine vertex positions and other per-vertex attributes. The allocation of GPCs  may vary dependent on the workload arising for each type of program or computation.","GPCs  receive processing tasks to be executed via a work distribution unit , which receives commands defining processing tasks from front end unit . Processing tasks include indices of data to be processed, e.g., surface (patch) data, primitive data, vertex data, and\/or pixel data, as well as state parameters and commands defining how the data is to be processed (e.g., what program is to be executed). Work distribution unit  may be configured to fetch the indices corresponding to the tasks, or work distribution unit  may receive the indices from front end . Front end  ensures that GPCs  are configured to a valid state before the processing specified by the pushbuffers is initiated.","When PPU  is used for graphics processing, for example, the processing workload for each patch is divided into approximately equal sized tasks to enable distribution of the tessellation processing to multiple GPCs . A work distribution unit  may be configured to produce tasks at a frequency capable of providing tasks to multiple GPCs  for processing. By contrast, in conventional systems, processing is typically performed by a single processing engine, while the other processing engines remain idle, waiting for the single processing engine to complete its tasks before beginning their processing tasks. In some embodiments of the present invention, portions of GPCs  are configured to perform different types of processing. For example a first portion may be configured to perform vertex shading and topology generation, a second portion may be configured to perform tessellation and geometry shading, and a third portion may be configured to perform pixel shading in screen space to produce a rendered image. Intermediate data produced by GPCs  may be stored in buffers to allow the intermediate data to be transmitted between GPCs  for further processing.","Memory interface  includes a number D of partition units  that are each directly coupled to a portion of parallel processing memory , where D\u22671. As shown, the number of partition units  generally equals the number of DRAM . In other embodiments, the number of partition units  may not equal the number of memory devices. Persons skilled in the art will appreciate that DRAM  may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets, such as frame buffers or texture maps may be stored across DRAMs , allowing partition units  to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .","Any one of GPCs  may process data to be written to any of the DRAMs  within parallel processing memory . Crossbar unit  is configured to route the output of each GPC  to the input of any partition unit  or to another GPC  for further processing. GPCs  communicate with memory interface  through crossbar unit  to read from or write to various external memory devices. In one embodiment, crossbar unit  has a connection to memory interface  to communicate with I\/O unit , as well as a connection to local parallel processing memory , thereby enabling the processing cores within the different GPCs  to communicate with system memory  or other memory that is not local to PPU . In the embodiment shown in , crossbar unit  is directly connected with I\/O unit . Crossbar unit  may use virtual channels to separate traffic streams between the GPCs  and partition units .","Again, GPCs  can be programmed to execute processing tasks relating to a wide variety of applications, including but not limited to, linear and nonlinear data transforms, filtering of video and\/or audio data, modeling operations (e.g., applying laws of physics to determine position, velocity and other attributes of objects), image rendering operations (e.g., tessellation shader, vertex shader, geometry shader, and\/or pixel shader programs), and so on. PPUs  may transfer data from system memory  and\/or local parallel processing memories  into internal (on-chip) memory, process the data, and write result data back to system memory  and\/or local parallel processing memories , where such data can be accessed by other system components, including CPU  or another parallel processing subsystem .","A PPU  may be provided with any amount of local parallel processing memory , including no local memory, and may use local memory and system memory in any combination. For instance, a PPU  can be a graphics processor in a unified memory architecture (UMA) embodiment. In such embodiments, little or no dedicated graphics (parallel processing) memory would be provided, and PPU  would use system memory exclusively or almost exclusively. In UMA embodiments, a PPU  may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high-speed link (e.g., PCI-EXPRESS) connecting the PPU  to system memory via a bridge chip or other communication means.","As noted above, any number of PPUs  can be included in a parallel processing subsystem . For instance, multiple PPUs  can be provided on a single add-in card, or multiple add-in cards can be connected to communication path , or one or more of PPUs  can be integrated into a bridge chip. PPUs  in a multi-PPU system may be identical to or different from one another. For instance, different PPUs  might have different numbers of processing cores, different amounts of local parallel processing memory, and so on. Where multiple PPUs  are present, those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs  may be implemented in a variety of configurations and form factors, including desktop, laptop, or handheld personal computers, servers, workstations, game consoles, embedded systems, and the like.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 3A","FIG. 2B"],"b":["208","202","208","208"]},"Operation of GPC  is advantageously controlled via a pipeline manager  that distributes processing tasks to streaming multiprocessors (SPMs) . Pipeline manager  may also be configured to control a work distribution crossbar  by specifying destinations for processed data output by SPMs .","In one embodiment, each GPC  includes a number M of SPMs , where M\u22671, each SPM  configured to process one or more thread groups. Also, each SPM  advantageously includes an identical set of functional execution units (e.g., execution units, and load-store units, shown as Exec units  and LSUs  in ) that may be pipelined, allowing a new instruction to be issued before a previous instruction has finished, as is known in the art. Any combination of functional execution units may be provided. In one embodiment, the functional units support a variety of operations including integer and floating point arithmetic (e.g., addition and multiplication), comparison operations, Boolean operations (AND, OR, XOR), bit-shifting, and computation of various algebraic functions (e.g., planar interpolation, trigonometric, exponential, and logarithmic functions, etc.); and the same functional-unit hardware can be leveraged to perform different operations.","The series of instructions transmitted to a particular GPC  constitutes a thread, as previously defined herein, and the collection of a certain number of concurrently executing threads across the parallel processing engines (not shown) within an SPM  is referred to herein as a \u201cwarp\u201d or \u201cthread group.\u201d As used herein, a \u201cthread group\u201d refers to a group of threads concurrently executing the same program on different input data, with one thread of the group being assigned to a different processing engine within an SPM . A thread group may include fewer threads than the number of processing engines within the SPM , in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SPM , in which case processing will take place over consecutive clock cycles. Since each SPM  can support up to G thread groups concurrently, it follows that up to G*M thread groups can be executing in GPC  at any given time.","Additionally, a plurality of related thread groups may be active (in different phases of execution) at the same time within an SPM . This collection of thread groups is referred to herein as a \u201ccooperative thread array\u201d (\u201cCTA\u201d) or \u201cthread array.\u201d The size of a particular CTA is equal to m*k, where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SPM , and m is the number of thread groups simultaneously active within the SPM . The size of a CTA is generally determined by the programmer and the amount of hardware resources, such as memory or registers, available to the CTA.","Each SPM  contains an L1 cache (not shown) or uses space in a corresponding L1 cache outside of the SPM  that is used to perform load and store operations. Each SPM  also has access to L2 caches within the partition units  that are shared among all GPCs  and may be used to transfer data between threads. Finally, SPMs  also have access to off-chip \u201cglobal\u201d memory, which can include, e.g., parallel processing memory  and\/or system memory . It is to be understood that any memory external to PPU  may be used as global memory. Additionally, an L1.5 cache  may be included within the GPC , configured to receive and hold data fetched from memory via memory interface  requested by SPM , including instructions, uniform data, and constant data, and provide the requested data to SPM . Embodiments having multiple SPMs  in GPC  beneficially share common instructions and data cached in L1.5 cache .","Each GPC  may include a memory management unit (MMU)  that is configured to map virtual addresses into physical addresses. In other embodiments, MMU(s)  may reside within the memory interface . The MMU  includes a set of page table entries (PTEs) used to map a virtual address to a physical address of a tile and optionally a cache line index. The MMU  may include address translation lookaside buffers (TLB) or caches which may reside within multiprocessor SPM  or the L1 cache or GPC . The physical address is processed to distribute surface data access locality to allow efficient request interleaving among partition units. The cache line index may be used to determine whether of not a request for a cache line is a hit or miss.","In graphics and computing applications, a GPC  may be configured such that each SPM  is coupled to a texture unit  for performing texture mapping operations, e.g., determining texture sample positions, reading texture data, and filtering the texture data. Texture data is read from an internal texture L1 cache (not shown) or in some embodiments from the L1 cache within SPM  and is fetched from an L2 cache, parallel processing memory , or system memory , as needed. Each SPM  outputs processed tasks to work distribution crossbar  in order to provide the processed task to another GPC  for further processing or to store the processed task in an L2 cache, parallel processing memory , or system memory  via crossbar unit . A preROP (pre-raster operations)  is configured to receive data from SPM , direct data to ROP units within partition units , and perform optimizations for color blending, organize pixel color data, and perform address translations.","It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units, e.g., SPMs  or texture units , preROPs  may be included within a GPC . Further, while only one GPC  is shown, a PPU  may include any number of GPCs  that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC  receives a particular processing task. Further, each GPC  advantageously operates independently of other GPCs  using separate and distinct processing units, L1 caches, and so on.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 3B","FIG. 2B"],"b":["215","202","215","350","355","360","350","210","360","350","355","355","355","220","220"]},"In graphics applications, ROP  is a processing unit that performs raster operations, such as stencil, z test, blending, and the like, and outputs pixel data as processed graphics data for storage in graphics memory. In some embodiments of the present invention, ROP  is included within each GPC  instead of partition unit , and pixel read and write requests are transmitted over crossbar unit  instead of pixel fragment data.","The processed graphics data may be displayed on display device  or routed for further processing by CPU  or by one of the processing entities within parallel processing subsystem . Each partition unit  includes a ROP  in order to distribute processing of the raster operations. In some embodiments, ROP  may be configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.","Persons skilled in the art will understand that the architecture described in , B, A, and B in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit, including, without limitation, one or more CPUs, one or more multi-core CPUs, one or more PPUs , one or more GPCs , one or more graphics or special purpose processing units, or the like, without departing the scope of the present invention.","In embodiments of the present invention, it is desirable to use PPU  or other processor(s) of a computing system to execute general-purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier (\u201cthread ID\u201d) that is accessible to the thread during its execution. The thread ID, which can be defined as a one-dimensional or multi-dimensional numerical value controls various aspects of the thread's processing behavior. For instance, a thread ID may be used to determine which portion of the input data set a thread is to process and\/or to determine which portion of an output data set a thread is to produce or write.","A sequence of per-thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example, the sequence of per-thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point, an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access, an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs, or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read, with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques, data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently, any desired pattern of data sharing among threads can be supported, and any thread in a CTA can share data with any other thread in the same CTA. The extent, if any, of data sharing among threads of a CTA is determined by the CTA program; thus, it is to be understood that in a particular application that uses CTAs, the threads of a CTA might or might not actually share data with each other, depending on the CTA program, and the terms \u201cCTA\u201d and \u201cthread array\u201d are used synonymously herein.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 3C","FIG. 3A"],"b":["310","310","370","335","312","370","304","310","310","302","303"]},"SPM  provides on-chip (internal) data storage with different levels of accessibility. Special registers (not shown) are readable but not writeable by LSU  and are used to store parameters defining each CTA thread's \u201cposition.\u201d In one embodiment, special registers include one register per CTA thread (or per exec unit  within SPM ) that stores a thread ID; each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers, readable by all CTA threads (or by all LSUs ) that store a CTA identifier, the CTA dimensions, the dimensions of a grid to which the CTA belongs, and an identifier of a grid to which the CTA belongs. Special registers are written during initialization in response to commands received via front end  from device driver  and do not change during CTA execution.","A parameter memory (not shown) stores runtime parameters (constants) that can be read but not written by any CTA thread (or any LSU ). In one embodiment, device driver  provides parameters to the parameter memory before directing SPM  to begin execution of a CTA that uses these parameters. Any CTA thread within any CTA (or any exec unit  within SPM ) can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .","Local register file  is used by each CTA thread as scratch space; each register is allocated for the exclusive use of one thread, and data in any of local register file  is accessible only to the CTA thread to which it is allocated. Local register file  can be implemented as a register file that is physically or logically divided into P lanes, each having some number of entries (where each entry might store, e.g., a 32-bit word). One lane is assigned to each of the N exec units  and P load-store units LSU , and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups, so that a given entry in the local register file  is accessible only to a particular thread. In one embodiment, certain entries within the local register file  are reserved for storing thread identifiers, implementing one of the special registers.","Shared memory  is accessible to all CTA threads (within a single CTA); any location in shared memory  is accessible to any CTA thread within the same CTA (or to any processing engine within SPM ). Shared memory  can be implemented as a shared register file or shared on-chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments, shared state space might map onto a per-CTA region of off-chip memory, and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory , or as a separate shared register file or on-chip cache memory to which the LSUs  have read-only access. In one embodiment, the area that implements the parameter memory is also used to store the CTA ID and grid ID, as well as CTA and grid dimensions, implementing portions of the special registers. Each LSU  in SPM  is coupled to a unified address mapping unit  that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently, an instruction may be used to access any of the local, shared, or global memory spaces by specifying an address in the unified memory space.","The L1 Cache  in each SPM  can be used to cache private per-thread local data and also per-application global data. In some embodiments, the per-CTA shared data may be cached in the L1 cache . The LSUs  are coupled to a uniform L1 cache , the shared memory , and the L1 cache  via a memory and cache interconnect . The uniform L1 cache  is configured to receive read-only data and constants from memory via the L1.5 Cache .",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 4","FIG. 2"],"b":["400","202","310","415","425","460","410","420","455","465","208","215","400"]},"Data assembler  processing unit collects vertex data for high-order surfaces, primitives, and the like, and outputs the vertex data, including the vertex attributes, to vertex processing unit . Vertex processing unit  is a programmable execution unit that is configured to execute vertex shader programs, lighting and transforming vertex data as specified by the vertex shader programs. For example, vertex processing unit  may be programmed to transform the vertex data from an object-based coordinate representation (object space) to an alternatively based coordinate system such as world space or normalized device coordinates (NDC) space. Vertex processing unit  may read data that is stored in L1 cache , parallel processing memory , or system memory  by data assembler  for use in processing the vertex data.","Primitive assembler  receives vertex attributes from vertex processing unit , reading stored vertex attributes, as needed, and constructs graphics primitives for processing by geometry processing unit . Graphics primitives include triangles, line segments, points, and the like. Geometry processing unit  is a programmable execution unit that is configured to execute geometry shader programs, transforming graphics primitives received from primitive assembler  as specified by the geometry shader programs. For example, geometry processing unit  may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters, such as plane equation coefficients, that are used to rasterize the new graphics primitives.","In some embodiments, geometry processing unit  may also add or delete elements in the geometry stream. Geometry processing unit  outputs the parameters and vertices specifying new graphics primitives to a viewport scale, cull, and clip unit . Geometry processing unit  may read data that is stored in parallel processing memory  or system memory  for use in processing the geometry data. Viewport scale, cull, and clip unit  performs clipping, culling, and viewport scaling and outputs processed graphics primitives to a rasterizer .","Rasterizer  scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Additionally, rasterizer  may be configured to perform z culling and other z-based optimizations.","Fragment processing unit  is a programmable execution unit that is configured to execute fragment shader programs, transforming fragments received from rasterizer , as specified by the fragment shader programs. For example, fragment processing unit  may be programmed to perform operations such as perspective correction, texture mapping, shading, blending, and the like, to produce shaded fragments that are output to raster operations unit . Fragment processing unit  may read data that is stored in parallel processing memory  or system memory  for use in processing the fragment data. Fragments may be shaded at pixel, sample, or other granularity, depending on the programmed sampling rate.","Raster operations unit  is a processing unit that performs raster operations, such as stencil, z test, blending, and the like, and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in graphics memory, e.g., parallel processing memory , and\/or system memory , for display on display device  or for further processing by CPU  or parallel processing subsystem . In some embodiments of the present invention, raster operations unit  is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.","Path objects may be used to compose a path object scene, characterized as being a resolution-independent image. Each path object within the path object scene may specify a very complex geometry, with potentially overlapping stokes and complex fill geometry. Path objects are conventionally rendered on a general-purpose CPU, where highly complex rendering algorithms may be readily performed. While CPU-based rendering is able to cope with arbitrary complexity associated with certain path objects, CPU-based path object rendering does not leverage high-throughput processing capacity available on a typical GPU. The GPU can easily process a high volume of simple, parallel computations, but is not able to efficiently process the highly serial or highly complex algorithms that are typically associated with path object rendering.","Embodiments of the present invention set forth a technique for decomposition of an arbitrarily complex path object comprising an arbitrary number of path commands into a decomposed path object comprising simple stencil and cover operations constructed from geometric primitives such as triangles that are easily processed by a GPU. The path commands are generally associated with either stroking operations or filling operations. Stroking and filling operations are each rendered in two phases. The first phase involves stenciling, which establishes geometric coverage, down to a sub-pixel resolution, for the path object. The second phase involves covering, which involves computing a color for the covered regions. A given path object may be specified as a combination of both stroking and filling path objects, which are typically rendered one after the other. A stroking path object typically includes certain details such as a dash pattern and a dash end specification. By performing stencil testing on a sub-image sample basis using multiple stencil values per image sample, embodiments of the present invention increase path coverage precision, thereby improving anti-aliased appearance of resulting rendered path objects.","The process of applying decomposition operators to a scene comprising path objects into simple stencil and cover operations for rendering on a GPU is referred to herein as \u201cbaking\u201d the scene. The simple stencil operators and fill operators comprise a \u201cbaked representation\u201d of the scene. Specific types of simple stencil operators and simple fill operators are selected for efficient rendering on a particular GPU. Importantly, the simple stencil operators and simple fill operators of the baked representation comprise resolution-independent geometric specifications for corresponding resolution-independent path objects. Certain exemplary decomposition operations are described below in conjunction with the present invention for baking a path object scene. However, any technically feasible techniques for decomposing a path object into a baked representation for efficient rendering on a GPU may be implemented without departing the scope and spirit of the present invention. A scene may be re-baked to accommodate changes within the scene.","A technique for efficiently evaluating an implicit representation of cubic B\u00e8zier segments for filling an object path is described in patent application Ser. No. 13\/097,483 filed Apr. 29, 2011, and entitled \u201cDecomposing Cubic B\u00e8zier segments for Tessellation-Free Stencil Filling.\u201d This related application is also hereby incorporated by reference in its entirety.","This technique describes a path as consisting of a sequence of connected path segment commands for line segments, B\u00e8zier segments, and partial elliptical arcs. Cubic B\u00e8zier segments pose a particular challenge when rendering these segments into the stencil buffer to determine what framebuffer sample locations are within the filled region of the respective path. If not done carefully, multiple classes of cubic B\u00e8zier segments can contribute incorrect winding number offsets to the net winding number for a particular framebuffer sample location. An incorrect winding number determination immediately leads to an incorrect determination of a rasterized filled region of said path. Decomposing each arbitrary cubic B\u00e8zier in a path into one or more simple cubic B\u00e8zier segments produces a geometry set that is suitable for rendering filled paths containing cubic B\u00e8zier segments. Such decomposition is beneficial because it results in a robust determination of the filled region of a rendered path without tessellating the path. The path is divided into cubic B\u00e8zier path segments that are each classified and further divided into simple cubic B\u00e8zier path segments. Care must be taken to preserve the proper vertex winding order of each simple B\u00e8zier cubic segment, split the original cubic B\u00e8zier at the proper positions, and linearly interpolate texture coordinates according to the technique described by Loop and Blinn for use with a discard shader. The simple cubic B\u00e8zier path segments are then rasterized using a discard shader program to generate a stencil buffer indicating pixels that are inside of the path. In contrast, the discard shader technique described by Loop and Blinn fills the inside of the path by rendering the tessellated B\u00e8zier curve segments using the discard shader to write directly to the image buffer.","B\u00e8zier curves are defined by their control points. In the 2D content of path rendering, each control point is a 2D position. Curved path segments for a path may be generated by path commands for quadratic B\u00e8zier curves, cubic B\u00e8zier curves, and partial elliptical arcs.","A quadratic B\u00e8zier curve is specified by 3 control points and a cubic B\u00e8zier curve is specified by 4 control points. The QTcommand uses the terminal position of the prior command as its initial control point (x0,y0) and then 4 associated coordinates form the two new (x1,y1) and (x2,y2) control points. The quadratic B\u00e8zier curve starts at (x0,y0) heading towards (x1,y1) and ends at (x2,y2) as if coming from (x1,y1). Despite (x1,y1) providing the initial tangent direction when starting from (x0,y0) and terminating at (x2,y2), the resulting curve does not pass through (x1,y1); for this reason, (x1,y1) is known as an extrapolating control point while (x0,y0) and (x2,y2) are known as interpolating control points. Quadratic B\u00e8zier curves may be filled without tessellation manner, because non-degenerate quadratic B\u00e8zier curves have no points of self-intersection and the segment curve does not intersect the line formed by the initial and terminal control points.","The CTcommand is similar to the QTcommand but generaFtes a cubic B\u00e8zier curve. Such a curve is specified by 4 control points. The CTcommand uses the terminal position of the prior command as its initial control point (x0,y0) and then 6 associated coordinates form the 3 new (x1,y1), (x2,y2), and (x3,y3) control points. The cubic B\u00e8zier curve starts at (x0,y0) heading towards (x1,y1) and ends at (x3,y3) as if coming from (x2,y2). While a quadratic B\u00e8zier curve has a single extrapolating control point, cubic B\u00e8zier curves have two extrapolating control points, (x1,y1) and (x2,y2). A cubic B\u00e8zier curve has the freedom, unlike a quadratic B\u00e8zier curve, to specify arbitrary initial and terminal tangent directions for its end-points. This control makes cubic B\u00e8zier curves popular with artists. This additional control comes from the curve being described by a third-order polynomial equation instead of a second-order equation in the case of a quadratic B\u00e8zier curve (and first-order in the case of line segments). This additional polynomial degree provides the requisite freedom for a cubic B\u00e8zier segment to non-trivially self-intersect itself or cross the line formed by the segment's initial and terminal control points. These conditions result in reversals of the local sense of \u201cinside\u201d and \u201coutside\u201d the path. In order for a tessellation-free path filling approach based on stencil counting of rasterized polygons to be robust when a discard shader is used to write a stencil buffer, such situations must be avoided.","A technique for stroking a path object based on quadratic B\u00e8zier segments is described in patent application Ser. No. 13\/097,993 filed Apr. 29, 2011, and titled \u201cPoint Containment for Quadratic B\u00e8zier Strokes.\u201d This related application is also hereby incorporated by reference in its entirety.","The resulting quadratic B\u00e8zier segments from this technique comprise a geometry set that is suitable for stroking rendered paths containing higher-order B\u00e8zier segments, such as cubic B\u00e8zier segments, without tessellating the path into polygons. The path is divided into quadratic B\u00e8zier path segments, arcs, and\/or line segments.","This technique described path stroking as having an associated \u201cstroke width\u201d that defines a region that is included in the stroke when a circle having a diameter of the stroke width is moved along the path segment. The path segment is considered a generating curve and the circle generates an inside offset curve and an outside offset curve as the circle moves along the path segment. Mathematical computation of the boundary of such offset curves is difficult. Because stroking is an important operation for many application programs that produce 2D images, it is desirable to accelerate stroking operations.","In one embodiment, a GPU, such as the PPU , may be used to perform functions to accelerate stroking operations. Importantly, tessellation of the path segments is avoided. Instead, a path is decomposed into quadratic B\u00e8zier path segments or segments of lower complexity, e.g., arcs, line segments, and the like. The stroking operations are accelerated without determining or even approximating the boundary of the strokes (the inside and outside offset curves) that can be defined by high-order polynomials. Instead, computations are performed to determine whether or not discrete point locations are inside or outside of a particular quadratic B\u00e8zier stroke or stroke of lower complexity.","A technique for decomposing a path into quadratic B\u00e8zier segments is described in patent application Ser. No. 13\/098,102 filed Apr. 29 2011, and titled \u201cApproximation of Stroked Higher-Order Curved Segments by Quadratic B\u00e8zier Curve Segments.\u201d This related application is also hereby incorporated by reference in its entirety.","The resulting quadratic B\u00e8zier segments from this technique comprise a geometry set that is suitable for stroking rendered paths containing higher-order B\u00e8zier segments, such as cubic B\u00e8zier segments, without tessellating the path into polygons. The path is divided into quadratic B\u00e8zier path segments, arcs, and\/or line segments. The quadratic B\u00e8zier path segments generated by this decomposition technique are then processed to determine whether or not points are contained within the stroke region of each quadratic B\u00e8zier path segment, arc, or line segment.","GPU-accelerated stroking techniques typically perform approximately 1 to 2 orders of magnitude more fragment processing operations per sample than filling of the paths. This relative expense is justified because it results in fewer approximations and a more compact and resolution-independent baked representation from which to render stroked paths. The observation that more rendered pixels are filled than stroked in typical path rendering scenes with both types of path rendering also helps balance the relatively higher per-sample cost of stroking to filling.","Decomposing stroking objects with dashing is described in patent application Ser. No. 13\/098,147 filed Apr. 29 2011, and titled \u201cConversion of Dashed Strokes into Quadratic B\u00e8zier Segments Sequences.\u201d This related application is also hereby incorporated by reference in its entirety.","The quadratic B\u00e8zier path segments, arcs, and line segments generated by the decomposition technique are then processed to determine whether or not points are contained within the stroke region of each quadratic B\u00e8zier path segment, arc, or line segment.","Dashing is a standard embellishment to stroking whereby the stroke is dividing up into multiple sub-strokes based on an on-off pattern known as the dash pattern of the stroke. Path rendering standards supporting dashing include PostScript, Portable Document Format (PDF), Open XML Paper Specification (OpenXPS), SVG, and OpenVG. The dash pattern is an array of lengths specified in path-space units. For example, a dash pattern [4,3,2,7] is 4 arc lengths on, 3 arc lengths off, 2 arc lengths on, 7 arc lengths off, repeated. If the dash pattern has an odd number of elements, the effective dash pattern is repeated twice to ensure the effective dash pattern always has an even number of elements.","Alternating elements of the dash pattern are arc lengths that specify how long to \u201cdash on\u201d and \u201cdash off\u201d the stroked curve; the dash pattern is initially on. When stroking a path, an additional scalar dash offset parameter indicates how many path-space units into the dash pattern the stroke begins, i.e., dash offset is an offset into the dash pattern. Another scalar dash phase parameter may also be specified that indicates if the subpaths restart at the dash offset or at a particular phase of the dash offset. A subpath is a connected set of path segments; a new subpath is initiated by a MoveTo command in the path's command sequence is encountered. Intuitively, a MTcommand is similar to an artist picking up the pen and moving to a new 2D position on the page. So the dash phase indicates whether the dash pattern restarts for disconnected segments of a stroked path or not. An end-cap style indicates what happens at the end points of open (non-closed) sub-paths. Typical end-cap styles are round, square, none, and triangle. If the sub-path is closed, the join style is used to connect the initial and terminal segments rather than using end caps. When dashing, the ends of dashed stroked segments may have a capping style distinct from the end caps of each stroked subpath; in this case, these caps are referred to as dash caps.","In one embodiment, a GPU, such as the PPU , may be used to perform functions to accelerate the above operations. Importantly, tessellation of the path segments is avoided. Instead, a path is decomposed into quadratic B\u00e8zier path segments or segments of lower complexity, e.g., arcs, line segments, and the like. Path decomposition results in fewer approximations and a more compact and resolution-independent baked representation from which to render stroked paths compared with tessellation of the path. Persons skilled in the art will recognize that, in addition to the above techniques, other decomposition techniques may be implemented in conjunction with path object baking without departing the scope and spirit of the present invention.","Path objects typically comprise complex shapes described by complex mathematical models, as described above. In one embodiment of the present invention, each path object within a path object scene is decomposed or \u201cbaked\u201d into substantially equivalent decomposed path objects that are simpler to render. Each decomposed path object may represent a portion of an original path object, and a collection of decomposed path objects may together represent the whole original path object. Both the original path object and decomposed path objects are resolution independent. However, the decomposed path objects comprise simpler mathematical models that may be efficiently rendered on a GPU.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":["FIG. 5","FIG. 2A"],"b":["100","510","103","102","510","512","510","512"]},"The path object scene  may comprise high-order path objects for stroking, filling, and dashing. The baked path object data  comprises only simple stencil and cover operations suitable for efficient execution on a GPU. In one embodiment, the GPU comprises the parallel processing subsystem . Specific types of simple stencil and cover operations are implementation specific for a given GPU.","In one embodiment, an application programming interface (API) specifies associated path objects that should be baked for rendering on the GPU. For example, an extension to the industry standard OpenGL API may specify a set of API calls for specifying path objects, and parameters for the path objects. Such API calls may include, for example, MoveTo, LineTo and QuadraticTo commands, which set a point location, draw a line, draw a quadratic curve, respectively. An additional API call may be implemented for triggering a baking operation on a group of path objects or baking may occur implicitly as a consequence of rendering. The API should facilitate specification of any relevant aspect of a path object. For example, the API should facilitate specification of object types and coordinates for control points. The API should include parameters for end cap styles, join styles, miter limits, dash arrays, dash offsets, a default radius value, a default fill rule, fill stroke usage, and the like. Internal state for the device driver  should include a private buffer for object state, including vertex attributes forming geometric primitives such as triangles, constants, shaders, and pre-computed push-buffer commands for organizing GPU-bound commands.","After the path object scene  is baked for GPU rendering, the corresponding baked path object data  is copied to PP memory  via copy operation  as baked path object data . The parallel processing subsystem  renders the baked path object data  to a stencil buffer  in a stenciling phase. The parallel processing subsystem  then renders the baked path object data  to an image buffer  in a cover phase, with geometric coverage determined by the stencil buffer . In a conventional 3D graphics system, a depth buffer comprising three bytes per pixel and one stencil sample per pixel may be allocated and associated with an image buffer of equivalent pixel count. Such an allocation scheme is inefficient for path rendering because depth is typically not used in computing visibility of path objects, although the only format for allocating a stencil buffer is in conjunction with a larger depth buffer. Embodiments of the present invention enable allocation of a pure stencil buffer, such as stencil buffer .","As previously discussed, the GPU renders the baked data in two phases. During the stenciling phase, the GPU is configured for pass-through vertex processing, with clip coordinates generated based on clip enables. Geometry and tessellation shaders are disabled and fragment shaders are selected based on each topology state within the path being rendered. Front and back polygon fill modes are set to the known state of GL_FILL. Furthermore, color and depth writes are disabled. During stenciling, stencil state is over-written with path stenciling parameters.","During the covering phase, the GPU is configured for pass-through vertex processing, with clip coordinates generated based on clip enables. Geometry and tessellation shaders are disabled. Front and back polygon fill modes are set to the known state of GL_FILL. During covering, the stencil state and the color and depth write masks are preserved.","Embodiments of the present invention allocate multiple stencil samples per color value. A stencil sample is analogous to a coverage assessment for a path object at the geometric location of the stencil sample. Efficient anti-aliasing is achieved for path rendering by computing pixel coverage for the path object at each covered pixel using a plurality of stencil samples associated with the pixel. In one embodiment, each one of the plurality of stencil samples is computed at a location within the associated pixel, or more generally, an image sample. In the practice of multisampling, a pixel is generated from a plurality of image samples, where each image sample includes a separately computed color, depth, and stencil value.","In one embodiment that does not implement multisampling, each pixel is generated from one color value computed at the pixel center, a stencil sample computed at the pixel center, and three additional stencil samples computed at locations within the pixel. This configuration is shown below in . Other configurations for 4\u00d7 and 8\u00d7 multisampling are shown below in , respectively.",{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 6A","b":["610","620","0","622","622"]},"In one embodiment, a color surface having a specified height and width is allocated to store a rendered image. A corresponding stencil buffer is also allocated, having an identical height and width, to store stencil data. For example, a four-byte per pixel color surface allocates one byte to each of alpha, red, green, and blue components for a pixel. The stencil buffer allocates a corresponding four-byte unit of data per pixel, where each of the four bytes is interpreted as a stencil sample. In this configuration, each pixel -A includes four sub-pixel coverage samples via the four stencil samples. Stencil samples are conventionally allocated as 8-bit values sharing a 32-bit word of storage with a 24-bit depth value. In certain embodiments of the present invention, storage otherwise allocated to a 24-bit depth value is advantageously overlapped with three additional 8-bit stencil values, so that each 32-bit word comprises four 8-bit stencil samples. As disclosed herein, this novel reinterpretation of a standard layout of a conventional depth-stencil buffer is particularly advantageous for path rendering because path rendering depends on rendering order (the so-called painter's algorithm) for resolving scene order rather than explicit depth order, as indicated by a depth buffer. Hence, during path rendering, the PPU  is not otherwise rendering to or accessing depth values. Indeed, when the PPU  is configured to operate according to certain embodiments of the invention, depth testing is implicitly disabled. Therefore, storing four 8-bit stencil samples is particularly advantageous, and a preferred embodiment implements this approach to best match a standard 32-bit word allocated per pixel within the context of a conventional stencil-depth systems architecture designed to accommodate 8-bit stencil values. Other configurations are also easily accommodated within a 32-bit per pixel allocation, including sixteen 4-bit stencil samples, three 10-bit stencil samples, or five 6-bit stencil samples. Each of these configurations make different tradeoffs with respect to coverage quality and range of stencil values.",{"@attributes":{"id":"p-0125","num":"0124"},"figref":["FIG. 6B","FIG. 6B","FIG. 6B"],"b":["610","620","622","622","622","622"]},"In one embodiment, a color surface having a specified height and width is allocated to store a rendered image of one half the height and one half the width in size. A corresponding stencil buffer is also allocated, having an identical height and width to the color surface for storing stencil data. Four bytes specify each color sample (sub-pixel color) within the color surface, including one byte for each of alpha, red, green, and blue components. The stencil buffer includes a corresponding four-byte unit of data per color sample, and each one of the four bytes is interpreted as a stencil sample value for the sub-pixel. In this configuration, each pixel -B, configured as shown in , includes sixteen sub-pixel stencil coverage samples via the sixteen stencil samples associated with the pixel -B.",{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 6C","b":["610","620","622","622"]},"In one embodiment, a color surface having a specified height and width is allocated to store a rendered image of one half the height and one quarter the width in size. A corresponding stencil buffer is also allocated, having an identical height and width to the color surface for storing stencil data. Four bytes specify each color sample (sub-pixel color), including one byte for each of alpha, red, green, and blue components. The stencil buffer may include a corresponding four-byte unit of data per sub-pixel, and each one of the four bytes is interpreted as a stencil sample value for the sub-pixel. In this configuration, each pixel -C, configured as shown in , includes thirty-two sub-pixel coverage samples via the thirty-two stencil samples associated with the pixel -C. This configuration is advantageous because existing, contemporary GPUs support 8\u00d7 multisample rendering mode and 32 coverage samples per pixel rivals or exceeds typical coverage quality of purely CPU-based path rendering systems. This is particularly true because GPUs rasterizer on jittered (rather than orthogonal) grids of pixels resulting in a typically better sampling pattern than CPU-based path rendering systems achieve.  similarly illustrate jittered stencil positions for this reason.","While  illustrate specific configurations of color samples and stencil samples, any technically feasible configuration of an image buffer and stencil buffer having multiple stencil samples per color value is within the scope and spirit of the present invention. In certain embodiments, specific sub-pixel locations for one or more color samples, and two or more stencil samples are programmable. By executing a programmable shader on each stencil sample position, such a shader can conditionally discard any covered stencil sample prior to the stencil test. Additionally, a programmable shader running at the frequency of each pixel or color sample may receive, modify, and output a discard mask of samples to be discarded to cull stencil updates to certain samples. The ability to operate this discard process at the per-pixel or per-color sample rate is advantageous to avoid execution overheads from running a programmable shader at the stencil sample rate (typically 4 times the color sample rate). In one embodiment, a shader program, such as a discard shader program, is configured to generate a discard mask associated with one or more stencil coverage samples being rendered. The discard mask serves to disable stencil testing for discarded sample points. When the discard shader marks a sample point for discard, subsequent stencil testing on the sample point is disabled and yields a fail value. A discard shader may mark one or more sample points for discard, for example, based on a determination that the point is not part of a path cover area. The discard mask also enables discard of samples that would be located outside a given pixel boundary as a result of uttering sub-pixel sample locations during multi-sampling. This ability to discard stencil coverage prior to the stencil test is necessary in processing the baked path object data  containing curved coverage boundaries when stenciling paths.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":["FIG. 7A","FIG. 5"],"b":["710","712","720","722","710","532","720","530","712","710","722","720"]},{"@attributes":{"id":"p-0131","num":"0130"},"figref":"FIG. 7B","b":["712","712","714","0","714","1","714","2","714","3","714","712","710"]},{"@attributes":{"id":"p-0132","num":"0131"},"figref":"FIG. 7C","b":["722","722","724","0","0","724","3","3","724","712","724","712","724","722","1","724","1","2","724","2","2","724","3","0","724","0","722","710"]},{"@attributes":{"id":"p-0133","num":"0132"},"figref":["FIG. 8","FIGS. 2A-5"],"b":"800"},"In one embodiment, the method steps  are performed during the stenciling phase and during the covering phase for rendering a path object from baked path object data . The method steps assume a stencil buffer, such as stencil buffer , is allocated and populated with stencil values. The stencil buffer includes multiple stencil samples per color sample within a corresponding image buffer. During stenciling, multiple stencil samples per color sample are generated when the geometric primitives that make up the baked path object  for path stenciling are rasterized. The method steps are performed per image sample location within an image buffer, such as image buffer . In one embodiment, the method steps are performed by a path rendering module comprising one or more GPU shader programs executing within the GPU.","The method begins in step , where the parallel processing subsystem , alternatively understood to be any other viable implementation of graphics pipeline  or other rendering system, selects a target image sample location that is at least partially covered by a geometric primitive, where partial covered means one of the associated stencil sample locations  is covered. Any technically feasible technique may be implemented to select the target image sample. For example, rasterization of geometric primitives such as triangles may be implemented to select the target image sample by rasterizer . Geometric primitives are typically represented as a set of edge equations. A sample position is covered by the primitive is the sample location can satisfy all the edge equations. In one embodiment, the target image sample location represents a pixel center.","In step , an optional shader, such as a discard shader, may determine whether or not to discard one or more of the stencil sample locations . Step  may be performed by executing a shader for each stencil sample location or running a shader instance per-image sample or per-pixel where the sample locations are discarded by updating a sample mask. In step , the raster operations unit  performs stencil testing at each sample location associated with the target image sample and covered by the geometric primitive. Stencil testing may include any technically feasible stencil test on each sample associated with the target pixel. Each stencil test results in is a Boolean value of either pass (1) or fail (0). For example, an implementation having four stencil samples per pixel will generate four Booleans from stencil testing related to one pixel. Uncovered or discarded stencil samples for the image sample are treated as failing. If, in step , any of the stencil tests produce a pass, then the method proceeds to step .","In step , the rendering module generates a coverage percentage based on the Boolean values from stencil testing. In one embodiment, the coverage percentage is calculated as a quotient of a count of stencil test passes divided by a count for stencil samples being subjected to stencil testing. For example, four stencil samples can produce a coverage percentage of zero percent (all stencil testes fail), twenty-five percent (one stencil test passes), fifty percent (two stencil tests pass), seventy-five percent (three stencil tests pass), and one hundred percent (all stencil tests pass). Different configurations having a different number of stencil samples can produce correspondingly different coverage percentage values.","In step , the path rendering module generates a color value for an image sample within the geometric primitive. In one embodiment the color may be computed by the programmable shader executing in step . A pixel center may be used as a position for computing the color value. Any technically feasible technique may be implemented to generate the color value. In step , the path rendering module computes a modulated color value based on the generated color value and the coverage percentage. In one embodiment, the modulated color value is computed on a per component basis by multiplying the coverage percentage by each of four color components (alpha, red, green, and blue). For example, if the coverage percentage is twenty five percent for a given pixel, then each of the four color components for the pixel are separately multiplied by 0.25 to generate the modulated color value. In step , the raster operations unit  blends the modulated color value with a pixel previously stored in the image buffer, based on the alpha value associated with the modulated color value. Any technically feasible technique may be used to blend the modulated color value with the previously store pixel. For example to implement \u201cover\u201d compositing, the modulated color value may be added, on a per component basis, to the product of the previously stored pixel and a difference of one minus the resulting modulated alpha value. The method terminates in step .","Returning to step , if none of the stencil tests produce a pass, then the method proceeds to step , where a fragment destined for the target pixel is discarded.","In sum, a technique useful to improve the quality of path rendering using multiple stencil samples per color sample is disclosed. A stencil buffer comprising plural stencil samples per image sample is allocated in conjunction with an image buffer. A coverage percentage for a pixel is determined based on results of stencil tests performed on the plural stencil samples associated with the pixel. A pixel color is computed based on a path object and modulated based on the coverage percentage. The pixel color is blended into an image buffer to produce the path object contribution to pixel.","One advantage of the disclosed technique is that high-quality, anti-aliased path object rendering may be efficiently performed on a GPU, which is able to achieve higher overall path rendering performance than a comparable CPU. Plural stencil samples are efficiently packed into a stencil buffer to provide sub-pixel coverage sampling for anti-aliasing.","One embodiment of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored.","The invention has been described above with reference to specific embodiments. Persons skilled in the art, however, will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 1C","FIG. 1A"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 1D","FIG. 1B"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 2B","FIG. 2A"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 3A","FIG. 2B"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 3B","FIG. 2B"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 3C","FIG. 3A"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4","FIG. 2B"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 7C"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
