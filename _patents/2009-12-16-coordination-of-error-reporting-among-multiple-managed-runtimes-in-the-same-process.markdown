---
title: Coordination of error reporting among multiple managed runtimes in the same process
abstract: Systems and methods are described for coordinating error reporting among a plurality of managed runtimes that are concurrently executing in the same process. In accordance with various embodiments, an error reporting manager that executes concurrently in the same process as the managed runtimes coordinates error reporting among the managed runtimes in a manner that does not require the managed runtimes to be aware of each other or to communicate directly with each other.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08429454&OS=08429454&RS=08429454
owner: Microsoft Corporation
number: 08429454
owner_city: Redmond
owner_country: US
publication_date: 20091216
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["As used herein, the term native application refers to an application that is designed to run natively (i.e., without translators or other intermediary mechanisms) on an operating system executing on a processor-based computer system. In contrast, a managed application refers to an application that is not capable of running natively on the operating system, but is instead designed to run in an environment provided by a managed runtime executing on top of the operating system. The managed runtime manages the execution of the managed application and provides services thereto. Among other features, the managed runtime may provide a just-in-time compiler that converts the code of a managed application into code native to the operating system at runtime. By using managed runtimes, applications that have been compiled for a single architecture can be run on many different machines. Examples of managed runtimes include the Common Language Runtime published by Microsoft Corporation of Redmond, Wash., and the Java Runtime Environment published by Sun Microsystems of Santa Clara, Calif.","When the execution of a managed application is initiated on a processor-based computer system, the operating system is prompted to load the appropriate managed runtime to facilitate execution of the managed application. In certain computing environments, it is now possible to concurrently run more than one managed runtime in a single process. This feature enables a native or managed application to invoke the features of one or more additional managed applications, wherein each managed application is supported by its own managed runtime. One advantage of the ability to concurrently run multiple managed runtimes in a single process is that managed applications written for different versions of the same managed runtime can be concurrently executed within the same process without concerns about compatibility. For example, managed applications written for different versions of the Common Language Runtime may be executed concurrently within the same process by loading the appropriate version of the Common Language Runtime to support each managed application.","Certain challenges arise when attempting to operate a computing environment in which more than one managed runtime can run concurrently in the same process. For example, when two or more managed runtimes are running concurrently in the same process and one of the managed runtimes fails unexpectedly, each managed runtime may independently attempt to report an application error even when the managed runtime did not itself cause the failure. This results in the generation of multiple error reports, with only one of the reports coming from the failing managed runtime, which has the context of the original failure to be used to generate a useful error report. The generation of multiple error reports in this manner provides a poor user experience. Furthermore, the generation of multiple error reports in this manner could mislead subsequent investigations into the cause of the failure since only the error report generated by the failing managed runtime is useful for investigation.","In order to provide a reasonable error reporting user experience, it would appear that some sort of cooperation is required between the different managed runtimes running in the same process. For example, let it be assumed that a failure occurs due to an unhandled exception thrown by a first managed runtime executing on a thread and that a second managed runtime owns the base of the thread. In this case, only the first managed runtime will have the information necessary to produce a useful error report. However, due to the way exceptions are managed in some computing environments, only the second managed runtime may have the information necessary to determine whether the exception is fatal and that an error report should be triggered. Since the first and second managed runtimes are designed to be unaware of each other and do not communicate directly, the result may be that only the second managed runtime produces an error report, but the error report is not useful. Other possible results due to this lack of cooperation between the managed runtimes is that no error reports are generated or that multiple error reports are generated, but at best only one of the error reports is useful.","Commonly-owned co-pending U.S. patent application Ser. No. 12\/358,708, filed on Jan. 23, 2009, describes a customized error reporting system that can be used to coordinate error reporting among multiple managed runtimes concurrently running in the same process. However, the error reporting facilities described in this application are provided as part of an operating system. As such, the approach to coordinating error reporting described in that application will only work in a system in which the operating system has been built or modified to include the described facilities. Otherwise, the concurrent execution of multiple runtimes in the same process will lead to the various problems described above.","What is needed then is a system and method for coordinating error reporting among multiple runtimes that are concurrently executing in the same process. The desired system and method should address one or more of the problems described above, including but not limited to the generation of error reports that are not useful and\/or the generation of multiple error reports by the managed runtimes. The desired system and method should also address the problem(s) in a manner that is not dependent on facilities built or added into a particular operating system.","Systems and methods are described herein for coordinating error reporting among a plurality of managed runtimes that are concurrently executing in the same process. In accordance with various embodiments, an error reporting manager that executes concurrently in the same process as the managed runtimes coordinates error reporting among the managed runtimes in a manner that does not require the managed runtimes to be aware of each other or to communicate directly with each other. By performing such coordination, the error reporting manager operates to ensure that if the process crashes, at most one error report will be generated by the managed runtime that caused the failure or the first managed runtime that encounters an error that does not come from any of the managed runtimes in the process. By performing such coordination, the error reporting manager also operates to ensure that the managed runtime that caused the failure will claim the error and will generate the error reporting information. Because the error reporting manager performs this coordination in-process, it provides an approach to managing error reporting among multiple managed runtimes concurrently running in the same process in a manner that is not dependent on facilities built or added into a particular operating system. Thus, this approach to managing error reporting can conceivably be implemented on different systems running different versions of the same operating system, or different operating systems entirely.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter. Moreover, it is noted that the invention is not limited to the specific embodiments described in the Detailed Description and\/or other sections of this document. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein.","The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings, in which like reference characters identify corresponding elements throughout. In the drawings, like reference numbers generally indicate identical, functionally similar, and\/or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit(s) in the corresponding reference number.","I. Introduction","The following detailed description refers to the accompanying drawings that illustrate exemplary embodiments of the present invention. However, the scope of the present invention is not limited to these embodiments, but is instead defined by the appended claims. Thus, embodiments beyond those shown in the accompanying drawings, such as modified versions of the illustrated embodiments, may nevertheless be encompassed by the present invention.","References in the specification to \u201cone embodiment,\u201d \u201can embodiment,\u201d \u201can example embodiment,\u201d or the like, indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Furthermore, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the relevant art(s) to implement such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.","II. Example Systems and Methods for Coordinating Error Reporting Among Multiple Managed Runtimes Concurrently Running in the Same Process",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 1","FIG. 1","FIG. 5"],"b":["100","100"]},"As shown in , an operating system  is installed on user machine  and is executed thereon. Operating system  acts as a host for software applications running on user machine . For example, operating system  manages and coordinates the sharing of the resources of user machine  by various applications running thereon. Operating system  also interfaces with various hardware elements of user machine  on behalf of applications, thereby relieving the applications from having to manage details of hardware operations and making the applications easier to write. Operating system  may offer a number of services to applications and users. Applications access these services through application programming interfaces (APIs) or system calls. By invoking these interfaces, an application can request a service from operating system , pass parameters thereto, and receive results therefrom. Depending upon the implementation, users may interact with operating system  via a software user interface (SUI) such as a command line interface (CLI) or a graphical user interface (GUI). For handheld and desktop computers, the user interface is generally considered part of operating system . On larger multi-user systems, the user interface is generally implemented as an application program that runs on top of operating system .","In one embodiment, operating system  comprises a WINDOWS\u00ae XP, WINDOWS\u00ae VISTA\u00ae or WINDOWS\u00ae 7 operating system published by Microsoft Corporation of Redmond, Wash. However, this example is not intended to be limiting, and operating system  may comprise any conventional or subsequently-developed operating system that is designed to perform at least one or more of the aforementioned functions.","As shown in , a process  is running on top of operating system . A process includes an instance of computer code, such as an application, that is being executed by user machine . To accommodate the fact that some applications are programmed to call or invoke other applications, a single process may include multiple concurrently-executing applications. Applications may be native or managed. A native application is an application that is designed to run natively (i.e., without translators or other intermediary mechanisms) on an operating system while a managed application refers to an application that is not capable of running natively on the operating system, but is instead designed to run in an environment provided by a managed runtime executing on top of the operating system. When the execution of a managed application is initiated on a processor-based computer system, the operating system is prompted to load the appropriate managed runtime to facilitate execution of the managed application.","In certain computing environments, it is possible to concurrently run more than one managed runtime in a single process. The system of  represents an example of such a computing environment. As shown in that figure, process  includes multiple concurrently-executing managed runtimes through . Each of the managed runtimes has been loaded by operating system  to support the execution of one or more managed applications in process . For example, managed runtime has been loaded to support the execution of one or more managed applications and managed runtime has been loaded to support the execution of one or more managed applications . In one embodiment, each managed runtime comprises a version of the Common Language Runtime published by Microsoft Corporation of Redmond, Wash. However, this is only one example, and the managed runtimes may include other managed runtimes including but not limited to the Java Runtime Environment published by Sun Microsystems of Santa Clara, Calif., the ADOBE\u00ae FLASH\u00ae Player published by Adobe Systems of San Jose, Calif., a Ruby programming language runtime environment, a Python programming language environment, or the like.","One advantage of the ability to concurrently run multiple managed runtimes in a single process is that managed applications written for different versions of the same managed runtime can be concurrently executed within the same process without concerns about compatibility. For example, managed applications written for different versions of the Common Language Runtime may be executed concurrently within the same process by loading the appropriate version of the Common Language Runtime to support each managed application.","As further shown in , operating system includes an error reporting service . Among other features, error reporting service  collects data about native and managed applications running on operating system  that experience failures. Such information may be stored locally on user machine  and\/or transmitted to a remote server (not shown in ) that aggregates such information so that patterns that reveal the source of failures can be identified. The transmission of the information to the remote server may be carried out, for example, over a local area network or wide area network, such as the Internet. In certain embodiments, the error reporting information stored locally on user machine , or a subset of such information, may be viewed by a user of user machine  via a GUI provided by operating system .","Depending upon the implementation, when error reporting service  becomes aware of a failed application, it may cause a dialog box to be presented to a user via a GUI provided by operating system  that asks the user if an error report should be transmitted to a remote server and\/or if the user wishes to debug the failed application.","Each of managed runtimes -includes logic for reporting error information on behalf of a failing managed application to error reporting service . A managed runtime may trigger error reporting, for example, when it determines that a managed application has thrown an unhandled exception. An unhandled exception indicates a problem with an application. Certain problems, such as invalid input, are anticipated by application developers and handlers for certain exceptions may be provided within an application. But, when an exception is not handled by the application, the application is no longer in an operational state (e.g., it has \u201ccrashed\u201d). A managed runtime may also trigger error reporting, for example, if a managed application fails to respond for a period of time. This condition is sometimes referred to an \u201capplication hang.\u201d An application hang may be caused by a number of conditions, such as encountering an infinite loop in the application code, a deadlock condition, or resource starvation. An application may request the managed runtime that executes the application to trigger error reporting when it detects a logic error, a security risk or corrupted state.","As described in the Background Section above, certain challenges arise when attempting to operate a computing environment in which more than one managed runtime can run concurrently in the same process and each is capable of independently reporting an application error. As described in that section, this may result in the generation of no error reports for a failure, or the generation of multiple error reports where at best only one of the error reports is useful. To address this issue, user machine  includes an in-process component denoted error reporting manager  that coordinates error reporting among managed runtimes -in a manner that does not require the managed runtimes to be aware of each other or to communicate directly with each other. By performing such coordination, error reporting manager  operates to ensure that if process  crashes, at most one error report will be generated by the managed runtime that caused the failure or the first managed runtime that encounters an error that does not come from any of managed runtimes in the process. By performing such coordination, error reporting manager  also operates to ensure that the managed runtime that caused the failure will claim the error and will generate the error reporting information if there is no other concurrent and different error being processed in the process. If there are two or more concurrent and different errors being processed in the process, the first managed runtime that is ready to report an error will report an error.","Because error reporting manager  performs this coordination in-process, it provides an approach to managing error reporting among multiple managed runtimes concurrently running in the same process in a manner that is not dependent on facilities built or added into a particular operating system. Thus, this approach to managing error reporting can conceivably be implemented on different systems running different versions of the same operating system, or different operating systems entirely.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 2"],"b":["132","132","132","132","202","204","206","208","210","212","214"]},"RegisterErrorClaimingCallback API  may be invoked by a managed runtime to register an error claiming callback with error reporting manager . In an embodiment, each managed runtime in a process will invoke RegisterErrorClaimingCallback API  to register an error claiming callback with error reporting manager  during startup of the managed runtime.","UnregisterErrorClaimingCallback API  may be invoked by a managed runtime to unregister an error claiming callback that was previously registered with error reporting manager . In an embodiment, each managed runtime in a process will invoke UnregisterErrorClaimingCallback API  during shutdown of the managed runtime to unregister an error claiming callback that was previously registered with error reporting manager .","HasErrorReportingBeenTriggered API  may be invoked by a managed runtime to determine whether error reporting has already been initiated for the process in which the managed runtime is running In one embodiment, responsive to the invocation of HasErrorReportingBeenTriggered API  by a managed runtime, error reporting manager  will return TRUE to the managed runtime if error reporting has already been initiated for the process and will return FALSE to the managed runtime if error reporting has not already been initiated for the process.","IsErrorClaimed API  may be invoked by a managed runtime to determine if an error that has been encountered by the managed runtime has been claimed by any other managed runtime concurrently running in the same process. In one embodiment, in response to invocation of this API by a managed runtime, error reporting manager  will iterate through all registered exception claiming callbacks, invoking a callback to each registered managed runtime. In response to the callback, each registered managed application will either return TRUE if it claims the error or FALSE if it does not claim the error. If any managed application returns TRUE, then error reporting manager will return TRUE to the managed runtime that invoked IsErrorClaimed API . However, if no managed application returns TRUE, then error reporting manager  will return FALSE to the managed runtime that invoked IsErrorClaimed API .","IsCurrentRuntimeAllowedToReportError API  may be invoked by a managed runtime to determine if the managed runtime is permitted to initiate the reporting of information about an error encountered and\/or claimed by the managed runtime. In an embodiment, in response to the invocation of IsCurrentRuntimeAllowedToReportError API  by a managed runtime, error reporting manager  will return FALSE to the managed runtime if error reporting has already been initiated for the process. If error reporting has not yet been initiated for the process, but two or more managed runtimes have concurrently called IsCurrentRuntimeAllowedtoReportError API , then error reporting manager  will return TRUE to one of the calling managed runtimes and return FALSE to all of the other calling managed runtimes. If error reporting has not yet been initiated for the process, and only one managed runtime has called IsCurrentRuntimeAllowedtoReportError API , then error reporting manager  will return TRUE to the calling managed runtime.","WaitForErrorReportingCompletionEvent API  may be invoked by a managed runtime to cause the managed runtime to suspend execution while waiting for the completion of error reporting for the process. In an embodiment, a managed runtime will invoke WaitForErrorReportingCompletionEvent API  in response to calling HasErrorReportingBeenTriggered API  and receiving TRUE from error reporting manager  or in response to calling IsCurrentRuntimeAllowedToReportError API  and receiving FALSE from error reporting manager . The suspension of execution of the managed runtime ensures that the managed runtime cannot initiate shutdown of the process in which it is running prior to the completion of error reporting. Error reporting manager  will only respond to this call when it has determined that error reporting has been completed for the process.","SignalErrorReportingCompletionEvent API  may be invoked by a managed runtime that has been allowed to perform error reporting when it has completed the error reporting process. In an embodiment, error reporting manager  will respond to all pending calls to WaitForErrorReportingCompletionEvent API  only after SignalErrorReportingCompletionEvent API  is invoked by a managed runtime.","The foregoing APIs have been provided by way of example only. Persons skilled in the relevant art(s) will appreciate that other APIs may be provided to facilitate communication between managed runtimes -and error reporting manager . Furthermore, in other embodiment, means other than APIs may be used to enable communication between managed runtimes -and error reporting manager .","The manner in which error reporting manager  and managed runtimes -operate and interact to coordinate error reporting among the managed runtimes will now be further described. In particular,  collectively depict a flowchart  of a method by which error reporting manager  may operate to coordinate error reporting between managed runtimes -concurrently executing in process . Although the method of flowchart  is described herein in reference to components of example system , persons skilled in the relevant art(s) will readily appreciate that the method is not limited to that implementation and may be implemented by other systems or other components.","The steps of flowchart  are shown as being executed sequentially for ease of explanation only. It is to be understood that various steps shown in flowchart  may be executed concurrently. For example, in an embodiment in which user machine  comprises multiple processors or multiple processing cores, two or more steps of flowchart  may be concurrently executed by corresponding processors or processing cores.","As shown in , the method of flowchart  begins at step  in which startup of error reporting manager  occurs. In an embodiment, startup of error reporting manager  occurs automatically when the first managed runtime to execute within process  is loaded by operating system . After step , control then flows to decision step .","At decision step , error reporting manager  determines if a managed runtime running within process  is attempting to register an error claiming callback. In one embodiment, a managed runtime running within process  attempts to register an error claiming callback by calling RegisterErrorClaimingCallback API  and including a pointer back to the managed runtime as an argument to the API call. However, this is only an example, and other methods may be used to attempt to register an error claiming callback with error reporting manager .","If error reporting manager  determines at decision step  that no managed runtime running within process  is attempting to register an error claiming callback, then control flows to decision step . However, if error reporting manager  determines at decision step  that a managed runtime running within process  is attempting to register an error claiming callback, then error reporting manager  will register the error claiming callback as shown at step . In one embodiment, registering the error claiming callback comprises storing a pointer provided as an argument to RegisterErrorClaimingCallback API  in a table or other data structure managed by error reporting manager . However, this is only an example, and other methods may be used to register an error claiming callback provided by a managed runtime. After step , control then flows to decision step .","At decision step , error reporting manager  determines if a managed runtime running within process  is attempting to unregister a previously-registered error claiming callback. In one embodiment, a managed runtime running within process  attempts to unregister a previously-registered error claiming callback by calling UnregisterErrorClaimingCallback API . However, this is only an example, and other methods may be used to attempt to unregister an error claiming callback that was previously registered with error reporting manager .","If error reporting manager  determines at decision step  that no managed runtime running within process  is attempting to unregister a previously-registered error claiming callback, then control flows to decision step . However, if error reporting manager  determines at decision step  that a managed runtime running within process  is attempting to unregister a previously-registered error claiming callback, then error reporting manager  will unregister the previously-registered error claiming callback as shown at step . In one embodiment, unregistering the error claiming callback comprises removing a pointer to the managed runtime from a table or other data structure managed by error reporting manager . However, this is only an example, and other methods may be used to unregister a previously-registered error claiming callback. After step , control then flows to decision step .","At decision step , error reporting manager  determines if a managed runtime running within process  is attempting to determine whether or not error reporting has already been triggered for process . In one embodiment, a managed runtime attempts to determine whether or not error reporting has already been triggered for process  by calling HasErrorReportingBeenTriggered API . However, this is only an example, and other methods may be used to attempt to determine whether or not error reporting has already been triggered for process .","If error reporting manager  determines at decision step  that no managed runtime running within process  is attempting to determine whether or not error reporting has already been triggered for process , then control flows to decision step . However, if error reporting manager  determines at decision step  that a managed runtime running within process  is attempting to determine whether or not error reporting has already been triggered for process , then control flows to decision step .","At decision step , error reporting manager  determines whether or not error reporting has already been triggered for process . If error reporting manager  determines that error reporting has already been triggered for process , then error reporting manager  returns an indicator to that effect (e.g., \u201cTRUE\u201d) to the managed runtime attempting to retrieve such information as shown at step . If error reporting manager  determines at decision step  that error reporting has not already been triggered for process , then error reporting manager  returns an indicator to that effect (e.g., \u201cFALSE\u201d) to the managed runtime attempting to retrieve such information as shown at step . After the performance of step  or step , control then flows to decision step .","At decision step , error reporting manager  determines if a managed runtime running within process  is attempting to determine whether an error has been claimed by any other managed runtime running within process . In one embodiment, a managed runtime attempts to determine whether an error has been claimed by any other managed runtime running within process  by calling IsErrorClaimed API . However, this is only an example, and other methods may be used to attempt to determine whether an error has been claimed by any other managed runtime running within process .","If error reporting manager  determines at decision step  that no managed runtime running within process  is attempting to determine whether an error has been claimed by any other managed runtime running within process , then control flows to decision step  (shown in ). However, if error reporting manager  determines at decision step  that a managed runtime running within process  is attempting to determine whether an error has been claimed by any other managed runtime running within process , then control flows to step .","At step , error reporting manager  iterates through all registered error claiming callbacks, invoking the callback corresponding to each registered managed runtime. In response to the callback, each registered managed runtime will either return an indicator that indicates that the managed runtime claims ownership of the error (e.g., \u201cTRUE\u201d) or an indicator that indicates that the managed runtime does not claim ownership of the error (e.g., \u201cFALSE\u201d). Control then flows to decision step . Note that in an embodiment in which different steps of flowchart  may be performed concurrently, when step  is being performed by error reporting manager , the performance of steps  and  dealing with registering and unregistering error claiming callbacks will be blocked. Similarly, when step  or  is being performed, the performance of step  will be blocked.","At decision step , error reporting manager  determines whether any of the registered managed runtimes have returned an indicator that indicates that the error has been claimed (e.g., \u201cTRUE\u201d). If error reporting manager  determines that a registered managed runtime has returned an indicator that indicates that the error has been claimed, then error reporting manager  will return an indicator that indicates that the error has been claimed (e.g., \u201cTRUE\u201d) to the managed runtime seeking such information as shown at step . However, if error reporting manager  determines that no registered managed runtime has returned an indicator that indicates that the error has been claimed, then error reporting manager  will return an indicator that indicates that the error has not been claimed (e.g., \u201cFALSE\u201d) to the managed runtime seeking such information as shown at step . After the performance of step  or step , control then flows to decision step  (shown in ).","At decision step , error reporting manager  determines if a managed runtime running within process  is requesting permission to report an error. In an embodiment, a managed runtime requests permission to report an error by calling IsCurrentRuntimeAllowedToReportError API . However, this is only an example, and other methods may be used to attempt to determine whether an error has been claimed by any other managed runtime running within process .","If error reporting manager  determines at decision step  that no managed runtime running within process  is requesting permission to report an error, then control flows to decision step . However, if error reporting manager  determines at decision step  that a managed runtime running within process  is requesting permission to report an error, then control flows to decision step .","At decision step , error reporting manager  determines whether or not error reporting has already been triggered for process . If error reporting manager  determines that error reporting has already been triggered for process , then error reporting manager  returns an indicator (e.g., \u201cFALSE\u201d) to the managed runtime requesting permission to report an error that indicates that the managed runtime is not permitted to report the error as shown at step . If error reporting manager  determines at decision step  that error reporting has not already been triggered for process , then control flows to decision step , in which error reporting manager  determines if other managed runtimes running within process  are concurrently requesting permission to report an error. In one embodiment, error reporting manager  performs this function by determining whether multiple concurrent calls to IsCurrentRuntimeAllowedToReportError API  have been received. However, this is only an example, and error reporting manager  may use other methods for determining whether multiple managed runtimes running within process  are concurrently requesting permission to report an error.","If error reporting manager  determines during decision step  that there are no concurrent error reporting requests, then error reporting manager  returns an indicator (e.g., \u201cTRUE\u201d) to the managed runtime requesting permission to report an error that indicates that the managed runtime is permitted to report the error as shown at step . However, if error reporting manager  determines during decision step  that there are concurrent error reporting requests from different managed runtimes, then error reporting manager  will return an indicator (e.g., \u201cTRUE\u201d) to only one of the managed runtimes requesting permission to report an error that indicates that the managed runtime is permitted to report the error and will return a different indicator (e.g., \u201cFALSE\u201d) to all the other managed runtime(s) requesting permission to report an error that indicates that the other managed runtime(s) are not permitted to report the error as shown at step . This step ensures that even if different managed runtimes executing on different threads are requesting permission to report an error that only a single managed runtime will be permitted to report an error, and thus only a single error report will be produced for process .","Various methods may be used by error reporting manager  to determine which one of the multiple managed runtimes requesting permission to report an error will receive permission to report. Such a determination may be made in a logical or arbitrary fashion. For example, in one embodiment, error reporting manager  grants permission to the requesting managed runtime that first notified error reporting manager  of an error.","After completion of step , step  or step , control then flows to decision step .","At decision step , error reporting manager  determines if a managed runtime running within process  is requesting to wait for the completion of error reporting for process . In an embodiment, a managed runtime requests to wait for the completion of error reporting by calling WaitForErrorReportingCompletionEvent API . However, this is only an example, and other methods may be used by a managed runtime to request to wait for the completion of error reporting. A managed runtime may request to wait for completion of error reporting in response to being notified by error reporting manager  that error reporting has already been triggered for process  during step  or in response to being denied permission to perform error reporting during steps  or  as previously described.","If error reporting manager  determines at decision step  that no managed runtime running within process  is requesting to wait for the completion of error reporting for process , then control flows to decision step . However, if error reporting manager  determines at decision step  that a managed runtime running within process  is requesting to wait for the completion of error reporting for process , then control flows to decision step .","At decision step , error reporting manger  determines if a managed runtime running within process  has notified error reporting manager  that it has completed error reporting for process . In one embodiment, a managed runtime running within process  notifies error reporting manager  that it has completed error reporting for process  by calling SignalErrorReportingCompletionEvent API . However, this is only an example and other methods may be used by a managed runtime to notify error reporting manager  that it has completed error reporting for process .","If error reporting manager  determines during decision step  that no managed runtime running within process  has notified error reporting manager  that it has completed error reporting for process , then error reporting manager  will not respond to the call from the managed runtime requesting to wait for the completion of error reporting and will continue to check if another managed runtime has reported the completion of error reporting. The failure to respond to the call from the requesting managed runtime has the effect of suspending the execution of the requesting managed runtime, thereby ensuring that the requesting managed runtime cannot initiate termination of process  prior to the completion of error reporting. It is noted that this is only one example of a mechanism for suspending the execution of the requesting managed runtime and that other mechanisms may be used.","However, if error reporting manager  determines during decision step  that a managed runtime running within process  has notified error reporting manager  that it has completed error reporting for process , then error reporting manager  will respond to the call from the managed runtime requesting to wait for the completion of error reporting as shown at step . This will have the effect of causing the execution of the requesting managed runtime to resume, thereby allowing the requesting managed runtime to initialize a managed runtime termination procedure. It is noted that this is only one example of a mechanism for causing the execution of the requesting managed runtime to resume and that other mechanisms may be used. After step , control flows to decision step .","At decision , error reporting manager  determines if process  is about to terminate. If error reporting manager  determines that process  is not about to terminate, then control flows back to decision step  (shown in ). However, if error reporting manager  determines that process  is about to terminate, then error reporting manager  will shut down as shown at step .","The manner in which error reporting manager  and managed runtimes -operate and interact to coordinate error reporting among the managed runtimes will now be further described in reference to flowchart  of . In particular,  depicts a flowchart  of steps taken by a managed runtime, such as any of managed runtimes -, to facilitate coordinated error reporting. The managed runtime discussed in  will be denoted managed runtime , although it may represent any one of managed runtimes -. Although the method of flowchart  is described herein in reference to components of example system , persons skilled in the relevant art(s) will readily appreciate that the method is not limited to that implementation and may be implemented by other systems or other components.","As shown in , the method of flowchart  begins at step  in which startup of managed runtime  occurs within process . In an embodiment, operating system  is prompted to initiate managed runtime  responsive to the execution of a managed application that requires managed runtime  to operate. After step , control then flows to step .","Note that, in one embodiment, error reporting manager  is initialized by the first instance of managed runtime  that is loaded within process  during startup of that managed runtime. This occurs before any managed runtime can interact with error reporting manager .","At step , responsive to the startup of managed runtime , managed runtime  registers an error claiming callback with error reporting manager . In one embodiment, managed runtime  registers the error claiming callback by calling RegisterErrorClaimingCallback API  and including a pointer back to managed runtime  as an argument to the API call. However, this is only an example, and other methods may be used by managed runtime  to register an error claiming callback with error reporting manager . After step , control then flows to decision step .","At decision step , managed runtime  determines whether an error has occurred. As will be appreciated by persons skilled in the relevant art(s), various mechanisms exist by which managed runtime  may encounter an error. For example, managed runtime  may own the base of a thread on which an unhandled exception is encountered and may be notified of the unhandled exception by exception management logic running on user machine  that has worked its way up the thread searching for an exception handler. Alternatively, operating system  may be notified of an unhandled exception and report the unhandled exception to a set of registered modules that includes managed runtime . These are only examples, and there may be other mechanisms or means by which managed runtime  may determine that an error has occurred. Furthermore, it is noted that the term \u201cerror\u201d as used herein is not limited to unhandled exceptions, but is intended to broadly represent any condition that would require an unexpected or abnormal termination of a managed runtime or application.","If managed runtime  determines at decision step  that no error has occurred, then control flows to decision step . At decision step , managed runtime  determines if managed runtime  is about to terminate. Such termination may occur, for example, in response to the orderly shutdown of a managed application that relies on managed runtime  for execution or in response to an error that causes an unexpected or abnormal termination of managed runtime  and\/or any managed application that managed runtime  was invoked to support.","If managed runtime  is not about to terminate, then control returns to decision step . However, if managed runtime  is about to terminate then control flows to step , in which managed runtime  unregisters its previously-registered error claiming callback with error reporting manager . In one embodiment, managed runtime  unregisters its previously-registered error claiming callback with error reporting manager  by calling UnregisterErrorClaimingCallback API . However, this is only an example, and other methods may be used by managed runtime  to unregister its previously-registered error claiming callback with error reporting manager . After step , control then flows to step , in which managed runtime  is shutdown.","Note that, in one embodiment, error reporting manager  will be shut down after the last instance of managed runtime  unregisters its error claiming callback.","If managed runtime  determines during decision step  that an error has occurred, then control flows to decision step . During decision step , managed runtime  communicates with error reporting manager  to determine if error reporting has already been initiated for process . Such error reporting may have been initiated, for example, by a different managed runtime executing on a different thread of execution. In one embodiment, managed runtime  communicates with error reporting manager  to determine if error reporting has already been initiated for process  by calling HasErrorReportingBeenTriggered API  and then, in response to calling the API, receiving an indicator from error reporting manager  that indicates either that error reporting has already been initiated (e.g., \u201cTRUE\u201d) or that error reporting has not already been initiated (e.g., \u201cFALSE\u201d). However, this is only an example, and other methods may be used by managed runtime  to communicate with error reporting manager  to determine whether or not error reporting has already been initiated for process .","If managed runtime  determines during decision step  that error reporting has already been initiated for process , then control flows to step . During step , managed runtime  sends a request to error reporting manager  to wait for the completion of error reporting for process . In response to sending the request, error reporting manager  causes the execution of managed runtime  to be suspended until another managed runtime has notified error reporting manager  that error reporting is complete. This step ensures that managed runtime  cannot initiate termination of process  until error reporting has completed. In an embodiment, managed runtime  sends a request to error reporting manager  to wait for the completion of error reporting for process  by calling WaitForErrorReportingCompletionEvent API  and error reporting manager  causes the execution of managed runtime  to be suspended by not returning a response to the API call until another managed runtime has notified error reporting manager  that error reporting is complete (e.g. via a call to SignalErrorReportingCompletionEvent API ). However, this is only an example, and other methods may be used by managed runtime  to send a request to error reporting manager  to wait for the completion of error reporting and by error reporting manager  to cause the execution of managed runtime  to be suspended until error reporting is complete.","After step , control flows to step , in which managed runtime  unregisters its previously-registered error claiming callback with error reporting manager , and then to step , in which managed runtime  is shutdown.","If managed runtime  determines during decision step  that error reporting has not already been initiated for process , then control flows to decision step . During decision step , managed runtime  determines whether it has caused the error. If managed runtime  determines during decision step  that it has caused the error, then control flows to step .","During step , managed runtime  sends a request for permission to report the error to error reporting manager . In one embodiment, managed runtime  sends a request for permission to report the error to error reporting manager  by calling IsCurrentRuntimeAllowedToReportError API . However, this is only an example, and other methods may be used by managed runtime  to send a request for permission to report the error to error reporting manager . After step , control flows to decision step .","During decision step , managed runtime  determines if the request for permission sent to error reporting manager  during step  has been granted. In one embodiment, managed runtime  determines that the request for permission has been granted if error reporting manager  returns an indicator indicating that permission has been granted (e.g., \u201cTRUE\u201d) in response to calling IsCurrentRuntimeAllowedToReportError API  and determines that the request for permission has been denied if error reporting manager  returns an indicator indicating that permission has been denied (e.g., \u201cFALSE) in response to calling IsCurrentRuntimeAllowedtoReportError API . However this is only an example and managed runtime  may use other methods to determine if the request for permission sent to error reporting manager  during step  has been granted.","In one embodiment, error reporting manager  will deny permission if error reporting has already been triggered for process . In further accordance with such an embodiment, if error reporting has not already been triggered for process , but two or more managed runtimes are concurrently requesting permission to report an error, then error reporting manager  will grant permission to only one of the calling managed runtimes and deny permission to all of the other calling managed runtimes. In still further accordance with such an embodiment, if error reporting has not already been triggered for process , but only one managed runtime is requesting permission to report an error, then error reporting manager  will grant permission to the calling managed runtime. This approach to granting\/denying permission ensures that at most one error report will be generated for process .","If managed runtime  determines during decision step  that permission has not been granted to report the error, then control flows to step , in which managed runtime  waits for error reporting for process  to complete, then to step , in which managed runtime  unregisters its previously-registered error claiming callback with error reporting manager , and finally to step , in which managed runtime  is shutdown.","If managed runtime  determines during decision step  that permission has been granted to report the error then control flows to steep  in which managed runtime  reports the error. Reporting the error may comprise, for example, providing information about the error to error reporting service  in operating system . After step  is complete, managed runtime  signals error reporting manager  that error reporting is complete as shown at step . This enables error reporting manager  to cause any other managed runtimes within process  that are in a state of suspended execution pending the completion of error reporting for process  to resume execution. In one embodiment, managed runtime  signals error reporting manager  that error reporting is complete by calling SignalErrorReportingCompletionEvent API . However, this is only an example, and other methods may be used by managed runtime  to signal error reporting manager  that error reporting is complete.","After step , control flows to step , in which managed runtime  unregisters its previously-registered error claiming callback with error reporting manager , and then to step , in which managed runtime  is shutdown.","Returning now to decision step , if managed runtime  determines during that step that the error was not caused by itself, then control flows to decision step . During decision step , managed runtime  communicates with error reporting manager  to determine if any other managed runtime running within process  has claimed ownership of the error. In one embodiment, managed runtime  communicates with error reporting manager  to determine if any other managed runtime running with process  has claimed ownership of the error by calling IsErrorClaimed API . In response to the calling of this API by managed runtime , error reporting manager  will either return an indicator that indicates that another managed runtime has claimed ownership of the error (e.g., \u201cTRUE\u201d) or an indicator that indicates that no other managed runtime has claimed ownership of the error (\u201cFALSE\u201d). However, this is only an example, and other methods may be used by managed runtime  to communicate with error reporting manager  to determine if any other managed runtime running within process  has claimed ownership of the error.","If managed runtime  determines during decision step  that the error has been claimed by another managed runtime running within process , then managed runtime  will ignore the error as shown at step , after which control returns to decision step . This allows error dispatching logic within operating system  to subsequently invoke the appropriate error-claiming managed runtime, which will then perform at least a portion of the protocol shown in flowchart  for facilitating coordinated error reporting. In an alternative embodiment, rather than ignoring the error in step , managed runtime  may directly invoke the appropriate error-claimed managed runtime, which will then perform at least a portion of the protocol shown in flowchart  for facilitating coordinated error reporting and then go to step  once error reporting is complete.","However, if managed runtime  determines during decision step  that the error has not been claimed by another managed runtime running within process , then managed runtime  will request permission to report the error as shown at step . Step  may be performed in a like fashion to step  as previously described.","After step , control then flows to decision step . As previously described, during decision step , managed runtime  determines if the request for permission sent to error reporting manager  has been granted.","As was previously described, if managed runtime  determines during decision step  that permission has not been granted to report the error, then control flows to step , in which managed runtime  waits for error reporting for process  to complete, then to step , in which managed runtime  unregisters its previously-registered error claiming callback with error reporting manager , and finally to step , in which managed runtime  is shutdown.","As also was previously described, if managed runtime  determines during decision step  that permission has been granted to report the error then control flows to step  in which managed runtime  reports the error. After step  is complete, managed runtime  signals error reporting manager  that error reporting is complete at step .","After step , control flows to step , in which managed runtime  unregisters its previously-registered error claiming callback with error reporting manager , and then to step , in which managed runtime  is shutdown.","Execution of the foregoing method of flowchart  as described above in reference to  by error reporting manager  and the foregoing method of flowchart  as described above in reference to  by each managed runtime concurrently executing in process  will advantageously ensure that if process  crashes, at most one error report will be generated by the managed runtime that caused the failure or the first managed runtime that encounters an error that does not come from any of managed runtimes in the process. Execution of the foregoing methods by error reporting manager  and each managed runtime concurrently executing in process  will also advantageously ensure that the managed runtime that caused the failure will claim the error, and will generate the error reporting information if there is no other concurrent and different error being processed in the process. If there are two or more concurrent and different errors being processed in the process, the first managed runtime that is ready to report an error will report an error.","III. Example Computer System Implementation",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 5","FIG. 1"],"b":["500","100","500","500","500","500","500"]},"As shown in , computer  includes a processing unit , a system memory , and a bus  that couples various system components including system memory  to processing unit . Processing unit  may comprise one or more processors or processing cores. Bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. System memory  includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS) is stored in ROM .","Computer  also has one or more of the following drives: a hard disk drive  for reading from and writing to a hard disk, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM, DVD ROM, or other optical media. Hard disk drive , magnetic disk drive , and optical disk drive  are connected to bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer-readable instructions, data structures, program modules and other data for the computer. Although a hard disk, a removable magnetic disk and a removable optical disk are described, other types of computer-readable media can be used to store data, such as flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROM), and the like.","A number of program modules may be stored locally on the hard disk, magnetic disk, optical disk, ROM, RAM or FLASH, or remotely on network storage in a LAN or WAN such as the Internet. These programs include an operating system , one or more application programs , other program modules , and program data . Operating system  may represent operating system  shown in  and thus may include error reporting service . Application programs  or program modules  may include, for example, logic representative of managed runtimes -, managed applications -, and\/or error reporting manager . Thus, when executed, these application programs  or program modules  can perform methods such as those described above in reference to flowchart  of  or flowchart  of .","A user may enter commands and information into the computer  through input devices such as keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game controller, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to bus , but may be connected by other interfaces, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device is also connected to bus  via an interface, such as a video adapter . In addition to the monitor, computer  may include other peripheral output devices (not shown) such as speakers and printers.","Computer  is connected to a network  (e.g., a local area network or wide area network such as the Internet) through a network interface or adapter , a modem , or other means for establishing communications over the network. Modem , which may be internal or external, is connected to bus  via serial port interface .","As used herein, the terms \u201ccomputer program medium\u201d and \u201ccomputer-readable medium\u201d are used to generally refer to media such as the hard disk associated with hard disk drive , removable magnetic disk , removable optical disk , as well as other media such as flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROM), and the like.","As noted above, computer programs and modules (including application programs  and other program modules ) may be stored on the hard disk, magnetic disk, optical disk, ROM, or RAM. Such computer programs may also be received via network interface  or serial port interface . Such computer programs, when executed or loaded by an application, enable computer  to implement features of embodiments discussed herein. Accordingly, such computer programs represent controllers of the computer .","Embodiments are also directed to computer program products comprising software stored on any computer useable medium. Such software, when executed in one or more data processing devices, causes a data processing device(s) to operate as described herein. Embodiments may employ any computer-useable or computer-readable medium, known now or in the future. Examples of computer-readable mediums include, but are not limited to storage devices such as RAM, hard drives, floppy disks, CD ROMs, DVD ROMs, zip disks, tapes, magnetic storage devices, optical storage devices, MEMS-based storage devices, nanotechnology-based storage devices, and the like.","IV. Conclusion","While various embodiments have been described above, it should be understood that they have been presented by way of example only, and not limitation. It will be apparent to persons skilled in the relevant art(s) that various changes in form and details can be made therein without departing from the spirit and scope of the invention. Thus, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS\/FIGURES","p":["The accompanying drawings, which are incorporated herein and form part of the specification, illustrate embodiments of the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the relevant art(s) to make and use the invention.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
