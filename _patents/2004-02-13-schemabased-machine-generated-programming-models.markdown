---
title: Schema-based machine generated programming models
abstract: A programming model that takes general purpose APIs and machine-generates new programming models based on user defined schemas that provide the developer with data and view separation, and a way to communicate to the host application using the domain of the problem being solved. The system comprises a schema component that the developer uses to define a schema that includes one or more domain terms related to the problem to be solved, and a mapping component that uses the schema to search and map selected constructs from one or more generic host application APIs to the corresponding problem domain terms. Once the mapping is completed, a generating component generates a new API that is used by a host application to facilitate developing an application document using terms related to the domain of the problem to be solved.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07694315&OS=07694315&RS=07694315
owner: Microsoft Corporation
number: 07694315
owner_city: Redmond
owner_country: US
publication_date: 20040213
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention is related to software development architectures.","Today when a developer wants to write a program customization that extends the functionality of another program (a host), the developer must use an API (Application Program Interface) exposed by that host. This often forces the developer into dealing with things on a level understood by the host program, such as cell addresses for a spreadsheet or paragraph numbers for a word processor. This creates code that is difficult to read and maintain, since it is difficult to attach any meaning to such general constructs.","These host APIs are generic to allow maximum flexibility in the customizations that will be written against that host. The APIs also use the vocabulary of the host application, which is generic and does not typically match the terminology of, for example, the business problem being solved by the specific program customization. A customization written against the word processor API might use API objects such as \u201cBookmark\u201d and \u201cTable\u201d, while a customization written against a spreadsheet API might use API objects like \u201cRange\u201d and \u201cList\u201d.","However, the customization developer might be writing an Expense Reporting customization and would prefer using terminology from that problem domain such as \u201cEmployee\u201d, \u201cExpense\u201d, \u201cE-Mail Address\u201d, etc. For example, consider that a programmer wants to write code that runs against a spreadsheet containing an expense report that detects when a cell containing the employee e-mail address is edited. When the e-mail address is edited, the programmer wants the application to automatically lookup the employee's employee ID and put it into another cell in the worksheet. Conventionally, the code a developer would write using the API of the spreadsheet is very generic and does not have any reference to the names or terminology in the domain of the problem being solved. Instead of talking in terms of employee e-mail address, and employee ID, the developer is forced to talk in terms of the generic spreadsheet object model and use generic objects such as Range (which represents a range of cells) and cell addresses that represent the column and row of a cell of interest.","What is needed is an improved programming model that uses the terminology of the problem being solved.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key\/critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The present invention disclosed and claimed herein, in one aspect thereof, comprises a programming model that allows a developer to create a schema and then map the elements of the schema to constructs understood by the host APIs. Essentially, the invention takes the general purpose host APIs such as those exposed by a word processing application and\/or a spreadsheet application, for example, and machine-generates new programming models based on a user defined schema. The schema provides the developer with separation of data and view, and a way to communicate to the host application using the domain terminology of the problem being solved (e.g., Customer, E-Mail, and ID, instead of cell addresses or paragraph numbers). This allows the developer to write code that is expressed in terms of the concepts being utilized and leads to much more understandable and maintainable code.","In support there of, there is provided a system that includes a schema component that the developer uses to define one or more domain terms related to the problem to be solved. The schema component interfaces to a mapping component, which mapping component uses information provided by the developer to search and map selected constructs from one or more generic host application APIs to the corresponding problem domain terms. Once the mapping is completed, the system employs a generating component to use the mapping information from the mapping component to generate a new API. The new API is then used by a host application to facilitate developing an application document using terms related to the domain of the problem to be solved.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative, however, of but a few of the various ways in which the principles of the invention may be employed and the present invention is intended to include all such aspects and their equivalents. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The present invention is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate describing the present invention.","As used in this application, the terms \u201ccomponent\u201d and \u201csystem\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","Referring now to , there is illustrated a system  of the present invention. The system  includes a schema component  that the developer uses to define one or more domain terms related to the problem to be solved. The schema component  interfaces to a mapping component , which mapping component  uses information provided by the developer to search and map selected constructs from one or more generic host application APIs (Application Program Interfaces)  to the corresponding problem domain terms. Once the mapping is completed, the system  employs a generating component  to use the mapping information from the mapping component  to generate a new API . The new API  is then used by a host application to facilitate developing an application document using terms related to the domain of the problem to be solved.","As indicated, the schema component  can include schema elements that are associated with constructs from a single generic API , or from more than one of the generic APIs  (also denoted API, API, . . . , API). Note that the schema component  can also interface to the generating component  such that the generating component  uses the schema information and the mapping information from the mapping component to generate the new API . Additionally, it is to be appreciated that the schema and mapping components ( and ) can be combined into a single component, or further, combined with the generating component  in order to facilitate creation of the new API  in accordance with the present invention.","Referring now to , there is illustrated a flow chart of extending the functionality of an application in accordance with the present invention. While, for purposes of simplicity of explanation, the one or more methodologies shown herein, e.g., in the form of a flow chart, are shown and described as a series of acts, it is to be understood and appreciated that the present invention is not limited by the order of acts, as some acts may, in accordance with the present invention, occur in a different order and\/or concurrently with other acts from that shown and described herein. For example, those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events, such as in a state diagram. Moreover, not all illustrated acts may be required to implement a methodology in accordance with the present invention.","At , the developer defines terminology of the problem domain. At , the constructs in the generic host APIs that correspond to the domain terminology are determined. At , the constructs are mapped to the corresponding domain terms. At , the new API is generated based on the mappings of the domain schema and the constructs. At , the new API is used by the host application to facilitate document development by the developer using terms related to the problem to be solved. The process then reaches a Stop block.","Referring now to , there is illustrated a block diagram of a system  that maps constructs from one or more of the generic APIs for use in generating the new API. In this implementation, the system  embodies a schema component  internal to a mapping component . The schema component includes a schema of problem terms (denoted as PROBTERM, PROBTERM, . . . , PROBTERM) that are predefined by the developer that relate to the problem to be solved. The mapping component  interfaces to a plurality of the generic APIs  (denoted Generic API, . . . , Generic API) each having a plurality of generic constructs. The first generic API  includes a plurality of generic constructs denoted CONSTRUCT, CONSTRUCT, . . . , CONSTRUCT. The last generic API  (denoted Generic API) also can includes a plurality of generic constructs denoted CONSTRUCT, CONSTRUCT, . . . , CONSTRUCT.","The disclosed architecture allows the developer to search and use generic constructs from any of the plurality of generic APIs . Here, the mapping is between PROBTERMand CONSTRUCT, CONSTRUCTand PROBTERM, and CONSTRUCTand PROBTERM. Note that many more mappings can be made.","The output of the mapping component  is to the generator  to further output the new API .","The disclosed architecture is not restricted to a word processing application and a spreadsheet application, but can be applied to many other types of applications, including, but not limited to ACCESS brand database software, FRONTPAGE brand website design and development software, POWERPOINT brand presentation graphics software, PROJECT brand project management software, PUBLISHER brand publication software, VISIO brand drawing software, ONENOTE brand note management software, and INTERNET EXPLORER brand browser and communication software.","Referring now to , there is illustrated a block diagram of a relationship of the host, view and data models, in accordance with the present invention. The host object model  is available for host compatibility and control. The view model  interfaces to the host model  via a view control hookup mechanism. The data model  interfaces to host object model  through the view model  via data binding to the view model . The view model  and data model  are schema-oriented models specific to the application being created. Sample code for each illustrates the relationships.","Host Model",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim w as Worksheet"]},{"entry":[{},"w = ThisWorkBook.Sheets(2)"]},{"entry":[{},"w.Range(\u201c$F$11\u201d).Value2= 12345"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"View Model",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CustomerIDCell.Value2 = 12345"]},{"entry":[{},"CustomerIDCell.Font.Bold = True"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Data Model",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Customer.ID = 12345"]},{"entry":[{},"Customers[0].FirstName = \u201cJohn\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Following is a sample coding illustrates the relationship between the view model  and the host object model .",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"ExpenseReportView.Customer.ID.Font.Name"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The code \u201cExpenseReportView.Customer. ID\u201d is the portion generated from user-defined schema. The period (.) after \u201cID\u201d is the connection between the generated view model to the correct host object model object made by using the schema to the host view element mapping information. The code \u201cFont.Name\u201d is a property provided by the spreadsheet application specific object model. Font is a property of the Range object that represents a cell.","Referring now to , there is illustrated a flow chart for building the relationship of . At , the generic host model is received. This occurs with any host application that provides generic APIs. At , the view model is constructed. At , the view model is interfaced to the host model using a view control mechanism. At , the data model is constructed. At , the data model is interfaced indirectly to the host model though the view model via data binding to the view model. The process then reaches a Stop block.","Today when a developer wants to write a program (customization) that extends the functionality of another program (host), the developer must use the API exposed by that host. For example, consider that a programmer wants to write code that runs against a spreadsheet containing an expense report that detects when a cell containing the employee's e-mail address is edited. When the e-mail address is edited, the programmer wants to automatically lookup the employee's employee ID and put it into another cell in the worksheet. The code a developer would write using the generic API of the spreadsheet might look like this.",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Public Sub Spreadsheet_OnChange(changedRange As Range)"]},{"entry":[{},"\u2003\u2003If (changedRange.Address = \u201c$A$4\u201d) Then"]},{"entry":[{},"\u2003\u2003\u2003\u2003changedRange.Value2 ="]},{"entry":[{},"GetIDFromEMailAlias(Spreadsheet.Range(\u201c$B$1\u201d))"]},{"entry":[{},"\u2003\u2003End If"]},{"entry":[{},"End Sub"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This code is very generic and does not have any reference to the names in the domain of the problem being solved. Instead of talking in terms of employee e-mail address, and employee ID, the user is forced to talk in terms of the generic spreadsheet object model and use generic objects such as Range (that represents a range of cells) and cell addresses that represent the column and row of a cell of interest. Here, \u201c$A$4\u201d refers to the cell with the employee's e-mail address, and \u201c$B$1\u201d refers to the cell with the employee's employee ID.","The disclosed invention utilizes generic, general purpose APIs and machine-generates new programming models based on user defined schemas that provide the developer with data and view separation, and a way to communicate to the host application using the domain of the problem being solved (e.g., Customer, EMail, and ID, instead of Range (\u201c$B$1\u201d).","The disclosed architecture allows the developer to write code that functionally does the same thing as the prior example, but with naming in terms of the problem being solved, as included in the following sample code.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Public Sub EmployeeEmail_OnChange( )"]},{"entry":[{},"\u2003\u2003Employee.ID = GetIDFromEMailAlias(Employee.Email)"]},{"entry":[{},"End Sub"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Referring now to , there is illustrated a traditional expense report spreadsheet  with customer information defined according to the problem to be solved. The spreadsheet  will be used as a basis for describing an implementation of view and data models in the following figures. Consider this portion of an expense report spreadsheet shown in . From the perspective of the host, there is a collection of cells that contain text and formatting information. Some of that text has type constraints on it and some of the text contains formulas that manipulate the contents of other cells, but fundamentally, it is a collection of cells.","A spreadsheet model of the cells of  could look something like the following, as represented partially in XML (eXtensible Markup Language):",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Cell ID=\u201c$A$1\u201d value=\u201c\u201d backColor=\u201cwhite\u201d fontName=\u201cArial\u201d>"},{"entry":"<Cell ID=\u201c$B$1\u201d value=\u201c\u201d backColor=\u201cwhite\u201d fontName=\u201cArial\u201d>"},{"entry":"<Cell ID=\u201c$C$1\u201d value=\u201c\u201d backColor=\u201cwhite\u201d fontName=\u201cArial\u201d>"},{"entry":"<Cell ID=\u201c$D$1\u201d value=\u201c\u201d backColor=\u201cwhite\u201d fontName=\u201cArial\u201d>"},{"entry":"<Cell ID=\u201c$A$2\u201d value=\u201c\u201d backColor=\u201cwhite\u201d fontName=\u201cArial\u201d>"},{"entry":"<Cell ID=\u201c$B$2\u201d value=\u201cNAME:\u201d backColor=\u201cwhite\u201d"},{"entry":"fontName=\u201cArial\u201d>"},{"entry":"<Cell ID=\u201c$C$2\u201d value=\u201cJohn Doe\u201d backColor=\u201cwhite\u201d"},{"entry":"fontName=\u201cArial\u201d>"},{"entry":"<Cell ID=\u201c$D$2\u201d value=\u201c\u201d backColor=\u201cwhite\u201d fontName=\u201cArial\u201d>"},{"entry":"..."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As indicated, the host model is very generic and broad to allow any type of application to be written, and does not present to the developer the notion that an expense report is being developed.","Following is a schema-based machine generated programming model for data. The developer now naturally sees the expense report in terms of the data being represented. For example, the developer's model of the data in the spreadsheet above could look like this, as represented in XML:",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<ExpenseReport>"]},{"entry":[{},"\u2003\u2003<Employee>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Name>John Doe<\/Name>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Email>jdoe@company.com<\/Email>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<EmployeeNumber>100231<\/EmployeeNumber>"]},{"entry":[{},"\u2003\u2003<\/Employee>"]},{"entry":[{},"\u2003\u2003<Purpose>Very important conference<\/Purpose>"]},{"entry":[{},"\u2003\u2003<Expenses>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Expense>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<Date>1-Jan<\/Date>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<Description>Dinner<\/Description>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<Cost>20.00<\/Cost>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/Expense>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Expense>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<Date>2-Jan<\/Date>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<Description>Breakfast<\/Description>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<Cost>10.00<\/Cost>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/Expense>"]},{"entry":[{},"\u2003\u2003<\/Expenses>"]},{"entry":[{},"<\/ExpenseReport>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The data focused programmer does not care about the spreadsheet-specific implementation details such as the identifier \u201c$B$2\u201d. Furthermore, a developer focused on the data does not want to think about the details of the view such as the fact that the name cell is colored, for example, white, in this instance.","For the data focused programmer, the disclosed architecture allows the developer to use a data schema and write code in terms of that data schema, rather than use the generic host API. The data focused programmer needn't think much about the view or the host API. All that is required is a design time mapping that indicates how specific instances of schematized data are mapped to application host view elements such as a cell. The developer would generate the mapping at design time (using tools) that allows generation of a new programming model. For example, the developer might create a mapping such as the following, that maps the elements from the data model (e.g., Employee Name) to generic identifiers recognized by the host (e.g., $C$2).",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\\\\ExpenseReport\\Employee\\Name->$C$2"]},{"entry":[{},"\\\\ExpenseReport\\Employee\\Email->$C$3"]},{"entry":[{},"\\\\ExpenseReport\\Employee\\EmployeeNumber->$C$4"]},{"entry":[{},"\\\\ExpenseReport\\Employee\\Purpose->$C$5"]},{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Given a data schema and mapping, a new API is generated that mirrors the data schema. The developer of the expense report can now write code against this schema-based machine generated programming model. For example, these lines of code will change the cell $C$3 to contain the name \u201cFred Smith\u201d and the cell $C$4 to contain the e-mail address \u201cfsmith@company.com\u201d. The developer using this generated programming model no longer needs to know details about the host API such as the fact that it uses an object called \u201cRange\u201d or identifies cells with the moniker \u201c$A$4\u201d.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ExpenseReport.Employee.Name = \u201cFred Smith\u201d"]},{"entry":[{},"ExpenseReport.Employee.Email = \u201cfsmith@company.com\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The developer can also take advantage of specific features of the view in an application by utilizing the view programming model. For example, consider that the developer chooses to set ExpenseReport.Employee.Name to \u201cFred\u201d and wants to set the font being used to display \u201cFred\u201d to bold. The level of abstraction can be increased until the programmer is manipulating concepts in the appropriate realm.","In the present invention the view abstraction and the data abstraction are built on top of the underlying host abstraction. The view abstraction allows the view developer to refer to a spreadsheet range based on its meaning within the domain of the view (e.g., to refer to a range as \u201cNameField\u201d rather than \u201cField(\u201c$B$2\u201d)). Essentially, view data is just more schematized data to be bound to host API objects. A view developer naturally sees the expense report in terms of the view being represented. For example, the developer's model of the view in the spreadsheet above might look like this, represented partially in XML:",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<ExpenseReportView>"]},{"entry":[{},"\u2003<NameLabel>"]},{"entry":[{},"\u2003\u2003<Text>Name:<\/Text>"]},{"entry":[{},"\u2003\u2003<BackColor>White<\/BackColor>"]},{"entry":[{},"\u2003<\/NameLabel>"]},{"entry":[{},"\u2003<NameField>"]},{"entry":[{},"\u2003\u2003<Text>John Doe<\/Text>"]},{"entry":[{},"\u2003\u2003<BackColor>White<\/BackColor>"]},{"entry":[{},"\u2003<\/NameField>"]},{"entry":[{},"\u2003<EMailLabel>"]},{"entry":[{},"\u2003\u2003<Text>E-Mail:<\/Text>"]},{"entry":[{},"\u2003\u2003<BackColor>White<\/BackColor>"]},{"entry":[{},"\u2003<\/EMailLabel>"]},{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Although there are similarities in this view schema to the host schema and API described earlier, the view schema using names that are in the domain of the problem being solved. Moreover, the view schema only names cells of interest, whereas the host schema and API name all cells.","For the view focused programmer, the developer can use a view schema to pull objects of interest out of vast collections of host API provided objects and turn these objects of interest into first class named objects called \u201cView Controls\u201d. All that is required is a design time mapping that indicates how specific instances of schematized data are mapped to application host API objects, such as a cell. The mapping allows the generation of a view programming model. For example, the mapping created could look the following, that maps the elements from the view model (e.g., NameLabel) to identifiers recognized by the host (e.g., $B$2).",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\\\\ExpenseReportView\\NameLabel->$B$2"]},{"entry":[{},"\\\\ExpenseReportView\\NameField->$C$2"]},{"entry":[{},"\\\\ExpenseReportView\\EMailLabel->$B$3"]},{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Given a view schema and mapping of the schema, a new view API is machine generated that mirrors the view schema. The developer of the expense report can now write code against this schema-based machine generated programming model. For example, these lines of code will change the cell $B$2 to be blue and the cell $B$3 to be green, yet the developer using this generated programming model no longer needs to know details about the host API such as the fact that it uses an object called \u201cRange\u201d or identifies cells with the moniker \u201c$A$4\u201d.",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ExpenseReportView.NameLabel.BackColor = Blue"]},{"entry":[{},"ExpenseReportView.NameField.BackColor = Green"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The machine-generated view API is a hybrid of the user defined view schema and the host provided API. For example, assume that NameLabel is mapped to a spreadsheet cell. The spreadsheet can already provide an object model for a Cell via a COM object that represents a cell. The development environment hooks the host specific object model to the leaf nodes of the generated from user defined view schema object model.","The data model connects indirectly to the host API via the view model. That is, the mapping for the data to connect to the host could look like the following.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\\\\ExpenseReport\\Employee\\Name->\\\\ExpenseReportView\\NameField->"},{"entry":"$C$2"},{"entry":"..."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The connection between data and view model is made via a data-binding mechanism that the developer can see in their code. To do this, any view control can be configured to be data bindable using the data binding functionality and syntax provided by data binding. Thus, a developer inspecting the machine generating programming model might see the following lines of code that hookup the schema based data programming model to the view (where the code connects the NameField view control to the Employee.Name data model item).",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ExpenseReportView.NameField.DataBindings.Add(\u201cText\u201d,"]},{"entry":[{},"EmployeeData, \u201cName\u201d)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"There are several reasons to keep data separate from the document content. Keeping the data in the document content requires that each data element be mapped to a document view element. In reality, there is often data that is desired to be maintained and manipulated, but not displayed or stored in the document content. For example, an employee ID may be desirable in the data model but not actually displayed it in the document contents or in the view model. Moreover, many applications have document file formats that are not transparent or are very difficult to retrieve data from if the host application is not running. Typically, the host application must be run to read or modify data that is contained in the document content. This is inefficient for scenarios such as server scenarios where a web page needs to quickly retrieve and display important data in a document but does not need or want to start the entire host application to get the data from the document.","Developers want to deal directly with data and not have to start the host application to read data from document content. Given a schema for the data in the document, the present invention automatically separates the data from the view by generating and saving a data island in the document that conforms to the data schema created by the developer. The data island can be accessed and modified on the server without having to start the host application.","Each time the document runs inside the host application, the contents of this data island are synchronized with the document contents. Additionally, the generated data model is connected to the data island so that the data model works directly against data. Changes to the data model are then moved into the document contents via the data binding mechanism to view controls that are described herein.","Referring now to , there is illustrated a different perspective of the programming model of the present invention. A spreadsheet  includes a Customer Information block  that presents customer information related to a customer ID, FirstName, LastName, Company, PhoneNumber, Address, and EMail address. These are the domain terms that the developer wants to use and are related to the problem to be solved. The developer creates a schema  of those domain terms. Here, the schema  is a file named Customer.xsd, which can be generated using an XML Schema Definition (XSD) language. Other suitable languages can also be used. The developer performs the mapping of the schema  to the corresponding cells  of the spreadsheet .","A data model  receives the customer schema information in the form of an XML file (i.e., Customer.xml) as a typed dataset. The customer.xml file is the data island referred to previously. The data model includes data that can be coded against on the client or the server. A view model  includes a view control (not depicted), which adds data binding support to the host object mode, that is created for each cell that has an XML element mapped to it. The developer then codes against the view control, data, data bindings, and host object model. The data model interfaces to the view model via two-way data binding.","Referring now to , there is illustrated a programming model as exposed to a developer. The cells  of the customer information block  are exposed to the developer in the form of a window  where each mapped cell is aliased out into the view programming model  as a named object (and as a data bindable control). The \u201cCustomers\u201d element is a data object that can be coded against on the client or the server.","In the data model , the Customer.xml file data can be projected to the developer as a typed dataset that is used to access embedded data in the document on the client or the server. Declarations in the file can be exposed to the developer in declarations window . A handler in the code behind the document for an event raised by a server object can access the data model (Customers) on the server, but not the view model (e.g., AddressCell). Since the view model is tied to the host API, the host application has to be running, and it is undesirable to run a heavyweight host like Excel on the server.","Referring now to , there is illustrated a block diagram of a computer operable to execute the disclosed architecture. In order to provide additional context for various aspects of the present invention,  and the following discussion are intended to provide a brief, general description of a suitable computing environment  in which the various aspects of the present invention may be implemented. While the invention has been described above in the general context of computer-executable instructions that may run on one or more computers, those skilled in the art will recognize that the invention also may be implemented in combination with other program modules and\/or as a combination of hardware and software.","Generally, program modules include routines, programs, components, data structures, etc., that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, minicomputers, mainframe computers, as well as personal computers, hand-held computing devices, microprocessor-based or programmable consumer electronics, and the like, each of which may be operatively coupled to one or more associated devices.","The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","A computer typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media can comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital video disk (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by the computer.","Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","With reference again to , there is illustrated an exemplary environment  for implementing various aspects of the invention that includes a computer , the computer  including a processing unit , a system memory  and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  may be any of various commercially available processors. Dual microprocessors and other multi-processor architectures may also be employed as the processing unit .","The system bus  can be any of several types of bus structure that may further interconnect to a memory bus (with or without a memory controller), a peripheral bus, and a local bus using any of a variety of commercially available bus architectures. The system memory  includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) is stored in a non-volatile memory  such as ROM, EPROM, EEPROM, which BIOS contains the basic routines that help to transfer information between elements within the computer , such as during start-up. The RAM  can also include a high-speed RAM such as static RAM for caching data.","The computer  further includes an internal hard disk drive (HDD)  (e.g., EIDE, SATA), which internal hard disk drive A may also be configured for external use (B) in a suitable chassis (not shown), a magnetic floppy disk drive (FDD) , (e.g., to read from or write to a removable diskette ) and an optical disk drive , (e.g., reading a CD-ROM disk  or, to read from or write to other high capacity optical media such as the DVD). The hard disk drive , magnetic disk drive  and optical disk drive  can be connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface  and an optical drive interface , respectively. The interface  for external drive implementations includes at least one or both of Universal Serial Bus (USB) and IEEE 1394 interface technologies.","The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, and so forth. For the computer , the drives and media accommodate the storage of any data in a suitable digital format. Although the description of computer-readable media above refers to a HDD, a removable magnetic diskette, and a removable optical media such as a CD or DVD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as zip drives, magnetic cassettes, flash memory cards, cartridges, and the like, may also be used in the exemplary operating environment, and further, that any such media may contain computer-executable instructions for performing the methods of the present invention.","A number of program modules can be stored in the drives and RAM , including an operating system , one or more application programs , other program modules  and program data . All or portions of the operating system, applications, modules, and\/or data can also be cached in the RAM .","It is appreciated that the present invention can be implemented with various commercially available operating systems or combinations of operating systems.","A user can enter commands and information into the computer  through one or more wired\/wireless input devices, e.g., a keyboard  and a pointing device, such as a mouse . Other input devices (not shown) may include a microphone, an IR remote control, a joystick, a game pad, a stylus pen, touch screen, or the like. These and other input devices are often connected to the processing unit  through an input device interface  that is coupled to the system bus , but may be connected by other interfaces, such as a parallel port, an IEEE 1394 serial port, a game port, a USB port, an IR interface, etc.","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , a computer typically includes other peripheral output devices (not shown), such as speakers, printers etc.","The computer  may operate in a networked environment using logical connections via wired and\/or wireless communications to one or more remote computers, such as a remote computer(s) . The remote computer(s)  may be a workstation, a server computer, a router, a personal computer, portable computer, microprocessor-based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory storage device  is illustrated. The logical connections depicted include wired\/wireless connectivity to a local area network (LAN)  and\/or larger networks, e.g., a wide area network (WAN) . Such LAN and WAN networking environments are commonplace in offices, and companies, and facilitate enterprise-wide computer networks, such as intranets, all of which may connect to a global communication network, e.g., the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a wired and\/or wireless communication network interface or adapter . The adaptor  may facilitate wired or wireless communication to the LAN , which may also include a wireless access point disposed thereon for communicating with the wireless adaptor . When used in a WAN networking environment, the computer  can include a modem , or is connected to a communications server on the LAN, or has other means for establishing communications over the WAN , such as by way of the Internet. The modem , which may be internal or external and a wired or wireless device, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory\/storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","The computer  is operable to communicate with any wireless devices or entities operably disposed in wireless communication, e.g., a printer, scanner, desktop and\/or portable computer, portable data assistant, communications satellite, any piece of equipment or location associated with a wirelessly detectable tag (e.g., a kiosk, news stand, restroom), and telephone. This includes at least Wi-Fi and Bluetooth\u2122 wireless technologies. Thus, the communication may be a predefined structure as with conventional network or simply an ad hoc communication between at least two devices.","Wi-Fi, or Wireless Fidelity, allows connection to the Internet from a couch at home, a bed in a hotel room or a conference room at work, without wires. Wi-Fi is a wireless technology like a cell phone that enables such devices, e.g., computers, to send and receive data indoors and out; anywhere within the range of a base station. Wi-Fi networks use radio technologies called IEEE 802.11 (a, b, g, etc.) to provide secure, reliable, fast wireless connectivity. A Wi-Fi network can be used to connect computers to each other, to the Internet, and to wired networks (which use IEEE 802.3 or Ethernet). Wi-Fi networks operate in the unlicensed 2.4 and 5 GHz radio bands, with an 11 Mbps (802.11b) or 54 Mbps (802.11a) data rate or with products that contain both bands (dual band), so the networks can provide real-world performance similar to the basic 10 BaseT wired Ethernet networks used in many offices.","Referring now to , there is illustrated a schematic block diagram of an exemplary computing environment  in accordance with the present invention. The system  includes one or more client(s) . The client(s)  can be hardware and\/or software (e.g., threads, processes, computing devices). The client(s)  can house cookie(s) and\/or associated contextual information by employing the present invention, for example. The system  also includes one or more server(s) . The server(s)  can also be hardware and\/or software (e.g., threads, processes, computing devices). The servers  can house threads to perform transformations by employing the present invention, for example. One possible communication between a client  and a server  may be in the form of a data packet adapted to be transmitted between two or more computer processes. The data packet may include a cookie and\/or associated contextual information, for example. The system  includes a communication framework  (e.g., a global communication network such as the Internet) that can be employed to facilitate communications between the client(s)  and the server(s) .","Communications may be facilitated via a wired (including optical fiber) and\/or wireless technology. The client(s)  are operably connected to one or more client data store(s)  that can be employed to store information local to the client(s)  (e.g., cookie(s) and\/or associated contextual information). Similarly, the server(s)  are operably connected to one or more server data store(s)  that can be employed to store information local to the servers .","What has been described above includes examples of the present invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly, the present invention is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
