---
title: Memory management offload for RDMA enabled network adapters
abstract: A method, computer program product, and distributed data processing system for memory management. Memory regions are registered and have access rights and Protection domains associated with them in response to receiving a request for a memory operation including a virtual address, which is used to address into a data structure. A second data structure is then used to translate the virtual address into physical addresses for the operation. A third data structure is used to allow an incoming request responsive to a remote operation being initiated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07299266&OS=07299266&RS=07299266
owner: International Business Machines Corporation
number: 07299266
owner_city: Armonk
owner_country: US
publication_date: 20020905
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention is related to an application entitled iSCSI DRIVER TO ADAPTER INTERFACE PROTOCOL, Ser. no. 10\/235,686, filed Sep. 5, 2002, assigned to the same assignee, and incorporated herein by reference.","1. Technical Field","The present invention relates generally to communication protocols between a host computer and an input\/output (I\/O) device. More specifically, the present invention provides a method for memory management in the context of communication between a host and I\/O device.","2. Description of Related Art","In an Internet Protocol (IP) Network, the software provides a message passing mechanism that can be used to communicate with input\/output devices, general purpose computers (host), and special purpose computers. The message passing mechanism consists of a transport protocol, an upper level protocol, and an application programming interface. The key standard transport protocols used on IP networks today are the Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP). TCP provides a reliable service and UDP provides an unreliable service. In the future the Stream Control Transmission Protocol (SCTP) will also be used to provide a reliable service. Processes executing on devices or computers access the IP network through upper level protocols, such as Sockets, iSCSI, and Direct Access File System (DAFS).","Unfortunately, the TCP\/IP software consumes a considerable amount of processor and memory resources. This problem has been covered extensively in the literature (see J. Kay, J. Pasquale, \u201cProfiling and reducing processing overheads in TCP\/IP\u201d, IEEE\/ACM Transactions on Networking, Vol. 4, No. 6, pp. 817-828, December 1996; and D. D. Clark, V. Jacobson, J. Romkey, H. Salwen, \u201cAn analysis of TCP processing overhead\u201d, IEEE Communications Magazine, Vol. 27, Issue , June 1989, pp 23-29). In the future the network stack will continue to consume excessive resources for several reasons, including: increased use of networking by applications; use of network security protocols; and the underlying fabric bandwidths are increasing at a higher rate than microprocessor and memory bandwidths. To address this problem the industry is offloading the network stack processing to an IP Suite Offload Engine (IPSOE).","There are two offload approaches being taken in the industry. The first approach uses the existing TCP\/IP network stack, without adding any additional protocols. This approach can offload TCP\/IP to hardware, but unfortunately does not remove the need for receive side copies. As noted in the papers above, copies are one of the largest contributors to central processing unit (CPU) utilization. To remove the need for copies, the industry is pursuing the second approach that consists of adding Framing, Direct Data Placement (DDP), and Remote Direct Memory Access (RDMA) over the TCP and the latter two over SCTP. The IP Suite Offload Engine (IPSOE) required to support these two approaches is similar, the key difference being that in the second approach the hardware must support the additional protocols.","The IPSOE provides a message passing mechanism that can be used by sockets, iSCSI, and DAFS to communicate between nodes. Processes executing on host computers, or devices, access the IP network by posting send\/receive messages to send\/receive work queues on an IPSOE. These processes also are referred to as \u201cconsumers\u201d.","The send\/receive work queues (WQ) are assigned to a consumer as a queue pair (QP). The messages can be sent over three different transport types: traditional TCP, RDMA TCP, UDP, or SCTP. Consumers retrieve the results of these messages from a completion queue (CQ) through IPSOE send and receive work completion (WC) queues. The source IPSOE takes care of segmenting outbound messages and sending them to the destination. The destination IPSOE takes care of reassembling inbound messages and placing the inbound messages in the memory space designated by the destination's consumer. These consumers use IPSOE verbs to access the functions supported by the IPSOE. The software that interprets verbs and directly accesses the IPSOE is known as the IPSO interface (IPSOI).","Today the host CPU performs most IP suite processing. IP Suite Offload Engines offer a higher performance interface for communicating to other general purpose computers and I\/O devices. Data sends or receives through the IPSOE require that the CPU either copy data from one memory location to another or register the memory so that the IPSOE can directly access the memory region. Each of these options requires significant CPU resources with the memory registration option being preferred for large memory transfers, however, as network speeds increase the amount of CPU resources required will increase. It would be advantageous to have an improved method, apparatus, and computer instructions for reducing the amount of CPU resources required to register these memory locations, expose them to remote systems through memory windows, and then provide one touch access as an option on the exposed memory windows. It would also be advantageous to have the mechanism apply for iSCSI 1.0, RDMA, and iSCSI-R.","The present invention provides a method, computer program product, and distributed data processing system for registering memory locations, exposing previously registered memory locations through memory windows, and then providing one touch access as an option on the exposed memory windows.","Specifically, the present invention is directed to memory regions that are written to and from by an Internet Protocol Suite Offload Engine (IPSOE) in accordance with a preferred embodiment of the present invention. A mechanism is provided for implicitly or explicitly registering memory regions and allowing hardware to directly use the region through memory region tables and address translation tables while keeping the region isolated from use by other applications. A method for accessing previously registered memory regions by incoming requests by utilizing a tag table to associate the request to with either a physical or virtual address. A mechanism for unbinding a previously bound window upon first use by an incoming message.","The present invention provides a distributed computing system having endnodes, switches, routers, and links interconnecting these components. The endnodes can be Internet Protocol Suite Offload Engines or traditional host software based Internet protocol suites. Each endnode uses send and receive queue pairs to transmit and receive messages. The endnodes segment the message into frames and transmit the frames over the links. The switches and routers interconnect the endnodes and route the frames to the appropriate endnode. The endnodes reassemble the frames into a message at the destination.","With reference now to the figures and in particular with reference to , a diagram of a distributed computer system is illustrated in accordance with a preferred embodiment of the present invention. The distributed computer system represented in  takes the form of an Internet protocol network (IP net), such as IP net  and is provided merely for illustrative purposes and the embodiments of the present invention described below can be implemented on computer systems of numerous other types and configurations. For example, computer systems implementing the present invention can range from a small server with one processor and a few input\/output (I\/O) adapters to massively parallel supercomputer systems with hundreds or thousands of processors and thousands of I\/O adapters. Furthermore, the present invention can be implemented in an infrastructure of remote computer systems connected by an internet or intranet.","IP net  is a high-bandwidth, low-latency network interconnecting nodes within the distributed computer system. A node is any component attached to one or more links of a network and forming the origin and\/or destination of messages within the network. In the depicted example, IP net  includes nodes in the form of host processor node , host processor node , and redundant array independent disk (RAID) subsystem node . The nodes illustrated in  are for illustrative purposes only, as IP net  can connect any number and any type of independent processor nodes, storage nodes, and special purpose processing nodes. Any one of the nodes can function as an endnode, which is herein defined to be a device that originates or finally consumes messages or frames in IP net .","In one embodiment of the present invention, an error handling mechanism in distributed computer systems is present in which the error handling mechanism allows for TCP or SCTP communication between endnodes in a distributed computing system, such as IP net .","A message, as used herein, is an application-defined unit of data exchange, which is a primitive unit of communication between cooperating processes. A frame is one unit of data encapsulated by Internet Protocol Suite headers and\/or trailers. The headers generally provide control and routing information for directing the frame through IP net . The trailer generally contains control and cyclic redundancy check (CRC) data for ensuring frames are not delivered with corrupted contents.","Within a distributed computer system, IP net  contains the communications and management infrastructure supporting various forms of traffic, such as storage, interprocess communications (IPC), file access, and sockets. IP net  shown in  includes a switched communications fabric , which allows many devices to concurrently transfer data with high-bandwidth and low latency in a secure, remotely managed environment. Endnodes can communicate over multiple ports and utilize multiple paths through the IP net fabric. The multiple ports and paths through the IP net shown in  can be employed for fault tolerance and increased bandwidth data transfers.","The IP net  in  includes switch , switch , and router . A switch is a device that connects multiple links together and allows routing of frames from one link to another link using the layer  destination address field. When the Ethernet is used as the link, the destination field is known as the media access control (MAC) address. A router is a device that routes frames based on the layer  destination address field. When Internet Protocol (IP) is used as the layer  protocol, the destination address field is an IP address.","In one embodiment, a link is a full duplex channel between any two network fabric elements, such as endnodes, switches, or routers. Example suitable links include, but are not limited to, copper cables, optical cables, and printed circuit copper traces on backplanes and printed circuit boards.","For reliable service types (TCP and SCTP), endnodes, such as host processor endnodes and I\/O adapter endnodes, generate request frames and return acknowledgment frames. Switches and routers pass frames along, from the source to the destination.","In IP net  as illustrated in , host processor node , host processor node , and RAID subsystem node  include at least one IPSOE to interface to IP net . In one embodiment, each IPSOE is an endpoint that implements the IPSOI in sufficient detail to source or sink frames transmitted on IP net . Host processor node  contains IPSOEs in the form of host IPSOE  and IPSOE . Host processor node  contains IPSOE  and IPSOE . Host processor node  also includes central processing units - and a memory  interconnected by bus system . Host processor node  similarly includes central processing units - and a memory  interconnected by a bus system .","IPSOE  provides a connection to switch , while IPSOE  provides a connection to switch , and IP Suite Offload Engines  and  provide a connection to switches  and .","In one embodiment, an IP Suite Offload Engine is implemented in hardware or a combination of hardware and offload microprocessor(s). In this implementation, IP suite processing is offloaded to the IPSOE. This implementation also permits multiple concurrent communications over a switched network without the traditional overhead associated with communicating protocols. In one embodiment, the IPSOEs and IP net  in  provide the consumers of the distributed computer system with zero processor-copy data transfers without involving the operating system kernel process, and employs hardware to provide reliable, fault tolerant communications.","As indicated in , router  is coupled to wide area network (WAN) and\/or local area network (LAN) connections to other hosts or other routers.","In this example, RAID subsystem node  in  includes processor , memory , IP Suite Offload Engine (IPSOE) , and multiple redundant and\/or striped storage disk unit .","IP net  handles data communications for storage, interprocessor communications, file accesses, and sockets. IP net  supports high-bandwidth, scalable, and extremely low latency communications. User clients can bypass the operating system kernel process and directly access network communication components, such as IPSOEs, which enable efficient message passing protocols. IP net  is suited to current computing models and is a building block for new forms of storage, cluster, and general networking communication. Further, IP net  in  allows storage nodes to communicate among themselves or communicate with any or all of the processor nodes in a distributed computer system. With storage attached to IP net , the storage node has substantially the same communication capability as any host processor node in IP net .","In one embodiment, the IP net  shown in  supports channel semantics and memory semantics. Channel semantics is sometimes referred to as send\/receive or push communication operations. Channel semantics are the type of communications employed in a traditional I\/O channel where a source device pushes data and a destination device determines a final destination of the data. In channel semantics, the frame transmitted from a source process specifies a destination processes' communication port, but does not specify where in the destination processes' memory space the frame will be written. Thus, in channel semantics, the destination process pre-allocates where to place the transmitted data.","In memory semantics, a source process directly reads or writes the virtual address space of a remote node destination process. The remote destination process need only communicate the location of a buffer for data, and does not need to be involved in the transfer of any data. Thus, in memory semantics, a source process sends a data frame containing the destination buffer memory address of the destination process. In memory semantics, the destination process previously grants permission for the source process to access its memory.","Channel semantics and memory semantics are typically both necessary for storage, cluster, and general networking communications. A typical storage operation employs a combination of channel and memory semantics. In an illustrative example storage operation of the distributed computer system shown in , a host processor node, such as host processor node , initiates a storage operation by using channel semantics to send a disk write command to the RAID subsystem IPSOE . The RAID subsystem examines the command and uses memory semantics to read the data buffer directly from the memory space of the host processor node. After the data buffer is read, the RAID subsystem employs channel semantics to push an I\/O completion message back to the host processor node.","In one exemplary embodiment, the distributed computer system shown in  performs operations that employ virtual addresses and virtual memory protection mechanisms to ensure correct and proper access to all memory. Applications running in such a distributed computer system are not required to use physical addressing for any operations.","Turning next to , a functional block diagram of a host processor node is depicted in accordance with a preferred embodiment of the present invention. Host processor node  is an example of a host processor node, such as host processor node  in . In this example, host processor node , shown in , includes a set of consumers -, which are processes executing on host processor node . Host processor node  also includes IP Suite Offload Engine (IPSOE)  and IPSOE . IPSOE  contains ports  and  while IPSOE  contains ports  and . Each port connects to a link. The ports can connect to one IP net subnet or multiple IP net subnets, such as IP net  in .","Consumers - transfer messages to the IP net via the verbs interface  and message and data service . A verbs interface is essentially an abstract description of the functionality of an IP Suite Offload Engine. An operating system may expose some or all of the verb functionality through its programming interface. Basically, this interface defines the behavior of the host. Additionally, host processor node  includes a message and data service , which is a higher-level interface than the verb layer and is used to process messages and data received through IPSOE  and IPSOE . Message and data service  provides an interface to consumers - to process messages and other data.","With reference now to , a diagram of an IP Suite Offload Engine is depicted in accordance with a preferred embodiment of the present invention. IP Suite Offload Engine A shown in  includes a set of queue pairs (QPs) A-A, which are used to transfer messages to the IPSOE ports A-A. Buffering of data to IPSOE ports A-A is channeled using the network layer's quality of service field (QOSF), for example, the Traffic Class field in the IP Version 6 specification, A-A. Each network layer quality of service field has its own flow control. Internet Engineering Task Force (IETF) standard network protocols are used to configure the link and network addresses of all IP Suite Offload Engine ports connected to the network. Two such protocols are Address Resolution Protocol (ARP) and Dynamic Host Configuration Protocol. Memory translation and protection (MTP) A is a mechanism that translates virtual addresses to physical addresses and validates access rights. Direct memory access (DMA) A provides for direct memory access operations using memory A with respect to queue pairs A-A.","A single IP Suite Offload Engine, such as the IPSOE A shown in , can support thousands of queue pairs. Each queue pair consists of a send work queue (SWQ) and a receive work queue (RWQ). The send work queue is used to send channel and memory semantic messages. The receive work queue receives channel semantic messages. A consumer calls an operating system specific programming interface, which is herein referred to as \u201cverbs\u201d, to place work requests (WRs) onto a work queue.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 3B","b":["300","300","302","304","306","300"]},"Similarly,  depicts a router C according to a preferred embodiment of the present invention. Router C includes a frame relay C in communication with a number of ports C through network layer quality of service fields such as IP version 4's Type of Service field C. Like switch B, router C will generally be able to route frames from one port to any other port on the same router.","With reference now to , a diagram illustrating processing of work requests is depicted in accordance with a preferred embodiment of the present invention. In , a receive work queue , send work queue , and completion queue  are present for processing requests from and for consumer . These requests from consumer  are eventually sent to hardware . In this example, consumer  generates work requests  and  and receives work completion . As shown in , work requests placed onto a work queue are referred to as work queue elements (WQEs).","Send work queue  contains work queue elements (WQEs) -, describing data to be transmitted on the IP net fabric. Receive work queue  contains work queue elements (WQEs) -, describing where to place incoming channel semantic data from the IP net fabric. A work queue element is processed by hardware  in the IPSOE.","The verbs also provide a mechanism for retrieving completed work from completion queue . As shown in , completion queue  contains completion queue elements (CQEs) -. Completion queue elements contain information about previously completed work queue elements. Completion queue  is used to create a single point of completion notification for multiple queue pairs. A completion queue element is a data structure on a completion queue. This element describes a completed work queue element. The completion queue element contains sufficient information to determine the queue pair and specific work queue element that completed. A completion queue context is a block of information that contains pointers to, length, and other information needed to manage the individual completion queues.","Example work requests supported for send work queue  shown in  are as follows. A send work request is a channel semantic operation to push a set of local data segments to the data segments referenced by a remote node's receive work queue element. For example, work queue element  contains references to data segment  , data segment  , and data segment  . Each of the send work request's data segments contains part of a virtually contiguous memory region. The virtual addresses used to reference the local data segments are in the address context of the process that created the local queue pair.","A remote direct memory access (RDMA) read work request provides a memory semantic operation to read a virtually contiguous memory space on a remote node. A memory space can either be a portion of a memory region or portion of a memory window. A memory region references a previously registered set of virtually contiguous memory addresses defined by a virtual address and length. A memory window references a set of virtually contiguous memory addresses that have been bound to a previously registered region.","The RDMA read work request reads a virtually contiguous memory space on a remote endnode and writes the data to a virtually contiguous local memory space. Similar to the send work request, virtual addresses used by the RDMA read work queue element to reference the local data segments are in the address context of the process that created the local queue pair. The remote virtual addresses are in the address context of the process owning the remote queue pair targeted by the RDMA read work queue element.","A RDMA write work queue element provides a memory semantic operation to write a virtually contiguous memory space on a remote node. For example, work queue element  in receive work queue  references data segment  , data segment  , and data segment  . The RDMA write work queue element contains a scatter list of local virtually contiguous memory spaces and the virtual address of the remote memory space into which the local memory spaces are written.","A RDMA FetchOp work queue element provides a memory semantic operation to perform an atomic operation on a remote word. The RDMA FetchOp work queue element is a combined RDMA Read, Modify, and RDMA Write operation. The RDMA FetchOp work queue element can support several read-modify-write operations, such as Compare and Swap if equal. The RDMA FetchOp is not included in current RDMA over IP standardization efforts, but is described here, because it may be used as a value-added feature in some implementations.","A bind (unbind) remote access key (STag) work queue element provides a command to the IP Suite Offload Engine hardware to modify (destroy) a memory window by associating (disassociating) the memory window to a memory region. The STag is part of each RDMA access and is used to validate that the remote process has permitted access to the buffer.","In one embodiment, receive work queue  shown in  only supports one type of work queue element, which is referred to as a receive work queue element. The receive work queue element provides a channel semantic operation describing a local memory space into which incoming send messages are written. The receive work queue element includes a scatter list describing several virtually contiguous memory spaces. An incoming send message is written to these memory spaces. The virtual addresses are in the address context of the process that created the local queue pair.","For interprocessor communications, a user-mode software process transfers data through queue pairs directly from where the buffer resides in memory. In one embodiment, the transfer through the queue pairs bypasses the operating system and consumes few host instruction cycles. Queue pairs permit zero processor-copy data transfer with no operating system kernel involvement. The zero processor-copy data transfer provides for efficient support of high-bandwidth and low-latency communication.","When a queue pair is created, the queue pair is set to provide a selected type of transport service. In one embodiment, a distributed computer system implementing the present invention supports three types of transport services: TCP, SCTP, and UDP.","TCP and SCTP associate a local queue pair with one and only one remote queue pair. TCP and SCTP require a process to create a queue pair for each process that TCP and SCTP are to communicate with over the IP net fabric. Thus, if each of N host processor nodes contains P processes, and all P processes on each node wish to communicate with all the processes on all the other nodes, each host processor node requires P\u00d7(N\u22121) queue pairs. Moreover, a process can associate a queue pair to another queue pair on the same IPSOE.","A portion of a distributed computer system employing TCP or SCTP to communicate between distributed processes is illustrated generally in . The distributed computer system  in  includes a host processor node , a host processor node , and a host processor node . Host processor node  includes a process A . Host processor node  includes a process C  and a process D . Host processor node  includes a process E .","Host processor node  includes queue pairs 4, 6 and 7, each having a send work queue and receive work queue. Host processor node  has a queue pair 9 and host processor node  has queue pairs 2 and 5. The TCP or SCTP of distributed computer system  associates a local queue pair with one and only one remote queue pair. Thus, the queue pair 4 is used to communicate with queue pair 2; queue pair 7 is used to communicate with queue pair 5; and queue pair 6 is used to communicate with queue pair 9.","A WQE placed on one send queue in a TCP or SCTP causes data to be written into the receive memory space referenced by a receive WQE of the associated queue pair. RDMA operations operate on the address space of the associated queue pair.","In one embodiment of the present invention, the TCP or SCTP is made reliable because hardware maintains sequence numbers and acknowledges all frame transfers. A combination of hardware and IP net driver software retries any failed communications. The process client of the queue pair obtains reliable communications even in the presence of bit errors, receive underruns, and network congestion. If alternative paths exist in the IP net fabric, reliable communications can be maintained even in the presence of failures of fabric switches, links, or IP Suite Offload Engine ports.","In addition, acknowledgements may be employed to deliver data reliably across the IP net fabric. The acknowledgement may, or may not, be a process level acknowledgement, i.e. an acknowledgement that validates that a receiving process has consumed the data. Alternatively, the acknowledgement may be one that only indicates that the data has reached its destination.","The User Datagram Protocol is connectionless. The UDP is employed by management applications to discover and integrate new switches, routers, and endnodes into a given distributed computer system. The UDP does not provide the reliability guarantees of the TCP or SCTP. The UDP accordingly operates with less state information maintained at each endnode.","Turning next to , an illustration of a data frame is depicted in accordance with a preferred embodiment of the present invention. A data frame is a unit of information that is routed through the IP net fabric. The data frame is an endnode-to-endnode construct, and is thus created and consumed by endnodes. For frames destined to an IPSOE, the data frames are neither generated nor consumed by the switches and routers in the IP net fabric. Instead for data frames that are destined to an IPSOE, switches and routers simply move request frames or acknowledgment frames closer to the ultimate destination, modifying the link header fields in the process. Routers may modify the frame's network header when the frame crosses a subnet boundary. In traversing a subnet, a single frame stays on a single service level.","Message data  contains data segment  , data segment  , and data segment  , which are similar to the data segments illustrated in . In this example, these data segments form a frame , which is placed into frame payload  within data frame . Additionally, data frame  contains cyclic redundancy check (CRC) , which is used for error checking. Additionally, routing header  and transport header  are present in data frame . Routing header  is used to identify source and destination ports for data frame . Transport header  in this example specifies the sequence number and the source and destination port number for data frame . The sequence number is initialized when communication is established and incremented by 1 for each byte of frame header, DDP\/RDMA header, data payload, and CRC. Frame header  in this example specifies the destination queue pair number associated with the frame and the length of the Direct Data Placement and\/or Remote Direct Memory Access (DDP\/RDMA) header plus data payload plus CRC. DDP\/RDMA header  specifies the message identifier and the placement information for the data payload. The message identifier is constant for all frames that are part of a message. Example message identifiers include, for example, send, write RDMA, and read RDMA.","In , a portion of a distributed computer system  is depicted to illustrate an example request and acknowledgment transaction. Distributed computer system  in  includes a host processor node  running process A  and a host processor node  running process B . Host processor node  includes an IPSOE . Host processor node  includes an IPSOE . The distributed computer system in  includes IP net fabric , which includes switch  and switch . The IP net fabric includes a link coupling IPSOE  to switch ; a link coupling switch  to switch ; and a link coupling IPSOE  to switch .","In the example transactions, host processor node  includes a client process A. Host processor node  includes a client process B. Client process A interacts with host IPSOE  through queue pair 23  comprising send queue  and receive queue . Client process B interacts with host IPSOE  through queue pair 24  comprising send queue  and receive queue . Queue pairs 23 and 24 are data structures that include a send work queue and a receive work queue.","Process A initiates a message request by posting work queue elements to the send queue of queue pair 23. Such a work queue element is illustrated in . The message request of client process A is referenced by a gather list contained in the send work queue element. Each data segment in the gather list points to part of a virtually contiguous local memory region, which contains a part of the message, such as indicated by data segments , , and , which respectively hold message parts , , and , in .","Hardware in host IPSOE  reads the work queue element and segments the message stored in virtual contiguous buffers into data frames, such as the data frame illustrated in . Data frames are routed through the IP net fabric, and for reliable transfer services, are acknowledged by the final destination endnode. If not successfully acknowledged, the data frame is retransmitted by the source endnode. Data frames are generated by source endnodes and consumed by destination endnodes.","With reference to , a diagram illustrating the network addressing used in a distributed networking system is depicted in accordance with the present invention. A host name provides a logical identification for a host node, such as a host processor node or I\/O adapter node. The host name identifies the endpoint for messages such that messages are destined for processes residing on an endnode specified by the host name. Thus, there is one host name per node, but a node can have multiple IPSOEs.","A single link layer address (e.g. Ethernet Media Access Layer Address)  is assigned to each port  of a endnode component . A component can be an IPSOE, switch, or router. All IPSOE and router components must have a MAC address. A media access point on a switch is also assigned a MAC address.","One network address (e.g. IP Address)  is assigned to each port  of an endnode component . A component can be an IPSOF, switch, or router. All IPSOE and router components must have a network address. A media access point on a switch is also assigned a MAC address.","Each port of switch  does not have a link layer address associated with it. However, switch  can have a media access port  that has a link layer address  and a network layer address  associated with it.","A portion of a distributed computer system in accordance with a preferred embodiment of the present invention is illustrated in . Distributed computer system  includes a subnet  and a subnet . Subnet  includes host processor nodes , , and . Subnet  includes host processor nodes  and . Subnet  includes switches  and . Subnet  includes switches  and .","Routers create and connect subnets. For example, subnet  is connected to subnet  with routers  and . In one example embodiment, a subnet has up to 216 endnodes, switches, and routers.","A subnet is defined as a group of endnodes and cascaded switches that is managed as a single unit. Typically, a subnet occupies a single geographic or functional area. For example, a single computer system in one room could be defined as a subnet. In one embodiment, the switches in a subnet can perform very fast wormhole or cut-through routing for messages.","A switch within a subnet examines the destination link layer address (e.g. MAC address) that is unique within the subnet to permit the switch to quickly and efficiently route incoming message frames. In one embodiment, the switch is a relatively simple circuit, and is typically implemented as a single integrated circuit. A subnet can have hundreds to thousands of endnodes formed by cascaded switches.","As illustrated in , for expansion to much larger systems, subnets are connected with routers, such as routers  and . The router interprets the destination network layer address (e.g. IP address) and routes the frame.","An example embodiment of a switch is illustrated generally in . Each I\/O path on a switch or router has a port. Generally, a switch can route frames from one port to any other port on the same switch.","Within a subnet, such as subnet  or subnet , a path from a source port to a destination port is determined by the link layer address (e.g. MAC address) of the destination host IPSOE port. Between subnets, a path is determined by the network layer address (IP address) of the destination IPSOE port and by the link layer address (e.g. MAC address) of the router port, which will be used to reach the destination's subnet.","In one embodiment, the paths used by the request frame and the request frame's corresponding positive acknowledgment (ACK) frame are not required to be symmetric. In one embodiment employing oblivious routing, switches select an output port based on the link layer address (e.g. MAC address). In one embodiment, a switch uses one set of routing decision criteria for all its input ports in the switch. In one example embodiment, the routing decision criteria are contained in one routing table. In an alternative embodiment, a switch employs a separate set of criteria for each input port.","A data transaction in the distributed computer system of the present invention is typically composed of several hardware and software steps. A client process data transport service can be a user-mode or a kernel-mode process. The client process accesses IP Suite Offload Engine hardware through one or more queue pairs, such as the queue pairs illustrated in , , and . The client process calls an operating system specific programming interface, which is herein referred to as \u201cverbs.\u201d The software code implementing verbs posts a work queue element to the given queue pair work queue.","There are many possible methods of posting a work queue element and there are many possible work queue element formats, which allow for various cost\/performance design points, but which do not affect interoperability. A user process, however, must communicate to verbs in a well-defined manner, and the format and protocols of data transmitted across the IP net fabric must be sufficiently specified to allow devices to interoperate in a heterogeneous vendor environment.","In one embodiment, IPSOE hardware detects work queue element postings and accesses the work queue element. In this embodiment, the IPSOE hardware translates and validates the work queue element's virtual addresses and accesses the data.","An outgoing message is split into one or more data frames. In one embodiment, the IPSOE hardware adds a DDP\/RDMA header, frame header and CRC, transport header and a network header to each frame. The transport header includes sequence numbers and other transport information. The network header includes routing information, such as the destination IP address and other network routing information. The link header contains the destination link layer address (e.g. MAC address) or other local routing information.","If a TCP or SCTP is employed, when a request data frame reaches its destination endnode, acknowledgment data frames are used by the destination endnode to let the request data frame sender know the request data frame was validated and accepted at the destination. Acknowledgement data frames acknowledge one or more valid and accepted request data frames. The requester can have multiple outstanding request data frames before it receives any acknowledgments. In one embodiment, the number of multiple outstanding messages, i.e. request data frames, is determined when a queue pair is created.","One embodiment of a layered architecture  for implementing the present invention is generally illustrated in diagram form in . The layered architecture diagram of  shows the various layers of data communication paths, and organization of data and control information passed between layers.","IPSOE endnode protocol layers (employed by endnode , for instance) include upper level protocols  defined by consumer , transport layer , network layer , link layer , and physical layer . Switch layers (employed by switch , for instance) include link layer  and physical layer . Router layers (employed by router , for instance) include network layer , link layer , and physical layer .","Layered architecture  generally follows an outline of a classical communication stack in order to complete consumer operations  of transferring data between consumers  and . With respect to the protocol layers of endnode , for example, upper layer protocols  employs verbs to create messages at transport layer . Transport layer  passes messages  to network layer . Network layer  routes frames between network subnets . Link layer  routes frames within a network subnet . Physical layer  sends bits or groups of bits to the physical layers of other devices. Each of the layers is unaware of how the upper or lower layers perform their functionality.","Consumers  and  represent applications or processes that employ the other layers for communicating between endnodes. Transport layer  provides end-to-end message movement. In one embodiment, the transport layer provides four types of transport services as described above which are traditional TCP, RDMA over TCP, SCTP, and UDP. Network layer  performs frame routing through a subnet or multiple subnets to destination endnodes. Link layer  performs flow-controlled , error checked, and prioritized frame delivery across links.","Physical layer  performs technology-dependent bit transmission. Bits or groups of bits are passed between physical layers via links , , and . Links can be implemented with printed circuit copper traces, copper cable, optical cable, or with other suitable links.","Turning now to , a flowchart and diagram illustrating two Memory Registration mechanisms in accordance with a preferred embodiment of the present invention are provided. In the \u201cTraditional Mechanism\u201d () for registering a Memory Region with the IPSOE, Consumer , uses a single step  to register the Memory Region with the IPSOE. The single step uses either Memory Mapped I\/O (MMIO), Programmed I\/O (PIO), or perhaps a Direct Memory Access (DMA) CPU assist to transfer the Memory Translation and Protection Table (TPT) entry into IPSOE 's Memory TPT . If the Traditional Mechanism uses MMIOs or PIOs to perform the transfer, the Consumer must wait for these MMIOs or PIOs to return control to the Host CPU before the Consumer can use the newly create Memory TPT. Depending on the implementation the delay may degrade system performance.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 11","b":["1130","1140","1144","1148","1152","1140","1192","1172","1164","1160","1164","1156","1140","1164"]},"When IPSOE 's SQ  processes the Physical Memory Registration WQE , it validates the Memory Registration WQE. If the QP has the Send Queue based Physical Memory Registration Mechanism enabled and the STag is valid (e.g. STag points to an entry in the Memory TPT and the STag Tag_Instance matches the Tag_Instance in that entry and there is enough space in the Memory TPT for the new entry), then the new Memory TPT entry  is created (step ).","If the Memory Registration WQE encounters an error (e.g. STag does not point to an entry in the Memory TPT, or the STag Tag_Instance does not match the Tag_Instance in the entry pointed to by the STag, or the entry pointed to by the STag does not have enough space for the new Memory TPT entry), there are two semantic options for an implementation to take. Option  (step ) is reactive and presumes that Consumer  is not keeping track of the Memory TPT space. If an IPSOE implementation uses option , then the following process is performed: the IPSOE places the QP associated with the SQ in the Send Queue Drained State, stops processing WQEs subsequent to Memory Registration WQE  (but continues processing all RQ WQEs, all incoming RDMA Read Requests, any Terminate message, and all preceding SQ WQEs), generates a completion error CQE  identifying the error in the Memory Registration WQE, places CQE  in Completion Queue , and returns all subsequent SQ WQEs with a Flush error CQE through CQ . Consumer  can retry the Memory Registration WR that was completed in error and all subsequent WRs.","Option  (step ) is anticipatory and presumes that Consumer  is keeping track of the Memory TPT space. That is, Consumer keeps track of how the Memory TPT space is being used by IPSOE . Under this option, Consumer  only issues Memory Registration WRs that are guaranteed to have enough space in the Memory TPT. If an IPSOE implementation uses option , then the following process is performed: the IPSOE places the QP associated with the SQ in the Error State, stops processing all local and remote operations, issues a Terminate Message to bring down the RDMA Stream, generates a completion error CQE  identifying the error in the Memory Registration WQE, places CQE  in Completion Queue , and returns all other SQ and RQ WQEs with a Flush error CQE through CQ .","Finally (step ), Consumer  retrieves the result of the Physical Memory Registration WR through a Work Completion .","Turning next to , a diagram of a memory management system is depicted in accordance with a preferred embodiment of the present invention. Memory management system  employs a two-table memory translation and protection management structure, which includes memory region\/window table  and address translation tables . Together these tables are known as the Memory Translation and Protection Table (Memory TPT). Memory region\/window table  contains information used by IPSOE hardware to determine whether access to an area of memory referenced in a work request or a remote operation is authorized. In this example, the access may be requested in WQE data segment  within work queue . Address translation tables  contain the information used to convert a virtual address provided in WQE data segment  into a list of one or more real addresses of pages making up a data buffer within a memory region, such as memory region . The data buffer may encompass one or more pages in these examples.","When a WQE data segment, such as WQE data segment  is received, the key index within the WQE data segment is used as an index into memory region\/window table  to identify a memory region entry or a memory window entry within the memory region\/window table, such as memory region entry  or memory window entry . Memory region table entry  is used to determine whether the requested memory access is authorized for the memory region defined by the memory region entry. If access is authorized, then an address translation table  is accessed. Multiple address translation tables are present in which one address translation table is used for every memory region\/window defined. Each entry in an address translation table is the real address of a page that makes up part of the memory region\/window. Entries are arranged in ascending order corresponding to the incrementing virtual address associated with the memory region\/window. The IPSOE hardware indexes into the address translation table  based on the offset into the memory region\/window, which is calculated by subtracting starting virtual address  of the memory region\/window obtained from memory region\/window table entry  from virtual address  specified in the work request or remote operation packet header. This result forms offset  into the area of memory to be accessed. The low order bits of this offset are used to index into the page specified in the address translation table entry, and the high order bits are used to index into the address translation table. In this example, offset  results in a translation of the address into real addresses identifying pages - as those containing the data buffer referenced by WQE data segment .",{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 13","b":"1300"},"In this example, the memory region\/window entry  includes the virtual address of the start of memory region\/window , length of memory region\/window , protection domain , tag_instance , entry type , valid entry , access control , iSCSI control , ATT control , page size , and address translation pointer .","Each entry in memory region\/window table  defines the characteristics of a memory region or a memory window. A Memory Region Entry () is used to describe a Memory Region. A Memory Window Entry () is used to describe a Memory Window. The remainder of this section will describe the contents of the Memory Region Entry. Except where noted otherwise, the description is applicable to a Memory Window Entry, because both MREs and MWEs contain the same fields. Though the Memory Window Entry can be optimized to use the Address Translation Table of the Memory Region that the Memory Window is bound to.","A portion of the STag that is used to reference the data buffer is called the Tag_Index, and this is used by the IPSOE hardware to index into the memory region\/window table to obtain the memory region table entry (MRE) for the memory region that is to be accessed. More specifically, the STag Tag_Index is used to reference the memory region. The STag of the memory region are included in the Bind WQE.","Virtual address  of the start of the memory region and length  of the memory region define the bounds of the memory region. Protection domain (PD)  is used to determine if the QP originating the work queue request has authorization to access this memory region. That is, the PD value stored in the Memory Region Entry must match the PD value stored in the QP. Tag_Instance  is the value of the Tag instance associated with the memory region and is used to validate the portion of the STag that is not part of the Tag_Index. The Tag_Instance provides access control when the definitions of memory regions change. More specifically, the STag Tag_Instance is validated with the Tag_Instance stored in the memory region entry for the region.","Entry Type  specifies whether the entry is for: an RDMA Region, an RDMA Window, or iSCSI. It can be implemented as two bits, with three values used and one reserved or as three bits.","The following example is for a two bit implementation: if the Entry Type field is \u201800\u2019b, then the entry is for RDMA Region; if the Entry Type field is \u201801\u2019b, then the entry is for a RDMA Window; if the Entry Type field is \u201810\u2019b, then the entry is for a iSCSI Region; and an Entry Type field of \u201811\u2019b is reserved and unused.","If the entry is for a RDMA Region (including iSCSI-R), then the first Address Translation Table entry for the Memory Region points to the byte offset into the first physical page associated of the Memory Region. If the entry is for a RDMA Window (including iSCSI-R), then the first Address Translation Table entry for the Memory Window can be implemented as an index into the Memory Region's ATT which is bound to the Memory Window. If the entry is for iSCSI 1.0, then the Virtual Address  field is used as a pointer to a WQE in the send queue that contains the iSCSI command and the first Address Translation Table entry for the iSCSI 1.0 Region points to the byte offset into the first physical page associated of the iSCSI 1.0 Region.","Valid Entry  denotes whether the entry is valid or invalid. Valid Entry  can be implemented as a single bit. If the bit is set, the entry is valid, otherwise it is not valid.","Access control  determines the write access rights for this memory region. The Access Control  field contains three sub-fields: Type of Access Control , Window Binding Control , and Touch Access Control .","The Type of Access Control  field contains four distinct access types: local read, local write, remote read, and remote write access. These distinct access types can be encoded as four bits, where if a bit is set, the access type associated with the bit is enabled. If a bit is not set, the access type associated with the bit is disabled. For example, if the local write access bit is set, local write access is enabled. If the local write access bit is not set, local write access is disabled. Note: if standard specifications prohibit Windows from being used for local access, then a Memory Window Entry would only have two distinct access types: remote read access and remote write access.","Window Binding Control  field contains a single bit denoting whether Memory Windows can be bound to the Memory Region or not. If the bit is set, Memory Windows can be bound to the Memory Region. If the bit is not set, Memory Windows cannot be bound to the Memory Region.","Touch Access Control  field contains at least two bits: a One Touch Enabled bit which designates whether the entry has One Touch Enabled or not; and Touched bit which only has meaning if the One Touch Enabled bit is set and designates whether the entry has been touched before or not.","A One Touch entry cannot be used after the incoming byte-stream lines up with the end of the last segment associated with the first RDMA Message that targets the entry. A Multiple Touch entry can be used after the incoming byte-stream lines up with the end of the last segment associated with the first RDMA Message that targets the Region.","For One Touch Memory Region, the Memory Region's Valid Region  field is reset, when the incoming byte stream lines up with the end of the last segment associated with the first RDMA Message that targets the Region. For a Multiple Touch Memory Region, the Memory Region's Valid Region  field is not affected, when the incoming byte stream lines up with the end of the last segment associated with the first RDMA Message that targets the Region. A more detailed description of this process is provided in  and the accompanying text.","If standard specifications enable one touch access on Windows only, then an implementation may choose to use one touch access on Memory Window Entries only (or may offer one touch access on Memory Regions as an option).","The Stored DDP Sequence Number  is used to store the DDP Sequence Number associated with the last byte of the payload of a DDP Segment that has the Last bit set in the DDP Header. A more detailed description of this process is provided in  and the accompanying text.","ATT Control  specifies whether the ATT entries reference physical page address (Direct Pointers), a list of physical page addresses (1st Order Indirect Pointers), or an indirect ATT page that contains a list of ATT pages (2nd Order Indirect Pointers). Address translation pointer  references the address translation table associated with this memory region. Note the first entry in the ATT that references a physical page can point to an offset into the page. Similarly, the last entry can end at an offset from the start of the last physical page.","Page size  specifies the size of the page. For example, 4 KB, 8 KB, 64 KB, 1 MB, 16 MB, and 256 MB may also be valid page sizes, as well as other possible sizes, as one skilled in the art will appreciate.","ATT Entries  specifies one or more 64-bit physical addresses. If ATT Control field  is set to Direct Pointers , then each ATT Entry  points to a physical address. If ATT Control field  is set to 1st Order Indirect Pointers , then each ATT Entry  points to a list of Physical Addresses . If ATT Control field  is set to 2nd Order Indirect Pointers , then each ATT Entry  points to a list of ATT Entries  and each Entry in the ATT Entries  points to a list of Physical Addresses .",{"@attributes":{"id":"p-0136","num":"0135"},"figref":"FIG. 14","b":["1400","1400","1410","1400","1412"]},"We now turn to , which is a flowchart and diagram representation of the process used by the IPSOE to validate memory accesses performed by Work Queue Elements posted by the Consumer as Work Request on an IPSOE Work Queue, in accordance with a preferred embodiment of the present invention.","First (step ), the Consumer  posts a Work Request into an IPSOE Work Queue . The Work Queue can either be a Send Queue or a Receive Queue. The Work Request contains zero or more Data Segments. For RDMA (including iSCSI-R), each Data Segment contains a STag, Virtual Address, and Length. For iSCSI 1.0: a single STag is used for all Data Segments in the WR; each Data Segment in the WR contains a physical address; the first Data Segment contains an additional field that is used to define the starting offset into the first physical page; the last Data Segment also contains an additional field that is used to define the ending offset into the last physical page; and all intermediate Data Segments only contain a physical address, because the intermediate pages must start and end on a page boundary.","Next (step ), the verbs interface converts the WR into a Work Queue Element (WQE) and places WQE  into WQ .","Then (step ), the IPSOE  accesses the WQE . If the WQ  is a RDMA (including iSCSI-R) WQ, then each Data Segment referenced in WQE  is validated. The validation includes the following checks: a) the Valid Entry field is set; b) the Entry Type for the entry is set to region (i.e. windows cannot be used for local access); c) the PD (protection domain) in the QP context associated with WQ  matches the PD of Memory Region Entry  referenced by the Data Segment's STag; d) the portion of the Data Segment's STag that is the Tag_Instance matches Tag_Instance in the MRE ; e) the base address and length of the Data Segment is within the range of addresses associated with the MRE ; f) the type of access is valid (SQ RDMA Write and Send WRs, require local read access; and RQ WRs require local write access); and g) for SQ Bind WR, the MRE  being bound to the memory window has window access enabled. Note: if the WR is a SQ Bind WR and it requests that one touch access be set for the associated Window, then the one touch access bit will be set when the IPSOE creates the associated Window.","If the WQ, is a iSCSI 1.0 WQE, then the STag provided in the WQE is used to create an iSCSI Memory Region from the list of Data Segments provided in the WQE. iSCSI 1.0 Memory Regions are referenced from a zero base, because they do not have a virtual address field.","If the Data Segment provided by the Consumer is valid, then the associated Memory Region is accessed and the WQE is processed. Upon good completion a CQE is returned through the CQ associated with the WQ.","Next (step ), If any of the Data Segments are invalid, then the associated Memory Region is not accessed and an error is returned through a CQE  on the CQ  associated with the WQ .","Finally, in step , Consumer  retrieves a WC for the WR submitted in step .","We now turn to , which is a flowchart and diagram representation of the process used to distinguish between the different types of streams that can be associated with a remote operation.","The IPSOE receives an incoming TCP\/IP Segment .","In step , The IPSOE uses well-known TCP\/IP\/Ethernet validation mechanisms to validate an incoming TCP Segment . In step , IPSOE checks if an error was encountered during TCP\/IP Segment validation. If incoming TCP\/IP Segment is valid, the process continues to step . Otherwise  the segment is dropped and the process continues waiting for TCP\/IP Segment (step ).","In step , after the validation process is completed, the TCP\/IP quintuple (Transport Type, Destination TCP Port Number, Source TCP Port Number, Destination IP Address, and Source IP Address) of the incoming TCP Segment is used to access the QP Context associated with the incoming TCP Segment.","In step , if no QP Context exists for the incoming TCP Segment, then the Consumer is not using any of the IPSOE's TCP\/IP Offload mechanisms and the incoming TCP Segment is passed up to the Consumer through well-known traditional NIC mechanisms.","In step , If the incoming TCP Segment references a iSCSI 1.0 QP Context, then the processing described in  is performed on the incoming TCP Segment.","In step , If the incoming TCP Segment references a RDMA (including iSCSI-R) QP Context, then Marker with PDU Alignment (MPA) mechanism is used to by the IPSOE to retrieve a DDP Segment and its associated DDP Header and the processing described in  is performed on the incoming TCP Segment.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":["FIG. 17A","FIG. 17"],"i":"a ","b":["1706","1708"]},"In step , when Consumer  (which is typically an iSCSI Device Driver running in the host CPU's Operating System Kernel) initializes QP Context , Consumer  sets the mode of the QP to iSCSI 1.0. When a QP Context has been initialized in iSCSI mode, the Work Request posted to the QP's Send Queue, such as SQ , contains the iSCSI Command and a list of Data Transfer Data Segments associated with the SCSI Command. The IPSOE will follow the flowchart described in  to: create (register) a Memory TPT entry for the iSCSI Command and the Data Transfer Data Segments associated with the iSCSI Command; issue the iSCSI Command to the Target; perform the data transfer associated with the iSCSI Command () and upon reception of the iSCSI Response destroy the iSCSI Command's Memory TPT entry (deregister) and create a WC containing the iSCSI Response.","Before Consumer  can send an iSCSI Command to the Target, Consumer  must create a RQ WQE to receive the iSCSI Response. In step , Consumer  passes a RQ WR to IPSOE  for the iSCSI Response that will be associated with an iSCSI Command. The Verbs interface, in step , validates the RQ WR and if valid the Verbs interfaces creates a RQ WQE  from the WR, places RQ WQE  in the associated RQ , and immediately returns to the Consumer . If the WR is not valid, the Verbs interface returns an error to the Consumer .","In step , Consumer  then requests the IPSOE  to perform an iSCSI Command by passing a SQ WR to the IPSOE containing the iSCSI Command and the Data Transfer Data Segments associated with the iSCSI Command. The Verbs interface, in step , validates the SQ WR and if valid the Verbs interfaces creates a SQ WQE from the WR, places the SQ WQE  in the associated SQ , and immediately returns an iSCSI Command ID to the Consumer . The Command ID is used between the Consumer and the IPSOE to associate the iSCSI Response with the iSCSI Command. If the WR is not valid, the Verbs interface returns an error to the Consumer .","When IPSOE 's SQ  processes iSCSI Command SQ WQE , it validates the WQE. In step , if the QP is initialized to iSCSI mode, the iSCSI Command is valid for the type of device it will be sent to, and the Data Transfer Data Segments associated with the iSCSI Command are valid (e.g. they do not wrap), and there is enough space in the Memory TPT for the new entry, then new iSCSI Memory TPT entry  is created in Memory TPT .","If iSCSI Command SQ WQE  encounters an error (e.g. there isn't enough space in the Memory TPT for another entry or the iSCSI Command op-code is invalid for the type of device being referenced), then there are two semantic options for an implementation to take. Option  (step ) is reactive and presumes that Consumer  is not keeping track of the Memory TPT space. If an IPSOE implementation uses option , then the following process is performed: the IPSOE places the QP associated with the SQ in the Send Queue Drained State, stops processing WQEs subsequent to iSCSI Command SQ WQE  (but continues processing all RQ WQEs, all incoming R2Ts, all preceding SQ WQEs, and other incoming iSCSI Control Messages), generates a completion error CQE  identifying the error in iSCSI Command SQ WQE , places CQE  in the Completion Queue , and returns all subsequent SQ WQEs with a Flush error CQE through CQ . Consumer  can retry the iSCSI Command WR that was completed in error and all subsequent WRs.","Option  (step ) is anticipatory and presumes that Consumer  is keeping track of the Memory TPT space. That is, the Consumer keeps track of how the Memory TPT space is being used by the IPSOE. Under this option, Consumer  only issues iSCSI Command WRs that are guaranteed to have enough space in the Memory TPT. If an IPSOE implementation uses option , then the following process is performed: the IPSOE places the QP associated with the SQ (QP ) in the Error State, stops processing all local and remote operations, terminates the iSCSI Stream, generates a completion error CQE  identifying the error in the iSCSI Command SQ WQE, places CQE  in Completion Queue , and returns all other SQ and RQ WQEs with a Flush error CQE through CQ .","In step , when the IPSOE Target Side Processing logic reaches the iSCSI Command SQ WQE, the IPSOE sends the iSCSI Command to the Target.","The flowchart in , which is described below, describes a mechanism used by the IPSOE to perform the data transfer phase of the iSCSI Command in accordance with a preferred embodiment of the present invention.","When the Target completes the iSCSI Command, (step ), the Target sends an iSCSI Response (or, for Device Reads, includes the iSCSI Status in a Data-In Message) to the initiator.","In step , when the IPSOE receives the iSCSI Response the IPSOE validates that QP Context  is associated with the stream (e.g., via SCTP) or connection (e.g., via TCP) that received the iSCSI Response. For TCP\/IP, the IPSOE performs this step by assuring that the quintuple (Transport Type, Destination Port Number, Source Port Number, Destination IP Address, and Source IP Address) associated with the incoming iSCSI Response matches the quintuple associated with the QP Context. The IPSOE then validates the other iSCSI and TCP fields associated with the iSCSI Response Message (e.g. the Sequence Number in the TCP Segment containing the iSCSI Response matches the next expected Sequence Number stored in the QP). The IPSOE then uses the Tag_Index portion of the iSCSI Initiator Tag to look-up the Memory TPT entry () associated with the iSCSI Response. The IPSOE validates the Tag_Instance portion of the iSCSI Initiator Tag.","If the incoming iSCSI Response is valid (including the Tag_Instance portion of the iSCSI Initiator Tag), then IPSOE : accesses Memory TPT entry  to retrieve the Command ID of the iSCSI Command that is associated with the iSCSI Response; retrieves the Command ID from Memory TPT entry ; destroys (deregisters) Memory TPT entry ; and places the Command ID and the incoming iSCSI Response into RQ WQE  of the QP associated with the incoming iSCSI Response. Otherwise IPSOE  drops the incoming iSCSI Response.","Finally, in step  , the Consumer  retrieves the WC containing the iSCSI Command ID and the iSCSI Response. The Consumer  uses the iSCSI Command ID to associate the iSCSI Response with the iSCSI Command.","The mechanism described in  can be applied to a general purpose QP. That is, the memory registration step can be combined with a general purpose WR and the deregistration step can be performed when the remote node sends a message containing the Tag (e.g. Steering Tag) that is to be deregistered.",{"@attributes":{"id":"p-0166","num":"0165"},"figref":"FIG. 17B"},"In step , the Tag_Index portion of the incoming iSCSI Header's Initiator Task Tag is used to validate the incoming DDP Segment. Continue to step B.","In step , the following checks are performed on the entry that has been indexed by the Tag_Index portion of the incoming iSCSI Header's Initiator Task Tag: a) the Valid Entry field is set; b) the Entry Type for the entry is set to iSCSI 1.0 (i.e. Regions or Windows cannot be used for iSCSI 1.0); c) the PD in the QP context associated with the incoming TCP Segment matches the PD of the Memory TPT Entry; d) the portion of the iSCSI 1.0 Header's Initiator Task Tag that is the Tag_Instance matches Tag_Instance in the Memory TPT Entry; e) the Offset of the incoming iSCSI 1.0 Segment's Header does not exceed the size of Length field stored in the Memory TPT Entry; f) the type of access is valid (e.g. for R2T the Memory TPT Entry has remote read access enabled and for Data-In the Memory TPT Entry has remote write access enabled) and g) the Initiator's iSCSI Command (looked up by using the Virtual Address field of the Memory TPT entry) matches the incoming (Target) iSCSI message's action (i.e. Initiator iSCSI Command is a Disk Write and the incoming iSCSI Message is a R2T or the iSCSI Command is a Disk Read and the incoming iSCSI Message is a Data). If these checks pass, processing continues to step . Otherwise the erroneous iSCSI Message is passed to the Consumer through the iSCSI QP's Receive Queue.","In step , the type of iSCSI message is determined. In step , if the incoming iSCSI Header is a R2T, the Target Offset is used to offset into the buffer pointed to by the Tag Index portion of the Initiator Task Tag and the contents of the buffer, up to the length specified in the iSCSI header is transferred to the remote node. The iSCSI Header's control information is passed to the Consumer through the iSCSI QP's Receive Queue.","In step , if the incoming iSCSI Header is a Data-in Transfer, the Target Offset is used to offset into the buffer pointed to by the Tag Index portion of the Initiator Task Tag and the contents of the buffer, up to the length specified in the iSCSI Header is transferred to the remote node. The iSCSI Header's control information is passed to the Consumer through the iSCSI QP's Receive Queue.","In step , if the incoming iSCSI Header is something other than a Data-in or R2T Transfer, the entire iSCSI message (control information and any data) is passed to the Consumer through the iSCSI QP's Receive Queue.",{"@attributes":{"id":"p-0172","num":"0171"},"figref":["FIGS. 18A-18B","FIG. 11"]},"For RDMA Read Request , if the incoming DDP Segment's Header references an Untagged Buffer with Buffer Number 2, then the incoming DDP Header's Message Sequence Number (MSN) is used to index into the RDMA Read Resource Queue. This corresponds to step .","To index into the RDMA Read Request Queue the IPSOE maintains a next expected MSN. In step , if the incoming DDP Header's MSN is the next expected MSN or corresponds to the MSN that would be associated with an available RDMA Read Request Queue Entry, then the incoming DDP Segment's payload (i.e. the RDMA Read Request) is placed in the RDMA Read Request Queue Entry referenced by the incoming DDP Header's MSN. Otherwise the RDMA Stream termination process is invoked by the IPSOE. The RDMA Stream termination process consists of creating a Terminate RDMA Message that contains the cause of the termination, sending the Terminate RDMA Message to the other side of the RDMA Stream, and then tearing down the RDMA Stream (e.g. by tearing down the TCP Connection).","In step , the Tag_Index portion of the incoming RDMA Read Request Header's Source STag is used to validate the incoming RDMA Read Request.","In step , the following checks are then performed on the entry that has been indexed by the Tag_Index portion of the incoming RDMA Read Request Header's Source STag: a) the Valid Entry field is set; b) the Entry Type for the entry is set to window (i.e. regions cannot be used for remote access); c) the PD in the QP context associated with the incoming TCP Segment matches the PD of the Memory Window Entry; d) the portion of the DDP Header's STag that is the Tag_Instance matches Tag_Instance in the MWE; e) the base address (Target Offset) and length (MPA Header Length) of the incoming DDP Segment is within the range of addresses associated with the MWE; and f) the type of access is valid (i.e. the MWE has remote read access enabled).","If all the checks pass, the IPSOE creates the RDMA Read Responses by reading the Memory Window referenced by the RDMA Read Request and issuing the RDMA Read Responses. Otherwise a Terminate Message is generated describing the cause of the error.","For RDMA Read Response or RDMA Write , in step , if the incoming DDP Segment's Header references a Tagged Buffer, then the Tag_Index portion of the DDP Header's STag is used to index into the Memory Region\/Window Table.","In step , the following checks are performed on the entry that has been indexed by the Tag_Index portion of the incoming DDP Header's STag: a) the Valid Entry field is set; b) the Entry Type for the entry is set to window (i.e. regions cannot be used for remote access); c) the PD in the QP context associated with the incoming TCP Segment matches the PD of the Memory Window Entry; d) the portion of the DDP Header's STag that is the Tag_Instance matches Tag_Instance in the MWE; e) the base address (Target Offset) and length (MPA Header Length) of the incoming DDP Segment is within the range of addresses associated with the MWE; and f) the type of access is valid (i.e. the MWE has remote write access enabled). If all the checks pass, then processing continues to step , otherwise a Terminate Message is generated describing the cause of the error.","In step , the following fields are checked: the DDP standard's Last bit in the incoming DDP Header (if set it indicates the incoming DDP Segment is the last DDP Segment of a RDMA Message); the One Touch Enabled bit stored in the Memory TPT entry referenced by the STag; the Touched bit stored in the Memory TPT entry referenced by the STag; Stored DDP (Byte Stream) Sequence Number stored in the Memory TPT entry referenced by the STag; the underlying TCP Byte Sequence Number; and the Last Byte of the Incoming DDP Segment's (Byte Stream) Sequence Number. In step , the following set of checks is performed against the above-listed fields.","If the Last bit is not set, then the incoming DDP Header's Target Offset field is used to index into the Memory Region\/Window referenced by the Memory TPT entry and the incoming DDP Segment's payload is transferred into the Memory Region\/Window (starting at the TO).","If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit reset, then the incoming DDP Header's Target Offset field is used to index into the Memory Region\/Window referenced by the Memory TPT entry and the incoming DDP Segment's payload is transferred into the Memory Region\/Window (starting at the TO).","If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit set and the Touched bit is also set, then the Memory TPT entry's Valid Entry bit is reset and a Terminate Message is generated describing the cause of the error (e.g. two access attempted on a One Touch Region\/Window).","If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit set and the Touched bit is not set and the Last Byte of the Incoming DDP Segment's (Byte Stream) Sequence Number is equal to the Next Expected TCP Byte Sequence Number minus 1, then the Memory TPT entry's Valid Entry bit is reset and the incoming DDP Header's Target Offset field is used to index into the Memory Region\/Window referenced by the Memory TPT entry and the incoming DDP Segment's payload is transferred into the Memory Region\/Window (starting at the TO). This covers the case where the Incoming DDP Segment is the last segment of a Tagged Buffer Message and is received in order.","If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit set and the Touched bit is not set and the Last Byte of the Incoming DDP Segment's (Byte Stream) Sequence Number is within the TCP Byte Sequence Number Window, but is not the Next Expected TCP Byte Sequence Number minus 1, then the Memory TPT entry's Touched bit is set, the (Byte Stream) Sequence Number associated with the Last Byte of the incoming DDP Segment's payload is stored in the Memory TPT entry's DDP Sequence Number field, and the incoming DDP Segment's payload is transferred into the Memory Region\/Window (starting at the TO). When the incoming byte stream lines up with the end of the Memory TPT entry's DDP Sequence Number field, the Memory TPT's Valid Entry field is reset. This covers the case where the Incoming DDP Segment is the last segment of a Tagged Buffer Message and is received out of order.","If the Last bit is set and Memory TPT entry associated with the incoming DDP Segment has the One Touch Enabled bit set and the Touched bit is not set and the Last Byte of the Incoming DDP Segment's (Byte Stream) Sequence Number is outside of the TCP Byte Sequence Number Window, then the Incoming DDP Segment is dropped (the sender will resend).","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions or other functional descriptive material and in a variety of other forms and that the present invention is equally applicable regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system. Functional descriptive material is information that imparts functionality to a machine. Functional descriptive material includes, but is not limited to, computer programs, instructions, rules, facts, definitions of computable functions, objects, and data structures.","The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17A"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 17B"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 18A-18B"}]},"DETDESC":[{},{}]}
