---
title: Abstract layer for automatic user interface testing
abstract: A method to provide automatic testing of a graphical user interface (GUI) having a plurality of GUI components includes maintaining an abstract layer configured to provide a uniform interface for accessing a plurality of user interface (UI) testing tools, each of which is configured to interact with one or more of the plurality of GUI components to perform automatic testing of the GUI. The method also includes receiving a test command, selecting one of the plurality of UI testing tools based on the test command, identifying the GUI component from the plurality of GUI components based on a first uniform identifier in the test command, and utilizing the uniform interface to communicate with the selected UI testing tool for interacting with the GUI component based on the test command.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09465726&OS=09465726&RS=09465726
owner: VMware, Inc.
number: 09465726
owner_city: Palo Alto
owner_country: US
publication_date: 20130605
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Automatic software testing refers to the process of testing software using an automatic testing tool. The automatic testing tool may control the execution of the software, compare the actual behaviors of the software with the predicted outcomes, and determine whether the software has any bugs or issues. To test a software's graphical user interface (GUI), the automatic testing tool may generate simulated user actions such as keystrokes and mouse clicks as inputs to the GUI, observe the behavior of the GUI, and validate whether the observed behavior is as predicted. Automatic software testing is an important procedure for improving the overall quality of software, and is cost-effective because the test cases may be repeatedly executed. Nonetheless, implementing the test cases may require a large amount of upfront efforts, and the test cases may not be portable to a different piece of software or a different automatic testing tool.","Since GUI software is designed for human access, it is often hard to simulate all the user actions that can be performed on the GUI. Therefore, the conventional GUI automatic testing tools are more focused on the displayed components in the GUI, while ignoring the testing of structure and organization of the software. When software becomes more and more sophisticated, and the GUI utilizes multiple technologies in multiple environments, the number of test scenarios increases as well. As a result, developing automatic test cases are often conducted by copy-paste instead of code reuse. Also, maintaining the test cases become a burden when the tightly-coupled test code causes heavy code dependencies.","Systems and methods for providing automatic software testing of a graphical user interface are described. The system may contain a plurality of user interface (UI) testing tools executing on a computer system. Each of the plurality of UI testing tools may be configured to interact with one or more of the plurality of GUI components to perform automatic testing of the GUI. The system may contain an abstract layer coupled with the plurality of UI testing tools. The abstract layer may be configured to provide a uniform interface for accessing the plurality of UI testing tools. The system may further contain an automatic test platform coupled with the abstract layer and configured to issue a test command to the abstract layer simulating a user action performed on a GUI component of the plurality of GUI components. The abstract layer may be configured to identify the GUI component based on a first uniform identifier in the test command and utilize the first uniform identifier to communicate with one of the plurality of UI testing tools for interacting with the GUI component.","In the following detailed description, reference is made to the accompanying drawings, which form a part hereof. In the drawings, similar symbols typically identify similar components, unless context dictates otherwise. The illustrative embodiments described in the detailed description, drawings, and claims are not meant to be limiting. Other embodiments may be utilized, and other changes may be made, without departing from the spirit or scope of the subject matter presented here. It will be readily understood that the aspects of the present disclosure, as generally described herein, and illustrated in the Figures, can be arranged, substituted, combined, and designed in a wide variety of different configurations, all of which are explicitly contemplated herein.","The present disclosure provides a framework for performing automatic user interface testing (hereinafter \u201cautomatic UI testing framework\u201d). The automatic UI testing framework may include automation tools, abstraction layers, design patterns, and project blueprints. The automatic UI testing framework may create a friendly and intuitive development environment for the test developers, allow natural mitigation of the common automation problems, and has short on-board time for new test developers with opportunities for gradual improvements.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 1","FIG. 1"],"b":["130","140","150","160","120","110","130","140","150","160"]},"In one embodiment, the GUI  may be an image-based human-computer interface of a software application executing in a desktop operating system (e.g., Microsoft\u00ae Windows\u00ae, MacOS\u00ae, or UNIX\u00ae X, etc) or a mobile operating system (e.g., Android\u00ae, Symbian\u00ae, Blackberry OS\u00ae, Palm\u00ae, iOS\u00ae, etc.). The GUI  may also be an interface of a web-based application displayed in a web browser such as Microsoft Internet Explorer\u00ae, Firefox\u00ae, etc. The GUI  may contain windows, menus, icons, and other image-based components that can be used to interact with the software application. Specifically, the GUI  may contain one or more GUI components  that are configured to display various types of data, and may be manipulated using a mouse device and\/or a keyboard device. Examples of GUI components  may include, without limitation, text, image, checkbox, select-box, drop-box, button, text field, icon, menu, menu item, outline field, list field. The GUI  may be developed based on one or more user interface technologies such as Java\u00ae, Apache\u00ae Flex, HTML\u00ae, C#\u00ae, etc. The GUI  may also adopt multiple GUI technologies and\/or operating on multiple environments.","In one embodiment, the UI testing tools , , and\/or  may be utilized to perform user interface testing, functional testing, internationalization (e.g., I18N) testing, and\/or localization (e.g., L10N) testing. Further, these UI testing tools may be utilized to perform regression tests or build acceptance tests to improve software development processes. The UI testing tools may be configured to simulate a user's actions in interacting with the GUI  and its GUI components . Specifically, these UI testing tools may utilize scripts and\/or high-level programming language (PL) to define the user actions that can be performed on the GUI components . During testing, these UI testing tools may simulate a user pressing a button or input a string into a text field by executing the scripts and\/or the high-level PL codes.","In one embodiment, each of the UI testing tools , , and  may have its own tools, scripting languages, and programming languages, and may support various UI technologies. The abstract layer  may decouple the UI testing platform  from these various UI testing tools , , and , as well as these different UI technologies. For example, the UI testing tool  may be a script-based testing tool configured to support web-based user interfaces, and the UI testing tool  may be a high-level PL-based testing tool configured to test WINDOW based user interfaces. Thus, the UI testing tools , , and  may be standalone software applications executing independently and operating externally with respect to the abstract layer . And the abstract layer  may be configured to provide a set of uniform services to the UI testing platform  for interacting with each of the UI testing tools , , and  via communication channels , , and . Each of the communication channels , , and  may utilize one or more communication protocols, such as, without limitation, HTML\u00ae, REST\u00ae, SOAP\u00ae, RMI\u00ae, etc.","In one embodiment, the UI testing platform  may be configured to build and maintain a test development environment, and utilize the abstract layer  for automatic testing of the GUI . The UI testing platform  may employ the set of uniform services provided by the abstract layer  to generate a common testing project, regardless of which of the UI testing tools , , or  is used to test the GUI , or what type of UI technologies the GUI  is implemented in. Thus, the common testing project, which may contain testing codes in scripts and\/or high-level PL, may stay substantially the same over time, even when the UI testing tools are changed or the GUI  are updated. Further, the UI testing platform  may reuse knowledge and codes obtained during the development of a first testing project for a second testing project, thereby saving the time and efforts in developing the second testing project. Thus, the abstract layer  may allow the building of a higher-level abstract testing platform , which may achieve tested-product independence.","In one embodiment, the abstract layer  may provide a uniform identifier service for identifying a specific GUI component . The abstract layer  may provide an abstract test automation interface and uniform tool services for accessing and control any one of the UI testing tools , , and . Specifically, the abstract layer  may automatically route the calls received from the UI testing platform  to the corresponding UI testing tools , , and\/or . The details of the abstract layer  and its various services are further described below.","In one embodiment, the UI testing platform  and the abstract layer  may be implemented by a computer system  or software running on the computer system . The computer system  may contain, among other components, a processor  and memory . The UI testing platform  and the abstract layer  may be implemented as a set of non-transitory machine-executable instructions that can be stored in the memory  and executed by the processor . Alternatively, the UI testing platform  and the abstract layer  may be implemented as one or more hardware modules in the computer system .",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 2","FIG. 1","FIG. 1","FIG. 1"],"b":["110","110","120","120","220","230","240","250","250","251","253","255","120","251","253","255","130","140","150","130","140","150","131","141","151"]},"In one embodiment, the UI testing platform  may be configured to adopt one or more uniform GUI models  to represent a GUI and its associated GUI components (the GUI and its GUI components are not shown in ). The uniform GUI model  may be deemed an abstract data object configured to \u201cdescribe\u201d the GUI and the GUI components. Further, the UI testing platform  may utilize the uniform GUI model  to uniformly describe, access, and interact with, the GUI and the GUI components that may be implemented using various UI technologies. When developing an automatic test application, the UI testing platform  may adopt a high-level PL and construct the uniform GUI model  using the same high-level PL. Thus, there is no need to create and use proxy classes that are directly tied to the structures and UI technologies of the GUI and the GUI components. Further, when the GUI and its GUI components are changed, the uniform GUI model  used for accessing the GUI and the GUI components may remain the same. Therefore, the uniform GUI model  may bring script-based advantages to a high-level PL-based UI testing platform  in terms of data structure decoupling.","In one embodiment, the goal of simplifying usage during test-development and simplifying maintenance when the GUI and GUI components are changed may be achieved by using one or more uniform identifiers  as the building blocks for the uniform GUI model  and\/or the uniform page model . Similar to the utilizing of a conventional GUI model (which has data structures that mirror the structures of the GUI and its GUI components) to retrieve GUI properties and control GUI actions, the UI testing platform  may utilize the uniform identifiers  to accomplish the same tasks. During automatic test development, the UI testing platform  may program the uniform identifiers  with identification information. During run time, the UI testing platform  may request the uniform identifier service  to generate the uniform identifiers , and request the abstract test automation interface  to locate the identified GUI components based on the uniform identifiers . Alternatively, the UI testing platform  may use the uniform GUI model  and\/or the uniform page model  as a resource to obtain additional uniform identifiers  before calling the abstract test automation interface . The details about the uniform identifier  and the uniform identifier service  are further described below.","In one embodiment, the UI testing platform  may utilize the abstract automation interface  to issue test commands to (or obtain property values via) the UI testing tools , , and . Specifically, the abstract test automation interface  may be implemented by grouping the functionalities of the UI testing tools , , and  into functional sets, including, without limiting, common tools , customized tools , and extension tools . The common tools  may contain tools handling simple GUI component automations and common user input functionalities involving e.g., buttons, labels, mouse, and\/or keyboard inputs. The customized tools  may handle composite GUI components such as tables, trees, and\/or handle scrollable containers. The extension tools  may include specialized tools that support the development and debugging of the automatic UI test codes in the UI testing platform . For example, the extension tools  may contain a tool that can record the structure and the component properties of a current GUI component. During automatic test case development, such a tool may be called to collect a GUI component's identification data. During automatic test case execution, such a tool may be invoked to obtain a particular GUI state for debugging purposes.","In one embodiment, the functional sets in the abstract test automation interface  may be supported by services provided by the uniform tool services . The uniform tool services  may be configured with, among other modules, a component tracking module , a component proxy module , a user input module , and other extension services modules  (which implement functionalities that support, e.g., test design and debugging). To perform their respective functionalities, the modules in the uniform tool services  may collaborate with each other, and may communicate with the external tool interface . For example, to serve a test command request originated from the UI testing platform , the uniform tool services  may have a set of rules for selecting an appropriate tool adapter from the external tool interface . The uniform tool services  may either statically configure, or query at run-time, the external tool interface  to determine which of the UI testing tools , , and , and the corresponding tool adapters , , and , should be utilized to perform the test command request.","In one embodiment, the component tracking module  of the uniform tool services  may be configured to track a GUI component in the current screen rendering. That is, given a uniform identifier , other modules in the uniform tool services  (e.g., the component proxy module ) may utilize the component tracking module  to determine which GUI components should be taken control of. The component proxy module  of the uniform tool services  may be configured to create one or more uniform proxies. Given a uniform identifier , the component proxy module  may facilitate GUI component interactions and cache some of the GUI component properties.","In one embodiment, the user input service module  may be configured to simulate user inputs from different devices such as keyboard, mouse, and\/or touch screen. For example, the user input service module  may receive a uniform identifier , and utilize the component tracking module  to locate the GUI component identified by the uniform identifier . Afterward, the user input service module  may transmit a simulated user input (e.g., mouse interaction, keyboard interaction, clip-board interaction) to the identified GUI component. In another example, the user input service module  may receive a GUI component's screen location data, and use the screen location data to direct the simulated user input. The user input service module  may also simulate a user input designed for whichever GUI component in the GUI that has the focus during run-time.","In one embodiment, the UI tool adapters , , and  may be configured to provide uniform access to the functionalities of the external UI testing tools , , and , respectively. Each of the UI tool adapters , , and  may include mechanisms to convert data and interpret commands, both of which are received from other components in the abstract layer . Further, the UI tool adapters , , and  may be configured to convert response data returned from the UI testing tools , , and , and transmit the converted response data to the other components in the abstract layer .","In one embodiment, the abstract layer  may provide stateless and atomic-operation services to the UI testing platform . An \u201catomic operation\u201d may contain a set of actions to be performed sequentially and\/or logically by the abstract layer  as a whole. For example, the abstract test automation interface  may receive from the UI testing platform  a first test command with optional data via a communication channel . The abstract test automation interface  may transmit the first test command to the uniform tool services  for further processing. Afterward, the abstract test automation interface  may transmit a first return message returned from the uniform tool services  back to the UI testing platform  as a response to the first test command. Thus, the above sequence of actions may be deemed a first atomic operation. In a subsequent atomic operation, the UI testing platform  may transmit a second test command to the abstract test automation interface , and forward a second return message from the abstract test automation interface  back to the UI testing platform  in response to the second command.","In one embodiment, the abstract layer  may maintain a stateless environment between the first atomic operation and the second atomic operation. In other words, the abstract layer  may not temporarily store in memory transactional data from the first atomic operation which may be used by the second atomic operation. Thus, upon the completion of the first atomic operation, the abstract layer  may clear\/discard the transactional data associated with the first atomic operation, and perform the subsequent second atomic operation as if the first atomic operation is never performed. In another embodiment, the abstract layer  may cache the GUI component properties in uniform proxies beyond the executing of an atomic operation. In this case, the abstract layer  may temporarily store transactional data from the first atomic operation which may be used by the second and\/or subsequent atomic operations.","In one embodiment, the abstract layer  may implement an atomic operation to ensure that no new screen rendering may be triggered by any other actions except the last action in the atomic operation. In other words, the last action of the atomic operation may trigger a new screen rendering for the GUI, but not the actions before the last action. In one embodiment, the abstract layer  may perform an atomic operation which contains no simulated user action. In another embodiment, the abstract layer  may implement an atomic operation with one simulated user action being at the end of a sequence of actions. In a further embodiment, the abstract layer  may implement an atomic operation with multiple data retrieving actions, as long as none of these data retrieving actions trigger new screen rendering. Also, the abstract layer  may implement an atomic operation with multiple calls to the uniform tool services , or with multiple invocations of more than one of the UI testing tools , , and .","In one embodiment, the abstract layer  may utilize the uniform identifier service  to create and support the uniform identifier . For example, when the UI testing platform  requests a uniform identifier , the uniform identifier service  may be configured to construct an instance of the uniform identifier  based on identification information supplied by the UI testing platform , and transmit the instantiated uniform identifier  to the UI testing platform  via a communication channel . Afterward, the UI testing platform  may transmit the received uniform identifier  with a test command to the abstract test automation interface , which in turn may perform a corresponding atomic operation based on the test command. For example, once a specific GUI component is identified based on the uniform identifier , the abstract layer  may perform an atomic operation to check whether the specific GUI component exists in the GUI, to request for retrieval of a property of the specific GUI component, or to invoke a mouse or keyboard action on the specific GUI component.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 3A","FIG. 3A","FIG. 1","FIG. 2"],"b":["110","212","120","220","240","241","243","212","110","120","243","310"]},"In one embodiment, the uniform identifier  may contain one or more property filters  and\/or one or more relational filters . The property filter  may be configured with a uniform property , a filtering function , and one or more filtering values . In many situations, a GUI component may be modeled differently by different UI testing tools , , and . For example, a GUI attribute (e.g., a text string) of a GUI component may be referred to as \u201clabel\u201d, \u201ccaption\u201d, or \u201ctext\u201d by different UI testing tools. To decouple the UI testing platform  from knowing these specific names used by the UI testing tools, the abstract layer  may define a common and uniform property  for this GUI attribute. Thus, the uniform property  may be deemed defined and supported by the abstract layer .","In one embodiment, the uniform property  may be a value selected from a set of supported properties defined by the abstract layer . The set of supported properties may include, without limitation, \u201cTEXT\u201d, \u201cVALUE\u201d, \u201cX\u201d, \u201cY\u201d, \u201cH\u201d, \u201cW\u201d, \u201cIMG\u201d, \u201cID\u201d, and \u201cCLS\u201d. For example, \u201cTEXT\u201d may represent a user-visible text displayed by a GUI component having a label, a caption, or a label sub-component. \u201cVALUE\u201d may represent a user-changeable property of a GUI component which can be used to select\/set a value from a list-box or a check-box. \u201cX\u201d or \u201cY\u201d may represent the x or y screen coordinate of the upper-left corner of a GUI component. \u201cH\u201d or \u201cW\u201d may represent the height or width of a GUI component. \u201cIMG\u201d may represent a graphic image of a GUI component. \u201cID\u201d may represent a non-visible fixed unique property for a GUI component. And \u201cCLS\u201d may represent a non-visible fixed property that is associated with the intrinsic class name of a GUI component.","In one embodiment, the filtering function  in the property filter  may be based on a set of supported functions defined by the abstract layer . The supported functions may include, without limitation, mathematical comparisons such as \u201c=\u201d, \u201c>\u201d, \u201c<\u201d; mathematical functions such as \u201csum\u201d, \u201cmax\u201d; text functions such as \u201ccontained\u201d. The filtering values  in the property filter  may store information provided by the UI testing platform  and used along with the uniform property  and the filtering function . Thus, the property filter  may define a filtering condition, and any GUI component that can satisfy the filtering condition may be deemed identified by the uniform identifier .","In one embodiment, once the UI testing platform  populates the uniform propriety , the filtering function , and the filtering value  of a specific uniform identifier , the abstract layer  may transmit the specific uniform identifier  to the component tracking module  and\/or the component proxy module  to identify and take control of one or more GUI components in the GUI. When the UI testing platform  supplies the uniform identifier  with multiple property filters . The multiple property filters may be deemed having an \u201cAND\u201d relationship among themselves. For example, a uniform identifier  may have three property filters : the first one describing a uniform property \u201cVISIBLE\u201d equaling \u201ctrue\u201d, the second one indicating a uniform property \u201cTEXT\u201d containing \u201cdeleted\u201d, and the third one providing a uniform property \u201cX\u201d larger than \u201c\u201d. A GUI component may be identified when its properties satisfy the filtering conditions in these three property filters .","In one embodiment, the uniform identifier  may contain one or more relational filters . In some situations, a second GUI component may be easier to identify from the perspective of a first GUI component than by using a property filter  filtering the GUI component's property values. Thus, the UI testing platform  may first define a first uniform identifier  capable of identifying the first GUI component, and then define a second uniform identifier  having a relational filter  which describes a relationship between the first GUI component and the second GUI component. The UI testing platform  may store the relationship in a relation function  of the relational filter , and store the first uniform identifier  in the relational uniform identifier  of the relational filter .","In one embodiment, similar to the filtering function , the relation function  may be based on a set of supported functions (e.g., isChildOf, isInColumnOf, isInsideOf, isBelow) defined by the abstract layer . For example, a first uniform identifier  may have a relational filter  with a relation function  being \u201cisChildOf\u201d, and a relational uniform identifier  referencing a second uniform identifier . Thus, the component tracking module  may search for a first GUI component which has a child-parent relationship with a second GUI component identified by the relational uniform identifier . Similarly, a uniform identifier  may use a relation filter  to identify a first GUI component positioned on the \u201cleft\u201d of a second GUI component, \u201cbelow\u201d a third GUI component, or have properties relative to a fourth GUI component.","In one embodiment, the component proxy module  may be configured to manage a uniform proxy  for caching information retrieved based on a uniform identifier  (having the same structure as the uniform identifier ). The uniform proxy  may serve as a bridge between the uniform identifier  and a set of matching GUI components  obtained from the current rendering GUI. In other words, the matching components  may be the GUI components that match the filtering conditions of the uniform identifier . After the uniform proxy  is under the control of the component proxy module , the abstract layer  may offer convenient access to the uniform proxy  throughout multiple atomic operations.","In one embodiment, the UI testing platform  and\/or the abstract layer  may utilize the uniform proxy  to check for the existence of matching components  or a number of the matching components . Further, the UI testing platform  and\/or the abstract layer  may access the property values of the matching components  associated with the uniform identifier , or invoke multiple user actions on the matching components . The uniform proxy  may also cache a GUI component's property values in the matching components  to improve the performance of the abstract layer .","In one embodiment, the relational filter  of a uniform identifier  may be configured to associate a uniform proxy  as its relational uniform identifier . In this case, the component tracking module  may convert the uniform proxy  into an equivalent list of property filters  for the uniform identifier . Specifically, the component tracking module  may retrieve property values from the matching components  of the uniform proxy , in order to construct the property filters .","Referring back to . In one embodiment, once a uniform identifier  is populated by the UI testing platform  with identification information, the UI testing platform  may embedded the uniform identifier  in a test command and transmit the test command to the abstract test automation interface . Based on the test command, the abstract test automation interface  may select a specific tool from the common tools , the customized tools , and\/or the extension tools . The specific tool may then extract the uniform identifier  from the test command, and transmit the uniform identifier  to the uniform tool services . Specifically, the specific tool may issue a \u201cget-matching-components-list\u201d command to the component tracking module  and\/or the component proxy module  of the uniform tool services . The component tracking module  and\/or the component proxy module  may process the \u201cget-matching-components-list\u201d command using the uniform identifier . Upon a complete execution of the \u201cget-matching-components-list\u201d command, if one or more GUI components are identified based on the uniform identifier , the component tracking service  and\/or the component proxy module  may continue the processing of the test command based on the one or more GUI components.","In one embodiment, the uniform identifier  may contain one or more property filters but no relational filter. In this case, The component tracking service  may process the \u201cget-matching-components-list\u201d function by performing one or more of the following steps: A) call a \u201cselect-UI-tool-adapter\u201d function to retrieve a UI tool adapter from the UI tool interface ; B) call a \u201crequest-for-candidates\u201d function based on one or more of the property filters in the uniform identifier  to receive a \u201ccandidate-list\u201d; C) call a \u201cmatch-property-filter\u201d function by iterating through each candidate in the \u201ccandidate-list\u201d using the remaining property filters in the uniform identifier ; D) remove candidates from the \u201ccandidate-list\u201d that do not match any one of the property filters in the uniform identifier ; and E) return the final \u201ccandidate-list\u201d as a \u201cmatching-components-list\u201d to the abstract test automation interface .","In one embodiment, the uniform identifier  may contain one or more property filters and one or more relational filters. In this case, The component tracking service  may execute the \u201cget-matching-components-list\u201d function by performing one or more of the following steps: A) call a \u201cconvert-relational-filter\u201d function to convert each of the relational filters in the uniform identifier  to a property filter and consolidate the property filter into an extended property filter list; B) merge the extended property filter list with the property filters of the uniform identifier  to generate a merged property filter list; C) call the uniform identifier service  providing the merged property filter list to collect a new uniform identifier ; D) issue a new \u201cget-matching-components-list\u201d command with the new uniform identifier  and collect the returned \u201cmatching-components-list\u201d; and E) return the \u201cmatching-components-list\u201d to the abstract test automation interface . The above mentioned functions may be further described below.","In one embodiment, the uniform tool services  may invoke the external tool interface  to select a specific tool adapter and its associated UI testing tool for handling some of the \u201cget-matching-components-list\u201d functions. Specifically, the external UI tool interface  may be configured to perform a \u201cselect-UI-tool-adapter\u201d function for dynamic selection of the UI tool adapter. The select-UI-tool-adapter function may be based on one or more of the following criteria: A) a type of the command to be processed; B) the uniform identifier and its property filters; C) current runtime environment variables (e.g., browser type\/version, OS type\/version, etc.); D) the available UI tool adapters that can handle the command processing; and\/or E) predefined static rules for prioritization. The select-UI-tool-adapter function may finish its operations by either F) returning a selected UI tool adapter, or G) throw exceptions for error situations.","In one embodiment, once a tool adapter is selected, the selected tool adapter may perform a \u201crequest-for-candidates\u201d function using the uniform identifier . Specifically, the selected tool adapter may be configured to perform the \u201crequest-for-candidates\u201d function based on zero, one, or more property filters in the uniform identifier . The \u201crequest-for-candidates\u201d function may include one or more of the following steps: A) choose a strategy for GUI components enumeration; B) iterate through the GUI components for potential candidate GUI components; C) for a current GUI component selected from the GUI components, apply each of the property filters to the \u201cmatch-property-filter\u201d function; D) if all of the provided property filters yield \u201ctrue\u201d result, then add the current GUI component to the candidate list; E) return empty list if no GUI component matched all property filters simultaneously; and F) return the accumulated candidate list. Thus, upon its completion, the \u201crequest-for-candidates\u201d function may identify one or more GUI components that satisfy the one or more property filters. The \u201cmatch-property-filter\u201d function is further described below.","In one embodiment, the selected tool adapter may be configured to perform a \u201cmatch-property-filter\u201d function on a current GUI component for each of the property filters in the uniform identifier. The \u201cmatch-property-filter\u201d function may include one or more of the following steps: A) invoke \u201cretrieve-property-value\u201d on the current GUI component using the uniform property in the property filter to collect the property value; B) compare the collected property value based on the filtering values and the filtering function in the property filter; and C) return \u201ctrue\u201d if comparison is successful, or \u201cfalse\u201d if otherwise. The \u201cretrieve-property-value\u201d function is further described below.","In one embodiment, the \u201cget-matching-components-list\u201d function, which may be implemented by the component tracking service , and the \u201crequest-for-candidates\u201d function, which may be implemented by the selected tool adapter, may selectively share the utilizations of the property filters in the uniform identifier  in identifying GUI components. Specifically, the selected tool adapter may pick one or some of the property filters from all the property filters in the uniform identifier  based on its specific \u201cnative\u201d knowledge about the UI test tool associated with the selected tool adapter. Afterward, the selected tool adapter may perform the \u201crequest-for-candidates\u201d function based on the picked one or some of the property filters, and obtain a subset of GUI components. The component tracking service  may then continue the \u201cget-matching-components-list\u201d function, and filter the subset of GUI component utilizing the rest of the property filters in the uniform identifier  that are not \u201cpicked\u201d by the selected tool adapter, in order to obtain the \u201cmatching-components-list\u201d result.","In one embodiment, the \u201cget-matching-components-list\u201d function may \u201ccomplement\u201d the \u201crequest-for-candidates\u201d function in choosing the property filters. Since the selected tool adapter and its associated UI testing tool may have a higher efficiency in filtering the GUI components, to improve performance, the selected tool adapter may try to utilize as many property filters, if not all, in the uniform identifier as possible. Thus, if the \u201crequest-for-candidates\u201d function manages to apply all of the uniform identifier 's property filters, then the \u201cget-matching-components-list\u201d function may not perform any additional filtering, and may simply forward the list of GUI components received from the \u201crequest-for-candidates\u201d function as the \u201cmatching-components-list\u201d result. If the \u201crequest-for-candidates\u201d function utilizes only part of the property filters, the \u201cget-matching-components-list\u201d function may then use its generic approach of extracting properties from each of the short-listed candidates and applying the remaining property filters on them to complete the filtering process. Thus, both functions may work together to maximize both performance and component access.","In one embodiment, the selected tool adapter may be configured to perform a \u201cretrieve-property-value\u201d function on a current GUI component based on a uniform property. The \u201cretrieve-property-value\u201d function may include one or more of the following steps: A) call \u201ctranslate-property\u201d function with the uniform property to receive a native property; B) retrieve the property value for the native property from the current GUI component; C) throw an exception when the retrieval fails; and D) return the property value. For example, once a uniform property \u201cVISIBLE\u201d is translated to a native property \u201cvisible\u201d for a button GUI component, the retrieve-property-value function may extract a value \u201ctrue\u201d from the button GUI component. In one embodiment, the selected tool adapter may invoke multiple retrieve-property-value functions as a group of actions within one atomic operation. The \u201cretrieve-property\u201d function is further described below.","In one embodiment, the selected tool adapter may be configured to perform a \u201ctranslate-property\u201d function based on a uniform property. The \u201ctranslate-property\u201d function may include one or more of the following steps: A) extract and evaluate the native types of the GUI components in the GUI; B) extract and evaluate current environment variables; C) extract and evaluate current GUI rendering values; D) consider the native properties supported by the associated UI testing tool; E) throw exception when translation is not supported; and F) return a native property that matches the provided uniform property. For example, the translate-property function may translate a uniform property \u201cTEXT\u201d to a native property \u201ctext\u201d for a text edit GUI component, or to a native property \u201clabel\u201d for a list item GUI component.","In one embodiment, the component tracking module  may be configured to perform the \u201cconvert-relational-filter\u201d function based on one relational filter. The \u201cconvert-relational-filter\u201d function may include one or more of the following steps: A) extract the uniform identifier from the relational filter and call the \u201cget-uniform-proxy\u201d function using the uniform identifier to create a new uniform proxy for the related component; B) pass the uniform proxy of the related component to the relation function to collect a list of property filters; and F) return the list of property filters. The \u201cget-uniform-proxy\u201d function is further described below.","In one embodiment, the component proxy module  may be configured to perform a \u201cget-uniform-proxy\u201d function based on a uniform identifier . The \u201cget-uniform-proxy\u201d function may include one or more of the following steps: A) create a new uniform proxy; B) assign the provided uniform identifier to the new uniform proxy; C) call the \u201cget-matching-components-list\u201d function providing the uniform identifier as parameter and collecting the \u201cmatching-components-list\u201d; D) assign the \u201cmatching-components-list\u201d to the created new uniform proxy; and E) return the new uniform proxy.","In one embodiment, the component proxy module  may be configured to perform a \u201cget-restricted-uniform-proxy\u201d function based on an existent uniform proxy and one or more additional property filters. The \u201cget-restricted-uniform-proxy\u201d function may include one or more of the following steps: A) create a new uniform proxy; B) retrieve an existent uniform identifier from the previously available uniform proxy; C) use the uniform identifier service  to create a new uniform identifier from the existent uniform identifier and the additional filters provided as parameters; D) assign the new uniform identifier to the new uniform proxy; E) utilizing the \u201cmatching-components-list\u201d function of the existent uniform proxy, apply the new property filters provided as parameter and generate the new \u201cmatching-components-list\u201d for the new uniform proxy; and F) return the new uniform proxy. In some situations, as the existent uniform proxy may be \u201ccached\u201d, there is little or no need to access any UI testing tool during the performing of the \u201cget-restricted-uniform-proxy\u201d function. Thus, the \u201cget-restricted-uniform-proxy\u201d function may provide an efficient approach in the testing of composite GUI components such as grid, tree, etc.","In one embodiment, the user input service module  may request a selected tool adapter to simulate one or more \u201cmouse-actions\u201d, \u201ckeyboard-actions\u201d, and\/or \u201cinput-device-x-actions\u201d. The selected tool adapter may be configured to handle a sequence of \u201cmouse-actions\u201d on a current GUI component based on one or more mouse action parameters. A sequence of \u201cmouse-actions\u201d may include, without limitation, one or more of the following steps: A) execute a mouse-button action on the current GUI component; B) execute a mouse-move action on a requested screen-point; C) execute special keyboard actions to support a special mouse action. For example, some mouse-action commands may be configured to simulate a left-click on a GUI component, a pressing of a key \u201cShift\u201d and the right mouse button, and a drag-n-drop with the current GUI component.","In one embodiment, the selected tool adapter may be configured to handle a sequence of \u201ckeyboard-actions\u201d on a current GUI component based on one or more keyboard action parameters. A sequence of \u201ckeyboard-actions\u201d may include, without limitation, one or more of the following steps: A) set the key-typing focus to the current GUI component; B) type a sequence of keys; C) press and hold a special key to support a key combination; D) release the special key to complete the key combination; E) send text content to the system clipboard; and F) retrieve the text content from the system clipboard. For example, some keyboard-actions may be configured to simulate typing some text, pressing a key combination \u201cShift-Alt-z\u201d, sending the text to the system clipboard, and pressing key combination \u201cCtrl-v.\u201d","In one embodiment, the selected tool adapter may be configured to handle a sequence of \u201cinput-device-x-actions\u201d on a current GUI component based on one or more device-x action parameters. The sequence of \u201cinput-device-x-actions\u201d may allow simulation of one or more user-component interactions through the input device \u201cX\u201d. Examples of such input devices may include touch screens, and 3D user interaction interfaces.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 3B","FIG. 3B"],"b":["330","331","330","332"]},"In one embodiment, the uniform identifier  may contain two property filters, one describing a filtering condition for a uniform property \u201cIMG\u201d, and the second one describing a filtering condition for a uniform property \u201cX.\u201d To identify the GUI component referenced by the uniform identifier , a component tracking module of the abstract layer may invoke the \u201cget-matching-components-list\u201d function with the uniform identifier . The component tracking module may then call the \u201cselect-UI-tool-adapter\u201d function with uniform identifier . In the \u201cselect-UI-tool-adapter\u201d function, an external tool interface may recognize (based on the \u201cIMG\u201d property filter) that a UI testing tool having image recognition capability is needed, and select an appropriate tool adapter accordingly. The selected tool adapter may call the \u201crequest-for-candidates\u201d function with the \u201cIMG\u201d-based property filter. The \u201crequest-for-candidates\u201d function may return from a selected UI testing tool a candidate-list with 6 entries of GUI components. Afterward, the component tracking module may call the \u201cmatch-property-filter\u201d function using the selected tool adapter for each of the 6 candidate components, passing the \u201cX=120\u201d property filter as one parameter. As the right-most candidate component may be the only GUI component that matches the \u201cX=120\u201d property filter, the other candidate components may be removed from the candidate list, and a matching component list with the right-most candidate component may be returned as a response to the \u201cget-matching-components-list\u201d function. In other words, the uniform identifier  may be used to identify the right-most graphic block in a progress bar.","In one embodiment, the uniform identifier may use regular expression or mathematic function as filtering functions. For example, the uniform identifier  may have two property filters, one property filter checking whether the uniform property \u201cCLS\u201d of the GUI component is equal to \u201cButton\u201d, the other property filter evaluating whether the uniform property \u201cTEXT\u201d matches the regular expression of \u201c*10*\u201d. Thus, if there is a button in the GUI  which has \u201c10\u201d contained in its label, then the button may be deemed to have been identified by the uniform identifier . Further, the property filter may use approximation for number evaluation. For example, a property filter may check whether the Y-position of a GUI component is within proximity of a target position value.","In one embodiment, the uniform identifier  may have one property filter based on a uniform property \u201cIMG\u201d and one relational filter having a relation function \u201cinside-of\u201d and a relational uniform identifier referring to the uniform identifier . The uniform identifier  may have one property filter based on a uniform property \u201cCLS\u201d and one relational filter having a relation function \u201cbelow-of\u201d and a relational uniform identifier referring to the uniform identifier . And the uniform identifier  may have two property filters based on uniform properties \u201cCLS\u201d and \u201cTEXT\u201d.","To identify a GUI component using the uniform identifier , the component tracking module may invoke the \u201cget-matching-components-list\u201d function using the uniform identifier  as a parameter, expecting to receive a \u201cmatching-components-list.\u201d The component tracking module may then invoke the \u201cconvert-relational-filter\u201d function using the \u201cinside-of\u201d relational filter from the uniform identifier , expecting a first list of property filters. The component tracking module may further invoke the \u201cget-uniform-proxy\u201d function, with the uniform identifier  retrieved from the relational filter \u201cinside-of\u201d as a parameter, expecting a first uniform proxy. In one embodiment, the component tracking module may then invoke the \u201cconvert-relational-filter\u201d function using the \u201cbelow-of\u201d relational filter from the uniform identifier , expecting a second list of property filters. Likewise, the component tracking module may further invoke the \u201cget-uniform-proxy\u201d function, with the uniform identifier  retrieved from the relational filter \u201cbelow-of\u201d as a parameter, expecting a second uniform proxy.","In one embodiment, the component tracking module may invoke the \u201cget-matching-components-list\u201d function, with the uniform identifier  as a parameter, and collects a \u201cmatching-components-list\u201d having one GUI component (with a label \u201cMemory\u201d). A component proxy module may create a new uniform proxy, and assign the uniform identifier  and the collected \u201cmatching-components-list\u201d to the new uniform proxy. The new uniform proxy may be deemed the second uniform proxy mentioned above. Afterward, the component tracking module may utilize the new uniform proxy to retrieve the \u201cY\u201d and the \u201cH\u201d property values (e.g.  and ) of the wrapped GUI component, and construct a list of one property filter \u201cY=212\u201d. The list of property filters may be deemed the second list of property filters mentioned above.","In one embodiment, the component tracking module may merge the property filter \u201cY=212\u201d and the property filter of uniform identifier  \u201cCLS=ProgBar\u201d into a merged property filter list. The merged property filter list may be passed to the uniform identifier service  in order to generate a new temporary uniform identifier T1. The component tracking module may then invoke the \u201cget-matching-components-list\u201d function, with the temporary uniform identifier T1 as a parameter, and generate a \u201cmatching-components-list\u201d with one GUI component (the progress bar below the \u201cMemory\u201d label). Afterward, the component proxy module may create another new uniform proxy by assigning the temporary uniform identifier T1 and the \u201cmatching-components-list\u201d generated above. The new uniform proxy may be deemed the first uniform proxy mentioned above.","In one embodiment, the component tracking module may utilize the first uniform proxy to retrieve the \u201cX\u201d, \u201cY\u201d, \u201cW\u201d and the \u201cH\u201d property values (e.g. , ,  and ) of the wrapped GUI component, and construct a list of two property filters \u201cX_between__and_\u201d and \u201cY_between__and_\u201d. The list of two property filters may be deemed the first list of property filters mentioned above. Thus, the component tracking module may merge the returned property filters \u201cX_between__and_\u201d and \u201cY_between__and_\u201d with the property filter of uniform identifier  \u201cIMG=<image>\u201d into a merged property filter list, then passes this merged property filter list to the uniform identifier service  in order to collect another temporary uniform identifier T2. Finally, the component tracking module may invoke the \u201cget-matching-components-list\u201d function with the uniform identifier T2 as a parameter, and collects a \u201cmatching-components-list\u201d with one GUI component (the progress bar separator of the progress bar below the \u201cMemory\u201d label). This GUI component may be deemed identified by the uniform identifier .","In other words, the above identification process based on the uniform identifier  may be summarized into the following steps: A) use the uniform identifier  to identify a first list of GUI components; B) generate the \u201csecond uniform proxy\u201d based on the uniform identifier  and the first list of GUI components; C) use the \u201csecond uniform proxy\u201d to generate the property filter \u201cY=212\u201d; D) generate the \u201ctemporary uniform identifier T1\u201d with the property filters \u201cY=212\u201d and \u201cCLS=ProgBar\u201d; E) use the \u201ctemporary uniform identifier T1\u201d to identify a second list of GUI components; F) generate the \u201cfirst uniform proxy\u201d based on the \u201ctemporary uniform identifier T1\u201d and the second list of GUI components; G) use the \u201cfirst uniform proxy\u201d to generate the list of two property filters \u201cX_between__and_\u201d and \u201cY_between__and_\u201d; H) generate the \u201ctemporary uniform identifier T2\u201d with the property filters \u201cX_between__and_\u201d and \u201cY_between__and_\u201d, and \u201cIMG=<image>\u201d; I) use the \u201ctemporary uniform identifier T2\u201d to identify a third list of GUI components which contain the identified GUI component.","Thus, the abstract layer  may bring the advantages of script-based UI tools to high-level PL. By utilizing a high-level PL, the UI testing platform  may be more reliable, highly scalable, and have high code reusability. The high-level PL may also be better in handling complex algorithms and data structures, as well as in supporting advanced UI technologies. Thus, the high-level PL is suitable for testing big and complex system implemented using multiple technologies. At the same time, by utilizing the abstract layer , the UI testing platform  may enable code portability and code reusability, which may reduce time and resource in providing reliable and repeatable test executions.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 4","FIG. 4"],"b":["401","401"]},"At block , a UI testing platform of an automatic testing system may be configured to maintain an abstract layer for testing a GUI having a plurality of GUI components. Each of the UI testing tools may be configured to interact with one or more of the plurality of GUI components to perform automatic testing of the GUI.","At block , the UI testing platform may issue a test command to the abstract layer for the testing of a GUI component selected from the plurality of GUI components in the GUI. The UI testing platform may obtain a first uniform identifier from the abstract layer, and embed the first uniform identifier in the test command. The abstract layer may receive the test command which is configured to simulate a user action performed on a GUI component selected from the plurality of GUI components.","At block , the abstract layer may extract the first uniform identifier from the test command, and select a UI testing tool from the plurality of UI testing tools for interacting with the GUI component. The abstract layer may be configured to dynamically identify the GUI component from the plurality of GUI components based on the first uniform identifier.","In one embodiment, the first uniform identifier may contain a first property filter having a corresponding filtering function and a corresponding filtering value. The abstract layer may obtain a first subset of GUI components that satisfy the first property filter by filtering the plurality of GUI components using the corresponding filtering function and the corresponding filtering value in the first property filter. The GUI component to be identified may be in the first subset of GUI components.","In one embodiment, in additional to the first property filter, the first uniform identifier may further contain a second property filter having a corresponding filtering function and a corresponding filtering value. In this case, the abstract layer may obtain a second subset of GUI components that satisfy the second property filter by filtering the first subset of GUI components using the corresponding filtering function and the corresponding filtering value in the second property filter. Afterward, the GUI component to be identified may be in the second subset of GUI components.","In one embodiment, the first uniform identifier may include a first relational filter having a corresponding relation function and a corresponding relational uniform identifier. The abstract layer may convert the relational filter to a first property filter based on the corresponding relation function and the corresponding relational uniform identifier in the first relational filter. The abstract layer may then obtain the GUI component from the plurality of GUI components by filtering the plurality of GUI components using the first property filter.","In one embodiment, in addition to the first relational filter, the first uniform identifier may further contain a second property filter having a corresponding relation function and a corresponding relational uniform identifier. The abstract layer may generate a second uniform identifier based on the first property filter and the second property filter, and identify the GUI component from the plurality of GUI components using the second uniform identifier.","In one embodiment, the first uniform identifier may contain a first relational filter having a corresponding relation function and a corresponding relational uniform identifier. The abstract layer may generate a uniform proxy based on a second GUI component identified from the plurality of GUI components using the corresponding relational uniform identifier. The abstract layer may generate a second property filter based on a property value extracted from the uniform proxy. The abstract layer may then obtain the GUI component from the plurality of GUI components by filtering the plurality of GUI components using the second property filter.","At block , the abstract layer may be configured to utilize a uniform interface to communicate with the selected UI testing tool for interacting with the GUI component based on the test command.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 5","FIG. 5"],"b":["501","501"]},"At block , a UI testing platform in an automatic user interface testing system may be configured to maintain an abstract layer for testing a GUI. The GUI may contain a plurality of GUI components. At block , the abstract layer may be configured to provide a uniform identifier to identify one of the plurality of GUI components. The UI testing platform may utilize the uniform identifier to issue test commands for the testing of the specific GUI component identified by the uniform identifier. At block , the abstract layer may be configured to provide a uniform interface for access a plurality of user interface (UI) testing tools. Each of the plurality of UI testing tools may be configured to interact with one or more of the plurality of GUI components.","At block , the UI testing platform may be configured to issue a test command for interacting with a GUI component selected from the plurality of GUI components. The test command may contain a specific uniform identifier for identifying the GUI component. Upon receiving the test command from the UI testing platform, the abstract layer may be configured to extract the uniform identifier from the test command. At block , the abstract layer may be configured to select a UI testing tool from the plurality of UI testing tools for handling the test command. The UI testing tool may then locate the GUI component from the GUI based on the uniform identifier, and perform automatic testing operations on the GUI component.","One skilled in the art will appreciate that, for this and other processes and methods disclosed herein, the functions performed in the processes and methods may be implemented in differing order. Furthermore, the outlined steps and operations are only provided as examples, and some of the steps and operations may be optional, combined into fewer steps and operations, or expanded into additional steps and operations without detracting from the essence of the disclosed embodiments. Moreover, one or more of the outlined steps and operations may be performed in parallel.","Systems and methods for managing code review have been disclosed. The various embodiments described herein may employ various computer-implemented operations involving data stored in computer systems. For example, these operations may require physical manipulation of physical quantities usually, though not necessarily, these quantities may take the form of electrical or magnetic signals where they, or representations of them, are capable of being stored, transferred, combined, compared, or otherwise manipulated. Further, such manipulations are often referred to in terms, such as producing, identifying, determining, or comparing. Any operations described herein that form part of one or more embodiments of the disclosure may be useful machine operations. In addition, one or more embodiments of the disclosure also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes, or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular, various general purpose machines may be used with computer programs written in accordance with the teachings herein, or it may be more convenient to construct a more specialized apparatus to perform the required operations.","The various embodiments described herein may be practiced with other computer system configurations including hand-held devices, microprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, virtual machines, and the like.","One or more embodiments of the present disclosure may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable storage medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive, network attached storage (NAS), read-only memory, random-access memory (e.g., a flash memory device), a CD (Compact Discs) CD-ROM, a CD-R, or a CD-RW, a DVD (Digital Versatile Disc), a magnetic tape, and other optical and non-optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.","Although one or more embodiments of the present disclosure have been described in some detail for clarity of understanding, it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly, the described embodiments are to be considered as illustrative and not restrictive, and the scope of the claims is not to be limited to details given herein, but may be modified within the scope and equivalents of the claims. In the claims, elements and\/or steps do not imply any particular order of operation, unless explicitly stated in the claims.","Plural instances may be provided for components, operations or structures described herein as a single instance. Finally, boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the disclosure(s). In general, structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements may fall within the scope of the appended claims(s)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
