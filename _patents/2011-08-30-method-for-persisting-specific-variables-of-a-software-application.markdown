---
title: Method for persisting specific variables of a software application
abstract: Some embodiments of the invention provide a variable persister that allows an application running on a device to efficiently make a set of variables persistent across termination and relaunch of the application. According to some embodiments of the invention, an application executing on the device can utilize this archiving service by simply having its persisted variables declared in the application's code as variables that are to be persisted. Based on such declarations, the variable persisting service of the device stores the values of the set of persisted variables in a non-volatile storage archive (e.g., disk, flash storage, etc.) when the application terminates, and retrieves these values from the archive when the application restarts such that the values of the persisted variables are restored to a state before the application was last terminated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08904373&OS=08904373&RS=08904373
owner: 
number: 08904373
owner_city: 
owner_country: 
publication_date: 20110830
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["When an application is executed on a device, the application often declares and instantiates variables that represent the state of the application or settings of the application that are customizable by users. These variables are usually assigned with initial values (i.e., default values) to represent the initial state or settings of the application when the application is initiated. As the application runs, the values of these variables may change to represent a different state of the application and\/or a changed setting by the user. For instance, the state of the application is changed when one or more document files are opened or closed by the application, or when the window location of an opened document file is changed. Similarly, the setting of the application is changed when the user selects a different appearance of the graphical user interface (GUI) of the application.","Often times, the users of the application would like to have the changed state of the application and the changed settings persist across termination and relaunch of the application, so that the application will operate under the latest (most updated) state and settings (rather than the default state and settings) the next time the application is initiated. In order for the application to operate under the customized settings each time it is launched, the variables that have been updated must be saved on a disk before the application is terminated and retrieved from the disk when the application is initiated.","Historically, applications that persist the customized settings have to be coded extensively to implement the archiving and unarchiving of the variables that represent the state settings of the application. Specifically, the author of the applications must write numerous lines of programming code to perform the archiving and unarchiving operations. Such coding is often time consuming and prone to causing errors.","Some embodiments of the invention provide a variable persister that allows an application running on a device to efficiently make a set of variables persistent across termination and relaunch of the application. To do this, the persister of some embodiments stores the values of the set of persisted variables in a non-volatile storage archive (e.g., disk, flash storage, etc.) when the application terminates, and retrieves these values from the archive when the application restarts such that the values of the persisted variables are restored to a state before the application was last terminated. In some embodiments, the persister also automatically archives the latest values of the set of persisted variables to the non-volatile storage (e.g., disk, flash storage, etc.) from time to time when the application is running. This periodic archiving while the application is running allows the persisted variables to be mostly retained even when the application crashes (i.e., quits abnormally without following the normal termination procedure) or when the application is suddenly terminated by the operating system during a fast shutdown of the device.","The variable persister in some embodiments is an archiving service that is provided on a device. According to some embodiments of the invention, an application executing on the device can utilize this archiving service by simply having its persisted variables declared in the application's code as variables that are to be persisted. Based on such declarations, the variable persisting service of the device can identify persisted variables during the launch and termination of the application, as well as during the periodic storage of the running application's state.","In some embodiments, the persister is a service that an operating system of the device provides to applications that execute on top of the operating system. The persister in some embodiments is part of the framework of the operating system that provides a runtime environment for the applications. In other embodiments, the persister is not part of the operating system, but is part of, or is, an application running (i.e., executing) on top of the operating system.","In some embodiments, an application may declare and instantiate many variables when the application is executed. Some of these variables are objects or contained within an object. Persisted variables in some embodiments represent different settings of the application, different values that are stored in one or more instances of a user-generated document and other data structures (e.g., data files created and saved by the user) associated with the application, or application state data related to a user interaction with the application at a particular time in a particular interaction. Application settings are configurations that are particular to the execution of the application. Some examples of application settings are locations of a set of tool icons, a particular appearance of the graphical user interface (GUI) of the application, etc. Examples of user-generated documents and other data structures include text documents created by text editing applications, tables created by spreadsheet applications, slide presentations created by presentation editing applications, photo albums created by photo organizing applications, video presentations created by video editing applications, etc. Examples of user-interaction, application-state data include cursor location and window location of a text document at a particular time in a particular interaction with a text editing application, etc.","In some embodiments, the persister stores the persisted variables of the application in a non-volatile storage of the device that runs the application (i.e., archiving locally). In other embodiments, instead of or in addition to archiving the persisted variables in the local device, the persister stores the persisted variables of the application in a non-volatile storage of a different device that is connected to the device that runs the application over a network, such as the Internet (i.e., archiving in a cloud). In these embodiments, archiving the persisted variables involves sending the values of the persisted variables over the network in order to store the variables in the designated non-volatile storage of the networked device.","Different embodiments store the persisted variables in different locations in the non-volatile storage. Some embodiments are implemented on a device that allows document based applications and non-document based applications to execute. Document based applications are applications that can run multiple instances at a time (e.g., a text editing application that can open multiple text documents at a time). A non-document based application, on the other hand, is an application that can only run as a single instance at any given time (e.g., a game application that can only run one instance of the game at a time).","In some embodiments, the persister stores persisted variables that represent application settings in the system files of the application, while storing in a user-generated document persisted variables that represent values in the user-generated document, and application state data that is related to the user-generated document. Alternatively, some embodiments do not store persisted variables of the application state data in the associated user-generated document file, but store the persisted variables of the application state data in a separate file that is linked to the user-generated document file.","In some embodiments, the application has a default value for each persisted variable. Whenever the application launches (and when a user generated document is opened), some embodiments automatically load the persisted variables initially with their default values, and then replace these default values with the latest values of these variables that were persisted last for them by the persister in the last persistence operation (which may have occurred during the termination of the application or the last periodic persistence of the application while it was running). Other embodiments, however, might load the persisted variables differently. For instance, after archiving new values for the persisted variables, some embodiments do not initially load default values for these persisted variables, but rather just directly load the values that were stored last by the persister for these variables. Yet other embodiments might directly load the persisted values for some persisted variables, while for other persisted variables, they might initially load default values and replace these values with the persisted values.","Some embodiments allow the application to control when to load the archived values of the persisted variables by using syntax extensions or calling application programming interface (APIs) functions of the framework within the programming code. In these embodiments, the persister does not automatically perform the unarchiving operation when the application launches, but rather, loads the archived values of the persisted variables only when instructed to do so by the application.","The preceding Summary is intended to serve as a brief introduction to some embodiments of the invention. It is not meant to be an introduction or overview of all inventive subject matter disclosed in this document. The Detailed Description that follows and the Drawings that are referred to in the Detailed Description will further describe the embodiments described in the Summary as well as other embodiments. Accordingly, to understand all the embodiments described by this document, a full review of the Summary, Detailed Description and the Drawings is needed. Moreover, the claimed subject matters are not to be limited by the illustrative details in the Summary, Detailed Description and the Drawing, but rather are to be defined by the appended claims, because the claimed subject matters can be embodied in other specific forms without departing from the spirit of the subject matters.","In the following detailed description of the invention, numerous details, examples, and embodiments of the invention are set forth and described. However, it will be clear and apparent to one skilled in the art that the invention is not limited to the embodiments set forth and that the invention may be practiced without some of the specific details and examples discussed.","Some embodiments of the invention provide a variable persister that allows an application running on a device to efficiently make a set of variables persistent across termination and relaunch of the application. To do this, the persister of some embodiments stores the values of the set of persisted variables in a non-volatile storage archive (e.g., disk, flash storage, etc.) when the application terminates, and retrieves these values from the archive when the application restarts such that the values of the persisted variables are restored to a state before the application was last terminated. In some embodiments, the persister also automatically archives the latest values of the set of persisted variables to the non-volatile storage (e.g., disk, flash storage, etc.) from time to time when the application is running. This periodic archiving while the application is running allows the persisted variables to be mostly retained even when the application crashes (i.e., quits abnormally without following the normal termination procedure) or when the application is suddenly terminated by the operating system during a fast shutdown of the device. In some embodiments, the device on which the persister is implemented may be a computer, a handheld device, a tablet, a smartphone, etc.","The variable persister in some embodiments is an archiving service that is provided on a device. According to some embodiments of the invention, an application executing on the device can utilize this archiving service by simply having its persisted variables declared in the application's code as variables that are to be persisted. Based on such declarations, the variable persisting service of the device can identify persisted variables during the launch and termination of the application, as well as during the periodic storage of the running application's state.  below illustrates an example of how persisted variables may be declared in an application's code.","In some embodiments, the persister is a service that an operating system of the device provides to applications that execute on top of the operating system. The persister in some embodiments is part of the framework of the operating system that provides a runtime environment for the applications. In other embodiments, the persister is not part of the operating system, but is part of, or is, an application running (i.e., executing) on top of the operating system.","In some embodiments, an application may declare and instantiate many variables when the application is executed. Some of these variables are objects or contained within an object. Persisted variables in some embodiments represent different settings of the application, different values that are stored in one or more instances of a user-generated document and other data structures (e.g., data files created and saved by the user) associated with the application, or application state data related to a user interaction with the application at a particular time in a particular interaction. Application settings are configurations that are particular to the execution of the application. Some examples of application settings are locations of a set of tool icons, a particular appearance of the graphical user interface (GUI) of the application, etc. Examples of user-generated documents and other data structures include text documents created by text editing applications, tables created by spreadsheet applications, slide presentations created by presentation editing applications, photo albums created by photo organizing applications, video presentations created by video editing applications, etc. Examples of user-interaction, application-state data include cursor location and window location of a text document at a particular time in a particular interaction with a text editing application, etc.","In some embodiments, the persister stores the persisted variables of the application in a non-volatile storage of the device that runs the application (i.e., archiving locally). In other embodiments, instead of or in addition to archiving the persisted variables in the local device, the persister stores the persisted variables of the application in a non-volatile storage of a different device that is connected to the device that runs the application over a network, such as the Internet (i.e., archiving in a cloud). In these embodiments, archiving the persisted variables involves sending the values of the persisted variables over the network in order to store the variables in the designated non-volatile storage of the networked device.","Different embodiments store the persisted variables in different locations in the non-volatile storage. Some embodiments are implemented on a device that allows document based applications and non-document based applications to execute. Document based applications are applications that can run multiple instances at a time (e.g., a text editing application that can open multiple text documents at a time). A non-document based application, on the other hand, is an application that can only run as a single instance at any given time (e.g., a game application that can only run one instance of the game at a time).","In some embodiments, the persister stores persisted variables that represent application settings in the system files of the application, while storing in a user-generated document persisted variables that represent values in the user-generated document, and application state data that is related to the user-generated document. Alternatively, some embodiments do not store persisted variables of the application state data in the associated user-generated document file, but store the persisted variables of the application state data in a separate file that is linked to the user-generated document file.","In some embodiments, the application has a default value for each persisted variable. Whenever the application launches (and when a user generated document is opened), some embodiments automatically load the persisted variables initially with their default values, and then replace these default values with the latest values of these variables that were persisted last for them by the persister in the last persistence operation (which may have occurred during the termination of the application or the last periodic persistence of the application while it was running) Other embodiments, however, might load the persisted variables differently. For instance, after archiving new values for the persisted variables, some embodiments do not initially load default values for these persisted variables, but rather just directly load the values that were stored last by the persister for these variables. Yet other embodiments might directly load the persisted values for some persisted variables, while for other persisted variables, they might initially load default values and replace these values with the persisted values.","Some embodiments allow the application to control when to load the archived values of the persisted variables by using syntax extensions or calling application programming interface (APIs) functions of the framework within the programming code. In these embodiments, the persister does not automatically perform the unarchiving operation when the application launches, but rather, loads the archived values of the persisted variables only when instructed to do so by the application.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 1","FIG. 1"],"b":["120","105","110","115","120","125","130","120","135","140"]},"The first stage  illustrate the application  after it has been initiated for the first time. When the application  is executed, the application  declares an object that includes variable X, variable Y, and variable Z. Among these variables, the application  declares that variables Y and Z are persisted variables. In this example, the application  declares each individual variable as either persistent or not persistent. In some embodiments, an application may declare an object in its entirety as persistent, such that each variable within the object becomes persistent.","In some embodiments, the application  includes default values for the variables that are stored in the disk storage . As shown, the disk storage  includes variable X with a default value of 0, variable Y with a default value of \u201cWhite\u201d, and variable Z with a default value of \u201cLeft\u201d. As the application is starting, the unarchiver  of the persister  retrieves the default values of the variables from the disk storage  and applies values to the application . After the unarchiver  applies the retrieved values to the application , variable X now has a default value of 0, persisted variable Y has a default value of \u201cWhite\u201d, and persisted variable Z has a default value of \u201cLeft\u201d.","The second stage  illustrates a state of the application  after the application  has been operating for a period of time. At this time, the values of the variables in object 1 have been changed (either by the user of the application or by the application itself) during the course of running the application. Specifically, variable X now has a value of 100 instead of the default value 0, variable Y has a value of \u201cBlue\u201d instead of the default value \u201cWhite\u201d, and variable Z has a value of \u201cCenter\u201d instead of the default value \u201cLeft\u201d. The second stage  also shows that the persister  performs an archiving operation for application  (either during a periodic persistence operation while application  is running or when the application  is terminating). As shown, the archiver  of the persister  archives the latest values of the variables that application  has declared as persistent. Specifically, the archiver  saves the latest values of variables Y and Z of object 1 to disk storage  because these variables have been declared as persistent. Although the second stage  of this figure shows that the persisted variables Y and Z are stored together with non-persisted variable X, in some embodiments, the persisted values are stored separately from the non-persisted variables. The different ways of storing the variables will be discussed in more detail below by reference to .","The third stage  illustrates a state of the application  when the user is restarting the application  again after the application  has been terminated. Similar to the first stage  of this figure, the unarchiver  of the persister  retrieves the default and archived values of the variables from the disk storage  and applies them to the application  as the user initiates the application . As shown, the disk storage  includes the archived values of persisted variables Y and Z that the archiver  has previously stored. As a result of the unarchiver  retrieving and applying the persistent variables to application , variable X of object 1 still has the default value of 0 because variable X is not a persisted variable, variable Y now has the archived value of \u201cBlue\u201d instead of the default value because variable Y is a persisted variable, and variable Z now has the archived value of \u201cCenter\u201d instead of the default value because variable Z is a persisted variable.","As mentioned above, the persister of some embodiments provides a mechanism for an author of the application to declare a set of variables to be persistent within the programming code. Different embodiments provide different mechanisms for an application to declare a variable persistent. In some embodiments, a variable may be declared as persistent by being associated with a keyword within the programming code.  illustrates several examples of declaring variables by showing a portion of pseudo code. As shown in the first line of the pseudo code, variable X is declared and instantiated with a value of 0. Since no persistent keyword is associated with this variable, variable X is a non-persisted variable. The next line of the programming code illustrates an example of declaring variable Y as a persisted variable by associating the variable with a keyword \u201cpersistent\u201d. As mentioned above, the persister of some embodiments may store a persisted variable locally (i.e., within a disk storage of a device that runs the application) or store the persisted variable in a cloud (i.e., within a disk storage of a different device that is connected to the device that runs the application over a network). Some embodiments also allow the author of the application to specify whether to store the variable locally or in a cloud by associating a different keyword with the variable. As shown in the next several lines in the pseudo code, in addition to the \u201cpersistent\u201d keyword, variable Z is also associated with a keyword \u201clocal\u201d which indicates to the persister that this variable should be stored locally. Variable A is associated with a different keyword \u201ccloud\u201d, which indicates to the persister that this variable should be stored in a cloud, rather than storing locally at the device that runs the application.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIGS. 1 and 2","FIGS. 3 and 4","FIG. 3"],"b":["300","305","310","315","320","325","330"]},"As shown in , the GUI  includes a desktop area  of the operating system of a device for the user to interact with the operating system and its applications. When an application is executed within the operating system, the application may provide its own GUI that appears on the desktop area  to interact with the user. The GUI  also includes a dock  within the desktop area . The dock  includes a group of application icons (including a media player icon ) that provide easy access to some of the applications and indicate which applications are currently running. In some embodiments, the user can initiate an application by selecting the icon that corresponds to the application on the dock .","The operation of the persister will now be described by reference to the state of this GUI  during the six stages , , , , , and . The first stage  shows the GUI  after the user has initiated a media player application (e.g., by selecting the media player icon ). The initiation of the media player application is indicated by the GUI  of the media player application appearing on the desktop  and a blue light  appearing on top of the media player icon . As shown, the GUI  of the media player application includes an exit button  for terminating the application and a browser display area  for browsing media clips on the computer.","During the initiation of the application, the media player application declares and instantiates a set of objects and variables. Some of the instantiated variables define the settings of the GUI  of the application. For instance, the media player application may include a \u201cbrowser view\u201d variable that defines the look and feel of the browser display area . In this example, the \u201cbrowser view\u201d variable has a default value of \u201cgrid view\u201d, which instructs the media player application to configure the browser display area  to display small icons that represent different media clips in a grid (in rows and columns).","Although the media player application displays the browser display area  in a \u201cgrid view\u201d in the first stage , the user can change the look and feel of the browser display area  through the GUI  (e.g, by making a selection in a drop down menu, on a tool bar, etc.). In some embodiments, the selection of a different view causes the value of the \u201cbrowser view\u201d variable to change. The media player application in turn changes the look and feel of the browser display area  based on the new value of the \u201cbrowser view\u201d variable.","As mentioned above, one of the features of the persister is the ability to allow an application to declare any variables as persistent in the programming code. In this example, the media player application has declared the \u201cbrowser view\u201d variable as persistent so that when the user changes the appearance of the browser display area , the application can restore to that appearance the next time it is initiated.","The second stage  illustrates the GUI  after the user has selected a different look and feel for the display area . Specifically, the user has changed the browser view from the \u201cgrid view\u201d to the \u201ccover view\u201d. The selection causes the media player application to change the value of the \u201cbrowser view\u201d variable from \u201cgrid view\u201d to \u201ccover view\u201d. As a result, the media player application changes the look and feel of the browser display area  based on the new value of the \u201cbrowser view\u201d variable. As shown, the browser display area  is now split into two areas: a top area  and a bottom area . The top area  includes large icons that represent different media clips on the computer system. The bottom area  provides a list of descriptions for the different media clips.","The third stage  illustrates the GUI  of the operating system when the user is terminating the media player application by selecting the exit button , as indicated by the highlighting of the exit button . In this third stage , as the media player application is terminating, the persister archives the latest values of the variables that the media player application has declared to be persistent. In this example, since the media player application has declared the variable \u201cbrowser view\u201d to be persistent, the persister stores the variable \u201cbrowser view\u201d with its latest value\u2014\u201ccover view\u201d\u2014in a non-volatile storage (e.g., disk, flash storage, etc.).","The fourth stage  is a transitional stage after the media player application has been completely terminated. As shown, the GUI  of the media player application has disappeared from the desktop  and the blue light  has disappeared from the top of the media player icon .","In the fifth stage , the user has initiated the media player application again (e.g., by selecting the media player icon ), as indicated by the animated media player icon  in the dock. When the media player application is initiating, the persister of some embodiments retrieves the variables that were persisted last for the application by the persister. In this example, the persister retrieves the variable \u201cbrowser view\u201d having the persisted value of \u201ccover view\u201d from the non-volatile storage. Furthermore, the persister applies this archived variable to the application. In some embodiments, the persister applies the archived variable to the application by updating the variable that was instantiated by the application with the persisted value. In this example, the persister updates the \u201cbrowser view\u201d variable of the application with the persisted value of \u201ccover view\u201d so that the media player application now has the persisted value \u201ccover view\u201d instead of the default value \u201cgrid view\u201d for the variable \u201cbrowser view\u201d.","The sixth stage  shows the GUI  after the media player application has completed its initiation, as indicated by the GUI  of the media player application appearing on the desktop  and the blue light  appearing on top of the media player icon . As a result of the persister retrieving and applying the archived value of the variable \u201cbrowser view\u201d for the media player application, the media player application displays the browser display area  in the \u201ccover view\u201d setting, instead of the default \u201cgrid view\u201d setting.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 3","FIG. 4","FIG. 4"],"b":["300","405","410","415","420","425","430"]},"The GUI  in  is identical to the GUI  of , except that the dock  has a game icon  representing the game application. The first stage  shows the GUI  after the user has initiated the game application by selecting the game icon . The initiation of the game application is indicated by the GUI  of the game application appearing on the desktop  and a blue light  appearing on top of the game icon . As shown, the GUI  of the game application includes an exit button  for terminating the game application and a start game icon  for initiating a new game. In addition, the GUI  also shows the score and the game level for the current user.","Similar to the media player application of , the game application declares and instantiates a set of objects and variables at the initiation of the application. Some of the instantiated variables define specific information of a user of the application. For instance, the game application may include a \u201cuser score\u201d variable that defines the current score of a particular user, and a \u201cuser game level\u201d variable that defines the current game level for the particular user. In this example, because the user has just started the game application for the first time, the \u201cuser score\u201d has a value of 0 and the \u201cuser game level\u201d variables have a value of 0. As a result, the game application displays the current score of 0 and the current game level of 0 in the GUI .","One of the features of the persister is the ability to allow the author of an application to declare any variable as persistent in the programming code. In this example, the game application has declared the \u201cuser score\u201d variable and the \u201cuser game level\u201d variable as persistent. As the user begins to play the game within the game application, the two variables \u201cuser score\u201d and \u201cuser game level\u201d will be changed.","The second stage  illustrates the GUI  after the user has started playing the game for a period of time. At this stage, the user has been playing at game level  and has accumulated a total score of 1435. The values of the \u201cuser score\u201d variable and the \u201cuser game level\u201d variable are updated in real time to reflect the current state of the game for the user. Consequently, the game application displays the score and game level of the user on the GUI  based on the most current values of the two variables. As shown, the GUI  displays a score of 1435 and a game level of 3.","The third stage  illustrates the GUI  of the operating system when the user is terminating the game application by selecting the exit button  (as indicated by the highlighting of the exit button ). In this third stage , as the game application is terminating, the persister archives the latest values of the variables that the game application has declared to be persistent. In this example, since the game application has declared the \u201cuser score\u201d and the \u201cuser game level\u201d variables as persisted variables, the persister stores these variables with their latest values in a non-volatile storage (e.g., disk, flash storage, etc.).","The fourth stage  is a transitional stage after the game application has been completely terminated. As shown, the GUI  of the game application has disappeared from the desktop  and the blue light  has disappeared from the top of the game icon .","In the fifth stage , the user has initiated the game application again by selecting the game icon , as indicated by the animated game icon  in the dock. When the game application is initiating, the persister retrieves the variables that were persisted last by the persister in the non-volatile storage. In this example, the persister retrieves the \u201cuser score\u201d variable and the \u201cuser game level\u201d variable from the disk. Furthermore, the persister applies these archived variables to the game application so that the game application uses the archived values of the two variables instead of the default values.","The sixth stage  shows the GUI  after the game application has completed its initiation, as indicated by the GUI  of the game application appearing on the desktop  and the blue light  appearing on top of the game icon . As a result of the persister retrieving and applying the archived values of the \u201cuser score\u201d variable and the \u201cuser game level\u201d variable for the game application, the game application begins with where the user has left off before the termination of the application. In addition, the GUI  of the game application displays the user score of 1435 (instead of the default value of 0) and the game level of 3 (instead of the default value of 0).","Several more detailed embodiments are described below. Section I describes details of the archiving and unarchiving operations of some embodiments. Section II then describes the software architecture of a persister of some embodiments. Finally, Section III describes an electronic system with which some embodiments of the invention are implemented.","I. Archiving and Unarchiving","A. Archiving","As mentioned above, the persister of some embodiments provides a service that automatically archives a set of persisted variables of an application when the application is terminating.  conceptually illustrates an example of such a process. Specifically,  illustrates a process  of some embodiments for archiving a set of persisted variables for an application. In some embodiments, the process  is automatically performed by the archiver of a persister for an application when the application is terminating. The process  will now be described by reference to .  illustrates an example dataflow of the persisted variables during an archiving operation.","The process  illustrates the operation of archiving a set of persisted variable for an application in which all the constructs are objects. Thus, all variables within the applications are objects, or exist within an object. However, the persister of some embodiments can also perform the archiving operation for applications that include both objects as well as other variables that are not objects or variables that exist within an object, as well as applications that do not include objects at all (e.g., applications written using imperative\/procedural programming, rather than object-oriented programming).","As shown, the process  begins by receiving (at ) a termination event of the application. In some embodiments, a termination event occurs when a user of the application quits (or exits) the application or when the user of the application closes a document associated with the application. Upon receiving such a termination event, the archiver archives all of the persisted variables of the application.","Next, the process retrieves (at ) a handle of an object of the application from a list of objects that was created at the initiation of the application. When the application is initiated, the archiver of some embodiments creates a list that includes persisted objects and objects containing persisted variables. In some embodiments, the list includes the name and location of the objects, and the location of the file to which the archived variables are to be saved. As the application is terminating, the process  uses the created list to retrieve all of the application's objects that include persisted variables.","For the retrieved object, the process identifies (at ) the variables in the object that have been declared as persistent. In some embodiments, the process determines whether a variable is persistent or not persistent by checking whether the variable is associated with a \u201cpersistent\u201d keyword when the variable is declared. In some embodiments, each variable of the application includes a persistence attribute that indicates whether the variable is persistent or not persistent. In these embodiments, the process determines whether a variable is persistent or not persistent by checking the persistence attribute of the variable.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 6","FIG. 6"],"b":["500","605","135","130","605","130"]},"As shown, the system memory  stores two instantiated objects of an application when the application is running. Object 1 includes a non-persisted variable X having a value of 100, a persisted variable Y having a value of \u201cBlue\u201d, and a persisted variable Z having a value of \u201cCenter\u201d. Furthermore, object 2 includes a persisted variable Q having a value of 3, a non-persisted variable R having a value of 50%, and a persisted variable S having a value of false. In some embodiments, each instantiated variable includes an attribute that indicates whether the variable has been declared as persistent or not. In these embodiments, the archiver  identifies the persisted variables by checking the value of the persistence attribute of each variable. Since both objects contain persisted variables, the archiver has included both objects to the list of objects created when the application is initiated.","The process  then extracts (at ) the persisted variables from the object. Next, the process includes (at ) the extracted persisted variables with other persisted variables in a stream of data. In some embodiments, the stream of data is for writing to a file in a non-volatile storage.","Referring to , the archiver  extracts variables Y and Z from object 1 and variables Q and S from object 2 because the application has declared these variables as persistent. The archiver  includes each of the extracted variables into a stream of data with other persisted variables for storing in the disk storage .","The process  next deconstructs (at ) the object. In some embodiments, the deconstruction of an object involves releasing system resources such as memory, GPU locks, and locks on network interfaces that have been allocated for the object. In some embodiments, deconstructing an object involves disengaging the object from other objects, etc. so that the other objects will not message the deconstructed object about events that occur for which the deconstructed object was registered.","Next, the process determines (at ) if there are more objects that have persisted variables in the list. If there are more objects in the list, the process returns to  to retrieve a handle of another object, and will cycle through operations - until all of the objects in the list are processed.","If there are no more objects in the list, the process stores (at ) the stream of data on a disk. Then the process ends. Referring to , after the archiver  has included all persisted variables from the objects in the list into a stream of data, the archiver  sends the stream of data to the disk storage . As shown, the disk storage  includes persisted variable Y with the latest value of \u201cBlue\u201d, persisted variable Z with the latest value of \u201cCenter\u201d, persisted variable Q with the latest value of 3, and persisted variable S with the latest value of false.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 6","FIG. 7","FIG. 6"],"b":["130","130"]},"In some embodiments, the archiver  stores all extracted persisted variables in a single file (e.g., the archived variables file) that is separate from the object code, application settings, and user generated data, regardless of the types of the persisted variables. In these embodiments, the archiver combines all persisted variables into one stream of data and writes it to a single file on a disk. In other embodiments, the archiver may store different types of variables into different files that are associated with the application. For instance, the archiver may store persisted variables that represent the application settings and stores these persisted variables in the system setting file. The archiver may also store persisted variables that represent values of different user generated documents and application state data related to the respective user generated documents. Alternatively, the archiver may not store persisted values that represent the application state data in the associated user-generated document file, but stores the persisted variables of the application state data in a separate file that is linked to the user-generated file. In these embodiments, the archiver writes different types of persisted variables into different streams of data and stores the different streams of data into the different files associated with the application.","As shown in , after the archiver  extracted the persisted variables from the objects, the archiver creates multiple streams of data for different types of persisted variables to be written into files. In this example, the archiver  stores the persisted variables of object 1 in the system file and stores the persisted variables of object 2 in the user data file.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 7","FIG. 2"],"b":["135","130","130","135"]},"As mentioned above, the process  is described for an application in which all the constructs are objects. For other types of applications in which some variables are not objects or within an object, the persister may retrieve each variable of the application that the application has declared to be persistent, include the values of the persisted variables in the stream of data, and store the stream of data on the disk.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 5","FIG. 8"]},"The process  illustrates the operation of archiving a set of persisted variable for an application in which all the constructs are objects. Thus, all variables within the application are objects, or exist within an object. However, the persister of some embodiments can also perform the archiving operation for applications that include both objects as well as other variables that are not objects or variables that exist within an object, as well as applications that do not include objects at all (e.g., applications written using imperative\/procedural programming, rather than object-oriented programming).","The process  begins by retrieving (at ) a handle of an object from the created list. As mentioned above, the archiver of some embodiments creates a list that includes objects containing persisted variables for an application when the application is initiated. The process  uses this created list during this operation to retrieve to retrieve all persisted variables and objects that include persisted variables.","For the retrieved object, the process identifies (at ) the variables in the object that have been declared as persistent. In some embodiments, the process determines whether a variable is persistent or not persistent by checking whether the variable is associated with a \u201cpersistent\u201d keyword when the variable is declared. In other embodiments, the process determines whether a variable is persistent by checking the persistence attribute of the variable.","The process then extracts (at ) the persisted variables from the object. Next, the process includes (at ) the extracted persisted variables with other persisted variables in a stream of data. As mentioned, the process of some embodiments includes all the persistened variables into one stream of data while other embodiments include different types of persisted variables in different streams of data. In some embodiments, the streams of data are for writing to a file on a disk.","Next, the process determines (at ) if there are more objects in the list. If there are more objects in the list, the process returns to  to retrieve a handle of another object, and will cycle through operations - until all of the objects in the list are processed.","If there are no more objects in the list, the process stores (at ) the stream of data on a disk. After storing the stream of data on the disk, the process determines (at ) if the application is terminated. The application may be terminated normally (i.e., by a user quitting the application) or abnormally (i.e., the application crashing or suddenly terminating due to circumstances of the operating system or the device in which the application runs).","If the application is terminated, the process ends. If the application is not terminated, the process determines (at ) if the timer has expired. The archiver of some embodiments performs the archiving operation at a predetermined interval (e.g., every five minutes) when the application is running. Therefore, the archiver uses a timer to determine when to archive the persisted variables for the application. If the time has expired, the process returns to  to retrieve a handle of an object from the created list, and will cycle through operations - until the timer has expired. If the timer has not expired, the process returns to  to determine if the application is terminated.","As mentioned above, the process  is described for an application in which all the constructs are objects. For other types of applications in which some variables are not objects or within an object, the persister may retrieve each variable of the application that the application has declared to be persistent, include the values of the persisted variables in the stream of data, and store the stream of data on the disk.","B. Unarchiving",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIGS. 5","FIG. 9","FIG. 10","FIG. 10"],"b":["6","7","8","900","900","900","900"]},"The process  illustrates the operation of unarchiving a set of persisted variable for an application in which all the constructs are object. Thus, all variables within the application are objects, or exist within an object. However, the persister of some embodiments can also perform the unarchiving operation of other types of applications in which some variables are not objects or within an object.","As shown, the process  begins by receiving (at ) an initialization event of an application. In some embodiments, an initialization event occurs when the user initiates the application, or opens a document associated with the application (e.g., by selecting the application from a desktop GUI or from a menu of applications, by selecting a document associated with the application from a folder window, etc.).","Next, the process instantiates (at ) an object for the application. As mentioned above, an application may declare several variables and\/or objects at the initiation of the application. In some embodiments, the process instantiates the objects (and\/or variables) for the application.","The process then determines (at ) whether the instantiated object contains a persisted variable. If the object contains a persisted variable, the process includes (at ) the object in the list of persisted objects. This list of persisted objects is created to be used when the persister archives the persisted variables for the application when the application terminates, or periodically when then application runs.","Then, the process determines (at ) whether there are more objects to be instantiated. If there are more objects to be instantiated, the process returns to  to instantiate another object, and will cycle through operations - until there are no more objects to be instantiated.","If the process determines that the object does not contain any persisted variables at , the process proceeds directly to  to determine if there are more objects to be instantiated. In some embodiments, the process also assigns default values to the instantiated variables.","Next, the process retrieves (at ) from the disk a stream of data that contains a set of variables for the application. In some embodiments in which the persister archives the persisted variables in multiple streams of data (that is written into multiple files), the process retrieves the multiple streams of data during this operation.","The process next (at ) converts the stream of data into the set of persisted variables. Referring to ,  illustrates the data flow of the persisted variables when the unarchiver is performing the process . As shown,  includes system memory , an unarchiver , an application launcher , and a disk storage . The disk storage  includes an object code file (e.g., an executable file), a set of system files, and a set of user generated data files for the application. The object code file contains instructions that when executed will instantiate a set of objects and variables in the system memory. For this application, the object code contains two objects: object 1 and object 2. Object 1 includes variable X with a default value of 0, variable Y with a default value of \u201cWhite\u201d, and variable Z with a default value of \u201cLeft\u201d. Object 2 includes variable Q with a default value of 3, variable R with a default value of 50%, and variable S with a default value of false. As the application is initiated, the set of variables of the application are instantiated with the default values in the system memory , as shown in the figure.","The system files and user data files file contain different types of persisted variables that the archiver has last stored. As shown, the system file includes persisted variables of object 1 and the user data file includes persisted variables of object 2. Object 1 includes variable Y with a current value of \u201cBlue\u201d and variable Z with a current value of \u201cCenter\u201d. Object 2 includes variable Q with a current value of 3 and variable S with a current value of false. When the application is initiated, the application launcher loads the program code of the application from the disk storage  to the system memory . The application instantiates the objects and their variables with the stored default values. The unarchiver  then retrieves one or more bit streams that contain the archived variables from the disk storage . In this example, the unarchiver  retrieves the persistent variables from the system files and the user data files of the application. However, in some embodiments, the archiver stores all or some of the persisted variables in a separate file. In these embodiments, the unarchiver  also retrieves the persistent variables from the separate file.","Furthermore, the unarchiver  may retrieve the persisted variables from the files that are stored in a local device if the persister is configured to archive locally (i.e., storing the persisted variables on a disk of the device that runs the application), or retrieve the persisted variables from the files that are stored in a networked device if the persister is configured to archive in a cloud (i.e., storing the persisted variables on a disk of a different device that is connected to the device that runs the application over a network).","Referring back to , the process  next selects (at ) an instantiated object from the application. The process then updates (at ) the persisted variables in the object with the archived values. Next, the process determines (at ) whether there are more instantiated objects of the application. If there are more instantiated objects, the process returns to  to receive another instantiated object, and will cycle through operations - until all of the instantiated objects of the application are updated. If there are no more instantiated objects, the process ends.","Referring to , the unarchiver  receives instantiated objects 1 and 2 from the system memory . For object 1, the unarchiver  updates persisted variable Y with the archived value of \u201cBlue\u201d and updates persisted variable Z with the archived value of \u201cCenter\u201d. Similarly for object 2, the unarchiver  updates persisted variable Q with the archived value 3 and updates persisted variable S with the archived value false.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIGS. 9 and 10"},"As mentioned above, the process  is described for an application in which all the constructs are objects. For other types of applications in which some variables are not objects or within an object, the persister may identify all the persisted variables of the application when the variables are instantiated during the launch of the application. The persister may then update the value of each persisted variable of the application with the archived value.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 9","FIG. 11"],"b":"1100"},"The process  illustrates the operation of unarchiving a set of persisted variable for an application in which all the constructs are object. Thus, all variables within the applications are objects, or exist within an object. However, the persister of some embodiments can also perform the unarchiving operation for applications that include both objects as well as other variables that are not objects or variables that exist within an object, as well as applications that do not include objects at all (e.g., applications written using imperative\/procedural programming, rather than object-oriented programming).","In some embodiments, the persister performs the process  when it receives instructions from the application to unarchive the persisted variables. As such, the process  begins by receiving (at ) instructions from the application to load the persisted variables of the application. As mentioned above, the application may instruct the persister of some embodiments to load the persisted variables using syntax extensions or application programming interface (APIs) of the framework within the programming code. In these embodiments, the persister receives the instructions by receiving programming syntax for loading the persisted variables or receiving the API function call from the application.","Next, the process retrieves (at ) from the disk a stream of data that contains a set of persisted variables for the application. In some embodiments in which the persister archives the persisted variables in multiple streams of data (that is written into multiple files), the process retrieves the multiple streams of data during this operation. The process next (at ) converts the stream of data into the set of persisted variables.","The process then selects (at ) an instantiated object from the application. After selecting an object, the process updates (at ) the persisted variables in the object with the archived values. Next, the process determines (at ) whether there are more instantiated objects of the application. If there are more instantiated objects, the process returns to  to receive another instantiated object, and will cycle through operations - until all of the instantiated objects of the application are updated. If there is no more instantiated object, the process ends.","As mentioned above, the process  is described for an application in which all the constructs are objects. For other types of applications in which some variables are not objects or within an object, the persister may select each persisted variable (that is identified during the launch of the application as part of the process  of ) of the application when instructed by the application, and update the variable with the archived value.","C. Different Types of Applications",{"@attributes":{"id":"p-0120","num":"0119"},"figref":["FIGS. 7 and 10","FIG. 12","FIG. 12"],"b":["1205","1210"]},"Example 1 illustrates an example of a document based application. A document based application is an application that can run multiple instances at the same time where each instance represent a different data file of the application. Examples of document based applications include a text editing application, a spreadsheet application, etc. As shown in Example 1, the document based application has stored four documents in the disk storage . As mentioned above, a document based application may open and access multiple data files at the same time. In this example, the application has loaded and opened two of the four documents from the disk storage  to the system memory  (e.g., the text editing application opens two text documents from the disk storage). In some embodiments, when the archiver performs the archiving operation on the application, the archiver stores the persisted variables associated with each individual document in the respective document file in the disk storage.","Example 2 illustrates an example of a non-document based application. A non-document based application is an application that can run only one instance at a time, even though the application may store multiple associated data files in the disk storage . An example of a non-document application is a game application. As shown in this example, the non-document based application has stored two user data files in the disk storage . For a non-document based application such as a game application, these data files may include players' information such as game score and game level for each player of the game. However, because this is a non-document based application, the application may load and open only one data file in the system memory  at a time, as shown in this example. In some embodiments, when the archiver performs the archiving operation on the application, the archiver also stores the persisted variables associated with each individual user data in the respective user data file in the disk storage.","Example 3 illustrates another example of a non-document based application. Unlike the non-document based application in Example 2, the non-document based application in Example 3 does not store any user data file in the disk storage . As such, even though the application may create one or more data files in the system memory when the application is running, the content of the data files will be lost once the application terminates. For instance, a game application of some embodiments may store the player's score in the system memory while the player is using the game application. However, once the player terminates the game, the score will be lost the next time the player starts the game application. In some embodiments, when the archiver performs the archiving operation on this application, the archiver does not store any variables related to the user data in the disk storage.","The overall operation of the persister  will now be described by reference to . This figure presents the state diagram  that represents various operations of the persister  in some embodiments. One of ordinary skill in the art will recognize that the state diagram does not describe all states of the persister , but instead specifically pertains to its operations during archiving and unarchiving of variables for a single application. The persister of some embodiments will normally operate to archive and unarchive variables for multiple applications and multiple documents of such applications.","As shown in , an initial state of the persister is an application running state . The persister enters this state after an application has been initiated. The persister stays at the application running state so long as (1) no application terminating event is received and (2) an archiver timer has not expired.","Upon the expiration of the timer, the persister transitions to the archiving state . In the archiving state , the persister of some embodiments retrieves and archives the persisted variables of the application. In some embodiments, the persister retrieves and archives the persisted variables using the process described above by reference to . When all the persisted variables of the application are archived, the persister returns to the application running state  and resets the archiver timer.","When the persister receives an application terminating event while the persister is in the application running state (e.g., the user quitting the application, the user closing a document associated with the application, etc.), the persister transitions to the archiving state . Similar to the archiving state , the persister in the archiving state  retrieves and archives the persisted variables of the application. In some embodiments, the persister retrieves and archives the persisted variables using the process described above by reference to . When all the persisted variables of the application are archived and the application completely terminated, the persister transitions from the archiving state  to the application terminated state .","The persister stays at the application terminated state  so long as no application initializing event is received. When the persister receives an application initializing event (e.g., the user initiating an application, the user closing a document associating with the application, etc.), the persister may transition to one of two states. If the persister is configured to automatically unarchive the persisted variables when the application restarts, the persister transitions to the unarchiving state . In the unarchiving state , the persister retrieves the archived variables from the disk and updates the instantiated objects of the application. In some embodiments, the persister retrieves the archived variables and updates the objects using the process described above by reference to . After the persister restores the persisted variables of the application, the persister transitions to the application running state .","If the persister is configured not to automatically unarchive the persisted variables, the persister transitions directly to the application running state . At the application running state , the persister transitions to the unarchiving state  only when instructed to unarchive (unloading and restoring) the persisted variables by the application. After unarchiving, the persister returns back to the application running state .","When the persister is at the application running state , the application may abnormally terminate (e.g., the application crashing or suddenly terminating due to other circumstances such as the operating system performing a fast shutdown of the device that runs the application). When the application abnormally terminates, the persister transitions to the application terminated state . Even though the persister does not archive the persisted variables when the application abnormally terminates, the application is still able to restore the values of the persisted variables that were last archived during the last periodically archiving.","II. Software Architecture","In some embodiments, the processes described above are implemented as software running on a particular machine or device, or stored in a machine readable medium. In some embodiments, the machine or device on which the processes are implemented may be a desktop computer, laptop computer, a tablet, a smartphone, etc.  conceptually illustrates the software architecture of an operating system  of some embodiments that includes a persister. In some embodiments, the persister is part of the framework (e.g., within the core services layer) of an operating system for providing the core functions to the application.","As shown, the operating system  includes a set of application APIs , a framework , and input\/output drivers . The operating system  interacts with the applications through the set of application APIs . The operating system  also accesses the system memory  and the disk storage  through the input\/output (I\/O) drivers . As shown in the figure, the framework  of the operating system  includes a persister .","In some embodiments, the persister performs an archiving operation for an application that is running on top of the operating system using the process described above by reference to , , and . In some embodiments, the persister automatically performs the archiving operation when the application terminates. In some embodiments, the persister also performs the archiving operation periodically when the application is running. To perform the archiving operation for an application, the persister communicates with the application and retrieves the latest values of the persisted variables of the application from the system memory . The persister then stores the persisted variables in the disk storage  through the I\/O drivers . When the application restarts, the persister of some embodiments performs an unarchiving operation for the application using the process described above by reference to . The persister retrieves the persisted variables from the disk storage  through the I\/O drivers  and applies the retrieved persisted variables to the objects that the application has instantiated in the system memory .",{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 14","b":["1405","1415","1410","1405","1415","1405","1405","1435","1415","1405","1405","1405"]},{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 15","b":["1500","1500","1505","1510","1515","1520","1525","1530","1535","1500","1505","1540","1505","1510","1510","1505","1510","1515"]},"In some embodiments, the persister  archives all of the persisted variables of the application to a single file. In these embodiments, the serializer  combines the received persisted variables into one stream of data and saves the stream of data in the system memory . In some embodiments, the system memory  is the same system memory that stores the application. The writer  retrieves the stream of data from the system memory  and writes the stream of data to a single file in the data storage . In some embodiments, the writer  converts the stream of data into a different format before writing the stream of data to the disk storage . In other embodiments, the writer  writes the stream of data to the data storage  in the same format that the writer  retrieves from the system memory .","In other embodiments, the persister archives the persisted variables to different files based on the type of the persisted variables. For instance, the persister may archive variables that represent settings of the application (e.g., the appearance of the application's GUI) to the application settings file, and archive variables that represent user generated data (e.g., documents, spreadsheet, other data files, etc.) and application state data related to the user generated data (e.g., location of the cursor for an instance of the user generated data) to the user data files. In these embodiments, the serializer  creates different streams of data for the different types of variables and saves the streams of data in the system memory . The writer  retrieves the multiple streams of data from the system memory  and writes them to the respective application setting file and user data files of the application.","When the user restarts the application, the application launcher  loads the application from the disk storage  to the system memory  and instantiates all the variables with default values. The initiation of the application also triggers the persister  to perform the unarchiving operation for the application. When the persister begins the unarchiving operation for the application, the file retriever  retrieves the streams of data from the files containing the persisted variables of the application in the disk storage . The file retriever  passes the streams of data to the de-serializer . Upon receiving the streams of data, the de-serializer coverts the streams of data to the set of persisted variables of the application and stores the set of persisted variables in the system memory . In some embodiments, the system memory  is the same system memory that stores the loaded application. The object reconstructor  uses the set of persisted variables in the system memory  to update the instantiated objects of the application (i.e., overwriting some of the objects with the retrieved persisted variables).","III. Electronic System","Many of the above-described features and applications are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium (also referred to as computer readable medium). When these instructions are executed by one or more computational or processing unit(s) (e.g., one or more processors, cores of processors, or other processing units), they cause the processing unit(s) to perform the actions indicated in the instructions. Examples of computer readable media include, but are not limited to, CD-ROMs, flash drives, random access memory (RAM) chips, hard drives, erasable programmable read only memories (EPROMs), electrically erasable programmable read-only memories (EEPROMs), etc. The computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.","In this specification, the term \u201csoftware\u201d is meant to include firmware residing in read-only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also, in some embodiments, multiple software inventions can be implemented as sub-parts of a larger program while remaining distinct software inventions. In some embodiments, multiple software inventions can also be implemented as separate programs. Finally, any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments, the software programs, when installed to operate on one or more electronic systems, define one or more specific machine implementations that execute and perform the operations of the software programs.",{"@attributes":{"id":"p-0141","num":"0140"},"figref":"FIG. 16","b":["1600","1600","1600","1605","1610","1615","1620","1625","1630","1635","1640","1645"]},"The bus  collectively represents all system, peripheral, and chipset buses that communicatively connect the numerous internal devices of the electronic system . For instance, the bus  communicatively connects the processing unit(s)  with the read-only memory , the GPU , the system memory , and the permanent storage device .","From these various memory units, the processing unit(s)  retrieves instructions to execute and data to process in order to execute the processes of the invention. The processing unit(s) may be a single processor or a multi-core processor in different embodiments. Some instructions are passed to and executed by the GPU . The GPU  can offload various computations or complement the image processing provided by the processing unit(s) . In some embodiments, such functionality can be provided using CoreImage's kernel shading language.","The read-only-memory (ROM)  stores static data and instructions that are needed by the processing unit(s)  and other modules of the electronic system. The permanent storage device , on the other hand, is a read-and-write memory device. This device is a non-volatile memory unit that stores instructions and data even when the electronic system  is off. Some embodiments of the invention use a mass-storage device (such as a magnetic or optical disk and its corresponding disk drive) as the permanent storage device .","Other embodiments use a removable storage device (such as a floppy disk, flash memory device, etc., and its corresponding disk drive) as the permanent storage device. Like the permanent storage device , the system memory  is a read-and-write memory device. However, unlike storage device , the system memory  is a volatile read-and-write memory, such a random access memory. The system memory  stores some of the instructions and data that the processor needs at runtime. In some embodiments, the invention's processes are stored in the system memory , the permanent storage device , and\/or the read-only memory . For example, the various memory units include instructions for processing multimedia clips in accordance with some embodiments. From these various memory units, the processing unit(s)  retrieves instructions to execute and data to process in order to execute the processes of some embodiments.","The bus  also connects to the input and output devices  and . The input devices  enable the user to communicate information and select commands to the electronic system. The input devices  include alphanumeric keyboards and pointing devices (also called \u201ccursor control devices\u201d), cameras (e.g., webcams), microphones or similar devices for receiving voice commands, etc. The output devices  display images generated by the electronic system or otherwise output data. The output devices  include printers and display devices, such as cathode ray tubes (CRT) or liquid crystal displays (LCD), as well as speakers or similar audio output devices. Some embodiments include devices such as a touchscreen that function as both input and output devices.","Finally, as shown in , bus  also couples electronic system  to a network  through a network adapter (not shown). In this manner, the computer can be a part of a network of computers (such as a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), or an Intranet, or a network of networks, such as the Internet. Any or all components of electronic system  may be used in conjunction with the invention.","Some embodiments include electronic components, such as microprocessors, storage and memory that store computer program instructions in a machine-readable or computer-readable medium (alternatively referred to as computer-readable storage media, machine-readable media, or machine-readable storage media). Some examples of such computer-readable media include RAM, ROM, read-only compact discs (CD-ROM), recordable compact discs (CD-R), rewritable compact discs (CD-RW), read-only digital versatile discs (e.g., DVD-ROM, dual-layer DVD-ROM), a variety of recordable\/rewritable DVDs (e.g., DVD-RAM, DVD-RW, DVD+RW, etc.), flash memory (e.g., SD cards, mini-SD cards, micro-SD cards, etc.), magnetic and\/or solid state hard drives, read-only and recordable Blu-Ray\u00ae discs, ultra density optical discs, any other optical or magnetic media, and floppy disks. The computer-readable media may store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations. Examples of computer programs or computer code include machine code, such as is produced by a compiler, and files including higher-level code that are executed by a computer, an electronic component, or a microprocessor using an interpreter.","While the above discussion primarily refers to microprocessor or multi-core processors that execute software, some embodiments are performed by one or more integrated circuits, such as application specific integrated circuits (ASICs) or field programmable gate arrays (FPGAs). In some embodiments, such integrated circuits execute instructions that are stored on the circuit itself. In addition, some embodiments execute software stored in programmable logic devices (PLDs), ROM, or RAM devices.","As used in this specification and any claims of this application, the terms \u201ccomputer\u201d, \u201cserver\u201d, \u201cprocessor\u201d, and \u201cmemory\u201d all refer to electronic or other technological devices. These terms exclude people or groups of people. For the purposes of the specification, the terms display or displaying means displaying on an electronic device. As used in this specification and any claims of this application, the terms \u201ccomputer readable medium,\u201d \u201ccomputer readable media,\u201d and \u201cmachine readable medium\u201d are entirely restricted to tangible, physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals, wired download signals, and any other ephemeral signals.","While the invention has been described with reference to numerous specific details, one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. In addition, a number of the figures (including , , , and ) conceptually illustrate processes. The specific operations of these processes may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations, and different specific operations may be performed in different embodiments. Furthermore, the process could be implemented using several sub-processes, or as part of a larger macro process. Thus, one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details, but rather is to be defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features of the invention are set forth in the appended claims. However, for purposes of explanation, several embodiments of the invention are set forth in the following figures.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
