---
title: Using and generating finite state machines to monitor system status
abstract: Provided are a method, system, and program for monitoring a system including a plurality of subcomponents. An implementation of a plurality of subcomponent finite state machines for subcomponents of the system is provided, wherein each subcomponent finite state machine indicates output values for combinations of input state values related to states in the subcomponent. An implementation of a system finite state machine having output values for combinations of the output values from the subcomponent finite state machines is provided. For each subcomponent finite state machine, a determination is made of the output value by determining the input state values of the subcomponent, processing the subcomponent finite state machine with the determined input state values to determine the subcomponent output value, and processing the system finite state machine with the determined subcomponent output values to determine the system output value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06968291&OS=06968291&RS=06968291
owner: Sun Microsystems, Inc.
number: 06968291
owner_city: Santa Clara
owner_country: US
publication_date: 20031104
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention relates to using and generating finite state machines to monitor system status.","2. Description of the Related Art","A storage area network (SAN) comprises a network linking one or more servers to one or more storage systems. Each storage system could comprise a Redundant Array of Independent Disks (RAID) array, tape backup, tape library, CD-ROM library, or JBOD (Just a Bunch of Disks) components. A managed SAN must ensure both data integrity and data availability, which requires monitoring the health of the storage components in the SAN. The health of the SAN comprises the collective health of the storage devices interconnected in the SAN. Each storage device is comprised of multiple components, such as independent field replaceable units (FRUs), including a power supply, disk drive, loop card, etc., where each of these FRUs have a state and status. The health of each storage device is thus a function of the health of the FRUs and subcomponents therein.","An administrator for a storage device or SAN including monitored subcomponents, e.g., FRUs, may be alerted of problems with a particular storage device in the SAN or FRUs within the storage device. The monitored storage device may include code to notify an administrator upon detecting an error state. Further, an administrator person or program may poll the storage devices to run diagnostic tests to ascertain the health of the storage device.","To determine status, the system may perform synchronous polling where FRUs within the device are polled at intervals to see if an attribute has changed and the value of such changed attribute. Asynchronous polling of the FRUs is performed by polling upon the FRU generating an alert on a state change or problem.","Notwithstanding current techniques for monitoring devices, there is a need in the art for improved techniques for monitoring networks, devices, and FRU components of devices.","Provided are a method, system, and program for monitoring a system including a plurality of subcomponents. An implementation of a plurality of subcomponent finite state machines for subcomponents of the system is provided, wherein each subcomponent finite state machine indicates output values for combinations of input state values related to states in the subcomponent. An implementation of a system finite state machine having output values for combinations of the output values from the subcomponent finite state machines is provided. For each subcomponent finite state machine, a determination is made of the output value by determining the input state values of the subcomponent, processing the subcomponent finite state machine with the determined input state values to determine the subcomponent output value, and processing the system finite state machine with the determined subcomponent output values to determine the system output value.","Further provided are a method, system, and program for implementing an administrative policy for a device having at least one component. An implementation of an administrative policy finite state machine indicating at least one action to perform for combinations of input administrative and operational states of the component in the device is provided. A determination is made of the input administrative and operational states for the component and the administrative policy state machine is processed with the determined input administrative and operational states to determine at least one action to perform.","Still further provided are a method and program for generating implementations of a plurality of subcomponent finite state machine for subcomponents of a system, wherein each subcomponent finite state machine indicates output values for combinations of input state values related to states in the subcomponent and generating an implementation of a system finite state machine having output values for combinations of the subcomponent output values from the subcomponent finite state machines. Each subcomponent finite state machine is processed with determined input state values for the subcomponent state machine to determine the subcomponent output value and the system finite state machine is processed with the determined subcomponent output values to determine the system output value.","In the following description, reference is made to the accompanying drawings which form a part hereof and which illustrate several embodiments of the present invention. It is understood that other embodiments may be utilized and structural and operational changes may be made without departing from the scope of the present invention.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 1","FIG. 1"],"b":["2","4","4","4","4","6","6","6","8","8","10","10","10","6","6","6","8","8","10","10","10","6","6","6","8","8","8","8"],"i":["a","b","c","a","a","b","c","a","b","a","b","c","a","b","c","a","b","a","b","c ","a","b","c ","a","b ","a","b "]},"The hosts , , may comprise any computing device known in the art, such as a server class machine, workstation, storage host, host cluster, etc., having adaptor cards with ports to connect to one switch port in switches , . The switches , may each include multiple switch ports to interconnect different devices in a fabric, wherein the devices may be connected in a network, such as a SAN, Local Area Network (LAN), Wide Area Network (WAN), etc. The storages , , may comprise any storage system known in the art which has compatible ports, such as a storage array, e.g., a storage subsystem, a subsystem cluster, Just a Bunch of Disks (JBOD), Redundant Array of Independent Disks (RAID), Direct Access Storage Device (DASD), etc., tape drive, tape library, disk drive, optical disk drive, etc. The ports within the hosts , , and storages , , may comprise NxPorts, or any other ports known in the art. The network  may further include direct attached storage (DAS) devices that connect directly to another host or device other than a switch and orphan devices not connected to any other component.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2","b":["20","22","22","22","24","26","22","22","22","2","26","24","26","20"],"i":["a","b","c","a","b","c "]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["22","22","22","22","30","26","22","28","30","26","22","22","22","26","28","26"],"i":["a","b","c","a","b","c "]},"There may be any number of FRUs and systems nested in one another so that the health of the subcomponents, which themselves may include FRUs\/subcomponents, at one level, is calculated to determine a health value for the subcomponent, which may be passed to the next system\/higher level subcomponent that includes the subcomponent whose health value was calculated. For instance, a SAN system comprises storage device subcomponents, where the health value of the SAN as a whole is based on the health value of the various subcomponents of the SAN, such as storage systems, switches, etc. Each of these system components themselves include FRUs and have a health value derived from the aggregate health values of the FRUs within that system component of the network.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4","b":["30","32","34","36","38","40","42","30","44","30","32","30","42","34","32","34","36","36","34","36","34"]},"In described implementations, the developer of the health monitor program  would have to empirically determine how different health related parameters could affect the health of the sub-components of the system, where the system health comprises an aggregation of the health of the subcomponents. For instance, the health of the storage system  may be determined by a weighted aggregation of the health of the FRUs , , , , , and . The developer would create a truth table that considers different states and effects of a subcomponent\/FRU on the system health and then for each possible combination of FRU health values, determine the system health value for that combination of subcomponent\/FRU health values. In certain implementations, there may be two or more possible health values, such as good, bad, degraded and\/or different levels of degraded.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 5","FIG. 4","FIG. 5","FIG. 4"],"b":["38","38","38","34","32"],"sub":["\u2014","\u2014","\u2014","\u2014"]},"After developing a truth table, the developer may then create a K-map, which is used to derive a finite state machine to provide two or more health values based on different input parameter and state values of the subcomponent being measured. The K-map would allow identification of the transitions between health parameter and state values that produce specific health states, e.g., 0, 1 or D. From this K-map, the developer can determine finite state machine equations to model the health values for each combination of measured parameters and states.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIGS. 6 and 7","FIGS. 6 and 7","FIG. 7"],"b":["50","50","50","50","52","52","60","60","60","60","62","62"],"i":["a","b","c","d ","a ","b ","a","b","c","d ","a ","b "]},"For instance, based on the K-map of , the health of a good power supply, e.g., output state of \u201c1\u201d is represented below in equation (1):\n\nTempStatus*BatteryStatus*FanStatus.\u2003\u2003(1)\n\nAccording to equation (1), the health is good if the three mentioned statuses, TempStatus, BatteryStatus, and FanStatus are all \u201c1\u201d values, i.e., good health. The health of a bad power supply, e.g., output state of \u201c0\u201d, is represented below in equation (2):\n\n[TempStatus]*[BatteryStatus*FanStatus]\u2003\u2003(2)\n\nAccording to equation (2), the health is bad if the TempStatus value is bad (\u201c0\u201d and either BatteryStatus has a bad (\u201c0\u201d) value or FanStatus has a bad value. Including two statuses in brackets indicates that just either of the two states need be bad. Further, a degraded health value, e.g., output state of \u201cD\u201d, is represented below in equation (3):\n\n(TempStatus*[BatteryStatus*FanStatus])+([TempStatus]* BatteryStatus*FanStatus).\u2003\u2003(3)\n\nAccording to equation (3), the health is a degraded state if the temperature status is good (1) and the battery or fan statuses are bad (0). In this way, the three finite state machine equations (1), (2), and (3) model a fine state machine indicating different possible output health values for the power supply based on the four input statuses and parameters.\n","For each of the subcomponents, i.e., FRUs, of the system , e.g., , , , , , , and , similar truth tables may be used to generate K-Maps, which in turn are used to generate the finite state machine equations to model the health output values for the different subcomponents. A system truth table may use as inputs the final health output value for each of the FRUs to determine an health output value for the system as a whole, based on an aggregation of the health output values of the component FRUs.","Further, although one or more possible degraded output states are possible, certain sub-components may have only two possible states, such as good (1) and bad (0) and other subcomponents may have three or more possible health values, good, bad and one or more degraded levels. The equations to determine the health of the subcomponents and overall system are coded into the health monitor program . Still further, numerous different assignments of degradation weights to the health related parameters may be used based on empirical testing and knowledge.","In further implementations, the developer may observe and assign multiple degraded states indicating different levels of degradation.  illustrates a K-map where multiple degradation weights are assigned, such as a 20%, 30% and 50% degraded. For instance, a fan status of bad (0) has a lower impact on degradation, e.g., 20%, than the battery status, which produces a degradation of 30% or 50%. Further, the power supply state has no effect on the health, and can thus be disregarded in the finite state machine equations. The developer may make these determinations of degraded levels based on observations and measurements when generating the truth tables and determining health output values based on the inputs of temperature status, battery status, fan status, and power supply state. Further, based on the truth table having multiple levels of degraded, such as shown in , the developer would create equations for good health, bad health and each different grade or level of degradation.","For instance, based on the K-map of , the health of a good power supply, e.g., output state of \u201c1\u201d is shown below in equation (5):\n\nTempStatus*BatteryStatus*FanStatus.\u2003\u2003(5)\n\nAccording to equation (5), the health is good if the three mentioned statuses, TempStatus, BatteryStatus, and FanStatus are all \u201c1\u201d values, i.e., good health. The health of a bad power supply, e.g., output state of \u201c0\u201d, is shown below in equation (6):\n\n[TempStatus]*[BatteryStatus*FanStatus]\u2003\u2003(6)\n\nAccording to equation (6), the health is bad if the TempStatus value is bad (\u201c0\u201d and either BatteryStatus has a bad (\u201c0\u201d) value or the FanStatus has a bad value. Further, the health of a 20% degraded power supply, e.g., output state of \u201c20% D\u201d, is expressed below in equation (7):\n\nTempStatus*BatteryStatus*[FanStatus]\u2003\u2003(7)\n\nAccording to equation (7), the health is 20% degraded if the temperature and battery status are good (1) and the fan status is bad (0). The health of a 30% degraded power supply, e.g., output state of \u201c30% D\u201d, is expressed below in equation (8):\n\nTempStatus*[BatteryStatus]*FanStatus\u2003\u2003(8)\n\nAccording to equation (8), the health is 30% degraded if the temperature and fan status are good (1) and the battery status is bad (0). The health of a 50% degraded power supply, e.g. output state of \u201c50% D\u201d, is expressed below in equation (9):\n\n([TempStatus]*BatteryStatus*FanStatus)+(TempStatus*[BatteryStatus]*[FanStatus])\u2003\u2003(9)\n\nAccording to equation (9), the health is in a 50% degraded state if the temperature status is good (1) and the battery and fan statuses are bad (0) or if the temp status is good (1) and the battery and fan statuses are bad (0). In this way, the equations 5\u20139 9 model a finite state machine indicating one of five different possible output health values for the power supply based on the four input status.  illustrates a schematic of a finite state machine implementing the equations (5)\u2013(9) discussed above.\n","The above examples show how equations coding a state machine may be ascertained for the subcomponents or FRUs of a system. The developer would also create a truth table including a column for each FRU for which health is measured to provide system health output values for each different possible combination of FRU health output values. The truth table would require more health output states if additional degraded health states are possible for the final FRU health values. From this truth table, the developer would then create K-maps and then equations coding system health output values based on the inputs of the health output values of the subcomponents. Still further, the subcomponents themselves may include FRUs whose health is independently determined based on the health related parameters and values for such FRUs. In this way, the value of a subcomponent would comprise the aggregation of the health values of the FRUs within the subcomponents.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 9","FIG. 4"],"b":["44","30","44","100","102","112","32","34","36","38","040","42","44","44","104","106","108","44","110","44","144","44"]},"In the operations of , the health monitor program maintains equations for each FRU to determine the FRU health values. In alternative implementations, certain of the FRUs may include their own health monitor program including finite state machine equations, where those FRUs would run their own health monitor program to independently determine their own health. In such implementations, the system health monitor program  would use an API to query the FRU for its health output value, which the system health monitor program  would then use as input to the system finite state machine determine the overall system health value.","The described implementations may also be used to implement a policy for a system component based on various state values of that component.  illustrates a switch  including a CPU  and an administrative policy program  that initiates policy actions based on the state of switch ports , . . . . The administrative policy program  maintains administrative information , which includes information for each port on the current and previous administrative and operational states. The administrative state indicates whether the administrator set the port to be offline (0) or online (1) and the operational state indicates whether the port is in fact offline (0) or online (1). The administrative information  may be updated whenever an administrator takes action affecting the administrative state or the operational state is determined.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 11","FIG. 11"],"b":["158","156","156","156","158"],"i":["a","b ","n "]},"The developer may generate equations to express the finite state machine based on the truth table, which may involve generating a K-Map to assist in determining the equations. Equation (10) below expresses the equation for when an event would be generated for the truth table in :\n\nIf (Previous Admin State!=Current Admin State OR Previous Oper State!=Current Oper State) then Generate Event\u2003\u2003(10)\n\nWith equation (10) an event is generated, which may call another routine to perform a set of actions, if the previous administrative or operational state are not equal to the current administrative or operational state, respectively.\n","Equation (11) below expresses the equation for when an alert is to be created:\n\nPrevious Oper State*[Current Oper State]*Current Admin State\u2003\u2003(11)\n\nAccording to equation (11), an alert is created if the previous operational state and current administrative state are online and the current operational state is offline, where a bracketed state name indicates an \u201coffline\u201d value. In this way, if the operating state of the port changes from online to offline and the current administrative state of the port is online, then an alert is initiated to alert the administrator that the port has gone offline after the administrator set the port online.\n","Equation (12) below expresses the equation for when an alert is cleared:\n\n[Previous Oper State]*Current Oper State*Current Admin State\u2003\u2003(12)\n\nAccording to equation (12), an alert is cleared if the current operational state and current administrative state are online and the previous operational state is offline. In this way, if the operating state of the port changes from offline to online and the current administrative state of the port is online, than an alert is cleared because the administrator requested state has occurred.\n","The developer may then code the above finite state machine equations into the administrator policy program . The same set of finite state machine equations may be used for all ports, or there may be port specific sets of equations.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 12","b":["154","156","156","156","150","200","156","156","156","154","202","158","203","204","204","154","206","158","208","210","212","214","216","154","218"],"i":["a","b ","n ","a","b ","n"]},"In additional implementations, a truth table may be generated for an entire network, e.g., 2 (), which uses as input the health of the components of the network, e.g., 2, such as the storages , , and switches , . Each component of the network may execute their own health monitoring program to generate an output health value based on input comprising the health values of the subcomponents (e.g., FRUs,) within the network component, e.g., switch, storage system, etc. The health values of the network components would then be inputted to the network finite state machine equations to produce an output health value for the network based on the aggregate health values of the network components.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 13","FIG. 4","FIG. 9"],"b":["300","44","154","300","302","304","306","308","310","312","306","306","308","314","312","314","310","316","316"]},"The described techniques for generating and executing a finite state machine for a system may be implemented as a method, apparatus or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof. The term \u201carticle of manufacture\u201d as used herein refers to code or logic implemented in hardware logic (e.g., an integrated circuit chip, Programmable Gate Array (PGA), Application Specific Integrated Circuit (ASIC), etc.) or a computer readable medium, such as magnetic storage medium (e.g., hard disk drives, floppy disks, tape, etc.), optical storage (CD-ROMs, optical disks, etc.), volatile and non-volatile memory devices (e.g., EEPROMs, ROMs, PROMs, RAMs, DRAMs, SRAMs, firmware, programmable logic, etc.). Code in the computer readable medium is accessed and executed by a processor complex. The code in which embodiments are implemented may further be accessible through a transmission media or from a file server over a network. In such cases, the article of manufacture in which the code is implemented may comprise a transmission media, such as a network transmission line, wireless transmission media, signals propagating through space, radio waves, infrared signals, etc. Thus, the \u201carticle of manufacture\u201d may comprise the medium in which the code is embodied. Additionally, the \u201carticle of manufacture\u201d may comprise a combination of hardware and software components in which the code is embodied, processed, and executed. Of course, those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention, and that the article of manufacture may comprise any information bearing medium known in the art.","The above discussed FRUs comprised hardware components in the system. Additionally, the FRUs may comprise application programs.","The logic of  describe specific operations occurring in a particular order. In alternative implementations, certain of the logic operations may be performed in a different order, modified or removed. Morever, steps may be added to the above described logic and still conform to the described implementations. Further, operations described herein may occur sequentially or certain operations may be processed in parallel. Yet further, the described operations may be performed by a single processing unit or by distributed processing units.","The foregoing description of various implementations of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto. The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Referring now to the drawings in which like reference numbers represent corresponding parts throughout:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 6 and 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 8","FIG. 6"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
