---
title: Communication in multiprocessor using proxy sockets
abstract: Systems and methods for implementing communication in a multiprocessor are disclosed. In one exemplary implementation a first processor receives a request to provide a communication resource for an application executing on the first processor to communicate with a remote application. In response to the communication request, the first processor opens a communication resource on a second processor, and manages communication operations between the application executing on the first processor and the remote application using the communication resource on the second processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08650302&OS=08650302&RS=08650302
owner: Hewlett-Packard Development Company, L.P.
number: 08650302
owner_city: Houston
owner_country: US
publication_date: 20110914
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a divisional of co-pending U.S. patent application Ser. No. 10\/856,263, filed May 27, 2004, the entire contents of which are hereby incorporated by reference as though fully set forth herein.","The described subject matter relates to electronic computing, and more particularly to systems and methods for implementing proxy sockets to facilitate communication in a multiprocessor computing system.","In multiprocessor computing systems, each processor is capable of managing its own network connectivity operations. In such a configuration, each physical network interface is bound only to the local communication stack in the multi-processor system. A communication stack that is not bound to a particular network interface does not have direct access to the data link layer supplied by that interface.","Thus, an application-level service may find that not all network interfaces in a multiprocessor environment are available for establishing a communication endpoint because the local network stack cannot bind to all of the interfaces in the multi-processor system. In other words, not all of the network interfaces are available to all application layer services present in a multi-processor system.","One way to address this issue is to pair application-level services with specific local network interfaces, i.e., to dedicate local network interfaces to specific applications or task. However, dedicating services only to specific local network interfaces impairs the scalability of the system. Accordingly, additional solutions are desirable.","Systems and methods described herein address these issues by enabling multiprocessor communication using proxy sockets. In one exemplary implementation a first processor receives a request to provide a communication resource for an application executing on the first processor to communicate with a remote application. In response to the communication request, the first processor opens a communication resource on a second processor, and implements communication operations between the application executing on the first processor and the remote application using the communication resource on the second processor.","Described herein are exemplary architectures and techniques for implementing proxy sockets in a multi-processor computing system. The methods described herein may be embodied as logic instructions on a computer-readable medium, firmware, or as dedicated circuitry. When executed on a processor, the logic instructions (or firmware) cause a processor to be programmed as a special-purpose machine that implements the described methods. The processor, when configured by the logic instructions (or firmware) to execute the methods recited herein, constitutes structure for performing the described methods.","Exemplary Storage Architecture",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","100","130","130","120","110","120","130","130","110","120","110","120"],"i":["a","f","a","f "]},"In an exemplary implementation data storage system  may implement RAID (Redundant Array of Independent Disks) data storage techniques. RAID storage systems are disk array systems in which part of the physical storage capacity is used to store redundant data. RAID systems are typically characterized as one of six architectures, enumerated under the acronym RAID. A RAID 0 architecture is a disk array system that is configured without any redundancy. Since this architecture is really not a redundant architecture, RAID 0 is often omitted from a discussion of RAID systems.","A RAID 1 architecture involves storage disks configured according to mirror redundancy. Original data is stored on one set of disks and a duplicate copy of the data is kept on separate disks. The RAID 2 through RAID 5 architectures involve parity-type redundant storage. Of particular interest, a RAID 5 system distributes data and parity information across a plurality of the disks -. Typically, the disks are divided into equally sized address areas referred to as \u201cblocks\u201d. A set of blocks from each disk that have the same unit address ranges are referred to as \u201cstripes\u201d. In RAID 5, each stripe has N blocks of data and one parity block which contains redundant information for the data in the N blocks.","In RAID 5, the parity block is cycled across different disks from stripe-to-stripe. For example, in a RAID 5 system having five disks, the parity block for the first stripe might be on the fifth disk; the parity block for the second stripe might be on the fourth disk; the parity block for the third stripe might be on the third disk; and so on. The parity block for succeeding stripes typically rotates around the disk drives in a helical pattern (although other patterns are possible). RAID 2 through RAID 4 architectures differ from RAID 5 in how they compute and place the parity block on the disks. The particular RAID class implemented is not important.","In a RAID implementation, the storage management system  optionally may be implemented as a RAID management software module that runs on a processing unit of the data storage device, or on the processor unit of a computer. The disk array controller module  coordinates data transfer to and from the multiple storage disks -. In an exemplary implementation, the disk array module  has two identical controllers or controller boards: a first disk array controller and a second disk array controller . Parallel controllers enhance reliability by providing continuous backup and redundancy in the event that one controller becomes inoperable. Parallel controllers and have respective mirrored memories and . The mirrored memories and may be implemented as battery-backed, non-volatile RAMs (e.g., NVRAMs). Although only dual controllers and are shown and discussed generally herein, aspects of this invention can be extended to other multi-controller configurations where more than two controllers are employed.","The mirrored memories and store several types of information. The mirrored memories and maintain duplicate copies of a coherent memory map of the storage space in multiple storage disks -. This memory map tracks where data and redundancy information are stored on the disks, and where available free space is located. The view of the mirrored memories is consistent across the hot-plug interface, appearing the same to external processes seeking to read or write data.","The mirrored memories and also maintain a read cache that holds data being read from the multiple storage disks -. Every read request is shared between the controllers. The mirrored memories and further maintain two duplicate copies of a write cache. Each write cache temporarily stores data before it is written out to the multiple storage disks -","The controller's mirrored memories and are physically coupled via a hot-plug interface . Generally, the controllers and monitor data transfers between them to ensure that data is accurately transferred and that transaction ordering is preserved (e.g., read\/write ordering).",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2","b":["210","210","240","240","244","242","242","240","240","210","210","240","240","242","242","210","210","244","240","240"],"i":["a ","b","a ","b","a ","b","a ","b ","a ","b ","a ","b ","a ","b ","a","b","a","b. "]},"Each controller , has a converter , connected to receive signals from the host via respective I\/O modules , . Each converter and converts the signals from one bus format (e.g., Fibre Channel) to another bus format (e.g., peripheral component interconnect (PCI)). A first PCI bus , carries the signals to an array controller memory transaction manager , , which handles all mirrored memory transaction traffic to and from the NVRAM , in the mirrored controller. The array controller memory transaction manager maintains the memory map, computes parity, and facilitates cross-communication with the other controller. The array controller memory transaction manager , is preferably implemented as an integrated circuit (IC), such as an application-specific integrated circuit (ASIC).","The array controller memory transaction manager , is coupled to the NVRAM , via a high-speed bus , and to other processing and memory components via a second PCI bus , . Controllers , may include several types of memory connected to the PCI bus and . The memory includes a dynamic RAM (DRAM) , , flash memory , , and cache , ","The array controller memory transaction managers and are coupled to one another via a communication interface . The communication interface  supports bi-directional parallel communication between the two array controller memory transaction managers and at a data transfer rate commensurate with the NVRAM buses and ","The array controller memory transaction managers and employ a high-level packet protocol to exchange transactions in packets over hot-plug interface . The array controller memory transaction managers and perform error correction on the packets to ensure that the data is correctly transferred between the controllers.","The array controller memory transaction managers and provide a memory image that is coherent across the hot plug interface . The managers and also provide an ordering mechanism to support an ordered interface that ensures proper sequencing of memory transactions.","In an exemplary implementation each controller , includes multiple central processing units (CPUs) , , , , also referred to as processors. The processors on each controller may be assigned specific functionality to manage. For example, a first set of processing units , may manage storage operations for the plurality of disks -, while a second set of processing units , may manage networking operations with host computers or other devices that request storage services from data storage system .","Separating networking operations from storage operations and assigning the networking operations to a separate processor can improve the performance of a storage controller. Computationally-expensive networking operations can be off-loaded to a co-processor, thereby permitting the main processor to dedicate its processor cycles to storage operations.","In such a multi-processor architecture, each processor side may implement its own software protocol stack for communication purposes.  is a schematic illustration of a multiprocessor communication configuration. In one exemplary implementation the multiprocessor configuration depicted in  may be implemented in storage controller such as, e.g., the storage controller depicted in . The multiprocessor configuration comprises a first processor, i.e., the main processor  and a second processor, i.e., the co-processor . The main processor  manages data I\/O operations to and from the plurality of disks -, while the co-processor  manages network operations.","Main processor  comprises a services module  that provides one or more services to a management network by invoking one or more applications in application module . Application module  invokes a communication module  to pass service protocol data units (PDUs) down the protocol stack. Communication module  includes a sockets I\/O demultiplexer module , a socket I\/O API module , a local communication protocol stack , a proxy\/socket mirror module , and a shared memory driver module . The various modules in communication module  may be implemented as software objects that facilitate transmitting and receiving service PDUs with other objects in an attached management network. Operation of these modules will be explained in greater detail below.","Co-processor  also comprises a services module  that provides one or more services via a storage attached network by invoking one or more applications in application module . Application module  invokes a communication module  to pass service PDUs down the protocol stack. Communication module  includes a sockets I\/O API , a primary\/socket master module , a shared memory driver module , and a local network protocol module . The various modules in communication module may be implemented as software objects that facilitate transmitting and receiving service PDUs with other object in an attached network. Operation of these modules will be explained in greater detail below.","In an exemplary implementation, main processor  communicates with co-processor  logically at the sockets I\/O demultiplexer  and the sockets I\/O API  level using conventional sockets-based communications techniques that rely on underlying remote procedure call (RPC) between proxy\/socket mirror  and primary\/socket master . This communication depends on the lower-level communication layer between shared memory drivers , , which is implemented by shared memory function calls (SMFC). Sockets I\/O demultiplexer  implements operations that permit the main processor to send and receive communication with external devices using a proxy socket it manages (the co-processor plays part in this managed or proxy socket by offering server-side RPCs for socket APIs called by main processor).","Connection  illustrates a logical link between the sockets I\/O demultiplexer  and the sockets I\/O API on co-processor  where main processor  connects to  via the proxy module. Connection  illustrates a logical link between the proxy\/socket mirror module  and the primary\/socket master module  where  connects to this link as client side RPC and  connects to this link as server side RPC. Connection  illustrates a logical link between shared memory drivers  and  where this link implements the IPC (Inter-Processor Communication) using SMFCs through . The data path from  through  and  which is the proxy\/socket mirror path leads to managed sockets through the use of proxy module in . The data path from  through  and  which is the conventional socket I\/O API path leads to unmanaged sockets through the use of master module in .","Operation of an exemplary sockets I\/O demultiplexer  will be described with reference to the flowcharts of , , and the data tables of .","Exemplary Operations",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIGS. 4A-4B","FIG. 4","FIG. 4","FIG. 6"],"b":["318","310","314","410","318","610","314","318"],"i":["a ","a "]},"Referring briefly to  the SdOSockets table  is a data structure that can include as many entries as are required by applications. Each entry in the SdOSockets table  includes a pointer to a separate instance of a data structure referred to herein as a SockFdEx data structure , . Referring to SockFdEx data structures , the SockFdEx data structure includes a SOps pointer , , a proxy flag data field , and a SockFd field , . The SOps pointer points to one of two data structures: the ProxySocketOps data structure  or the PriSocketOps data structure . The proxy flag data field holds a data flag that indicates whether the socket represented by the particular instance of the SockFdEx data structure is a proxy socket. The SockFd field holds the socket handle as returned by the underlying Socket I\/O API , .","The ProxySocketOps data structure  includes entry points into application programming interfaces (APIs) for performing various socket operations. By way of example, the ecs_proxy_socket entry  provides an entry into an API that creates a proxy socket, the ecs_proxy_bind entry  provides an entry into an API that binds a proxy socket, the ecs_proxy_listen entry  provides an entry into an API that transforms a proxy socket into a listening socket. One skilled in the art will recognize the remaining socket operations in the ProxySocketOps table.","Similarly, the PriSocketOps table data structure  includes entry points into application programming interfaces (APIs) for performing various socket operations. By way of example, the ecs_socket entry  provides an entry into an API that creates a primary socket, the ecs_bind entry  provides an entry into an API that binds a primary socket, the ecs_listen entry  provides an entry into an API that transforms a primary socket into a listening socket. One skilled in the art will recognize the remaining socket operations in the PriSocketOps table.","Referring again to , at operation  the sockets I\/O demultiplexer  initializes and activates the master module and the proxy module. The term master module refers to the library of functions that enable communication using the communication stack on the main processor . The term proxy module refers to the library of services that permit communication with applications on the main processor  via the communication stack on the co-processor . In an exemplary implementation, the proxy module is implemented as client-server software (or firmware) that communicates via shared memory inter-process communication (IPC) calls. The client-side software resides in the main processor  and the server-side software resides in the co-processor .","At operation  the sockets I\/O demultiplexer  determines whether the request includes a proxy flag that is set. In an exemplary implementation the proxy flag is implemented in a protocol parameter, specifically, a shared memory function call (SMFC) flag is passed to the demultiplexer with the socket request.","If the proxy flag is not set, then control passes to operation , and the sockets I\/O demultiplexer  determines whether it can accept socket I\/O to the socket I\/O API  in the main processor . If it can accept socket I\/O to the socket I\/O API  then control passes to operation , and the sockets I\/O demultiplexer  determines whether the socket I\/O API  is active (or initialized properly and ready). If the socket I\/O API  is active, then control passes to operation  and the sockets I\/O demultiplexer  selects the master module. By contrast, if the socket I\/O API  is inactive, then control passes to operation  and an error code is returned to the calling routine.","Referring back to operation , if the sockets I\/O demultiplexer  cannot accept socket I\/O to the socket I\/O API  in the main processor , then control passes to operation , and the sockets I\/O demultiplexer  determines whether it can accept sockets I\/O communication to the proxy module. If so, then control passes to operation , and if the socket I\/O API  is active, then the proxy module is selected for communication at operation . By contrast, if either of the tests implemented at operations  or  fail, then control passes to operation , and an error code is returned to the calling routine.","Referring back to operation , if the SMFC flag is set, then control passes to operation  and the sockets I\/O demultiplexer  determines whether it can accept socket I\/O to the socket I\/O API  in the co-processor . If it can accept socket I\/O to the socket I\/O API  then control passes to operation , and the sockets I\/O demultiplexer  determines whether the socket I\/O API  is active. If the socket I\/O API  is active, then control passes to operation  and the sockets I\/O demultiplexer  selects the proxy module. By contrast, if the socket I\/O API  is inactive, then control passes to operation  and an error code is returned to the calling routine.","Referring back to operation , if the sockets I\/O demultiplexer  cannot accept socket I\/O to the socket I\/O API  in the co-processor , then control passes to operation , and the sockets I\/O demultiplexer  determines whether it can accept sockets I\/O communication to the master module. If so, then control passes to operation , and if the socket I\/O API  is active, then the master module is selected for communication at operation . By contrast, if either of the tests implemented at operations  or  fail, then control passes to operation , and an error code is returned to the calling routine.","After the sockets I\/O demultiplexer  has selected either the proxy module or the master module for communication, control passes to operation  () and the sockets I\/O demultiplexer  allocates a new SockFdEx data structure and points to it from the SdOSockets table . If at operation  the master module is selected, then control passes to operation  and the sockets I\/O demultiplexer  attaches a PriSocketOps structure  to the newly-created SockFdEx structure, e.g., by setting a pointer SOps in the SockFdEx structure to point to the PriSocketOps table. Referring to , this is illustrated by the SockFdEx structure , in which the pointer SOpsis set to point to the PriSocketOps table . In addition, the proxy field in the SockFdEx table is set to a value that indicates \u201cfalse\u201d (operation ).","By contrast, if at operation  the master module is not selected then control passes to operation  and the sockets I\/O demultiplexer  attaches a ProxySocketOps structure to  to the newly-created SockFdEx structure, e.g., by setting a pointer SOps in the SockFdEx structure to point to the ProxySocketOps table. Referring to , this is illustrated by the SockFdEx structure , in which the pointer SOpsis set to point to the ProxySocketOps table . In addition, the proxy field in the SockFdEx table is set to a value that indicates \u201ctrue\u201d (operation ).","Control then passes to optional operation , in which the SMFC flag is cleared from \u201cprotocol\u201d actual argument prior to reusing it in reissuing call to socket( ) API. At operation  the sockets I\/O demultiplexer  sends a socket create request to the selected communication module, i.e., either the proxy module or the master module. If an error is returned (operation ) then at operation  an error code is returned to the calling module. By contrast, if an error code is not returned at operation , then a socket descriptor is returned at operation .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 5","FIG. 5","FIG. 5"],"b":["318","318"]},"At operation  the sockets I\/O demultiplexer  sends a socket I\/O request to a selected module, i.e., the proxy module or the master module. In an exemplary implementation operation  may be performed by selecting a socket operation that corresponds to the network I\/O request in the SocketOps structure that corresponds to the selected module. By way of example, if the network I\/O request involves a bind operation and the master module is the selected module, then the sockets I\/O demultiplexer  would select the ecs_bind operation  in the PriSocketOps table . Similarly, if the network I\/O request involves a bind operation and the proxy module is the selected module, then the sockets I\/O demultiplexer  would select the ecs_proxy_bind operation  in the ProxySocketOps table . Hence, the data tables of  provide a mechanism for the sockets I\/O demultiplexer  to map network I\/O requests to socket operations for either the master module or the proxy module. One skilled in the art will recognize that the sockets I\/O demultiplexer  can match the network I\/O request to a corresponding socket operation in either the ProxySocketOps table  or the PriSocketOps table .","At optional operation  the sockets I\/O demultiplexer  determines whether the call is still pending. If the call is still pending, then the sockets I\/O demultiplexer  implements a loop that waits for the call to return. Once the call returns, control may pass to operation , where the sockets I\/O demultiplexer  sets a return variable to the value returned by the call to the selected module, i.e., either the proxy module or the master module.","If, at operation , the network I\/O call was a request to close a socket, then control passes first to operation , where the sockets I\/O demultiplexer  releases the SockFdEx data structure assigned to the socket, then to operation , where the sockets I\/O demultiplexer  clears the socket descriptor slot from the SdOSockets table .","Control then passes to operation , and the sockets I\/O demultiplexer  passes the return value to the module that invoked the socket I\/O API function call.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIGS. 7-10","FIG. 7","FIG. 7","FIG. 3"],"b":["310","320","322"]},"At operation  the application layer  generates a socket( ) call and passes the socket( ) call to the sockets I\/O demultiplexer . The sockets I\/O demultiplexer  receives the socket( ) call and passes the call to the selected communication module. In this circumstance the master module is the selected communication resource, so at operation  the sockets I\/O demultiplexer  passes the socket( ) request to the socket I\/O layer API , which returns a handle to the newly-instanced primary socket object (operation ).","At operation  the application layer  generates a bind( ) request and passes the bind( ) request to the sockets I\/O demultiplexer , which in turn passes the bind( ) request to the socket I\/O layer API  (operation ). At operation  the socket I\/O layer API  binds the newly-instanced socket handle to a communication resource.","At operation  the application layer  generates a listen( ) call to convert the newly-instanced socket handle into a listening socket, and passes the listen( ) call to the sockets I\/O demultiplexer , which in turn passes the listen( ) call to the socket I\/O layer API . The socket I\/O layer API  converts the newly-instanced socket handle into a listening socket and sends a reply to the application layer  (operation ). At operation  the application layer  generates an accept( ) call and passes the accept( ) call to the sockets I\/O demultiplexer , which passes the accept( ) call to the socket I\/O layer API . The socket I\/O layer API  configures the newly-instanced socket handle to accept an incoming connection request from a remote application. In an exemplary implementation, the accept( ) call may be implemented as a blocking call, such that the process or thread waits for an incoming (or inbound) connection requests call from a remote application.","At operation  the socket I\/O layer API  receives a connect request from a remote application. At operation  the socket I\/O layer API  unblocks the accept wait, and at operation  the socket I\/O layer API  forwards a newly-instanced socket handle to the socket I\/O demultiplexer , which in turn forwards the newly-instanced socket handle to the application layer  (operation ).","At operation  the remote application communicates with the application layer  using the newly-instanced socket handle. When the communication session is finished, the application layer  generates a close( ) call (operation ) to close the socket created in step  and the socket I\/O demultiplexer passes the close( ) to the sockets I\/O demultiplexer  (operation ), which in turn passes the close( ) call to the socket I\/O API . At operation  the socket I\/O API  closes the socket instanced in step  for send and receive operations and returns a response to the application layer .",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIGS. 8A-8B","FIG. 8","FIG. 3"],"b":["310","310","350"]},"At operation  an application  generates a socket( ) call and passes the socket( ) call to the sockets I\/O demultiplexer . In an exemplary implementation the socket( ) call specifies that the socket call is to a proxy socket, e.g., by including a SMFC flag in a \u201cprotocol\u201d formal parameter passed with the socket( ) call as described above. The sockets I\/O demultiplexer  receives the socket( ) call and, at operation , passes the socket( ) request to the co-processor .","In an exemplary implementation the sockets I\/O demultiplexer  passes various socket calls to the co-processor  via a shared memory function call (SMFC). Accordingly, the socket( ) call is passed to the proxy\/socket mirror module , which passes the socket( ) call to a shared memory driver . The shared memory driver  maintains a communication path to shared memory driver  in the co-processor via shared memory module . The shared memory driver  retrieves the call from the shared memory module  and passes it up its communication stack to the primary\/socket master module  and to the socket I\/O layer  for processing. Communication from the co-processor to the main processor follows the reverse path.","At operation  the socket I\/O layer API  generates a newly instanced socket and at operation  the socket I\/O layer API  returns a handle to the newly-instanced socket for send and receive operations to the socket I\/O demultiplexer  in the main processor. At operation  the socket I\/O demultiplexer  passes the handle to the application . At operation  the application  generates a bind( ) call and passes the bind( ) call to the socket I\/O demultiplexer . At operation  the socket I\/O demultiplexer  passes the bind( ) call to the co-processor . At operation  the socket I\/O layer API  in co-processor  binds the newly-instanced socket handle to a communication resource in the co-processor and returns an acknowledgment to the socket I\/O demultiplexer , which passes the acknowledgment back to the application .","At operation  the application  generates a listen( ) call, which is passed to the socket I\/O demultiplexer . At operation  the socket I\/O demultiplexer  passes the listen( ) call to the co-processor . At operation  the socket I\/O layer API  executes the listen( ) call and returns an acknowledgment to the socket I\/O demultiplexer , which passes the acknowledgment back to the application .","At operation  the application generates an accept( ) call, which is passed to the socket I\/O demultiplexer . At operation  the accept( ) call is passed to the co-processor . At operation  the socket I\/O API  executes the accept( ) call, which places the proxy socket implemented at the co-processor into a state that can accept a connect-request from a remote application. In an exemplary implementation an accept( ) call may be implemented as a blocking call. At operation  the newly-instanced socket receives a connect request from a remote application. At operation  the socket I\/O API  returns the newly instanced socket handle to the application  in main processor .","At operation  the application  in main processor communicates with the remote application that invoked the connect( ) call over the communication path via the proxy (or managed) socket that has equivalent of real socket instantiated in co-processor . When the communication session is finished the application  passes a close( ) call to the socket I\/O demultiplexer  operation . At operation  the socket I\/O demultiplexer passes the close( ) call to the co-processor . At operation  the socket I\/O API  executes the socket close call to close the real socket instance implemented in co-processor  at operation , and passes an acknowledgment back to the application , which terminates socket operations over the proxy socket at operation .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIGS. 9A-9B","FIG. 9","FIG. 3"],"b":["310","310","350"]},"Operations - involve opening and binding a proxy socket, and may be implemented as described in operations -. For brevity and clarity, these operations will not be repeated in detail.","At operation  the application  generates a connect( ) call and passes the connect( ) call to the socket I\/O demultiplexer . At operation  the socket I\/O demultiplexer  passes the connect request to the co-processor . At operation  the socket I\/O API  executes the connect( ) call and sends an acknowledgment back to the socket I\/O demultiplexer .","At operation  the applications communicate using the newly instanced socket. When the communication session is finished the application  generates a close( ) call and passes the close( ) call to the socket I\/O demultiplexer . At operation  the socket I\/O demultiplexer  passes the close( ) call to the co-processor. At operation  the socket I\/O API  executes the close( ) call to close the real socket instanced in operation  in the co-processor  and returns an acknowledgment back to the application , which terminates socket operations over the proxy socket at operation .","In another implementation an application  on main processor  may communicate with an application  on co-processor . This may be implemented using the operations illustrated in  with minor changes. In operation  the application sends a bind( ) request to bind the communication resource to a local address on the co-processor (i.e., a loopback address). When the bind( ) call in operation  is executed, it enables a communication path between the application  on the main processor and an application  on the co-processor. The application  on the co-processor  creates and binds a socket to a loopback address to enable the communications path. In an exemplary implementation the loopback network interface is assigned IP address of 127.0.0.1 in TCP\/IP network stack's network layer. Remaining communication operations can be implemented as described in .","The system architecture and techniques described herein enable multiprocessor communication using proxy sockets. Applications on a first processor can communicate with remote applications using communication resources from a second processor. The remote application can be external to both processors, or can execute on the second processor such that communication takes place using a private loopback address for extra security instead of using existing public address assigned real socket instanced in second processor.","Although the described arrangements and procedures have been described in language specific to structural features and\/or methodological operations, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or operations described. Rather, the specific features and operations are disclosed as preferred forms of implementing the claimed present subject matter."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 4A-4B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 8A-8B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 9A-9B"}]},"DETDESC":[{},{}]}
