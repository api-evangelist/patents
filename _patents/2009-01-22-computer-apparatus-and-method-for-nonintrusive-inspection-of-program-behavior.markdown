---
title: Computer apparatus and method for non-intrusive inspection of program behavior
abstract: A computer-implemented method for malicious code detection. An emulator is initialized, and import dynamic link libraries are processed. Instructions of a target program are emulated using the emulator. Select application programming interface calls are intercepted using an intercept list during the program emulation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08407787&OS=08407787&RS=08407787
owner: Trend Micro Incorporated
number: 08407787
owner_city: Tokyo
owner_country: JP
publication_date: 20090122
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["1. Field of Art","The present invention generally relates to the field of malicious code detection.","2. Description of the Related Art","Conventional anti-virus software protection is typically reactionary. It is reactionary in that the anti-virus software is updated to protect a computer from malware only after the malware is released. Unfortunately, this means that at least some computers will be infected before anti-virus software is updated. Furthermore, the anti-virus update cycle is a costly process.","It is highly desirable to improve protection against malware which may be provided by antivirus software. In addition, it is highly desirable to improve the performance efficiency of, and decrease the intrusion which may be caused by, antivirus software.","One embodiment relates to a computer apparatus configured with malicious code detection. Data storage is configured to store computer-readable instructions and data, and a processor is configured to execute computer-readable instructions and to access said data storage. Computer-readable code is configured to initialize an emulator and process import dynamic link libraries. Computer-readable code is also configured to emulate instructions of a target program using the emulator. Furthermore, computer-readable code is configured to intercept select application programming interface calls using an intercept list during the program emulation.","Another embodiment relates to a computer-implemented method for malicious code detection. An emulator is initialized, and import dynamic link libraries are processed. Instructions of a target program are emulated using the emulator. Select application programming interface calls are intercepted using an intercept list during the program emulation.","Other embodiments, aspects and features are also disclosed.","Applicants have determined that prior technologies to monitor program behavior have certain flaws and disadvantages. For example, one prior technology involves hooking system APIs (i.e. redirection to stub DLLs) on the actual running system (the real system). However, hooking system APIs may cause interoperability issues. Worse yet, when monitoring a malicious process, the system may already be detrimentally affected prior to the system API hooking. For example, a file infection may have already gone through and occurred.","The present application discloses a method and apparatus for monitoring program execution behavior without hooking system APIs on the real system. Advantageously, this technique secures the monitoring task and avoids substantial impact to the real system.","In accordance with an embodiment of the invention, a virtual system is constructed for the program emulation, inspection and behavior monitoring. However, unlike VMWare\u00ae software or other virtualization tools, the virtual system is constructed without modifications to real system resources, such as the file system, registries, and the internal kernel objects. Furthermore, no additional guest OS (operating system) installation is required.","Computer Apparatus",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":"100"},"As shown in , the computer apparatus  comprises a processor , a computer-readable memory system , a storage interface , a network interface , and other interfaces . These system components are interconnected through the use of an interconnection network (such as a system bus or other interconnection system) . The memory  may be configured to include, in addition to other components and data, processor-executable instructions to perform various method steps disclosed herein.","The storage interface  may be used to connect storage devices  to the computer apparatus . The network interface  may be used to communicate with other computers  by way of an external network . The other interfaces may interface to various devices, for example, a display , a keyboard , and other devices.","Non-Intrusive Inspection of Program Behavior","Conventional solutions for monitoring program behavior include either using a complex virtualized solution or directly hooking application programming interfaces (APIs) from the real system. The largest effort for these solutions typically involves the implementation of the system dynamic link libraries (DLLs) in the virtual solution or taking the risk to modify the entry of the API in the direct hooking solution. In either case, the aim is to gather API information.","The present application discloses an alternative technique for program behavior inspection that advantageously reduces the required effort to implement a solution. The disclosed technique provides for a capability to inspect program behavior without requiring API hooking and without needing to implement DLL wrappers.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2","b":["204","204","206","208","210","208","212","214","202","204"]},"In accordance with an embodiment of the invention, the virtual machine  may communicate with the system DLLs  and the process virtual memory . Such communication may occur by way of an input\/output (I\/O) interface . In addition, a program behavior analyzer  may receive behavior-related data from the intercept module  of the virtual machine .",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3","b":"300"},"In accordance with one embodiment, an executable file  of interest is loaded by the main routine  of the program behavior inspector. The main routine  then initializes  the emulator. The emulator initialization  is described in further detail below in relation to .","If the initialization  fails, then the procedure ends . Otherwise, if the emulator initialization  succeeds, then the procedure goes on to process import DLLs . The processing of import DLLs  is described in further detail below in relation to .","If the processing of import DLLs  fails, then the procedure ends . Otherwise, if the processing of import DLLs  succeeds, then the procedure goes on to emulate instructions . The instruction emulation  is described in further detail below in relation to .","The instruction emulation  continues until a terminate condition  is met. If a terminate condition  is met, then the procedure ends . Until then, API calls are intercepted  and a determination  is made as to whether each of the intercepted API calls has a match in a list or data structure of API calls of interest. If a match is found, then the intercepted API call information is logged . Otherwise, the information is not logged and the procedure continues to monitor the instruction emulation .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 4","b":["400","410","420","430"]},"The first phase (emulator initialization)  includes placing the input executable file into memory . This may be accomplished using the LoadLibrary API to load the input file into virtual memory, processing the process environment (PE) header to gather the PE information, and assigning an entry pointer to the EIP of the emulator. Also, the method allocates virtual memory to be the emulator's stack (depending on the stack reserve size), and assigns virtual memory to be the emulator's ESP register. Subsequently, when the emulator starts to emulate the program, the emulator will fetch instructions from the location pointed to by the EIP, and the emulator will use the emulator's stack to store values to be operated upon and parameters for API calls.","In accordance with an exemplary embodiment, after the emulator has been initialized and the input file loaded into memory, a process environment block (PEB)  and a thread information block (TIB)  are created by the system loader and prepared for program emulation purposes. PEB and TIB are memory blocks allocated by the system loader, and each of them contains information which may be advantageously modified to better control the program execution inside the emulator. This improves the accuracy of the program emulation so that it is like the program is running in the real system. Various data in the PEB and\/or TIB is advantageously reformatted. For example, a malware may check whether or not it is being executed in a debugger. The malware may do so, for instance, by checking the debugger flag inside the PEB, or getting the command line string from the PEB, or manipulating the structured exception handling (SEH) to change the program execution flow by modifying the SEH frame from the TIB. Other virtualization solutions do not provide such functionality and so may lead to emulation failure or incorrect execution.","In further accordance with an exemplary embodiment, an intercept list (or intercept data structure)  is also prepared for program emulation purposes. The intercept list is a predefined data structure that includes the API names which are desired to be intercepted and the number of parameters each API has. The intercept list may be hard-coded inside the code for the program behavior inspection, or it may be placed outside the code in a data file. The intercept list is advantageously used so that APIs may be intercepted without hooking and without overwriting the API behavior.","After the emulator initialization is completed, the second phase (processing of import DLLs)  is performed. Exemplary steps for the second phase  are discussed in relation to .","In accordance with an embodiment of the invention, the second phase  includes loading import DLLs into process memory . The import DLLs are the DLLs named in the import table (see DLL name ). The loading of an import DLL into process memory may be performed by using a LoadLibrary call (see LoadLibrary ). If loading the import DLL is not successful, then a failure indication may be returned (Return Fail ). Otherwise, if loading the import DLL is successful, then the procedure fixes-up (modifies) the imported API addresses .","Fixing-up an imported API address may be accomplished, for example, by way getting the API name from the import table  and then using the GetProcAddress function  to get the API offset from the corresponding import DLL. If getting the API offset fails, then a failure indication may be returned (Return Fail ). Otherwise, if getting the API offset succeeds, then the procedure writes the API offset for that entry to the specified field .","As shown in , the procedure  continues in a first loop through the API names in the import table () and getting () and writing () the API offsets until the end of the API name list for that DLL is reached . In addition, the procedure also continues in a second loop through the DLL names in the import table () until the end of the DLLs to be loaded is reached . When the last DLL is so processed, a success indication may be returned .","In accordance with an embodiment of the invention, the third phase  involves emulation of file execution  and utilizes an intercept mechanism .","The virtual machine  starts to emulate instructions of the executable file () one by one from the entry by fetching the op codes. In an exemplary embodiment, the virtual machine has implemented an x86 instruction set for emulating functions. The emulated functions may be defined as function pointers, based on the op codes. The function pointer array may use the op code as an index to dispatch what emulated function needs to execute. The emulation may continue until program termination or occurrence of an exception.","An exemplary embodiment of the procedure  used by the intercept mechanism is depicted in . During the emulation of instructions, API calls are led by op code 0xFF 0x15 (Call Far) or 0xFF 0x25 (Jump Far), and in some special cases using 0xC3 (Ret). Within those instruction functions, a function is inserted to determine if the calling API address () matches one of the records within a predefined intercept list ().","The predefined intercept list includes API names and how many parameters each API has (counts of parameters). Preferably, the APIs on the intercept list are those that are known to be frequently used by malicious programs. Hence, by monitoring these APIs, the procedure may identify harmful actions performed by malicious programs.","If there is no match between the API address and the intercept list, then the procedure continues to emulate the next instruction (). The emulation and the matching of API addresses with the intercept list continues until program termination or occurrence of an exception.","On the other hand, if there is a match between the API address and the intercept list, then the procedure obtains the API name and the number of parameters for that API from the match record (). The parameters are then fetched from the stack base ().","In accordance with an embodiment of the invention, a determination may then be made as to whether or not to overwrite the API (). If the API is not to be overwritten, then the virtual machine executes the original API and then continues on to emulate the next instruction (). If the API is to be overwritten, the virtual machine executes a previously defined overwrite function (), instead of the original API. The defined function is configured to obtain extra information and\/or redirect input\/output. Information gathered by the defined function may be used by an intelligent quarantine engine to detect programs that behave maliciously. Various techniques may be used by the intelligent quarantine engine.","The above-described solution is technologically advantageous over one which uses VMWare\u00ae software. This is because VMWare\u00ae software requires installation of a guest operating system (OS), such as Windows\u00ae or Linux\u00ae operating systems. The VMWare\u00ae software then may act like a real machine to execute the installed guest OS. In contrast, the presently-disclosed solution does not require installation of a guest OS.","The above-described solution is also technologically advantageous over solutions which utilize \u201cstub DLLs\u201d (system DLL wrappers). In such solutions, when the program being emulated calls to the interface of the stub DLLs (instead of the real DLLs), the stub DLLs gather the API information. In contrast, the presently-disclosed solution does not need to implement stub DLLs because the real DLLs from the live system are used instead.","These technological advantages lead to better performance in program emulation. This is because the presently-disclosed solution does not use a virtual machine management (VMM) layer. The conventional VMM layer manages interactions between guest and host, and these interactions usually cause performance-reducing context switching to occur.","In addition, the presently-disclosed solution provides more full emulation of the user's environment. This enables the detection of certain malicious codes that can only exploit certain versions of the environment. Other solutions providing less full emulation of the user's environment may fail to detect these malicious codes.","In other words, the presently-disclosed solution implements an x86-based emulator and directly runs in the real OS environment. This is distinct from other virtualization solutions which involve either installing a guest OS or implementing system DLL wrappers to gather API information. This means that the program emulation of the presently-disclosed solution has the capabilities to perform actions in a real computing environment when calling certain APIs, such as creating a file or even receiving files from the Internet. These capabilities enable detection of malicious behaviors which may elude detection by conventional solutions.","The method disclosed herein emulates the behavior of a real operating system in an advantageous manner so as to enable non-intrusive inspection of program behavior. This provides better security protection to detect malicious software variants using a technique other than signature matching. Inspection is performed during secure program execution before the program is actually executed on the user's system. The secure program execution is advantageously implemented to leave no leftover files and no inserted run keys without a user's awareness.","The features and advantages described in the specification provide a beneficial use to those making use of a system and a method as described in embodiments herein. For example, a user is provided mechanisms, e.g., by receiving and\/or transmitting control signals, to control access to particular information as described herein.","Numerous specific details have been set forth herein to provide a thorough understanding of the embodiments. It will be understood by those skilled in the art, however, that the embodiments may be practiced without these specific details. In other instances, well-known operations, components and circuits have not been described in detail so as not to obscure the embodiments. It can be appreciated that the specific structural and functional details disclosed herein may be representative and do not necessarily limit the scope of the embodiments.","Various embodiments may be implemented using one or more hardware elements. In general, a hardware element may refer to any hardware structures arranged to perform certain operations. In one embodiment, for example, the hardware elements may include any analog or digital electrical or electronic elements fabricated on a substrate. The fabrication may be performed using silicon-based integrated circuit (IC) techniques, such as complementary metal oxide semiconductor (CMOS), bipolar, and bipolar CMOS (BiCMOS) techniques, for example. Examples of hardware elements may include processors, microprocessors, circuits, circuit elements (e.g., transistors, resistors, capacitors, inductors, and so forth), integrated circuits, application specific integrated circuits (ASIC), programmable logic devices (PLD), digital signal processors (DSP), field programmable gate array (FPGA), logic gates, registers, semiconductor device, chips, microchips, chip sets, and so forth. The embodiments are not limited in this context.","Various embodiments may be implemented using one or more software elements. In general, a software element may refer to any software structures arranged to perform certain operations. In one embodiment, for example, the software elements may include program instructions and\/or data adapted for execution by a hardware element, such as a processor. Program instructions may include an organized list of commands comprising words, values or symbols arranged in a predetermined syntax, that when executed, may cause a processor to perform a corresponding set of operations.","The software may be written or coded using a programming language. Examples of programming languages may include C, C++, BASIC, Perl, Matlab, Pascal, Visual BASIC, JAVA, ActiveX, assembly language, machine code, and so forth. The software may be stored using any type of computer-readable media or machine-readable media. Furthermore, the software may be stored on the media as source code or object code. The software may also be stored on the media as compressed and\/or encrypted data. Examples of software may include any software components, programs, applications, computer programs, application programs, system programs, machine programs, operating system software, middleware, firmware, software modules, routines, subroutines, functions, methods, procedures, software interfaces, application program interfaces (API), instruction sets, computing code, computer code, code segments, computer code segments, words, values, symbols, or any combination thereof. The embodiments are not limited in this context.","Some embodiments may be implemented, for example, using any computer-readable media, machine-readable media, or article capable of storing software. The media or article may include any suitable type of memory unit, memory device, memory article, memory medium, storage device, storage article, storage medium and\/or storage unit, such as any of the examples described with reference to a memory. The media or article may comprise memory, removable or non-removable media, erasable or non-erasable media, writeable or re-writeable media, digital or analog media, hard disk, floppy disk, Compact Disk Read Only Memory (CD-ROM), Compact Disk Recordable (CD-R), Compact Disk Rewriteable (CD-RW), optical disk, magnetic media, magneto-optical media, removable memory cards or disks, various types of Digital Versatile Disk (DVD), subscriber identify module, tape, cassette, or the like. The instructions may include any suitable type of code, such as source code, object code, compiled code, interpreted code, executable code, static code, dynamic code, and the like. The instructions may be implemented using any suitable high-level, low-level, object-oriented, visual, compiled and\/or interpreted programming language, such as C, C++, Java, BASIC, Perl, Matlab, Pascal, Visual BASIC, JAVA, ActiveX, assembly language, machine code, and so forth. The embodiments are not limited in this context.","Upon reading this disclosure, those of skill in the art will appreciate still additional alternative structural and functional designs for a system and a process for a matching engine to query relevant documents, which may include a signature generation and relevance detection through the disclosed principles herein. Thus, while particular embodiments and applications have been illustrated and described, it is to be understood that the present invention is not limited to the precise construction and components disclosed herein and that various modifications, changes and variations which will be apparent to those skilled in the art may be made in the arrangement, operation and details of the method and apparatus of the present invention disclosed herein without departing from the spirit and scope of the invention as defined in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The disclosed embodiments have other advantages and features which will be more readily apparent from the following detailed description and the appended claims, when taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
