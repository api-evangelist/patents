---
title: Design and redesign of enterprise applications
abstract: An enterprise application may be constructed or reconstructed according to a system and method for designing or redesigning enterprise applications. The design or redesign process may include identification of the application type, in addition to representation of the application type as a decomposition of software components. The design or redesign may focus on reviewing code level component design and utilization. The code level design or redesign may include an analysis of each component within each use case within each tier based on patterns, frameworks, and/or refactoring. The application design or redesign may yield recommendations for code creation or code improvements. The recommendations may include specific application enhancements. The recommendations may include specific code design to be incorporated during construction or reconstruction. The recommendations may include results for guiding the design or redesign phase for an application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07076762&OS=07076762&RS=07076762
owner: Sun Microsystems, Inc.
number: 07076762
owner_city: Santa Clara
owner_country: US
publication_date: 20020329
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY INFORMATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION"],"p":["This application claims benefit of priority to U.S. provisional application Ser. No. 60\/366,841 entitled \u201cDesign and Redesign of Enterprise Application\u201d filed Mar. 22, 2002, whose inventor is Marina Fisher.","1. Field of the Invention","This invention relates to software, and more particularly to a system and method for designing or redesigning enterprise applications.","2. Description of the Related Art","Enterprise application development often focuses on service delivery. For example, anytime and anywhere access to needed services with predictable availability, reliability, usability, performance, and security may be major priorities during development. The application architecture may dictate how well these services, among others, can be provided. If the architecture is faulty, or not developed using preferred design techniques across multiple scenarios, a system may be difficult to scale, secure, or rapidly change.","Enterprise applications may also rely on real-time continuous processing for mission critical needs, and not on a traditional service model with scheduled downtime and scheduled batch processing. Achieving an effective and acceptable level of service involves integrating the development of these types of service-oriented capabilities into the architecture design process. In addition to these service goals, enterprise applications may operate in distributed, heterogeneous environments. Thus, processing in a complex system environment may be partitioned across network segments, CPU clusters, and storage locations. The complexity of system environments, and thus the complexity of enterprise applications, not only impacts service goals, but may also impose constraints on rapid development. For example, maintaining redundant code might become an issue since any changes may have to be propagated across various application modules. Also, having multiple objects execute similar functionality may impact application performance and scalability.","Various approaches, methodologies, tools, and practices are available to complement and\/or facilitate enterprise software architecture reviews. One model that focuses on architectural analysis is the SunTone Architecture Methodology (SunTone AM) developed by Sun Microsystems, Inc. Under the SunTone AM, design and development follows the creation of an architecture specification. The design and development is organized around functional scenarios at an architectural level, rather than components at a code level.","SunTone AM focuses on high-level architectural considerations more than code level component design and utilization. Components are typically small objects or programs that perform a specific function and are designed to easily operate with other applications or components. Development under the SunTone AM may be component-based, but focuses on reviewing components as utilized to solve problems associated with a specific business domain and how the overall architecture is affected. Thus, functional scenarios may be closely reviewed to ensure the architecture satisfies service goals.","Virtual platforms are available that provide capabilities for enterprise application development. One example virtual platform is J2EE (Java 2 Platform, Enterprise Edition) from Sun Microsystems, Inc. As a distributed computing model, the business presentation for an enterprise application in J2EE may be represented using servlets and\/or Java Server Pages (JSPs), and the business logic may run in the form of distributed components such as Enterprise JavaBeans (EJBs). A business interface may be implemented using the Java Messaging Service (JMS). Thus, J2EE provides a convenient platform for enterprise application development, but does not itself address application design practices.","A system and method for designing or redesigning enterprise application are described. The construction of the design or redesign may include identification of the application type, in addition to representation of the application type as a decomposition of software components. The enterprise application type may lead to the logical or physical representation of software components. Decomposition of the software components into a logical or physical representation may include tiers and layers. In one embodiment, the layers may include application and virtual layers consistent with the enterprise application technology used, or planned for use, during development.","In one embodiment, design or redesign may focus on reviewing code level component design and utilization at an application\/virtual layer. The code level design or redesign may include an analysis of each component within each use case within each tier. Enterprise application patterns may surface improvements during design or redesign. Patterns may help designers to verify if the components are utilized in an optimal way. During design or redesign, common components may be factored into common modules as a framework of reusable components. A framework may incorporate shared utility components or frequently used business logic to also help improve design. Using refactoring techniques may help improve the overall application design, performance, and maintainability.","The application design or redesign may yield recommendations for code creation or code improvements. The recommendations may include specific application enhancements based on design patterns, refactoring techniques, and\/or frameworks. The recommendations may include specific code design to be incorporated in an application. In one embodiment, the recommendations may include results for guiding the design or redesign phase of an application.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","A system and method for design or redesign of enterprise applications is described.  illustrates one embodiment of a high-level application design or redesign process for enterprise applications. The design or redesign process may be used during construction of an enterprise application or reconstruction of an existing enterprise application. The process starts with identifying the application type in . The enterprise application type may indicate how the enterprise application components are to be partitioned across multiple logical or physical representations of the application, which may also be referred to as tiers.","The enterprise application type may determine the partitioning of the enterprise components across multiple tiers, or some other logical or physical representation. For example,  illustrates an N-tier architecture. The N-tier application may include a thin Hyper Text Markup Language (HTML) based client tier, a servlet\/Java Server Pages (JSP) based presentation tier, an Enterprise Java Beans (EJB) and plain java objects based business tier, a Java Database Connectivity (JDBC)\/Java Naming and Database Interface (JNDI) based integration tier, and a database or another data source based resource tier. The client may communicate to the components of the presentation tier via Hyper Text Transfer Protocol (HTTP) or Secure Sockets Layer (SSL). Remote Method Invocation (RMI) may be used for communication between the presentation tier and the business tier. As another example of a tiered architecture,  illustrates an N-tier architecture with a rich client. Although the client typically relies on a server to perform some operation, the client may be referred to as rich, e.g., having some logic for operations as part of the client. An N-tiered model may include client logic where an applet communicates to presentation tier components such as servlets.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 3A","FIG. 3B"]},"Note the application type may determine the logical or physical representation of the components in relation to the various partitions or tiers. Thus, for application types, an integration tier may not exists separately and the resource tier may be considered thin because the data source is coupled with minimal logic. Alternatively, the integration tier may exists separately and the resource tier may be considered thick, for example, if the data source is actually an Enterprise Resource Planning (ERP) application in a distributed, heterogeneous environment. Depending on the application type, other organizations and representations of tiers are possible.","Turning again to , once the application type is identified, the application may be segmented into logical or physical representations such as tiers, or as deemed appropriate for the application type as in . In one embodiment, an application may be partitioned into tiers as described in the SunTone Architecture Methodology (SunTone AM) developed by Sun Microsystems, Inc. Depending on the application type, tiers may be the logical or physical organization of components into an ordered chain of service providers and consumers. Components within a tier typically consume the services of those in an adjacent provider tier and provide services to one or more adjacent consumer tiers. Within a tier, services are organized together according to like requirements, for example, functionality, security, or load distribution. Examples of tiers are client, presentation, business, integration, and resources. The client tier may include any device or system that manages display and local interaction processing. The presentation tier services may aggregate and personalize content and services into channel-specific user interfaces. Channel-specific interfaces may entail the assembly of content, formatting, conversions, and content transformations, or anything that has to do with the presentation of information to end users or external systems. The business tier may execute business logic and manage transactions. Examples range from low-level services such as authentication and mail transport to true line-of-business services such as order entry, customer profile, and inventory management. The integration tier services may abstract and provide access to external resources. Due to the varied and external nature of these resources, this tier may employ loosely coupled paradigms such as queuing and publish\/subscribe communications. The resource tier may include resources such as legacy systems, databases, external data feeds, and specialized hardware devices such as factory automation. These resources are information sources, sinks, or stores that may be internal or external to the system.","In one embodiment, the application may be segmented into logical or physical representations such as layers as in . Depending on the application type, layers may include the hardware and software stack that hosts services within a given tier. Layers may be the physical, network, and software platforms and standard Application Programming Interface (API) sets that support the components which provide a service. Layers, like tiers, may represent a well-ordered relationship across interface-mediated boundaries. While tiers may represent processing chains across components, layers may represent component relationships in implementation and deployment of services. Examples of layers are application, upper, virtual, lower, and hardware layers. The application layer may include Java\u2122 code based on components. The upper platform layer may include products such as Web servers, application servers, and various types of middleware. The virtual platform may include an application with standard APIs and specifications for the upper platform. The lower platform layer may include the operating system environment and associated low-level services. The hardware platform layer may include computing hardware such as servers, storage hardware like storage arrays, and networking hardware like switches and routers.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4"},"To further illustrate examples of partitioning the enterprise components across multiple representations,  depicts various embodiments for tiers, layers, and systemic qualities. For example, the upper platform may include any browser for the client tier, iPlanet Enterprise Server (iES) for the presentation tier, iPlanet Application Server (iAS) for the business tier, Message Queue Series (MQ Series) for the integration tier, or Customer Information Control System (CICS) for the resource tier. The hardware may be any hardware or a server like the E450 or ES9000 from Sun Microsystems, Inc. The tiers may include client, presentation, business, integration, and resource. A systemic quality for scaling, which may include parallelization, queuing, clustering, round robin, and horizontal scaling, may be applied. Other systemic qualities such as security, availability, performance, accessibility, and usability, may also be applied.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIGS. 2A through 5","FIG. 1"]},"Turning again to , once the application type is identified, and the application is segmented into logical tiers and layers, use case scenarios at the application\/virtual layer may be identified as in . In one embodiment, the design or redesign may focus heavily on the component relationships at the code level. Use cases are functional scenarios that describe the complete flow of an operation from the perspective of an actor. Actors may be referred to as entities which are external to the enterprise application. Examples of use cases are scenarios such as \u201cCustomer browses on-line catalog\u201d, or \u201cSales Representative enters order\u201d. Although various layers may be included in the logical or physical representation, use case scenarios may be identified only in the application\/virtual layers. The application\/virtual layers typically represent component relationships in implementation and deployment of services, and thus, relationships at the code level.","Once the application is segmented, and architecturally significant use case scenarios have been identified, a component-level code design or redesign of each tier associated with specific use cases is performed at the application\/virtual layers in . For one embodiment,  illustrates a high-level enterprise application component-level code design or redesign at the application\/virtual layers based on tiers. The design or redesign begins with an analysis of each component within each tier associated with a specific use case in . To further illustrate the design or redesign of each component,  illustrates specific design mechanisms that may be applied to each component. As part of , the component design or redesign begins with identifying application components within each tier in . While assessing individual application components, the application object model and the individual object design may be closely analyzed for coding issues in . During construction or reconstruction of code, the design or redesign process may surface issues with functionality incorrectly mapped to the object model or too much unrelated logic in the object design. As the implementation of the system functionality typically involves an interaction among multiple components, the design or redesign may include analysis of object interaction, the application APIs, and selected algorithms utilized by the various components. For example, the object design may satisfy requirements individually; however, once the object interacts with another object, the design may actually produce unexpected results. The cause for the unexpected results may be due to an object which inherited the wrong behavior, and thus inherited the wrong characteristics or features.","Enterprise application patterns may be applied during design or redesign in . Patterns convey a mechanism for solving common problems encountered in enterprise applications. Patterns may help designers to verify if the components are utilized in an optimal way. In one embodiment, the Gang of Four (GoF) design pattern catalog (-by Gamma, Helm, Johnson, and Vlissides, Addison-Wesley, 1995) may be utilized to assess the components for coding enhancements based on one or more patterns. For example, use of the Value Object, Data Access, and\/or Session Facade patterns may contribute towards a decoupled application, e.g., one application module is not tightly integrated with another module. A decoupled application may enable easier application maintenance because business logic changes in one application module may not lead to changes in another application module. J2EE specific patterns may also be used to assess pattern behavior for improvements. For example, tradeoffs inherent to the enterprise application design may lead to alternative design solutions.","In one embodiment, frameworks may be identified to help enhance the application design in . Frameworks may include implementation of the same functionality by multiple application components in different places. Generic frameworks, for example logging and error handling, may surface reusable logic in the application design. Since frameworks may be referenced by various application components, identifying and centralizing the frameworks may reduce the amount of implemented code and thus, code maintenance. Centralizing common functionality into a set of frameworks may allow application developers to concentrate on new features required by the application and to help simplify the development process. During design or redesign, common components may be factored into common modules as a framework of reusable components. A framework may incorporate shared utility components or frequently used business logic.","For example, organizing errors of an application into a framework helps different application components re-use error messages for the same type of exceptions.  illustrates a simple segmentation of errors into different categories. One way the errors may be subdivided is based on the error type. For instance, system related errors or database errors might be organized and handled differently from application errors resulting from the user input. Based on the type of errors, application modules may decide to record errors and in some cases send notification to the corresponding party. A new logging API, instead of various error handling routines in every module, may be incorporated into the design to allow developers to select a distribution channel. With the new logging API in , developers can select a distribution channel such as the Java console, a log file, or a database. Additionally, the logging libraries may provide a way to format logs into an XML document if necessary. Designing an effective error handling mechanism may help the overall application organization and may contribute towards code reusability.","In another example,  is a sequence diagram depicting the flow of events in the process of obtaining a database connection. A Data Access framework may be used to improve the overall design. The purpose of the Data Access framework may be to support application wide access to various data stores the application accesses or may potentially access in the future. A DataAccessFactory component is an abstract class and defines a generic API to obtain a corresponding factory such as a database, e.g., OraDataAccessFactory. The specific factory would then create a DataAccessObject called ProductDao. The DataAccessObject called ProductDao provides access to the desired data and facilitates application communication to the underlying persistent storage.","A concrete DataAccessObject, such as ProductDAO in , may be based on a generic interface that defines primary methods of the data access component. The Product class defines a value object for a product of a given type. The Product class encapsulates the data structure of the Product component used by the application as in . The class implementing the ProductDAO interface may provide access to the corresponding data source such as a concrete relational database and may be used by the main application.","Designing or redesigning the application to encompass data access functionality into a framework may improve application interoperability and manageability. The Data Access framework may provide a facade to the underlying data source, thus abstracting the implementation details from the application components. The actual implementation of the Data Access framework may be based on the Data Access Object pattern that outlines the mechanism to access the underlying data store. Depending on the component type and the underlying data source, several Data Access objects that access corresponding data sources such as a RDBMS or XML repository may be used.","In one embodiment, refactoring may be applied during the code design or redesign in . Although refactoring may involve code changes to improve the internal structure, the observable behavior of the software may not change. Using refactoring techniques may help improve the overall application design, performance, and maintainability. For example, one application design pattern may be a single object implementing various types of functionality. A class may be designed to perform business related data manipulation, obtain a connection to the underlying data source, query the database, process the result set, and prepare the response to the user. Individual business logic for each business aspect may be factored out into separate helper components. For instance, a user request of the product price may be initially designed as illustrated in . By refactoring some of the functionality to the helper components, the main class such as ProcessRequestServlet might only be responsible for control of the execution flow. To enhance communication among various objects, it may be useful to apply the Model-View-Controller (MVC) paradigm. The improved design may be represented as in . In the latter scenario, the servlet may perform a controller role while the session bean helper object, e.g., ProductPrice, and other objects facilitate execution of the business flow. By refactoring some of the functionality to execute the business flow, the overall application design, performance, and maintainability may be improved.","An application method may contain excessive amounts of logic as illustrated in . Leaving large conditional statements in the code may deteriorate application maintenance. Troubleshooting, extending, or changing existing functionality might become a difficult task. Refactoring out the content of the conditional statements into corresponding methods, or placing the excessive logic of the conditional statements into a subclass, may help improve design. Applying the Strategy (GoF) pattern to encapsulate behavior of the conditional statement into separate subclasses may reduce complexity and enhance application manageability. An alternative design of the process request is illustrated in . By factoring out the conditional logic associated with an invalid request, an invalid data input, and a system error, the design may improve because the method complexity is reduced.","Turning again to , after the components within a tier have been designed or redesigned based on the component-level process, individual systemic qualities within the tier may be assessed as in . For example, the tier may be assessed based on availability, security, performance, and\/or reliability factors. Note the list of systemic qualities is potentially infinite. In one embodiment, systemic qualities may be grouped and assessed by levels based on the category of quality. For example, availability and reliability may be considered in the design or redesign in the service level and interoperability and scalability may be considered in the design or redesign in the system level. Modifications may be made to the application design to help achieve various systemic qualities.","The application design or redesign may yield either a series of tactical and strategic recommendations for code creation or code enhancements in . The recommendations may include specific application enhancements based on design patterns, refactoring techniques, and frameworks. The recommendations may include specific code design to be incorporated. In one embodiment, the recommendations may include results for guiding the design or redesign phase. Tactical and strategic mechanisms for enhancing systemic qualities, or various categories of systemic qualities, may be depicted in an orthogonal view against the logical and physical representations. For example, the mechanisms may highlight the impact of a design or code change to a systemic quality within a layer or tier. An enterprise application may be designed or redesigned according to the recommendations.","After the components within a tier have been designed or redesigned based on the component-level process, individual systemic qualities within the tier have been assessed, and recommendations have been created, the design or redesign process may be repeated for any additional tiers as in .","To further illustrate an example of the design or redesign of an enterprise application,  illustrates a high-level view of the process according to one embodiment. The design or redesign begins with the identification of the application type in . The enterprise application type may determine the partitioning of the enterprise components across multiple tiers, or some other logical or physical representation. The application type may lead to other organizations and representations of tiers.","Once the application type is identified, the application may be segmented into logical or physical representations such as tiers as in . Depending on the application type, tiers may be the logical or physical organization of components into an ordered chain of service providers and consumers. Components within a tier typically consume the services of those in an adjacent provider tier and provide services to one or more adjacent consumer tiers. Examples of tiers are client, presentation, business, integration, and resources.","In one embodiment, the application may be segmented into logical or physical representations such as layers as in . Depending on the application type, layers may include the hardware and software stack that hosts services within a given tier. While tiers may represent processing chains across components, layers may represent component relationships in implementation and deployment of services. Examples of layers are application, upper, virtual, lower, and hardware layers.","Once the application type is identified, and the application is segmented into logical tiers and layers, architecturally significant use case scenarios at the application\/virtual layer may be identified as in . In one embodiment, the design or redesign may focus heavily on the component relationships at the code level. Use cases are functional scenarios that describe the flow of an operation from the perspective of an actor.","Once the application is segmented, and architecturally significant use case scenarios have been identified, the components within each tier associated with a use case may be selected as in . For one embodiment, a component-level code design or redesign of each tier associated with specific use cases is performed at the application\/virtual layers may be performed as in  to . Specific design mechanisms may be applied to each component. While assessing individual application components, the application object model and the individual object design may be closely analyzed for coding issues in . During construction or reconstruction of code, the design or redesign process may surface issues with functionality incorrectly mapped to the object model or too much unrelated logic in the object design. As the implementation of the system functionality typically involves an interaction among multiple components, the design or redesign may include analysis of object interaction, the application APIs, and selected algorithms utilized by the various components. For example, the object design may satisfy requirements individually; however, once the object interacts with another object, the design may actually produce unexpected results. The cause for the unexpected results may be due to an object which inherited the wrong behavior, and thus inherited the wrong characteristics or features.","Enterprise application patterns may surface improvements during design or redesign in . Patterns convey a mechanism for solving common problems encountered in enterprise applications. In one embodiment, J2EE specific patterns may be used to assess pattern behavior for improvements. For example, tradeoffs inherent to the enterprise application design may lead to alternative design solutions.","In one embodiment, frameworks may be identified to help enhance the application design in . Frameworks may include implementation of the same functionality by multiple application components in different places. Since frameworks may be referenced by various application components, identifying and centralizing the frameworks may reduce the amount of implemented code and thus, code maintenance. Centralizing common functionality into a set of frameworks might allow application developers to concentrate on new features required by the application and to help simplify the development process. During design or redesign, common components may be factored into common modules as a framework of reusable components. A framework may incorporate shared utility components or frequently used business logic.","In one embodiment, refactoring may be applied during the code design or redesign in . Although refactoring may involve code changes to improve the internal structure, the observable behavior of the software does not change. Using refactoring techniques may help improve the overall application design, performance, and maintainability. For example, one application design pattern may be a single object implementing various types of functionality. A class may be designed to perform business related data manipulation, obtain a connection to the underlying data source, query the database, process the result set, and prepare the response to the user. Individual business logic for each business aspect may be factored out into separate helper components.","After the components within a tier have been designed or redesigned based on the component-level process, individual systemic qualities within the tier may be assessed as in . For example, the tier may be assessed based on availability, security, performance, and reliability factors. Note the list of systemic qualities is potentially infinite. In one embodiment, systemic qualities may be grouped and assessed by levels based on the category of quality. For example, availability and reliability may be considered in the design or redesign in the service level and interoperability and scalability may be considered in the design or redesign in the system level. Modifications may be made to the application design to help achieve various systemic qualities.","The application design or redesign may yield either a series of tactical and strategic recommendations for code creation or code improvements in . The recommendations may include specific application enhancements based on design patterns, refactoring techniques, and frameworks. The recommendations may include specific code the design should incorporate. In one embodiment, the recommendations may include results for guiding the design or redesign phase. In one embodiment, the recommendations may be tier based. For example, the design or redesign concludes with recommendations from a component-level, use case, tier level view.","Note that the flow charts described herein represent exemplary embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. Note also that the flow charts described herein do not necessary require a temporal order. It is intended that the following claims be interpreted to embrace all such modifications and changes and, accordingly, the specifications and drawings are to be regarded in an illustrative rather than a restrictive sense.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer readable medium. Generally speaking, a computer readable medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc. as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 8A and 8B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 9A","b":["9","9"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 12A and 12B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
