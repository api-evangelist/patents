---
title: Visualizing relationships between a transaction trace graph and a map of logical subsystems
abstract: A method for diagnosing problems in a computer system by providing a user interface for visualizing flows through subsystems of the computer system, and allowing a user to explore relationships between a triage map which graphically depicts subsystems, and a transaction trace graph, which depicts a time sequence of invoked components of the subsystems. In one aspect, in response to a user selecting a portion of the transaction trace graph which depicts an invoked component, the user interface visually distinguishes one of the subsystems which invokes the invoked component. In another aspect, the transaction trace can be played back so that subsystems in the triage map are highlighted in turn, in a time sequence, as components of different subsystems are invoked. A time marker can skip to selected time points which result in updating of the triage map.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08438427&OS=08438427&RS=08438427
owner: CA, Inc.
number: 08438427
owner_city: Islandia
owner_country: US
publication_date: 20110408
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention is directed to technology for monitoring software in a computing environment.","2. Description of the Related Art","The growing presence of the Internet as well as other computer networks such as intranets and extranets has brought many new applications in e-commerce, education and other areas. Organizations increasingly rely on such applications to carry out their business or other objectives, and devote considerable resources to ensuring that they perform as expected. To this end, various application management techniques have been developed.","One approach involves monitoring the infrastructure of the application by collecting application runtime data regarding the individual software components that are invoked in the application. This approach can use agents that essentially live in the system being monitored. For example, using instrumentation of the software, a thread or process can be traced to identify each component that is invoked, as well as to obtain runtime data such as the execution time of each component. Tracing refers to obtaining a detailed record, or trace, of the steps a computer program executes. One type of trace is a stack trace. Traces can be used as an aid in debugging.","However, diagnosis of problems continues to be a vexing problem. For example, when a transaction or application is failing, the provider wants to know what exactly is going wrong, and why. Improved diagnostic techniques are needed.","The present invention provides a method for diagnosing problems in a computer system by visualizing flows through subsystems of the computer system.","In one embodiment, a tangible, non-transitory computer readable storage having computer readable software embodied thereon is provided for programming at least one processor to perform a method for visualizing flows through one or more applications. The method performed includes: (a) accessing a data store to access data which is obtained from one or more agents associated with the one or more applications, the agents provide the data using instrumentation which is installed in the one or more applications, (b) displaying a triage map region on a user interface, where the triage map region graphically depicts subsystems of the one or more applications and dependency relationships between the subsystems, and the subsystems are depicted as nodes, and (c) based on the accessed data, displaying an auxiliary region of the user interface, the auxiliary region displays at least a first transaction trace, where the at least a first transaction trace is a graph which identifies invoked components of at least a first transaction instance, and calling relationships among the invoked components of the at least a first transaction instance.","In another embodiment, a tangible, non-transitory computer readable storage having computer readable software embodied thereon is provided for programming at least one processor to perform a method for visualizing flows through one or more applications. The method performed includes: (a) accessing a data store to access data which is obtained from one or more agents associated with the one or more applications, where the agents provide the data using instrumentation which is installed in the one or more applications, (b) displaying a triage map region on a user interface, where the triage map region graphically depicts subsystems of the one or more applications and dependency relationships between the subsystems, and the subsystems are depicted as nodes, (c) based on the accessed data, displaying an auxiliary region of the user interface, the auxiliary region displays at least one transaction trace, where the at least one transaction trace is a graph which identifies invoked components of at least one transaction instance, and calling relationships among the invoked components, and (d) updating the auxiliary region in a time sequence in which a time marker moves across the at least one transaction trace, where the triage map is updated to visually distinguish one or more of the subsystems based on a position of the time marker.","In another embodiment, a computer-implemented method for visualizing flows through one or more applications is provided. The method includes the computer-implemented steps of: (a) accessing a data store to access data which is obtained from one or more agents associated with the one or more applications, where the agents provide the data using instrumentation which is installed in the one or more applications, (b) displaying a triage map region on a user interface, the triage map region graphically depicts subsystems of the one or more applications and dependency relationships between the subsystems, where the subsystems are depicted as nodes, (c) based on the accessed data, displaying an auxiliary region of the user interface, the auxiliary region displays at least one transaction trace, where the at least one transaction trace is a graph which identifies invoked components of at least one transaction instance, and calling relationships among the invoked components, and (d) updating the auxiliary region in a time sequence in which a time marker moves across the at least one transaction trace, where the triage map is updated to visually distinguish one or more of the subsystems based on a position of the time marker, (e) where the dependency relationships are depicted with arrows connecting the nodes, and (f) the triage map is updated to visually distinguish one or more of the arrows based on a position of the time marker.","Corresponding methods, systems and computer-or processor-readable storage devices which include a storage media encoded with instructions which, when executed, perform the methods provided herein, may be provided.","The present invention provides a method for diagnosing problems in a computer system by visualizing flows through subsystems of the computer system.","When a Business Transaction or application is failing, the provider wants to know what exactly is going wrong and why. A Business Transaction can represent a task from a client perspective, such as logging into a web site, ordering an item, and so forth. Sometimes the problem is general\u2014the transaction fails every time\u2014and sometimes it is more specific. For instance, the transaction may fail only when a certain user attempts it, or when a certain type of item is requested. Determining whether the problem is general or specific can be challenging, and isolating the source of the problem is more so.","Different diagnostic tools are provided for the general and specific cases. For example, a triage map can be used to address the general case, as it aggregates transactions and displays every possible way the associated logical subsystems may interact. It also displays the overall health of each of the subsystems. A transaction tracing tool can be used to handle the most specific case. It records individual transactions as they pass through the system and displays them as sequences of timed low-level method calls. The problem is that there is a wide gap between the two tools. If the triage map is too general and coarse-grained, the transaction tracer may be too specific and granular. The user who starts at the triage map and finds nothing wrong\u2014no general trend\u2014must start pulling transaction traces and browsing through them to discern a pattern. Mapping the problem back to the subsystem level requires a thorough knowledge of both the software and the underlying infrastructure.","There is thus a real need to combine the two visualizations\u2014to show the individual transactions as a series of timed steps through the logical subsystems. One possible solution allows the user to \u201coverlay\u201d an individual transaction trace (or a related set of traces) on the associated triage map. Thus, if a problem has been reported for a particular Business Transaction, the user could first view the triage map for that Business Transaction. If the overall health of the associated subsystems appeared normal, the user would recognize that this was not a general problem. The user would then request transaction traces for the Business Transaction. The transaction tracer would record and return a list of recent transactions that match the Business Transaction's parameters (e.g., a specific URL and POST parameter) and exceed the specified duration, and the user would choose one or more to \u201cmap.\u201d The user might choose to map all the lengthiest transactions one at a time (or simultaneously) to see if a pattern emerges\u2014if, for example, database calls made from one particular host are responsible for the delays.","A mapped transaction appears as a highlighted portion of the current map, with durations listed on each node and beside each relevant edge. An edge is a transition between subsystems and is represented by an arrow. That is, those subsystems that were active in the transaction appear highlighted in the map, along with the edges that represent a call from one subsystem to the next. The total time spent within a subsystem appears on the node, while the length of the calls between subsystems appears beside the edges. The component with the longest total duration in the map is marked with a special icon, such as a clock symbol. Note that in the case of multiple overlaid transactions, average durations can be displayed. Individual durations can be provided on hover, in a tooltip.","Moreover, an auxiliary region such as a tabbed pane below the map can offer additional options and information. A first tab can contain the list of returned transactions (transaction list), so the user may view and change which items are selected (and overlaid on the map). A \u201cFind More\u201d button allows the user to record more transactions using the same parameters. The second tab (details) offers information about the item currently selected in the map. For instance, if a front end node is selected, all components of the overlaid transactions corresponding to that front end will be listed, by class and method, along with their agent identifiers and their durations. The user can navigate from these nodes to the corresponding metric paths in the Investigator agent tree.","Finally, for each transaction displayed in the map, a tab displays the transaction's \u201cTrace View\u201d as it appears in the Transaction Tracer, with VCR-type controls such as rewind, play, stop, pause and fast forward, appearing above it. The user can select individual components in the trace, causing the corresponding subsystem which invokes the component to be selected in the map; the user may also choose to \u201creplay\u201d the entire transaction. During the replay, each component in the trace will be selected in turn, and the corresponding subsystem in the map will be selected as well. The relevant durations will appear in the map alongside the selected items. Again, the user can navigate from a component in the trace view to the corresponding metric path in the Investigator agent tree.","This same functionality could be available throughout an existing interface which provides transaction traces. If the trace matched one of the applications or Business Transactions available in the triage map, an option could be offered to \u201cMap This Transaction.\u201d This would bring up the appropriate map with the corresponding overlay, as described above.","Additionally, this feature could be expanded to include options for dynamically adding instrumentation from the transaction traces. Temporary instrumentation could be added by the user to drill into slow transactions for more detailed information; it could also be used to evaluate whether the current instrumentation is adequate or optimal for tracking the performance of specific Business Transactions. If not, the temporarily added instrumentation could be made permanent. Taken to the next level, this functionality could provide a simple way for users to configure their systems to monitor their Business Services.","Different types of design screens, or user interfaces, can be provided, as detailed further below.","Via the user interface, the user can easily detect relationships between subsystems and transactions of the triage map, and transaction instance data.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 1","b":["100","106","110","114","106","110","114","120","120","106","110","114","104"]},"For example, a corporation running an enterprise application such as a web-based e-commerce application may employ a number of application servers at one location for load balancing. Requests from users, such as from an example web browser  of a user, are received via a network cloud  such as the Internet, and can be routed to any of the computing devices ,  and . The web browser  typically accesses the network cloud  via an Internet Service Provider, not shown. Agent software running on the computing devices ,  and , denoted by Agent A (), Agent A () and Agent A (), respectively, gather information from an application, middleware or other software, running on the respective computing devices ,  and , in one possible approach. For example, such information may be obtained using instrumentation, one example of which is byte code instrumentation. However, the gathered data may be obtained in other ways as well. The agents essentially live in the computing device being monitored and provide a data acquisition point. The agents organize and optimize the data communicated to the manager .","The manager  can be provided on a separate computing device such as a workstation which communicates with a user interface , such as a monitor, to display information based on data received from the agents. The manager can also access a database  to store the data received from the agents. In the example provided, the computing devices can communicate with the manager  without accessing the network cloud . For example, the communication may occur via a local area network. In other designs, the manager  can receive data from the agents of a number of computing devices via the network cloud . For instance, some large organizations employ a central network operations center where one or more managers obtain data from a number of distributed agents at different geographic locations. To illustrate, a web-based e-commerce enterprise might obtain agent data from servers at different geographic locations that receive customer orders, from servers that process payments, from servers at warehouses for tracking inventory and conveying orders, and so forth. The manager  and user interface display  might be provided at a corporate headquarters location. Other applications which are not necessarily web-based or involve retail or other sales, similarly employ agents and managers for managing their systems. For example, a bank may use an application for processing checks and credit accounts. Moreover, in addition to the multi-computing device arrangements mentioned, a single computing device can be monitored as well with one or more agents.","Various approaches are known for instrumenting software to monitor its execution. For example, as mentioned at the outset, tracing may be used to track the execution of software. One example of tracing is discussed in U.S. Patent Application Publication No. 2004\/0078691, titled \u201cTransaction Tracer,\u201d published Apr. 22, 2004, incorporated herein by reference. In one approach discussed therein, object code or bytecode of an application to be monitored is instrumented, e.g., modified, with probes. The probes measure specific pieces of information about the application without changing the application's business or other logic. Once the probes have been installed in the bytecode of an application, it is referred to as a managed application. The agent software receives information from the probes and may communicate the information to another process, such as at the manager , or process the information locally, such as to determine whether the information indicates an abnormal condition. The agent thus collects and summarizes information received from the probes. The probes collect information as defined by a directives file. For example, the information from the probes may indicate start and stop times of a transaction or other execution flow, or of individual components within a transaction\/execution flow. This information can be compared to pre-established criteria to determine if it within bounds. If the information is not within bounds, the agent can report this fact to the manager so that appropriate troubleshooting can be performed. The agents ,  and  are typically aware of the software executing on the local computing device ,  and , respectively, with which they are associated.","The probes can report a standard set of metrics which include: CORBA method timers, Remote Method Invocation (RMI) method timers, Thread counters, Network bandwidth, JDBC update and query timers, Servlet timers, Java Server Pages (JSP) timers, System logs, File system input and output bandwidth meters, Available and used memory and EJB (Enterprise JavaBean) timers. A metric is a measurement of a specific application activity.","An agent reports information about transactions, which identifies resources which are accessed by an application. In one approach, when reporting about transactions, the word Called designates a resource. This resource is a resource (or a sub-resource) of a parent component, which is a consumer. For example, assume that Servlet A is the first component invoked in a transaction. Under the consumer Servlet A (see below), there may be a sub-resource Called EJB. Consumers and resources can be reported by the agent in a tree-like manner. Data for a transaction can also be stored according to the tree. For example, if a Servlet (e.g. Servlet A) is a consumer of a network socket (e.g. Socket C) and is also a consumer of an EJB (e.g. EJB B), which in turn is a consumer of a JDBC (e.g. JDBC D), the tree might look something like the following:",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Servlet A"]},{"entry":[{},"\u2003\u2003Data for Servlet A"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003Called EJB B"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Data for EJB B"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Called JDBC D"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Data for JDBC D"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003Called Socket C"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Data for Socket C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, the above tree is stored by the Agent in a stack, called the Blame Stack. When transactions are started, they are pushed onto the stack. When transactions are completed, they are popped off the stack. In one embodiment, each transaction on the stack has the following information stored: type of transaction, a name used by the system for that transaction, a hash map of parameters, a timestamp for when the transaction was pushed onto the stack, and sub-elements. Sub-elements are Blame Stack entries for other components (e.g. methods, process, procedure, function, thread, set of instructions, etc.) that are started from within the transaction of interest. Using the tree as an example above, the Blame Stack entry for Servlet A would have two sub-elements. The first sub-element would be an entry for EJB B and the second sub-element would be an entry for Socket Space C. Even though a sub-element is part of an entry for a particular transaction, the sub-element will also have its own Blame Stack entry. As the tree above notes, EJB B is a sub-element of Servlet A and also has its own entry. The top (or initial) entry (e.g., Servlet A) for a transaction, is called the root component. Each of the entries on the stack is an object.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 2A","b":["130","132"]},{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameters","Appears in","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["UserID","Servlet, JSP","The UserID of the end-user invoking"]},{"entry":[{},{},"the http servlet request."]},{"entry":["URL","Servlet, JSP","The URL passed through to the servlet"]},{"entry":[{},{},"or JSP, not including the Query String."]},{"entry":["URL Query","Servlet, JSP","The portion of the URL that specifies"]},{"entry":[{},{},"query parameters in the http request"]},{"entry":[{},{},"(text that follows the \u2018?\u2019 delimiter)."]},{"entry":["Dynamic","Dynamic JDBC","The dynamic SQL statement, either in a"]},{"entry":["SQL","Statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Method","Blamed Method","The name of the traced method. If the"]},{"entry":[{},"timers","traced method directly calls another"]},{"entry":[{},"(everything","method within the same component,"]},{"entry":[{},"but Servlets,","only the \u201coutermost\u201d first encountered"]},{"entry":[{},"JSP's","method is captured."]},{"entry":[{},"and JDBC"]},{"entry":[{},"Statements)"]},{"entry":["Callable","Callable JDBC","The callable SQL statement, either in a"]},{"entry":["SQL","statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Prepared","Prepared JDBC","The prepared SQL statement, either in a"]},{"entry":["SQL","statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Object","All non-static","toString( ) of the this object of the"]},{"entry":[{},"methods","traced component, truncated to some"]},{"entry":[{},{},"upper limit of characters."]},{"entry":["Class Name","All","Fully qualified name of the class of the"]},{"entry":[{},{},"traced component."]},{"entry":["Param_n","All objects with","toString( ) of the nth parameter passed"]},{"entry":[{},"WithParams","to the traced method of the component."]},{"entry":[{},"custom tracers"]},{"entry":["Primary Key","Entity Beans","toString( ) of the entity bean's property"]},{"entry":[{},{},"key, truncated to some upper limit of"]},{"entry":[{},{},"characters."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Parameters can include query, cookie, post, URL and session type name\/value pairs.","In step , the system acquires a timestamp indicating the current time. In step , a stack entry is created. In step , the stack entry is pushed onto the Blame Stack. In one embodiment, the timestamp is added as part of step . The process is performed when a transaction is started. A similar process is performed when a sub-component of the transaction starts (e.g., EJB B is a sub-component of Servlet A\u2014see tree described above).",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 2B","FIG. 1"],"b":["140","142","144","146","142","148","148","146","150","150","160","162","120"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 2B"},"Note, in one embodiment, if the transaction tracer is off, the system will still use the Blame Stack; however, parameters will not be stored and no component data will be created. In some embodiments, the system defaults to starting with the tracing technology off. The tracing only starts after a user requests it, as described above.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 2C","FIG. 1","FIG. 1"],"b":["200","200","210","220","230","240","210","250","210","230","250","250"]},"The database  may be included in the storage device  when the storage device  is part of a computing device  such as an application server, manager and\/or user interfaces. The storage device  can represent one or more storage devices which store data received from one or more agents, and which can be accessed to obtain data to provide a user interface as described herein. The storage device  can represent a data store.","Further, the functionality described herein may be implemented using hardware, software or a combination of both hardware and software. For software, one or more non-transitory, tangible processor readable storage devices having processor readable code embodied thereon for programming one or more processors may be used. The non-transitory, tangible processor readable storage devices can include computer readable media such as volatile and nonvolatile media, removable and non-removable media. For example, non-transitory, tangible computer readable media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Examples of non-transitory, tangible computer readable media include RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer. In alternative embodiments, some or all of the software can be replaced by dedicated hardware including custom integrated circuits, gate arrays, FPGAs, PLDs, and special purpose processors. In one embodiment, software (stored on a storage device) implementing one or more embodiments is used to program one or more processors. The one or more processors can be in communication with one or more tangible computer readable media\/storage devices, peripherals and\/or communication interfaces.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 3"},"A top level of the hierarchy is a domain level  named \u201cDomain.\u201d A next level of the hierarchy is a Business Service level . An example of a Business Service relates to trading involving a stock or other financial instrument using a web site. Thus, \u201cTrading\u201d can be the name of a node at the Business Service level of the hierarchy. A specific instance of the Trading Business Service occurs, e.g., when a particular user executes a trade. Other example Business Services include \u201cBuy Book\u201d for a book-selling web site, and \u201cEnroll in benefits\u201d for a employees enrolling in a benefits program.","A next level of the hierarchy is a Business Transaction level. As mentioned, a Business Transaction can represent a task from a client perspective, such as logging into a web site, ordering an item, and so forth. A Business Service can be made up of a number of Business Transactions. For example, for Trading, the Business Transactions can include: Login  (e.g., login to the web site), Balances  (e.g., obtain a balance of an account), Account Summary  (e.g., obtain a report of recent buy\/sell activity), Place Order  (e.g., place an order to buy or sell a security such as a stock or bond-something other than an option) and Options Trading  (perform an action such as researching and\/or making an options trade). A specific instance of Login occurs when a user attempts to login to an account.","Further, a Business Transaction can be associated with one or more Business Transaction Components. In one approach, a Business Transaction has only one identifying component. A Business Transaction Component can be a type of component of an application which is recognizable and measurable by a server, such as a servlet or EJB. In one approach, one of the components of an application is set as a Business Transaction Component, which is an identifying transaction component for a Business Transaction. The Business Transaction Component is the identifying transaction component for the transaction that is the identifying transaction for the Business Transaction. A transaction can represent a sequence of software components which are invoked in response to a request from a client, to provide a corresponding response to the client. For example, a Business Transaction Component can be identified by determining when component data reported by an agent match the a set of rules. This definition can include, e.g., a specified URL host name, URL parameters, HTTP post parameters, cookie and\/or session manager parameters. Additionally, or alternatively, the definition may require a transaction to start with a specified URL host name. The agent or manager, for instance, can compare the component data against the set of rules to determine when a Business Transaction Component is present in a Business Transaction. If a Business Transaction Component is detected, then the associated Business Transaction is of a specified type. For example, if the Business Transaction Component , , ,  or  is detected, then the associated Business Transaction is Login , Balances , Account Summary , Place Order  or Options Trading , respectively.","For instance, for a transaction which is associated with a servlet, a Business Transaction Component might be invoked in connection with a JavaServer Page (JSP) that is loaded into a secondary frame.","Additionally, one or more applications include different subsystems, e.g., software components which perform a specific task. Typically, each instance of a Business Transaction involves execution of code of a sequence of one or more of the subsystems. The subsystems depend on one another, e.g., call one another, in a serial or branched chain. Different Business Transactions can sometimes use a common subsystem.","The example subsystems include instrumented subsystems which are represented by dashed line boxes, and which are typically front end subsystems, as well as un-instrumented subsystems which are represented by dotted line boxes, and which are typically back end subsystems. As used herein, a front end subsystem is typically instrumented, while a back end subsystem is typically not instrumented. Moreover, one front end subsystem can call another front end subsystem, such as via a Web Services call. Or, a front end subsystem can call a back end subsystem. A full range of performance metrics can be obtained from an instrumented subsystem. Limited information may be obtained regarding an un-instrumented subsystem from the methods that are used to call out to them from the instrumented subsystems. In the case of un-instrumented databases, for example, a JDBC driver (located in the same Java Virtual Machine (JVM) as the calling front end) provides metrics that give us an idea of the responsiveness of the database. In the case of un-instrumented mainframes, there is usually a method that calls out to the mainframe on a specified port on the mainframe, and we can measure how long that call takes or if it stalls or reports an error.","In many cases, an un-instrumented subsystem is a back end subsystem such as a mainframe, database or some other un-instrumented computing device. These are unknown components\/destinations. The instrumented subsystems include: TradeService , OrderEngine , AuthenticationEngine , ReportingService , AuthenticationService  and ReportingEngine . The un-instrumented subsystems include: OrderRecordsSQL , ReportRecordsSQL , a system caDBHost , which is accessed via its port number , a system caSAPHost , which is accessed via its port number  and CustRecordsSQL . A subsystem which includes SQL in its name is a Structured Query Language (SQL) database. A \u201c?\u201d indicates that the subsystems  and  are unknown.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 4A"},"This example provides details of the Login Business Transaction discussed previously. In one possible implementation, each component of Login is a class-method (CM) pair. For example, a servlet is a JAVA class. It is an object that receives a request and generates a corresponding response. A class-method pair can be represented by the notation class.method. Login could involve a first class-method pair CM which obtains a user's login credentials such as a login name and a password. An example format of CM is: ServletA.ObtainLoginCredentials.","As an example, CM could be the Business Transaction Component of Login. Thus, whenever an agent detects that CM has been invoked, it concludes that the current transaction is part of Login, and associates its component data with Login.","A second class-method pair CM (e.g., ServletA.CheckLoginCredentials) checks a format of the login credentials.","If the login credentials are not in a proper format, CM calls a third class-method pair CM (e.g., ServletA.DisplayErrorMessage) which displays an error message, prompting the user to provide the proper input. If the login credentials are in the proper format, CM calls a CM(e.g., ServletA.ValidateLoginCredentials). CMcalls CM (e.g., ServletB.ReceiveLoginCredentials), passing the login credentials with the call.","CM calls CM (e.g., JDBC driver call\/SQL statement to CheckCredentialRecords) which accesses a database to determine if the user login credentials match with customer records. If CM replies to CM indicating that there is a match, CM calls CM (e.g., JDBC driver call\/SQL statement to CheckAccountStanding) which accesses a database to determine if the user's account is in good standing. If CM provides a response to CM indicating that the account is in good standing, CM calls CM (e.g., JDBC driver call\/SQL statement to UpdateLoginRecords) to update a database to indicate that the user is logged in, and return a login status=true to CM. If the credentials do not match at CM, or if the account is not in good standing at C, CM sets login status=false and CM is not called, so that a default login status=false remains.","In an example implementation, CM to CM can each include a JDBC driver call which invokes one or more SQL statements, such as to create a table entry in a database, add data to the entry and so forth. Alternatively, each SQL statement could be specified as a separate component which is called by the JDBC driver call, if desired. See also .","CM returns a reply to CM, and CMreturns the reply to CM, with either login status=true or login status=false. If login status=true, CM calls CM, which calls CM (e.g., ServletA.DisplayMessageAccessGranted) which displays a message to the user indicating that access is granted. Or, if login status=false, CM calls CM, which calls CM (e.g., ServletA.DisplayMessageAccessDenied) which displays a message to the user indicating that access is denied.","Note that separate components CMand CMare used to allow separate instrumenting of the call to CM by CM, and the call to CM or CM by CM. Alternatively, one component, CM, could handle the functions of CMand CM. This one component would invoke both a WebServices call (to CM) and another method (CM or CM) within the same app server.","As an illustration, CM to CM execute within the AuthenticationService subsystem, while CM to CM execute within the AuthenticationEngine subsystem. Login can thus execute in, or invoke, both of these subsystems.","Note that a component can continue executing after calling another component, which begins executing, in an asynchronous, multi-thread or multi-process mode. Or, a component can temporarily pause until the called component has finished executing, in a synchronous, single-thread or single-process mode. A component which is pausing can be considered to be in a wait interval, while a component which is executing can be considered to be in an active, executing mode. A component may be invoked more than once during a transaction.","FIG. B depicts example transaction traces for sequences of components invoked in a transaction, based on one possible sequence of components of . The horizontal direction represents time, while the vertical direction indicates call stack depth or position. A transaction trace, also referred to as a call stack, identifies instrumented components which have been called or invoked during the execution of one or more programs, processes or threads. Trace data of instrumented components can be used along with dependency data to understand and debug an application. A transaction trace can be a trace or all or a portion of a transaction and can extend over one or more computing devices having respective agents.","In particular, a separate transaction trace can be provided for each agent, such that different threads are separated out into different transaction traces. Moreover, each transaction trace can be represented by a separate horizontally-extending region, or \u201cswim lane\u201d of the diagram. In this diagram, a transaction trace  of the agent for the AuthenticationService subsystem is in the top horizontally-extending region, and a transaction trace  of the agent for the AuthenticationEngine subsystem is in the bottom horizontally-extending region. The two transaction traces are presented together to allow greater understanding of their relative timing. If it is known that the different agents' clocks are sufficiently synchronized, accurate conclusions can be made about the relative timing of the different transaction traces. Arrows  and  represent the respective call stack depths for the transaction traces  and , respectively.","In a graphical representation which can be provided on a user interface display, component CM is the first or root component of the transaction trace . The transaction trace includes CM at the second layer, CMand CMat the third layer and CM at the fourth layer. In the transaction trace , CM is at the first level and CM, CM and CM are at the second level. Optionally, the transaction trace  could show further detail. For instance, if CM, CM and CM are each JDBC driver calls, the transaction trace  could be modified to show child SQL statements ,  and , respectively, such as depicts in , discussed further below.","The time scale extends from t-t, which can represent 1300 milliseconds (ms.), for instance. The transaction trace indicates a time interval in which a component executes, and the calling relationship between components. For example, CM executes from t-t, CM executes from t-t., CMexecutes from t-t (approximately), CMextends from t (approximately)-t and CM executes from t-t.. Further, CM calls CM, CM calls CMand CM, and CMcalls CM.","FIG. B depicts waiting periods in the example transaction traces of FIG. B. A synchronous transaction involves one component, e.g., CM, calling another component, e.g., CM, and waiting for CM to reply before continuing\/resuming execution. We can assume that the time required by the called method is a \u201cwait time\u201d for the calling method. It is also possible to trace an asynchronous transaction as well, and to depict it in a transaction trace view similar to FIG. B. A time consumed by a component which is outside the wait time may be considered to be a net duration of the execution or response time, such that the wait time plus the net duration equals the total duration of the execution or response time. The total duration of a component can be calculated by summing the durations for all the methods directly called by the component and then subtracting that sum from the total recorded duration for the component.","For each horizontal bar in the graph, an unpatterned portion indicates that the component is not waiting for a response from a called component, while a bar with a pattern of slanted lines indicates that the component is waiting for a response from a called component. Even if the instrumentation of a component does not explicitly indicate whether a component is executing or waiting, we can infer that, for the synchronous case, the earlier components are waiting while the methods they called are executing. In the time consumed by a component, some of it may be spent executing, waiting for a called component to respond, being delayed by the network or CPU delay, and so forth.","In this example, CM begins to execute at t, at the start of an instance of the Login Business Transaction, and calls CM at t. CM begins to execute at t and calls CMat t. CMbegins to execute at t. The transaction trace  may not specify that CMcalled CM at t because CM is on a different subsystem, associated with a different agent, in this example. Also, there may be a delay between CMcalling CM and CM starting to execute due to a network transit time, processing delay, or other factors, for instance. However, the transaction trace  indicates that CMstarts to execute at t. and was called by CM, e.g., in a cross-process call. That is, CM starts to execute as a result of an invocation of CM. CM calls CM at t and CM executes from t-t. CM calls CM at t and CM executes from t-t. CM calls CM at t and CM executes from t-t. At t, the control flow returns to CM and at t., CM stops executing. The control flow does not return to CMuntil t due to the above-mentioned factors. At t, the control flow returns to CMbriefly and then to CM briefly, when CM calls CMjust after t. In the transaction trace , CMcalls CM at t and CM executes from t-t.. At t., the control flow returns to CM, at t the control flow returns to CM and at t. the control flow returns to CM.","CM, CM and CM each call a database (CustRecordsSQL). However, because the database is un-instrumented, the amount of time consumed by the database cannot be distinguished from the total execution time of CM, CM or CM in the transaction trace .","In this example, for CM, the total duration is t\u2212t=1300 ms., the wait time is t.-t=1150 ms. and the net duration is 1300\u22121150=150 ms. For CM, the total duration is 1150 ms., the wait time is t\u2212t=1000 ms. and the net duration is 1150\u22121000=150 ms. For CM, the total duration is t\u2212t=800 ms., the wait time is t\u2212t=700 ms. and the net duration is 800\u2212700=100 ms. For CM, the total duration is t\u2212t=200 ms., the wait time is t.\u2212t=50 ms. and the net duration is 200\u221250=150 ms. For CM, the total duration is t.\u2212t=50 ms., the wait time is 0 ms. and the net duration is 50\u22120=50 ms.","Similarly, in the transaction trace , for CM, the total duration is t.\u2212t.=600 ms., a back end call time is t\u2212t+t\u2212t+t\u2212t=100+100+100=300 ms. and a time spent in the AuthenticateEngine subsystem is 600\u2212300=300 ms. This time spent is analogous to a net duration. For CM, the total duration is t\u2212t=100 ms., the wait time is assumed to be 0 ms. and the net duration is 100 ms. For CM, the total duration is t\u2212t=100 ms., the wait time is assumed to be 0 ms. and the net duration is 100 ms. For CM, the total duration is t\u2212t=100 ms., the wait time is assumed to be 0 ms. and the net duration is 100 ms.","A total duration for the AuthenticationEngine subsystem is 600 ms. based on the total duration of its root component, CM. The back end call time of the AuthenticationEngine subsystem is 100+100+100=300 ms. based on the times when a call was made outside the subsystem (e.g., the calls by CM, CM and CM, the lowest level components, at t, t and t, respectively) and the times when a corresponding response to the calls were received (e.g., t, t and t, respectively). The time spent in the AuthenticationEngine subsystem is then the total duration less the back end call times, or 600\u2212300=300 ms. The back end call times can be apportioned to one or more instrumented or un-instrumented subsystems which are called. In this example, one un-instrumented subsystem is called (CustRecordsSQL) so the 300 ms. is attributed to it.","For the AuthenticationEngine subsystem as a whole, functionally, there is no \u201cwait time\u201d identified, in one implementation. CM, CM and CM correspond to \u201cback end call\u201d times. The three components in the trace represent the calls made to one or more back ends, but we can't distinguish time spent in executing the call and time spent waiting for the back end to respond. We subtract the back end time from the total time for AuthenticationEngine so that we can distinguish between time spent in the AuthenticationEngine \u201cfront end\u201d and time spent in \u201cback end calls.\u201d In this case, since all the back end calls go to the same back end, they can be aggregated into a single value\u2014the total time spent calling CustRecordsSQL. In other cases, a separate back end call time can be aggregated for each of multiple back ends.","Similarly, we can determine a total duration for the AuthenticationService subsystem as 1300 ms. from the total duration of its root component, CM. The wait time of the AuthenticationService subsystem is 700 ms. based on the time when a lowest level component call was made outside the subsystem (e.g., the call by CM, the lowest level component, to CM at t) and a time when a response to the call was received (e.g., t). The net duration of the AuthenticationService subsystem is then the total duration less the wait time, or 1300\u2212700=600 ms.","Further, the wait time of 700 ms. of the AuthenticationService subsystem can be attributed to the one or more subsystems it calls. Since the AuthenticationEngine subsystem is the only subsystem called by the AuthenticationService subsystem, we can attribute the 700 ms. to the AuthenticationEngine subsystem. However, it was determined that the total duration of the AuthenticationEngine subsystem was only 600 ms. Accordingly, 700\u2212600=100 ms. can be attributed to a time consumed in communicating a request from the AuthenticationService subsystem to the AuthenticationEngine subsystem, and in communicating a corresponding reply from the AuthenticationEngine subsystem to the AuthenticationService subsystem. Note that the communicating of a request and a reply between subsystems can include accessing a service such as a Web Service, in addition to network and CPU delays.","In this manner, we can work from the last-called subsystem backwards to the first called subsystem of a transaction to determine total durations, net durations or time spent in a subsystem, wait times, back end call times (or other calls to un-instrumented subsystems), and inter-subsystem communication times. In terms of representing back end call times\u2014there is a question of when and how to use net versus full duration. Net duration may be preferable because it provides more granularity, but in the case where the call is being made to an un-instrumented back end, we have only the full duration. We can set a rule to use net duration where available, but indicate with a grouping bracket or similar when the time includes that of the un-instrumented back end. An example procedure is discussed next.","FIG. B depicts a method for determining total durations, net durations, wait times and inter-subsystem communication times, for a sequence of dependent instrumented subsystems. A sequence of instrumented subsystems can be serial, so that one subsystem calls a first next subsystem, the first next subsystem calls a second next subsystem and so forth, so that there is only one branch or chain in the sequence. Or, the sequence can have one or more parallel branches, such as when one subsystem calls a first next subsystem and a second next subsystem. For example, in , discussed further below, a serial sequence of instrumented subsystems is provided for Login, where AuthenticationService calls AuthenticationEngine. Further, a multi-branch sequence of instrumented subsystems is provided for Place Order, where TradeService calls both OrderEngine and AuthenticationEngine in separate branches. Furthermore, stages of a sequence of dependent subsystems can be defined. For example, for Login, AuthenticationService is at a first stage and AuthenticationEngine is at a second (and last) stage. For Place Order, TradeService is at a first stage, and OrderEngine and AuthenticationEngine are both at a second (and last) stage.","In view of these concepts, step  of FIG. B includes selecting an instrumented subsystem for which a trace has been obtained of components invoked by the subsystem. For example, in FIG. B, select the AuthenticateService subsystem and its trace . Step  determines a total duration T of the subsystem from the duration of its root component. For example, T=1300 ms. based on CM in the trace . Step  identifies all components in the trace that correspond to calls (e.g., a cross-process call) going out of the subsystem to a destination subsystem, whether instrumented or un-instrumented. For example, we identify CMin the trace . Step  sums the times of the identified components to obtain the total duration T of all calls outside the subsystem. Here, there is only one such identified component, CM, with Tc=700 ms., and we have T=Tc=700 ms. Step  subtracts the total duration T of all calls outside the subsystem from the total duration T of the subsystem to obtain the net duration T of the subsystem, also referred to as a front end time. For the trace , we have T=T\u2212T=1300\u2212700=600 ms.","Step  groups the identified components by their destination subsystem, then sums each group's times (such as the times Tc, Tc. . . of step ). These sums are the full durations TF for each call to a destination subsystem. For the trace , there is only one group because there is only one destination subsystem, e.g., AuthenticateEngine subsystem. The sum of times for AuthenticateEngine subsystem is TF=700 ms. Decision step  determines if there is a next subsystem to analyze. If there is a next subsystem to analyze, steps - are repeated for the next subsystem. For example, a next subsystem to analyze would include a destination subsystem identified in step . The process could start at the front of a sequence of subsystems and work its way down to successively called subsystems in one or more serial paths. For example, AuthenticateEngine subsystem is a destination subsystem of AuthenticateService subsystem.","Thus, AuthenticateEngine subsystem and its trace  in FIG. B are selected at step . Step  determines a total duration T=600 ms of the subsystem from the duration of its root component CM. Step  identifies CM, CM and CMwhich correspond to calls going out of the subsystem, in this case to the un-instrumented back end CustRecordsSQL. Step  sums the times of the identified components to obtain the total duration T of all calls outside the subsystem. Here, we have Tc=100 ms. for CM, Tc=100 ms. for CM and Tc=100 ms. for CM, so T=300 ms. Step  provides, for the trace , T=T\u2212T=600\u2212300=300 ms.","Step  groups the identified components by their destination subsystem, then sums each group's times (TF=Tc+Tc+Tc=300 ms.). Decision step  determines if there is a next subsystem to analyze. When there is no next subsystem to analyze at decision step , the process revisits each call to a destination subsystem, which is instrumented and is associated with a respective agent. In particular, step  selects an instrumented destination subsystem. In the example of FIG. B, AuthenticateEngine subsystem is revisited. Step  subtracts the total duration (T=600 ms.) from the full duration TF=700 ms of the calls to the destination subsystem to obtain the net duration TN=100 ms. for the calls to the destination subsystem.",{"@attributes":{"id":"p-0114","num":"0113"},"figref":"FIG. 5A","b":"500"},"A region  of the user interface allows the user to select a map tab  or a browse tab . Currently, the map tab  is selected. The tab provides a tree of nodes, including a node which can be opened to provide a view of the available Business Services, and a node which can be opened to provide a view of the available Frontends. The By Business Service node includes a node for the Business Service called Trading, and Trading includes nodes for its constituent Business Transactions: Balances, Login, Options Trading, Place Order and Account Summary, as discussed. Trading has been selected by the user, and the current display is based on this selection. This selection is noted by the underlining of \u201cTrading\u201d in the tree in region .","In response to this selection, a number (one or more) of associated Business Transactions, subsystems of the Business Transactions, and arrows which show dependency relationships among the subsystems, are displayed in a main area  of the user interface, referred to as a triage map region. The oval-shaped nodes , , ,  and  on the left hand side represent, and include names of, the Business Transactions. Arrows, also referred to as edges, indicate which subsystem is first invoked for a Business Transaction, and the subsystems which are subsequently invoked. In some cases, a common subsystem is invoked for different Business Transaction instances. For example, AuthenticationService could be invoked by Options Trading and Login Business transactions.","The components which are invoked for a given Business Transaction instance can be separately tracked using unique identifiers, even when the components are at the same subsystem. Moreover, it is possible for separate instances of a component to be invoked at a subsystem in different Business Transaction instances. Again, these separate instances can be separately tracked.","Also, note that separate instances of the same Business Transaction need not invoke the same subsystems. For instance, due to an error or network failure, a Business Transaction instance may not invoke a particular subsystem which would otherwise be invoked when no error occurs. Or, due to the time of day or available resources, separate instances of the same Business Transaction can invoke different subsystems. Many variations are possible which are not necessarily depicted in these simplified examples.","The border of the nodes is used to depict whether the node is highlighted, and in some cases, a type of highlighting. Highlighting is one way to visually distinguish a node from other nodes. Different colors may also be used. In one approach, a dotted or dashed line border indicates no highlighting, while a solid line indicates highlighting. Double borders can also be used as well. In one approach, a solid line outer border indicates the node was selected by a user, and a dashed line outer border indicates that the node is being visually distinguished based on some other command by the user. The highlighting of a node can be responsive to a user selection in the region  and to a user selection of the node itself in the UI. Various highlighting, color coding and other visual effects can be provided to convey information to the user. Some of the subsystem nodes include: (a) a symbol such as two overlapping screens which represents a front end or aggregated front end (e.g., all servlets that share the same application context), (b) a cylinder-shaped symbol that represents a database or (c) a symbol that represents an unknown (un-instrumented) subsystem which is the destination of a socket call, to identify a type of the subsystem.","Other types of notations involve metrics and alerts. Alerts are available for Business Transactions (based on the associated component data), for a front end's overall performance (\u201cHealth\u201d), and for back end calls made by the front end to an un-instrumented back end or to another front end. Calls made to another front end can be made through Web Services or EJB Clients to appear as such on the map. These alerts can be created and configured by a user. Thus, any given Business Transaction, front end, or back end call might or might not have an alert defined for it. If an alert is defined, it can appear in one of several states: normal (green), caution (yellow), danger (red), no data (gray) and scheduled downtime (black and gray). If an alert is not defined, no icon appears within the Business Transaction or front end, but a small \u201cmetric icon\u201d can appear at the endpoint of the back end call to indicate that metric data is available here.","A circle which appears at the end of an arrow, which represents a call from one subsystem to another, indicates that there is recent data available for that call, though no alert has been defined. When an alert is defined for a back end call, the alert icon can be overlaid on and essentially replace the metric icon. The lack of any circle\/alert icon can mean that no metrics have been seen for that call since the map was loaded. The alert icon for a method call can be set based on the total duration of the method call. The circle can be placed at a tip of the arrow, next to the called subsystem. For simplicity, in this example, a fully solid dark colored circle denotes a danger alert status, an open circle denotes a normal alert status, and a half-dark colored circle denotes that metrics are available and no alert has been defined. The region  can also provide the alert notation next to the name of a Business Service and Business Transaction to indicate what alert level is displayed for the associated hierarchical level. The circle notation in the region  for the Business Transactions is consistent with the circle notation for the nodes , , ,  and . The alert level of a subject subsystem represents the highest alert level based on health metrics of the subsystem, as well as all associated destination subsystems of the subject subsystem. Also, the alert level of a Business Service can be set as the highest alert level of any of its Business Transactions.","The front end subsystems can make a call out of the application server through a socket. Those calls could be Web Services calls, JDBC driver calls or other types of calls. Web Services are typically application programming interfaces (API) or Web APIs that are accessed via Hypertext Transfer Protocol (HTTP) and executed on a remote system hosting the requested services. These calls, and others such as the JDBC driver calls, are still in the application server so we can detect them and obtain metrics regarding them, but since they call out of the application server, they are referred to as back end calls. Thus, the whole map such as in  shows detected front ends and the calls they make to back ends. The destinations of these back end calls are either other front ends (in the case of Web Services and some EJB calls) or un-instrumented back end components. Most of these un-instrumented components can be at least partially identified from the back end call; for instance, JDBC driver calls are labeled with their destination database name, and the default socket calls are labeled with the destination host and port. In other cases, the user may have defined custom calls and labeled them with their destination. In all these cases, the UI can provide a box representing the back end destination, labeled appropriately and with an icon depicting a database or other appropriate type of component.","For instance, if there is a call through a socket and we have instrumented the call and knew that it took 56 milliseconds, but we do not know its destination (what subsystem it called), we can display that time metric in the UI alongside a back end node showing an \u201cunknown component\u201d icon and labeled with the system hostname and port. The back ends , , ,  and  are essentially dummy nodes in the map because they represent a destination which is not instrumented and for which we therefore have no information reported by the destination. The circular icon adjacent to these nodes, at the end of the arrows representing the calls from the front ends, serve as placeholders for the back end call metrics and associated alerts.","For a call from one front end to another, full instrumentation is available. The call may be made, e.g., via Web Services or an EJB client. All Web Services calls originating from a single front end are aggregated and represented as a single \u201cWeb Services\u201d back end call; thus, unlike other types of calls, a Web Services call may have more than one destination. In this case, the back end call will appear as a forking or branching arrow in the map. Since only one set of data is associated with this call, in one approach, the circular \u201cW\u201d icon appears in the map at the base of the fork, rather than alongside the destination box. In , Web Services  and  represent two such forking Web Services calls; contrast these with the call between AuthenticationService  and AuthenticationEngine , which is also a Web Services call, but with a single destination. Specifically, a the Web Services icon  is at the base of a fork and not alongside the destination nodes  and , so there is one set of data associated with the call to Web Services . A Web Services icon  is alongside or adjacent to the destination node  since there is only one destination for the call. Optionally, the Web Services icon  could be between the nodes  and  so that the arrow  still extends between the node  and the Web Services icon  but an additional arrow (not shown) extends between the Web Services icon  and the node . A Web Services node  is at the base of a fork and not alongside the destination nodes  and , so there is one set of data associated with the call to Web Services .","Recall that the TradeService node , for instance, can represent a summary of multiple instances of the TradeService subsystem which run across multiple machines. The Web Services  are associated with one or more computing device\/machines on which the TradeService  subsystem runs, and the Web Services  are associated with one or more computing device\/machines on which ReportingService  subsystem runs. The metric or alert icons for Web Services  and  represent the performance or health of the method call(s) that were made from one computing device to a next computing device.","In one approach, the alert relates to a time metric such as a response time. The alerts can be configured so that a normal status is indicated for a response time less than a first level L, a caution status is indicated for a response time between L and a second level L, and a danger status is indicated for a response time greater than L. The alerts can be configured based on any type of performance metric. For example, instrumentation can yield many types of performance metrics, including an average execution or response time of a component, an invocation rate per second or per interval, a count of invocations, a concurrency metric indicating a number of invocations that have started but not finished per interval, and a stalled metric indicating a number of invocations that have started whose method invocation times have exceeded a specific threshold per interval. These are examples of component data obtained at application runtime and reported by an agent. Alerts can be provided for any of the items.","Further, for resources in use on the computing machine that support the subsystems, the instrumentation can yield, e.g., data which can identify a garbage collection heap size, a bandwidth metric indicating file and socket activity, a number of threads, system logs, exceptions, memory leaks and component interactions. Alerts can also be provided for any of these items.","Moreover, an alert can be configured based on one or more performance metrics for a Business Transaction Component, such as a URL with specific parameters. For example, an alert can represent an average response time of a Business Transaction Component over a specified period of time.","As explained further below, based on the alerts and metrics icons, the user can take various steps to obtain further information regarding the Business Transactions, subsystems and calls depicted in the UI. In one approach, the user is guided by the presence of the alerts and metrics icons and seeks to obtain further information regarding the associated Business Transactions, subsystems and calls, such as to diagnose a problem. Moreover, as explained below, other types of information can be presented on the UI to assist in diagnosis. Generally, the various UIs provided herein can be provided in one or more windows and can use known UI techniques such as a popup window, mouse over or hover box, tooltip and right-clicking to access information.","Referring to the specific Business Transactions and their subsystems, the UI indicates that Place Order  and Options Trading  both invoke the front end subsystem, TradeService . In an example scenario, a user initiates Place Order  by defining an order which is to be placed, e.g., to buy or sell a stock or bond. All user inputs, and information or instructions presented to the user, can be provided via a web page or other UI. Or, a user initiates Options Trading  by defining a trade involving an option, such as a put or call. In either case, TradeService is used. TradeService calls System caSAPHost , such as to obtain additional information to process the order\/trade. Little is known about the System caSAPHost  because it is not instrumented, so the node for it is merely a placeholder. The port of the computing device  which is called by the instance of TradeService is known (e.g., port ), and this information is used to decorate the node . System caSAPHost  could call another host or resource (not shown) as well, but this would not be depicted.","In computer networking, a port is an application-specific or process-specific software construct serving as a communications endpoint. It is used, e.g., by Transport Layer protocols of the Internet Protocol Suite, such as Transmission Control Protocol (TCP) and User Datagram Protocol (UDP). A specific port is identified by its number, commonly known as the port number, the IP address with which it is associated, and the protocol used for communication. TCP and UDP specify a source and destination port number in their packet headers. A process associates its input or output channel file descriptors (sockets) with a port number and an IP address, a process known as binding, to send and receive data via a network. The operating system's networking software has the task of transmitting outgoing data from all application ports onto the network, and forwarding arriving network packets to a process by matching the packets IP address and port numbers.","Processes create associations with transport protocol ports by means of sockets. A socket is the software structure used as the transport end-point. It is created by the operating system for the process and bound to a socket address which consists of a combination of a port number and an IP address. Sockets may be set to send or receive data in one direction at a time (half duplex) or simultaneously in both directions (full duplex).","TradeService  uses one or more Web Services (aggregated into a Web Services nodes ) to request the order\/trade. Web Services  in turn call: (a) the OrderEngine subsystem , which processes the order\/trade, and\/or (b) the AuthenticationEngine subsystem , which authenticates the order\/trade, such as by verifying the user's credentials. The map does not necessarily indicate that TradeService calls both of these other subsystems at approximately the same time or at different times (e.g., maybe it was after the call to the OrderRecordsSQL database was made); as part of the same Business Transaction or as part of different Business Transaction (there are two Business Transactions associated with TradeService, after all); etc. It's also possible they were both called as part of the same Business Transaction but during different instances of it. The map tells us that at some point in a specified time period, TradeService called both of these front ends, using Web Services .","To service one or more calls from Web Services , the OrderEngine subsystem  calls two back ends: the OrderRecordsSQL database , which stores order records using SQL, and System caDBHost . System caDBHost  may be used, e.g., for some administrative handshake or other task that was not marked as being part of the JDBC driver. The AuthenticationEngine subsystem  calls the CustRecordsSQL database , which stores customer records, such as to confirm that the user\/customer is authorized to place the order\/trade.","The Business Transaction of Login  involves the front end subsystem, AuthenticationService . In an example scenario, discussed previously, Login invokes components CM-CMat the AuthenticationService subsystem  and CM-CM at the AuthenticationEngine subsystem .","As depicted by arrow , CMcalls CM at the AuthenticationEngine subsystem , which could be on the same server, or a different server, than the AuthenticationService subsystem . CM calls CM, which calls the CustRecordsSQL database  to access customer records to confirm that the user login matches the password. Assuming this succeeds, the control flow returns to CM and CM calls CM. CM calls the CustRecordsSQL database  (or another database) to again access customer records to confirm that the user's account is in good standing, e.g., the user has paid fees, or made a minimum number of trades, to maintain the account. Assuming this succeeds, the control flow returns to CM and CM calls CM. CM calls the CustRecordsSQL database  (or another database) to again access customer records to update the records to indicate that the user is now logged in, and returns login status=true to CM. The control flow then returns to CM, and CM calls CMwhich in turn calls CM. The control flow then returns to CM, then to CM and finally to CM at which point the instance of the Login Business Transaction ends.","Both Balances  and Account Summary  invoke a common front end subsystem, ReportingService . In an example scenario, a user initiates Balances by making a request to obtain an account balance, e.g., to learn the amount of funds in a particular account. Or, a user initiates Account Summary  by making a request to obtain a report (e.g., statement) of recent transactions, e.g., orders\/trades, fund transfers and so forth. In either case, ReportingService  processes the report request by calling the Web Services , which in turn calls the AuthenticationEngine subsystem , which may call the CustRecordsSQL database  to access customer records to confirm that the user\/customer is authorized to obtain a report.","In one implementation, the control flow returns to the ReportingService , which makes another call via the Web Services  to the ReportingEngine subsystem , which fulfills the report request by calling the ReportRecordsSQL database , to obtain records which are used to provide the report. This call to Web Services  may include information which specifies the type of report desired, an account identifier, a time frame involved and so forth.","The time metrics which are calculated as discussed in connection with FIG. B-B can be displayed on the UI , such as above a corresponding node. That is, the UI and its nodes and arrows are decorated with the metrics. The total duration, net duration and\/or wait time can be displayed. Here, the total duration of Login (1300 ms. or ms.) is displayed above the Login node , the net duration of 600 ms. is displayed above the AuthenticationService node , the inter-subsystem communication time (100 ms.) for the call to AuthenticationEngine , is displayed above the arrow , the duration 300 ms. is displayed above the AuthenticationEngine node  and the wait time of 300 ms. which is allocated to CustRecordsSQL is displayed above the arrow . The nodes and arrows are thus decorated with metrics. These metrics may be for a single instance of a Business Transaction such as Login or, more commonly, an average over multiple instances of the Business Transaction, such as over a specified time interval.","The danger level alert which is displayed for the Login node  may be based on the time of 1300 ms. exceeding a threshold level such as 1000 ms. The danger level alert which is displayed for the AuthenticationService node  may be based on the time of 600 ms. exceeding a threshold level such as 300 ms. The danger level alert which is displayed for the arrow  may be based on the time of 100 ms. exceeding a threshold level such as 50 ms. The normal level alert which is displayed for the AuthenticationEngine node  may be based on the time of 300 ms. not exceeding a threshold level such as 500 ms. The half-dark colored circle at the tip of the arrow  (e.g., at the endpoint of a back end call) denotes that related metrics are available and no alert has been defined.","Generally, the UI  can be populated with time metrics for various Business Transactions, subsystems and calls. Time metrics are depicted for the Login Business Transaction  only for simplicity, but in practice, can be displayed for all Business Transactions at the same time. When multiple time metrics are associated with a subsystem which is invoked by different Business Transactions (an example is TradeService  which is invoked by Place Order  and Options Trading ), each time metric can be associated with one of the Business Transactions by color coding or other visual technique. For example, a time metric associated with Place Order can be displayed in one color above the TradeService node , while another time metric associated with Options Trading can be displayed in another color above the TradeService node .","A clock icon  can be provided for the subsystem which has a highest net duration (or total duration or wait time) among all subsystems of the Login Business Transaction. If two net durations are the same, within a tolerance, the higher level subsystem can receive the icon, the icon can be displayed with both subsystems, or the icon need not be displayed.","In this way, the user can quickly ascertain that a given subsystem is a problem and focus the diagnosis on that subsystem. Multiple problematic subsystems can also be identified. The severity of an alert can also guide the user. For example, if a normal level alert is displayed for the AuthenticationEngine subsystem, and a danger level alert is displayed for the AuthenticationService subsystem, the user may be led to investigate the AuthenticationService subsystem first. Various techniques are provided which allow a user to obtain additional details regarding a subsystem and the components it invokes.","The metrics which are provided on the UI are based on data from a managed application in a specified time interval. In one approach, the UI is initially displayed with no metrics, and the user enters a command to obtain metrics such as by finding transactions which match user-specified filter criterion. The user can manually specify the criterion, or a default set of one or more criterion can be used. The UI is then populated with the metrics from transactions that match the criterion. In another approach, the UI can be displayed initially with metrics which are captured based on a default set of filter criterion.","FIG. B depicts the user interface of  with the addition of a hover box showing metrics for the Login Business Transaction . In the UI , the user can use a pointing device such as a mouse to point a cursor (represented by an angled arrow) over a node of a Business Transaction, subsystem or Web Service call, or over an arrow, to display related performance metrics. Generally, the user can point at and click on a node to enter a selection to cause related information to be displayed in an auxiliary region of the UI, discussed further below. Pointing at an element usually causes the hovering tooltip to appear; clicking on (i.e., selecting) the element usually displays related information in another part of the UI. The node can be associated, e.g., with a Business Transaction overall or with a subsystem of a Business Transaction. The specific performance metrics and their format can be configurable. Here, the cursor is pointed at, and held over, the node for Login for a few moments, causing a hover box  to appear. The user thus provides a command to display metrics associated with the selected Business Transaction.","The hover box identifies the name of the Business Transaction (Login), as well as an alert level and performance metrics for a relevant time interval. The alert level indicates a dangerous condition. Next, the average response time (total duration) of 1300 ms. is displayed. In this scenario, as an example, the response time of Login is an average over four instances of Login. \u201cCount\u201d indicates a number of instances or invocations of Login in the most recent time interval, which is the time interval under analysis. Here, count=4 indicates four invocations. \u201cMin\u201d indicates the minimum response time, e.g., 1100 ms., and \u201cMax\u201d indicates the maximum response time, e.g., 1500 ms. \u201cErrors per interval\u201d identifies the number of errors in Login in the most recent time interval. \u201cResponses per interval\u201d identifies the number of responses associated with Login, e.g., four responses. \u201cStall count\u201d identifies the number of stalls in Login in the most recent time interval, e.g., zero stalls. The hover box can provide summary performance data across all the computing devices\/agents that are reporting the selected Business Transaction.","FIG. B depicts the user interface of  with the addition of a hover box showing metrics for the AuthenticationService subsystem . In the UI , in addition to providing a hover box for a Business Transaction, e.g., via node , a hover box with metrics could similarly be provided for any of the subsystems of Login. For example, a hover box  for the AuthenticationService subsystem  could indicate metrics specific to the subsystem, such as: an alert level, average response time, number of concurrent invocations, errors per interval, responses per interval and stall count.","Thus, for a given subsystem, the user can trigger the display of associated performance metrics. This is across all transactions that pass through that subsystem, so it is represents a general health or overall performance.","As a further example, a hover box for the Web Service  could indicate similar metrics which are specific to the calls made by TradeService , such as: an alert level, average response time, errors per interval and stall count.","The user can also trigger the display of a list of reporting agents and per-agent data. Along with the by-agent data, the dependency map can display summary performance data, e.g., overall health data, across all the computing devices\/agents that are reporting a particular Business Transaction. The current values are displayed on hover, and time trends are also available, e.g., under the tabs labeled Transaction List, Details and Trace View, in an auxiliary region. Finally, the same kind of summary data is also available for the identified subsystems (front ends and their back end calls), both the snapshot on hover and the time trends.","The tooltip data (and the data charts shown in ) corresponds to the \u201cgeneral health\u201d or \u201coverall performance,\u201d as it is summarized across all relevant transactions on all agents. When we list contributing agents and the by-agent performance metrics (as in ), we are summarizing across all relevant transactions reported by the listed agent (i.e., running on a particular JVM). We refer to this as a single \u201cLocation\u201d of the subsystem, and talk about the Location health metrics.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":["FIG. 5C","FIG. 5A"],"b":["532","304","530"]},"For example, the context menu  allows the user to select among four options to obtain additional information regarding Login . The first option is to display a map of Login, which results in the interface of . The second option is to find matching transactions, which results in the interface of FIG. E. The third option is to find locations (i.e., contributing agents and their associated health metric data) for Login, which results in the interface of . The fourth option is to view health metrics for Login, which results in the interface of . The health metrics, a set of performance metrics, can indicate the overall health of Login, for instance.",{"@attributes":{"id":"p-0154","num":"0153"},"figref":["FIG. 5D","FIG. 5C"],"b":["532","504","540","504","532","304","304","562"]},"Here, the user selection causes the UI to highlight the node  which represents Login  and the associated subsystem nodes ,  and  with a heavy solid line border. Again, highlighting by changing the border of the nodes is one option, as the use of color, shadows and\/or other visual effects is also possible. The arrows associated with Login can also be highlighted, e.g., by an increased thickness or other visual technique. Through this highlighting, the user can easily identify and focus on the subsystems involved in a user-selected Business Transaction, as well as the calling dependency relationships among these subsystems. The nodes of the subsystems which are not involved in the user-selected Business Transaction are not highlighted, and can remain de-emphasized, e.g., with a dashed or dotted border. The highlighting is one way to visually distinguish one node or arrow from another.","FIG. E depicts a user interface to find matching transactions for the Login Business Transaction which is launched from the context menu  of the UI of . In the UI , a window  is displayed which allows a user to find matching transaction instances for a currently selected Business Transaction, e.g., Login. The window allows the user to enter a command with one or more filter criterion to be used in obtaining data from instrumentation of an application in a future time period, in a transaction mapping mode. For example, consider a scenario in which a user of a client computing device has a problem logging in to an application, where the login takes an unusually long time. The user may telephone personnel at a help center and explain the problem. The help center personnel may take steps to diagnose the problem, such as instructing the user to repeat the same steps which resulted in a problem, while initiating a new recording of metrics from the transaction. This can assist the help center personnel in determining if the problem is specific to the particular user, occurring each time for that user, or is general, occurring for all, or a substantial portion of, users who attempt to login. If the problem is specific to a user, additional matching transactions can be located for only that user. The window  could include a field (UserId) to identify a user of a client computing device as a filter criterion. Determining whether the problem is general or specific is helpful in isolating the source of the problem.","The help center personnel can obtain additional data by configuring the recording of data in a future monitoring period, such as the next few seconds or minutes. The help center personnel can enter a threshold duration for the transactions which is a specified number of milliseconds or longer. This means only component data for future Login Business Transactions (e.g., transactions which invoke CM) which exceed the threshold will be captured and displayed via the UI. In some cases, a Business Transaction includes multiple threads in which case the first thread can be captured and displayed, in one approach. Depending on the configuration, we can also capture all the threads; however, we typically list\/label the traces by the first component of the first thread.","Further, the help center personnel can set the time period to end after the earlier of: (a) a specified number of seconds, and (b) after a specified number of matching transactions (e.g., matching instances or traces) are detected. As an example, the help center personnel may set the threshold for 1000 ms. stopping after 180 seconds (3 minutes) or after 10 matching transactions, whichever comes first. The help center personnel can select the \u201cOK\u201d button to begin the monitoring period, or the \u201cclose\u201d button to close the window without beginning a new monitoring period.","The window  could be used to set any filter criterion, including minimum and maximum transaction duration, as well as filtering by agent or host identifier, or other factors.","Information about the matching transactions is depicted in auxiliary region . The auxiliary region  provides a table which lists a total duration, or other time metric, of each transaction instance, the reporting agent identifier, the identifier of the host on which the agent runs, and a timestamp of a start time of the transaction. The time is listed in hours, minutes and seconds. Fractions of a second could also be provided. The auxiliary region  could provide any type of performance metric associated with the transaction instances.","The metrics that we gather every 15 seconds, for instance, are different from this transaction trace data. Transaction traces involve recording matching transactions and identifying the call sequence and the durations of each call (and total duration of the sequence). We also obtain information about whether a particular transaction reported an error.","The auxiliary region  can be displayed as a window or other portion of the UI , or on a separate display screen, for instance. It is helpful if the auxiliary region is displayed concurrently with the triage map region . The auxiliary region can appear in any portion of the UI.","The user can click the column headings to sort the table entries in the auxiliary region . In another approach, the auxiliary region  could present the results on two or more axes, where one axis represents time and one or more other axes represent the other table headings, e.g., duration, transaction id, agent id and host id. Other visual displays are possible such as bar charts, pie charts and so forth. The longest duration transactions can be identified quickly, for instance, for diagnosis.","Here, four transactions are located, two from AgentA at HostA and two from AgentB at HostB. The response times (total duration) of the transactions at AgentA are 1100 and 1200 ms. for an average of 1150 ms. The response times (total duration) of the transactions at AgentB are 1500 and 1400 ms. for an average of 1450 ms. An average response time of the four transactions is thus 1300 ms. The user can select the \u201cfind more\u201d button to obtain more of the same type of transaction instances which are currently displayed in the auxiliary region . In one approach, this search automatically uses the same filter criterion set by the window  so the user is not required to re-enter the criterion. That is, the \u201cFind More\u201d command repeats the transaction trace session with the same criterion as before. Or, the user can search again with new criterion. In either case, the auxiliary region  is updated with the new results, either in place of or in addition to, the previous results.","The auxiliary region  can be updated in real time as additional matching transactions are identified. Furthermore, a region  can inform the user of the progress of the search before it completes. Here, the user is informed that four transactions which exceed 1000 ms. in duration have been traced\/located so far, and the remaining time in the search is 53 seconds. Buttons in the region  allow the user to stop or restart the current search. The relative size of the auxiliary region  can expand, up to a certain point, as additional transactions are located. A scrolling mechanism can allow the user to view additional transactions when there is not sufficient space on the screen to display all results concurrently. The results can be displayed as entries or rows in a table, in one approach. A \u201cClear\u201d button allows the user to remove all of the old transaction instances from the list, that is, all traces from the previous recording session. Individual entries can be deleted by the user by selecting the checkbox next to the entry, then selecting the \u201cDelete\u201d button.","When the recording session is concluded, and no transaction is selected in the auxiliary region , the timing data which is located near the node of Login can be updated to reflect the current set of metrics. For example, the average duration of Login (1300 ms.) can be displayed. The average total durations of the associated subsystem nodes ,  and , and the inter-subsystem communication times, can also be displayed. If the user selects one or more of the transactions in the auxiliary region  by selecting the check boxes and then the \u201cView in map\u201d button, the triage map region  can be updated with the corresponding metrics. For example, if the first two entries are selected, the duration of 1150 ms. would be provided for the Login node  and corresponding metrics optionally provided for the other nodes.","Note that for some transactions, it is possible that fewer than all of the subsystems of the Business Transaction were invoked. This can be reflected by the highlighting only the invoked subsystems but not the other subsystems in triage map region , when the user selects that transaction instance from the auxiliary region  followed by \u201cView in map.\u201d For example, as depicted in , one of the transaction instances may invoke AuthenticationService but not AuthenticationEngine or CustRecordsSQL, in which case the nodes  and  are highlighted, but not the nodes  and , or the arrows  and .","FIG. E depicts a user interface to find matching transactions for the AuthenticationService subsystem in the context of a selected Business Transaction. As an alternative to finding transaction traces which are associated with a Business Transaction, it is possible to find transaction traces which are associated with one or more user-selected subsystems in the context of a selected Business Transaction. In this example, the user selects a front end view in the region  for the AuthenticateService subsystem in the UI . A front end view represents all the transactions originating in a front end subsystem. With this selection the nodes in the region  which are not associated with the selected subsystem are removed. Optionally, the nodes for the associated Business Transactions  and  can remain. Moreover, one or more additional subsystems which are dependencies of the AuthenticateService subsystem can be displayed. For example, another unknown component (socket)  is depicted. The AuthenticationService may occasionally call some backup system that isn't involved in any of the Business Transactions defined as part of the Trading Business Service. In this case, that backup subsystem would appear in the front end view but not in the Trading Business Service map.","Here, the user selects the icon  by pointing at it to call up a context menu (such as context menu  in ) and selects \u201cFind matching transactions\u201d to find matching transactions, resulting in the window  being displayed. In this example, the Login Business Transaction is selected so that matching transactions are considered which invoke AuthenticationService only in the Login Business Transaction. The threshold can be run in comparison to a total duration of a subsystem. The threshold is set at 1000 ms. again in this example. Thus, we can find transaction instances which meet a filter for front ends and Business Transactions as well as the previous example of finding transactions for a specified Business Transaction without regard to a front end. In other words, we can look for all Business Transactions of Login where the first subsystem was AuthenticationService. In this case, we return Login instances, but not standalone threads from other Business Transactions that require authentication using AuthenticationService. For example, we do not return transactions of Options Trading which can also call AuthenticationService. The auxiliary region  indicates that three transactions have been matched so far, and that they are from AgentA and AgentB with response times of 1150 ms., 1250 ms. and 1550 ms.","The above example could be extended in a case where three or more Business Transactions can invoke a subsystem. For example, the user could select the first and second Business Transactions but not the third as the filter criterion.","FIG. E depicts a user interface to find matching transactions for the AuthenticationService subsystem in the context of multiple Business Transactions. In contrast, to FIG. E, the user interface  allows the user to locate matching transactions for AuthenticateService across all associated Business Transactions. Here, the icons for Login and Options Trading are unselected so that, when the AuthenticateService icon  is selected, the window  indicates that the filter criterion does not specify a particular Business Transactions. Optionally, from a Business Transaction View, such as in FIG. E, the user could request matching transaction for a selected subsystem independent of Business Transaction (this might be the default if the Business Service was selected in the tree. We could then jump the user to a front end view for that subsystem such as in FIG. E before running the trace.",{"@attributes":{"id":"p-0172","num":"0171"},"figref":"FIG. 5F","b":["560","562"]},{"@attributes":{"id":"p-0173","num":"0172"},"figref":["FIG. 5G","FIG. 5C"],"b":["570","532","532","562","532","562"]},"In this example, two agents\/computing devices have reported a location for Login, each reporting two instances of Login. Specifically, AgentA at HostA detected two Login transaction instances and the average response time or duration was 1150 ms. (e.g., an average of one instance at 1100 ms. and another instance at 1200 ms.). Agent B at HostB detected two other Login transaction instances and the average response time or duration was 1450 ms. (e.g., an average of 1400 ms. for one instance and 1500 ms. for another instance). Optionally, auxiliary region  could display an entry for each instance of Login instead of aggregating the instances for each agent\/host. A host could be identified by a text name or by an Internet Protocol (IP) address or other network address. Both of these hosts represent computing devices that recorded the triggering request of the Login transaction; thus both are associated with AuthenticationService. But these numbers represent the metrics for the specific Business Transaction Component that defines the Business Transaction, which is a subset of the total activity measured for the AuthenticationService front end.","It is possible that software for implementing Login is installed on only one computing device. Or, software for implementing Login may be installed on multiple computing devices, but only one of them has invoked Login in the specified time period for which information is reported. This information is revealed in the auxiliary region . The reported metrics can be provided by the agent to a central manager which provides the UI, in one implementation.",{"@attributes":{"id":"p-0176","num":"0175"},"figref":["FIG. 5H","FIG. 5C"],"b":["580","532","504"]},"The health metrics can include graphs, tables, or other visual presentations which provide metrics such as average response time, responses per interval, concurrent invocations, errors per interval and stall count. The UI  could be launched as a new window, as a popup window over the UI , on or a separate display screen, for instance.","Nodes of the tree can be expanded to view each option, or collapsed to hide the options. \u201cBy Business Service\u201d and \u201cBy Front end\u201d are different portions of the map tree (different sub-trees), representing different objects (Business Transactions and front ends) that are used for grouping and mapping transactions through the applications. That is, a transaction can be categorized as matching a particular Business Transaction, or it can be categorized as having a particular subsystem as its front end (or both). We can map a Business Transaction and its dependencies (i.e., all the subsystems invoked by transactions matching the Business Transaction), or we can map a front end and its dependencies (i.e., all the subsystems invoked by transactions originating in that front end).","Selecting \u201cBy Business Service\u201d or \u201cBy Front end\u201d in the tree region  provides a search utility for finding a particular Business Service or Business Transaction, in the first case, or Front end or Back end Call, in the second case. Selecting a Business Service or Business Transaction in the tree yields a \u201cBusiness View\u201d of the Application Triage Map\u2014that is, a map of all the Business Transactions in the Business Service (with one of them highlighted if a Business Transaction is selected). Selecting a front end in the tree yields a \u201cFront end View\u201d of the Application Triage Map\u2014that is, a map of that front end and its dependencies. Selecting anything beneath the level of a Business Transaction or a front end yields metric information about the selected item or its child nodes.","Performance metrics can be collected for the Business Transaction (actually, the Business Transaction Component) or for the front end's overall health and its various back end calls. The Business Service node in the tree is a folder for grouping the associated Business Transactions (and mapping them all together); the Business Transaction nodes let us see the Business Transaction maps; the front end nodes let us see the front end maps; all the other nodes show us relevant performance data.","Thus, the \u201cBy Business Service\u201d element in the tree region  allows the user to view data from the perspective of the hierarchical arrangement of a Business Service and Business Transaction, for instance.","The \u201cBy Front end\u201d element in the tree region  allows the user to view data from the perspective of a front end subsystem. This is a different way to look at the same data as the \u201cBy Business Service\u201d view. For example, the nodes of the tree can include the different subsystems discussed previously. The node for ReportingService is expanded to indicate that Health Metrics can be accessed. This node could be expanded to provide sub-nodes such as average response time, concurrent invocations, errors per interval, responses per interval and stall count. The \u201cBack end calls\u201d node has been expanded to show sub-nodes for Web Services and its performance metrics. As mentioned, the circles identify alert levels (white for a normal level and dark for a danger level). This allows the user to quickly diagnose a problem.","In particular, the alerts \u201cbubble up\u201d in the tree, so that parent nodes show the worst-case alert status of any of their child nodes. So if ReportingService's Web Services back end call has a danger level alert, the \u201cBack end Calls\u201d node above it will also have a danger level alert, and so will the ReportingService node itself (The \u201cHealth\u201d nodes represent the health of the front end itself, while the node above that represents the full set of items\u2014front ends and back end calls\u2014for that application.) Actual alert thresholds can be defined for the individual metrics associated with the front end \u201chealth\u201d, the back end calls, and the Business Transaction Components. The rest can be summary alerts based on those (worst-case, \u201cbubble up\u201d alerts).",{"@attributes":{"id":"p-0184","num":"0183"},"figref":["FIG. 5I","FIG. 5G"],"b":["322","562","590","322"]},"For example, the region  can identify each instance of a component which is invoked at the subsystem as part of Login. In a simple example, only one instance of each component is depicted. In practice, multiple instances of each component can be depicted. As an example, the response times (total duration) of CM CM, CM, CMand CM are 1300 ms., 1150 ms., 800 ms., 200 ms. and 50 ms., respectively. Recall that CM denotes a class-method pair. Further, AgentA on HostA is associated with each component, and execution start times of each component are indicated. Net durations could also be provided, additionally or alternatively. The Details tab is now active and selected; it lists the method calls from the transaction trace that are associated with the AuthenticationService node  in the triage map.","Optionally, the components of a subject subsystem which call a dependent subsystem are not provided in the auxiliary region  when only the subject subsystem node is selected by the user. For example, when only subsystem node  is selected, CM CM, CMand CM can be listed in the auxiliary region  but not CMsince it calls CM in subsystem . In this approach, the calling components to the dependent subsystem (e.g., CMa) can be listed by itself in the auxiliary region when the user selects only the arrow . If the user then also selects the node , the additional components CM CM, CMand CM can be listed. This allows the user to explore the triage map with greater granularity.","The components (calling components) which are invoked by a subsystem and call another subsystem can also be visually distinguished (e.g., by color, font, icon, note, etc.) in the auxiliary display region  from components which are invoked by the subsystem and do not call another subsystem. For example, the calling component CMis distinguished by italics in .","The user can choose the Close button from any of the tabs to exit a \u201ctransaction-mapping mode\u201d and return the map to its standard appearance and behavior.","In another option, the information under one or more of the \u201cTransaction List,\u201d \u201cDetails\u201d and \u201cTrace View\u201d tabs can be provided concurrently in the user interface instead of using tabbed views.",{"@attributes":{"id":"p-0190","num":"0189"},"figref":["FIG. 5J","FIG. 5G"],"b":["328","562","600","328","562","7","8","9","10"]},"Optionally, as mentioned, the components of a subject subsystem which call a dependent subsystem are not provided in the auxiliary region  when only the subject subsystem node is selected by the user. For example, when only subsystem node  is selected, CM can be listed in the auxiliary region  but not CM, CM and CM since CM, CM and CM call subsystem . In this approach, the calling components to the dependent subsystem (e.g., CM, CM and CM) can be listed by themselves in the auxiliary region when the user selects only the arrow  and\/or the node . If the user then also selects the node , the additional component CM can be listed.","The components (calling components) which are invoked by a subsystem and call another subsystem can also be visually distinguished (e.g., by color, font, icon, note, etc.) in the auxiliary display region  from components which are invoked by the subsystem and do not call another subsystem. For example, the calling components are distinguished by italics in .",{"@attributes":{"id":"p-0193","num":"0192"},"figref":"FIG. 5K","b":["5","1","562","5","1","4","1","4","2","5","1"]},"In the auxiliary region  of the UI , a transaction trace  is provided based on component data from the agent associated with AuthenticationService, and a transaction trace  is provided based on component data from the agent associated with AuthenticationEngine. The transaction trace  includes graph portions , , ,  and  to represent CM, CM, CM, CMand CM, respectively. The transaction trace  includes graph portions , ,  and  to represent CM, CM, CM and CM, respectively.","The user can view the triage map region  and the transaction traces at the same time, in the same UI on one or more screens, while exploring correlations between the two. The user can select (e.g., using a pointing device) a transaction trace as a whole, or its graph regions  and -, to cause one or more corresponding nodes to be visually distinguished in the triage map region .","When the user selects the first transaction trace , the node  is visually distinguished from the node  and other nodes. And, when the user selects the second transaction trace , the node  is visually distinguished from the node  and other nodes. In another possible approach, when the user selects the first transaction trace , the node  and all dependent nodes (, ) and associated arrows (, ) are visually distinguished from other nodes and arrows. And, when the user selects the second transaction trace , the node  and all dependent nodes () and associated arrows () are visually distinguished from other nodes and arrows.",{"@attributes":{"id":"p-0197","num":"0196"},"figref":["FIG. 5L","FIG. 5K"],"b":["620","322","641","651","562","562","328","651","641"]},"Optionally, if the user only selects the node , only the components (e.g., CM, CM, CMand CM but not CM) in the transaction trace  which do not call another subsystem are visually distinguished. If the user only selects the arrow , only the component (e.g., CM) in the transaction trace  which calls another subsystem is visually distinguished. All components are visually distinguished if the user selects both the node  and the arrow . Similarly, if the user selected only node , then only CM in the transaction trace  would be visually distinguished. If the user selected arrow  and\/or node , only CM, CM and CM (but not CM) in trace  would be visually distinguished.","FIG. M depicts the user interface of  when a user selects a transaction trace. Here, in a UI , the user selects the transaction trace  (that is, the user selects the corresponding portion of the graph), as indicated by the cursor location, causing it to be visually distinguished from the transaction trace , as indicated by the heavy line. This results in the corresponding subsystem node  being highlighted with a heavier dashed line and thus visually distinguished from the node . The user can therefore quickly identify a subsystem, from among multiple subsystems in the triage map region , which is associated with a selected transaction trace. Alternatively, the user could select the transaction trace , causing it to be visually distinguished from the transaction trace . This results in the corresponding subsystem node  being highlighted and thus visually distinguished from the node .","In another example, the user selects an arrow which depicts a calling relationship between a subsystem and a back end (such as arrow  between subsystem  and back end . In response, one or more graph portions of a trace in the auxiliary region  are visually distinguished, such as graph portions CM (), CM () and CM () in the auxiliary region  of FIG. M, or graph portions - in the auxiliary region  of , discussed further below. These graph portions represent components which are invoked at the subsystem  to call the back end . The subsystem  and\/or back end  could also be highlighted based on this user selection. Or, the user can select a node which depicts a back end (such as back end ), in response to which one or more graph portions of a trace in the auxiliary region  are visually distinguished. These graph portions represent components which are invoked at the subsystem to  call the back end . The subsystem  and\/or arrow  could also be highlighted based on this user selection. See  for further details.","FIG. M depicts the user interface of  when a user selects a component in a transaction trace. In the user interface , auxiliary region , the user selects a single component CM, in response to which the associated subsystem node  is visually distinguished. The user could also select multiple components of a trace, but fewer than all components of the trace, in response to which the associated subsystem node or nodes are visually distinguished. This allows the user to understand the system with greater granularity.",{"@attributes":{"id":"p-0202","num":"0201"},"figref":["FIG. 5N","FIG. 5K"],"b":["322","657","658"]},"The time marker can be moved manually by the user, e.g., by dragging it, or automatically in a playback mode. In the playback mode, the auxiliary region  includes a VCR-style playback control button region , including buttons for jump to start (js), step back (sb), play\/pause (pp), stop (sp), step forward (sf), and jump to end (je). Instead of using the step back and step forward buttons, the user can click on the next (nx) or previous element (pe) while the playback is paused. An alternative is: \u201cstep back, play\/stop, step forward\u201d, where the assumption is that \u201cplay\u201d always starts from the first of the currently selected segments (or the first segment if none are selected). Stop is thus the same as pause, and the user can click on the first element to rewind or click on a later element to jump ahead.","By activating these controls, the time marker and the intersection point move, and corresponding portions of the map are highlighted. In one approach, each successive node in a Business Transaction is highlighted, based on the current position of the intersection point , while the previously-highlighted nodes remain highlighted. In another approach, only the nodes which are associated with the current position of the time marker are highlighted. The node  which identifies the Business Transaction (Login) could optionally remain highlighted through the playback.","For example, by selecting \u201cplay,\u201d the time marker can begin at t and move gradually from left to right at a fixed rate, with increasing time, or in steps. The user can have the ability to adjust the playback speed. Moreover, the user can adjust the time scale of the transaction traces for greater visibility into the smaller segments. The playback speed will be typically slower than the actual speed at which the data was recorded.","In one option, the \u201cskip ahead\u201d or \u201cskip back\u201d button allows the playback to proceed only in discrete increments, e.g., steps, which result in a change in the highlighted nodes and\/or arrows between nodes, so that the user can quickly progress through changes in the highlighted nodes of the triage map. For example, each time the user clicks the \u201cskip ahead\u201d button, the time marker  can jump to the next time point which results in a change in highlighting of the nodes. In this case, the time marker skips in increments in response to a user command for each increment. Similarly, each time the user clicks the \u201cskip back\u201d button, the time marker  can jump to the previous time point which results in a change in highlighting of the nodes. In another option, the \u201cskip ahead\u201d button is a toggle button selected once by the user, in response to which the playback proceeds in the same discrete increments, but without requiring the user to reselect the command for each increment. The time marker thus moves in increments to stop at selected time points which result in a change in the highlighting of the nodes of the subsystems and\/or arrows, without stopping at time points which do not result in a change in the highlighting of the nodes and\/or arrows. These selected time points can be identified, e.g., by dividing the graph into intervals based on each transition in the graph, identifying the one or more subsystems and\/or arrows, associated with each interval, and combining adjacent intervals which are associated with the same one or more subsystems and\/or arrows. The remaining time points are time points at which a change in highlighting occurs. Clicking the button a second time would cause the button to return to its normal raised state and cause the playback to resume its regular, segment-by-segment updates.","As an example of discrete increments which result in a change in the highlighted nodes and\/or arrows, the subsystem nodes and\/or arrows which are highlighted, and the corresponding times are: t (node ), t (arrow ), t. (node ), t (arrow ), t (node ), t (arrow ), t (node ), t (arrow ), t (node ), t. (arrow ), t (node ), and optionally t (node ) as an end point.","In another option, the time marker skips from component-to-component in the transaction trace, rather than moving across the trace evenly. Each skip may or may not cause a change in the triage map, but it would help the user see where the different components are in the trace and how many components are associated with the same subsystem. Also, the map could update to show the duration of the currently selected component, e.g., rather than the total time for the subsystem. For example, td is the time for the component CM in , discussed further below. As an example of discrete increments for component-to-component skipping, the subsystem nodes and\/or arrows which are highlighted, and the corresponding times are the same as the previous example, with the addition of: t (node ), t (node ), t. (node ), t (node ) and t. (node ).","In the skipping approaches, the time marker can be positioned at the left most portion, the center, or the rightmost portion, of each discrete time increment.",{"@attributes":{"id":"p-0210","num":"0209"},"figref":["FIG. 5O","FIG. 5N"],"b":["513","650","2","3","4","7","2","7","3","513","513"]},{"@attributes":{"id":"p-0211","num":"0210"},"figref":["FIG. 5P","FIG. 5N"],"b":["328","660","3","4","7","336","613"]},{"@attributes":{"id":"p-0212","num":"0211"},"figref":["FIG. 5Q","FIG. 5N"],"b":["613","670","4","5","8","336","613","328","336","336","613","336","8","9","10","641","642"]},{"@attributes":{"id":"p-0213","num":"0212"},"figref":["FIG. 5R","FIG. 5Q"],"b":["651","8","9","10","691","692","693"]},{"@attributes":{"id":"p-0214","num":"0213"},"figref":["FIG. 5S","FIG. 5R"],"b":["680","613","8","647","9","648","10","649","562","5","1","613","691","193"]},{"@attributes":{"id":"p-0215","num":"0214"},"figref":["FIG. 6","FIG. 1","FIG. 2C"],"b":["118","210"]},"At step , the data can be accessed for a specified time interval under analysis which can be set to a default such as 15 minutes or as specified by the user. In one approach, this step can involve the \u201cFind more\u201d command, discussed previously. The data can be accessed from a data store, for instance. Historical data (past days or months) could also be used, although gathering and storing large quantities of transaction trace data can be costly in terms of processing time and storage space. Also, it is possible to rely on ongoing transaction trace sampling, with the sampling set to a higher frequency.","Generally, three separate processing paths can be followed. In a first processing path, performance metrics such as response times and durations can be computed from the transaction traces\/call stacks at step . Step  determines alert levels, such as by comparing the performance metrics to respective thresholds. Alerts may be computed based on the overall performance metrics for the subsystems. Regarding thresholds for transaction trace durations, we could reuse the thresholds for the subsystem's \u201caverage response time\u201d alerts\u2014applying them to the corresponding durations measured in the transaction traces. These thresholds might be overly sensitive for use on a single transaction, resulting in many yellow and red alerts. In one approach, performance metrics and alerts are not directly dependent on, and can be computed independently from, the triage map structure. The performance metrics describe the performance of the Business Transaction Components, front end and back end calls as a whole\u2014that is, over all transactions observed over a particular time interval, typically every 15 seconds. This data is used in the triage map in live and historical modes.","Performance metrics can include average response time, concurrent invocations, errors per interval, responses per interval and stall count. Moreover, for a particular transaction instance, the transaction tracer can calculate the execution time and invocation duration for each Business Transaction, transaction and component based, e.g., on FIG. B and the associated discussion.","In a second processing path, two different sets of data are provided: one to specify the structure of the triage map, and one to map specific transaction traces to that map structure. These are used to provide an overlay of transaction trace information on the triage map. To provide these data sets, we identify Business Transactions and front end subsystems which were invoked in the time period, at step . Triage map data can be provided across all transactions. The data used to build the triage map is captured and stored on an ongoing basis (with data sampling), and each map can represent\u2014by default\u2014the data for the past three days, for instance, with live updates. Configuration settings can change this default time window, and the user can also specify a historical time range. In both cases, the information to build the map is retrieved from a data store.","The association of subsystems to a Business Transaction can be achieved using special map tracers that report back information about transactions that are occurring; if the transaction matches a Business Transaction Component, then that transaction is labeled with that Business Transaction Component name and all the lower-level components invoked during that transaction are associated with that Business Transaction Component (and thus its Business Transaction). Those lower-level components later get aggregated into \u201csubsystems\u201d based on certain rules.","A Business Transaction can be identified by looking for the selected Business Transaction Component or front end identifier\u2014as the initial segment of the thread. Once a subsystem identifier is found in the transaction trace, it can be concluded that the subsystem has been invoked. All the calls made from that point on in the transaction are then necessarily part of the same subsystem\u2014until the next recognized subsystem (front end or back end call) is invoked.","Moreover, within an individual transaction trace, the front end and back end-calls that appear in the map and the tree are associated with specific metric paths (identifiers) that are associated with a segment when that component is hit as part of a traced transaction.","In a third processing path, step  calculates health metrics in an additional set of data for the subsystems on the triage map. See also . These metrics are in contrast to performance metrics such as response time which are obtained from the transaction traces.","Step  includes receiving a user command. User commands can include selections and\/or entries in the various portions of the user interface, such as the tree region , main area  and auxiliary region  as described herein. Step  includes displaying, e.g., updating, the user interface with the relevant information for the time interval under analysis.","The foregoing detailed description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application, to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 2C","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4A"},"FIG. B depicts example transaction traces for sequences of components invoked in a transaction, based on one possible sequence of components of .","FIG. B depicts waiting periods in the example transaction traces of FIG. B.","FIG. B depicts a method for determining total durations, net durations, wait times and inter-subsystem communication times, for a sequence of dependent instrumented subsystems.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5A"},"FIG. B depicts the user interface of  with the addition of a hover box showing metrics for the Login Business Transaction .","FIG. B depicts the user interface of  with the addition of a hover box showing metrics for the AuthenticationService subsystem .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 5C","FIG. 5A"],"b":["532","304"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 5D","FIG. 5C"],"b":"532"},"FIG. E depicts a user interface to find matching transactions for the Login Business Transaction which is launched from the context menu  of the user interface of .","FIG. E depicts a user interface to find matching transactions for the AuthenticationService subsystem in the context of a selected Business Transaction.","FIG. E depicts a user interface to find matching transactions for the AuthenticationService subsystem in the context of multiple Business Transactions.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5F"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 5G","FIG. 5C"],"b":"532"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 5H","FIG. 5C"],"b":"532"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 5I","FIG. 5G"],"b":["322","562"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 5J","FIG. 5G"],"b":["328","562"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5K","b":["5","1"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 5L","FIG. 5K"]},"FIG. M depicts the user interface of  when a user selects a transaction trace.","FIG. M depicts the user interface of  when a user selects a component in a transaction trace.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 5N","FIG. 5K"],"b":"322"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 5O","FIG. 5N"],"b":"513"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 5P","FIG. 5K"],"b":"328"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5Q","FIG. 5K"],"b":"613"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 5R","FIG. 5Q"],"b":"651"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5S","b":["680","613","8","647","9","648","10","649","562","5","1"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
