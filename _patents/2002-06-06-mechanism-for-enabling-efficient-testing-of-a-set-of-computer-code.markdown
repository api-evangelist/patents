---
title: Mechanism for enabling efficient testing of a set of computer code
abstract: A mechanism is disclosed for enabling efficient testing of a set of computer code. Untested code portions within a body of code are determined, and testing priorities are assigned to untested code portions according to how frequently the untested code portions are likely to be invoked during normal operation. More frequently invoked untested code portions are ranked higher than less frequently invoked untested code portions. The prioritized data may be used by a testing team to determine which additional tests should be created for effective and efficient testing of the body of code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07039902&OS=07039902&RS=07039902
owner: Sun Microsystems, Inc.
number: 07039902
owner_city: Palo Alto
owner_country: US
publication_date: 20020606
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENT(S)","Background Information","Functional Overview","Sample Operation","Hardware Overview"],"p":["This invention relates generally to computer systems, and more particularly to a mechanism for enabling efficient testing of a set of computer code.","Computer source code is typically written using a high level computer language. Examples of high level languages include C++, JAVA, FORTRAN, etc. Once written, source code is converted into object or machine code, which can be executed by a computer. A computer program called a compiler program receives as input source code and generates as output object code which may be loaded into the computer memory and executed.","Often, the source code will contain \u201cbugs\u201d. Bugs are logical errors in the original source code that cause unexpected results during the execution of the object code. These unexpected results may cause the computer executing the object code to generate unintended output and erroneous data, or to terminate prematurely.","Before releasing any set of computer code, software manufacturers test their code rigorously. Ideally, every set of code should be 100% tested prior to release so that once released, the computer code will not experience any errors. From a practical standpoint, however, this is extremely difficult if not impossible. To do so would require more resources (both in terms of human resources and actual costs) than would be practicable to expend. As a result, most manufacturers settle for a compromise. So long as the testing of a set of code has reached a certain threshold (e.g. 85% of the code has been executed and tested), the code is deemed ready for release.","To determine whether a set of code has been sufficiently tested, manufacturers generally run tests on the code, and generate test coverage data based upon the tests. Basically, the coverage data specifies which lines of source code were executed during the tests, and what percentage of the lines of source code were actually executed and tested. Based upon the coverage data, the manufacturer determines whether the set of code has been sufficiently tested.","Currently, software tests locate untested portions of code, and subsequent tests are created to test some of these portions. However, current methods employ a \u201csmoke\u201d approach, whereby tests are created for randomly selected untested sets of code. This process is very inefficient, usually results in a small incremental increase in the total amount of code tested and is ineffective for debugging a body of code.","Because of the shortcomings of the current methods, there exists a need for an improved mechanism which enables computer code to be tested more efficiently.","It is observed that the current methodologies test untested portions of a body of code in an inefficient and ineffective manner. To overcome this problem, in one embodiment, the untested code portions within a body of code are determined, and testing priorities are assigned to at least some of the untested code portions. When assigning testing priorities, the untested code portions are ranked based upon how frequently the untested code portions are likely to be invoked during normal operation. More frequently invoked untested code portions are ranked higher than less frequently invoked untested code portions.","In one embodiment, when assigning testing priorities, a particular untested code portion is selected. It is then determined whether the particular untested code portion is part of a core portion of the body of code. In response to a determination that the particular untested code portion is part of a core portion of the body of code, the particular untested code portion is assigned a higher priority. In response to a determination that the particular untested code portion is not part of a core portion of the body of code, the particular untested code portion is assigned a lower priority.","In determining whether the particular untested code portion is part of a core portion of the body of code, the particular code portion is associated with an object class. It is then determined whether the object class is a core object class within the body of code.","In another aspect, when assigning testing priorities, a particular untested code portion is selected and associated with a method. An accessibility parameter for the method is determined, and a priority to the particular untested code portion is assigned based upon the accessibility parameter. A higher priority is assigned to the untested code portion if the accessibility parameter indicates that the method is a public method. A lower priority is assigned to the untested code portion if the accessibility parameter indicates that the method is a private method.","Prioritization of untested portions of code is advantageous over prior approaches because it finds the untested portions with the most potential impact in the body of code. By identifying, and hence enabling, a user to test portions with the most potential impact, maximum benefit is derived for each testing effort. Thus, testing time is used more efficiently.","Before describing the invention in detail, a short discussion of some background information will first be provided in order to facilitate a complete understanding of the invention.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","106","104","102","106","100","106","104","102","104","104","102","102","102","102","104","106"]},"In this representation, the higher up in the pyramid a set of code resides, the more basic the function, and the greater the effect it might have on the overall body of code. Therefore, if an error is fixed in the core portion  of the stack, higher coverage percentage may be reached more efficiently because the new tests developed for the higher priority object class may also fix errors in the implementation portion  and application  portion.","During quality assurance testing, the body of code embodied in the API stack is tested and analyzed using one or more tests. For example, the code may be tested using a code coverage analyzer. After a set of tests are run on a body of code, the code coverage analyzer generates information indicating which lines of source code were tested and which lines were not tested. Based on the code coverage information, additional tests for the untested portions may be created by a testing team to increase test coverage. However, using prior approaches, untested portions are selected randomly throughout the body of code for subsequent testing. Such an approach is costly, inefficient and only improves overall testing effectiveness in small increments.","With reference to , there is shown a functional block diagram of a sample system in which one embodiment of the present invention may be implemented. In the following discussion, for the sake of illustration, the invention will be described in the context of a Java-based environment. However, it should be noted that the invention is not so limited, but rather may be implemented in any system or any environment in which it is desirable to test untested sets of code.","As shown in , the sample system  comprises a set of computer code\/tests , a Java compiler , a Java virtual machine (\u201cJVM\u201d)  and a coverage data generator . In one embodiment, the code\/tests  take the form of Java source code, and represent the computer code that is to be tested and the tests that are to be run on the computer code.","The computer code\/tests , or source code, is compiled by the Java compiler  to derive a set of compiled code . It is the compiled code  that is actually executed by the JVM  during runtime. After the source code is compiled to derive the compiled code , the compiled code  is executed by the JVM  to implement the logic of the source code. After the code execution is complete, the coverage data generator  uses information obtained during the execution to determine which lines of source code were executed and which lines were not executed. Once generated, the coverage data  may be used to generate a report which may be used to determine whether the source code has been sufficiently tested.","An untested code prioritizer  thereafter processes the coverage data  to determine which code portions have not been tested. The prioritizer  selects an untested code portion and prioritizes the portion according to how frequently it is likely to be invoked during normal operation. First, the untested code portion is associated with an object class. Then, the prioritizer  determines whether the object class belongs in the core portion  of the API . If so, then the untested code portion is assigned a higher priority. If not, the untested portion is assigned a lower priority.","Further, the untested code portion is associated with a method. An accessibility parameter is determined for the method. For example, the accessibility parameters include public, private, protected and package visible. Based upon the accessibility parameter, a priority is assigned to the untested code portion. A higher priority is assigned to the untested code portion if the accessibility parameter indicates that the method is a public or protected method. If the accessibility parameter indicates that the method is a private or package visible method, then a lower priority is assigned to the untested code portion.","Further, it is determined whether the untested code portion is an entire method or a block within a method. A higher priority is assigned to the untested code portion if it is an entire method and a lower priority if it is a block within a method.","After the untested code portion is prioritized, the prioritizer selects another untested code portion and repeats the process. In one embodiment, this continues until all of the untested code portions have been prioritized to generate a set of prioritization data. Once generated, this data may be used by a testing team to determine which of the untested code portions should be tested next for effective and efficient testing of the body of code.","To overcome the shortcomings of current methodologies, one embodiment of the present invention prioritizes untested code according to its impact within the body of code.","According to one embodiment of the present invention, the untested portions from a body of code are sorted into priorities based upon their functional role within the body of code.  is a flow diagram illustrating a method for prioritizing untested code portions in accordance with one embodiment of the present invention. Initially, a code coverage analyzer generates information indicating what lines of source code have been tested and what lines have not been tested. Thereafter, in step , a code portion that is determined by coverage analysis to have not been tested is selected. The untested code portion is placed in a ranking based on how frequently the untested code portion is likely to be invoked during normal operation. In step , the untested code portion is associated with an object class. In step , it is determined in which of the portions (i.e., core portion , implementation portion  or application portion ) the object class belongs. The higher in the hierarchy the untested portion belongs, the higher priority the untested portion will be assigned. For example, if the untested portion belongs in the core portion , it is assigned a higher priority. If the untested portion belongs in the implementation portion  or application portion , it is assigned a lower priority.","In step , it is determined in which method the untested portion belongs. Thereafter, in step , the accessibility parameter (such as private, public, protected or package visible) of the method is determined. As explained further below, priority of the untested portion is based partially on the accessibility parameter of the method. For example, if the accessibility parameter is public, the untested portion will be assigned a higher priority. If the accessibility parameter is private, the untested portion will be assigned a lower priority.","In Java, the accessibility parameter determines what other methods and object classes may access a method. The four levels of accessibility are public, protected, private and package visible. A public method can be invoked by any method in any object class. A protected method can be invoked by any method in the object class in which it is defined or any subclasses of that object class. The most restrictive accessibility parameter is private. A private method can only be invoked by other methods in the class in which it is defined. This is used when the method provides behavior that is specific to the class. This level includes variables that contain information that if accessed by an outsider, could jeopardize the state of the object or the program in which it is running. Finally, a package visible method is effectively public to all other classes within the same package, but private to classes external to the package.","In one embodiment, in order to minimize the number of priority levels, the private and package visible accessibility parameters are grouped into the same category, and the public and protected accessibility parameters are grouped into the same category.","In step , it is determined whether the untested code portion is an entire method or a block within a method. If the untested portion is an entire method, it is assigned a higher priority. If the untested portion is a block within a method, it is assigned a lower priority. In one embodiment, an untested code portion is considered an entire method if the method is not invoked at all during execution. If the method is executed but the untested code portion is just not reached, then the untested code portion is considered a block within the method. This may occur, for example, when a method is invoked but a condition within the method is not reached. Based on the above parameters, a priority is assigned () to the untested code portion.","As a sample illustration, the untested code portion may be assigned one of the following eight priorities:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Priority","Untested Code Portion"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Core API classes and their public or protected methods"]},{"entry":["2","Blocks in the public or protected methods of Core API"]},{"entry":[{},"classes"]},{"entry":["3","Core API classes and their non-public methods"]},{"entry":["4","Blocks in the non-public methods of Core API classes"]},{"entry":["5","Non-core API classes and their public or protected methods"]},{"entry":["6","Blocks in the public or protected methods of non-core API"]},{"entry":[{},"classes"]},{"entry":["7","Non-core API classes and their non-public methods"]},{"entry":["8","Blocks in the non-public methods of non-core APT classes"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"As shown in the above table, the prioritizer  assigns the highest priority to an untested code portion if it is located in the core portion , the accessibility parameter is public or protected, and the entire method has not been tested. Such a code portion has the most potential impact on the overall body of code. The prioritizer  assigns a lower priority (priority 2) to an untested portion if it is located in the core portion , the accessibility parameter is public or protected, and the untested portion is just a block within a method.","The prioritizer  assigns lower priorities (priorities 3 and 4) to the untested portion if the untested portion is in a method that is non-public (i.e., private or package visible). A public method can be invoked by any method in any object class, and a private method can only be invoked by other methods in the class in which it is defined. Therefore, a non-public method will generally be invoked less frequently in normal operation. Hence, it is given a lower priority.","In one embodiment, a priority 3 is assigned to an untested portion if it is located in the core portion , the accessibility parameter is private or package visible, and if the code portion represents an entire method. A priority 4 is assigned if the untested code portion is located in the core portion , the accessibility parameter is private or package visible, and the code portion is just a block within a method.","The prioritizer  assigns lower priorities (priorities 5, 6, 7 and 8) to untested portions which are not located in the core portion , because untested portions in the implementation portion  and application portion  have less potential impact on the overall body of code than untested portions in the core portion . The prioritizer  assigns priority 5 to an untested code portion if the code portion is not in the core portion , if the accessibility parameter is public or protected, and if the entire method has not been tested. The prioritizer  assigns an even lower priority (priority 6) to an untested portion if the code portion is not in the core portion , if the accessibility parameter is public or protected, and if the code portion is just a block within a method.","Finally, the prioritizer  assigns the lowest priorities (priority 7 and 8) to an untested portion which is not located in the core portion  and which has an accessibility parameter that is non-public. In priority 7, the entire method has not been tested, and in priority 8, only a block within the method has not been tested. These untested portions are assigned the lowest priorities because they have the least overall impact on the body of code.","In one embodiment, as illustrated in , a loop continues until all untested portions have been prioritized. Given this prioritized information, a testing team is able to determine which tests to create to derive the greatest benefit for each testing effort. A testing team can develop new tests for untested portions which are assigned higher priorities by the untested code prioritizer . As a result, these tests may also test many untested portions which are assigned lower priorities. Therefore, a higher coverage percentage is reached, and overall testing efficiency and effectiveness is greatly improved.","In one embodiment, the various components , , ,  and  of the present invention are implemented as sets of instructions executable by one or more processors. The invention may be implemented as part of an object oriented programming system, including but not limited to the JAVA\u2122 programming system manufactured by Sun Microsystems, Inc. of Palo Alto, Calif.  shows a hardware block diagram of a computer system  in which an embodiment of the invention may be implemented. Computer system  includes a bus  or other communication mechanism for communicating information, and a processor  coupled with bus  for processing information. Computer system  also includes a main memory , such as a random access memory (RAM) or other dynamic storage device, coupled to bus  for storing information and instructions to be executed by processor . Main memory  may also be further used to store temporary variables or other intermediate information during execution of instructions by processor . Computer system  further includes a read only memory (ROM)  or other static storage device coupled to bus  for storing static information and instructions for processor . A storage device , such as a magnetic disk or optical disk, is provided and coupled to bus  for storing information and instructions.","Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","According to one embodiment, the functionality of the present invention is provided by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another computer-readable medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.","The term \u201ccomputer-readable medium\u201d as used herein refers to any medium that participates in providing instructions to processor  for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device . Volatile media includes dynamic memory, such as main memory . Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or electromagnetic waves, such as those generated during radio-wave, infra-red, and optical data communications.","Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.","Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer system , are exemplary forms of carrier waves transporting the information.","Computer system  can send messages and receive data, including program code, through the network(s), network link  and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface . The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution. In this manner, computer system  may obtain application code in the form of a carrier wave.","At this point, it should be noted that although the invention has been described with reference to a specific embodiment, it should not be construed to be so limited. Various modifications may be made by those of ordinary skill in the art with the benefit of this disclosure without departing from the spirit of the invention. Thus, the invention should not be limited by the specific embodiments used to illustrate it but only by the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
