---
title: Resumable upload for hosted storage systems
abstract: An initial portion of an object is received at a hosted storage system. The initial portion of the object is stored at the hosted storage system. After receiving the initial portion of the object, a timer is started. Prior to the expiration of the timer, whether an additional portion of the object is received at the hosted storage system is determined. The initial portion is deleted upon the expiration of the timer if the additional portion is not received. The timer is reset if the additional portion is received.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08375124&OS=08375124&RS=08375124
owner: Google Inc.
number: 08375124
owner_city: Mountain View
owner_country: US
publication_date: 20111006
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This specification relates to hosted storage systems.","A hosted storage system may provide a remote user the ability to store data files without acquiring additional local storage resources. One concern for uploading data files to hosted storage systems is an unexpected interruption during the uploading process.","In one aspect, an initial portion of an object is received at a hosted storage system. The initial portion of the object is stored at the hosted storage system. After receiving the initial portion of the object, a timer is started. Prior to the expiration of the timer, whether an additional portion of the object is received at the hosted storage system is determined. The initial portion is deleted upon the expiration of the timer if the additional portion is not received. The timer is reset if the additional portion is received.","Implementations may include one or more of the following features. The additional portion of the object may be received at the hosted storage system, and whether a size of the received, additional portion exceeds a threshold size is determined. The initial portion is deleted upon expiration of the timer if the size of the additional portion does not exceed the threshold. Resetting the timer may include resetting the timer if the size of the additional portion exceeds the threshold. The threshold size may include a percentage of a size of the object's size. The threshold size may include a defined number of bytes.","The additional portion of the object may be received at the hosted storage system, and whether the received, additional portion completes the object is determined. Resetting the timer can include resetting the timer if the received, additional portion does not complete the object. Receiving the initial portion of the object may include receiving the initial portion of the object as part of an interrupted upload of the object.","Receiving the initial portion of the object may include receiving, at the hosted storage system and from a client system, an initial upload request that does not include the object. In response to receiving the initial upload request, an object identifier may be sent to the client system. A revised upload request is received at the hosted storage system and from the client system, where the revised upload request may include the object identifier and the object, wherein the revised upload request is interrupted such that only the initial portion of the object is received by the hosted storage system. A resumed upload request is received at the hosted storage system and from the client system, where the resumed upload request may include the object identifier. In response to receiving the resumed upload request, a range of bytes that correspond to the initial portion of the object is determined based on the object identifier. The range of bytes is sent from the hosted storage system and to the client system. The additional portion of the object from the client system starting after the range of bytes is received at the hosted storage system.","In another aspect, a hosted storage system includes a service interface configured to receive an initial portion of an object, at least one data store configured to store the initial portion of the object, and a garbage collector configured to start a timer after the initial portion of the object is received, to determine whether an additional portion of the object is received at the hosted storage system prior to the expiration of the timer, to delete the initial portion upon the expiration of the timer if the additional portion is not received, and to reset the timer if the additional portion is received.","Implementations may include one or more of the following features. The service interface may be configured to receive the additional portion of the object at the hosted storage system. The garbage collector may be configured to determine whether a size of the received, additional portion exceeds a threshold size, to delete the initial portion upon expiration of the timer if the size of the additional portion does not exceed the threshold, and to reset the timer if the additional portion of the object is received and the size of the received, additional portion exceeds the threshold. The threshold size may be a percentage of a size of the object's size. The threshold size may be a defined number of bytes.","The service interface may be configured to receive the additional portion of the object at the hosted storage system. The garbage collector may be configured to determine whether the received, additional portion completes the object, and to reset the timer if the additional portion of the object is received and the received, additional portion does not complete the object. The initial portion of the object may be received as part of an interrupted upload of the object.","The service interface may be configured to receive the initial portion of the object, where an initial upload request that does not include the object is received from a client system. In response to receiving the initial upload request, an object identifier is sent to the client system, and a revised upload request is received from the client system, where the revised upload request may include the object identifier and the object, wherein the revised upload request may be interrupted such that only the initial portion of the object is received by the hosted storage system. The service interface is configured to receive a resumed upload request from the client system, where the resumed upload request may include the object identifier. In response to receiving the resumed upload request, a range of bytes that correspond to the initial portion of the object may be determined based on the object identifier. The range of bytes may be sent to the client system. The additional portion of the object starting after the range of bytes may be received form the client system.","In another aspect, a computer readable medium having stored instructions that, when executed by one or more processors, causes the one or more processors to perform the operations of receiving and storing an initial portion of an object at a hosted storage system. After receiving the initial portion of the object, a timer is started. Prior to the expiration of the timer, whether an additional portion of the object is received at the hosted storage system is determined. If the additional portion is not received, the initial portion is deleted upon the expiration of the timer. If the additional portion is received, the timer is reset.","Implementations may include one or more of the following features. The additional portion of the object may be received at the hosted storage system, and whether a size of the received, additional portion exceeds a threshold size is determined. The initial portion is deleted upon expiration of the timer if the size of the additional portion does not exceed the threshold. Resetting the timer may include resetting the timer if the size of the additional portion exceeds the threshold. The threshold size may include a percentage of a size of the object's size. The threshold size may include a defined number of bytes.","The additional portion of the object may be received at the hosted storage system, and whether the received, additional portion completes the object is determined. Resetting the timer can include resetting the timer if the received, additional portion does not complete the object. Receiving the initial portion of the object may include receiving the initial portion of the object as part of an interrupted upload of the object.","Receiving the initial portion of the object may include receiving, at the hosted storage system and from a client system, an initial upload request that does not include the object. In response to receiving the initial upload request, an object identifier may be sent to the client system. A revised upload request is received at the hosted storage system and from the client system, where the revised upload request may include the object identifier and the object, wherein the revised upload request is interrupted such that only the initial portion of the object is received by the hosted storage system. A resumed upload request is received at the hosted storage system and from the client system, where the resumed upload request may include the object identifier. In response to receiving the resumed upload request, a range of bytes that correspond to the initial portion of the object is determined based on the object identifier. The range of bytes is sent from the hosted storage system and to the client system. The additional portion of the object from the client system starting after the range of bytes is received at the hosted storage system.","The details of one or more implementations of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.","Like reference numbers and designations in the various drawings indicate like elements.","In general, a client system is coupled to a hosted storage service system in which user-provided data upload processes can be resumed after interruptions have occurred. For example, in one implementation, the client system initializes an upload request for a data object to be stored at the hosted storage service. The hosted storage system keeps a timer on the data object upload, where the hosted storage system starts and resets the timer each time a portion of the data object has been received. In the event of an interruption, the client system submits a separate request for a resumable upload for the same data object. If the timer for the data object at the hosted storage service has not expired, the hosted storage service can allow the client system to resume uploading the same data object without having to restart the upload process. If the timer expires before an additional portion of the object has been received (that is, before the user has resumed the upload and sent an additional portion of the object), the portion of the object already received is deleted.","Implementations may include one or more of the following advantages. The storage space at the hosted storage service can be efficiently utilized and controlled if the hosted storage service does not need to allocate new storage space each time a data object upload process is interrupted and re-initiated. The upload of a data object with a large size (e.g. several Terabytes) can be resumed upon one or more interruptions with one unique object identifier, where the upload does not need to restart from the beginning each time an interruption has occurred. Data management time and resources on the client system can be reduced, if data object upload process can be resumed upon unexpected interruptions. In some cases, starting or resetting the timer upon a partial completion of the upload may enable a simple and uniform standard for monitoring upload processes regardless of the size of the data files to be uploaded. As one example, the hosted storage service system does not need to adjust the length of the timer associated with a data file according to the size of the file. For instance, if instead the timer was started when the object began uploading, then whether or not the timer expired before the uploading was complete would depend on the size of the object and the upload speed. Thus, in that case, large objects or ones being uploaded across slow networks might not finish uploading before the timer expires and, accordingly, become deleted during the uploading.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","102","120","102"]},"The system  can provide scalable stores for storing data objects. The client device  can upload data objects to the hosted storage service  and resume the uploading process of the data objects if the uploading process has been interrupted by an unexpected event. For example, the unexpected event can be a component, system, or connection failure from the client device , the hosted storage service , or a network  that provides a connection between the client device  and the hosted storage service . The hosted storage service  can use a simple and consistent application programming interface, or API, which can allow arbitrary quantities of structured or unstructured data to be kept private or shared between individuals, organizations, or with the world at large. The client device  can store data in the hosted storage service  for mutual business reasons (e.g., submission of work product ordered by the owner of the hosted storage service ), or for use in data processing by other services (e.g., images uploaded are used to automatically and dynamically create a photo gallery web page).","The client device  can be implemented using a computing device, such as the computing device  or the mobile device  described with respect to . The client device  can communicate with the hosted storage service  via the network , such as the Internet. The client device  can communicate across the network  using communication protocols such as, for example, one or more of Transmission Control Protocol\/Internet Protocol (TCP\/IP), Hypertext Transfer Protocol (HTTP), Secure Shell Remote Protocol (SSH). While only a single client device  is shown, there can be multiple client devices communicating across the network  with the hosted storage service  and\/or other services and devices.","The hosted storage service  can be implemented such that client applications such as a client application  can store, retrieve, or otherwise manipulate data objects, such as objects , , and , in the hosted storage service . The hosted storage service  can be implemented by one or more server devices, which can be implemented using a computing device, such as the computing device  or mobile device  described with respect to . For example, the hosted storage service  can be implemented by multiple server devices operating in the same, or different, data centers.","The hosted storage service  generally includes an interface frontend , an interface backend , a storage backend , metadata  for objects stored in the storage backend , and a garbage collector . In general, the interface frontend  may receive requests from and send responses to the client device . For instance, the hosted storage service  can be implemented as a Web Service with a corresponding set of Web Service Application Programming Interfaces (APIs). The Web Service APIs may be implemented, for example, as a Representational State Transfer (REST)-based HTTP interface or a Simple Object Access Protocol (SOAP)-based interface.","An interface frontend  can receive messages from the client  and parse the request into a format usable by the hosted storage service , such as a remote procedure call (RPC) to an interface backend . The interface frontend  writes responses generated by the hosted storage service  for transmission to the client . In some implementations, multiple interface frontends  are implemented, for example to support multiple access protocols.","The interface frontend  can include a graphical front end, for example to display on a web browser for data access. The interface frontend  can include a sub-system to enable managed uploads and downloads of large files (e.g., for functionality such as pause, resume, and recover from time-out). The interface frontend  can monitor load information and update logs, for example to track and protect against denial of service (DOS) attacks.","As described above, the Web Service API may be a REST-based HTTP interface. In a REST-based interface, a data object is accessed as a resource, uniquely named using a URI, and the client application  and service  exchange representations of resource state using a defined set of operations. For example, requested actions can be represented as verbs, such as by HTTP GET, PUT, POST, HEAD, and DELETE verbs. The GET verb may be used to retrieve an object, while the HEAD verb may be used to retrieve information about an object without retrieving the object itself. The DELETE verb may be used to delete an object from the hosted storage service . The PUT and POST verbs may be used to upload an object to the service . PUT requests can come from the client  and contain authentication and authorization credentials and object metadata in a header, such as an HTTP header. In some implementations, the PUT requests can contain instructions for resuming previously-interrupted upload processes. POST requests can be received when a client  wants to upload from a web browser form. The form POST upload protocol for the hosted storage service  can involve multiple required form fields to provide authentication, authorization and object metadata. POST requests may alternatively, or additionally, be used to initiate or resume resumable uploads.","In general, objects stored in the hosted storage service  can be referenced by object identifiers. The hosted storage service  can define namespaces to which a valid object identifier must conform. For example, the namespace may require that object identifiers be a sequence of Unicode characters whose UTF-8 encoding is at most 1024 bytes long. As another example, the namespace may require that object identifiers be globally unique identifiers (GUIDs), which may be 128-bit integers.","Objects can be stored in hosted storage service  in buckets. In some examples, each bucket is uniquely named in the hosted storage service , each object is uniquely named in a bucket, and every bucket and object combination is unique. Objects may be uniquely identified by a URI that includes the bucket name and the object name, and identifies the hosted storage service . For example, an object named \u201clong\/song.mp3\u201d in a bucket named \u201cmusic\u201d could be specified using a URI pattern such as http:\/\/s.hostedstoragesystem.com\/music\/long\/song.mp3 or http:\/\/music.s.hostedstoragesystem.com\/long\/song.mp3. Alternatively, the user of the client  can create a bucket named www.music.org, publish a CNAME alias redirecting that to http:\/\/music.s.hostedstoragesystem.com, and address the object as http:\/\/www.music.org\/long\/song.mp3. In some examples, buckets do not nest.","The interface backend  can process upload requests including resumable upload requests, can handle request authentication and authorization, can manage data and metadata, and can track activities such as for billing. The interface backend  can provide functionality for independent frontend\/backend scaling for resource utilization and responsiveness under localized heavy loads. Data management can be encapsulated in the interface backend  while communication serving can be encapsulated in the interface frontend . The interface backend  can isolate security mechanisms from the client-facing interface frontend .","The interface backend  can expose an interface usable by both the interface frontend  and other systems. In some examples, some features of the interface backend  are accessible only by an interface frontend (not shown) used by the owners of the hosted storage service  (internal users). Such features can include those needed for administrative tasks (e.g., resolving an object reference to a low level disk address.) The interface backend  can handle request authentication (e.g., ensuring a user's credentials are valid) and authorization (e.g., verifying that a requested operation is permitted.) The interface backend can also provide encryption and decryption services to prevent unauthorized access to data, even by internal users.","The interface backend  can manage metadata  associated with data objects , , and , for example in a structured data format such as a database (e.g., MySQL). In some implementations, user-specified names labeling the buckets can be completely defined within the metadata , and object metadata  can map a resource name to one or more datastores , , or storing the resource. The metadata  can also include bucket and object creation times, object sizes, hashes, access control lists, timers , and byte counters  for both buckets and objects. Each of the timers  can be associated with a data object, such as one of the objects , , or , and can indicate the amount of time remaining until the data object associated with the particular timer is deleted from the storage backend . One or more components in the hosted storage service  can control the timer reset, including the garbage collector . In some implementations, the garbage collector  can set a timer associated with a data object when the upload process has been initiated for the data object. In some implementations, the garbage collector  can reset the timer associated with a data object when a portion of the data object has been received and stored at the storage backend . In the event of an interruption, the garbage collector  can start the counting down of the timer, and can reset the timer upon the hosted storage service  receiving more of the data object, or can remove the data object upon the timer expiring. Each of the byte counters  can be a data structure associated with a data object, and can be referenced to indicate the portion of the corresponding data object that has been uploaded. In the event of an interruption, the byte counter  can be referenced later in a resumed upload to determine the portion of the data object that has been uploaded prior to the interruption. The interface backend  can log activity and track storage consumption to support accounting for billing and chargebacks. In some examples, this includes quota monitoring in each dimension in which customers are charged (e.g., reads, writes, network transfers, total storage in use).","A garbage collector  can determine whether to delete or remove a data object from the hosted storage service . In some implementations, the garbage collector  can determine whether to delete the received portion of a data object from the hosted storage service  during a resumed upload process. The garbage collector  can start a timer after an initial portion of a data object is received at the hosted storage system . Prior to the expiration of the timer, the garbage collector  can determine whether an additional portion of the data object is received at the hosted storage system . If the additional portion has not been received, the garbage collector  can delete the initial portion of the data object upon the expiration of the timer. If the additional portion has been received, the garbage collector  can reset the timer. In the event that the upload is interrupted and the garbage collector  determines whether the upload is resumed and more of the data object is received at the hosted storage system . If more of the object has not been received, the garbage collector  can delete the accumulated portion of the data object upon the expiration of the timer. If more of the object has been received prior to the timer expiring, the garbage collector  can reset the timer. In the event that the whole data object is received, the garbage collector  can stop the timer associated with the data object.","The storage backend  can contain multiple datastores -. Although three datastores  are shown, more or fewer are possible. Each of the datastores -can store data objects -in a particular format. For example, data store can store a data object as a Binary Large Object (BLOB), data store can store a data object in a distributed file system (e.g., Network File System), and data store can store a data object in a structured data format such as a database (e.g., MySQL).",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":["200","200","106","108","122","100","200"]},"An upload request is received by the interface frontend  from the client application  to upload a data object (). In some implementations, the data object may have a determined object size at the time of the request. In some other implementations, the data object may be a streaming data object such as voice or video, and may not have a determined object size at the time of the request. The request headers can include a HTTP PUT or POST request, an authentication credential that authenticates the principal (entity) making the request, a data object, an object type, an object identifier, an object size, an indication that this request is for a resumable upload, and a target for the object consisting of a bucket and data object name. The interface frontend  can make a RPC to the interface backend  including the request headers.","The interface backend  determines whether the upload request from the client application  is a request to resume a previously interrupted upload (). In one implementation, the interface backend  can parse the header of an HTTP POST or PUT request to identify attributes related to resumable uploads. As one example, an HTTP POST request can include a customized attribute {name: value} pair such as {Resumable: Start} to indicate that this request is a new upload request, and that the client application  supports resumable uploads. For example, the interface backend  can receive a request for a new upload as:","POST\/music.mp3 HTTP\/1.1","Host: example.commondatastorage.googleapis.com","Date: Fri, 01 Oct 2010 21:56:18 GMT","Content-Length: 0","Content-Type: audio\/mpeg","x-goog-resumable: start","x-goog-api-version: 2","Authorization: OAuth 1\/zVNpoQNsOSxZKqOZgckhpQ","where the POST verb and the {name: value} pair {x-goog-resumable: start} along with other parameters indicate that this is a request for a new object upload, where a resumable upload is supported by the client application .","As another example, an HTTP PUT request can include an object identifier of an existing data object as an indication that this request is for resumable upload of a previously interrupted upload process (described further below).","In the event that the interface backend  determines that the request is not for resuming a previously interrupted upload and does not include a data object, the interface backend  creates and sends a RPC which includes an object identifier to the interface frontend . The interface frontend  then sends a response which includes the object identifier to the client device  (). For instance, the interface frontend  may send a  Created status message, which indicates to the client device  that a new object identifier has been created (and the status message may include the object identifier). In some implementations, the object identifier can be a sequence of Unicode characters whose UTF-8 encoding is at most 1024 bytes long. In some other implementations, the object identifier can be a globally unique identifier (GUIDs), which may be 128-bit integers. For example, the interface frontend  may send a HTTP CREATED message to the client device  as:","HTTP\/1.1 201 Created","Location: https:\/\/example.commondatastorage.googleapiscom\/music.mp3? upload_id=tvA0ExBntDa . . . gAAEnB2Uowrot","Date: Fri, 01 Oct 2010 21:56:18 GMT","Content-Length: 0","Content-Type: audio\/mpeg","where a new object identifier, as indicated as \u201cupload_id=tvA0ExBntDa . . . gAAEnB2Uowrot,\u201d is included in the \u201cLocation\u201d attribute of the message. The client application  can then associate the object identifier with the object during this and future uploading processes.","The interface backend  then creates metadata  associated with the data object, including initializing a byte counter  for the data object to zero (). In some implementations, the byte counter  can be a data structure associated with the data object, and can be referenced to indicate the portion of a data object that has been uploaded. The interface backend  can allocate a segment of storage space at the storage backend . If the request includes information about the object type, the interface backend  can allocate the segment of storage space in the datastore  associated with the object type.","A revised upload request is received by the interface frontend  from the client application  to upload the data object (). In the revised upload request, the request headers can include a HTTP PUT verb, the object identifier, the data object, the object size, and the authentication credentials. The interface frontend  can make a RPC to the interface backend  including the revised request headers. For example, the interface frontend  can receive a revised upload request for a new object upload as:","PUT\/music.mp3?upload_id=tvA0ExBntDa . . . gAAEnB2Uowrot","HTTP\/1.1","Host: example.commondatastorage.googleapis.com","Date: Fri, 01 Oct 2010 21:56:18 GMT","Content-Length: 7351375","x-goog-api-version: 2","Authorization: OAuth 1\/zVNpoQNsOSxZKqOZgckhpQ","where the unique object identifier associated with the new object is included in the HTTP PUT request. The content length of the object is also included in the request, where the interface backend  can store the content length information in the metadata  associated with the object.","Upon receiving the revised upload request, the interface backend  receives the data object from the client device  starting from the current value of the byte counter (). Here, since the request is for uploading a new data object, the interface backend  receives the initial portion of the data object. The interface backend  can then store the initial portion of the object at the storage backend . The garbage collector  can update the metadata  associated with the object including the timer  and the byte counter . The interface backend  can continue to receive and store the additional portions of the data object at the storage backend , and the garbage collector  can update the metadata  accordingly until the upload is complete or interrupted, or until the timer  associated with the data object expires.","In the event that the interface backend  determines that the request is for resuming a previously interrupted upload (), the interface backend  retrieves the object identifier from the request, and the interface backend  determines whether the resumed object upload has expired (). For example, the interface frontend  can receive a resume request from the client application  as:","PUT\/music.mp3?upload_id=tvA0ExBntDa . . . gAAEnB2Uowrot HTTP\/1.1","Host: example.commondatastorage.googleapis.com","Date: Fri, 01 Oct 2010 22:25:53 GMT","Content-Range: bytes*\/7351375","Content-Length: 0","x-goog-api-version: 2","Authorization: OAuth 1\/zVNpoQNsOSxZKqOZgckhpQ","where the object identifier is included in the \u201cupload_id\u201d of the request. The request also includes a \u201cContent-Range\u201d attribute, where the length of the object is specified, but the sent portion of the object is indicated as \u201c*\u201d to query the interface backend  on the portion of the object already uploaded prior to the interruption. The interface backend  can then associate the object identifier in the request with the object in the storage backend , and determine the portion of the object already uploaded.","In some implementations, the garbage collector  can delete the accumulated portion of the object uploaded in the storage backend  upon the timer  associated with the object expiring. The interface backend  can then determine whether the resumed object upload has expired by checking whether the object is still stored at the storage backend .","In the event that the interface backend  determines that the resumed object upload has expired, the interface backend  notifies the interface frontend . The interface frontend  can then send a response to the client device  (). In one implementation, the response is a  Not Found status message, which indicates to the client device  that the resumed object upload has expired and the data object and the corresponding metadata  have been deleted.","In the event that the garbage collector  determines that the resumed object upload has not expired, the interface backend  can make a RPC to notify the interface frontend , including information on the range of bytes which has been uploaded and stored at the storage background . In some implementations, the interface backend  can retrieve information on the range of bytes received from the byte counter  of the metadata  associated with the data object. The interface frontend  can then send a response including the byte counter  associated with the data object to the client device  (). In one implementation, the response is a  Resume Incomplete status message, which indicates to the client device  that the resumed object upload has not expired and the data object has not been completely uploaded and stored at the storage backend . The status message may include the range of bytes that have been received. For example, the interface frontend  can send a response for the resumed upload as:","HTTP\/1.1 308 Resume Incomplete","Range: bytes=0-2359295","Date: Fri, 01 Oct 2010 22:25:53 GMT","Content-Length: 0","Content-Type: audio\/mpeg","where the attribute \u201cRange\u201d specifies the range of bytes already uploaded and stored at the storage backend  prior to the resumed upload request. In some implementations, the information on the range of bytes already uploaded can be retrieved from the byte counter  associated with the object.","A revised upload request is then received by the interface frontend  from the client application  to resume the upload of the data object (). In the revised upload request, the request headers can include a HTTP PUT verb, the object identifier, the data object, the object size, the authentication credentials, and the range of the data object to be uploaded in the resumed upload process. In one implementation, the range of the data object to be uploaded can be the lowest and highest byte-indices of the data object which have not been uploaded to the storage backend  upon the resumed upload request. The interface frontend  can make a RPC that includes the revised request headers to the interface backend . For example, the interface frontend  can receive a revised upload request for a resumed upload as:","PUT\/music.mp3?upload_id=tvA0ExBntDa . . . gAAEnB2Uowrot HTTP\/1.1","Host: example.commondatastorage.googleapis.com","Date: Fri, 01 Oct 2010 22:25:53 GMT","Content-Range: bytes 2359296-7351374\/7351375","Content-Length: 4992079","x-goog-api-version: 2","Authorization: OAuth 1\/zVNpoQNsOSxZKqOZgckhpQ","where the object identifier is included in the request, so the interface backend  can associate the request with the object. The attribute \u201cContent-Range\u201d indicates the portion of object to be uploaded to the storage backend  to complete the object, where the starting value reflects the byte counter  associated with the object.","Upon receiving the revised upload request, the interface backend  receives the data object from the client device  starting from the current value of the byte counter  (). Since the request is for resuming the upload of an existing data object, the interface backend  receives the portion of the data object which has been previously interrupted. The interface backend  then can store the previously interrupted portion of the object at the storage backend . The garbage collector  can update metadata  associated with the object including the timer  and the byte counter . The interface backend  can continue to receive and store the additional portions of the data object at the storage backend , and the garbage collector  can update the metadata  accordingly until the upload is complete or interrupted, or until the timer  associated with the data object has expired.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 3","b":["300","300","108","122","100","300"]},"The interface backend  receives an initial portion of an object, and stores the initial portion at the storage backend  (). In some implementations, the initial portion is associated with a new object where the corresponding byte counter  is zero. The initial portion can include the first byte to another byte earlier than the final byte of the object, where the remaining bytes of the object are not uploaded due to an unexpected interruption. For example, the unexpected interruption can be a component, system, or connection failure from the client device, the hosted storage service, or a network that provides a connection between the client device and the hosted storage service.","Upon the interface backend  receiving the initial portion of the object and storing the initial portion at the storage backend , the garbage collector  starts a timer  associated with the object (). In some implementations, the timer  is included in the metadata , where the timer  identifies the remaining time prior to the garbage collector  deleting the object. The expiration time of the timer  can be configured automatically or manually by an administrator of the hosted storage service system .","Prior to the expiration of the timer , the interface backend  determines whether an additional portion of the object is received at the interface backend  (). In the event that the interface backend  has not received any additional portion of the object, the garbage collector  continues to determine whether the timer  has expired (). In the event that the garbage collector  determines that the timer  has expired () prior to receiving the additional portion of the object (), the garbage collector  deletes the initial portion of the object at the storage backend  and deletes the metadata  associated with the object ().","In the event that the interface backend  has received and stored an additional portion of the object, the garbage collector  determines whether the object upload is complete (). In the event that the garbage collector  determines that the object upload is not complete, the garbage collector  determines whether the size of the received additional portion exceeds a predetermined threshold size (). In some implementations, the threshold size can be a percentage of the object's size. In some other implementations, the threshold size can be a defined number of bytes. In some implementations, the threshold size can be selected to optimize network utilization or to avoid a denial of service attack, where a malicious user can upload a portion of the object and then upload the remaining object at a very slow rate. For example, if the garbage collector  resets the timer  every time a byte is received, then a malicious user may trickle data to the system, potentially allowing him or her to occupy large amounts of space in the storage backend . The solution could be to enforce that at least N bytes have been uploaded during the timer  countdown period, with N chosen so the user has real network costs associated with this attack.","In the event that the garbage collector  determines that the size of the additional portion does not exceed the threshold size, the garbage collector  continues to determine whether the timer  has expired (). In the event that the garbage collector  determines that the timer  has not expired, the garbage collector  continues to determine whether the interface backend  has received and stored more portions of object, and if so, whether the accumulated additional portion of the object exceeds the threshold size () prior to the timer expiring (). In the event that the garbage collector  determines that the timer  has expired (), the garbage collector  then deletes the portion of the object stored at the storage backend  and deletes the metadata  associated with the object ().","In the event that the garbage collector  determines that the size of the accumulated additional portion exceeds the threshold size prior to the timer  expiring, the garbage collector  resets the timer associated with the object (). The process  then continues to receive portions of the object until the object is either completely uploaded at the storage backend , or the object is deleted from the hosted storage service  upon the timer  expiring.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 4","b":["400","450","400","450"]},"The computing device  includes a processor , a memory , a storage device , a high-speed interface  connecting to the memory  and multiple high-speed expansion ports , and a low-speed interface  connecting to a low-speed expansion port  and the storage device . Each of the processor , the memory , the storage device , the high-speed interface , the high-speed expansion ports , and the low-speed interface , are interconnected using various busses, and may be mounted on a common motherboard or in other manners as appropriate. The processor  can process instructions for execution within the computing device , including instructions stored in the memory  or on the storage device  to display graphical information for a GUI on an external input\/output device, such as a display  coupled to the high-speed interface . In other implementations, multiple processors and\/or multiple buses may be used, as appropriate, along with multiple memories and types of memory. Also, multiple computing devices may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system).","The memory  stores information within the computing device . In some implementations, the memory  is a volatile memory unit or units. In some implementations, the memory  is a non-volatile memory unit or units. The memory  may also be another form of computer-readable medium, such as a magnetic or optical disk.","The storage device  is capable of providing mass storage for the computing device . In some implementations, the storage device  may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations. Instructions can be stored in an information carrier. The instructions, when executed by one or more processing devices (for example, processor ), perform one or more methods, such as those described above. The instructions can also be stored by one or more storage devices such as computer- or machine-readable mediums (for example, the memory , the storage device , or memory on the processor ).","The high-speed interface  manages bandwidth-intensive operations for the computing device , while the low-speed interface  manages lower bandwidth-intensive operations. Such allocation of functions is an example only. In some implementations, the high-speed interface  is coupled to the memory , the display  (e.g., through a graphics processor or accelerator), and to the high-speed expansion ports , which may accept various expansion cards (not shown). In the implementation, the low-speed interface  is coupled to the storage device  and the low-speed expansion port . The low-speed expansion port , which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet) may be coupled to one or more input\/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.","The computing device  may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server , or multiple times in a group of such servers. In addition, it may be implemented in a personal computer such as a laptop computer . It may also be implemented as part of a rack server system . Alternatively, components from the computing device  may be combined with other components in a mobile device (not shown), such as a mobile computing device . Each of such devices may contain one or more of the computing device  and the mobile computing device , and an entire system may be made up of multiple computing devices communicating with each other.","The mobile computing device  includes a processor , a memory , an input\/output device such as a display , a communication interface , and a transceiver , among other components. The mobile computing device  may also be provided with a storage device, such as a micro-drive or other device, to provide additional storage. Each of the processor , the memory , the display , the communication interface , and the transceiver , are interconnected using various buses, and several of the components may be mounted on a common motherboard or in other manners as appropriate.","The processor  can execute instructions within the mobile computing device , including instructions stored in the memory . The processor  may be implemented as a chipset of chips that include separate and multiple analog and digital processors. The processor  may provide, for example, for coordination of the other components of the mobile computing device , such as control of user interfaces, applications run by the mobile computing device , and wireless communication by the mobile computing device .","The processor  may communicate with a user through a control interface  and a display interface  coupled to the display . The display  may be, for example, a TFT (Thin-Film-Transistor Liquid Crystal Display) display or an OLED (Organic Light Emitting Diode) display, or other appropriate display technology. The display interface  may comprise appropriate circuitry for driving the display  to present graphical and other information to a user. The control interface  may receive commands from a user and convert them for submission to the processor . In addition, an external interface  may provide communication with the processor , so as to enable near area communication of the mobile computing device  with other devices. The external interface  may provide, for example, for wired communication in some implementations, or for wireless communication in other implementations, and multiple interfaces may also be used.","The memory  stores information within the mobile computing device . The memory  can be implemented as one or more of a computer-readable medium or media, a volatile memory unit or units, or a non-volatile memory unit or units. An expansion memory  may also be provided and connected to the mobile computing device  through an expansion interface , which may include, for example, a SIMM (Single In Line Memory Module) card interface. The expansion memory  may provide extra storage space for the mobile computing device , or may also store applications or other information for the mobile computing device . Specifically, the expansion memory  may include instructions to carry out or supplement the processes described above, and may include secure information also. Thus, for example, the expansion memory  may be provide as a security module for the mobile computing device , and may be programmed with instructions that permit secure use of the mobile computing device . In addition, secure applications may be provided via the SIMM cards, along with additional information, such as placing identifying information on the SIMM card in a non-hackable manner.","The memory may include, for example, flash memory and\/or NVRAM memory (non-volatile random access memory), as discussed below. In some implementations, instructions are stored in an information carrier. The instructions, when executed by one or more processing devices (for example, processor ), perform one or more methods, such as those described above. The instructions can also be stored by one or more storage devices, such as one or more computer- or machine-readable mediums (for example, the memory , the expansion memory , or memory on the processor ). In some implementations, the instructions can be received in a propagated signal, for example, over the transceiver  or the external interface .","The mobile computing device  may communicate wirelessly through the communication interface , which may include digital signal processing circuitry where necessary. The communication interface  may provide for communications under various modes or protocols, such as GSM voice calls (Global System for Mobile communications), SMS (Short Message Service), EMS (Enhanced Messaging Service), or MMS messaging (Multimedia Messaging Service), CDMA (code division multiple access), TDMA (time division multiple access), PDC (Personal Digital Cellular), WCDMA (Wideband Code Division Multiple Access), CDMA2000, or GPRS (General Packet Radio Service), among others. Such communication may occur, for example, through the transceiver  using a radio-frequency. In addition, short-range communication may occur, such as using a Bluetooth, WiFi, or other such transceiver (not shown). In addition, a GPS (Global Positioning System) receiver module  may provide additional navigation- and location-related wireless data to the mobile computing device , which may be used as appropriate by applications running on the mobile computing device .","The mobile computing device  may also communicate audibly using an audio codec , which may receive spoken information from a user and convert it to usable digital information. The audio codec  may likewise generate audible sound for a user, such as through a speaker, e.g., in a handset of the mobile computing device . Such sound may include sound from voice telephone calls, may include recorded sound (e.g., voice messages, music files, etc.) and may also include sound generated by applications operating on the mobile computing device .","The mobile computing device  may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a cellular telephone . It may also be implemented as part of a smart-phone , personal digital assistant, or other similar mobile device.","Various implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and\/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and\/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.","These computer programs (also known as programs, software, software applications or code) include machine instructions for a programmable processor, and can be implemented in a high-level procedural and\/or object-oriented programming language, and\/or in assembly\/machine language. As used herein, the terms machine-readable medium and computer-readable medium refer to any computer program product, apparatus and\/or device (e.g., magnetic discs, optical disks, memory, Programmable Logic Devices (PLDs)) used to provide machine instructions and\/or data to a programmable processor, including a machine-readable medium that receives machine instructions as a machine-readable signal. The term machine-readable signal refers to any signal used to provide machine instructions and\/or data to a programmable processor.","To provide for interaction with a user, the systems and techniques described here can be implemented on a computer having a display device (e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor) for displaying information to the user and a keyboard and a pointing device (e.g., a mouse or a trackball) by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback (e.g., visual feedback, auditory feedback, or tactile feedback); and input from the user can be received in any form, including acoustic, speech, or tactile input.","The systems and techniques described here can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here), or any combination of such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network (LAN), a wide area network (WAN), and the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","Although a few implementations have been described in detail above, other modifications are possible. For example, while a client application is described as accessing the delegate(s), in other implementations the delegate(s) may be employed by other applications implemented by one or more processors, such as an application executing on one or more servers. In addition, the logic flows depicted in the figures do not require the particular order shown, or sequential order, to achieve desirable results. In addition, other actions may be provided, or actions may be eliminated, from the described flows, and other components may be added to, or removed from, the described systems. Accordingly, other implementations are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
