---
title: System and method for optimizing database transaction termination
abstract: Embodiments of the invention are generally directed to a system and method for optimizing transaction termination. A database interface receives an indication to terminate a transaction. The database interface decides whether to send a command to the underlying database server to terminate the transaction. If the database interface does send a command to the database server, it determines which command is appropriate to send.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08655853&OS=08655853&RS=08655853
owner: SAP AG
number: 08655853
owner_city: Walldorf
owner_country: DE
publication_date: 20041001
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["Embodiments of the invention generally relate to the field of data processing and, more particularly, to a system and method for optimizing transaction termination.","Many businesses provide access to their products and services through applications that are delivered over computer networks such as the Internet. These applications typically have a multi-tiered architecture. In those cases where the applications are delivered over the Internet they are commonly referred to as Web-based applications.  is a block diagram of a Web-based application  having a multi-tiered architecture.","Web-based application  includes client layer , application layer , and database layer . Client layer  includes user interface  that runs on a client computing device such as a desktop computer, laptop computer, personal digital assistant, telephone, and the like. In a Web-based environment, user interface  is typically a Web browser. User interface  may collect input from a user and provide that input to application layer  for processing.","Application layer  includes application server  to receive and process input from client layer . Application server  typically includes a number of subcomponents including, for example, connectivity layer , presentation logic , business logic , and database interface . Connectivity layer  provides connections to client layer  using protocols such as the HyperText Transfer Protocol (HTTP), HTTP secured through the Secure Socket Layer, the Simple Object Access Protocol (SOAP), and the like. Presentation logic  generates a Graphical User Interface (GUI) using, for example, a markup language such as the Hyper Text Markup Language (HTML). Business logic  represents the core of the application, for example, the rules governing the underlying business process (or other functionality) provided by the application. The Java 2 Enterprise Edition Specification v1.3, published on Jul. 27, 2001 (the J2EE specification) defines an increasingly popular architecture for application layer .","Database layer  includes data access logic used by business logic  to store and retrieve data in database . Database  provides non-volatile storage (sometimes referred to as a persistent store) for the data accessed and\/or processed by application layer . Database  may be, for example, a relational database or an object-oriented database.","Database interface  provides an interface between business logic  and database layer . Database interface , for example, establishes (and terminates) connections between business logic  and database layer . Business logic  accesses database tables (and, in some cases, a data dictionary) via database interface . Typically, database interface  controls the access of database tables using transactions. The term \u201ctransaction\u201d refers to a series of database operations that form a unit with regard to backup and synchronization (e.g., a read transaction or a write transaction).","Database interface  typically terminates a transaction by sending a transaction termination request to the underlying database server . The term \u201ctermination request\u201d broadly refers to a database call that terminates a transaction and includes, for example, a call to a COMMIT method or a call to a ROLLBACK method. Using a termination request to terminate a transaction, however, incurs a cost in performance. For example, a system latency is incurred by passing the termination request to database server  and by subsequently waiting for the result. Experience has shown that additional costs are associated with using one type of termination request instead of another type. For example, calling a ROLLBACK method rather than a COMMIT method may incur a higher cost because some databases clear caches and reset other database connection states when rolling back a transaction.","Embodiments of the invention are generally directed to a system and method for optimizing transaction termination. A database interface receives an indication to terminate a transaction. The database interface decides whether to send a command to the underlying database server to terminate the transaction. If the database interface does send a command to the database server, it determines which command is appropriate to send.","Embodiments of the invention are generally directed to a system and method for optimizing transaction termination. A database interface receives an indication to terminate a transaction. The database interface decides whether to send a command to the underlying database server to terminate the transaction. If the database interface does send a command to the database server, it determines which command is appropriate to send.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","200"]},"Application server  includes database interface . In an embodiment, database interface  provides a connection handling infrastructure for connections between application server  and database . For example, database interface  provides database connections, as needed, for applications running on application server . The connections are used to submit database access statements and examine the results (if any). The term \u201cdatabase access statement\u201d refers to software that is used to access data stored on a database such as Structured Query Language (SQL) statements. An SQL statement broadly refers to a statement structured in accordance with any of the SQL standards, for example, statements that comply with the American National Standards Institute\/International Organization or Standardization (ANSI\/ISO) 9075: 1992 Information Technology\u2014Database Languages\u2014SQL standard (hereinafter, the SQL-92 Standard).","The applications running on application server  may be developed from an objected-oriented point-of-view. That is, they may consist of objects that are typically accessed by identifying a first object as a starting point and finding additional objects by, for example, following references or calling methods. In contrast, database  is typically organized according to a completely different organizational model that is based on set-oriented query and update statements. Database interface  includes database connectivity Application Programming Interface (API)  to provide, in part, a mechanism for object-oriented applications to access relational database  using, for example, SQL statements. In one embodiment, database connectivity API  is the JDBC\u2122 API.","JDBC API  defines a set of interfaces that encapsulate database functionality such as a connection interface, a query statement interface, and a result set interface. JDBC driver  is a set of classes that implements these interfaces for database . The database connections provided by database interface  are instances of the connection class or classes that implement the connection interface. The behavior of each database connection is, in part, defined by one or more connection parameters. Database porting layer  includes one or more ports to database . In an embodiment, database porting layer  is a collection of SAP specific interfaces and their database specific implementations extending JDBC API  for database porting purposes. As is further described below with to , database interface  provides a mechanism to defer configuration of one or more connection parameters until it is desirable to propagate the configuration of the parameters to database .",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3","b":["300","300","310","300","310","320","330","340","360","370","300","300"]},"Administration program  provides a mechanism to set up data source  and register it with naming service . In one embodiment, an application server (e.g. application server , shown in ) provides application program . Alternatively, application program  may be a stand alone program that creates data source , sets one or more properties of data source  (e.g., name, description, etc.), and registers it with naming service .","Data source  is a software object that represents an underlying physical data source (e.g., database , shown in ) and is a factory for connections to the underlying physical data source. In one embodiment, data source  is an instance of a class that implements an interface such as the DataSource interface of the javax.sq1 package of the JDBC API. In an alternative embodiment, data source  may implement a different interface and\/or may be an instance of software from a different package.","Naming service  provides a mapping of logical names to data sources. In one embodiment, naming service  is a service that works with the Java Naming and Directory Interface (JNDI) API. The JNDI API refers to any of the JNDI APIs including, for example, the JNDI API described in the JNDI 1.2 Specification released on Jul. 14, 1999. In an alternative embodiment, naming service  works with a different naming interface.","The illustrated embodiment of connection handling infrastructure  provides pooled connections to the underlying database. The term \u201cpooled connections\u201d refers to a number of previously established (e.g., during startup) database connections that are maintained in a pool and shared among several users. Pooled connections reduce the expense (in terms of resources such as memory and latency) of creating a new database connection for each access to the database. In addition, pooled connections allow for a more efficient use of database connections because they enable a single connection to be shared among two or more users. In an alternative embodiment, connection handling infrastructure  supports standard connection objects and\/or connection objects that support distributed transactions.","Connection pool  provides a factory for pooled connections (e.g., pooled connection ). In an embodiment, connection pool  returns a pooled connection when application  requests a connection from data source . In one embodiment, connection pool  is an instance of a class that implements a connection pool interface such as the ConnectionPoolDataSource interface available in the javax.sq1 package. In an alternative embodiment, connection pool  may implement a different interface and\/or may be an instance of software from a different package.","Pooled connection  is a connection (e.g., session) to an underlying data source (e.g., database  shown in ). Application  uses methods in connection handle  representing pooled connection  to specify transaction attributes, to send queries to an underlying data source, and to access the results of the queries. In an embodiment, pooled connection  is an instance of a class that implements an interface such as the PooledConnection interface of the javax.sq1 package. In such an embodiment, connection handle  representing pooled connection  is an object that may be used to create derived objects such as Statement objects and\/or PreparedStatement objects. In an alternative embodiment, pooled connection  may implement a different interface and\/or may be an instance of software from a different package.","Connection handle  is a logical connection object that represents pooled connection . In one embodiment, when application  requests a database connection (e.g., with a getConnection method), the application server assigns pooled connection  to the application and provides connection handle  to interface between application  and pooled connection . When application  is finished using the connection, it closes connection handle  (e.g., via a close method) and pooled connection  is returned to the connection pool (e.g., connection pool ). In one embodiment, connection handle  and pooled connection  maintain one or more internal variables representing various aspects of the database connection. The term \u201cinternal variable\u201d refers to a structure that holds data that is assigned to it until a new value is assigned or the program finishes. Connection handles are further discussed below with reference to .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["400","400","430","432","438","402","432","438","400"]},"In an embodiment, deferring the configuration of a database parameter includes maintaining both actual state information for a connection parameter and desired state information for the connection parameter. During startup of physical pooled connection , the actual state information is obtained once from the database server and stored, for example, in an internal variable of pooled connection . During creation of connection handle , representing pooled connection , the actual state information is copied from pooled connection  to an internal variable of connection handle . The desired state information is obtained from calls sent by the application to which handle  is assigned (e.g., application ) that are directed to changing connection parameter configuration.","In an embodiment, deferring the configuration of a database parameter also includes distinguishing between intervals of time when actual and desired connection parameter state information should be synchronized from those intervals of time when they need not be synchronized. One example of an interval of time when they need not be synchronized is, generally, between the end of one transaction and the start of another transaction.","For example, initially, connection handle  is assigned to application . Application  uses connection handle  to accesses database  within the context of a transaction. In an embodiment, connection handle  includes an internal variable to represent the current transaction state. When the transaction is complete, it is terminated with a COMMIT or ROLLBACK command and the current transaction state is set to inactive. In one embodiment, during the interval of time starting when the current transaction state is set to inactive and continuing until the next database access statement is sent to database , connection handle  does not propagate the connection parameter changes to the database server. Instead, for at least a selected subset of connection parameters, connection handle  defers requests to change parameter values and stores desired connection parameter state information in one or more internal variables. Thus, when connection handle  is assigned to application , a number of calls to change connection parameter values may be issued (e.g., from application  and\/or the application server on which application  is running). Until a specified event occurs, however, connection handle  may defer configuring one or more connection parameters.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 5","FIG. 6"],"b":["500","500","510"]},"Connection handle  maintains both desired state information and current state information for a selected subset of connection parameters. In an embodiment, the selected subset of connection parameters includes the transaction isolation level and the auto-commit mode. The auto-commit mode refers to a transaction mode in which a commit command is automatically sent after each database operation (e.g., read and\/or write operation). Typically, the value of the auto-commit mode for a transaction is either true or false depending on whether the auto-commit mode is on or off. Internal variable  represents a desired value for the auto-commit mode as indicated by an application. Internal variable  represents a current value of the auto-commit mode.","Transaction isolation levels determine the extent to which the operation of one transaction can affect the operation of another transaction. The American National Standards Institute (ANSI) defines four isolation levels in the ANSI X3.135-1992 standard entitled, \u201cAmerican National Standard for Information Systems\u2014Database Language\u2014SQL, November 1992\u201d (SQL-92 standard). The four isolation levels defined by the SQL-92 standard are: uncommitted read, committed read, repeatable read, and serializable. Internal variable  represents a desired value for the transaction isolation level as indicated by an application. Internal variable  represents a current value of the transaction isolation level as determined by the database server.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 6","FIG. 5"],"b":["600","630","602","608","520","550"]},"In one embodiment, the selected subset of connection parameters includes the auto-commit mode and the transaction isolation level. In such an embodiment, if the transaction state is an inactive transaction state (e.g., TRANSACTION_STATE_NONE ), method calls to set\/get the auto-commit mode and method calls to set\/get the transaction isolation level are deferred as shown by . In an alternative embodiment, the selected subset of connection parameters includes more connection parameters, fewer connection parameters, and\/or different connection parameters. For example, in one embodiment, the selected subset of connection parameters includes an SQL warning connection parameter. The SQL warning connection parameter refers to a subclass of an SQL exception in which the warnings must be explicitly retrieved. An SQL warning is often used when something not quite right has happened during the execution of an SQL statement but it is not significant enough to end processing.","In an embodiment, the execution of any method other than the ones to set\/get the auto-commit mode and to set\/get the transaction isolation level, triggers an alignment of the desired state variables and their corresponding current state variables. In one embodiment, the connection handling infrastructure compares the values of the desired state variables with the values of the current state variables. If the values are not aligned (e.g., not equal), then the connection handling infrastructure calls one or more set methods to synchronize the values.","In the illustrated embodiment, the current auto-commit mode state and the current transaction isolation level of the underlying physical database connection (e.g., JDBC connection) are compared to the corresponding desired values. The current values are aligned via deferred execution of setAutoCommit and\/or setTransactionIsolation thereby synchronizing the actual state information in the corresponding pooled connection, if necessary. The transaction state is then set to an initialized state (e.g., TRANSACTION_STATE_INITIALIZED ). In an embodiment, the transaction state is set to TRANSACTION_STATE_INITIALIZED  when the configuration of transactional behavior is complete and the connection handle is ready for a database transaction to be started.","In an embodiment, after the transaction has been initialized, every call to the methods of the connection handle that are directed to obtaining, modifying, and\/or providing data from the database, triggers adjustment of the transaction state. For example, every call to a prepareStatement method or the execute methods of statement objects derived from the connection, triggers adjustment of the transaction state. In one embodiment, these methods receive a tree representation of the current statement (e.g., current SQL statement) as a parameter. The tree representation of the statement provides easier identification of the statement type because the clauses of the statement (e.g., SELECT clause, WHERE clause, etc.) are represented by nodes of the tree representation. In one embodiment, the following statement types are possible: INSERT, UPDATE, DELETE, SELECT_FOR_UPDATE, and SELECT.","In one embodiment, the choice of which transaction state to transition to is based, at least in part, on the statement type. For example, if the statement is a SELECT statement, the underlying database porting layer determines whether a SELECT statement, under the current transaction isolation level, causes the database to allocate any resources. The term \u201cresources\u201d refers to, for example, database locks such as exclusive locks, non-exclusive locks, etc. In one embodiment, if the SELECT statement does not cause the database to allocate resources, then the transaction state transitions to a first state (e.g., TRANSACTION_STATE_ACTIVE_SELECTS ) as shown by . In an embodiment, the first state indicates that a database transaction is active and that database resources are not allocated for the transaction.","If, however, the SELECT statement does cause the database to allocate resources, then the transaction state transitions to a second state (e.g., TRANSACTION_STATE_ACTIVE_RESOURCES ) as shown by . If the statement is a SELECT_FOR_UPDATE statement, then the transaction state also transitions to the second state (e.g., TRANSACTION_STATE_ACTIVE_RESOURCES ). In an embodiment, the second state indicates that a database transaction is active and that database resources are allocated for the transaction.","In an embodiment, if the statement is one of an INSERT statement, an UPDATE statement, and a DELETE statement, then the transaction state transitions to a third state (e.g., TRANSACTION_STATE_ACTIVE_MODIFICATION ) as shown by . The third state indicates that a database transaction is active and data on the database is to be modified. In one embodiment, until the transaction is terminated, the transaction state can only be raised (e.g., from the first state to the second state to the third state) as shown by -.","The execution of one or more connection handle methods is based, at least in part, on whether the connection handle is in the first, second, or third state, when the method is called. In one embodiment, the relevant connection handle methods are the methods directed to terminating a transaction such as commit, rollback, setAutoCommit, and close. In such an embodiment, the cost in latency and system resources of propagating a command to the database can, in some cases, be reduced by selecting an appropriate command based, partly, on the current transaction state (e.g., first, second, or third state).","In one embodiment, the most significant benefits are available when a transaction is terminated while the transaction state is the first state (e.g., TRANSACTION_STATE_ACTIVE_SELECTS ). The reason for this is that the first state corresponds to a transaction for which the database does not allocate resources. Thus, the connection handling infrastructure need not explicitly release resources allocated on the database. In an embodiment, if the transaction state is the first state, explicit calls to the commit and rollback methods and implicit calls to the commit and rollback methods within the setAutoCommit and close methods are not propagated to the database.","In an embodiment, efficiencies are also possible when a transaction is terminated while the transaction state is the second state (e.g., TRANSACTION_STATE_ACTIVE_RESOURCES ). Experience has shown that a COMMIT command provides better performance (e.g., less latency and\/or fewer system resources used) than a ROLLBACK command. Since, the second state corresponds to a transaction for which database resources are allocated but data is not modified on the database, the connection handling infrastructure is free to release resources without regard for the consistency benefits provided by a ROLLBACK operation. Both a COMMIT command and a ROLLBACK command will release resources allocated on a database. In an embodiment, if a rollback method is called when the transaction state is the second state, a COMMIT command is propagated to the database.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 7","FIG. 6"],"b":["702","704","700","708","710","700","712","714","700","708","710","712","714","630"]},"In an embodiment, connection parameter changes for a selected subset of connection parameters are deferred during intervals of time when there is no active transaction as shown by -. The desired values for the connection parameters are internally stored, for example, until intervals -. In one embodiment, desired state values are synchronized with current state values during intervals - as shown by -.","Turning now to , the particular methods associated with embodiments of the invention are described in terms of computer software and hardware with reference to a flowchart. The methods to be performed by a computing device (e.g., an application server) may constitute state machines or computer programs made up of computer-executable instructions. The computer-executable instructions may be written in a computer programming language or may be embodied in firmware logic. If written in a programming language conforming to a recognized standard, such instructions can be executed on a variety of hardware platforms and for interface to a variety of operating systems. In addition, embodiments of the invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement embodiments of the invention as described herein. Furthermore, it is common in the art to speak of software, in one form or another (e.g., program, procedure, process, application, etc.), as taking an action or causing a result. Such expressions are merely a shorthand way of saying that execution of the software by a computing device causes the device to perform an action or produce a result.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 8","FIG. 4","FIG. 4"],"b":["810","400","432","438"]},"Referring to process block , the connection handling infrastructure receives an indication from the application to access a specified connection parameter. In one embodiment, \u201creceiving an indication\u201d includes being called by a method that passes a value for a connection parameter. The term \u201caccess\u201d includes setting a value and\/or getting a value. Examples of such methods include, and are not limited to, set\/get auto-commit mode and set\/get transaction isolation level.","Referring to process block , the connection handling infrastructure determines whether the specified connection parameter is one of a selected subset of connection parameters. In an embodiment, the connection handling infrastructure compares the specified connection parameter with the members of the selected subset to determine whether it is one of the selected subset of connection parameters. In one embodiment, the selected subset of connection parameters includes the auto-commit mode and the transaction isolation level. In an alternative embodiment, the selected subset of connection parameters includes more connection parameters, fewer connection parameters, and\/or different connection parameters.","Referring to process block , the connection handling infrastructure defers access to the specified connection parameter, if it is one of the selected subset of connection parameters. The term \u201cdefer access\u201d refers to deferring execution of an instruction to configure the connection parameters. For example, deferring access may include deferring execution of a get\/set auto-commit mode method and\/or a get\/set transaction isolation level method.","Referring to process block , the connection handling infrastructure stores a value indicating a desired setting for the specified connection parameter. In one embodiment, the stored value is obtained from the method call that attempted to access the connection parameter. Thus, if a setAutoCommit to true method is called, a value indicating true (e.g., 1) is stored. Similarly, if setTransactionIsolation method is called, a value indicating the desired transaction isolation level (e.g., 0, 1, 2, 4, 8) is called. In an embodiment, the values indicating the desired setting for the specified connection parameter are stored in one or more internal variables of the connection handle (e.g., internal variables -, shown in ).",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 9","b":["910","520","550"]},"Referring to process block , the connection handling infrastructure receives an indication to access another connection parameter. The received indication may be an instruction, a method call, and the like. The connection handling infrastructure determines whether the received indication is directed to one of the selected subset of connection parameters at . If it is not, the connection handling infrastructure compares the value indicating the desired state of the connection parameter with the value indicating the current state of the connection parameter at . If the values are not aligned, the connection handling infrastructure synchronizes the values at . Synchronizing the values refer to, for example, executing a method (e.g., a set auto-commit method and\/or a set transaction isolation level method) to set the current value of the connection parameter so that it is aligned (e.g., equal) to the desired value.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 10","b":"1010"},"Referring to process block , the connection handling infrastructure determines whether to send a termination request to the database. The term \u201ctermination request\u201d broadly refers to sending a command (e.g., a COMMIT command and\/or a ROLLBACK command) to the underlying database server. In an embodiment, whether a termination request is sent to the database depends, at least in part, on the current transaction state of the connection handle (e.g., see discussion above with reference to ). In addition, whether to send a termination request may be based, at least in part, on the received indication to terminate the transaction (e.g., see discussion above with reference to ).","Referring to process block , if a termination request is to be sent, the connection handling infrastructure determines which request to send (e.g., a COMMIT command and\/or a ROLLBACK command). Experience has shown that a COMMIT command is associated with less latency and the use of fewer system resources than a ROLLBACK command. In an embodiment, the connection handling infrastructure determines which termination request to send based, at least in part, on a current transaction state of the connection handle transaction (e.g., see discussion above with reference to ). The selected termination request is sent to the database at .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 11","FIG. 6","FIG. 6"],"b":["1110","640","650","670"]},"Referring to process block , the connection handling infrastructure determines a statement type for the received database statement. In one embodiment, the database statement type is one of: an INSERT statement, an UPDATE statement, a DELETE statement, a SELECT_FOR_UPDATE statement, and a SELECT statement. The received statement may be in the form of a tree structure. The connection handling infrastructure queries the received statement to determine its type. If the received statement is a SELECT statement, the connection handling infrastructure asks the database porting layer whether the SELECT statement causes the database to allocate a resource based, at least in part, on a current transaction isolation level.","Referring to process block , the transaction state of the connection transitions to one of a plurality of transaction states based, at least in part on the determined database statement type. In one embodiment, the transaction state transitions to a first state (e.g., state , shown in ), if the database statement is a SELECT statement that does not cause the database to allocate a resource. Similarly, the transaction state transitions to a second state (e.g., state , shown in ), if the database statement is a SELECT statement that causes the database to allocate a resource or if the database statement is a SELECT_FOR_UPDATE statement. In an embodiment, the transaction state transitions to a third state (e.g., state , shown in ) if the statement type is an INSERT statement, an UPDATE statement, and\/or a DELETE statement.","Referring to process block , the connection handling infrastructure receives an indication to terminate the transaction. The received indication may be, for example, a call to the connection's commit method or a call to the connection's rollback method. In an embodiment, the received indication may be a call to the connection's close method or a call to enable an auto-commit mode of the transaction.","Referring to process block , the connection handling infrastructure determines whether to send a termination request based, at least in part, on the transaction state of the database connection. In an embodiment, if the transaction state is the first state, the connection handling infrastructure does not send a termination request. If the transaction state is the second or the third state, then the connection handling infrastructure may send a termination request. In one embodiment, if a termination request is to be sent, the connection handling infrastructure further determines which termination request to send (e.g., either a COMMIT command or a ROLLBACK command). Determining which termination request to send is further discussed above with reference to .","Elements of embodiments of the present invention may also be provided as a electronically accessible storage medium for storing the machine-executable instructions. The electronically accessible storage medium may include, but is not limited to, flash memory, optical disks, compact disks-read only memory (CD-ROM), digital versatile\/video disks (DVD) ROM, random access memory (RAM), erasable programmable read-only memory (EPROM), electrically erasable programmable read-only memory (EEPROM), magnetic or optical cards, or other type of machine-readable media suitable for storing electronic instructions. For example, embodiments of the invention may be downloaded as a computer program which may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).","It should be appreciated that reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore, it is emphasized and should be appreciated that two or more references to \u201can embodiment\u201d or \u201cone embodiment\u201d or \u201can alternative embodiment\u201d in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures or characteristics may be combined as suitable in one or more embodiments of the invention.","Similarly, it should be appreciated that in the foregoing description of embodiments of the invention, various features are sometimes grouped together in a single embodiment, figure, or description thereof for the purpose of streamlining the disclosure aiding in the understanding of one or more of the various inventive aspects. This method of disclosure, however, is not to be interpreted as reflecting an intention that the claimed subject matter requires more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive aspects lie in less than all features of a single foregoing disclosed embodiment. Thus, the claims following the detailed description are hereby expressly incorporated into this detailed description, with each claim standing on its own as a separate embodiment of this invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the invention are illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings in which like reference numerals refer to similar elements.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
