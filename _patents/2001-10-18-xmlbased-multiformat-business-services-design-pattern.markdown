---
title: XML-based multi-format business services design pattern
abstract: A design pattern for a software architecture includes a business services layer comprising ApiService class, BusinessService class, Message class and Field class. ApiService class accepts a request that includes request parameters and utilizes corresponding instances of Message class and Field class to translate the request to an input message. The instances of Message and Field class contain the request parameters in self-describing form, namely, field names and associated values. The input message is forwarded to the appropriate subclass of BusinessService class by ApiService class. The subclass of BusinessService class uses the input message to retrieve data and generate an output message containing the data. The output message is generated in self-describing form utilizing Message class and Field class. ApiService class translates the output message to a presentation format identified by the request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07296226&OS=07296226&RS=07296226
owner: Accenture GmbH
number: 07296226
owner_city: Sulzbach
owner_country: DE
publication_date: 20011018
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit under 35 U.S.C. \u00a7119(e) of Provisional U.S. patent application Ser. No. 60\/268,981, filed on Feb. 15, 2001.","A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights.","A computer program listing appendix is file herewith and herein incorporated-by-reference in its entirety. The computer program listing appendix includes a first compact disc (copy 1) containing a computer program listing consisting of 10 files.","In addition, the computer program listing appendix includes a second compact disc (copy 2) which is an exact duplicate of the first compact disc.","This invention relates to application software architectures, and in particular, to architectures operating with multiple presentation formats in a diverse front-end systems layer and a diverse back-end systems layer.","Many financial services related businesses, such as banking, brokerage and insurance companies, are looking for ways to provide their core services to customers across electronic delivery technologies. These businesses are developing software applications and architectures to allow customers to tap into the business's existing application software infrastructure and access information contained in existing databases. Creating the software applications and architectures typically includes development of presentation and interfacing logic. In general the presentation and interfacing logic allows access to the information by customers using different front-end delivery technology, such as Internet browsers, interactive voice response units (IVRs) and wireless application protocol (WAP) phones.","In most cases, the presentation and interfacing logic is developed redundantly for every delivery technology. As such, changes to the underlying services may result in additional software development for each delivery technology. Moreover, because the information is usually handled with static data structures, any additional information required by customers may lead to a change in all software components related to this functionality.","One possible solution to this problem involves the use of extensible markup language (XML) technology. The XML technology is easily configurable and provides an extensible data structure. In addition, XML may be configured to provide a mechanism for translating the data for the different delivery technologies. However, the complexity and broad applicability of XML, along with multiple differing implementations available make a solution directly utilizing XML technology difficult to implement and maintain.","In view of the above, XML technology is leveraged through a set of classes that provide an easier to use abstraction for an application programmer than direct application of XML would provide. The set of classes are included within a business services layer. The business services layer provides a foundation for an XML based e-commerce software architecture that includes an end-user systems layer, a front-end systems layer, the business services layer and a back-end systems layer. The design pattern provided by the business services layer allows different delivery technologies within the end-user systems layer to interface with data contained within the back-end systems layer via the front-end systems layer. Messages in the form of requests for data and messages containing corresponding data are transferred between the front-end systems layer and the back-end systems layer using functionality within the business services layer. The functionality of the business services layer operates using XML technology while shielding the application programmer from many of the associated complexities.","The business services layer includes the core classes of an ApiService class, a Message class, a Field class and a BusinessService class. The application programmer deals with Message class and Field class while developing custom application code to integrate the business services layer into an e-commerce software architecture. ApiService class and BusinessService class transparently operate in cooperation with Message class and Field class to handle the details of XML as well as translation of information for the different delivery technologies within the end-user systems layer.","ApiService class together with BusinessService class, Message class and Field class handle the receipt of a request for data from the front-end systems layer and conversion of request parameters within the request to an input message. In addition, ApiService class directs execution of custom application code (contained in a subclasses of BusinessService) based on the request. The ApiService class also directs the creation of an output message from data provided by the custom application code in response to the request. Further, the ApiService class directs the translation of the output message to the desired format.","Message class and Field class act as wrappers to the functionality of a DOM (Document Object Model) class. Moreover, Message class and Field class include wrapping logic for an XSL Application Programming Interface (API). These wrappers limit the data structures that can be represented to \u201cmessages\u201d containing \u201cfields\u201d of simple data types (string, long, integer, boolean) or group fields. Limiting the richness of the data structures to what is essential, while providing a generic translation mechanism, advantageously simplifies development of a business services application within the e-commerce software architecture.","An interesting feature of the business services layer is the ability of the application programmer to define both a long field name and a short field name for each field. The long or short field names may be selected as a mode of operation depending on the runtime environment. Where speed and\/or bandwidth consumption is outweighed by the desire for longer more readily understood field names, the long field names may be selected; resulting in larger quantities of data being transferred among the layers. Conversely, where minimizing the volume of data is a priority, the short names may be selected. Selection of the mode of operation is performed with a static variable called the mode debug flag.","Another interesting feature involves identification of the data types for the fields. Those fields that routinely appear in the input and output messages may be defined in a MESSAGEDEFINITION class within the business services layer. The data type for fields associated with a particular subclass of BusinessService class (a particular request), however, are defined within the custom application code of that particular subclass. As such, fields that are repetitively utilized within different subclasses of BusinessService class need only be defined once in the business services layer.","These and other features and advantages will become apparent upon a review of the following detailed description of the presently preferred embodiments of the invention viewed in conjunction with the appended drawings.","The presently preferred embodiments describe an extensible markup language (XML) based e-commerce software architecture forming a business services application. The architecture includes a business services layer that provides a framework for interfacing between information within a back-end systems layer and users operating a front-end systems layer. Users may request the information via the front-end systems layer using a plurality of different delivery technologies. The different delivery technologies operate with at least one of multiple presentation formats. The framework of the XML based e-commerce software architecture provides a flexible and generic approach to translating requests from the different delivery technologies. In addition, information resulting from the requests also utilizes the framework for translation of the information to a format compatible with the different delivery technologies. As such, the architecture provides a relatively simple configuration that is easier and cheaper to maintain than straight code.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["10","10","12","14","16","18","10"]},"The end-user systems layer  includes delivery technologies allowing a user to interface with the e-commerce software architecture . Exemplary delivery technologies include an Internet browser, a telephone, a wireline communication device, a wireless communication device, a wireless application protocol (WAP) device or any other software, hardware, or a combination thereof allowing a user to interface with the front-end systems layer . During operation, the end-user systems layer  of one embodiment provides for entry of user requests for data and access to information\/data resulting from the user requests.","The front-end systems layer  may be any application and\/or mechanism capable of using a plurality of presentation formats to process user requests and make data available to the end-user systems layer . The front-end systems layer  includes communication technologies, such as, for example, server-based web-sites, wireline and\/or wireless communication networks, interactive voice response sites (IVRs) and\/or any other devices or applications capable of corresponding with the end-user systems layer . The front-end systems layer  operates to process user requests received via the delivery technologies and create a request. The requests are transferred via the business service layer  to the back-end systems layer . In addition, the front-end systems layer  provides access by the delivery technologies to data received from the back-end systems layer  via the business service layer .","As used herein, the term \u201crequest\u201d is a data solicitation that includes request parameters. The request parameters identify criteria used for selective retrieval of data. The criteria are based on selections made by users operating the delivery technologies.","The business services layer  may be any software architecture capable of performing a translation\/interfacing function between the front-end systems layer  and the back-end systems layer . The business services layer  may operate within the hardware and software of the front-end systems layer , the back-end systems layer  and\/or on a dedicated platform. An exemplary dedicated platform is at least one computer operating as a UNIX or NT server. The business services layer  provides a structure to facilitate the transfer of requests from the front-end systems layer  and transfer of data from the back-end systems layer . Applications within the business services layer  provide a generic translation mechanism and extensible data structure with application to a plurality of different delivery technologies. As such, the business services layer  provides a foundation for simplifying the configuration of an interface between delivery technologies, the front-end systems layer  and the back-end systems layer .","The back-end systems layer  may be any information system capable of storing and manipulating information. The back-end systems layer , may include, for example, mainframes, databases, servers, legacy systems or any other devices or systems used to store, display and manipulate data and other information. As used herein, the term legacy systems includes those systems operating with custom built applications, obsolete applications, proprietary operating systems, obsolete hardware or any other business logic, business information storage and\/or hardware not capable of directly interfacing with the front-end systems layer  and\/or the delivery technologies.","During operation, user requests are initiated with different delivery technologies within the end-user systems layer . The user requests can be processed by the front- end systems layer  and formulated into a request. The request can be provided to the business services layer . Within the business services layer , the request may be identified and translated to form an input message. The input message can include a plurality of fields containing data representing request parameters. The request parameters can be extracted from the input message with custom application code. The custom application code can be executed, based on identification of the request, to extract data from the back-end services layer  corresponding to the request parameters. The extracted data can be provided as a response. The response can be read into a plurality of fields created in an output message within the business services layer . The output message can be translated to a presentation format compatible with the delivery technology by the business services layer . The translated output message can then be provided to the front-end systems layer  where the data can be accessed by the delivery technology within the end-user systems layer .",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 2","FIG. 1"],"b":["10","12","22","2","24","26","28","14"]},"The end-user systems layer  and the front-end systems layer  are communicatively coupled as illustrated. More specifically, in this embodiment, the web user  is communicatively coupled with the HTML page 32. The web user  represents individual users, such as, for example, individual consumers of goods and services. The web user  accesses the HTML page 32 using delivery technologies such as, for example, a browser and the Internet, an intranet, an extranet or some other type of communication pathway. The HTML page 32 uses the hypertext markup language as a presentation format for the delivery technologies. The presentation format provides the communication mechanism for communicating requests and data.","The BB user  of this embodiment is communicatively coupled with the XML page 34. The BB user  represents businesses accessing the XML page 34, such as, for example, the computer system of one business interfacing with the computer system of another business. Applications such as, for example, home banking software applications used by retail customers on their home computers, customer orders to investment companies or any other business to business or business to consumer related services may be operated by the BB user . Exemplary delivery technologies may include a browser, proprietary communication software or any other communication mechanism for communicating requests and data. Communication between the computer systems may be over the Internet, an intranet, an extranet, a dedicated communication channel and\/or any other form of communication link. The presentation format for communicating data and requests represented by the XML page 34 is the extensible markup language.","The voice user  of this embodiment is communicatively coupled with the IVR-XML gateway , which is in turn communicatively coupled with the XML page 34. The voice user  represents wireline and wireless speech driven delivery technologies operatively cooperating with the IVR-XML gateway . An example being users communicating by cellular and wireline telephones with the IVR-XML gateway . The IVR-XML gateway  may be any converter capable of converting between speech and the extensible markup language used with the XML page 34. As such, this presentation format is the combination of extensible markup language and speech communication to interface with the voice user .","The WAP user  represents wireless interfaces. In this embodiment, the WAP user  interfaces with the WML page 38 using some form of wireless communication to exchange information. Exemplary WAP users  are users operating delivery technologies such as, for example, cellular phones, palm pilots, pagers or any other wireless mechanism for request, receipt and display of information. The presentation format for the WML page 38 provides communication with the delivery technologies using website Meta language.","In other embodiments, the end-user systems layer  may include other types of delivery technologies such as, for example, satellite based communication devices, automated systems and devices, such as automated teller machines, or any other type of communication device. In addition, the front-end systems layer  may include other types of presentation formats such as, for example, unformatted text, Directory Service Markup Language (DSML), proprietary formats, such as Microsoft\u2122 Word, or any other presentation format. Further, delivery technologies within the end-user systems layer  may be communicatively coupled with the different presentation formats within the front-end systems layer  in configurations other than those illustrated in . For example, the BB user  may be communicatively coupled with the HTML page 32 and the web user  may be communicatively coupled with the XML page 34.","Referring again to , the illustrated embodiment of the business services layer  includes core classes represented by ApiService class , Message class , Field class  and BusinessService class . In addition, the business services layer  includes MESSAGEDEFINITION class  and an extensible stylesheet language (XSL) script . In other embodiments, fewer or more classes may be used to provide the functionality of the business services layer  described herein. The embodiments of the business services layer  are preferably implemented using Java technology. In other embodiments, implementation may be with other object-oriented technologies, such as, for example C, C++ or Microsof\u2122 C sharp (C##).","Java technology is a well-known object-oriented technology. Objects within object-oriented technologies include a state maintained in one or more variables. Behavior of objects is implement with methods, which are functions (subroutines) associated with the object. A particular object is called an instance. An instance of an object is instantiated (or created) by a constructor. Multiple objects of the same kind may be part of a class or a subclass within the class. Objects within one or more classes form a program or application through interaction with each other using messages. Messages contain parameters that are information indicating how an object is to perform a corresponding method within the program.","Programs created with Java technology use a Java programming language operating on a Java Virtual Machine (Java VM). The Java VM may be ported onto various hardware-based platforms that include an operating system and hardware. Exemplary hardware-based platforms include Window NT\u2122, Windows 2000\u2122, Linux\u2122, Solaris\u2122 or MacOS\u2122 operating on a computer.","The Java programming language runs on any implementation of the Java VM. The Java programming language source code for one embodiment of the business services layer  is included in the computer program listing appendix filed herewith.","The Java technology also includes Java Application Programming Interface (API). Java API is a large collection of ready-made software components providing a wide range of functionality. The software components provide \u201coff the shelf\u201d capability that may be implemented within Java based programs. As discussed herein, software components that are from Java API are designated by a name followed by \u201cAPI.\u201d","Programs written in the Java programming language may be characterized as applets, servlets and applications. Applets are programs that adhere to certain conventions allowing the applet to run within a Java-enabled browser. Applications are standalone programs running directly on a Java platform that includes the Java VM and Java API. Some applications operate as servers, such as, for example, Web servers, mail servers and print servers to serve clients on a network. Servlets are run time extensions of applications that operate within Java Web servers to configure or tailor the server.","Referring again to , ApiService class  is preferably a servlet directing the overall operation of the business services layer . In one embodiment, Java servlet technology provides a mechanism for implementing the request\/reply mechanism for ApiService class . In other embodiments, analogous implementations using Enterprise Java Beans, JavaServer\u2122 Pages (JSP) or Microsoft\u2122 Application Server Pages (ASP) may be used.","ApiService class  is a generic mechanism for executing custom application code within subclasses of BusinessService class . The custom application code may be executed as a function of requests received from the front-end systems layer .","The requests received by ApiService class  of one embodiment may be in a Servlet Request Format. The Servlet Request Format may be a generic servlet format or may be implemented as, for example, an HTTP servlet or any other format. The presentation formats included in the front-end system layer  may be used to create requests in the Servlet Request Format. In other embodiments, the requests may be in other presentation formats such as, for example, unformatted text, HTML, WML, DSML, proprietary languages such as, MicrosoftTm Word or any other language. In addition, ApiService class  provides output messages based on responses by the subclasses of BusinessService class . In one embodiment, the output messages may be provided as XML, HTML or WML. In other embodiments, the output messages may be in other presentation formats such as, for example, unformatted text, DSML, proprietary languages such as, Microsoft\u2122 Word or any other language.","Languages such as XML may be utilized to represent self-describing data structures. Self-describing data structures identify units of data, referred to as an element, using tags. Tags are collectively referred to as markup. XWL allows the definition of the tags to provide almost limitless different classes of documents. In other words, XML allows creation of tag names that may provide additional information regarding what the element within a tag means. As such, tags are referred to as a field name which places a label on a field containing a unit of data. Labels within XML may be chosen by the programmer to be anything that makes sense in the context of a given application. Tags may also include attributes. Attributes are qualifiers on a tag that provide additional information about the element identified by the tag. Attributes may include an attribute name and an attribute value(s).","Requests received by the ApiService class  preferably include request parameters. The request parameters are formed to include a sequence of tags with corresponding units of data. An exemplary request parameter is a request name parameter to identify the nature, type or category of request received. Other exemplary request parameters may identify ranges of data, logic conditions or any other parameters associated with a request for data. The ApiService class  may translate the request parameters to generate an input message. In addition, responses from the subclasses of BusinessService class  may be similarly translated to form an output message.","In the presently preferred embodiments, ApiService class  utilizes Message class  and Field class  as wrappers of a document object model (DOM) class to create input messages and output messages. Message class  and Field class  are used as wrappers to simplify creation and handling of DOM documents in the DOM class. A wrapper is a class that provides changed\/enhanced interface and functionality of another class (a wrapped class). Wrappers serve as decoupling mechanisms by allowing changes to the wrapped class (the DOM class) while maintaining the interface\/functionality expected by users of the class that is the wrapper (Message class  and Field class ).","The DOM class includes a DOM API operating in a well-known manner. In general, the DOM API is a standardized document object model with a set of interfaces capable of describing an abstract structure for a document such as, for example, an XML document. An instance of the DOM document class is used by the DOM API to create a DOM document with a structure in the form of a virtual tree. The virtual tree is well known and includes element nodes with each element node representing an element within the document. Each of the element nodes is tagged with the same tag associated with the element in the document. In addition, each of the element nodes may include a first child that is a text node containing the element. Further, element nodes may also include a second child that is an attribute node containing any attributes of the tag.","Each element node, text node and attribute node are collectively defined to be a field where the tag is the field name, the text node contains the unit of data associated with the tag, and the attribute node contains attribute names and attribute values of the tag. The DOM API includes a DOM parser capable of generating the virtual tree and randomly accessing the fields within the virtual tree to edit, insert, delete and rearrange the fields.","In the presently preferred embodiments, requests in Servlet Request Format are translated to input messages represented as a first DOM document. In addition, responses from the back-end systems layer  are used to generate output messages represented as a second DOM document. The DOM API operating in conjunction with Message class  and Field class  creates the first and second DOM documents in an XML structure.","Message class  and Field class  reduce coding complexity and streamline processing for input and output messages passed between a servlet (ApiService class ) and custom application code (subclasses of Business Service class ). Message class  operates as a wrapper to restrict manipulation of the first and second DOM documents to what is necessary for operation within the business services layer . Field class  similarly restricts manipulation of the element nodes of the first and second DOM documents. Restriction of the first and second DOM documents, and corresponding element nodes, limits the full manipulative capability typically available for XML documents. Limitation of the manipulative capability within the DOM class provides an easier to use abstraction for programming while providing sufficient functionality for development of business services applications using the business services layer .","In one embodiment, Message class  is a wrapper for well-known classes within the DOM class called Document class, DOM Element class and associated ProcessingInstruction classes. In this embodiment, Message class  allows for more transparent updates of the DOM parser to accommodate changes in the input and output messages. In addition, Message class  includes convenience functions that may be utilized in generating XML text output. As described later, and detailed in the computer program listing appendix filed herewith, the convenience functions are the combination of often used method invocations into a single method to improve productivity and reduce the skill requirement of the developer. Further, Message class  includes functionality to name the first and second DOM documents, create the element nodes and populate the corresponding text nodes. The text nodes are populated with request parameters contained in the requests and data contained in the responses. In another embodiment, Message class  also includes validation functions to validate the format of data and the types of data present in the requests and responses.","Field class  of one embodiment is a wrapper of a well-known DOM setAttribute method within the DOM Element class. In this embodiment, Field class  provides simplified access methods to the text node and the attribute node of a specified element node in the first and second DOM documents. More specifically, Field class  returns the contents of a specified text node as a function of specification of a datatype. In addition, Field class  sets the attributes on a specified attribute node as a function of the datatype.","In one embodiment, the datatypes of the text and attribute nodes may be specified as short integer, long integer, Boolean or string. Short integer is 16-bit signed two's complement integers. Long integer is 64-bit signed two's complement integers. Boolean includes 8-bits of space and 1 bit of data indicating true\/false. String is a series of characters referred to as a string literal. In addition, fields may be specified with the datatype of group. Group is a field containing additional fields with datatypes. Groups may also contain additional groups. In other embodiments, fewer or additional datatypes and\/or formats may be specified.","A FldTypes class (not shown) provides definition of the datatypes for data in the fields of the first and second DOM documents wrapped by Message class . In other embodiments, the FldTypes class also performs validation of data received in the fields by confirming the nodes within the fields include data that is the defined datatype. In yet another embodiment, Field class  also performs validation that the contents of a text node or attribute node within a corresponding field are the datatype expected.","MESSAGEDEFINITION class  of one embodiment provides meta-information in the form of a listing of valid fields common to all messages handled by Message class . Meta-information describes the structure and layout of the messages and is useful in debugging and validation. The meta-information greatly simplifies repetitive fields since the repetitive fields need only be declared once in MESSAGEDEFINITION class .","The valid fields are specified for fields expected in every request and fields expected in every response. In one embodiment, MESSAGEDEFINITION class  includes a first subclass defining common structures for input messages generated from requests and a second subclass defining common structures for output messages generated from responses. Each field in MESSAGEDEFINITION class  is preferably described using a type, a first field name referred to as shortname and a second field name referred to as longname. The type indicates the datatype of the content of the text node and attribute nodes as well as fields containing a group as previously discussed.","Shortname and longname are two field names of different character length that may be selectively used to identify each field. Typically, longname is a field name identifying the content of the field in plain language. Shortname is also a field name, however, the format is abbreviated to a short sequence of letters and\/or numbers unique to the field. When longname is used for the field names, larger amounts of information content are present in requests and output messages. Conversely, shortname provides lesser amounts of information content. Accordingly, shortname provides shorter messages that may be transferred over communication channels faster and\/or with smaller carrier bandwidths. In addition, the field names in shortname are encoded identifiers thereby providing an extra level of security.","In one embodiment, Message class  includes a static variable that is a mode debug flag. The mode debug flag provides the ability to select between using longname or shortname as the mode of operation. Depending on the status of the mode debug flag, longname or shortname may be used as the field names for constructing and parsing messages. This selection is available for self-describing data structures that may create inefficiencies in production due to long field names. Selection of longname or shortname, in this embodiment, may be accomplished without changes to the source code within the business services layer . Changes in the mode of operation without changes to the source code also extends to the custom application code within the subclasses of BusinessService class  described later in detail.","BusinessService class  provides an abstract definition of a business services application that uses the business services layer  as a framework. BusinessService class  is a generic superclass that may be used to provide standardized access to the back-end systems layer  for servlets and other applications. A plurality of subclasses may be included in BusinessService class  to provide data retrieval functionality for the business services application. The subclasses each represent different custom application code responsive to at least one request. Exemplary custom application code for a brokerage related business services application, for example, may include services such as OrderAdd, OrderChange, OrderCancel, InquireOrders, InquireChecking, Transfer and other brokerage related requests for data. For an insurance related business services application, for example, custom application code corresponding to requests may include CheckHealthRisk, ApplyLife, ChangeLife and any other data requests related to insurance.","The custom application code provides an interface with the back-end systems layer . This interface may extract data from the back-end systems layer  based on requests and provide the data to the business services layer . The custom application code may extract data as a function of the request parameters translated into an XML structure within the input message. In addition, the custom application code may return the extracted data as a response. The data within the response may be translated to an XML structure within the business services layer  and provided as an output message as previously described.","In the presently preferred embodiments, the output message is translated by the business services layer  from the DOM document to HTML, WML or XML-text. In other embodiments, the output message may be translated to any other presentation format, such as, for example, Microsoft\u2122 Word, plain ASCII Text, etc. Translation is preferably based on a format identified by the request or some other mechanism associated with the request. In one embodiment, the presentation format is determined by querying servlet header parameters included with the request. The servlet header parameters may indicate the type of presentation format compatible with the corresponding delivery technology within the end-users system layer .","If, for example, the servlet header parameters indicate a Microsoft\u2122 browser is used as the delivery technology, XML-text may be returned (given the ability of Microsoft Internet Explorer\u2122 to display XML text). Alternatively, if for example, the servlet header parameters indicate an HTML or WML compatible browser, the output message may be translated to HTML or WML.","Translation of the output message from the XML based structure to an output presentation may be performed using the XSL script . The translation involves the XSL processor API and at least one XSL stylesheet. In one embodiment, an XSL sylesheet is available for translation of each presentation format available. For example, the XSL stylesheet for HTML output is utilized to translate the DOM document to HTML presentation format.","During operation, the basic flow of processing when a request is received by the business services layer  proceeds as follows: (1) Determination of a request name; (2) translation of request parameters to an input message with at least one field; (3) execution of subclasses of BusinessService class  to extract data from the back-end systems layer  based on the input message; and (4) creation and translation of an output message with at least one field to a desired format.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 3","FIG. 2"],"b":["16","16"]},"Processing within the business services layer  begins at block  with the receipt of a request from the front-end systems layer .","Determination Of A Request Name","Upon receiving the request, a doGet method of ApiService class  is executed at block . The doGet method manages the entire execution of request processing by first identifying a request name at block . The request name is identified based on the value of the request name parameter contained within the request. The request name parameter of one embodiment includes one of a plurality of possible predetermined strings. The predetermined strings are preferably predefined to represent different requests selectable by the end-user systems layer  from the front-end systems layer . In addition, the predetermined strings correspond to subclasses within the BusinessService class . In other embodiments, the request name parameters may include integers, characters or any other technique for uniquely identifying different requests.","Using the identified request name, an instance of a corresponding subclass of BusinessService class  is instantiated at block . The corresponding subclass is instantiated by a createInstance method of BusinessService class . The createInstance method preferably uses a Java Reflection application programming interface (API) to find a class with the same request name as the value of the request name parameter. The Java Reflection API supports dynamic retrieval of information about classes and data structures by name, and allows for their manipulation within an executing Java program. The createInstance method instantiates the class and passes a reference to the instance back as a subclass of BusinessService class . The reference is in the form of a name that is the same as the request name.","Translation Of Request Parameters To An Input Message","Using the instance of the subclass of the BusinessService class , the doGet method calls a createInputMessage method of the BusinessService class  at block . At block  the createInputMessage method creates an input message in XML format that is compatible with the instance of the subclass of the BusinessService class . In one embodiment, the createInputMessage method creates an instance in a subclass of Message class , and labels the input message with a message name that is the name of the instance of the subclass of BusinessService class  plus the suffix \u201c_REQUEST\u201d.","Referring now to , at block , a constructor for Message class  creates a first DOM document within an instance of the DOM Document class. The first DOM document represents the input message. The constructor for Message class  sets a root element node of the first DOM document to be a new Field (DOM Element) at block . At block  a createField method of Message class  is executed in ApiService class . The createField method creates the input message by adding element nodes and corresponding text nodes in the first DOM document. The element and textnodes are created as a function of the tags present in the request. The createField method also sets the text nodes to the unit of data associated with each of the tags in the request. The createField method is preferably provided in a plurality of different versions in Message class  as detailed in the computer program listing appendix filed herewith. The plurality of different versions may support different datatypes such as, for example, the previously described short integer, long integer, Boolean, string and group datatypes.","In one embodiment, one version of the createField method is used to create fields for the input message from the request. Specifically, only the createField (String, String) version is used to create element nodes for each tag and set each of the text nodes to the corresponding unit of data. One version of the createField method is used in this embodiment since the text node of each element is set to all the text (unit of data) identified by a tag in the request regardless of datatype. Accordingly, this embodiment does not make use of the datatypes included in MESSAGEDEFINITION class . In other embodiments, the datatype may be used to execute different versions of the createField method as a function of the datatype. A plurality of versions of the createField method may be used during processing to create the output message as discussed in detail later.","At block  the createField method creates an instance of Field class . The instance of the Field class  wraps an instance of DOM Element class. Wrapping DOM Element class involves the constructor for Field class  storing a reference to the new field (DOM Element) passed to Field class  in an instance variable. The createField method sets a tag \u201cmessage\u201d as the field name for the root element node forming the top level in the DOM virtual tree hierarchy at block .","At block , a setAttribute method in Field class  is executed. The setAttribute method is a wrapper for the DOM setAttribute method of DOM Element  class. Similar to the previously discussed createField method, the setAttribute method is provided in a plurality of different versions in Field class  as detailed in the computer program listing appendix filed herewith. The plurality of different versions may support different datatypes such as, for example, the previously described short integer, long integer, Boolean, string and group datatypes. In one embodiment, one version of the setAttribute method is used to set attributes for the root element of the input message. In this embodiment, only the setAttribute (String, String) version is used since the attribute node of the root element is set to all the attributes within the tag regardless of datatype. It should be noted by the reader that the remaining elements (tags) in the request of this embodiment do not include attribute nodes. In other embodiments, however, the request may include elements with attribute nodes. In addition, the reader should note that a plurality of versions of the setAttribute method may be used during processing to create the output message as discussed in detail later.","Referring now to , the attribute node of the root element node is set by a version of the setAttribute method in Field class  at block . More specifically, an attribute name of the attribute node is set to \u201cname\u201d and an attribute value is set to the message name of the input message (e.g. (message name)_REQUEST). Setting the root element node to the message name establishes the basic structure of the input message as an XML structure (one element, with all the remaining fields contained as sub elements). Setting the root element node also ensures that messages are compliant with the XML standard of having a single root element.","The string literals (datatype=string) used in both the createField method and the setAttribute method are preferably loaded from a static declaration of the datatype contained in MESSAGEDEFINITION class . The static declaration of the datatype identifies the format used for translation of the request parameters to the input message.","At block  a pickName method of Message class  is executed. The pickName method operates to pick the version of the field name as a function of the mode debug flag. The selected version of the field name is utilized when adding tag names to the input message as previously discussed.","The doGet method of ApiService class  processes the request parameters passed in the request and uses the createField method to create additional fields (element nodes and text nodes) at block . Because the root element node of the input message was previously created, these invocations of the createField method append the new fields as children to the \u201cmessage\u201d field name.","Execution Of Subclasses of BusinessService Class ","At block , the translation of request parameters to form the input message is complete and the doGet method of ApiService class  calls a Launch method of BusinessService class . The Launch method executes a createOutputMessage method of BusinessService class  at block .","Referring now to , at block , the createOutputMessage method creates an output message in an instance of a subclass within Message class  similar to the createInputMessage method previously described. The output message is labeled with the same message name as the input message except that the suffix added is \u201c_REPLY.\u201d The constructor for Message class  creates a second DOM document within an instance of the DOM Document class at block . The second DOM document represents the output message.","At block , the Launch method calls a serviceMain method. The serviceMain method is an abstract method in BusinessService class , which gets overloaded by the subclass of BusinessService class  corresponding to the request and response. Overloading describes the condition where a method (serviceMain method) includes multiple implementations in different subclasses (the subclasses of BusinessService class ), where each implementation provides functionality pertaining to the corresponding subclass.","When the serviceMain method gets overloaded, custom application code is executed at block . The custom application code is identified by the request name in the request. Execution of the custom application code associated with the subclass of BusinessService class  is directed by the serviceMain method. At block , the custom application code reads the XML structured first DOM document representing the input message and extracts the request parameters therefrom. The custom application code uses the request parameters in the first DOM document to extract data from the back-end systems layer  at block .","Referring now to , at block , the custom application code provides the extracted data to the business services layer  as a response to the input message. The createField method of Message class  is again executed at block  for each unit of data in the response. A plurality of versions of the createField method are available to simplify the conversion of the units of data in the response to the fields in the second DOM document representing the output message. Selection of the version of the createField method is based on the datatype of each unit of data. In one embodiment, the datatype of units of data may be short integer, long integer, Boolean, string or group. In other embodiments, greater or fewer datatypes may be included. Selection of the datatype is performed as part of developing the custom application code.","At block , the selected versions of the createField method create fields for the second DOM document. In addition, as a function of the version of the createField method, the corresponding text nodes are set to the unit of data. The fields are created to form the output message in similar fashion to the input message previously discussed. The selected versions of the setAttribute method of Field class  set the appropriate attributes for the newly created fields at block . Similar to the createField method, selection of the version of the setAttribute method is based on the datatype of each attribute value. In one embodiment, the datatype of attribute values may be short integer, long integer, Boolean, string or group. In other embodiments, greater or fewer datatypes may be included. The resulting output message is returned from the serviceMain method and, ultimately, from the Launch method.","Creation and Translation Of An Output Message To Desired Format","Once the Launch method completes, the doGet method of ApiService class  resumes control and initiates translation of the output message at block . Referring now to , at block , the request is checked to determine if the output message should be translated to XML-text format. If yes, a generateXML method within Message class  is executed at block . The generateXML method wraps an XML serializer to provide a textual representation of the virtual tree. At block  the second DOM document representing the output message is translated to XML-text by the generateXML method. The translated output message is returned to the end-user systems layer  via the front-end systems layer  at block .","If the output message should not be translated to XML-text format, the doGet method calls a precompileStylesheet method of Message class  at block . The precompileStylesheet method pre-compiles an XSL stylesheet used in translation from XML to the desired presentation format, such as, for example, HTML. At block , the doGet method executes a generatePresentation method of Message class . The generatePresentation method processes the output message with the pre-compiled XSL stylesheet to complete the translation to the desired presentation format at block . Both the precompileStylesheet method and the generatePresentation method wrap the XSL processor API and its associated methods. At block , the translated output message is returned to the end-user systems layer  via the front-end systems layer .",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 9","FIG. 2"],"b":["10","48","48","172","172","174","176","18","178","172","172"]},"In the exemplary embodiment, DirLister class  is initiated by a request to read the contents of a directory within the datafile . In this example, the datafile is is organized in a well-known data hierarchy which includes files contained in one or more directories and associated subdirectories. As a function of the request, DirLister class  may return data pertaining to the names, sizes, and modification dates of the files and subdirectories contained in the directory requested. Further, DirLister class  may also recursively retrieve similar data from files within the subdirectories associated with the directory requested. In this example embodiment, the amount of information returned for each file, as well as the traversal approach is selectable within the request.","Referring now to , a user desiring information on a directory in the datafile  accesses the e-conmmerce software architecture  using delivery technologies within the end-user systems layer . A request with the request name \u201cDirLister \u201d is made via the front-end systems layer . The request includes request parameters indicating the directory of interest and selection of the amount of data desired. An exemplary request is:\n\n","The request is translated by the business services layer  to an input message with the message name \u201cDirLister_Request.\u201d","An exemplary input message supported by DirLister class  is:",{"@attributes":{"id":"p-0096","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<message name=\u201dDirLister_REQUEST\u201d>"]},{"entry":[{},"<path>path name of directory<\/path>"]},{"entry":[{},"<short>true<\/short>"]},{"entry":[{},"<long>false<\/long>"]},{"entry":[{},"<info>false<\/info>"]},{"entry":[{},"<deep>false<\/deep>"]},{"entry":[{},"<\/message>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["48","172"]},"The corresponding Message\/Field object structure is:",{"@attributes":{"id":"p-0098","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Message \u201cDirLister_REQUEST\u201d"]},{"entry":[{},"!"]},{"entry":[{},"+---Field \u201cpath\u201d"]},{"entry":[{},"+---Field \u201cshort\u201d"]},{"entry":[{},"+---Field \u201clong\u201d"]},{"entry":[{},"+---Field \u201cinfo\u201d"]},{"entry":[{},"+---Field \u201cdeep\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The representative first DOM document is:",{"@attributes":{"id":"p-0100","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"!"]},{"entry":[{},"+---Element \u201cmessage\u201d"]},{"entry":[{},"\u2003\u2003\u2002!!"]},{"entry":[{},"\u2003\u2003\u2002!+---Attributes \u201cname=DirLister_REQUEST\u201d"]},{"entry":[{},"\u2003\u2003\u2002!"]},{"entry":[{},"\u2003\u2003\u2002+---Element \u201cpath\u201d"]},{"entry":[{},"\u2003\u2003\u2002!!"]},{"entry":[{},"\u2003\u2003\u2002!+---TextNode \u201cpathname of directory\u201d"]},{"entry":[{},"\u2003\u2003\u2002!"]},{"entry":[{},"\u2003\u2003\u2002+---Element \u201cshort\u201d"]},{"entry":[{},"\u2003\u2003\u2002!!"]},{"entry":[{},"\u2003\u2003\u2002!+---TextNode \u201ctrue\u201d"]},{"entry":[{},"\u2003\u2003\u2002!"]},{"entry":[{},"\u2003\u2003\u2002+---Element \u201clong\u201d"]},{"entry":[{},"\u2003\u2003\u2002!!"]},{"entry":[{},"\u2003\u2003\u2002!+---TextNode \u201cfalse\u201d"]},{"entry":[{},"\u2003\u2003\u2002!"]},{"entry":[{},"\u2003\u2003\u2002+---Element \u201cinfo\u201d"]},{"entry":[{},"\u2003\u2003\u2002!!"]},{"entry":[{},"\u2003\u2003\u2002!+---TextNode \u201cfalse\u201d"]},{"entry":[{},"\u2003\u2003\u2002!"]},{"entry":[{},"\u2003\u2003\u2002+---Element \u201cdeep\u201d"]},{"entry":[{},"\u2003\u2003\u2002!"]},{"entry":[{},"\u2003\u2003\u2002+---TextNode \u201cfalse\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Within an instance of DirLister class , the request parameters from the input message are used by the custom application code to extract data from the datafile . The units of data within the input message for those fields not common to all input messages are defined by DirLister_Request class . As previously discussed, MESSAGEDEFINITION class  includes the field names and indicates the expected datatype for those fields common to all input messages. DirLister_Request class  operates similarly and includes those fields specific to requests directed to DirLister class .","Depending on the status of the mode debug flag, DirLister class  may use either shortname or longname as the field names. The shortname and longname field names are defined in DirLister_Request class  and MESSAGEDEFINITION class . For example, if the field name \u201cpath\u201d is the longname and \u201cb\u201d is the short name, the above input message could have the fieldname translated to \u201cb \u201d to facilitate efficient transmission to DirLister class .","As a function of the request parameters, DirLister class  generates a response that is hierarchical representation of the directory contents. The response is translated to an output message using definitions for the units of data and shortname and longname field names from DirLister_Reply class  and MESSAGEDEFINITION class . An exemplary output message is:",{"@attributes":{"id":"p-0104","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<message name=\u201dDirLister_REPLY\u201d>"]},{"entry":[{},"<directory shortname=\u201dSample\u201d>"]},{"entry":[{},"<file shortname=\u201dpatent.doc\u201d\/>"]},{"entry":[{},"<file shortname=\u201dpictures.ppt\u201d\/>"]},{"entry":[{},"<directory shortname=\u201dsource\u201d unexpanded=\u201ctrue\u201d\/>"]},{"entry":[{},"<\/directory>"]},{"entry":[{},"<\/message>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"To generate the output message, the serviceMain method calls a traverse method of DirLister class . The traverse method determines what the \u201cpath\u201d field name is associated with. If the data is identified as a directory, the directory is traversed by the traverse method. Conversely, if the data is a file, the desired data is extracted as a function of the selected request parameters. To traverse the directory, a traverse method within DirLister class  is initialized. The traverse method recursively traverses the directory tree.","In one embodiment, both the traverse method and the traverse method use Java APIs and associated classes to read in the data and form a response. Operation of the Java APIs and associated classes of the traverse and traverse methods are unassociated with the operation of the core classes within the business services layer . As such, the traverse and traverse methods may be built to operate within the framework provided by the business services layer  without affecting the functionality of the core classes within the business services layer .","For every directory entry read, a createEntry method of DirLister class  is called to generate the appropriate field and attributes in the output message. The createEntry method calls the createField method of Message class  to add fields to the second DOM document. In addition, the createEntry method calls the setAttribute method of Field class  to set the appropriate attributes on each of the newly created fields. The resulting output message is returned from the serviceMain method and, ultimately, from the Launch method of BusinessService class .","The presently preferred embodiments of the business services layer  are designed to provide a foundation, or framework for building e-commerce architectures. Building of messages and extracting data from messages is simplified through leveraging XML based messaging with the business services layer . The business services layer  provides a design pattern for building business service applications using the DOM class and XML technology while avoiding exposure to most of the complexities otherwise associated therewith. By confining the configuration requirements to Message class  and Field class , the creation of XML-based business service applications is relatively easy. Further, changes and additions to business service applications built around the framework provided by business services layer  may be accomplished with relatively minor changes to Message class  and Field class . The conveniences associated with using the business services layer  allows simplification in transferring messages between the front-end systems layer  and the back-end systems layer  within a business services application without the complexities normally associated with XML based applications.","It is to be understood that a wide range of changes and modifications to the embodiments described above will be apparent to those skilled in the art and are contemplated. It is therefore intended that the foregoing detailed description be regarded as illustrative, rather than limiting, and that it be understood that it is the following claims, including all equivalents, that are intended to define the spirit and scope of the invention."],"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTICE REFERENCE","COMPACT DISC\/COPYRIGHT REFERENCE.","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF TH INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 7","FIG. 3"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 8","FIG. 3"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 9","FIG. 2"]}]},"DETDESC":[{},{}]}
