---
title: Column constraints based on arbitrary sets of objects
abstract: Techniques for using arbitrary sets of objects to constrain objects in database systems. The constraint set of objects is associated with the constrained object in the database system and the database system will perform an operation which adds an object to the constrained object only if the object being added belongs to the constraint set. In a preferred embodiment, the techniques are employed to obtain constraint sets of terms from ontologies which are then used to constrain columns containing those terms. An implementation of the techniques makes a materialized view out of the objects in the constraint set and uses the materialized view to define a referential integrity constraint on the constrained column.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08214354&OS=08214354&RS=08214354
owner: Oracle International Corporation
number: 08214354
owner_city: Redwood Shores
owner_country: US
publication_date: 20060331
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","REFERENCE TO A SEQUENCE LISTING","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","CONCLUSION"],"p":["U.S. Ser. No. 10\/916,547, System for ontology-based semantic matching in a relational database system, which has the same inventors and assignee as the present patent application and U.S. Ser. No. 11\/108,204, Integrating RDF data into a relational database system, which has the same inventors and assignee as the present patent application are hereby incorporated by reference into this patent application for all purposes.","Not applicable.","Not applicable.","1. Field of the Invention","The present invention relates generally to database management systems and more particularly to techniques for defining constraints on columns in database management systems.","2. Description of Related Art","Relational database systems have become increasingly robust with many features that insure the integrity of the data stored within the columns of tables of a database instance. The means of ensuring the integrity of data are a set of business rules defined by the application developer and are referred to as Integrity Constraints in the database system.","There are many types of integrity constraints; the most relevant type for the present discussion is referential integrity constraints. A referential integrity constraint is a constraint which maintains consistency between coupled tables. A value from a key column in a first one of the coupled tables is used as a value in a non-key column of a second one of the coupled tables. The value from the key column is termed the parent key; the key value in the non-key column of the other table is termed the foreign key. A referential integrity constraint requires that every foreign key value in the non-key column of the second table have a value which is equal to the value of one of the keys in the key column. A consequence of the rule is that when keys are added to or deleted from the key column in the first table, there may be effects on the foreign key values in the second table. The rules for dealing with these effects are:\n\n",{"@attributes":{"id":"p-0010","num":"0014"},"figref":"FIG. 1","b":"105"},"Tables  and  are coupled by a referential constraint, as shown by arrow . The primary key values in column DNAME () are parent keys. The foreign keys which have the values of the parent keys are values in column DNAME (). The referential integrity constraint guarantees that every value in the column () already exists as a value in the column (). Because of the constraint, the relational database system handles inserts in a manner that ensures data integrity. Insert  violates the referential integrity constraint in that the value \u2018MARKETING\u2019 for the column DNAME () cannot be found in the rows of column (). The referential integrity constraint further enforces rules concerning what occurs in EMP table  when a row containing a DNAME () has the corresponding row deleted from DEPT table .","What a referential constraint does in general terms is constrain DNAME column () such that all of the values in DNAME column () must be selected from the set of values defined by the values of DNAME column (). There are many contexts other than parent keys and foreign keys where it would be desirable to constrain a column such that the values in the column had to be selected from a dynamic set of values, that is, a set of values whose member values were not known until the time the constraint was enforced. In the following, such constraints will be generically termed dynamic set constraints. At present, the only dynamic set constraints which are supported in relational database systems are referential constraints. It is an object of the invention disclosed herein to provide a relational database system which supports other kinds of dynamic set constraints.","One kind of dynamic set constraint which is particularly useful is one in which the dynamic set is a set of terms that belong to a domain in an ontology. For purposes of the following discussion, ontology and domain are defined as follows:\n\n",{"@attributes":{"id":"p-0014","num":"0019"},"figref":"FIG. 2","b":["204","201","203","205","207","209","203","205"]},"As will be explained in more detail below, a set of departments defined in the ontology may be used as a constraint on column DNAME () or on column DNAME (). For example, if EMP table  were a table of engineering employees, column DNAME () could be constrained such that a row for an employee could be added to the table only if his or her department was Engineering, Software, or Hardware.","Within the RDBMS, an ontology can be represented using Resource Description Framework (RDF). RDF is a language that was originally developed for representing information (metadata) about resources in the World Wide Web. It may, however, be used for representing information about absolutely anything, including ontologies. U.S. Ser. No. 11\/108,204, Integrating RDF data into a relational database system, discloses how this may be done.","U.S. Ser. No. 11\/108,204 discloses the integration of RDF into SQL by means of a set of tables and user objects that represent RDF data sets and a table function RDF_MATCH that takes a specification of an RDF data set and an RDF pattern as parameters and returns a set of result rows of triples from the RDF data set that match the RDF pattern. The solution of the RDF pattern may include inferencing based on RDFS and user-defined rules.","The signature of RDF_MATCH is as follows:",{"@attributes":{"id":"p-0019","num":"0024"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RDF_MATCH ("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pattern","VARCHAR,"]},{"entry":[{},"Models","RDFModels,"]},{"entry":[{},"RuleBases","RDFRules,"]},{"entry":[{},"Aliases","RDFAliases,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},")"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RETURNS AnyDataSet;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0020","num":"0025"},"figref":["FIG. 3","FIG. 2"],"b":["305","223","307","307","316","305","309","307"]},"It should be noted that the contents of the result rows returned by RDF_MATCH will depend on the RDF pattern used in the query and the RDF data against which the query is run. For this reason, the return type for RDF_MATCH has been defined as AnyDataSet, which is a collection of tuples of a generic type called AnyData. When an SQL query employs the RDF_MATCH table function, components of the query such as its SELECT, WHERE, ORDER BY, etc., clauses can reference the variables present in the RDF pattern simply by the variable names.","An advantage of using the RDF_MATCH table function in a SELECT statement to query RDF data is that any SQL construct that can be used with a SELECT statement can be used to further process the result rows  returned by RDF_MATCH. These constructs include iterating over the result rows, aggregating values contained in the result rows, constraining the result rows using WHERE clause predicates, sorting the result rows using ORDER BY clauses, and limiting the result rows by using the ROWNUM clause. Also, the SQL set operations can be used to combine result sets of two or more invocations of RDF_MATCH. In SELECT statement , the WHERE clause limits the triples to those for students whose age is less than 25. The output of the SELECT statement is shown at .","An Ontology can be accessed using the new SQL operators disclosed in U.S. Ser. No. 10\/916,547, System for ontology-based semantic matching in a relational database system. The new operators are named ONT_RELATED, ONT_EXPAND, ONT_DISTANCE, and ONT_PATH. These operators may be used directly in SQL statements, and thus allow database users to combine these semantic matching operators with other conventional SQL operations such as joins to make use of the full expressive power of SQL while performing semantic based matching. Prior to executing a query containing the semantic matching operator, the specified ontology is expressed in RDF and represented in the database system as described in U.S. Ser. No. 11\/208,204. The operators, explained using ontology  of , are the following:","The ONT_RELATED operator performs ontology-based semantic matching and is expressed within an SQL statement using an expression of the form: \u201cONT_RELATED (term1, reltype, term2, ontology).\u201d When executed, the ONT_RELATED operator determines whether the two input terms (term1 and term2) are related by the specified relationship type \u201creltype\u201d by consulting the ontology. Thus, ONT_RELATED (Software, subDepartmentOf, Management, Department_Ontology) will return TRUE, because the subDepartmentOf relationship (modeled using subClassOf property) is transitive, and consequently, if Software is a subdepartment of Engineering and Engineering is a subdepartment of Management, then Software is a subdepartment of Management as well.","Two ancillary operators, ONT_PATH and ONT_DISTANCE, are employed to determine additional measures for pairs of terms belonging to the ontology, namely, the shortest path connecting two terms and the length of the shortest path, respectively.","The ONT_EXPAND Operator.","This operator returns rows representing a set of terms in the ontology. The terms to be returned are indicated by parameters that specify a first term, a second term, and a relationship between the first and second term. The specified relationship may be either a simple relationship or combination of them. The following is an example of the operator's declaration:",{"@attributes":{"id":"p-0027","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CREATE TYPE ONT_TermRelType AS OBJECT ("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Term1Name VARCHAR(32),"]},{"entry":[{},"PropertyName VARCHAR(32),"]},{"entry":[{},"Term2Name VARCHAR(32),"]},{"entry":[{},"TermDistance NUMBER,"]},{"entry":[{},"TermPath VARCHAR(2000)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CREATE TYPE ONT_TermRelTableType AS TABLE OF"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"ONT_TermRelType;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ONT_EXPAND (Term1, RelType, Term2, OntologyName"]},{"entry":[{},"\u2002) RETURNS ONT_TermRelTableType;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Typically, non-NULL values for RelType and Term2 are specified as input and then the operator computes all the appropriate <Term1, RelType, Term2> tuples in the closure taking into account the characteristics (transitivity and symmetry) of the specified RelType. In addition, it also computes the relationship measures in terms of distance (TermDistance) and path (TermPath). For cases when a term is related to input term by multiple paths, one row per path is returned. It is also possible that ONT_EXPAND invocation may specify input values for any one or more of the three parameters or even none of the three parameters. In each of these cases, the appropriate set of <Term1, RelType, Term2> tuples is returned.","The term1, reltype, and term2 can have either a specific input value or NULL value. The NULL means all possible values. For example, ONT_EXPAND (NULL, subDepartmentOf, Engineering, Department_Ontology) will generate all nodes that are related by the subDepartmentOf relationship to the node Engineering, namely the nodes Software and Hardware.","Objects of the invention include providing techniques for defining column constraints in terms of arbitrary sets of values and providing techniques for dealing with the effects of changes in the set of values used to define the constraint on the values in the column subject to the constraint, as well as providing techniques for defining column constraints in terms of sets of values obtained by queries on ontologies.","The objects of the invention are obtained by a technique that is used in the database system to associate a constrained object with an arbitrary constraint set of objects that are possible values of the constrained object. When an operation in the database system adds a value to the constrained object, the operation is permitted only if the added value is a member of the constraint set. The constraint set may be specified by a query that is executed in the database system. The query may include a table function.","In one aspect, the technique employs referential integrity constraint mechanisms provided by the database system. The constrained object is a column that is defined in the database system. The technique makes a materialized view with a column whose values are members of the constraint set and then uses the materialized view to define a referential integrity constraint for the constrained column.","In another aspect, when an operation in the database system results in a new constraint set, a variety of responses may be specified when the constraint set is associated with the constrained object. Operations that alter the constraint set may be barred or the database system may change values in the constrained object when the constraint set is altered. Changes may include setting a value which is in the constrained object but not in the new constraint set to NULL, setting it to a default value, and using a transform function to transform a value which is not in the new constraint set into a value which is in the new constraint set. The transform function may return a number of possibilities for transforming a value which is not in the new constraint set. In that case, the techniques permit user selection of one of the possibilities.","The constraint set may be derived from any source of objects; however, in one species of the invention, the constraint set is a set of terms from an ontology. The query that is used to obtain the constraint set from the ontology returns terms that stand in a defined relationship to each other in the ontology and the constraint set is used to limit terms in a keyword column to terms that belong to the part of the ontology that was returned by the query.","Other objects and advantages will be apparent to those skilled in the arts to which the invention pertains upon perusal of the following Detailed Description and drawing, wherein:","Reference numbers in the drawing have three or more digits: the two right-hand digits are reference numbers in the drawing indicated by the remaining digits. Thus, an item with the reference number  first appears as item  in .","The following Detailed description will first present an overview of a species of the invention in which the set of objects that is used to constrain the column is obtained from an ontology and will then present details of a preferred embodiment of the species. In the following, the species will be termed an \u201contology-based referential constraint\u201d.","Ontology-Based Referential Constraints","Traditional referential integrity constraints are specified by SQL syntax of the form \u2018<column a> REFERENCES <table b> (<column c>)\u2019, where <column a> is a foreign key and <column c> contains parent keys in <table b>. The database system ensures that the <column a> only contains values that are also present in <column c>.","This SQL syntax is extended to support ontology-based referential integrity constraints as follows:\n\n",{"@attributes":{"id":"p-0049","num":"0055"},"figref":"FIG. 4","b":["401","401","405","105","407","409","109","105","411","109","411","201","203","201","415","419","203"],"i":["ii","ii"]},"While ONT_EXPAND provides a useful functionality, its parameters are limited to expressing an RDF pattern that contains a single triple. The RDF_MATCH table function can be used for RDF patterns containing more than one triple. For example, assume that a user of a database system wants to create a journal article table for journal articles concerning macromolecules. The table will have a row for each journal article. The table's columns will include a column <chemical_compound> whose values are keywords for the classes of chemical compounds that the articles are written about, such as \u2018Proteins\u2019 and \u2018Polypeptides\u2019. The values contained in the column chemical_compounds are to be taken from terms which are subclasses of the class Macromolecules in the Pathway\/Genome ontology BioCyc, see www.biopax.org.","SQL statement  creates an ontology-based referential constraint which limits the terms used in the column chemical_compound to terms which are in fact subclasses of the class Macromolecules in the ontology. The referential constraint's SELECT clause uses the RDF_MATCH table function with an RDF pattern consisting of a single triple that returns all terms that are subclasses of Macromolecules.","If the user wants to further restrict the <chemical compounds> column to compounds that are subclasses of both the class \u2018Proteins\u2019 and the class \u2018Complexes\u2019, the user may issue a query like query . There, the RDF pattern used in RDF_MATCH at  contains two triples. The terms that satisfy the pattern are terms that are subclasses of both \u2018Proteins\u2019 and \u2018Complexes\u2019 . In the following, a column which is subject to dynamic set constraint such as an ontology-based referential constraint will be termed a constrained column and the set of objects which constrains the values in the constrained column will be termed the constraint set. Though the constraint set may come from any source, it is typically the result of a query.","An Efficient Implementation of Ontology-Based Referential Constraints: ","A na\u00efve implementation of an ontology-based referential constraint is inefficient in that each insert or update of a value in a column that is subject to the ontology-based referential constraint requires the execution of a query on the ontology to produce a constraint set from which the database system may determine whether the inserted or updated value violates the constraint. To allow for more efficient processing of inserts and updates subject to ontology-based referential constraints, a materialized view is used to store the constraint set in persistent storage.","In a relational database system, the execution of a SELECT statement returns a table containing the results of the query defined by the SELECT statement. The table returned by the query is termed a view. Ordinarily, a view is stored in non-persistent storage. A materialized view is a view whose data is stored in persistent storage. Because the materialized view is stored in persistent storage, the materialized view has an entry in the database system's data dictionary and the values in a column of the materialized view may serve as parent keys for a standard referential constraint.","Constraint enforcement diagram  shows how a materialized view and a standard referential constraint may be used to implement an ontology-based referential constraint. Keyword column  is constrained by an ontology-based referential constraint . Ontology-based referential constraint  executes a query against ontology . The result set returned by the query is the ontology-based referential constraint's constraint set. The constraint set is made into a materialized view . The materialized view is a table with a single column that contains the values of the constraint set. A conventional referential constraint  is then defined for keyword column  in which the terms in the single column of the materialized view are the parent keys for the terms in keyword column . Conventional referential constraint  is then enforced on keyword column  in the usual fashion: Whenever a new value appears in keyword column , conventional referential constraint  is enforced based on the contents of materialized view . As will be explained in more detail later, Journal Table  records changes to materialized view . It is used when ontology  is modified.","It should be pointed out here that the technique of  is general and can be used to implement any kind of dynamic set constraint. All that is required is a mechanism for making the values of the dynamic set constraint's constraint set into an RDBMS view. Once that has been done, the view can be materialized and the dynamic set constraint can be implemented using the conventional referential constraint.","Ontology Update Semantics: ","When an ontology that provides constraint sets is modified, the constraint sets may get modified as a result and then, to maintain the referential integrity constraints, changes may need to be made to the columns that are constrained by the constraint sets. The present invention provides techniques for handing any such changes that may become necessary due to modifications to constraint sets caused by modifications of ontology data. The techniques are supported by extensions to the SQL statements that define ontology-based referential constraints which permit the user to define actions to be performed on values in the constrained column when modification of the ontology results in constraint set modification. These extensions have the form:\n\n","Ontology-based referential constraint definition  is referential constraint definition  with the addition of the \u2018ON DELETE\u2019 clause . Clause  specifies that on deletion of an element from the constraint set (caused by modification to Department_Ontology ) a value in the column DNAME in the user table EMP  which is the same as the value that is being deleted from the constraint set will be replaced with a NULL value. EMP table  contains a number of records where the DNAME column contains the value Manufacturing belonging to the constraint set. A delete from ontology  of the MANUFACTURING department will result in deletion of the MANUFACTURING department from the constraint set and this will cause the clause  to be executed. The execution will search for the value MANUFACTURING in the column DNAME of user table EMP  and set them to NULL, as shown at  in updated EMP table .","Referential constraint definition  is a version of referential constraint definition  wherein \u2018ON DELETE TRANSFORM\u2019 clause  is being used to specify that a function find_broader_term be executed on a deletion from the constraint set (caused by a modification of Department_Ontology ). Function find_broader_term  finds a term which is still in the ontology and which is broader than the deleted term. The function is defined at line  and receives as input arguments O, R) and dterm. Ois the ontology prior to modification. Ris the constraint set after modification of the ontology, and dterm is the value of the deleted value. Function find_broader_term  starts at line  by applying the deleted term to the constraint set O(), starting from the position of the deleted term in Oand moving up Ountil it finds a broader term that is in R. The function returns a result set of the nearest ancestors in Rof the value deleted from the ontology (. The returned result set could be NULL, indicating no replacements could be found, or a (possibly singleton) subset of R. If a single replacement value is returned by the function, then the actual replacement can take place, automatically updating table . Otherwise, the set of replacement values may be stored in recommendation table .","Using ontology  as an example, deleting the \u2018Quality Assurance\u2019 department from the ontology leads to deletion of that term from the constraint set and that results in a search for broader terms. The search would return the next broader term, which is MANUFACTURING , to replace \u2018Quality Assurance\u2019 in updated EMP table . If more than one possible term were returned by the function, for example, if \u2018Quality Assurance\u2019 reported to more than one department, perhaps MANUFACTURING, then the two possible changes - would be inserted into recommendation table .","Changes to the ontology may cause insertion of terms into the constraint set and this may also cause a search for recommendations to replace current data. For example, if two new departments are added to Department_Ontology  under Hardware, that results in addition of those two departments into the constraint set, then a recommendation based on results returned by find_refined_term  of referential constraint definition  is executed. The addition of the two new departments causes recommendation table  to have the two departments \u2018Board Design\u2019  and \u2018Chip Design\u2019  added as possible new values of the DNAME column in the row for employee , who was previously listed as belonging to Hardware.","Techniques for Modifying Ontologies and Enforcing the Consequences of the Modifications","Modifications of ontologies and the resulting modifications to the values in the constrained column can be done either in batch or incrementally. Batch modification of the values of the constrained column in response to a modification of the ontology is termed in the following batch enforcement of the constraint. In batch enforcement, the ontology-based referential constraint is disabled during batch enforcement and reenabled thereafter. With incremental enforcement of the constraint, enforcement remains enabled but is deferred until changes to the ontology are committed.","Batch Enforcement: ","For batch enforcement, additional processing is needed for both DISABLE and ENABLE constraint operations. The details are described below.","DISABLE constraint: When the ontology-based constraint is disabled, a copy of current materialized view  is created. The copy is subsequently used to identify changes in the constraint set resulting from the modification of the ontology. Also saved is current version information for the ontology.","ENABLE constraint: Let R be the copy of materialized view  made when the constraint was last disabled, and R be the current constraint set. We determine the set of deleted terms using the following query:",{"@attributes":{"id":"p-0066","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT term FROM R0"]},{"entry":[{},"MINUS"]},{"entry":[{},"SELECT term FROM R1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If the constraint has a transformation function associated with it, the transformation function is invoked for the deleted terms and the ontology version that existed when the constraint was disabled. If the transformation function yields a single result (T) for a deleted term (T), then update all instances of Tin the constrained column to T. If the transformation function yields either no terms or multiple terms, then the ROWIDs of all rows in the table with the constrained column in which the value in the constrained column is equal to Tare recorded in the recommendations table along with the transformation function results before all instances of Tin the keyword column are updated to NULL. If the constraint does not have a transformation function, then all instances of Tin the keyword column are updated to NULL.","R, the copy of materialized view  made prior to the modification of ontology , is shown at . Then ontology  is modified by removing the department \u201cHardware\u201d is removed from ontology . The result of the query of modified ontology  produces constraint set , which is the constraint set represented by R. The difference of R () and R () is result set , which contains the deleted term Hardware. If the transformation function find_broader_term  is passed result set , it produces a single new term, namely Engineering . Table EMP 's DNAME column () is now constrained by result set R . Consequently, in each row of table EMP which has the term Hardware  in the column DNAME, Hardware  is replaced with Engineering .","Similarly, to determine the effect of insertions into the ontology on the constraint set, the following query is used.",{"@attributes":{"id":"p-0070","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT term FROM R1"]},{"entry":[{},"MINUS"]},{"entry":[{},"SELECT term FROM R0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If the constraint has a refinement function we invoke it for these terms. The refinement function's results are stored in the recommendations table.",{"@attributes":{"id":"p-0072","num":"0082"},"figref":["FIG. 9","FIG. 5"],"b":["901","513","513","919","509","505","918","917","711","509","915","918","920","917","505","509","917","509","509","917","923","509","711","921","505","925"]},"Finally the underlying conventional referential constraint is enabled. If the underlying constraint had an EXCEPTIONS clause (a clause which specifies a table into which constraint violations may be written), the clause is appended to the end of the constraint creation and has syntax of:",{"@attributes":{"id":"p-0074","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ALTER TABLE EMP"]},{"entry":[{},"ADD CONSTRAINT dept_constraint"]},{"entry":[{},"FOREIGN KEY (DNAME)"]},{"entry":[{},"REFERENCES (SELECT Term1Name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FROM TABLE( ONT_EXPAND( NULL,"]},{"entry":[{},"\u2018rdfs:subClassOf \u2018, \u2018Management\u2019,"]},{"entry":[{},"\u2018Department Ontology\u2019)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EXCEPTIONS INTO Ontology_Exceptions;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"If the constraint enforcement is successful, the R result set can be dropped.","This method can also be used as part of a protocol to enforce the constraint during incremental ontology modifications. In this case the constraint would be disabled before the modification is started and enabled after the modification is completed.","Incremental Enforcement","When the materialized view changes incrementally along with incremental changes in the ontology, the conventional referential integrity constraint enforcement between the constrained table and the materialized view is altered to a deferred constraint (i.e., a constraint that's enforced only at transaction commit-time) with ON DELETE SET NULL semantics. With a deferred constraint spurious constraint violations during transient states that may exist as the materialized view changes are avoided.","Row-level triggers on the materialized view journal all changes in the constraint query result set to temporary journal table . A row-level update trigger on the constrained column is used to write orphaned values and their row's rowid to the recommendation table when the ON DELETE SET NULL behavior specified in the constraint definition sets an orphaned value to NULL. (If a keyword is updated to null by explicit Data Manipulation Language (DML) this trigger will log the keyword and its rowid to the recommendation table, however since there is no ontology update in this case the update will not be further processed by the constraint's refinement or translation mechanisms).","After the ontology has been modified (i.e., after changes to the underlying ontology tables have committed), journal table  is processed to remove idempotent operations (e.g., a term may be deleted and reinserted during materialized view maintenance). Then the appropriate calls are made to the constraint's refinement and transformation functions based on the remaining operations, and the results are propagated to the constrained column and the constraint's recommendation table.","Improved Incremental Enforcement","There are several problems with the above incremental enforcement implementation:\n\n","To address these problems, we propose introducing AFTER REFRESH and AFTER REFRESH ERROR triggers on materialized views. Such triggers would run as part of the transaction that refreshes the materialized view.","With these triggers, we can improve the incremental enforcement scheme as follows:\n\n","The techniques described above for modifying the ontology, making a new materialized view from a query on the ontology, and altering values in the constrained column as required by the new materialized view can be applied with regard to constraint sets that are obtained in any way. Appropriate mechanisms will be of course required to obtain the constraint sets. For example, if the constraint set is obtained by a query executed in the database system, the proper query must be provided. Different sources for constraint sets will also require different transformation functions or no transformation functions at all.","The foregoing Detailed Description has disclosed to those skilled in the relevant technologies how to employ arbitrary sets of objects as constraints in database systems and has further disclosed the best mode presently known to the inventors of making constraints that use arbitrary sets of objects. While the specific example set forth in the Detailed Description employs constraints based on ontologies, the technique is very general and can be used with any set of objects that are accessible to a database system. To give an example of the generality of the techniques, the set of objects could be obtained via a table function that received the objects from a user of the database system.","While the techniques are very general, the preferred embodiment is implemented in an Oracle relational database management system and the character of many of the specific features of the preferred embodiment is determined in considerable part by the fact that they are implemented in a specific relational database system. Implementations of the techniques in other database systems, including non-relational database systems, will necessarily be determined by the characteristics of the database systems in which they are implemented. An apparatus includes a processor and a storage device as a storage medium.","For all of the foregoing reasons, the Detailed Description is to be regarded as being in all respects exemplary and not restrictive, and the breadth of the invention disclosed here in is to be determined not from the Detailed Description, but rather from the claims as interpreted with the full breadth permitted by the patent laws."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0036","num":"0041"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0037","num":"0042"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0038","num":"0043"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0039","num":"0044"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0040","num":"0045"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0041","num":"0046"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0042","num":"0047"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0043","num":"0048"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0044","num":"0049"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
