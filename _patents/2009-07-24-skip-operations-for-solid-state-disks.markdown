---
title: Skip operations for solid state disks
abstract: Described embodiments provide skip operations for transferring data to or from a plurality of non-contiguous sectors of a solid-state memory. A host layer module sends data to, and receives commands from, a communication link. Received commands are one of read requests or write requests, with commands including i) a starting sector address, ii) a skip mask indicating the span of all sector addresses in the request and the sectors to be transferred, iii) a total number of sectors to be transferred; and, for write requests, iv) the data to be written to the sectors. A buffer stores data for transfer to or from the solid-state memory. A buffer layer module i) manages the buffer, ii) segments the span of the request into a plurality of chunks, and iii) determines, based on the skip mask, a number of chunks to be transferred to or from the solid-state memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08166258&OS=08166258&RS=08166258
owner: LSI Corporation
number: 08166258
owner_city: Milpitas
owner_country: US
publication_date: 20090724
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The subject matter of this application is related to U.S. patent application Ser. No. 12\/436,227 filed May 6, 2009, Ser. No. 12\/477,996 filed Jun. 4, 2009, Ser. No. 12\/478,013 filed Jun. 4, 2009, and Ser. No. 12\/508,879 filed Jul. 24, 2009, the teachings of all of which are incorporated herein in their entireties by reference. The subject matter of this application is also related to U.S. patent application Ser. No. 12\/475,710 filed Jun. 1, 2009, Ser. No. 12\/475,716 filed Jun. 1, 2009, Ser. No. 12\/643,471 filed Dec. 21, 2009, Ser. No. 12\/649,490 filed Dec. 30, 2009, Ser. No. 12\/722,828 filed Mar. 12, 2010, Ser. No. 12\/730,627 filed Mar. 24, 2010, Ser No. 12\/731,631 filed Mar. 25, 2010, Ser. No. 12\/767,985 filed Apr. 27, 2010, Ser. No. 12\/768,058 filed Apr. 27, 2010, Ser. No. 12\/769,882 filed Apr. 29, 2010 and Ser. No. 12\/769,910 filed Apr. 29, 2010.","1. Field of the Invention","The present invention relates to flash memory storage devices, and, in particular, to skip operations for solid state disks (SSDs).","2. Description of the Related Art","Flash memory is a type of non-volatile memory that is electrically erasable and re-programmable. Flash memory is primarily used in memory cards and USB flash drives for general storage and transfer of data between computers and other digital products. Flash memory is a specific type of electrically erasable programmable read-only memory (EEPROM) that is programmed and erased in large blocks. One commonly employed type of flash memory technology is NAND flash memory. NAND flash memory forms the core of the flash memory available today, especially for removable universal serial bus (USB) storage devices known as USB flash drives, as well as most memory cards. NAND flash memory exhibits fast erase and write times, requires small chip area per cell, and has high endurance. However, the I\/O interface of NAND flash memory does not provide full address and data bus capability and, thus, generally does not allow random access to memory locations.","There are three basic operations for NAND devices: read, write and erase. The read and write operations are performed on a page by page basis. Page sizes are generally 2bytes, where N is an integer, with typical page sizes of, for example, 2,048 bytes (2 kb), 4,096 bytes (4 kb), 8,192 bytes (8 kb) or more per page. Pages are typically arranged in blocks, and an erase operation is performed on a block by block basis. Typical block sizes are, for example, 64 or 128 pages per block. Pages must be written sequentially, usually from a low address to a high address. Lower addresses cannot be rewritten until the block is erased.","Other storage devices, such as conventional hard disk drives (HDDs), support additional disk-access operations, such skip-write and skip-read. A skip operation is used for reading or writing relatively closely located, but non-contiguous, blocks on an HDD. The device requesting the skip-read or skip-write provides a starting logical block address (LBA), a length count of the number of blocks to read\/write, and a skip mask. The skip mask comprises a number of bits where each bit in the mask corresponds to a block offset from the starting block address. A logic \u20181\u2019 bit in the skip mask signifies that the block corresponding to that bit position will be read\/written. A logic \u20180\u2019 bit in the skip mask signifies that the block corresponding to that bit position will not be read\/written and will be skipped. The length count comprises the total number of blocks to transfer, not the span of the request. Thus, the length count matches the total number of logic \u20181\u2019 bits in the skip mask. HDDs process skip commands at a media layer of the network, for example corresponding to a layer in the OSI (\u201cOpen Systems Interconnection\u201d) model. A skip operation is useful for reading or writing several non-contiguous memory locations without issuing separate requests and requiring additional revolutions of the HDD. Further, only the requested data is transferred to or from the HDD.","A hard disk is addressed linearly by logical block address (LBA). A hard disk write operation provides new data to be written to a given LBA. Old data is over-written by new data at the actual LBA. NAND flash memories are accessed analogously to block devices, such as hard disks. NAND devices address memory linearly by page number. However, each page might generally be written only once since a NAND device requires that a block of data be erased before new data is written to the block. Thus, for a NAND device to write new data to a given LBA, the new data is written to an erased page that is a different physical page from the page previously used for that LBA. Therefore, NAND devices require device driver software, or a separate controller chip, to maintain a record of mappings of each LBA to the current page number where its data is stored. This record mapping is typically performed by a flash translation layer (FTL) in software that might generate a logical to physical translation table. The flash translation layer corresponds to the media layer of software controlling an HDD.","Associated with each page is a spare area (typically 100-500 bytes) generally used for storage of error correction code (ECC) information and for storage of metadata used for memory management. The ECC is for detecting and correcting errors in the user data stored in the page, and the metadata is used for mapping logical to physical addresses and vice-versa. As such, the additional bytes of memory are \u201chidden\u201d from the user and are not available for storing data. The first block (block ) of a flash die is generally provided from the manufacturer error-free, and is commonly used by designers to include program code and associated metadata for block management.","Typically, for high capacity solid state disks (SSDs), several design tradeoffs might be considered when implementing a method to maintain a logical to physical translation table. These tradeoffs typically include: efficient random access memory (RAM) usage; efficient flash usage; fast address lookup for both read operations and write operations; and fast reconstruction of the translation table on device startup.","Several techniques are known in the art for maintaining the logical to physical translation table. One such approach is known as direct page mapping, an example of which is described in the paper by Andrew Birrell & Michael Isard, et al., A DH-PFD,Vol. 41,Issue 2,pp. 88-93,(April 2007), which is incorporated herein by reference in its entirety (hereinafter \u201cBirrell\u201d). Direct page mapping maintains a lookup table in RAM having an entry for each flash page, and a summary page for metadata at the end of each block, from which the logical to physical translation table may be reconstructed at startup. For example, a direct page mapped translation table might contain, for every LBA, a logical sector number corresponding to a physical block number and a physical page number. Thus, direct page mapping comprises a single-level logical to physical translation. The summary page for each block might contain the LBA and valid bits for each page in the block so that the translation table can be reconstructed at startup. Thus, the direct page mapping scheme requires a large amount of RAM (on the order of 1-2 MB per GB of user storage) to store the translation table, which can become burdensome for higher capacity SSDs.","Another approach is known as block mapping. Block mapping generally classifies blocks as either data blocks (D-blocks) or update blocks (U-blocks). The total size of the D-blocks is the effective storage space for user data while U-blocks are invisible to users. Generally, when a write command cannot be accommodated in the D-block corresponding to the LBA, a U-block is allocated to receive the new data and the old data in the D-block is invalidated. Subsequent writes to that D-block will be received by the allocated U-block. When the U-block becomes full, another U-block might be allocated, or the U-block might be merged with the original D-block. Thus, block mapping maintains a lookup table in RAM that maps a logical block to a physical block. Block mapping lacks a page-level map, instead relying on the typical case that data is stored in sequential order within the block. For example, a block mapped translation table might contain a logical sector number corresponding to a logical block number and a logical page number. The logical block number can be translated into a physical block number and the logical page number might correspond to a physical offset within the physical block. Thus, block mapping comprises a two-level logical to physical translation. The size of the translation table is proportional to the number of blocks in the flash memory, thus requiring less RAM than a page mapped translation table.","However, because block mapping does not have a page-level map, the flash media may be inefficiently utilized when the data access workload is non-sequential. For non-sequential data access workloads, block mapping might require data to be copied and re-written numerous times to maintain the correct mapping. An example of block mapping is described in the paper by Jeong-Uk Kang & Heeseung Jo, et al., A S-BFTLNFM6& ,pp. 161-170,(Oct. 22-25, 2006), which is incorporated herein by reference in its entirety (hereinafter \u201cKang\u201d).","A third approach for maintaining the logical to physical translation table is known as a superblock mapping scheme. Superblock mapping groups together a set number of adjacent logical blocks into a superblock. The superblock mapping scheme maintains a page global directory (PGD) in RAM for each superblock. Page middle directories (PMDs) and page tables (PTs) are maintained in flash. Each LBA can be divided into a logical block number and a logical page number, with the logical block number comprising a superblock number and a PGD index offset. The logical page number comprises a PMD index offset and a PT index offset. Each entry of the PGD points to a corresponding PMD. Each entry of the PMD points to a corresponding PT. The PT contains the physical block number and the physical page number of the data. Super-block mapping, thus, comprises a four-level logical to physical translation and provides page-mapping.","The PMD's and PT's are stored in the spare areas of the flash pages to provide page-mapping without using an excessive amount of RAM. However, because the spare area is being used to store page-level mapping information, less memory is available for error correction codes (ECC). Further, the limited amount of memory available in the spare area precludes storing complicated mapping information. Finally, reconstruction of the translation table at startup can be time-intensive. An example of a superblock mapping scheme is described in Kang.","As described above, for write operations NAND devices store the new data for the LBA on a new page. Thus, NAND devices also generally require that the device driver software or the separate controller chip periodically initiate a process to erase data that is out-of-date. As would be apparent to one of skill in the art, without periodically erasing out-of-date data, the flash memory would fill up with data that is mostly out-of-date. This inefficiency would reduce the realized flash memory capacity because less current data could be stored. Therefore, device driver software or controller chips generally periodically run a \u201cgarbage collection\u201d routine adapted to provide efficient flash memory utilization by erasing out-of-date blocks. An example of a garbage collection routine is described in Kang.","However, NAND device blocks can be erased relatively few times before device failure (typically on the order of 100,000 erasures). Therefore, over the operational life of an SSD, blocks of flash memory will fail and become unusable. Thus, the device driver software or the separate controller chip should minimize the number of erasures, and must also maintain a record of bad blocks. For example, device driver software or controller chips might implement wear leveling to spread the erasing and writing of blocks over the entire flash memory to avoid repeatedly erasing and writing a given subset of blocks.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Described embodiments provide skip operations for transferring data to or from a plurality of non-contiguous sectors of a solid-state memory. A host layer module sends data to, and receives commands from, a communication link. Received commands are one of read requests or write requests, with the commands including i) a starting sector address, ii) a skip mask indicating the span of all sector addresses in the request and the sectors to be transferred, iii) a total number of sectors to be transferred; and, for write requests, iv) the data to be written to the sectors. A buffer stores data to be transferred to or from the solid-state memory. A buffer layer module i) manages the buffer, ii) segments the span of the request into a plurality of chunks, where each chunk corresponds to at least one sector, iii) determines, based on the skip mask, a number of chunks to be transferred to or from the solid-state memory, and iv) allocates storage space in the buffer corresponding to, for read requests, the number of chunks requiring data to be read, and, for write requests, the number of sectors to be written. A media layer module i) provides, for a read request, data from the solid-state memory to the buffer for each chunk requiring data to be read, and ii) transfers, for a write request, data from the buffer to the solid-state memory for each chunk to be written.","In accordance with embodiments of the present invention, skip operations for solid state disks (SSDs) are provided. Skip operations, such as skip-read and skip-write, allow a group of non-contiguous data blocks to be transferred that are in a given logical block address (LBA) range. For conventional hard disk drives (HDDs), skip operations allow reading or writing of data blocks within a single revolution of the disk, thereby reducing the number of operations required for transfer of data to and from the disk. While SSDs do not have moving components like HDDs, embodiments of the present invention might provide a similar reduction in the number of host transfers to and from the SSD.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1","b":["100","100","102","100","104","118","102","100","102"]},"Flash controller  controls transfer of data between flash media  and an external device coupled to communication link . Flash controller  might be implemented as a system-on-chip (SoC). Flash controller  might include internal RAM buffer . Flash controller  might also be coupled to additional external memory, shown as external RAM buffer . In an exemplary embodiment, internal RAM buffer  comprises 128 kB of static RAM (SRAM) and external RAM buffer  comprises 512 MB of double data rate version 2 dynamic RAM (DDR2 DRAM). RAM buffer  might act as a cache for processor , while RAM buffer  might act as a read\/write buffer between flash media  and communication link . Although shown in  as a single processor, processor  might be implemented by multiple processors (not shown). Processor  includes software\/firmware as needed for operation, including skip operations in accordance with exemplary embodiments of the present invention, as described subsequently with respect to .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["116","104","202","102","104","202","102","208","208","118","100","208","210","118","102","114","112","208","118","212","212","118","208","208","118","202","210","208"]},"For example, flash controller  () receives requests for flash media access from external devices, such as read or write operations, from communication link . Received requests are processed by host layer . Host layer  i) controls all host interface specific commands (e.g. SATA commands), ii) coordinates host-side data transfers and command execution, and iii) processes any other host commands (e.g. status updates). Host layer  is in communication with buffer layer . FTL  also interfaces with buffer layer . Since data transfers between communication link  and flash media  are temporally stored in buffer memory, buffer layer  generally directs the data traffic between host layer  and FTL . For example, if an external host (not shown) provides, via communication link , data to be written to flash media , buffer layer  might coordinate temporary storage of the data in buffer  until FTL  coordinates writing the data to flash media . Similarly, if the external host requests to read data from flash media , buffer layer  might temporarily store the data in buffer  until host layer  coordinates sending the data to the host via communication link .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 3","FIG. 3","FIG. 4"],"b":["210","202","302","304","210","304","210","306","118"],"sup":"N "},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 4","FIG. 4"],"b":["404","402","402","0","31","404","402"]},"Returning to , at step , buffer layer  allocates buffer space for one or more contiguous chunks in the current segment of the skip-read operation for which data is to be read. As shown in , chunks indicated by the skip mask that do not contain any data to be read are not allocated buffer space and create a gap in contiguous chunks. In the present invention, buffer layer  uses the skip mask to allocate buffer space for each chunk of a transfer that has data to be read for the current segment. Thus, at step , buffer layer  allocates buffer space only for each chunk that is to be read for the current segment, as indicated by the skip mask. During normal read processing, buffer layer  allocates buffer space for the entire read and transfers all of the chunks from flash media . For skip reads, buffer layer  only allocates buffer space for and transfers chunks having at least one block to transfer, as described above.","At step , buffer layer  requests data, corresponding to at least a portion of the data requested by the skip-read request received at step , to be transferred from flash media . For example, in embodiments of the present invention, at step  buffer layer  might request data for one or more contiguous chunks that have at least one sector to be read. At step , FTL  provides the chunk data, including skipped sectors, to buffer layer  and buffer layer  temporarily stores the data in buffer . At step , buffer layer  requests that host layer  retrieve the chunk data that FTL  provided to buffer layer  at step . At step , host layer  analyzes the skip mask for each chunk stored in buffer  and, at step , host layer  transfers only the requested sectors, not including skipped sectors, to communication link  according to the skip mask. At step , buffer layer  deallocates the space in buffer  that was allocated in step  for the current group of one or more chunks. At step , if there are more chunks to transfer, processing returns to step  for buffer layer  to allocate buffer space for the next group of one or more chunks to be processed. If there are no more chunks to be transferred, processing continues to step . At step , the skip-read operation is complete.","In an embodiment of the present invention, for the skip-read operation shown in , host-side operations, for example steps  and , for a first group of one or more chunks, and media-side operations, for example steps  and , for a subsequent group of one or more chunks might be performed in parallel. For example, by segmenting the skip-read operation into smaller transfers of one or more chunks, a first set of chunks might be transferred between FTL  and buffer layer  (step ), and host layer  might then transfer the first set of chunks to communication link  (step ). Concurrently with one or more of the host-side operations for the first set of chunks, a second set of chunks for the same skip-read operation might be transferred from FTL  to buffer layer  (step ), and so on, until all chunks for the skip-read operation are transferred. Thus, embodiments of the present invention provide the ability to perform host side and media side transfers in parallel.","Thus, the design of FTL  is simplified because FTL  need not track the skip mask. Embodiments of the present invention also reduce the amount of data transferred from flash media  to buffer  by breaking the skip operation into smaller operations of one or more chunks. The amount of data transferred from flash controller  to communication link  is also reduced. As described above, the skip mask is analyzed twice: once by buffer layer  as it determines how to break up the skip command internally, and once by host layer  when it transfers sectors between buffer layer  and host layer .","Buffer layer  might segment a skip-read operation into smaller into smaller internal data transfers. As described above, these internal data transfers might include one or more contiguous chunks, shown in  as chunks ()-(). As shown in the example of , each chunk corresponds to 8 contiguous sectors of LBA span , but other numbers might be employed. Thus, each of chunks ()-() corresponds to LBA span segments ()-() and skip mask segments ()-(). As shown in the example of , chunk () does not include any sectors to be read, as indicated by its corresponding skip mask segment (). Thus, buffer layer  can skip chunk () entirely when allocating buffer space or requesting FTL  retrieve data from flash media . Skip mask segments  correspond to the skip mask for each chunk having data to be read. For the example of  and as described above with regard to , buffer layer  would split the data transfer into two smaller data transfers: one transfer for chunk (), and one transfer for contiguous chunks () and ().",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 5","FIG. 5","FIG. 2","FIG. 2"],"b":["502","202","102","504","210","506","508","210","510","210","202","512","202","210","114"]},"At step , buffer layer  provides data for the one or more contiguous chunks of the segment to FTL . At step , FTL  analyzes the skip mask for the chunks. As previously described, the data of the skip-write operation includes only data for each sector to be written. However, most commonly used flash media supports only writing full pages, not writing of individual sectors. Thus, at step , FTL  must, based on the skip mask, merge page data for sectors that do not have data to be written and the data for sectors included in the skip-write operation. At step , FTL  writes one or more full pages, including new data for the sectors of the skip-write operation, and previous data for all other sectors, to flash media . At step , buffer layer  deallocates the space in buffer  allocated at step  for the current segment of one or more contiguous chunks. At step , if there are additional chunks having data to be written, processing returns to step . If there are no additional chunks to be written, at step , the skip-write operation is complete.","As described above with regard to the skip-read operations of , in an embodiment of the present invention, for the skip-write operation shown in , media-side operations, for example steps  through , for a first group of one or more chunks, and host-side operations, for example steps  through , for a subsequent group of one or more chunks might be performed in parallel. For example, by segmenting the skip-write operation into smaller transfers of one or more chunks, a first set of chunks might be transferred between buffer layer  and FTL  (step ) and associated page data might be transferred between FTL  and flash media  (step ). Concurrently with one or more of the media-side operations for the first set of chunks, a second set of chunks for the same skip-write operation might be transferred from communication link  to host layer  and stored by buffer layer  (steps  through ), and so on, until all chunks for the skip-write operation are transferred. Thus, embodiments of the present invention provide the ability to perform host side and media side transfers in parallel.","Reference herein to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment, nor are separate or alternative embodiments necessarily mutually exclusive of other embodiments. The same applies to the term \u201cimplementation.\u201d","While the exemplary embodiments of the present invention have been described with respect to processing blocks in a software program, including possible implementation as a digital signal processor, micro-controller, or general purpose computer, the present invention is not so limited. As would be apparent to one skilled in the art, various functions of software may also be implemented as processes of circuits. Such circuits may be employed in, for example, a single integrated circuit, a multi-chip module, a single card, or a multi-card circuit pack.","The present invention can be embodied in the form of methods and apparatuses for practicing those methods. The present invention can also be embodied in the form of program code embodied in tangible media, such as magnetic recording media, optical recording media, solid state memory, floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. The present invention can also be embodied in the form of program code, for example, whether stored in a storage medium, loaded into and\/or executed by a machine, or transmitted over some transmission medium or carrier, such as over electrical wiring or cabling, through fiber optics, or via electromagnetic radiation, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code segments combine with the processor to provide a unique device that operates analogously to specific logic circuits. The present invention can also be embodied in the form of a bitstream or other sequence of signal values electrically or optically transmitted through a medium, stored magnetic-field variations in a magnetic recording medium, etc., generated using a method and\/or an apparatus of the present invention.","It should be understood that the steps of the exemplary methods set forth herein are not necessarily required to be performed in the order described, and the order of the steps of such methods should be understood to be merely exemplary. Likewise, additional steps may be included in such methods, and certain steps may be omitted or combined, in methods consistent with various embodiments of the present invention.","As used herein in reference to an element and a standard, the term \u201ccompatible\u201d means that the element communicates with other elements in a manner wholly or partially specified by the standard, and would be recognized by other elements as sufficiently capable of communicating with the other elements in the manner specified by the standard. The compatible element does not need to operate internally in a manner specified by the standard.","Also for purposes of this description, the terms \u201ccouple,\u201d \u201ccoupling,\u201d \u201ccoupled,\u201d \u201cconnect,\u201d \u201cconnecting,\u201d or \u201cconnected\u201d refer to any manner known in the art or later developed in which energy is allowed to be transferred between two or more elements, and the interposition of one or more additional elements is contemplated, although not required. Conversely, the terms \u201cdirectly coupled,\u201d \u201cdirectly connected,\u201d etc., imply the absence of such additional elements. Signals and corresponding nodes or ports may be referred to by the same name and are interchangeable for purposes here.","It will be further understood that various changes in the details, materials, and arrangements of the parts which have been described and illustrated in order to explain the nature of this invention may be made by those skilled in the art without departing from the scope of the invention as expressed in the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other aspects, features, and advantages of the present invention will become more fully apparent from the following detailed description, the appended claims, and the accompanying drawings in which like reference numerals identify similar or identical elements.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
