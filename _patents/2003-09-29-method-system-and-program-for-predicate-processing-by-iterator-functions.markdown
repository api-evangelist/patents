---
title: Method, system, and program for predicate processing by iterator functions
abstract: Disclosed is a technique for processing predicates in an iterator function. When an iterator function included in a statement is invoked, one or more predicates included in the statement are obtained. The one or more predicates are applied to a row of data. If applying the one or more predicates results in a match, the row of data is returned. If applying the one or more predicates does not result in a match, a search is performed for another row of data for which application of the one or more predicates results in a match. Also disclosed is a technique for processing predicates in which a statement including an iterator function and one or more predicates is received. A qualification descriptor that describes the one or more predicates and one or more functions that are to be used to evaluate the one or more predicates is created. Then, the iterator function is invoked one or more times, until receiving a done indicator from the iterator function.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07685103&OS=07685103&RS=07685103
owner: International Business Machines Corporation
number: 07685103
owner_city: Armonk
owner_country: US
publication_date: 20030929
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Additional Implementation Details"],"p":["1. Field of the Invention","The present invention is related to predicate processing by iterator functions.","2. Description of the Related Art","A database system is one in which data is stored, retrieved, and processed. Data records in a relational database management system (RDBMS) in a computer are maintained in tables, which are a collection of rows of data all having the same columns. Each column maintains information on a particular type of data for the data records which comprise the rows of data. Tables in the database are searched using, for example, a Structured Query Language (SQL), which specifies search operations or predicates to perform on columns of tables in the database to qualify rows of data in the database tables that satisfy the search conditions. A predicate is an element of a search condition that expresses or implies a comparison operation (e.g., customer_number>100 or department_name=\u201cfinance\u201d).","Relational DataBase Management System (RDBMS) software using a SQL interface is well known in the art. The SQL interface has evolved into a standard language for RDBMS software and has been adopted as such by both the American National Standards Institute (ANSI) and the International Standards Organization (ISO).","One type of function that may be included in a SQL statement is an iterator function. Iterator functions may also referred to as \u201ctable\u201d functions in the DB2\u00ae UDB\u00ae system (e.g., for OS\/390\u00ae, Linux\u00ae, UNIX\u00ae, and Windows\u00ae operating systems) available from International Business Machines Corporation. These iterator functions may be written in, for example, C, C++, JAVA\u00ae, or SQL. An iterator function receives a set of arguments and returns a table to the SQL statement that invokes the function. A table function may be invoked in the FROM clause of a SELECT statement.","An iterator function may be used to retrieve\/extract data from an external source (e.g., a text search engine or a spread sheet) into a database. The result set (i.e., rows of data) returned by an iterator function may be treated as a table and may be referred to as a \u201cvirtual table\u201d. When an iterator function is used in the FROM clause of a SELECT statement, columns in rows of data returned by the iterator function are mapped to a virtual table, and the columns of the virtual table may be used in predicate expressions and may be joined with columns of other tables.","The following sample SQL statement (1) includes a transpose (\u201cIBM\u201d) iterator function:",{"@attributes":{"id":"p-0010","num":"0009"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"right"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Statement (1)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT vcol1.high, vcol1.low, vcol1.time_stamp"]},{"entry":[{},"FROM TABLE(FUNCTION transpose(\u201cIBM\u201d)) vtab1(vcol1),"]},{"entry":[{},"audit_table aut"]},{"entry":[{},"WHERE vcol1.time_stamp>\u20181970-01-01 00:00:00.00000\u2019 AND"]},{"entry":[{},"\u2003\u2003vcol1.time_stamp <\u20181971-01-01 00:00:00.00000\u2019 AND"]},{"entry":[{},"\u2003\u2003vcol1.time_stamp = aut.time_stamp;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The transpose (\u201cIBM\u201d) iterator function operates on timeseries data that stores historical data (e.g., of stock symbols) as binary large objects (BLOBs) and returns a set of rows that are stored in result table \u201cvtab1\u201d with column \u201cvcol1\u201d. The column \u201cvcol1\u201d is of a row datatype. A row datatype may have multiple fields, and, in this example, one of the fields is a timestamp field represented by \u201ct\u201d. Therefore, vcol1.time_stamp is used to access a timestamp field in a row of data. The predicates on vcol1.time_stamp (i.e., vcol1.time_stamp>\u20181970-01-01 00:00:00.00000\u2019 AND vcol1.time_stamp<\u20181971-01-01 00:00:00.00000\u2019) are used to filter the rows of data with the specified time range and are also used in the join filter (vcol1.time_stamp=aut.time_stamp).","In Statement (1), the qualification (i.e., the predicates) on the table returned by the transpose (\u201cIBM\u201d) iterator function is:",{"@attributes":{"id":"p-0013","num":"0012"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vcol1.time_stamp>\u20181970-01-01 00:00:00.00000\u2019 AND"]},{"entry":[{},"vcol1.time_stamp <\u20181971-01-01 00:00:00.00000\u2019 AND"]},{"entry":[{},"vcol1.time_stamp = aut.time_stamp;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Typically, the iterator function creates a virtual table with a result set. Then, the qualification is applied to the virtual table to filter rows of data in the virtual table. In many cases, only a small percentage of rows of data in the virtual table remain after the qualification is applied. Unfortunately, because the qualification is applied after the rows of data are retrieved for the result set, many rows of data are unnecessarily retrieved for the virtual table.","The following sample SQL statement (2) includes a text search iterator function:",{"@attributes":{"id":"p-0016","num":"0015"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"right"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Statement (2)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT a.isbn, a.year, b.score"]},{"entry":[{},"FROM articles a,"]},{"entry":[{},"\u2003\u2003text_search(\u2018articles\u2019, \u2018abstract\u2019, \u201cBush\u201d in same sentence as"]},{"entry":[{},"\u2003\u2003\u201crecession\u201d) b"]},{"entry":[{},"WHERE a.year >= 2000 AND a.isbn = b.key AND b.score >= 0.9"]},{"entry":[{},"ORDER BY 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The text_search( ) iterator function returns a key and a score for articles that have \u201cBush\u201d in the same sentence as \u201crecession\u201d from an external data source \u201cb\u201d. The application program submitting SQL statement (2) is interested in articles with a score (assigned by the text_search( ) iterator function) greater than or equal to 0.9. Because the text_search( ) iterator function is not aware of the score qualification, the text_search( ) iterator function returns a virtual table with all articles that have \u201cBush\u201d in the same sentence as \u201crecession.\u201d Not having knowledge about the qualification and filtering rows of data after the virtual table is created by the text_search iterator function is an overhead on query performance and system resources. Note that the database engine would process the a.year>=2000 AND a.isbn=b.key predicates as the iterator function does not have access to table \u201ca\u201d. Alternatively, a new text_search( ) function may be written with a new parameter for passing in the score to the text_search( ) function. However, if the overloading of the function is not allowed, this leads to a situation in which a user chooses the right name of the parameter to be passed in, requiring new development and release of software whenever there is a need to add a new predicate to the search criteria.","The DB2\u00ae Text Extender product (available from International Business Machines Corporation) has a hard-coded solution to this problem. For more information on the DB2\u00ae Text Extender, see \u201cDB2\u00ae Optimization in Support of Full Text Search\u201d, by Albert Maier and David Simmen, Bulletin of the Technical Committee on Data Engineering, Volume 24, No. 4, IEEE Computer Society, December 2001.","Thus, there is a need in the art for a generalized solution to allow predicate processing by iterator functions.","Provided are a method, system, and program for processing predicates in an iterator function. When an iterator function included in a statement is invoked, one or more predicates included in the statement are obtained. The one or more predicates are applied to a row of data. If applying the one or more predicates results in a match, the row of data is returned. If applying the one or more predicates does not result in a match, a search is performed for another row of data for which application of the one or more predicates results in a match.","Also disclosed is a method, system, and program for processing predicates in which a statement including an iterator function and one or more predicates is received. A qualification descriptor that describes the one or more predicates and one or more functions that are to be used to evaluate the one or more predicates is created. Then, the iterator function is invoked one or more times, until receiving a done indicator from the iterator function.","In the following description, reference is made to the accompanying drawings which form a part hereof and which illustrate several implementations of the present invention. It is understood that other implementations may be utilized and structural and operational changes may be made without departing from the scope of the present invention.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","190","120","100","190","100","104","110","104","110","120"]},"The server computer  includes system memory , which may be implemented in volatile and\/or non-volatile devices. A data store engine  executes in the system memory . Programs running in the data store engine  (e.g., User Defined Functions (UDFs)) may also issue queries (e.g., SQL queries) to be processed by the data store engine , and these queries may include iterator functions (e.g., in the FROM clauses of SELECT statements). A iterator function processor  executes as part of the data store engine  and may invoke external applications on the network  (e.g., on the World Wide Web), such as search engines or Web services. The iterator functions may obtain data from different locations, such as local memory, local disk, or storage sources connected to the network . Additionally, one or more server applications  execute in system memory .","The server computer  provides the client computer  with access to data in a data store  (e.g., a database). Although a single data store  is illustrated for ease of understanding, tables  and other data in data store  may be stored in data stores at other computers connected to server computer . Also, an operator console  executes one or more applications  and is used to access the server computer  and the data store .","The data store  may comprise an array of storage devices, such as Direct Access Storage Devices (DASDs), Just a Bunch of Disks (JBOD), Redundant Array of Independent Disks (RAID), virtualization device, etc. The data store  includes tables  that are used with implementations of the invention.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["130","200","130","110","182"]},"In block , the data store engine  creates a qualification descriptor. A qualification descriptor may be described as an internal representation of a qualification. The term \u201cqualification\u201d refers to predicates. Also, the term \u201cqualifiers\u201d may be used to refer to the predicates. In certain implementations of the invention, a qualification descriptor is a dynamically allocated structure that describes one or more predicates in a query and provides information to evaluate the predicates. In particular, the qualification descriptor describes the predicates in the statement and provides a handle to each function that is used to evaluate one of the predicates. In certain implementations, each predicate is evaluated by a separate function.","The following Example (1) provides a SELECT statement, in which the predicate to be evaluated by the iterator function processor  is vcol1.time_stamp>\u20181994-01-05 00:00:00.0000\u2019.",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"right"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Example (1)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT vcol1.time_stamp, vcol1.high"]},{"entry":[{},"FROM table (function transpose(\u201cIBM\u201d)) vtab1(vcol1)"]},{"entry":[{},"WHERE vcol1.time_stamp > \u20181994-01-05 00:00:00.0000\u2019;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Although examples herein may refer to a transpose( ) iterator function, implementations of the invention are applicable to any iterator function, including, for example, the following: text_search( ), web_service( ), or spatial_search( ). For example, for the web_service( ) iterator function, when SQL is used to invoke a web service, the predicates may be pushed across the web to minimize dataflow. Spatial (1) provides an example of a spatial_search( ) iterator function:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"right"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Spatial(1)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT sp_tab.location, sp_distance(my_tab.myloc,sp_tab.location)"},{"entry":"FROM spatial_search(\u2018location\u2019, \u201cnearest pharmacy\u201d) sp_tab"},{"entry":"WHERE sp_distance(my_tab.myloc, sp_tab.location) < 2.0 and"},{"entry":"\u2003\u2003sp_tab.pharmacy_rating = 1;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3A","b":["300","300","302","304","306","308","310","312","314","302","304","132","306","308","308","310","312","314","314","316"]},"The following Example (2) provides a SELECT statement, in which the predicates to be evaluated by the iterator function processor  are vcol1.time_stamp<\u20181994-01-05 00:00:00.0000\u2019 and vcol1.high<20.00.",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"right"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Example (2)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT vcol1.time_stamp, vcol1.high"]},{"entry":[{},"FROM table (function transpose(\u201cIBM\u201d)) vtab1(vcol1)"]},{"entry":[{},"WHERE vcol1.time_stamp < \u20181994-01-05 00:00:00.0000\u2019 and"]},{"entry":[{},"vcol1.high < 20.00;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3B","b":["320","320"]},"The following Example (3) provides a SELECT statement, in which the predicates to be evaluated by the iterator function processor  are vcol1.time_stamp<\u20181994-01-05 00:00:00.0000\u2019 and vcol1.high<20.00.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"right"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Example (3)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT vcol1.t, vcol1.high"]},{"entry":[{},"FROM table (function transpose(\u201cIBM\u201d)) vtab1(vcol1)"]},{"entry":[{},"WHERE vcol1.t < \u20181994-01-05 00:00:00.0000\u2019 and"]},{"entry":[{},"\u2003\u2003vcol1.high < 20.00 and vcol1.high = audit_table.high;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 3C","b":["340","340","132"]},"Example (4) provides a SELECT statement, in which the predicates to be evaluated by the iterator function processor  are vcol1.time_stamp<\u20181994-01-05 00:00:00.0000\u2019 and vcol1.high<20.00.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"right"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Example (4)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT vcol1.t, vcol1.high"]},{"entry":[{},"FROM table (function transpose(\u201cIBM\u201d)) vtab1(vcol1)"]},{"entry":[{},"WHERE vcol1.t < \u20181994-01-05 00:00:00.0000\u2019 or"]},{"entry":[{},"\u2003\u2003vcol1.high = 15.00"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3D","b":"360"},"In block , the data store engine  invokes the iterator function. The logic for processing the iterator function is represented by the iterator function processor . The data store engine  may also perform other processing prior to invoking the iterator function. For example, the data store engine  performs parsing and optimization before executing the statement including the iterator function. In block , the data store engine  determines whether the iterator function processor  returned a row of data or a done indicator. A done indicator is returned by the iterator function processor  after the iterator function processor  has processed all rows of data it has to process. If the iterator function processor  returned a row of data, then processing continues to block , otherwise, processing continues to block .","In block , the data store engine  stores the row of data received from the iterator function processor  for which simple and\/or complex predicates have already been applied and processing continues to block . The predicates passed to and evaluated by the iterator function may be a combination of simple predicates, and the combination may be referred to as a complex predicate. Simple predicates are ones which compare a column value to a constant. In particular, in certain implementations, the iterator function applies simple and\/or complex predicates to rows of data and returns a row of data for which application of the predicates results in a match to the qualification. That is, in certain implementations, the iterator function processor  applies predicates involving constants against a column in the result set that the iterator function processor  returns.","In block , the data store engine  applies predicates in the statement not already applied by the iterator function processor . These predicates may include simple and\/or complex predicates not applied by the iterator function processor  (e.g., due to lack of resources), join predicates, and predicates on columns not in the result set of the iterator function. That is, in certain implementations, the data store engine  and the iterator function processor  may each apply some of the simple predicates (i.e., the iterator function processor  does not apply all of the simple predicates in these implementations). In block , the data store engine  determines whether the iterator function is to be invoked again. In certain implementations, the iterator function is invoked again if the iterator function did not return a done indicator to indicate that all rows have been processed. If so, processing loops back to block , otherwise, processing continues to block . In block , the data store engine returns the result of processing the statement (e.g., returns a table or a set of rows of data) to the client application  or application  that submitted the statement.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIGS. 4A and 4B","b":["132","400","132","130","130","402","132"]},"In block , the iterator function processor  applies one or more of the obtained predicates to the retrieved row of data. That is, for each row of data that is generated by the iterator function processor , the appropriate function specified in the qualification descriptor is applied on the corresponding predicate column. For each predicate (e.g., for a built-in datatype or a user-defined datatype), implementations of the invention will provide a function (e.g., a User Defined Function (UDF) or a system defined function) to evaluate that predicate on a column. In certain implementations, each simple predicate is a Boolean expression. If the predicate is an integer comparison (e.g., equal), a handle to the function that performs the integer equal comparison and returns a Boolean value is provided in the qualification descriptor. For each row of data, the iterator function processor  calls one or more functions on the data referenced by a predicate, and each of the functions processes the predicate. In certain implementations, one function corresponds to one type of predicate (e.g., an equal comparison). In certain alternative implementations, one function may process more than one type of predicate. The results from the functions may be combined using a predicate expression (e.g., combining AND and OR connectors in the statement).","In certain implementations of the invention, an IBM\u00ae Informix\u00ae Virtual-Table Interface provides a mechanism to represent and process predicates. The mechanism may be thought of as a set of interfaces to access the predicates and access the type of each predicate and to combine the result of each predicate. This mechanism may also be used to push down other query processing information, such as the requested sort order for the result so that the iterator function may process this information as well. The IBM\u00ae Informix\u00ae Virtual-Table Interface is further described in the IBM\u00ae Informix\u00ae Virtual-Table Interface Programmer's Guide, Version 9.1, March 2003, which is available from International Business Machines Corporation.","In block , the iterator function processor  determines whether the predicates were applied successfully. For example, the iterator function processor  is able to apply simple or complex predicates, but not join predicates. Also, the iterator function processor  may be unable to process predicates for other reasons, such as a lack of resources or due to unexpected errors. In certain alternative implementations, the iterator function processor  may also determine whether some predicates should be applied by the data store engine  (e.g., because the data store engine  has more processing resources). In certain implementations, the iterator function processor  does not process the predicates if any one of the predicates is to be applied by the data store engine . In this case, from block , if the iterator function processor  is able to process all of the predicates, then processing continues to block , otherwise, processing continues to block .","In certain alternative implementations, the iterator function processor  applies those predicates that may be applied by the iterator function processor  and sends indicators to the data store engine  to apply the remaining predicates. In this case, from block , if at least one of the predicates may be processed by the iterator function processor , then processing continues to block , otherwise, processing continues to block .","In block , the iterator function processor  sets one or more indicators to indicate which predicates were applied by the iterator function processor , and processing continues to block .","In block , the iterator function processor  sets one or more indicators to indicate that predicates can not be successfully applied by the iterator function processor  and processing continues to block . In block , the iterator function processor  returns the retrieved row to the data store engine .","By setting the one or more indicators, the iterator function processor  is able to notify the data store engine  which predicates the iterator function processor  has applied, so that the data store engine  can save resources and avoid applying these applied predicates. Also, the data store engine  is able to apply those predicates that the iterator function processor  did not apply so that the statement initially received that includes an iterator function is evaluated correctly.","In block , the iterator function processor  determines whether there is a match. In certain implementations of the invention, there is a \u201cmatch\u201d if the row of data qualifies for selection based on application of one or more predicates (i.e., all of the predicates for that iterator function). If there is a match, processing continues to block , otherwise, processing continues to block . In block , the iterator function processor  returns the row of data to the data store engine . That is, the iterator function processor  returns a row of data if the predicate evaluation returns TRUE (i.e., each of the functions returned in the qualification descriptor return TRUE).","If there is no match, in block , the iterator function processor  discards the row of data. In block , the iterator function processor  determines whether all rows of data have been processed. If so, processing continues to block , otherwise, processing loops back to block  to retrieve another row of data. That is, if there was not a match, the iterator function processor  continues searching for a next qualifying row of data.","Thus, to minimize data flow from the iterator function to the data store engine , implementations of the invention make predicates for a given query available to the iterator function processor . The following sample SQL statement (3) includes a transpose (\u201cIBM\u201d) iterator function.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"right"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Statement (3)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT vcol1.high, vcol1.low, vcol1.time_stamp"]},{"entry":[{},"FROM TABLE(FUNCTION transpose(\u201cIBM\u201d)) vtab1(vcol1),"]},{"entry":[{},"audit_table aut"]},{"entry":[{},"WHERE vcol1.time_stamp>\u20181970-01-01 00:00:00.00000\u2019 AND"]},{"entry":[{},"\u2003\u2003vcol1.time_stamp <\u20181971-01-01 00:00:00.00000\u2019 AND"]},{"entry":[{},"\u2003\u2003vcol1.time_stamp = aut.time_stamp AND"]},{"entry":[{},"\u2003\u2003aut.name = \u201cIBM\u201d;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The result set from the transpose (\u201cIBM\u201d) iterator function is mapped to column \u201cvcol1\u201d of table \u201cvtab1\u201d. In this example, since the transpose( ) iterator function returns a row of data (i.e., data of the row datatype), column \u201cvcol1\u201d is of row datatype. In general, an iterator function may return data of any datatype (e.g., system defined or user defined datatypes), however, an iterator function in a statement returns data of one datatype, as specified in the statement. In this example, column \u201cvcol1\u201d has time (t), high (high), low (low) fields.","The iterator function processor  calls an API function to get the qualification descriptor that describes the predicates and the functions to evaluate each predicate.","For each row of data that is generated by the iterator function processor , the appropriate function specified in the qualification descriptor is applied on the corresponding predicate column.","The qualification descriptor obtained by the transpose( ) iterator function in statement (3) includes the following predicates on the result columns:",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"vcol1.time_stamp>\u20181970-01-01 00:00:00.00000\u2019 AND"]},{"entry":[{},"vcol1.time_stamp <\u20181971-01-01 00:00:00.00000\u2019 AND"]},{"entry":[{},"vcol1.time stamp = aut.timestamp"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The qualification descriptor obtained by the transpose( ) iterator function in statement (3) does not include the predicate aut.name=\u201cIBM\u201d because the column \u201caut.name\u201d is not in the result set of the transpose( ) iterator function. The iterator function processor  applies the predicates in the qualification descriptor, and the data store engine  applies the predicate aut.name=\u201cIBM\u201d. Similarly, the data store engine  would apply any join predicates.","Implementations of the invention provide a new function, which for ease of reference will be referred to as a get_qualification_descriptor function. In certain implementations of the invention, the get_qualification_descriptor function is an IBM\u00ae Informix\u00ae Virtual-Table Interface API function that is used to obtain a qualification descriptor when an iterator function is used in the FROM clause of a SELECT statement and may have the format mi_iter_qual_get( ).","The qualification descriptor may be used with an existing IBM\u00ae Informix\u00ae Virtual-Table Interface API function that is available for the IBM\u00ae Informix\u00ae Dynamic Server 9.x version (where x in 9.x represents a positive integer value).","The following is example psuedocode for a transpose( ) iterator function:",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/*ts_transpose_sql( ) is an example transpose iterator function.*\/"},{"entry":"void*"},{"entry":"ts_transpose_sql(ts_timeseries * ts, MI_FPARAM*fparam)"},{"entry":"\/* \u201ctimeseries\u201d refers to a datatype, and ts stores timeseries data;"},{"entry":"fparam stores function parameters, such as the state of a function.*\/"},{"entry":"{"},{"entry":"\u2003\u2003\/*mi_fp_request( ) indicates whether this is a first call from the data store engine.*\/"},{"entry":"\u2003\u2003if (mi_fp_request(fParam) = = SET_INIT) {"},{"entry":"\u2003\u2003\u2003\u2003\/*if mi_fp_request(fParam) is set to initialization, then the following"},{"entry":"\u2003\u2003\u2003\u2003processing is performed.*\/"},{"entry":"\u2003\u2003\u2003\u2003\/*mi_zalloc( ) allocates space for a structure.*\/"},{"entry":"\u2003\u2003\u2003\u2003state = (struct ts_state *) mi_zalloc(sizeof(struct ts_state));"},{"entry":"\u2003\u2003\u2003\u2003\/*Now, get the start and stop flags.*\/"},{"entry":"\u2003\u2003\u2003\u2003\/*mi_iter_qual_get( ) obtains predicates on the query by obtaining the"},{"entry":"\u2003\u2003\u2003\u2003qualification descriptor and store in qd.*\/"},{"entry":"\u2003\u2003\u2003\u2003qd=mi_iter_qual_get( );"},{"entry":"\u2003\u2003\u2003\u2003if (qd!=NULL)"},{"entry":"\u2003\u2003\u2003\u2003\/* If the qualification is not NULL, the following processing is"},{"entry":"\u2003\u2003\u2003\u2003performed.*\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/*ts_get_start_and_stop( ) gets the start and stop flags.*\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ts_get_start_and_stop(state, qd, &state->flags);"},{"entry":"\u2003\u2003\u2003\u2003\/*timeseries_open( ) opens the timeseries data and"},{"entry":"\u2003\u2003\u2003\u2003begins a scan at a given time.*\/"},{"entry":"\u2003\u2003\u2003\u2003state->tsdesc=timeseries_open(ts);"},{"entry":"\u2003\u2003\u2003\u2003\/*Timeseries_scan( ) uses the predicates to set"},{"entry":"\u2003\u2003\u2003\u2003the window of rows of data to return. *\/"},{"entry":"\u2003\u2003\u2003\u2003state->scan = timeseries_scan(state->tsdesc, state->start, state->stop);"},{"entry":"\u2003\u2003\u2003\u2003return (0);"},{"entry":"\/* Get the saved state.*\/"},{"entry":"state = (struct_ts_state *) mi_fp_funcstate(fParam);"},{"entry":"scan = state->scan;"},{"entry":"tsdesc = state->tsdesc;"},{"entry":"if (MI_FP_REQUEST(fParam) = = SET_END)"},{"entry":"\u2003\u2003return (0);"},{"entry":"\/* get_next_timeseries_elem( ) returns next row of data that qualifies when an additional"},{"entry":"row of data exists and returns TS_SCAN_EOS when stop date is reached. *\/"},{"entry":"ret = get_next_timeseries_elem(scan, &element);"},{"entry":"switch(ret) {"},{"entry":"\u2003\u2003case TS_SCAN_EOS: \/* End of rows of data.*\/"},{"entry":"\u2003\u2003\u2003\u2003MI_FP_SETISDONE(fParam, MI_TRUE); \/*Set done indicator to true.*\/"},{"entry":"\u2003\u2003case TS_SCAN_NULL: \/* Column value is NULL, which is a valid value. *\/"},{"entry":"\u2003\u2003\u2003\u2003return (0);"},{"entry":"\u2003\u2003case TS_SCAN_ELEM: \/* A qualifying row of data was retrieved. *\/"},{"entry":"\u2003\u2003\u2003\u2003return(element); \/*A qualifying row of data is returned. *\/"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":"\/*qd includes the predicates on the statement invoking the iterator function. *\/"},{"entry":"\/* ts_get_start_and_stop( ) finds start and stop date times in qualification. *\/"},{"entry":"ts_get_start_and_stop(struct ts_state *state, MI_AM_QUAL_DESC*qd,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003mi_integer*flags)"},{"entry":"{"},{"entry":"\u2003\u2003if (mi_qual_issimple(qd)) {"},{"entry":"\u2003\u2003\u2003\u2003if (qual column != 0)"},{"entry":"\u2003\u2003\u2003\u2003\/*If the qual column is not the timestamp column, return. *\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003\u2003\/* This is a simple qualification on the timestamp column and the operator"},{"entry":"\u2003\u2003\u2003\u2003needs to be found. *\/"},{"entry":"\u2003\u2003\u2003\u2003\/*mi_qual_funcname( ) gets the name of the function that will be used to"},{"entry":"\u2003\u2003\u2003\u2003evaluate the predicate.\/*"},{"entry":"\u2003\u2003\u2003\u2003funcname = mi_qual_funcname(qd);"},{"entry":"\u2003\u2003\u2003\u2003\/*mi_qual_constant( ) = gets the value of a constant for evaluating the"},{"entry":"\u2003\u2003\u2003\u2003predicate. *\/"},{"entry":"\u2003\u2003\u2003\u2003stamp = mi_qual_constant(qd);"},{"entry":"\u2003\u2003\u2003\u2003if (mi_qual_negate(qd) {"},{"entry":"\u2003\u2003\u2003\u2003\/*If the qualification is negated, the following is performed.*\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if(funcname = = \u201cgreaterthanorequal\u201d \u2225"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003funcname = = \u201cgreaterthan\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003state->stop = stamp;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003else if(funcname = = \u201clessthanorequal\u201d \u2225 funcname = = \u201clessthan\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003state->start = stamp;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003else if(funcname = = \u201cnotequal\u201d {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003state->start = stamp;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003state->stop = stamp;"},{"entry":"\u2003\u2003\u2003\u2003} else{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/* If the qualification is not negated, the following is performed.*\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if(funcname = = \u201cgreaterthanorequal\u201d \u2225"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003funcname = = \u201cgreaterthan\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003state->start = stamp;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003else if(funcname = = \u201clessthanorequal\u201d \u2225"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003funcname = = \u201clessthan\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003state->stop = stamp;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003else if(funcname = = \u201cequal\u201d {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003state->start = stamp;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003state->stop = stamp;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return"},{"entry":"} else {"},{"entry":"\u2003\u2003\/*If there compound qualification, recurse to find each simple qualification.*\/"},{"entry":"\u2003\u2003pred_cnt = mi_qual_nquals(qd);"},{"entry":"\u2003\u2003\/*mi_qual_nquals( ) returns the number of predicates in the compound"},{"entry":"\u2003\u2003qualification.\/*"},{"entry":"\u2003\u2003for (i=0; i<pred_cnt; i++)"},{"entry":"\u2003\u2003\u2003\u2003ts_get_start_and_stop(state, mi_qual_qual(qd,i), flags);"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Thus, implementations of the invention enable a table function to access a qualification and return only rows of data that satisfy the qualification. In many cases, this reduces the number of rows of data in the result set, which leads to fewer retrievals of data and which creates a table that uses less memory. For example, in prior systems in which the data store engine  applied the qualification, 10,000 rows of data may be returned by the iterator function. With implementations of the invention, because the iterator function (rather than the data store engine ) applies the qualification, 10 rows of data may be returned for storage in a virtual table. Additionally, because the iterator function processor  returns a next qualifying row, the data store engine  calls the iterator function processor  fewer times to retrieve rows of data.","IBM, DB2, OS\/390, UDB, and Informix are registered trademarks or common law marks of International Business Machines Corporation in the United States and\/or other countries. JAVA is a registered trademark or common law mark of Sun Microsystems in the United States and\/or other countries. Windows is a registered trademark of Microsoft Corporation in the United States and\/or other countries. Linux is a registered trademark of Linus Torvalds in the United States and\/or other countries. UNIX is a registered trademark or common law mark of The Open Group in the United States and\/or other countries.","The described techniques for predicate processing by iterator functions may be implemented as a method, apparatus or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof. The term \u201carticle of manufacture\u201d as used herein refers to code or logic implemented in hardware logic (e.g., an integrated circuit chip, Programmable Gate Array (PGA), Application Specific Integrated Circuit (ASIC), etc.) or a computer readable medium, such as magnetic storage medium (e.g., hard disk drives, floppy disks, tape, etc.), optical storage (CD-ROMs, optical disks, etc.), volatile and non-volatile memory devices (e.g., EEPROMs, ROMs, PROMs, RAMs, DRAMs, SRAMs, firmware, programmable logic, etc.). Code in the computer readable medium is accessed and executed by a processor. The code in which certain implementations are implemented may further be accessible through a transmission media or from a file server over a network. In such cases, the article of manufacture in which the code is implemented may comprise a transmission media, such as a network transmission line, wireless transmission media, signals propagating through space, radio waves, infrared signals, etc. Thus, the \u201carticle of manufacture\u201d may comprise the medium in which the code is embodied. Additionally, the \u201carticle of manufacture\u201d may comprise a combination of hardware and software components in which the code is embodied, processed, and executed. Of course, those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention, and that the article of manufacture may comprise any information bearing medium known in the art.","The logic of  A, and B describes specific operations occurring in a particular order. In alternative implementations, certain of the logic operations may be performed in a different order, modified or removed. Moreover, operations may be added to the above described logic and still conform to the described implementations. Further, operations described herein may occur sequentially or certain operations may be processed in parallel, or operations described as performed by a single process may be performed by distributed processes.","The illustrated logic of , A, and B may be implemented in software, hardware, programmable and non-programmable gate array logic or in some combination of hardware, software, or gate array logic.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 5","b":["500","100","120","180","500","500","502","504","510","505","504","510","506","510","504","502","508","512","502","514","502","500"]},"The computer architecture  may comprise any computing device known in the art, such as a mainframe, server, personal computer, workstation, laptop, handheld computer, telephony device, network appliance, virtualization device, storage controller, etc. Any processor  and operating system  known in the art may be used.","The foregoing description of implementations of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto. The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many implementations of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Referring now to the drawings in which like reference numbers represent corresponding parts throughout:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 3A","b":["3","3","3"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
