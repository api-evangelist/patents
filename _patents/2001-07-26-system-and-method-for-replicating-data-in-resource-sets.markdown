---
title: System and method for replicating data in resource sets
abstract: Described is a system and method for replicating each of a set of resources to a subject computer in a replica set prior to making use of a resource in the set of resources. The set of resources includes resources that are dependent upon each other for a proper functioning of the group. A manifest file that identifies each resource in a group of interrelated resources is used. The manifest file is generated at one computer in the replica set (typically the computer at which a modification to one of the interrelated resources occurred). When the modification occurs to one of the set of resources, the manifest file is transmitted (e.g., itself replicated) to each computer in the replica set. The manifest file includes an indicator that identifies the manifest file as a special file. When received at another computer in the replica set, a service evaluates the manifest file to identify whether the appropriate versions of the identified resources exist at the receiving computer. If not, the service at that computer awaits the receipt of each resource. The wait period may include delaying the execution of an application associated with (or even included within) the manifest file from launching. Alternatively, the FRS could simply disallow access to one or more resources identified in the manifest file until all have arrived. When all have arrived, the FRS releases control of the identified resources, which may then operate or be accessed in the ordinary manner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06917951&OS=06917951&RS=06917951
owner: Microsoft Corporation
number: 06917951
owner_city: Redmond
owner_country: US
publication_date: 20010726
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates to network-managed file systems. More particularly, the present invention relates to a file replication service for use in a networked computing environment.","The File Replication Service (FRS) pertains to the process of copying data from one computer to another over a network such that an identical data set is stored on each of the computers in the network. The network of computers sharing the replicated files is termed a \u201creplica set.\u201d FRS enhances file availability and file sharing by duplicating shared files. However, FRS does not guarantee the order in which files are duplicated at each computer. Files begin replication in sequential order based on when a changed file is closed, but file size and link speed determine the order of completion. In many instances, a group of files or data may be interrelated such that a proper functioning of any one file in the group is dependent on all the files existing and being current on a machine. In one example, an application program may include several files that are necessary to run the application. Given the latency of replicating all the necessary files, a user may attempt to launch the application before the FRS has had time to fully replicate all the necessary files to the particular computer in the replica set on which the application is being launched. The likely result is that the application would run unreliably or not run at all. Until now, there has been no solution to that problem.","Briefly stated, the present invention provides a system and method for ensuring that each of a set of resources has been replicated to a subject computer in a replica set prior to making use of a resource in the set of resources. In one aspect, the present invention provides a manifest file that identifies each resource in a group of interrelated resources. The group of interrelated resources includes resources that are dependent upon each other for a proper functioning of the group. In one example, an application program may require that the most current version of two separate files both exist on the computer or the application program may operate unreliably. The manifest file is generated at one computer in the replica set (typically the computer at which a modification to one of the interrelated resources occurred). When the modification occurs to one of the interrelated resources, the manifest file is first transmitted (e.g., itself replicated) to each computer in the replica set. The manifest file includes an indicator that identifies the manifest file as a special file. When received at another computer in the replica set, the FRS evaluates the manifest file to identify whether the appropriate versions of the identified resources exist at the receiving computer. If not, the FRS at that computer awaits the receipt of each resource. The wait period may include disallowing an application associated with (or even identified in) the manifest file from launching. Likewise, the FRS may simply disallow access to one or more resources identified in the manifest file until all have arrived. When all have arrived, the FRS releases control of the identified resources, which may then operate or be accessed in the ordinary manner.","In another aspect of the invention, the manifest file is secured by including with the manifest the security context of the user that created the manifest file. When the manifest file is received at a receiving member of the replica set, the FRS creates a new process in which to execute an application associated with the manifest file. The new process is given the same security context as that included with the manifest file. This aspect prevents the situation where a malicious user circumvents his own security constraints by creating a manifest file that causes an application to execute in and exploit a less-constrained process on another member of the replica set.","Illustrative Operating Environment","With reference to , an exemplary system for implementing the invention includes a computing device, such as computing device . In its most basic configuration, computing device  typically includes at least one processing unit  and system memory . Depending on the exact configuration and type of computing device, system memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. System memory  typically includes an operating system , one or more program modules , and may include program data . This basic configuration is illustrated in  by those components within dashed line .","Computing device  may also have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computing device . Any such computer storage media may be part of device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. All these devices are well know in the art and need not be discussed at length here.","Computing device  may also contain communications connection(s)  that allow the device to communicate with other computing devices , such as over a network. Communications connection(s)  is an example of communication media. Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2","b":["200","100","202","204","202","200","215","223","221","202","217","221","204"]},"As is known in the art, each of the several computing systems may communicate with each other through well known networking protocols and devices to share resources, such as files and printers. For instance, a file stored on a data store  at Machine C  may be made accessible to Machine A  over the wide area network  or to Machine D  over the local area network. Over and above those well known networking mechanisms, each of the computing systems also includes a File Replication Service (FRS) . The FRS  allows a portion of a data store, such as a file or directory, to be replicated to one or more of the computing systems. For instance, data store  may be identified as shared with one or more of the other computing systems in the networked environment . In addition, data store  may be configured to be replicated by the FRS  to each of the computing systems with which the portion is shared. Each of the computing systems with which data store  is shared is called a replication partner. The group of replication partners is called a replica set. For the purpose of this discussion only, the termed \u201cshared\u201d refers to resources that are both shared and identified for replication. For illustrative purposes only, each data store illustrated in  is assumed to be shared with each computing system in the networked environment . Those skilled in the art will appreciate that each computing system may include additional data storage that is not shared, or that each data store may be shared with fewer than all the computing systems in the networked environment . Moreover, each data store may be shared with other computing systems through non-networked mechanisms, such as CD-ROM or tape media, and it is not a requirement of the invention that the several computing systems each be \u201cshared\u201d in the conventional networked sense.","To achieve replication, the FRS  essentially operates as follows. A data store, which may be a directory or folder, is shared with each replication partner, which may be all or a subset of the computing systems in the networked environment . In that way, the resources (e.g., files) within the shared portion are available to each replication partner. If a resource within the shared data store is modified at any replication partner, the FRS  at that replication partner notes the modification and issues a notification to each of the other replication partners of the change. The replication partners may then accept the notification (or not based on certain criteria) and request that the modified resource be copied to the data store local to each replication partner.","For example, assume that each computing system in the networked environment  is a replication partner with respect to the shared data stores. If a file within the data store  at Machine A  is modified, the FRS  at Machine A  issues a notification of the change to each replication partner. A replication partner, such as Machine B , may accept the notification and copy the modified file from the data store  of Machine A  to the data store  at Machine B . Each of the other replication partners may also accept the notification and copy the file to their local data store. In that way, the modified file becomes replicated to each replication partner, and the modifications to the file are reflected at each replication partner.","In many instances, the several data stores may include replicas of a group of files or data that are interrelated such that a proper functioning of any one file in the group is dependent on all the files existing and being current within the data store. To better illustrate that situation, referring now to , one instance of the several data stores (e.g., data store  at Machine C ) is illustrated. Data store  contains several separate resources, each of which is replicated (via the FRS ) to the data stores of each of the replication partners. A group of the several resources may together form an application . Each of the resources within the application  may be necessary for a proper and complete functioning of the application. In addition, if the versions differ between one or more of the resources within the application , unpredictable execution of the application  may result.","The application  may occasionally be modified, such as if the application  is upgraded or if data is changed. The modification is likely to result in changes to many of the resources (e.g., file  and file ) within the application . In that situation, each replica of the application  at the several replication partners should include both modified file  and modified file  for a proper functioning of the application . However, given the latency of replicating resources within a networked environment, it is highly possible that one resource (e.g., file ) becomes replicated to a replication partner before other resources (e.g., file ). If a user attempts to launch the application  at the replication partner in the time between the first file  being replicated and the second file  being replicated (e.g., when only the current version of file  exists at the replication partner), application  may operate in an unpredictable and unstable manner.","This embodiment of the invention addresses that problem by including a manifest file  that describes a group of resources, such as the resources of application , that form a resource group. The resource group defines a set of resources that should each be present before any of the resources in the set is available for access. The manifest file  may identify each of the resources in the resource group including proper version information. A resource may also be part of more than one manifest file.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 4","FIG. 5"],"b":["325","325","500","5","325","325","410","415","411","412","325","325","500","325","500","5","325","325"]},"In this embodiment, during the creation of the manifest file , the process can call a function to include a special indicator (auto-launch ) that is interpreted by the FRS system as an instruction to automatically execute the resource group when it is completely replicated. The function causes the FRS system to capture the login credentials (e.g., a security \u201ctoken\u201d) of the process creating the manifest. These credentials are then included in the manifest file  as a token  for use when the resources are executed, as will be described later. In this way, a malicious process is prevented from creating a malicious application, such as a virus, and spreading the malicious application to other replication partners. In the absence of this safeguard, the resources could be made to automatically execute in an administrative or system process and thereby circumvent the security safeguards attached to the malicious process. With the advantages of this feature, when the malicious application is executed on a replication partner, it will have no more permissions than those had by the process that created the manifest file.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 5","FIG. 5"],"b":["500","500","505","507","509","511","501","500","501","501","501","2"]},"The components and operation of this embodiment of the invention are best described through the following example. Several resources are replicated across the replica set containing RP , RP , RP , RP , and RP , and thus exist within a data store at each replication partner, such as data store  at RP . Included in those resources is an application having a resource group , similar to application  (FIG. ). Although in this example the application already exists at each replication partner, this embodiment of the invention is equally applicable to situations where an application is first added to the data store at one replication partner and does not yet exist at other replication partners, as will become more clear later.","Continuing with the example, the application is upgraded or otherwise modified at RP , resulting in multiple modified files within the resource group . A manifest file  has been created in conjunction with the modifications to the application and in accordance with the discussion above regarding FIG. . The manifest file  identifies each resource in the resource group  and the versions of those resources. Thus, when the resources of the application are modified, the FRS system resident at RP  notes the modification and creates a \u201cchange order\u201d message.","Referring briefly to , which illustrates one example, the change order  is a message indicating that resources within the data store  have changed and should be replicated to each of the replicating partners. The change order  includes a resource name  and a resource globally unique identifier (GUID)  uniquely identifying the resources that are affected by the change order  (the manifest file  in this instance) and a version identifier . In addition, the change order  includes a flag  that indicates to the FRS system  that the change order  involves a manifest file, which is a special file to the FRS system . The change order  may optionally include other information useful to the FRS system , such as a checksum  of the contents of the manifest or a parent GUID  for the resources identified in the change order .","Returning to , when the change order has been created, the RP  passes it to each of the other replication partners, such as RP . In one embodiment, passing the change order may take the form of issuing a remote procedure call (RPC) to the RP  to handle the change order. When received at the RP , the change order is stored in a process queue  to await handling. A change order handler  is informed that the change order has arrived and retrieves the change order from the queue . The change order handler  compares the resources identified in the change order to information contained in a FRS database . Referring briefly to , the FRS database  is a file or other resource that includes information identifying each of the several resources within the local data store . Each resource may be identified by name , by GUID , and by version . In addition, the FRS database  may include a flag  that identifies whether each resource is a manifest file. Optionally, other identification information may be included.","Returning again to , the change order handler  compares the change order to the FRS database  to determine whether the resources identified in the change order are interesting to the FRS system . For instance, if the change order identifies a resource having a particular version, and that version of the resource is already identified in the FRS database  (meaning that the modified resource already exists locally), then the change order handler  may reject the change order. Rejecting the change order may involve simply doing nothing more, notifying the sending party that the change order was rejected, or may involve retiring the change order (described later) without retrieving the resources.","In this example, the change order identifies a resource (the manifest file ) which does not exist in the local data store . Accordingly, the change order handler  accepts the change order, such as by issuing an acceptance reply to the RP , and proceeds to replicate the manifest file . The change order handler  may instruct a fetch process  to retrieve the manifest file  from RP . Using conventional network file transfer mechanisms, the fetch process  retrieves the manifest file  from the RP  and passes it to an install process  that stores the manifest file  to the local data store . The install process  also updates the FRS database  to reflect that the manifest file  is now stored at the local data store . In addition, the change order handler  may compute a checksum for the manifest file and compare it to the checksum  stored in the change order to determine if the contents have changed, and if so, rejecting the change order.","At this point, the manifest file  has been identified as being such and has been retrieved from RP . The install process  then passes the change order to a retire process  to be retired. Retiring the change order involves marking the change order as handled and storing the change order in an outbound log  for dissemination to other replication partners (e.g., RP , RP , RP ). In addition, the retire process  notes that the change order refers to a manifest file (by the manifest file flag ) and passes the change order to a manifest handler  or otherwise notifies the manifest handler  of the existence of the manifest file  on the local data store .","The manifest handler  retrieves the manifest file  from the local data store  and compares the list of resources identified in the manifest file  with the resources identified in the FRS database . That comparison allows the manifest handler  to determine which resources identified in the manifest file  have already been replicated and which resources remain to be replicated. The manifest handler  may periodically query the FRS database  to determine when all the identified resources have arrived, or, alternatively, may register to be notified each time a change is made to the FRS database . Until the manifest handler  determines that all identified resources have arrived, it may lock access to each of the resources identified in the manifest file . More likely, the manifest handler  may simply delay making the resources associated with the manifest file  readily available for execution, such as by delaying the execution of an installation file or script or by not updating a system registry until all the resources have arrived. In this way, different versions of the resources within the resource group will not be accessed until the resource group has been completely replicated.","Eventually, the resource group is complete, and the manifest handler  makes the several resources in the resource group available for execution or other access at RP . If the manifest file  was created with instructions to execute when the resource group is complete (as described above), the manifest handler  may execute the resource group in an application process  created with the token  identified in the manifest file . As mentioned above, this security safeguard prevents a malicious network user from creating a manifest file describing a resource group that includes a virus that will self-execute on each replication partner that receives the manifest file.","Additional computers can be added to the replica set at any time. When this occurs, the new member computer does an initial sync with its specified inbound partner. As part of this sync, the new member computer receives any manifest files and, if they are not expired, the normal processing is performed. This has the benefit that existing manifests from installed applications which have not otherwise expired will cause that related application to get installed simply by adding the new member computer to the replica set without further administrative action is required.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 8","b":"801"},"At block , a manifest file is created at the first member of the replica set. The manifest file includes an identifier for each resource in the resource group at the first replica set member. Additionally, the manifest file may include GUIDs for each identified resource, or version identifiers for each resource, or both. One particular embodiment may include additional options in the manifest file. For instance, a LAUNCH-EQ option, a LAUNCH-GE option, and a LAUNCH-FAIL option may be available. Each could be included in the manifest file and identify a file name of an application or script to run. LAUNCH-EQ would cause the associated application to be launched only if resource version levels and conditions are met exactly as identified in the manifest file. LAUNCH-GE would cause the associated application to launch if the conditions are met or if the resource version levels on the given computer are greater than those specified in the manifest. LAUNCH-FAIL would cause the associated application to be launched if LAUNCH-GE was not specified and the resource version levels are higher than specified in the manifest or other required manifest conditions are not satisfied.","A manifest may have other required conditions which, because of unforeseen changes in the replicated environment, make it inappropriate to launch the associated application. For example, the application may be expecting a particular file to be deleted but other changes in the environment have caused that particular file to be \u201creanimated,\u201d such as through last-writer-wins semantics. In that case, the manifest conditions would never be met and the app associated with the LAUNCH-FAIL directive should be executed. The application might be a notification to the manifest submitter that the manifest failed to complete on the given computer.","Each resource listed in the manifest file could also contain a predicate that must be satisfied in addition to the version level. Once the version level test passes, this predicate must also be satisfied for the manifest to succeed. For example, four such predicates might be that the associated resource MUST-BE-DELETED, MUST-BE-PRESENT, ANY-VERSION-ALLOWED, or MAY-BE-MISSING.","At block , the manifest file is reproduced at another member of the replica set. The manifest file may be reproduced to the other replica set member by issuing a notice that the manifest file has been modified (or created) at the first member. The other replica set member may optionally verify that the manifest file does not currently exist locally, and if not, may retrieve a copy of the manifest file from the first replica set member.","At block , in response to the manifest file being received, the other replica set member determines whether each resource identified in the manifest file exists locally. For example, the other replica set member may compare the manifest file to a database that identifies the resources stored at the other replica set member. For the purpose of this determination, a resource is considered present if the version number of the existing resource is equal to or greater than the version number identified in the manifest for the resource. Alternatively, identity of version numbers could be required.","If each resource identified in the manifest file does not exist locally, then, at block , the other replica set member delays finalizing an installation process or other use of the resources until each of the resources does exist locally. For example, the other replica set member may await notification that new resources have been received at the other replica set member, and re-compare the manifest file to the database of locally stored resources until all the resources have arrived. Alternatively, the other replica set member may periodically re-compare the manifest file to the database.","Eventually, all the resources arrive at the other replica set member (or a timeout occurs), and, at block , the other replica set member releases access to the resources or completes an installation process, such as by launching a script or application identified or included within the manifest file. In that way, a user or other process may access the resources as a group without fear that the group will operate in an unpredictable or unstable manner.","The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
