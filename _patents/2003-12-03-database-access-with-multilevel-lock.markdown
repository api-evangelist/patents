---
title: Database access with multilevel lock
abstract: A multi-level lock procedure is used in scheduling access of a table in a database by multiple processes running in parallel. A lock level is associated with a particular process, a higher lock level representing a larger number of other processes having priority over the particular process in accessing the table. Repeatedly attempt to associate the particular process with a lower lock level, and if the particular process has been successfully associated with the lower lock level, release a previous lock level associated with the particular process so that the previous lock level may be associated with other processes. Allow the particular process to access the table when the lock level for the particular process is equal to a preset value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07574438&OS=07574438&RS=07574438
owner: SAP Aktiengesellschaft
number: 07574438
owner_city: Walldorf
owner_country: DE
publication_date: 20031203
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This invention relates to database access with multilevel lock.","In a parallel processing environment, a database can be shared by more than one process. For example, a database can contain records, each record containing entries related to customers of a company and entries related to products that the customers have ordered. A first process related to customer relationship management can attempt to access the database to update customer contact information of a particular record. A second process related to inventory control can also try to update a product specification contained in the same record. The customer relationship management information and the inventory control information within the same record can be dependent or independent of each other. To prevent multiple processes from updating the same record resulting in errors, a locking mechanism is provided so that before the first process attempts to modify a record, the first process \u201clocks\u201d the record to prevent other processes from modifying the record. When the second process attempts to modify a locked record, the attempt is rejected, and an error message is returned to the second process. The second process waits a period of time before attempting to modify the record again.","In general, in one aspect, the invention features a method of scheduling access of a table by multiple processes, including associating a lock level with a particular process, a higher lock level representing a larger number of other processes having priority over the particular process in accessing the table; repeatedly attempting to associate the particular process with a lower lock level, and if the particular process has been successfully associated with the lower lock level, releasing a previous lock level associated with the particular process so that the previous lock level may be associated with other processes; and allowing the particular process to access the table when the lock level for the particular process is equal to a preset value.","This and other aspects of the invention may include one or more of the following features. The preset value is equal to one. Each of the processes attempts to associate itself with a lower lock level independently of other processes.","In general, in another aspect, the invention features a method that includes, upon receiving a request from a first process to access a record in a database, associating a first lock level to the first process and allowing the first process to access the record but preventing other processes from accessing the record until the first process finishes accessing the record; and upon receiving a request from a second process to access the record while the first process is still accessing the record, associating a second lock level to the second process. The method includes, when the first process finishes accessing the record, releasing the first lock level from being associated with the first process, and either (a) releasing the second lock level from being associated with the second process and associating the first lock level with the second process, allowing the second process to access the record but preventing other processes from accessing the record until the second process finishes accessing the record, and when the second process finishes accessing the record, releasing the first lock level from being associated with the second process, or (b) releasing a lock level from being associated with a third process and associating the first lock level with the third process, allowing the third process to access the record but preventing other processes from accessing the record until the third process finishes accessing the record, and when the third process finishes accessing the record, releasing the first lock level from being associated with the third process.","This and other aspects of the invention may include one or more of the following features. Preventing other processes from accessing the record includes allowing the other processes to read the record but not modify the record. The record is locked when the first lock level is associated with a process. Information is written to a queue to specify which lock level is associated with which process. At least two of the first, second, and third processes are run in a parallel processing environment.","In general, in another aspect, the invention features a method that includes locking a record in a database at multiple levels when multiple processes running in parallel attempt to access the record; assigning a lock level to each of the multiple processes, different processes having different lock levels; and selectively permitting one of the multiple processes to access the record at a time.","This and other aspects of the invention may include one or more of the following features. The lock levels of the processes are reassigned when a process accessing the record terminates its access to the record. A process that attempted to access the record earlier than another process is assigned a lower lock level than the other process, and each process other than the process terminating its access to the record is assigned a lower lock level when the process terminates its access to the record. Information is stored in a queue indicating which process is associated with which lock level. Multiple instances of a procedure are called, where the procedure assigns a lock level to a process, and each instance of the procedure being associated with one of the multiple processes and configured to attempt to assign a different lock level to the process until the process is granted access to the record.","In general, in another aspect, the invention features a system that includes a database to store records, and a queue to store information relating to lock levels of processes that attempt to access the records, different processes having different lock levels when accessing the same record, one of the processes having a particular lock level being allowed to access the record.","This and other aspects of the invention may include one or more of the following features. The system includes a memory to store software code for implementing a procedure in which instances of the procedure are used to assign lock levels to the processes. The software code is configured so that the instances of the procedure are run in parallel.","In general, in another aspect, the invention features a computer program product, tangibly stored on a machine-readable medium, for implementing a multi-level lock process, comprising instructions operable to cause one or more programmable processors to lock a record in a database at a first level to allow a first process to modify the record but prevent other processes from modifying the record; and lock the record at a second level to allow a second process to modify the record after the record is unlocked at the first level but to prevent other processes from modifying the record while the record is being modified by the second process.","This and other aspects of the invention may include one or more of the following features. The computer program product includes instructions operable to cause the one or more programmable processors to, after the record is locked at the second level, check whether the record is locked at the first level, and if the record is not locked at the first level, lock the record at the first level a second time and unlocking the record at the second level. The computer program product includes instructions operable to cause the one or more programmable processors to write to a queue to specify that the record has been locked at the first level and\/or the second level. The computer program product includes instructions operable to cause the one or more programmable processors to run the first and second processes in parallel.","In general, in another aspect, the invention features a computer program product, tangibly stored on a machine-readable medium, for implementing a multi-level lock process, includes instructions operable to cause one or more programmable processors to, upon receiving a request from a first process to access a record in a database, associate a first lock level to the first process and allow the first process to access the record but prevent other processes from accessing the record until the first process finishes accessing the record; and upon receiving a request from a second process to access the record while the first process is still accessing the record, associate a second lock level to the second process. The computer program product includes instructions operable to cause one or more programmable processors to, when the first process finishes accessing the record, release the first lock level from being associated with the first process, and either (a) release the second lock level from being associated with the second process and associate the first lock level with the second process, allowing the second process to access the record but preventing other processes from accessing the record until the second process finishes accessing the record, and when the second process finishes accessing the record, releasing the first lock level from being associated with the second process, or (b) release a lock level from being associated with a third process and associate the first lock level with the third process, allowing the third process to access the record but preventing other processes from accessing the record until the third process finishes accessing the record, and when the third process finishes accessing the record, releasing the first lock level from being associated with the third process.","This and other aspects of the invention may include one or more of the following features. The instructions cause the one or more programmable processors to allow the other processes to read the record but not modify the record. The computer program product includes instructions operable to cause the one or more programmable processors to lock the record when the first lock level is associated with a process. The computer program product includes instructions operable to cause the one or more programmable processors to write to a queue to specify which lock level is associated with which process. The instructions cause the one or more programmable processors to execute at least two of the first, second, and third processes in a parallel processing environment.","In general, in another aspect, the invention features a computer program product, tangibly stored on a machine-readable medium, for scheduling access of a table by multiple processes, including instructions operable to cause one or more programmable processors to associate a lock level with a particular process, a higher lock level representing a larger number of other processes having priority over the particular process in accessing the table; repeatedly attempt to associate the particular process with a lower lock level, and if the particular process has been successfully associated with the lower lock level, release a previous lock level associated with the particular process so that the previous lock level may be associated with other processes; and allow the particular process to access the table when the lock level for the particular process is equal to a preset value.","This and other aspects of the invention may include one or more of the following features. The instructions are configured so that the preset value is equal to one. The instructions are configured so that each of the processes attempts to associate itself with a lower lock level independently of other processes.","In general, in another aspect, the invention features a computer program product, tangibly stored on a machine-readable medium, for implementing a multi-level lock process, comprising instructions operable to cause one or more programmable processors to lock a record in a database at multiple levels when multiple processes running in parallel attempt to access the record; assign a lock level to each process, different processes having different lock levels; and selectively allow one of the multiple processes to access the record at a time.","This and other aspects of the invention may include one or more of the following features. The computer program product includes instructions operable to cause the one or more programmable processors to reassign the lock levels of the processes when a process accessing the record terminates its access to the record. The instructions are configured so that a process that attempted to access the record earlier than another process is assigned a lower lock level than the other process, and each process other than the process terminating its access to the record is assigned a lower lock level when the process terminates its access to the record. The computer program product includes instructions operable to cause the one or more programmable processors to store in a queue information indicating which process is associated with which lock level. The computer program product includes instructions operable to cause the one or more programmable processors to call multiple instances of a procedure that assigns a lock level to a process, each instance of the procedure associated with one of the multiple processes and is configured to attempt to assign a different lock level to the process until the process is granted access to the record.","An advantage of the invention is that multiple users can send requests for accessing a shared database record even when another user is currently using the shared database record. The requests are automatically pipelined in a queue so that the users can access the shared database in sequence without being rejected or causing sharing violation errors.","Other features and advantages of the invention are apparent from the following description, and from the claims.","Like reference symbols in the various drawings indicate like elements.","As shown in , in a parallel processing system , multiple software processes (e.g., processes A, B, and C) access and process a table  in a database . System  implements a multilevel lock procedure  () to allow the processes to share table  without causing errors when the processes A, B, C attempt to access the same table  at the same time. Each process A, B, C attempting to access a table is assigned a \u201clock level.\u201d A process (A, B, or C) is assigned a lock level equal to n if previous (n\u22121) lock levels have previously been assigned to other processes currently using the same table  or waiting to use the table . Each process A, B, C attempts to obtain a lower lock level, and if successful, unlocks (releases) the previous lock level so the previous lock level can be available to other processes. A process (A, B, or C) is granted access to the table  when its associated lock level is equal to 1. The multilevel lock procedure  (described below) provides an efficient scheduling mechanism to allow multiple processes running in parallel to access and process data in table .","For example, initially, when process A attempts to access (86) table , process A is assigned a \u201clock level\u201d that is equal to 1 since no other processes are accessing table . The assignment of lock level  to process A is stored in a first-in-first-out (FIFO) queue . Table  is locked (90), and process A is granted access to table . While process A is processing data in table , process B attempts (92) to access the same table . Process B is assigned a lock level that is equal to 2 since lock level  is already assigned to process A. The assignment of lock level  to process B is stored in FIFO queue . Before process A finishes using table , process C attempts (94) to access the same table . Process C is assigned a lock level that is equal to 3 since lock levels  and  have already been assigned to other processes. The assignment of lock level  to process C is stored in FIFO queue . When process A successfully executes and finishes using table , lock level  is released (98), and the table  is unlocked (99). This allows process B to access table .","The multilevel lock procedure  can be implemented as, e.g., a software process or an application programming interface (API), that is called by other processes when accessing a table in database . In the description below, depending on context, the term \u201cprocedure\u201d is used to refer to the procedure itself or the software (e.g., process or API) that implements the procedure. Depending on context, the term \u201cprocess\u201d can be a noun (as in \u201ca process that accesses the data in the database\u201d) or a verb (as in \u201cto process the data in the database\u201d).","As shown in , procedure  starts (102) by assigning (104) a variable n to be equal to 1. The variable n represents a lock level that is assigned to a process (e.g., process A). An attempt is made to assign (106) a lock level n to the process, and a determination (108) is made whether lock level n is successfully assigned. Information relating to which lock levels have been assigned to which processes are stored in FIFO queue . If lock level n cannot be successfully assigned to the process, n is incremented (110) by 1, and the determination (106and 108) of whether lock level n can be assigned to the process is repeated. If lock level n can be successfully assigned to the process, a determination (112) is made whether n is equal to 1. If n is not equal to 1, then n is decremented (128) by 1.","Procedure  attempts (130) to assign lock level n to the process, and determines (132) whether the lock level can be successfully assigned to the process. If lock level n can not be successfully assigned to the process, the attempt (130) to assign lock level n to the process is repeated. Procedure  can pause for a predetermined period between attempts to assign lock level n to the process. When the lock level n is successfully assigned to the process, the lock level (n+1) is unlocked (134); i.e., the assignment of lock level (n+1) is released from the queue so that lock level (n+1) is available to other processes.","The determination (112) is made whether n is equal to 1. If n is equal to 1, an attempt to lock (114) the table  is performed. Locking the table  can be achieved by calling a locking API provided by system . Locking the table  allows one process to access the table and prevents other processes from accessing the table, or allows other users to read but not modify the table. A determination (116) is made as to whether the table  is successfully locked. If the table  is not locked, procedure  ends and returns an error message (118). If the table  is locked, access to table  is granted to the process, and the process can process (120) and modify the data in table . After the process finishes processing and updating table , the process calls an unlock API provided by system  to unlock (122) table . Procedure  unlocks (124) lock level  (i.e., releases lock level  from the FIFO queue  so that lock level  can be assigned to others), and ends (126).","Each time a process attempts to access a table  in database , the process calls procedure . When multiple processes attempt to access tables in database , multiple instances of the procedure  are executed in parallel to schedule access of the tables. The following describes how processes A, B, and C access the table  by calling procedures , , and (which are instances of procedure ), respectively, to schedule access of the table.","As shown in , a timing diagram  shows events that happen when processes A, B, and C attempt to access table . Process A requests (202) access to table  by calling procedure . Procedure determines that the table  is not locked, assigns (204) a lock level  to the process A, locks (206) table , and grants (208) access of the table  to process A. While process A is processing (210) data in table , process B requests (212) access to table  by calling procedure . Procedure determines that lock level  has already been assigned to some other process, assigns (214) lock level  to the process B, and waits for process A to finish using table . While process A is using table  and process B is waiting for process A to finish, process C requests (216) access of table  by calling procedure . Procedure determines that the lock level  has already been assigned to some other process, assigns (218) lock level  to the process C, and waits for processes A and B to finish using the table .","Procedure repeatedly tests whether it can assign lock level  to process B (130 and 132in ). Procedure repeatedly tests whether it can assign lock level  to process C. When process A notifies (220) procedure that process A has finished using table , procedure unlocks level  (222) (i.e., makes lock level  available to other processes), and unlocks (224) table . Procedure determines that lock level  is available, assigns (226) lock level  to process B, unlocks level , locks (228) table , and grants (230) access of table  to process B. Process B processes (232) data in table . When procedure c detects that level  is available, procedure assigns (229) lock level  to process C and unlocks level .","Procedure repeatedly tests whether it can assign lock level  to process C. When process B notifies (234) that process B has finished using table , procedure unlocks (236) level  and unlocks (238) table . Procedure determines that lock level  is available, assigns (240) lock level  to the process C, unlocks lock level , locks (242) table , and grants (244) access of table  to process C. Process C processes (246) data in table . When the process C notifies (248) procedure that process C has finished using table , procedure unlocks (250) level  and unlocks (252) table .","Other embodiments are within the scope of the following claims For example, each lock level may be associated with locking one record in one table, or locking multiple records in one table, or locking multiple records in multiple tables, or locking an entire table, or locking multiple tables."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
