---
title: Real-time software receiver
abstract: A real-time software receiver that executes on a general purpose processor. The software receiver includes data acquisition and correlator modules that perform, in place of hardware correlation, baseband mixing and PRN code correlation using bit-wise parallelism.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07010060&OS=07010060&RS=07010060
owner: Cornell Research Foundation, Inc.
number: 07010060
owner_city: Ithaca
owner_country: US
publication_date: 20040108
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","STATEMENT OF GOVERNMENT INTEREST","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present application claims priority to U.S. Provisional Application No. 60\/439,391 filed Jan. 10, 2003 entitled REAL-TIME SOFTWARE RECEIVER which is incorporated herein in its entirety by reference.","This invention was made with United States Government support from the Office of Naval Research (ONR) under contract number N00014-02-J-1822 and from the National Aeronautics and Space Administration (NASA) under contract numbers NCC5-563, NAG5-11819, and NAG5-12089. The United States Government has certain rights in the invention.","This invention relates generally to software radio receivers, and more specifically to a software receiver for positioning systems.","A typical positioning system receiver, such as is used in the Global Positioning System (GPS), includes an antenna, a radio frequency (RF) section, a correlator, a signal tracking and demodulation component, and a component to compute the navigation solution. The antenna, which is possibly followed by a pre-amplifier, receives L-band GPS signals. The RF section filters and down converts the GHz GPS signal to an intermediate frequency in the MHz range. The RF section also digitizes the signal. The correlator separates the down-converted signal into different channels (ten or more in modern receivers) allocated to each satellite. For each satellite, the correlator mixes the Doppler-shifted intermediate frequency signal to baseband by correlating it with a local copy of the carrier replica signal and it distinguishes the particular satellite by correlating the signal with a pseudo-random number (PRN) code. Software routines cause the carrier replica and PRN replica signals to track the actual received signal, extract the navigation message, and compute the navigation solution.","Baseband mixing is a multiplication of an input signal by a complex exponential where the frequency of the complex exponential approximately matches that of the input signal. The resultant signal is centered at baseband. A complex signal can be broken down into cosine and sine signal components, resulting in separate in-phase and quadrature components. The frequency of the baseband mixed signal must be controllable to within a few millihertz in the case of a phase-locked loop for use in a precision navigation system, and the baseband mixed signal must have a continuously varying phase. In a hardware correlator, local oscillators generate cosine and sine signal components that have precise frequency control and a continuous phase. Generating cosine and sine signal components on the fly with the correct frequency and phase is too time consuming to be feasible for a software correlator. Instead, the software correlator generates cosine and sine signal components on a grid of frequencies off-line. These signal components must be stored on a time grid of points sampled at the RF front-end sampling frequency, for example, at 5.714 MHz for one particular RF front-end hardware configuration, and the signals must last for a typical accumulation period, e.g., for a 0.001 second coarse\/acquisition (C\/A) PRN code period when working with GPS L1 civilian signals. It takes tens of gigabytes of memory or more in order to brute-force store all frequencies on a one mHz grid ranging from \u221210 KHz to +10 KHz, which is the needed frequency range when tracking GPS satellites from a terrestrial receiver, and additional storage is required to store a grid of possible starting phases at each frequency point.","PRN code mixing is a multiplication of a baseband mixed signal by a prompt +1\/\u22121 PRN code or by a +2\/0\/\u22122 early-minus-late PRN code, where the code timing and frequency approximately match that of the input signal. The resultant signal is a constant in the case of prompt PRN code mixing, and an approximately linear function of the code timing error in the case of early-minus-late mixing. A receiver accumulates both of these correlation outputs. The magnitude of the prompt accumulation indicates signal strength and whether a signal has been detected, and its in-phase (real) and quadrature (imaginary) components are used to measure carrier phase and Doppler shift. The magnitude of the early-minus-late accumulation measures the code timing error; it will be zero when the timing error is zero.","The code phase of the baseband mixing signal must be controllable to within a percent or less of a PRN code chip for use in a precision navigation system. In a hardware correlator, local oscillators generate the prompt and early-minus-late PRN code replicas. A software correlator can either compute and store PRN code replicas, or compute them in real-time.","The current Global Positioning System is slated to realize expanded capabilities that include new civilian codes on the L2 frequency, a new L5 frequency, and new codes (M-code, CL and CM codes) on the L2 frequency. Some of these upgrades are slated to start within one to three years. A hardware correlator requires hardware modifications in order to use these new signals. In the near term, a receiver designer will be faced with a complex trade-off in order to decide whether the extra complexity is worth the improved performance that will accrue only very slowly as new GPS satellites replace older models. One way to avoid the complex trade-off is to use a software receiver that can receive and process new signals without the need for a new correlator chip set.","A software receiver is flexible because its software components can be easily modified. One application of a software receiver is to merge together numerous devices that use wireless digital communication protocols to form a single device. For example, a cell phone, GPS receiver, and Personal Data Assistant (PDA) could become a single device that plays the role of all three. Another use of a software receiver is to shorten development and to-market times for new wireless devices. For example, as new frequencies and codes are added to GPS, a software receiver having a software correlator simply needs to be reprogrammed, while a hardware approach would require a brand new correlator chip design. New PRN codes can be used simply by making software changes. Thus, software receiver technology lessens the risks involved for designers during the period of transition to the new signals. Furthermore, a software receiver could be reprogrammed to use the Galileo system (European GPS) or GLONASS (Russian GPS).","In the recent past, GPS software receivers have been developed that either post-process stored signals or operate in real-time. Previous real-time software receivers function with a limited number of channels (4\u20136) or require high-end computer speeds or digital signal processor (DSP) chips such as are disclosed in -, Akos et al., ION NTM 2001, 22\u201324 Jan. 2001, Long Beach, Calif., pp. 809\u2013816 (Akos 2001a), and () , Akos et al., ION GPS 2001, 11\u201314 Sep. 2001, Salt Lake City, Utah, pp. 2851\u20132858, both incorporated herein in their entireties by reference.","Therefore, it is an object of the present invention to create a software receiver that operates in real-time and is not restricted to a severely limited number of channels or to a very fast processor.","Another object of the present invention is to minimize the number of sine and cosine signal components that must be stored.","A further object of the present invention is to process incoming signals through bit-wise parallelism.","A still further object of the present invention is to process over-sampled signals by use of bit-wise parallelism.","A still further object of the present invention is to use very long over-sampled PRN codes efficiently in a bit-wise parallel software receiver.","The objects set forth above as well as further and other objects are addressed by the present invention. The solutions and advantages of the present invention are achieved by the illustrative embodiment described herein below.","The software receiver system and method of the present invention enable the efficient execution of a set of algorithms, that perform software correlation on data sampled from incoming channels, on a general purpose processor. The system and method of the present invention provide for either PRN code storage or computation of PRN codes in real-time. PRN code storage is appropriate for PRN codes that have short periods, such as the GPS coarse\/acquisition codes, which are 1023 chips long. In this case, the system and method of the present invention pre-compute over-sampled replicas of entire PRN code periods and store them for orderly and efficient retrieval, such as in a table. This table can include a selection of code start times as measured relative to the sample times at which RF data are available from the receiver front end. There is a separate table for each unique PRN code.","The system and method of the present invention can also generate over-sampled versions of the prompt and early-minus-late PRN codes in real-time through use of an over-sampling function described herein. The values of the over-sampling function can be located in a specially designed table that can be generic across PRN codes. The length of the specially designed table can be independent of the length of the PRN code whose replica is being used to process a given received signal. The system and method of the present invention include techniques for efficiently calculating indices into the specially designed table that enable rapid, real-time table look-up.","The system of the present invention includes a software correlator that can mix the received signal to baseband, compute baseband\/PRN correlations through bit-wise parallelism and look-up tables using either the tabulated or real-time-generated PRN codes, and compute accumulations through bit-wise parallelism and processor instructions or look-up tables. Bit-wise parallelism allows the processing of multiple data samples simultaneously as the multiple bits of a given word of computer data. For example, for 32-bit words, the software correlator can process up to 32 samples at a time. Bit-wise parallelism can optimally operate when each signal in question can be represented by only a few bits, which is normally the case in RF digital signal processing of navigation signals.","The bit-wise parallel operations of the present invention can save computation time in comparison to integer mathematical correlation operations. If, for example, four accumulations are required per sample, integer mathematics requires six multiplications and four additions per sample (except for the last sample). At a sampling rate of, for example, 5.714 MHz this translates into 57,140 integer operations per PRN code period. In the illustrative embodiment, 33,500 bit-wise parallel operations are necessary per PRN code period when the RF signal has a 2-bit representation. This operation count is further reduced to approximately 16,750 bit-wise parallel operations per PRN code period when the RF signal has a 1-bit representation. Thus, there can be a savings of almost a factor of two to almost a factor of four in the operation count.","The system and method of the present invention also include a table of pre-computed baseband mixing sine waves, algorithms that can produce correlation accumulation outputs that are equivalent to what would be produced by a continuously variable sine wave, and a method of use of the table and algorithms. Thus, in the present invention, a relatively small set of sine wave values need to be pre-computed and saved, which can conserve computer memory and processing time.","The present invention also includes a system and method for tracking the phase of PRN code replicas in software in order to track the timing of any given \u201cchip\u201d of the PRN code replica as measured with respect to a pre-specified set of sample times at which the basic raw data comes out of the RF front end (a chip is an element of a PRN code). The PRN code phase is kept track of via a variable for each channel, that indicates the PRN code start time with respect to the RF sample times. The system and method of the present invention allow for the synchronization of the measurements of PRN code phase, carrier phase, and carrier frequency for each satellite relative to these sample times.","The method for tracking the phase of each PRN code replica and the phase of each carrier replica includes the steps of latching all the C\/A code phases, carrier phases, epoch counters, and carrier frequencies for each satellite at a pre-specified time, and computing the pseudo range to each satellite using the C\/A code phase and epoch counters. The method also includes the step of tracking and updating code and carrier phases by estimating code chipping rate and carrier Doppler shift inputs. The method further includes the step of computing the code phase at the pre-specified time for each satellite as a function of the updated code chipping rate and the pre-specified time. The method further includes the step of computing the carrier phase at the pre-specified time as a function of the updated carrier phase, the Doppler shift, and the pre-specified time. The timing of the PRN code phase (or chip location) is the most fundamental of GPS measurements for use in navigation data processing. The monitoring of these times in software allows complete control of the precision with which they can be measured, and it allows precise synchronization of these times with the measurement times of data from other sensors, such as inertial measurement units. This feature gives an enhanced ability to develop what are known as deeply coupled systems that must fuse GPS data with data from other types of sensor systems.","The software correlator of the present invention can advantageously be easily adapted to accept signals at any frequency, new PRN codes, or even signals for different types of devices. Thus, the same processing hardware could use the software correlator to implement such devices as a GPS receiver, a cell phone, or both. To allow for new codes, new frequencies, and new types of functionality, small changes can be made in the software correlator, or different versions of the software correlator can be run on the same processor. Hardware-correlator-based receivers of the prior art can deal only with frequencies and PRN codes that are hard-wired into their designs. Also, the system and method of the present invention could be implemented within systems such as GLONASS receivers, cell phones and cell base stations, pagers, wireless Ethernet (e.g. 802.11x standards), Bluetooth\u2122, Blackberry\u00ae wireless internet devices, and satellite radio\/phones (e.g. INMARSAT\u00ae). In fact, the system and method of the present invention are applicable to any sort of telecommunication system\/device that uses spread spectrum, code division multiple access (CDMA) PRN codes for the transmission of information, either wired or wireless.","For a better understanding of the present invention, together with other and further objects thereof, reference is made to the accompanying drawings and detailed description. The scope of the present invention is pointed out in the appended claims.","The present invention is now described more fully hereinafter with reference to the accompanying drawings, in which the illustrative embodiment of the present invention is shown. The following configuration description is presented for illustrative purposes only. Any computer configuration satisfying the speed and interface requirements herein described may be suitable for implementing the system of the present invention. The equations herein are stated in general terms, but have parameters that are specific to the GPS L1 C\/A signal for illustrative purposes only. For example, the 0.001 sec. accumulation interval seen in many of the equations is the nominal C\/A code period. Also, the C\/A PRN code of the illustrative embodiment can be replaced by the PRN code of any other CDMA signaling system.","By way of introductory explanation, RF signal processing equations and terms are herein provided. The time-domain L1 C\/A signal received from, for example, a satellite, is represented by: \n\n\nwhere tis the sample time, Ais the amplitude, Dis the navigation data bit, C[t] is the C\/A code, \u03c4and \u03c4are the start times of the received kand k+1C\/A code periods, \u03c9is the intermediate frequency corresponding to the L1 carrier frequency, \u03c6(t) is the carrier phase perturbation due to accumulated delta range, nis the receiver noise, and the subscript j refers to a particular GPS satellite. The summation is over all visible GPS satellites. The negative sign in front of \u03c6(t) comes from the high-side mixing that occurs in the RF front-end that has been used in the illustrative embodiment. The signal in equation (1) is the output of a typical RF front end.\n","A GPS receiver works with correlations between the received signal and a replica of it. The correlations are used to acquire and track the signal. The replica is composed of two parts, the carrier replica and the C\/A PRN code replica. Two carrier replica signals are used, an in-phase signal and a quadrature signal. When mixed with the received signal from the RF front end they form the in-phase and quadrature baseband mixed signals represented by: \n\n\nwhere equations (2) and (3) apply during the kC\/A code period. In these equations {circumflex over (\u03c4)}and {circumflex over (\u03c4)}are the receiver's estimates of the start times of the kand k+1code periods, {circumflex over (\u03c6)}is the estimated carrier phase at time {circumflex over (\u03c4)}, and {circumflex over (\u03c9)}is the estimated carrier Doppler shift during the kcode period.\n","A typical receiver computes the estimates {circumflex over (\u03c4)}, {circumflex over (\u03c4)}, {circumflex over (\u03c6)}, and {circumflex over (\u03c9)}by various conventional means that are described in , A. J. Van Dierendonck, , B. W. Parkinson and J. J. Spilker, Jr., Eds., vol. I, American Institute of Aeronautics and Astronautics, 1996, Chapter 8, pp. 329\u2013406 (Dierendonck), incorporated herein in its entirety by reference. These include open-loop acquisition methods and closed-loop signal tracking methods such as a delay-locked loop to compute {circumflex over (\u03c4)}and {circumflex over (\u03c4)}and a phase-locked loop or a frequency-locked loop to compute {circumflex over (\u03c6)}and {circumflex over (\u03c9)}. The software receiver developed herein uses conventional techniques for forming these estimates.","Both prompt and early-minus-late correlations are needed to track the carrier frequency, carrier phase, and code phase in a GPS receiver. A typical receiver uses the PRN code and carrier replicas to compute the following in-phase and quadrature correlation accumulations: \n\n\nwhere iis the index of the first RF front-end sample time that obeys {circumflex over (\u03c4)}\u2266tand N+1 is the total number of samples that obey {circumflex over (\u03c4)}\u2266t<{circumflex over (\u03c4)}. The time offset \u0394 causes the replica PRN code to play back early if it is positive and late if \u0394 is negative. The prompt correlations are defined by equations (4) and (5) with \u0394=0. The early-minus-late correlations are I(\u0394\/2)\u2212I(\u2212\u0394\/2) and Q(\u0394\/2)\u2212Q(\u2212\u0394\/2), where \u0394is the spacing between the early and late PRN carrier replicas. The present invention described herein is an efficient technique for the receiver to accumulate Iand Qin software.\n","Referring now to , the operational platform of the software receiver  of the present invention includes an antenna , conventional RF front-end , a data acquisition (DAQ) system , a microprocessor , a software correlator , and application-specific code . Conventional RF front-end  interfaces with antenna  and with (DAQ) system . DAQ system  includes a system of shift registers and a data buffer. Microprocessor  executes software correlator , which includes a set of specially developed bit-wise parallel algorithms, and application-specific code , such as the GPS navigation and tracking functions. In the illustrative embodiment, conventional GPS software functions (signal tracking, data extraction, navigation solution, etc.) are provided by the MITEL\u00ae GPS Architect software ported to RTLINUX\u00ae (see , Ledvina et al., (2000) Nov. 27\u201328, 2000), but can be provided by any equivalent configuration.","Continuing to refer to , conventional RF front-end  can, for example, be a MITEL\u00ae GP2015 RF front-end, which down converts the nominal 1.57542 GHz GPS signal  to an intermediate frequency of (88.54\/63)\u00d710Hz\u22481.4053968254 MHz and then performs analog-to-digital conversion. The resultant, digitized signal data  has a pre-determined number of bits\/sample, such as two binary bits\/sample, a sign bit and a magnitude bit, or one bit\/sample. The shift registers in the DAQ system  parallelize the magnitude and sign data bit streams into separate words, which the DAQ system  reads into the memory of microprocessor  using DMA. To make the process of reading data into the microprocessor  more efficient and to prepare for efficient correlation calculations, DAQ system  can read a pre-specified number of bits of buffered samples, such as thirty-two bits, at a time. The exemplary thirty-two bits include sixteen sign bits and sixteen magnitude bits.","Referring now to , the shift registers in DAQ system  () buffer signal data  () and pack signal sign A () and signal magnitude B () into separate words, that represent the integer values \u00b11 and \u00b13 as is shown in Table 1. In the case of a 1-bit signal, the bit stream representing the samples is packed into successive words to prepare the signal for bit-wise parallel processing. DAQ system  also provides for accurate timing by, for example, synchronizing signal sign A and signal magnitude B to a (40\/7)\u00d710Hz\u22485.714 MHz clock signal, which can be, for example, a third output from conventional RF front-end  (). DAQ system  can convert the 5.71424 MHz clock signal down to 357.14 KHz by use of, for example, a divide-by-16 counter for a 16-bit word, which can provide a signal indicating when the buffer is full. DAQ system  can use any method for providing a buffer full indication.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"The sign and magnitude combinations of the sample RF output of the"},{"entry":"conventional RF front-end and their corresponding values."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Signal Sign 21A","Signal Magnitude 21B","RE Signal Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","0","\u22121"]},{"entry":["0","1","\u22123"]},{"entry":["1","0","+1"]},{"entry":["1","1","+3"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"With further reference to , in the illustrative embodiment, the DAQ system  can consist of an interface card and driver software that can be compatible with, for example, a 1.73 GHz AMD ATHLON processor running RTLINUX\u00ae, but could be compatible with any operating system and any processor that can accommodate real-time operations. The interface card can, for example, be a NATIONAL INSTRUMENTS\u00ae PCI-DIO-32HS digital I\/O card. Pertinent features of this card are the thirty-two digital input lines, DMA, and availability of a driver for RTLINUX\u00ae, perhaps gotten from the suite of open source drivers and application interface software for interface cards known as COMEDI (COntrol and MEasurement and Device Interface). Modifications to the conventional COMEDI driver for the PCI-DIO-32HS card include increasing the number of input bits from sixteen to thirty-two, enabling DMA, and modifying the driver to support continuous interrupt-driven acquisition.","With still further reference to , microprocessor  can be, for example, a 1.73 GHz AMD ATHLON\u2122 processor running the RTLINUX\u00ae operating system, but any operating system and processor that can accommodate real-time operations can be used. Low latency interrupt responsiveness, the ability to execute threads at regular intervals, with the kernel having a possibility of being the lowest priority thread, and reliable execution of time-critical code are among features of an operating system that could enhance the performance of the system of the present invention. The use of RTLINUX\u00ae is presented herein for illustrative purposes only.","Continuing to refer to , analogous to a hardware correlator that takes input directly from the RF front end in serial fashion, software correlator  reads from a shared memory buffer that both software correlator  and DAQ system  can access, the former to read data, and the latter to write data. The shared memory buffer can be implemented as a DMA memory space and a circular buffer. In the illustrative embodiment in which the system and method of the present invention are used in a GPS (or similar) environment, microprocessor  can store the most recent twenty-one milliseconds of signal data  () in the circular buffer, but could store more or less. The present invention does not fix the size of the circular buffer, nor the amount of RF data that can be stored there. The circular buffer allows the processing of code periods that start and stop at different times for different satellites during different iterations of a regularly scheduled program thread. DMA memory space can be written to directly by DAQ system  using a DAQ software driver, which fills the circular buffer. Communication between software correlator  and application-specific code  can be performed using operating system-provided shared memory capability. For example, the mbuff driver, included with RTLINUX\u00ae, can be used to create and manage this shared memory space. Any memory management system that accommodates real-time processing can be used. If the mbuff driver is used, kernel modules can share memory and the kernel can be restricted from swapping the shared memory space to long-term storage.","Continuing with the analogy to hardware correlation, and still referring primarily to , in hardware correlation, the correlator receives frequency and phase information from tracking and acquisition loops that are part of application code, and Numerically Controlled Oscillators (NCOs) generate signals that correspond to the written frequencies and phases. In contrast, software correlator  includes simulated carrier and code NCOs that receive their frequency commands from application-specific code . Software correlator  uses these frequency commands to reconstruct carrier replica signal  () and prompt PRN code  and early-minus-late PRN code  () which it mixes with the signal data  () resulting in fully mixed prompt integrand  and fully mixed early-minus-late integrand  ().","To further continue the analogy, a hardware correlator generates in real-time a particular C\/A code replica at the correct Doppler shifted frequency and phase. In contrast, software correlator  can generate C\/A codes off-line and store them in a memory table, the pre-computed over-sampled PRN code table  (). The pre-computed over-sampled PRN code table  is used to select PRN codes with the correct timing relationship to the sample times of signal data  (). The codes are then used to form correlations with baseband mixed signals  (), the result from which is summed to produce the standard in-phase and quadrature, summed prompt accumulation  () and summed early-minus-late accumulation  () that are equivalent to what would be produced by a continuously variable sine wave. These are provided to application-specific code , such as conventional GPS software that executes signal tracking and navigation functions. In a second approach, software correlator  can generate the PRN carrier replicas on-line at the code chipping rate and can use tabulated functions to re-sample the code at the sample rate of the RF front-end for purposes of calculating accumulations. Real-time over-sampled PRN code generator A () is used in place of pre-computed over-sampled PRN code table  () in this latter approach. This latter method can be used with longer PRN codes, such as the new civilian GPS L2 CL codes.","With still further reference to , since the received L1 raw signal  can have an uncertain carrier phase, software correlator  computes both in-phase (I) and quadrature (Q) accumulations, as defined in equations (4) and (5). Software correlator  begins the accumulation process by using carrier replica signal  (), which it gets from pre-stored carrier replica table  (). The carrier replicas in this table fall on a rough frequency grid, and they all start with a particular phase, for example a phase of zero. The baseband mixing process involves selecting a carrier replica signal  () from carrier replica table  () that is at the frequency that is as close to \u201cideal\u201d as possible. In the case of a 175 Hz grid spacing, the baseband mixing process selects a signal that is maximally within \u00b187.5 Hz of the ideal signal. The rough frequency grid can have a spacing of, for example, 175 Hz but could be larger or smaller depending on (a) the frequency range needed to cover, for example, \u00b110 Khz, (b) the amount of space available for storing pre-computed signals, and (c) other design decisions. The pre-computed signals in carrier replica table  () each may occupy 180 32-bit words in order to be guaranteed to cover the full 5,714 RF front-end samples that occur in one PRN code period for any possible code period start time within the thirty-two samples of the initial word. Thus, 180*4=720 bytes could be required for each bit of each pre-computed carrier replica signal  that is stored in the table. The sine and cosine waves of carrier replica signals  () each have 2-bit representations, which translates into a storage requirement of 2880 bytes for the carrier replica signals  at a given Doppler shift. There are 115 Doppler shifts that may be stored in order to cover the \u221210 KHz to +10 KHz range with a 175 Hz grid spacing. This translates into 323 Kbytes of storage for all of the carrier replica signals . This approach avoids the need to pre-compute sine waves with a prohibitively large number of possible frequencies and phase offsets and it avoids the need to compute sine waves in real-time. Instead, the errors created by using pre-defined sine wave replicas are compensated for by post-processing calculations, as described below.","In any case, and continuing to refer to , the resulting accumulations are \n\n\nwhere \u03c9is the grid frequency that is closest to the estimated frequency {circumflex over (\u03c9)}and where tis the time at which this carrier replica signal  () has zero carrier phase. Software correlator  rotates these accumulations in order to create accurate approximations of what would have been computed had the estimated carrier phase time history in equations (4) and (5) been used:\n\n(\u0394)=(\u0394)cos(\u0394\u03c6)+(\u0394)sin(\u0394\u03c6)\u2003\u2003(8)\n\n(\u0394)=\u2212(\u0394)sin(\u0394\u03c6)+(\u0394)cos(\u0394\u03c6)\u2003\u2003(9)\n\nwhere \u0394\u03c6is the average phase difference between the grid carrier phase and the estimated carrier phase averaged over the accumulation interval: \n\n\nNote that equations (8), (9), and (10) are an illustrative example of how software correlator () can rotate its I and Q accumulations in order to correct for phase and frequency errors in its table of pre-computed carrier replica signals. There exist other formulas that yield equivalent results, and this patent disclosure covers all such techniques.\n","The validity of equations (8) and (9) is dependent on the assumption that \n\n\nFor example, a 175 Hz grid spacing and a nominal C\/A PRN code period of 0.001 sec yields a value on the left-hand side of inequality (11) of 0.04, which respects the assumed limit.\n","Note that equations (8) and (9) can be derived from equations (4) and (5) as follows. First, the carrier phase of the grid signal in the arguments of the cosine and sine terms of equations (6) and (7) are added to and subtracted from the arguments of the cosine and sine terms in equations (4) and (5). Next, trigonometric identities are used to split the resulting cosine and sine terms into sums of products of cosine and sine functions. In each product, one of the terms involves an argument like the arguments in the trigonometric terms in equations (6) and (7). The other trigonometric terms are then approximated by either cos(\u0394\u03c6) or sin(\u0394\u03c6). These approximations are valid because of the inequality in equation (11) and because the average of sin {(\u03c9\u2212{circumflex over (\u03c9)})[t\u2212\u00bd({circumflex over (\u03c4)}+{circumflex over (\u03c4)})]} over the accumulation interval is zero.","A decrease in the carrier to noise ratio C\/N, which characterizes the receiver's sensitivity, is caused by the use of an inexact baseband mixing frequency. The worst-case decrease is expressed as a function of the frequency grid spacing \u0394f and is given by \n\n\nwhere \u0394f is in units of Hz, and T is the integration period. Thus, a \u0394f of 175 Hz causes a worst-case C\/Nloss of 0.11 dB for T=0.001 sec.\n","Referring now to , B, and A, PRN codes (composed of prompt PRN codes  () and early-minus-late PRN codes  ()) are either pre-computed or generated in real-time. Pre-computing involves, for each satellite, computing an entire PRN code, storing the PRN code appropriately for easy retrieval, and referencing the PRN code, possibly by means of indices that are computed based on, for example, the incoming RF signal data  (). Pre-computing can be most advantageously used when the PRN code is not very long. Generating PRN codes in real-time can be a more appropriate solution when the PRN codes are very long (and thus would require an unacceptable amount of storage), or perhaps when too many PRN codes are required for the amount of storage available, or for any other reason, but real-time PRN code generation can entail an additional computational cost. Both pre-computing and real-time determination of PRN codes are described herein with respect to a bit-wise parallel implementation.","Continuing to refer primarily to , B, and A, in order to perform bit-wise parallel operations, software correlator  () stores pre-computed carrier replica sign A () and carrier replica magnitude B () in data words. Simple representations of signal data  () and carrier replica signal  () in terms of one, two, or more bits are suitable for using bit-wise parallelism to perform the calculations described herein. Bit-wise parallel operations work with representations of the data that store successive samples in successive bits of a word. For example, thirty-two samples (bits) of the RF front-end output are stored in two N=32-bit words, signal sign A () and signal magnitude B (), or simply a single 32-bit word if signal data  consists of a single data bit. Carrier replica sign A () and carrier replica magnitude B () are stored, for example in tables, in separate words, with each 32-bit word storing thirty-two sign or magnitude bits that tabulate to thirty-two successive samples of the corresponding cosine or sine wave. Similarly, tables can store prompt PRN code  () and early-minus-late PRN code  (), which are composed of prompt PRN code sign A (), early-minus-late PRN code sign A (), and early-minus-late PRN code zero mask B (). The data words that comprise the bit-wise parallel representations of these three signal types, the original RF signal data  (), the carrier replica signal  ( and ), and the de-spreading prompt PRN code  () and early-minus-late PRN code  (), are the inputs to the calculations of software correlator  ().","Further continuing primarily to refer to , B, and A, many intermediate calculated quantities and at least three types of intermediate signals are also stored in bit-wise parallel format. First there are the in-phase and quadrature baseband mixed signals  (), whose 3-bit representations for the illustrative embodiment are stored as baseband mixed sign A (), baseband mixed high magnitude B (), and baseband mixed low magnitude C (). The second bit-wise parallel signal type is the fully mixed integrand, of which there are four signals: in-phase and quadrature fully mixed prompt integrand  () and in-phase and quadrature fully mixed early-minus-late integrand  (). The former are stored as 3-bit representations in the illustrative embodiment as fully mixed prompt integrand sign A (), fully mixed prompt integrand high magnitude B (), and fully mixed prompt integrand low magnitude C (). The latter are stored as 3.5-bit representations in the illustrative embodiment as fully mixed early-minus-late integrand sign A (), fully mixed early-minus-late integrand high magnitude B (), fully mixed early-minus-late integrand low magnitude C (), and fully mixed early-minus-late integrand zero mask D (). This representation is called a 3.5-bit representation because the sign, high-magnitude, and low-magnitude bits are ignored if the corresponding zero mask bit has the value zero. The third bit-wise parallel signal type is a value word, of which there are two types: prompt integrand value words  () and early-minus-late integrand value words  (). Each fully mixed integrand is used to construct value words, one word for each possible value that the integer integrand can take on. There are eight possible values for the integrands of the illustrative embodiment: \u22121, \u22122, \u22123, \u22126, 1, 2, 3, and 6 for the in-phase and quadrature fully mixed prompt integrands  () and \u22122, \u22124, \u22126, \u221212, 2, 4, 6, and 12 for the in-phase and quadrature fully mixed early-minus-late integrands  (). Each bit-wise parallel value word contains a one bit for each sample time when the integrand value equals the value of the value word, but it contains a zero bit for all other sample times. The storage of raw data and intermediate results in bit-wise parallel format allows the EXCLUSIVE OR operations that are involved in mixing to operate on thirty-two samples at a time if microprocessor  () has a bit-wise EXCLUSIVE OR command. Other bit-wise commands are used to perform additional software correlation operations in parallel on sets of two thirty-two samples.","At this point, the problem of over-sampling is introduced. Referring now to , the problem of over-sampling is illustrated with respect to bit-wise parallelism as follows. There is normally more than one RF data sample per PRN code chip. The three successive \u22121 values  () at sample times tto tall occur during the same PRN code chip as do the four successive +1 values  () at times tthrough t. The difference in the number of samples for the two code chips arises because the PRN code chip period is not an integer multiple of the sample period. Analogously, referring to , where sample interval \u0394t is less than actual PRN code chip length \u0394t, over-sampling is indicated because the RF sampling frequency f\u00d71\/\u0394tis greater than the PRN code chipping frequency f=1\/\u0394t. PRN codes for CDMA signaling are sequences of +1 and \u22121 values, the elements of which are chips. Over the time intervals of interest, a carrier replica progresses through its chips at a constant chipping rate of f=1\/\u0394tchips\/second. The time interval \u0394tis the actual PRN code chip length  (). Software correlator  () normally receives PRN code, and attempts to align it with the prompt replica version of the code, prompt PRN code  (). It makes use of the signal's correlation with prompt PRN code  () and with early-minus-late PRN code  () in order to determine a chipping rate fthat tends to align prompt PRN code  () as desired. Conventional methods for determining fare well-known in the art. Chips of early code B () start and stop 0.5\u0394tseconds before the corresponding chips of prompt PRN code  (), and the chips of late code C () start and stop 0.5\u0394tseconds after prompt PRN code  (). Early-minus-late PRN code  () is the difference between early code B () and late code C (). Example segments of these four types of replica codes are depicted in .","Referring to , A, C, and D software correlator  () receives, through conventional RF front end  and DAQ system , signal data  (), the raw data  () source of which is sampled at the rate f=1\/\u0394tHz. In order to process the resulting RF signal data , software correlator  () needs prompt PRN code  () and early-minus-late PRN code  () replicas sampled at the same times as raw signal  ().  depicts sixteen sample times as vertical dash-dotted lines. Referring to , prompt PRN code  () can be represented by its prompt PRN code sign A () at the sample times. The bit value one represents +1, and the bit value zero represents \u22121. Prompt PRN code sign A (), shown at the sixteen sample times\u2014starting with three 1s, continuing with ten 0s, and finishing with another three 1s\u2014is a 16-bit word stored as the integer 2+2+2+2+2+2=57351. Early-minus-late PRN code  () requires a 1.5-bit representation. A zero mask bit is set to zero if early-minus-late PRN code  takes on the value zero, and it is set to one if early-minus-late PRN code  equals +2 or \u22122. Early-minus-late PRN code zero mask B () at sixteen sample times shown in  is equivalent to 2+2+2=12292. A 2's sign bit is set to one if early-minus-late PRN code  () equals +2 at the sample time, and it is set to zero if the code equals \u22122. The 2's sign bit is irrelevant if the corresponding early-minus-late PRN code zero mask B () bit equals zero. Early-minus-late PRN code sign A () for sixteen sample times contains X values that indicate bits whose values are irrelevant because the corresponding early-minus-late PRN code zero mask B () bits are zero. In an illustrative embodiment, all the X values become zero, thus the equivalent integer for early-minus-late PRN code sign A () is 2=4.","Continuing to refer to , an alternative to taking the prompt PRN code  and early-minus-late PRN code  from pre-computed over-sampled PRN code table  is to generate prompt PRN code sign A, early-minus-late PRN code sign A, and early-minus-late PRN code zero mask B using real-time over-sampled PRN code generator A (). Shown in  are two circles and a loose arrow with a quarter circle pointer. These are the symbols for a switch and indicate the ability of the system to choose possible alternate sources of PRN code. Using the real-time over-sampled PRN code generator A includes a step of generating the PRN code chips in real-time by conventional means. For example, the GPS civilian L2 CL and CM codes are generated by a 27-bit feedback shift register (see 2 , R. D. Fontana et al., 2001, Sep. 11\u201314, 2001, Salt Lake City, Utah, pp. 617\u2013631). The method further includes the steps of choosing chip values from the PRN code, where the chip values correspond to a data interval that contains the samples of a data word and where the chips have a known timing relative to the data interval, transforming the relative timing into a time grid index, and translating the PRN code chip values and the time grid index for the data interval into the PRN code's over-sampled bit-wise parallel format. These latter steps can be carried out efficiently by using a table look up function. One table each for prompt PRN code sign A, early-minus-late PRN code sign A, and early-minus-late PRN code zero mask B can include integer values that constitute the bit-wise parallel representation of the PRN code for the sample times associated with the data word in question. Indices into each 1-dimensional table are functions of (a) the time offset between the first PRN code chip and the first sample time of the given data word, and (b) the bit pattern of the PRN code chips that span the sample times of the data word. The sizes of the tables are independent of the period of the PRN code that is being over-sampled. The tables can be re-used for multiple PRN codes in a multi-channel receiver. The computation and use of the tables are discussed in more detail later.","Continuing with the description of bit-wise parallelism with respect to the operations of software correlator  (), and continuing to refer to , the specially-developed algorithms described herein make use of bit-wise parallelism so that a single programming language statement, such as a C code command, can partially process up to thirty-two samples at a time. Previously referred-to carrier replica signal  in the form of cosine and sine signals are stored as binary carrier replica sign A and carrier replica magnitude B. The format of this representation is defined in Table 2 and illustrated in  which is a reconstructed carrier and carrier replica in the form of representative sine signal  () shown in optimal 2-bit representation  () that has the minimum square error. The format of Table 2 assumes that the cosine and sine signals have an amplitude of approximately 2.4. Note that other representations, beyond 2-bit representation, are possible. In general, more bits yield a better SNR, but can also require a larger number of computations for the correlation operations.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sign and magnitude combinations of the stored intermediate-"},{"entry":"frequency baseband mixing carrier sine wave replicas"},{"entry":"and the values that they represent"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Carrier Replica Sign","Carrier Replica",{}]},{"entry":["25A","Magnitude 25B","Carrier Replica Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["0","0","\u22121"]},{"entry":["0","1","\u22122"]},{"entry":["1","0","+1"]},{"entry":["1","1","+2"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Continuing to refer to , multiplication of the RF front-end output representation, the signal sign A and signal magnitude B, of Table 1 by the sine wave representation, carrier replica sign A and carrier replica magnitude B, of Table 2 yields baseband mixed signals , consisting of baseband mixed sign A, baseband mixed high magnitude B, and baseband mixed low magnitude C, that can take on the values \u22126, \u22123, \u22122, \u22121, +1, +2, +3, and +6, as shown in Table 3. Baseband mixed high magnitude B is simply signal magnitude B, and baseband mixed low magnitude C is carrier replica magnitude B. Thus, these two magnitude bits are available without the need for computation. Baseband mixed sign A is the result of an EXCLUSIVE OR operation between signal sign A and carrier replica sign A. Notice how the relationship of the sign bit value with the actual sign gets reversed from that of Tables 1 and 2.",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sign, high-magnitude, and low-magnitude combinations"},{"entry":"of the baseband-mixed signal and their"},{"entry":"corresponding signal values."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Baseband","Baseband Mixed","Baseband Mixed",{}]},{"entry":["Mixed Sign","High Magnitude","Low Magnitude","Baseband Mixed"]},{"entry":["23A","23B","23C","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","0","0","+1"]},{"entry":["0","0","1","+2"]},{"entry":["0","1","0","+3"]},{"entry":["0","1","1","+6"]},{"entry":["1","0","0","\u22121"]},{"entry":["1","0","1","\u22122"]},{"entry":["1","1","0","\u22123"]},{"entry":["1","1","1","\u22126"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Continuing to refer to , and continuing to describe the bit-wise parallel algorithms, the required amount of storage for tables of pre-computed prompt PRN code  and early-minus-late PRN code  can be greatly reduced by making two simplifications. First, the prompt PRN code  is stored as prompt PRN code sign A. This representation is shown in Table 4. The early-minus-late PRN code , on the other hand, is stored in a two-bit representation (actually a 1.5 bit representation): early-minus-late PRN code sign A and early-minus-late PRN code zero mask B, as denoted in Table 5. Note that the X in the first column of Table 5 indicates that zero or one can be placed in this location without affecting the corresponding code value. The X signifies a lack of effect of the sign bit on the code value when the zero mask bit equals zero. This is why the early-minus-late PRN code  representation is referred to as a 1.5-bit representation. This X value will affect the corresponding fully mixed early-minus-late integrand sign A, but it will not affect any of the early-minus-late value words because the zero value in the corresponding zero mask location will null out the corresponding bit of all early-minus-late value words.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sign bits of the prompt C\/A code and the corresponding"},{"entry":"prompt signal values."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Prompt PRN Code",{}]},{"entry":[{},"Sign 29A","Prompt Code Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"1","+1"]},{"entry":[{},"0","\u22121"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sign and zero mask bit combinations of the early-minus-late"},{"entry":"PRN code 35 and the corresponding signal values."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Early-minus-late PRN","Early-minus-late PRN","Early-Minus-Late Code"]},{"entry":["Code Sign 35A","Code Zero Mask 35B","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["X","0","0"]},{"entry":["0","1","\u22122"]},{"entry":["1","1","+2"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Another simplification in the pre-computed over-sampled PRN code table , and continuing to refer to , can be to ignore code Doppler shift variations. All signals in the table are assumed to have zero Doppler shift; i.e., all C\/A codes in the table assume that {circumflex over (\u03c4)}\u2212{circumflex over (\u03c4)}=0.001 sec. Note that the period of 0.001 is applicable for accumulations that use the full 1023 chips of the C\/A code only. Any other type of code or accumulation interval may have a different period. The code phase errors due to this assumption can be eliminated by choosing a replica code from the pre-computed over-sampled PRN code table  whose midpoint occurs at the desired midpoint time ({circumflex over (\u03c4)}+{circumflex over (\u03c4)})\/2. The only other effect of this assumption can be a small correlation power loss, which is no more than 0.014 dB if the magnitude of the Doppler shift is less than 10 KHz. The pre-computed over-sampled PRN code table  should include a selection of different phases, for example fourteen, as measured relative to a signal sample spacing of, for example, 175 nsec. This translates into a code phase spacing of, for example, 12.5 nsec, which equals a pseudo range measurement digitization level of 3.8 m, or a maximum measurement error of 1.9 m. The number of phases in the pre-computed over-sampled PRN code table  is dependent upon the design of the system and no set number of phases is required by the present invention. Referring to , suppose that pre-computed over-sampled PRN code table  stores over-sampled bit-wise parallel representations of chips C() through C(M). The table must allow for the retrieval of over-sampled bit-wise parallel code replicas for a range of start times of code chip C() that span the entire first data sample word in the accumulation interval W (). The table may contain code replicas whose different phases yield start times that span only a single sample interval of data word W (), which is only 1\/nof the required number of start times. In this case the software correlator may apply bit shift operations to a tabulated PRN code replica from that sample interval in order to generate the over-sampled bit-wise parallel PRN code replica that applies when chip C() starts in a different sample interval of data word W ().","Continuing to refer to , and further continuing to describe the bit-wise parallel algorithms, prompt PRN code  and early-minus-late PRN code  replicas can be mixed with the baseband mixed signals  to form fully mixed prompt integrand  by an EXCLUSIVE OR operation and bit re-definitions. An EXCLUSIVE OR between prompt PRN code sign A and baseband mixed sign A produces fully mixed prompt integrand sign A given in Table 6. The fully mixed prompt integrand high magnitude B and fully mixed prompt integrand low magnitude C are baseband mixed high magnitude B and baseband mixed low magnitude C, also given in Table 6. Note that the Table 6 representation is identical to that of Table 3 except for the inversion in the meaning of the sign bits. The number of magnitude bits is dependent upon the design of the system and no set number of magnitude bits is required by the present invention. A change in the number of magnitude bits will cause a change in the number of entries of the equivalent of Table 6 and it will affect the possible values of the integrand.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sign, high-magnitude, and low-magnitude bit combinations of the fully"},{"entry":"mixed prompt integrand 31 and its corresponding values."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Fully Mixed",{},"Fully Mixed","Fully Mixed"]},{"entry":["Prompt","Fully Mixed Prompt","Prompt","Prompt"]},{"entry":["Integrand Sign","Integrand High","Integrand L w","Integrand"]},{"entry":["31A","Magnitude 31B","Magnitude 31C","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0","0","0","\u22121"]},{"entry":["0","0","1","\u22122"]},{"entry":["0","1","0","\u22123"]},{"entry":["0","1","1","\u22126"]},{"entry":["1","0","0","+1"]},{"entry":["1","0","1","+2"]},{"entry":["1","1","0","+3"]},{"entry":["1","1","1","+6"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Still continuing to refer to , the mixing of the early-minus-late PRN code  with the baseband mixed signals  forms fully mixed early-minus-late integrands . Fully mixed early-minus-late integrand sign A is an EXCLUSIVE OR between early-minus-late PRN code sign A and baseband mixed sign A. Fully mixed early-minus-late integrand high magnitude B and fully mixed early-minus-late integrand low magnitude C are, as above, baseband mixed high magnitude B and baseband mixed low magnitude C. Fully mixed early-minus-late integrand zero mask D is early-minus-late PRN code zero mask B. The resulting representation is given in Table 7. As in Table 5, each X entry in the table indicates that the corresponding bit can be either zero or one without affecting the corresponding integrand value.",{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sign, high-magnitude, low-magnitude, and zero mask bit combinations"},{"entry":"of the fully mixed early-minus-late integrands 33"},{"entry":"and their corresponding values."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EML","EML",{},{}]},{"entry":["Early-Minus-","Integrand","Integrand","EML","Early-"]},{"entry":["Late (EML)","High","Low","Integrand","Minus-Late"]},{"entry":["Integrand","Magnitude","Magnitude","Zero Mask","Integrand"]},{"entry":["Sign 33A","33B","33C","33D","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["X","X","X","0","0"]},{"entry":["0","0","0","1","\u22122"]},{"entry":["0","0","1","1","\u22124"]},{"entry":["0","1","0","1","\u22126"]},{"entry":["0","1","1","1","\u221212"]},{"entry":["1","0","0","1","+2"]},{"entry":["1","0","1","1","+4"]},{"entry":["1","1","0","1","+6"]},{"entry":["1","1","1","1","+12"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Referring now to , B, A, and B, the method for computing in-phase and quadrature accumulations for every accumulation period, for example every millisecond for GPS C\/A code, by use of bit-wise parallelism includes the steps of selecting carrier replica signal  () according to the proximity of its frequency to the desired frequency, and representing sample signal data  () and carrier replica signal  () from at least one channel as bits in signal sign A () and, if present, signal magnitude B () and carrier replica sign A () and carrier replica magnitude B () (method step , ). Note that carrier replica signal  () is chosen so that its frequency is close to the correct signal frequency. The method also includes the step of mixing signal data  () to baseband by computing in-phase and quadrature baseband mixed sign A () and in-phase and quadrature baseband mixed high and low magnitude B\/C () (method step , ). The method further includes the steps of selecting PRN code from pre-computed over-sampled PRN code table  () or of computing it using real-time over-sampled PRN code generator A (), representing prompt PRN code  () as prompt PRN code sign A (), and representing early-minus-late PRN code  () from as early-minus-late PRN code sign A () and early-minus-late PRN code zero mask B () (method step , ). The method further includes the step of de-spreading in-phase and quadrature baseband mixed signal  () by mixing it with prompt PRN code  () and early-minus-late PRN code  (), resulting in in-phase and quadrature fully mixed prompt integrands  (), and fully mixed early-minus-late integrands  () (method step , ). The method further includes the step of using prompt value word logic A () to compute prompt integrand value words  () from the in-phase and quadrature fully mixed prompt integrands  (). The method further includes the step of using early-minus-late value word logic A () to compute early-minus-late integrand value words  () from the fully mixed early-minus-late integrands  () (method step , ). The method further includes the steps of summing over each prompt integrand value word  and early-minus-late integrand value word  () the number of one bits (or zero bits) using one bits summation table  () or using a processor command if available (method step , ), and summing, over the accumulation interval, the number of one bits (or zero bits) in each prompt integrand value word  and early-minus-late integrand value word  to produce prompt accumulations  () and early-minus-late accumulations  () (method step , ). The method further includes the step of multiplying prompt accumulations  () and early-minus-late accumulations  () by corresponding values  A and summing the results over the value words of each signal for an entire accumulation interval to yield in-phase and quadrature summed prompt accumulations  () and summed early-minus-late accumulations  () (method step , ) that are stored for use by acquisition techniques or tracking loops. The method further includes the step of rotating the in-phase and quadrature summed prompt accumulations  () and summed early-minus-late accumulations  () (method step , ) to simulate a condition in which baseband mixing had been performed using cosine and sine signal replicas with the correct frequency and phase. If there are more channels to process (decision step , ), the method includes the step of repeating the previous steps beginning at method step , . If there are no more channels to process (decision step , ), the method includes the step of setting parameters for the next accumulation period, including storing current C\/A code phases, epoch counters, carrier phases, and carrier Doppler shifts (method step , ). If the time period to wait until the next accumulations need to be calculated has not expired (decision step , ), the method includes the step of sleeping until the expiration of the time period (method step , ). If the time period has expired (decision step , ), the method includes the step of repeating the previous steps beginning at method step , . The length of the time period depends on the nominal accumulation period. It is set to be less than this period, normally between 50% to 90% of this period, to reduce the possibility that accumulations are missed for any channels.","Referring again to , method step  () calls for computing value words. This computation starts by performing bit-wise parallel Boolean logic for each of the possible values in the right-hand column of the prompt integrand representation in Table 6. A 32-bit prompt integrand value word  () is computed for each thirty-two samples and each row of Table 6. The prompt integrand value word  () contains ones for the sample times when the actual integrand equals the corresponding value in the right-hand column of Table 6, and zeros for the remaining times when the actual integrand does not equal this value. The prompt integrand value words  () corresponding to the possible Table 6 values are formed by method step  () as follows:\n\nMINUSONE=NOT(SIGN) AND [NOT(HIGHMAG) AND NOT(LOWMAG)]\u2003\u2003(13)\n\nMINUSTWO=NOT(SIGN) AND [NOT(HIGHMAG) AND LOWMAG]\u2003\u2003(14)\n\nMINUSTHREE=NOT(SIGN) AND [HIGHMAG AND NOT(LOWMAG)]\u2003\u2003(15)\n\nMINUSSIX=NOT(SIGN) AND [HIGHMAG AND LOWMAG]\u2003\u2003(16)\n\nPLUSONE=SIGN AND [NOT(HIGHMAG) AND NOT(LOWMAG)]\u2003\u2003(17)\n\nPLUSTWO=SIGN AND [NOT(HIGHMAG) AND LOWMAG]\u2003\u2003(18)\n\nPLUSTHREE=SIGN AND [HIGHMAG AND NOT(LOWMAG)]\u2003\u2003(19)\n\nPLUSSIX=SIGN AND [HIGHMAG AND LOWMAG]\u2003\u2003(20)\n","Continuing to refer to , B, A, and B, method steps  (),  (), and  () call for operations for the fully mixed early-minus-late integrands  () that are similar to those for the fully mixed prompt integrands  (). Early-minus-late integrand value words  () correspond to values that are double those of the prompt integrand value words  (), i.e., the MINUSSIX word becomes the MINUSTWELVE word. Also, an additional AND operation must be performed with the zero mask bits of Table 7 in order to mask out sample times when the early and late PRN codes cancel each other. Possible formulas for the method step  () computation of these early-minus-late integrand value words  () are as follows:\n\nMINUSTWO=[ZEROMASK AND NOT(SIGN)] AND [NOT(HIGHMAG) AND NOT(LOWMAG)]\u2003\u2003(21)\n\nMINUSFOUR=[ZEROMASK AND NOT(SIGN)] AND [NOT(HIGHMAG) AND LOWMAG]\u2003\u2003(22)\n\nMINUSSIX=[ZEROMASK AND NOT(SIGN)] AND [HIGHMAG AND NOT(LOWMAG)]\u2003\u2003(23)\n\nMINUSTWELVE=[ZEROMASK AND NOT(SIGN)] AND [HIGHMAG AND LOWMAG]\u2003\u2003(24)\n\nPLUSTWO=[ZEROMASK AND SIGN] AND [NOT(HIGHMAG) AND NOT(LOWMAG)]\u2003\u2003(25)\n\nPLUSFOUR=[ZEROMASK AND SIGN] AND [NOT(HIGHMAG) AND LOWMAG]\u2003\u2003(26)\n\nPLUSSIX=[ZEROMASK AND SIGN] AND [HIGHMAG AND NOT(LOWMAG)]\u2003\u2003(27)\n\nPLUSTWELVE=[ZEROMASK AND SIGN] AND [HIGHMAG AND LOWMAG]\u2003\u2003(28)\n\nAdditional zero masking can occur in the first and last words of an accumulation interval. This is true because the start and stop times of an accumulation interval do not normally fall at the boundaries of data words. Therefore, the bits in the first word that precede the accumulation interval may need to get zero masked as might the bits in the last word that come after the end of the accumulation interval.\n","Referring primarily to , the one bits counting operations of method step  () form the count of the number of one bits in each of the eight value words. If there are no such counting operations in the instruction set of microprocessor  (), the counting can be accomplished using a table look-up. In the case of a table look-up, prompt integrand value words  and early-minus-late integrand value words  () can be used as addresses in one bits summation table  (), and one bits summation table  () can output the number of one values (or zeros) in the address. For example, if the table look-up operation is called BITSUM, the following computations can be performed to compute one-bits counts:\n\nONESCOUNT=BITSUM(VALUEWORD)\u2003\u2003(29)\n\nwhere the output of the table ONESCOUNT is the number of one bits in the word VALUEWORD. This operation is repeated for each of the prompt integrand value words  () and early-minus-late integrand value words  () in order to accomplish method step  (). Selection of table width, for example 16-bit or 32-bit, depends on the amount of memory available and other design decisions. If the table width is smaller than the number of bits in a value word, then multiple calls of the table are used in order to sum up the total number of one values in a given value word. Each call takes as input only a portion of the bits in the value word.\n","Continuing to refer primarily to , the accumulation operations of method steps  ( () sum the one bit counts for each prompt integrand value word  () and for each early-minus-late integrand value word  () over the entire accumulation interval, multiply each result by the value A () that is associated with the value word, and sum all of these scaled value accumulations to form the accumulations of equations (6) and (7), summed prompt accumulation  () and summed early-minus-late accumulation  (). For example, the following computations can be performed to compute the in-phase summed prompt accumulation  in equation (6) as follows: \n\n\nwhere l is the index of successive bit-wise parallel data words in the accumulation interval, Nis the total number of data words in the interval, and ONESCOUNT(k)is the ones count for the corresponding value word  () associated with value k A () for the lth data word interval and the in-phase summed prompt accumulation  (). The quadrature summed prompt accumulations  () and the in-phase and quadrature summed early-minus-late accumulations  () are calculated in a similar manner. The only difference is in the actual ONESCOUNT values used and, for the case of early-minus-late signals, the set of k values A ().\n","Continuing to refer primarily to , the method of the present invention can be adapted to work with a different number of bits in the representation of the RF front-end output and of the baseband mixed signals. An increase above two bits can make the logic more complex and may decrease the time savings over straight integer arithmetic. A decrease to a 1-bit representation can have the opposite effect. For example, if the RF front-end uses 1-bit digitization rather than 2-bit digitization while carrier replica signal  () retains its 2-bit digitization, then the operation count can decrease by a factor of almost two for the 1-bit method, which can make the logic execute about 4.2 times faster than straight integer arithmetic.","Returning to the discussion of determining PRN code, and now referring again , D, and A, the real-time generation of bit-wise parallel over-sampled prompt PRN code sign A (), early-minus-late PRN code sign A (), and early-minus-late PRN code zero mask B () can be carried out by real-time over-sampled PRN code generator A (). The inputs to this calculation are the actual PRN code chip length  (), \u0394t, the sample interval  (), \u0394t, the nominal early-to-late code delay  (), \u0394t, the end time of the first code chip relative to the first sample time, or put another way, the time lag \u0394t,  () from the first RF sample time to the end time of the first prompt PRN code chip, and prompt code chips  (). The outputs are the three integers that store the prompt PRN code sign A (), early-minus-late PRN code zero mask B (), and early-minus-late PRN code sign A (), which are all in bit-wise parallel format.","Referring again to , table look-ups can be used to translate a PRN code and its timing information to bit-wise parallel representations of its over-sampled prompt and early-minus-late versions. The required table look-ups can be simplified by recognizing that the following parameters are substantially constant, for the purposes of this calculation: sampling interval  (), \u0394t, the nominal chip length, \u0394t, the early-minus-late code delay  (), \u0394t, used by software correlator  (), and the maximum number of chips that span a data word of microprocessor  (). The difference between the actual chipping rate \u0394f(reciprocal of \u0394t) and the nominal chipping rate \u0394f(reciprocal of \u0394t) that is used for the above simplification can be accommodated by correcting time lag  (), \u0394t, for the average effects of Doppler shift, a procedure discussed later. Using the simplification, each look-up table has two variable inputs: the actual set of prompt code chips  () and time lag  (), \u0394t. A table look-up procedure for each signal component yields a single integer result for prompt PRN code sign A (), another single integer result for early-minus-late PRN code zero mask B (), and yet another single integer result for early-minus-late PRN code sign A ().","Time lag  (), \u0394t, can take on an infinite number of values in the continuous range: \n\n\nThis range's lower limit guarantees that the end time of the first late chip occurs no earlier than the first sample time. A lower time lag  () \u0394tvalue would make the first chip irrelevant to the prompt PRN code  (), early code B (), and late code C () at all of the sample times. The upper limit in equation (31) guarantees that the start time of the first late chip occurs no later than the first sample. A larger value of \u0394twould leave the late code C () at the first sample time undefined based on the available code chips.\n","Referring now to , to create an electronically processable table, the continuous range of \u0394tvalues can be replaced with a discrete grid having m equally spaced points per sample interval  (), \u0394t. The integer m is chosen to be large enough so that the granularity \u0394t\/m gives sufficient PRN code timing resolution. In GPS applications m is usually chosen to be large enough so that (c\u0394t\/m) is on the order of several meters or less, where c is the speed of light, but reasonably sized because the table sizes are usually proportional to m. Given a choice of m, the grid of relative end times of the first prompt code period is: \n\n\nwhere the limits \n\n\nprovide full coverage of the interval defined in equation (31). The floor( ) function rounds to the nearest integer in the direction of \u2212\u221e. This kvalue can cause the minimum \u0394tto fall slightly below the lower limit in equation (31), which can cause memory inefficiency, but this value is advantageous because it may simplify some further computations.\n","The size for each table can be a function of the maximum number of code chips that may fall within a data word's sample range. Given \u0394t, bit information for the following number of code chips is required in order for the prompt PRN code  (), early code B (), and late code C () to be fully specified at all of the data word's sample times: \n\n\nwhere nis the number of data samples that can be stored in bit-wise parallel format in each word. It is clear from equation (34) that l(\u0394t) is a non-increasing function of \u0394t. Therefore, the maximum number of required chips occurs at the minimum value of \u0394t:\n\n(\u0394t)\u2003\u2003(35)\n\nThe size of each table can be determined from the parameters k, k, and L. The grid contains k=(k\u2212k+1) different time offsets of the first code chip. At each of these grid points there are 2possible combinations of the code chips. Thus, each table optimally contains k\u00d72entries, and each entry is optimally an unsigned integer in the range from 0 to 2\u22121.\n","Continuing to refer to , each table can be stored as an array with a single index. The first 2entries correspond to the 2different possible chip sequences that can occur at \u0394t=\u0394t, the next 2entries correspond to \u0394t=\u0394t, and so forth. The tabulated bit sequences for a fixed \u0394tare ordered by interpreting the sequence as a binary index counter with the first chip being the most significant counter bit and the Lchip being the least significant bit. The integer elements of the table can be the x(i) table elements  with corresponding code time offset  \u0394t, and corresponding bit sequence  of the chips. The array index of a given x(i) table element  can be computed based on its code time offset  \u0394tgrid index k and its corresponding bit sequence . The corresponding bit sequence  associated with the array index consists of the chip values C(), C(), C(), . . . C(L). The C(j) chip values are either zero or one, with zero representing a \u22121 PRN code value and one representing a +1 PRN code value, and they are listed in order of increasing time. The corresponding array index of the x(i) table element  is: \n\n\nThis equation can be inverted to give the code time offset  grid index k and the corresponding bit sequence  as functions of the x(i) table element  index i:\n\n()=+floor[(\u22121)\/2]\u2003\u2003(37a)\n\n\n\nwhere mod(y,z)=y\u2212z\u00d7floor(y\/z) is the usual remainder function.\n","Continuing to refer to , the following computations generate the x(i) table elements  entries of the three tables. Given i, the corresponding code time offset  grid index k(i) is computed from equation (37a) and is used to generate three sequences of chip indices: \n\n\nwhere n is the index of the sample time within the over-sampled data word. The integer j(n,i) is the index of the PRN code chip that applies at sample n for the prompt PRN code  (). The integers j(n,i) and j(n,i) are defined similarly for the early code B () and late code C (), respectively. The formulas in equations (38a)\u2013(38c) amount to time measurements of each sample given in units of chip lengths past the first chip. These indices, in turn, can be used to determine the chip values that apply at the sample times:\n\n()=();] for 1, 2, 3\u2003\u2003(39a)\n\n()=();] for 1, 2, 3\u2003\u2003(39b)\n\n()=();] for 1, 2, 3\u2003\u2003(39c)\n\nwhere C(n,i) is the over-sampled prompt PRN code  (), and C(n,i) and C(n,i) are, respectively, the early code B () and late code C (). Each of these code bit values is either zero or one, as dictated by the outer mod(,2) operation in equation (37b). These over-sampled chip values can, in turn, be used to formulate tabulated functions x(i), x(i), and x(i) that generate the unsigned integers that constitute the bit-wise parallel code representations of the three tables: \n\n\nwhere x(i) is the entry of the prompt sign table, x(i) is the entry of the early-minus-late zero mask table, and x(i) is the entry of the early-minus-late 2's sign table. Note that the formula used in equation (40c) is only an example illustrative embodiment of the early-minus-late 2's sign table calculation. It places zeros in all of the X entries of early-minus-late PRN code sign A (). There exist alternate formulas that are equally correct but that do not place zeros in the X entries.\n","The table layout in  is only an illustrative embodiment of how one can construct a table that can be used to translate PRN code chip values and timing information into data words that store the bit-wise parallel representations of the over-sampled prompt PRN code sign A (), early-minus-late PRN code zero mask B (), and early-minus-late PRN code sign A (). Other table layouts are also possible. Possible illustrative index calculations are described below for indexing into the tables for PRN code retrieval during accumulation calculations If another table layout is used, then different indexing calculations might be needed. Furthermore, different indexing calculations can be used even for the illustrative table layout shown in .","Referring now primarily to , accumulation calculations, as have been previously outlined herein and elsewhere, work with a fixed sequence of code chips. The prompt version of this sequence has a specified timing relationship to the incoming RF signal data  (). This relationship can be pre-determined by a code search algorithm if software receiver  () is in acquisition mode or by its delay-locked loop if it is in tracking mode. Software correlator  () can calculate an accumulation using prompt code chips  () C() through C(M). The timing of the prompt replicas of prompt code chips  () can define the accumulation interval. The chip sequence starts at start lag  () \u0394tseconds past the first sample of data word W (), it chips at the constant chipping rate f=1\/\u0394t, and it ends at end time  (), which occurs \u0394t+M\u0394tseconds after the first sample of data word W (). The end of the Mprompt code chip can occur during data word W (), which implies that \n\n\nwhere the ceil( ) function rounds to the nearest integer towards +\u221e. Some of the initial bits of data word W () and some of the final bits of data word W () may not be included in the accumulation. Let nbe the number of initial bits of data word W () that are excluded, and let nbe the number of final bits of data word W () that are excluded. The timing relationship in  implies that these numbers are: \n\n","These sample counts can be used to develop additional zero mask words that software correlator  () uses to properly process the first and last data words during its bit-wise parallel accumulation calculations, as defined in 12--1 , B. M. Ledvina et al., , Jan. 22\u201324, 2003, Anaheim, Calif. and -, B. M. Ledvina et al., to appear in the , 2003, both incorporated herein in their entirety by reference. Note that equations (41)\u2013(42b) and all related timing considerations herein use the following code chip start\/stop convention: a sample is correlated with a particular code chip if the start time of the code chip coincides exactly with the sample time, but it will not get correlated with that chip if its sample time coincides exactly with the end time of the code chip.","Continuing to refer to , efficiently determining the correct x(i), x(i), and x(i) bit-wise parallel code representations for the N data words W () through data word W () involves making an efficient determination of the correct table index i that corresponds to data word W for \u03bd=1, . . . , N, where the table index i is a function of start lag \u0394t (), actual PRN code chip length \u0394t (), \u03bd, and prompt code chips C(), C(), C(), . . . , C(M+1)  (). The chip value C()  () is needed in order to specify the late code C () at the initial few samples of the accumulation, and the chip value C(M+1)  () is needed to specify the early code B () at the final few samples. Additional constants that can be used in order to determine the i indices are \u0394t, n, m, L, k, k, and nominal chip length \u0394t, which has been used to generate the three x(i) tables.","The first step of the index calculation procedure pre-computes and stores a table of candidate integers for the final summation term that appears on the right-hand side of equation (36). This table takes the form: \n\n\nThis computation requires the undefined chip values C(\u2212L+1), C(\u2212L+2), C(\u2212L+3), . . . , C(\u22121), and C(M+2), C(M+3), C(M+4), . . . , C(M+L). The value zero can be used for each of these undefined chips because they can affect the over-sampled codes only for the first nsamples of data word W () or for the last nsamples of data word W (), none of which are part of the accumulation. The table of equation (43) can be constructed by using the following iterative procedure:\n\n\u0394(1)=()\u2003\u2003(44a)\n\n\u0394(\u03bc)=mod[2\u0394(\u03bc\u22121),2(\u03bc\u22121) for \u03bc=2, 3, 4, . . . , (2)\u2003\u2003(44b)\n\n\u0394(\u03bc)=mod[2\u0394(\u03bc\u22121),2] for \u03bc=(3), (4), . . . , (1)\u2003\u2003(44c)\n\nNote that the mod(2\u00d7,2) operation in the latter two equations can be replaced by a single truncated leftward bit shift.\n","In many cases prompt code chips  () C(), C(), C(), . . . can be generated as the output of a feedback shift register or a system of such registers. For example, the new GPS civilian L2 signals can be generated this way. In this case, each iteration of equation (44b) can be interleaved with an iteration of the shift register calculations. Shift-register generation of PRN codes is well-known in the art.","An alternative to building up the previously-described table is to calculate the index component only for one data word at a time. Suppose that \u0394i is the correct index component for data word W, and that \u03bc is the auxiliary index that would have been used to determine \u0394i from the \u0394i(\u03bc) table had the table existed. In order to calculate \u0394ifor data word W, \u03bcis computed (procedure defined herein), feedback shift register calculations that generate C(\u03bc), C(\u03bc+1), C(\u03bc+2), . . . , C(\u03bc\u22121) are iterated, and the resulting chip values are used to perform (\u03bc\u2212\u03bc) iterations of equations (44b) or (44c).","Determination of the correct index into the x(i), x(i), and x(i) tables for data word W can be reduced to the determination of two quantities. One is the time offset index k that causes \u0394tfrom equation (32) to match the true time offset for data word W as closely as possible. The other quantity is the auxiliary table index \u03bc. It constitutes an index for the sequence of actual code chips that are associated with data word W. Given these two quantities, the correct index for the three x(i) tables is\n\n=1+()\u00d72(\u03bc) for \u03bd=1, 2, 3 \u2003\u2003(45)\n","The auxiliary index \u03bc is determined by the position of the W data word relative to the PRN code chip sequence. Once that position has been ascertained, the index k can be calculated from the position relative to the W samples of the L code chips that are associated with the index \u03bc.","A time integer can keep track of the number of fine-scale time units in a given interval. The fine-scale time unit is a small fraction of the sample interval  (), \u0394t: \n\n\nwhere mis the integer number of fine-scale time intervals per sample interval  (), \u0394t. This number is chosen large enough, for example m>2mN, to preclude any significant build-up of timing errors during an accumulation interval due to the finite time resolution \u0394t. N is the number of data words in the accumulation interval. The calculation of the k values over one accumulation interval involves approximately N iterative time increments, each of which has a resolution of \u0394t. If mobeys the inequality given above, then the cumulative timing errors due to the finite precision \u0394twill be less than the timing error caused by the finite timing precision of the x(i) tables. Normally it is possible to make mmuch larger than 2mN and still keep all of the relevant calculations within the size limits of a 32-bit signed integer. If mis a power of two, a rightward bit shift operation can be used to implement integer division by m. Time unit \u0394tcan be used to define an integer that approximately keeps track of the code\/sample time offset \u0394t for data word W: \n\n\nwhere the round( ) function rounds up or down to the nearest integer. The time lag  (), \u0394t, is the amount by which the end time of PRN code chip C(\u03bc\u2212L) lags the first sample time of data word W. The algorithm that iteratively determines k tries to keep the relationship in equation (47) exact, but using only integer operations can allow small errors to build up. Note that k\/m\u2245k\/m, as implied by a comparison of equations (32) and (47). This relationship can be used to determine k from an iteratively determined k. Several constants are required by the iterative procedure that determines k, k, and \u03bc. The first five constants are used to account for the difference between the nominal chip length \u0394t, used to generate the x(i) tables, and the actual chip length  (), \u0394tused in the accumulation:\n",{"@attributes":{"id":"p-0099","num":"0098"},"br":[{},{}],"in-line-formulae":[{},{}],"i":["k","n","m","a","b"],"sub":["fmid","s","f","fix","fix","fmid ","f ","fix","fix ","f\u03bd"],"maths":[{"@attributes":{"id":"MATH-US-00022","num":"00022"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":"\u03bb","mo":"=","mfrac":{"mrow":[{"mrow":[{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["t","c"]}},{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["t","cnom"]}}],"mo":"-"},{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["t","c"]}}]}}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"48","mo":"\u2062","mi":"b"}}}]},{"mtd":[{"mrow":{"msub":{"mi":["a","fix0"]},"mo":"=","mrow":{"mrow":[{"mi":"ceil","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["k","fmid"]},"mo":"-","mfrac":{"mrow":{"msub":[{"mi":["m","f"]},{"mi":["k","min"]}],"mo":"\u2062"},"mi":"m"}}},"mo":"\u2062","msup":{"mi":"\u03bb","mn":"2"}}}},{"mi":"sign","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03bb"}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"48","mo":"\u2062","mi":"c"}}}]},{"mtd":[{"mrow":{"msub":{"mi":["b","fix"]},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"1"},{"mrow":{"mrow":[{"mi":["if","\u0394"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["t","c"]}},{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["t","cnom"]}}],"mo":"="}}]},{"mtd":[{"msup":{"mn":"2","mrow":{"mi":"ceil","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":[{"mi":"log","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["a","fix0"]},"mo":"\/","mi":"\u03bb"}}},{"mi":"log","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"2"}}],"mo":"\/"}}}}},{"mrow":{"mrow":[{"mi":["if","\u0394"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["t","c"]}},{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["t","cnom"]}}],"mo":"\u2260"}}]}]}}}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"48","mo":"\u2062","mi":"d"}}}]}]}}},{"@attributes":{"id":"MATH-US-00023","num":"00023"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["k","fvfix"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["k","fv"]}}},{"msub":{"mi":["k","fv"]},"mo":"+","mrow":{"mi":"round","mo":["\u2062","[","]"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["k","fmid"]},{"mi":["k","fv"]}],"mo":"-"}},"mo":"\u2062","mfrac":{"msub":[{"mi":["a","fix"]},{"mi":["b","fix"]}]}}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"49"}}]}}}}],"b":"48"},"Equation (48d) picks bto equal a power of two so that the integer division by bin equation (49) can be accomplished using a rightward bit shift operation. The round( ) operation in equation (49) can be accomplished as part of the division if one first adds sign(a)\u00d7b\/2 to the quantity (k\u2212k)\u00d7abefore performing the rightward bit shift that constitutes division by b. This approach can give the correct kbecause the signs of (k\u2212k) and bare both positive and because the rightward bit shift has the effect of rounding the signed division result towards zero. An alternate implementation of the round function could be used for applications that do not guarantee k>k. Such applications are normally associated with L\u22662 PRN code chips per data word.","Five additional constants can be used to define the k and \u03bc iterations: \n\n\nThe constant Lis the typical number of code chips per data word. It is the nominal increment to \u03bc per data word. The constant \u0394kequals the number of fine-scale time intervals per PRN code chip. The constant \u0394kis used to adjust k up or down if k falls outside of the limits: k\u2266k\u2266k. The constant \u0394kis the nominal increment to k per data word. The limits kand kare approximately the limits kand kfrom equations (33a) and (33b) re-scaled to the new fine time scale and adjusted for the difference between the nominal code chipping rate of the x(i) tables and the actual chipping rate of the accumulation. The extra \u22122 term on the right-hand side of equation (33a) is compensated for by the increment to kon the right-hand side of equation (50d) and the decrement to kon the right-hand side of equation (50e). The original \u22122 term and the increment and decrement have been included because they ensure that kvalues which respect the limits in equation (50d) and (50e) are transformed into k values that respect the limits in equations (33a) and (33b).\n","The iteration begins by initializing kand \u03bcfor the first data word. The nominal initial values are: \n\n\nIt is possible that kfrom equation (51a) can violate its upper limit k. Therefore, the following conditional adjustment can be implemented in order to finish the initialization. \n\n\nGiven this initialization, the calculation of (k,\u03bc), (k,\u03bc), (k,\u03bc), . . . , (k,\u03bc) proceeds according to the following iteration:\n\nfor \u03bd=2, 3, 4\u2003\u2003(53a)\n",{"@attributes":{"id":"p-0103","num":"0102"},"br":[{},{}],"in-line-formulae":[{},{}],"sub":["\u03bdnom","typ ","\u03bd","\u03bd"],"b":"1","i":["+L",", . . . , N"],"maths":[{"@attributes":{"id":"MATH-US-00027","num":"00027"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":["k","fv"]},"mo":"=","mrow":{"mo":"{","mrow":{"mrow":{"mrow":{"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":"k","mrow":{"mi":["fv","nom"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},"mo":"+","mrow":{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["k","fc"]}}}},{"mrow":{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["k","fvnom"]}},"mo":"<","msub":{"mi":["k","fmin"]}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"3.9em","height":"3.9ex"}}}}}]},{"mtd":[{"mrow":{"msub":{"mi":"k","mrow":{"mi":["fv","nom"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"4.4em","height":"4.4ex"}}}}},{"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mo":"\u2062","mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["k","fmin"]}},"mo":["\u2264","\u2264"],"msub":[{"mi":["k","fvnom"]},{"mi":"k","mrow":{"mi":["f","max"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]}}}]},{"mtd":[{"mrow":{"msub":{"mi":"k","mrow":{"mi":["fv","nom"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},"mo":"-","mrow":{"mi":"\u0394","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["k","fc"]}}}},{"mrow":{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["k","fmax"]}},"mo":"<","msub":{"mi":["k","fvnom"]}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"4.2em","height":"4.2ex"}}}}}]}]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"3.9em","height":"3.9ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["for","v"]},"mo":"=","mn":"2"},"mo":[",",",",",","\u2062",","],"mn":["3","4"],"mi":["\u2026","N"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"54","mo":"\u2062","mi":"a"}}}]},{"mtd":[{"mrow":{"msub":{"mi":["\u03bc","v"]},"mo":"=","mrow":{"mo":"{","mrow":{"mrow":{"mrow":{"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":"\u03bc","mrow":{"mi":["v","nom"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},"mo":"+","mn":"1"}},{"mrow":{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["k","fvnom"]}},"mo":"<","msub":{"mi":["k","fmin"]}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"4.2em","height":"4.2ex"}}}}}]},{"mtd":[{"msub":{"mi":"\u03bc","mrow":{"mrow":{"mi":["v","nom"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"3.3em","height":"3.3ex"}}}}}},{"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mo":"\u2062","mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["k","fmin"]}},"mo":["\u2264","\u2264"],"msub":[{"mi":["k","fvnom"]},{"mi":"k","mrow":{"mi":["f","max"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]}}}]},{"mtd":[{"mrow":{"msub":{"mi":"\u03bc","mrow":{"mi":["v","nom"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},"mo":"-","mn":"1"}},{"mrow":{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["k","fmax"]}},"mo":"<","msub":{"mi":["k","fvnom"]}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"4.2em","height":"4.2ex"}}}}}]}]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"6.7em","height":"6.7ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["for","v"]},"mo":"=","mn":"2"},"mo":[",",",",",","\u2062",","],"mn":["3","4"],"mi":["\u2026","N"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"54","mo":"\u2062","mi":"b"}}}]}]}}},{"@attributes":{"id":"MATH-US-00028","num":"00028"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"msub":{"mi":["k","v"]},"mo":"=","mrow":{"mrow":{"mrow":{"mi":"round","mo":["\u2062","[","]"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mfrac":{"mrow":{"msub":{"mi":"mk","mrow":{"mi":["fv","fix"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["k","fv"]}}},"msub":{"mi":["m","f"]}}},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"4.2em","height":"4.2ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["for","v"]},"mo":"=","mn":"1"}},"mo":[",",",",",","\u2062",","],"mn":["2","3"],"mi":["\u2026","N"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}},{"mrow":{"mo":["(",")"],"mn":"55"}}]}}}}]},"The round( ) operation in equation (55) can be implemented by adding m\/2 to m\u00d7k(k) before the rightward bit shift that constitutes division by m. The result of the division will be the correct value of k for any sign of k(k) if the computer works with 2's compliment notation for signed integers and if the rightward bit shift fills in from the left with the 2's compliment sign bit, i.e., with the left-most bit.","Given k from equation (55) and \u03bc from equation (54b), one can use equation (45) to compute i. This value, in turn, can be used to index into the tables to determine the Prompt PRN code sign A (), x, the early-minus-late PRN code zero mask B (), x, and the early-minus-late PRN code sign A (), x, that correspond to data word W:\n\n() for \u03bd=1, 2, 3 \u2003\u2003(56a)\n\n() for \u03bd=1, 2, 3 \u2003\u2003(56b)\n\n() for \u03bd=1, 2, 3 \u2003\u2003(56c)\n","The conditionals in equations (54a) and (54b) can be reduced to a single conditional per data word during normal operation to improve efficiency. This can be done because the sign of \u0394kin equation (53a) is fixed for a given accumulation interval. (Normally the sign of \u0394kdoes not vary from accumulation interval to accumulation interval or from channel to channel for a given receiver because the only variable quantity that affects \u0394kis actual chip length  (), \u0394t, which normally does not vary significantly.) If \u0394k<0, then the proper formula for determining k and \u03bc can be chosen by considering the inequality k<k. Conversely, if \u0394k>0, then the proper formula can be determined by considering the inequality k>k. The decision about which condition to check can be made at the beginning of the accumulation because \u0394kis calculated prior to execution of the iteration in equations (53a)\u2013(56c).","When using a processor that creates instruction pipelines, \u201cif\u201d statements can disrupt the pipeline. In this case equations (54a) and (54b) can be replaced with the following computations: \n\n\u2212\u03b7for \u03bd=2, 3, 4(57b)\n\n=\u03bc\u2212\u03b7 for \u03bd=2, 3, 4\u2003\u2003(57c)\n\nThe min( ) and max( ) functions return, respectively, the minimum or maximum of their two input arguments. The variable \u03b7 is normally zero, in which case equations (57b) and (57c) leave k equal to kand \u03bc equal to \u03bc. The value of \u03b7 is \u22121 if \u0394k<0 and k<k, and +1 if \u0394k>0 and k>k. In both of these cases \u03b7 causes equation (57b) and (57c) to perform the necessary adjustments to k and \u03bc. Note that efficient code may not execute the conditional in equation (57a) once per data word. Instead, its accumulation iterations could be performed in one of three different iterative loops, depending on the value of \u0394k. Additional economies can be had in the first and third conditional clauses of equation (57a). The value of \u2212\u03b7 for the first condition is equal to the sign bit of the 2's compliment representation of k\u2212k. Similarly, +\u03b7 for the third condition is equal to the sign bit of the 2's compliment representation of k\u2212k. In either case, \u03b7 (or its negative) can be computed in two operations.\n","Summarizing real-time over-sampled PRN code generator A () and referring now to , to compute prompt PRN code  () and early-minus-late PRN code  () for an entire accumulation interval, the method includes the steps of iterating equations (44a)\u2013(44c) (method step , ) to construct the table of \u0394i(\u03bc) values. The method further includes the step of computing the auxiliary constants (method step , ) in equations (48a)\u2013(48e) and (50a)\u2013(50e). The method further includes the step of initializing kand \u03bc(method step , ) by evaluating equations (51a)\u2013(52b). The method further includes the step of iterating equations (53a), (53b), (57a)\u2013(57c), (49), (55), and (45) (method step , ) to compute, for each iteration, k, \u03bc, \u03b7, k, \u03bc, k, and i. The method further includes the step of iterating equations (56a)\u2013(56c) (method step , ) to compute, for each iteration, x, x, and x.","As mentioned already, it may prove efficient to interleave the equations (44a\u2013c) iterations and the accompanying shift register iterations between the iterations that compute kthrough x. In this scenario \u03bc can be computed from equation (57c). Afterwards, the shift register iterations that generate code chips C(\u03bc\u22121) though C(\u03bc\u22121) can be performed, and these chip values can be used to iterate equations (44a\u2013c) from \u03bcto \u03bc in order to determine \u0394i(\u03bc) from \u0394i(\u03bc).","The software correlator  () of the present invention can advantageously be easily modified to work with signals at different frequencies, new PRN codes, or even signals for different types of devices. Thus, the same hardware could use the software correlator  () to implement such devices as a GPS receiver, a cell phone, or both. To allow for new codes, new frequencies, and new types of functionality, small changes can be made in the software correlator  (), or different versions of the software correlator  () can be run on the same processor. The changes involve using a different baseband mixing frequency and a different PRN code in the correlation, and perhaps changes that would provide the new signals of interest to the software correlator  (). In order for the present invention to work with signals at different frequencies, new PRN codes, or signals for different devices, two fundamental changes need to be made. First, the baseband mixing frequency must be tailored to that of the signal data , which also involves pre-computing and storing sine and cosine tables at this new frequency. Second, new pre-computed over-sampled PRN code tables  () must be constructed. The size of the new tables should match the over-sampled accumulation period, or at least one over-sampled period of the PRN code. As an alternative to generating new pre-computed over-sampled PRN code tables  (), the new PRN codes can be generated in real-time by over-sampled PRN code generator A (). Also, the system and method of the present invention could be implemented within systems such as GLONASS receivers, cell phones and cell base stations, pagers, wireless Ethernet (e.g. 802.11x standards), Bluetooth\u2122, Blackberry\u00ae wireless internet devices, and satellite radio\/phones (e.g. INMARSAT\u00ae). In fact, the system and method of the present invention are applicable to any sort of telecommunication system\/device that uses spread spectrum, code division multiple access (CDMA) pseudo random number codes for the transmission of information, either wired or wireless.","Referring now to , navigation calculations require measured values of the PRN code phase , carrier phase, and carrier frequency. The measurements for all tracked satellites must be taken at exactly the same time. A time interval counter (TIC) function provides a periodic timing scheme to synchronize these measurements at time t. At time t, the TIC function latches all of the PRN code phase , carrier phases, and carrier frequencies along with the code epoch counters, and software correlator  () makes these available to application-specific code  (), for example, GPS receiver software. GPS receiver software uses the code phase and epoch counters to compute the pseudo range to each satellite. Software correlator  () keeps track of the code and carrier phase of each signal as determined by the code chipping rate and the carrier Doppler shift inputs. The quantity {circumflex over (f)}, the estimated code chipping rate of software receiver  for satellite j during its kPRN code period, can be determined either by an acquisition search procedure, or if tracking, by a delay-locked loop. Likewise, {circumflex over (\u03c9)}, the associated carrier Doppler shift, can be defined by an acquisition procedure or, if tracking has commenced, by a phase-locked loop or a frequency-locked loop. These determinations are made by application-specific code  (). Software correlator  () can use these two frequencies to update quantities that keep track of its code and carrier phases according to the formulas: \n\n\n{circumflex over (\u03c6)}={circumflex over (\u03c6)}+{circumflex over (\u03c9)}({circumflex over (\u03c4)}\u2212{circumflex over (\u03c4)})\u2003\u2003(59)\n","Software correlator  () can keep a running track of these quantities and can initialize these iterations as part of the signal acquisition calculations that it carries out in conjunction with application-specific code  (FIG. ). The quantities {circumflex over (\u03c4)}and {circumflex over (\u03c6)}are either sent to software correlator  by application-specific code , or they are initialized arbitrarily by software correlator  and application-specific code  executes feedback control of {circumflex over (f)}and {circumflex over (\u03c9)}to force the sequences defined by equations (58) and (59) to converge to appropriate values. Information about the previously-described conventional method can be found in Dierendonck.","The TIC time t () can occur at, for example, the millisecond boundaries of the receiver clock. At each time t, the PRN code phase  () of each signal is computed in the following manner: \n\n\nwhere {circumflex over (\u03c8)}is the PRN code phase  () in chips of signal j at TIC time t (). The epoch counters, which are simply a running total of the number of code periods  (), are incremented at each code start\/stop time.\n","The carrier phase calculation at time t () is similar to the PRN code phase  () calculation:\n\n{circumflex over (\u03c6)}={circumflex over (\u03c6)}+{circumflex over (\u03c9)}(\u2212{circumflex over (\u03c4)})\u2003\u2003(61)\n\nwhere {circumflex over (\u03c6)}is the carrier phase at time t. The Doppler shift that gets returned at time t () is {circumflex over (\u03c9)}.\n","With respect to the performance of the system and method of the present invention, a sample screen-shot from the illustrative embodiment of the present invention is provided in Table 8. This table illustratively shows the tracking of nine channels. The roof-mounted L1 antenna of the illustrative embodiment can have a pre-amp with 26 dB of gain. The software correlator  () of the present invention can provide positional accuracy on the order of 10\u201315 meters when working in conjunction with application specific software  ().",{"@attributes":{"id":"p-0116","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"350pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Numerical GPS tracking data output by the illustrative embodiment."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"13"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"12","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"13","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Lat","42.44354","Spd","0.5","SVs","8","Ctrack","FLL","Date","17\/10\/02",{},{},{}]},{"entry":["Lon","\u221276.48143","Hdg","327.0","Nav","3D","GDOP","1.9","GPS","19:58:11"]},{"entry":["Alt","269.6560","ROC","\u22120.7","HI",{},"DO","\u2212393.0","OscErr","0.25"]},{"entry":[{},{},{},{},"ELEV"]},{"entry":{"@attributes":{"namest":"1","nameend":"13","align":"center","rowsep":"1"}}},{"entry":["CH","SV","ELV","AZI","DOPP","NCO","UERE","SF","PRerr","PRRerr","LOCK","SNR","iS4"]},{"entry":{"@attributes":{"namest":"1","nameend":"13","align":"center","rowsep":"1"}}},{"entry":["1","1","67","237","\u2212528","\u2212927","4","1","9.0","0.7","CCBF","16.9","\u22121.000"]},{"entry":["2","22","64","47","\u22121644","\u22122045","4","1","14.3","0.6","CCBF","18.0","\u22121.000"]},{"entry":["3","3","50","152","2174","1778","2","1","5.5","\u22120.4","CCBF","18.4","\u22121.000"]},{"entry":["4","25","22","106","\u22122650","\u22123050","2","1","42.9","0.2","CCBF","13.2","\u22121.000"]},{"entry":["5","17","1","62","1722","1331","2","1","7.5","\u22120.4","CCBF","8.1","\u22121.000"]},{"entry":["6","15","2","81","2278","1887","2","1","\u22125.2","\u22120.7","CCBF","7.4","\u22121.000"]},{"entry":["7","27","12","295","2969","2575","0","1","0.0","0.0","CCBF","8.0","\u22121.000"]},{"entry":["8","13","44","303","1856","1866","2","0","0.0","0.0","C","14.9","\u22121.000"]},{"entry":["9","31","22","185","3860","3464","2","1","\u221211.0","\u22120.5","CCBF","15.9","\u22121.000"]},{"entry":["10\u2002","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014",{},"\u2014","\u2014"]},{"entry":["11\u2002","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014",{},"\u2014","\u2014"]},{"entry":["12\u2002","20","4","219","\u22123086","\u22123483","2","1","27.5","0.3","CCBF","9.6","\u22121.000"]},{"entry":{"@attributes":{"namest":"1","nameend":"13","align":"center","rowsep":"1"}}}]}}]}}},"Two comparison tests illustrate the performance of the system and method of the present invention. In the first test, a first configuration includes a MITEL\u00ae GP2021 hardware correlator, but is in all other ways identical to a second configuration that includes the software correlator  () of the present invention. The two configurations differ in SNR by less that 1 dB and in navigation solutions by no more than 5\u201310 meters. In the second test, timing studies using the system of the present invention show that processing six channels uses only about 20% of the processor's capacity, while Akos 2001a report a real-time software GPS receiver that would require 100% of the capacity a 1.73 GHz microprocessor to implement a 6-channel GPS receiver when processing data from an RF front-end with a sampling frequency of 5.714 MHz.","Referring now to , among other indicators that could assess the accuracy of the PRN code generated by real-time over-sampled PRN code generator A (), which includes prompt PRN code sign A (), early-minus-late PRN code sign A (), and early-minus-late PRN code zero mask B (), is the low distortion of the generated codes versus the true codes. , generated for prompt code comparisons, shows juxtaposed plots of the autocorrelation function  () of the sampled true code and the cross correlation function  () between the sampled true code and the sampled code as generated from the new xtable.  shows a similar comparison for early-minus-late PRN code  (). In either case, the nominal chipping frequency is f=1\/\u0394t=1.023 MHz, the sampling frequency is f=12.199 MHz, and the code timing resolution of the table is m=12, i.e., 1\/12of a sample. This resolution translates into approximately 1\/143of a code chip. The actual chipping rate differs from the nominal by (f\u2212f)=1.5 Hz. This Doppler shift of the code chipping rate corresponds to a significant non-zero range rate between the receiver and the transmitter, 438 m\/sec. The correlations are accumulated over 10230 code chips, and the code is a time-multiplexed version of a pair of the new GPS civilian L2 CL and CM codes. The data word indexing calculations for this example use a code chip start time resolution of \u0394t\/10, i.e., m=10.","It is obvious from  that prompt PRN code  () and early-minus-late PRN code  () distortion is very small. The correlations produced using the new tables are virtually identical to those produced from the exact code. The low distortion of the new approach is best characterized by two parameters: the amount by which the correlation peak of the prompt PRN code sign A () droops below one and the offset of the zero-crossing time of the early-minus-late PRN code  (). The former metric characterizes the power loss of the new approach, and the latter metric characterizes the net timing error. The droop of the prompt peak is only 0.3% of the nominal amplitude, which translates into a 0.03 dB loss. The timing distortion of the new code is less than 4\u00d710code chips. This distortion is very small; it translates into about 0.1 m of GPS range measurement error.","It may seem paradoxical that the code timing error is only 4\u00d710code chips when the code timing granularity of the x(i) tables is \u0394t(m\u0394t)\u22457\u00d710code chips. The resolution of this paradox lies in the averaging effect of the accumulations. The length of a code chip equals 143.099269 code offset time grid intervals for the example shown in . The non-integer nature of this number causes the code offset errors of the x(i) tables to get dithered as the accumulation works its way through successive data words. This dithering tends to average out the table granularity errors, and this averaging can reduce the net timing error by an order of magnitude or more, as shown in .","Although the invention has been described with respect to various embodiments, it should be realized this invention is also capable of a wide variety of further and other embodiments."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING","p":[{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2D"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIGS. 9A and 9B","FIG. 9A","FIG. 9B"]}]},"DETDESC":[{},{}]}
