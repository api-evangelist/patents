---
title: Method and apparatus for rendering instance geometry
abstract: A method and apparatus for rendering instance geometry whereby all culling, level of detail (LOD) and scene management is performed directly on a GPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08284197&OS=08284197&RS=08284197
owner: Advanced Micro Devices, Inc.
number: 08284197
owner_city: Sunnyvale
owner_country: US
publication_date: 20090316
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE EMBODIMENTS"],"p":["This application claims priority to U.S. Provisional Patent Application No. 61\/079,920, filed Jul. 11, 2008.","This application is related to the graphics rendering.","The simulation and rendering of massive crowds of characters with a high level of detail from a variety of viewpoints has presented a difficult scene management challenge to the gaming and general graphics community. The latest generations of commodity graphics processing units (GPUs) demonstrate incredible increases in geometry performance, especially with the inclusion of a GPU tessellation pipeline.","Nevertheless, even with state-of-the-art graphics hardware, rendering thousands of complex characters (objects) with high polygonal counts at interactive rates is very difficult and computationally expensive. These characters may be very small (virtually invisible) or not visible at all. The rendering of such invisible or virtually invisible characters with over a million polygons each on the screen can severely impede performance and waste critical computing resources. Some methods of object culling and level of detail (LOD) techniques are required in order to eliminate or minimize the rendering of these invisible or virtually invisible objects.","Graphics rendering is computationally demanding. GPUs typically possess nearly an order of magnitude more computing resources than central processing units (CPUs). This has prompted an increasing interest is using GPUs to perform more general types of calculation. For example, in game applications, many of the calculations used to drive the objects in the game world (such as physics simulation or artificial intelligence) may be accelerated by moving them to the GPU. Doing so, however, complicates the scene management techniques which must be used for efficient rendering.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1","b":"100"},"The programming model of a graphics system is as follows. The CPU is responsible for issuing rendering commands to the GPU, such as configuring the various pipeline stages, or issuing primitives to the graphics pipeline. A primitive is a geometric entity consisting of a set of vertices. The set of supported primitives includes, but is not limited to: points (a single vertex), lines (a pair of vertices), and triangles (three vertices). For each vertex, primitive, or pixel generated by a given rendering command, corresponding application defined programs are invoked by the hardware to perform calculations needed for rendering.","A vertex shader (VS) is a GPU program which is invoked for individual primitive vertices. Each VS invocation obtains a set of attributes for a single input vertex, performs user programmable calculations, and generates an output vertex. The input vertex data is generally retrieved from a vertex buffer (input buffer), which is typically located in graphics memory.","A geometry shader (GS) is a GPU program which is invoked for individual geometric primitives. Each GS invocation receives the VS outputs for a single primitive, performs user programmable calculations, and emits a variable number of output primitives, (or it may not emit any). The GS may be configured for stream output which causes all primitives emitted from the geometry shader to be written consecutively (and in order) to a vertex buffer. The GPU maintains a counter which tracks the number of primitives emitted to a particular buffer.","An API mechanism exists to cause the GPU to re-issue a set of primitives that were previously emitted by a geometry shader using the stored primitive count. This is presented to the application as a special graphics command which is issued by the CPU. For example, in Microsoft's DX10, this is known as a DrawAuto command. In addition, the number of primitives which would be issued by a DrawAuto call may be queried by the application to determine the number of object instances to ultimately render (draw).","Graphics APIs also include support for geometry instancing, whereby multiple copies of a single batch of geometry are issued to the graphics pipeline. With instance rendering, a separate vertex buffer (input buffer) may be used to supply per-instance data to the VS. The VS will be invoked multiple times with the same vertex data, but each invocation of a particular vertex is supplied with different instance data. Geometry instancing is the preferred way to render numerous copies of identical objects in different locations or configurations, because a large number of objects may be submitted for rendering with minimal CPU overhead.","The various shader stages (vertex, geometry, pixel) may be implemented as different threads sharing the same physical hardware, (as is the case in current GPUs such as Advanced Micro Device's ATI Radeon HD4870), or as separate physical hardware (as was the case in earlier generation GPUs). Typically, the programmable stages are vectorized, and operate on a number of elements (primitives and vertices) in parallel (but this does not have to be the case).","Culling and LOD are integral parts of a modern rendering engine. Culling is the process of identifying objects in the scene which are not visible and excluding them so that they will not be rendered. This is generally accomplished by performing some form of visibility test on a bounding volume which encloses the object. LOD refers to the use of simplified geometry or shading for visible objects with less visual importance. These techniques, collectively, are sometimes referred to as \u201cscene management.\u201d Given a set of objects to be rendered, it is the job of a rendering engine to identify the visible objects, to assign a level of detail to each visible object, and to issue the necessary rendering commands to the GPU.","The most common type of culling, known as view frustum culling, uses a geometric test to exclude objects which lie outside the field of view of the camera. In current systems, this culling test is performed on the host CPU, prior to submitting the object to the GPU for rendering. Objects which fail the test are simply not submitted.","Another kind of culling is occlusion culling. Occlusion culling eliminates objects that are not visible on a display screen because they are blocked by other objects, such as when a character moves behind a building in a game. One common technique is to separate the scene into fixed regions, and to pre-compute, for each region, the set of regions potentially visible from it (called a potentially visible set or PVS). Objects which do not lie in the PVS of the region containing the camera are simply not rendered. This method requires expensive preprocessing of the scene in order to be effective, and therefore is not suitable for highly dynamic environments.","Modern APIs such as Direct3D 10 also provide conditional rendering functionality which may be used for occlusion culling. To use this technique, the bounding volume of an object is rasterized and compared to a Z-buffer containing the depths of the occluders. The API commands to render the actual object can be issued conditionally, so that they are only carried out if at least one bounding volume pixel is not occluded. This technique can provide effective culling in arbitrary scenes, but it requires the CPU to issue several rendering commands per object, which can quickly create a performance bottleneck.","LOD selection is also typically implemented using the CPU. In a typical LOD system, objects which are determined to be visible may be partitioned into multiple groups, based on their visual importance. One way to do this is to partition the objects based on their distance from the camera. The less important groups may then be rendered in a less costly way (for example, by using simpler geometric models).","Existing implementations of object culling and LOD selection typically perform many of their calculations using the CPU, which imposes a serious performance bottleneck. Occlusion culling using conditional rendering can be particularly harmful to system performance, since it makes it impossible to leverage geometry instancing. Furthermore, CPU based implementations require that the positions of the objects be made available to the CPU. This complicates GPU-based simulation of objects, because it may require expensive data transfers from graphics memory to host memory.","A scalable method for implementing frustum culling, occlusion culling, LOD or other types of object culling is needed, that is compatible with GPU-based simulation of the objects. Such a method should not require any scene preprocessing or occluder selection (anything that is rendered earlier should function as an occluder), nor can it require additional per-object CPU overhead for rendering. In addition, such a method should not require excessive CPU\/GPU communication.","A method and apparatus for rendering instance geometry whereby all culling, level of detail (LOD) and scene management is performed directly on a GPU.","As used herein, the terminology \u201cfiltering test\u201d refers to a function that is evaluated for each object to decide whether it should pass the filter. The terms \u201cfiltering\u201d and \u201cstream filtering\u201d refer to the whole process of applying the filtering test and keeping things (objects, instance information, etc.) that pass. As used herein, the term \u201cobject\u201d refers to any geometric entity that may be rendered on a display screen.","An application program (AP) stores object candidates to be rendered in a buffer, and specifies the configuration of the graphics pipeline for the partitioning and processing of objects. The AP will define in a command stream, the specific steps and respective order for the processing of these objects, including but not limited to the types of culling methods (filtering type) utilized and\/or the number of LODs used.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2","b":["200","205","210","220","0","230","230"],"i":["a","n "]},"Referring to , an object and its respective object state is input . Frustum culling filtering is performed . If the object is outside of the view frustum, the object is discarded . Otherwise, occlusion filtering is performed on the object state . If the object is occluded, the object is discarded . Otherwise, the LOD for the object state is then determined (this is an example of multipass LOD determination) to determine the LOD of the object -. The object is stored in a LOD specific buffer (output buffer) (-). For example, if the object is LOD , (such as having a lowest level of detail), it is stored in the group  buffer ; if the object is LOD , (such as having a greater level of detail), it is stored in the group  buffer ; and this continues until the object having LOD n, (such as having a greatest level of detail), it is stored in the group n buffer . An object may exist in more than one LOD and as such the same object will be stored in multiple LOD specific buffers, group  to group n. If all of the objects have been processed , all of the objects are rendered  from the respective LOD specific buffers, in this example, group  through group n.","In an alternative embodiment, a single pass LOD generator may be used to sort the objects into distinct buffers for each respective LODs. A single pass LOD generator determines the objects LOD in a single LOD program instead of one for each LOD.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","b":["300","305","310","330","320","340","350","305"]},"As is known to those skilled in the art, multiple objects and their respective object states may be processed simultaneously. For example, if there are three objects: A, B and C, the object states of A, B and C will be input and frustum culling filtering may be performed in parallel on A, B and C. A GPU will receive a configuration command from the AP followed by another command specifying the number of objects. In this example, referring back to , the GPU will create three instances of the frustum culling filter . A will be submitted to a first instance, B to a second instance and C to a third instance. When frustum filtering has been performed on all three objects (A, B and C), the objects that pass frustum culling filtering (in this example, up to 3 objects) are submitted for occlusion filtering . The GPU will create up to three instances of occlusion filter . For example, assuming A, B and C passed frustum culling filtering, A will be submitted to a first instance, B to a second instance, and C to a third instance. When occlusion filtering has been performed on all three objects (A, B and C), the objects that passed occlusion filtering are submitted for LOD determination -. Similarly, the GPU will create up to three instances of each LOD determination test, three of LOD  , three of LOD  and three of all additional LOD tests through LOD n . After all of the objects have been processed, all of the objects are rendered from the respective LOD specific buffers (output buffers), in this example, group  through group n.","One skilled in the art will recognize that a very large number of objects may be processed at any given time. The number of objects actually processed in parallel will depend upon various system resources and constraints, including at least the speed of a processor or the amount of available graphics memory.","In one embodiment occlusion culling is accomplished based on a Hi-Z map, a technique based on Z pyramids. A Hi-Z map is a series of depth images, where the coarser (lower) resolution images contain the maximum depths of sets of pixels in the finer resolution images. It is assumed that a depth buffer exists containing the distance to occluding geometry for each screen pixel, which is generally obtained by rendering the occluding geometry. These are the same values generally used for Z buffering, and are correlated to the distance from the image plane to the 3D point visible under each pixel. Starting with this depth buffer, a series of coarser depth buffers is generated by repeatedly dividing the size of the buffer by in half (rounding down), until a 1\u00d71 buffer is reached. This process is shown in Table 1.",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"16.34mm","wi":"74.93mm","file":"US08284197-20121009-C00001.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Each pixel in a coarser level contains the maximum depth of corresponding pixels in the finer level below it. This is generally the maximum over a 2\u00d72 group of pixels. However, for odd-sized images, the coarse pixels on the boundaries must cover additional fine pixels to ensure that the entire screen is accounted for.","Construction of the Hi-Z map is implemented by processing successive levels in fine-to-coarse order. For each pixel in a coarser level, the maximum of the corresponding depth values in the next finest level is determined and stored. This process is repeated until the topmost (1\u00d71) level contains the largest depth value that was present in the input Z buffer. This computation may be implemented on the GPU by binding each coarse level as a render target, rendering screen-filling geometry, and configuring the pixel shader to fetch from the finer level and determine the maximum depth value.","After Hi-Z map construction, a stream filtering pass may be performed which uses the information in the Hi-Z map to execute occlusion culling. In order to ensure a stable, high frame rate, it is desirable to limit the number of pixels that are fetched for each object, and to avoid divergent flow control between object instances. This is accomplished by exploiting the hierarchical structure of the Hi-Z map.","Occlusion culling operates by computing a bounding rectangle which fully encloses the object on the screen, and using a fixed set of pixels from the Hi-Z map to determine whether or not the rectangle is occluded. The bounding rectangle is derived based on the position of a bounding sphere centered on the object (as seen from the camera).","One example embodiment of a method  of occlusion culling using a Hi-Z map is shown in . For each object state , the sphere center, Cv , is determined by transforming the center of the object's bounding sphere into camera-relative coordinates. The location of the object's bounding sphere is either stored directly in the object state, or else derived from it. The closest point to the camera on the sphere, Pv , is determined by the following formula:",{"@attributes":{"id":"p-0045","num":"0044"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":"Pv","mo":"=","mrow":{"mi":"Cv","mo":"-","mrow":{"mrow":{"mo":["(",")"],"mfrac":{"mi":"Cv","mrow":{"mo":["\uf603","\uf604"],"mi":"Cv"}}},"mo":"\u2062","mi":"r"}}},"mo":";"}},{"mrow":{"mi":"Equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"1"}}}]}}}},"br":{}},"The projected depth  of Pv is in the same space as the depth values in the Hi-Z map, and is determined by applying a standard projection transformation to the point Pv and performing the perspective division as is normally done for raterization.","In the special case where the camera lies inside the bounding sphere, then Equation (1) may result in a point behind the image plane whose projected depth is non-negative, This means that Pv is behind the camera. A test for this condition is made at . If Pv is behind the camera , then the object (e.g., character) must not be culled to prevent a false occlusion. The bounding rectangle (usually a square) on the screen which fully encloses the bounding sphere is then determined . One graphical example of bounding spheres and rectangles  is shown in . The bounding spheres  and  and the rectangles  and  are shown for two hypothetical objects A and B. The sides of the rectangles  and  must be aligned to both the x and y axes of the screen , as shown in .","A method  for the determination of the bounding rectangle  from the bounding sphere  is illustrated in . The sphere's  projected height in normalized device coordinates (ND C) space is approximated based on its distance (d) from the camera . The height (h) of the rectangle  can be approximated as follows, where d is the distance from the sphere center to the camera , and \u03b8 is the vertical field of view of the camera :",{"@attributes":{"id":"p-0049","num":"0048"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"h","mo":"=","mrow":{"mfrac":{"mi":"r","mrow":{"mi":"d","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"tan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":"\u03b8","mn":"2"}}}}},"mo":"."}}},{"mrow":{"mi":"Equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"2"}}}]}}}}},"Because of the change in coordinate systems, the height h in NDC space is equal to half the rectangle's  height in camera relative coordinates. The width (w\u2032) of the rectangle  is equal to h divided by the screen aspect ratio. The width (W) of the rectangle , in pixels, is equal to w\u2032, multiplied by half the width of the screen.","The method illustrated in  is a close approximation to the true bounding rectangle. It will underestimate the size of the rectangle when the sphere is close to the camera or under extreme fields of view, when the sphere is near the corners of the screen. In practice, an application may need to pad the size of the object's bounding sphere to compensate for the approximation. An alternative embodiment may calculate a conservative bounding rectangle by deriving a screen-facing quadrilateral in camera space which encloses the sphere, computing the screen positions of its corners, and using their extents on each of the screen axes to derive a conservative rectangle. This embodiment requires more computation than the approximation presented above.","Referring back to , a specific level in the Hi-Z map at which the rectangle will cover no more than one 2\u00d72 pixel neighborhood is chosen  The level is determined by ensuring that the size of the square is less than the width of a single texel at the chosen resolution. The lowest level i is chosen such that:",{"@attributes":{"id":"p-0053","num":"0052"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mo":["(",")"],"mfrac":{"mi":"W","msup":{"mn":"2","mi":"i"}}},"mo":"<","mn":"1."}},{"mrow":{"mi":"Equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"3"}}}]}}}}},"This yields the following equation for i:\n\n=\u250clog()\u2510.\u2003\u2003Equation (4)\n","If the width of the screen is less than its height, the height of the rectangle (in pixels) should be used instead. This pixel neighborhood is then fetched from the map , and the depth values are compared against the projected depth of the point Pv .","At , if all four pixels (the chosen 2\u00d72 pixel neighborhood) contain depth values less than the depth of the point Pv , then it is guaranteed that the entire sphere, and therefore the entire object, is occluded (i.e. not visible). This results in a failed condition , which means that the object currently being analyzed is eliminated (culled) and an LOD determination will not be performed. Otherwise, the object is visible, resulting in a pass condition , and the object will be submitted to determine its LOD (e.g., in , -).","The described test will never conclude that a visible object is occluded, but it may falsely conclude that an occluded object is visible. The test may be made more exact by using a larger neighborhood, and fetching additional pixels from finer levels of the Hi-Z map.","An example GPU  configured to implement the methods described above is shown in . The GPU  comprises a processor  including a VS component (VSC)  configured to execute a VS, a GS component (GSC)  configured to execute a GS and optionally a rasterizer , a pixel shader , and a Z bufferer , and a memory component, graphics memory , optionally including an input buffer  (there may optionally be multiple input buffers), an output buffer  (there may optionally be multiple output buffers, e.g., one for each LOD group) and a counter .","In one embodiment, GPU processor  receives graphics commands from an AP running in a Host CPU. The graphics commands may contain the specific graphics pipeline configuration and the number of objects to be processed by the GPU processor . The AP also stores object candidates (objects) to be rendered in an input buffer  in graphics memory .","An example of an AP command stream  is shown in . The command stream  begins with a command to setup the VSC  and GSC  for frustum culling . This is followed by a command to bind the object states as VS input . Binding associates a buffer with a slot in the pipeline. This is followed by a command to bind the frustum buffer (one example of an input buffer) to stream output  (an output buffer). Next, the command stream includes a call to a graphics API to draw 1 point per object . In this example, - are required to configure the graphics pipeline to perform frustum culling. The frustum culling commands are followed by a sequence of commands that set up the graphics pipeline to perform occlusion culling. These commands include a command to setup the VSC  and GSC  for occlusion culling , a command to bind the frustum buffer as VS input (the output from frustum culling filtering is now input for occlusion filtering), a command to bind the visible object buffer (an example of an output buffer) to stream output  and a command to the graphics API DrawAuto . Commands required to configure LOD determination follow the occlusion configuration commands. These commands include a command to bind the visible object buffer (now used as an input buffer) to VS input , a command to setup the VSC  and GSC  for LOD filtering , a command to bind the LOD buffer (an output buffer) to stream output  and a call to the graphics API DrawAuto . If more than one LOD is specified (as is usually the case), the command stream will contain multiple sets of commands similar to - to configure the pipeline to process each LOD (e.g., the command stream would contain additional sets of commands - or similar configuration commands). The last command is render all groups .","Referring back to , the VSC  is configured to receive a \u201cvertex\u201d which contains the state of a particular object (the object states are stored in vertex buffers) from graphics memory . Graphics memory  may optionally include an input buffer  (multiple input buffers may optionally exist) containing object states, an output buffer  (multiple output buffers may optionally exist) to receive and store the states of the objects that pass the filtering tests and a counter  for counting how many objects pass the filtering tests.","The VSC  performs a filtering test whose result is sent to the GSC . The GSC  is configured to conditionally store a point primitive containing the object state in graphics memory  based on the result of the filtering test and, optionally, a filtering test in output buffer . As described above, filtering tests include, but are not limited to, one or more of view frustum culling or occlusion culling using the Hi-Z map. All objects are then rendered from graphics memory .","In another embodiment, a stream filter may also be implemented by performing the entire calculation in the GSC , instead of the VSC . In this case, the VSC  is configured to simply pass the object state through the pipeline to the GSC . The reasons for separating these functions include:","1. On some GPUs, throughput for GS operation can be lower than for VS operation; or","2. For ease of programming, to de-couple the filtering test from the conditional emission.","By leveraging this stream filtering technique, culling and LOD determination may be implemented for instanced objects directly on graphics hardware, without CPU intervention.","Although features and elements are described above in particular combinations, each feature or element can be used alone without the other features and elements or in various combinations with or without other features and elements. The methods or flow charts provided herein may be implemented in a computer program, software, or firmware incorporated in a computer-readable storage medium for execution by a general purpose computer or a processor. Examples of computer-readable storage mediums include a read only memory (ROM), a random access memory (RAM), a register, cache memory, semiconductor memory devices, magnetic media such as internal hard disks and removable disks, magneto-optical media, and optical media such as CD-ROM disks, and digital versatile disks (DVDs).","Suitable processors include, by way of example, a general purpose processor, a special purpose processor, a conventional processor, a digital signal processor (DSP), a plurality of microprocessors, one or more microprocessors in association with a DSP core, a controller, a microcontroller, Application Specific Integrated Circuits (ASICs), Field Programmable Gate Arrays (FPGAs) circuits, any other type of integrated circuit (IC), and\/or a state machine. Such processors may be manufactured by configuring a manufacturing process using the results of processed hardware description language (HDL) instructions (such instructions capable of being stored on a computer readable media). The results of such processing may be maskworks that are then used in a semiconductor manufacturing process to manufacture a processor which implements aspects of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
