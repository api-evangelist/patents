---
title: Developing and executing applications with configurable patterns
abstract: Methods and apparatus, including computer program products, for developing user interface applications using configurable patterns and for executing such pattern-based applications. The applications can be developed by generating a graphic representation of a pattern, which can include multiple pattern elements having prearranged user interface elements. The pattern can specify predefined actions that can be performed using the user interface elements, and the graphic representation can include graphic objects corresponding to the pattern elements. Application development can further include receiving user input identifying a selected graphic object and modifying the graphic representation to display information regarding the pattern element corresponding to the selected graphic object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08312382&OS=08312382&RS=08312382
owner: SAP AG
number: 08312382
owner_city: Walldorf
owner_country: DE
publication_date: 20040511
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates to data processing by a computing device, and more particularly to application programming and execution.","A user interface (UI) facilitates interaction between humans and computers by inviting and responding to user input. User interfaces come in many varieties, and are designed to work in concert with application programs. Application programs, sometimes referred to simply as applications, are programs that an end-user runs to accomplish certain tasks. Applications typically work in conjunction with one or more back-end systems, which store the data to be worked on (e.g., business objects and other business data), as well as logic for manipulating the data (e.g., transactions or other business logic). Examples of back-end systems include database systems, enterprise resource planning (ERP) systems, and customer relationship management (CRM) systems.","A common scenario involving user interfaces is a network application, where a network connects an application program running on a server and one or more user interfaces displayed in client programs running on client devices. The client\/server relationship is one in which a server provides services to the client devices. Both the client devices and the server typically have a network interface for accessing networks such as a local area network (LAN), a wide area network (WAN), or the Internet.","In a network environment, a common client device is a personal computer, and a common client program is a Web browser. The client program, which displays a user interface for an application running on a server, enables networked communication between the client device and the server using a data transfer protocol (e.g., the Hypertext Transfer Protocol (HTTP)) to exchange files, images, programs, and\/or application data. HTTP is a request\/response-type protocol that specifies how the client device and the server communicate with each other. The server may receive a request from the client device using HTTP, respond to the request, and then close the connection. HTTP is a stateless protocol, meaning that each time a client device requests a Web page, the server will respond to the request independently of any previous requests from the client device, and without recording the request.","The information transmitted from the server and intended for display by the client program on the client device may be described with Hypertext Markup Language (HTML) code or Extensible Markup Language (XML) code. HTML is a language that is used to describe the structure of a document, such as a Web page. Client programs interpret HTML code to determine how to display the information contained in the page. A user may request a Web page from a server by clicking on a hyperlink or specifying a Uniform Resource Locator (URL) string. A URL can be used to identify the address of a file or Web page that may be accessed on a network. The address identifies the Web server on which the file or Web page is stored and the directory in which the item is located. When the server receiving the URL request finds a sought Web page, the server sends the page to the client device so that the client device can use that Web page, for example, by generating a display for a user according to the Web page.","An application usually implements the functionality required to display and execute one or more user interfaces for the application. For this reason, an application is sometimes referred to as a user interface application. In some cases, part of the user interface functionality (e.g., rendering) may be handled by a client program that interacts with the application. Whether or not this can occur depends on the capabilities of the client program.","The present invention provides methods and apparatus, including computer program products, implementing techniques for developing user interface applications using configurable patterns and for executing such pattern-based applications.","In one aspect, the techniques can include generating a graphic representation of a pattern, the pattern including multiple pattern elements having prearranged user interface elements. The pattern can specify predefined actions that can be performed using the user interface elements, and the graphic representation can include graphic objects corresponding to the pattern elements. The techniques can also include receiving user input including an identification of a selected graphic object and modifying the graphic representation to display information regarding the pattern element corresponding to the selected graphic object.","In particular implementations, the techniques include receiving additional user input including configuration information for the pattern and modifying the graphic representation of the pattern in accordance with the configuration information. The configuration information can specify associations between one or more of the user interface elements and one or more entities in a back-end system, and the graphic representation can suppress details of the pattern elements in order to reduce complexity of the graphic representation. The techniques can further include generating a visual representation of one or more available entities in a back-end system, wherein the additional user input can include a selection of one or more of the available entities. The configuration information can also specify customization data for the user interface elements, wherein the techniques can further include modifying the graphic representation of the pattern in accordance with the customization data. The techniques can additionally include generating configuration data for the pattern based on the configuration information, the configuration data specifying the associations between the user interface elements and the entities in the back-end system in a predefined format. The configuration data can be stored separately from the pattern.","In certain implementations, at least one pattern element can include a data port. Moreover, the techniques can include receiving user input identifying a second pattern, receiving user input specifying the connection of the data port to the second pattern, and automatically configuring the second pattern based on the data from the data port.","In particular implementations, at least one of the pattern elements is a nested pattern, and the selected graphic object corresponds to the nested pattern. Moreover, modifying the graphic representation of the pattern can include displaying a graphic representation of the nested pattern. The techniques can also include receiving additional user input including configuration information for the nested pattern and modifying the graphic representation of the nested pattern based on the configuration information. The pattern can, for example, be an application floor plan.","In certain implementation, the techniques also include receiving additional user input including configuration information for the pattern and automatically associating all the sub-entities with the pattern element corresponding to a selected graphic object. The configuration information can specify an association between the pattern element corresponding to a selected graphic object and an entity in a back-end system, and the entity in the back-end system can include multiple sub-entities. Moreover, automatically associating all the sub-entities with the pattern element can include generating a sub-element in the pattern element for each sub-entity.","Additionally, the pattern element can include a search form, the entity in the back-end system can include a query, the sub-entities can include query parameters for the query, and automatically associating all the sub-entities with the pattern element can include modifying the search form so that it is operable to display all the query parameters. Furthermore, the pattern element can include a list pane, the entity in the back-end system can include a table, the sub-entities can include columns in the table, and automatically associating all the sub-entities with the pattern element can include modifying the list pane so that it is operable to display all the table columns.","In certain implementations, the techniques can additionally include generating a visual representation of one or more chart objects, each chart object corresponding to a chart program operable to graphically represent data, receiving additional user input, and associating the chart program corresponding to the selected chart object with the selected pattern element corresponding to the selected graphic object. The additional user input can include configuration information and an identification of a selected chart object, the configuration information specifying an association between the pattern element corresponding to a selected graphic object and an entity in a back-end system. The chart program corresponding to the selected chart object can be operable to receive a specification of one or more chart features, wherein the additional user input can include a selection of one or more of the chart features.","In particular implementations, the techniques include receiving user input including additional configuration information for the pattern, identifying one or more related entities in the back-end system, each related entity being related the first entity, generating a visual representation of the related entities, receiving user input including an identification of a selected related entity, and associating the pattern element corresponding to the selected graphic object with the selected related entity instead of the first entity. The configuration information can specify an association between the pattern element corresponding to a selected graphic object and a first entity in a back-end system. Moreover, the first entity can include a first data structure having a key, wherein the related entities are distinct data structures having the key.","In certain implementations, the techniques can also include displaying a representation of one or more modules in a selected back-end system, receiving user input including an identification of a selected one of the modules, and sending a request for information about the selected module to an agent. The techniques can further include receiving first data including a description of one or more entities in the selected module, displaying a representation of the one or more entities, receiving user input including an identification of a selected one of the entities, and displaying a representation of the selected entity in the graphic representation of the pattern. The techniques can additionally include associating the selected entity with the pattern element corresponding to a selected graphic object.","The description of the one or more entities can include meta data about the one or more entities, and the meta data can be from a repository that stores normalized data describing the selected back-end system. Furthermore, the description of the one or more entities can be in a self-describing format, such as XML. The one or more entities can be queries that can be executed in the selected module.","The techniques can also include sending a request for information about the selected entity to the agent, receiving second data include a description of input that can be provided to the selected entity and output that can be produced by the selected entity, and displaying the second data in the graphic representation of the pattern. The selected entity can be a query that can be executed in the selected module, the description of the input can be a list of query parameters that can provided to the query, and the description of the output can be a list of data fields retrieved by the query.","The techniques can further include displaying a representation of one or more back-end systems, receiving user input including an identification of a selected back-end system, sending a request for information about the selected back-end system to the agent, and receiving second data from the agent, the second data including a description of the modules in the selected back-end system.","The techniques can be implemented to realize one or more of the following advantages. Graphically presenting a pattern and pattern components to a user assists a user in intuitively understanding the responsibilities of each part of a configuration. The understanding may be enhanced by allowing a user to \u201czoom in\/zoom out\u201d to particular portions of the configuration. Thus, the user is presented with a high-level pattern diagram while still being able to obtain information regarding low-level components. The graphical presentation can also suppress many details of a pattern to keep the complexity of the configuration operation small.","The graphical presentation can also assist a user in configuring a pattern. In particular implementations, in fact, at least some of the configuring operations may be automated. Additionally, the presentation can restrict a user to those actions that are possible for configuring a pattern.","One implementation of the invention provides all of the above advantages.","These general and specific aspects can be implemented using a computer program, a method, a system or apparatus, or any combination of computer programs, methods, or systems. Details of one or more embodiments of the invention are set forth in the accompanying drawings and in the description below. Other features, objects, and advantages of the invention will be apparent from the description, the drawings, and the claims.","Like reference numbers and designations in the various drawings indicate like elements.","Overview of UI Patterns",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1","b":["100","125","125","125","135"],"i":["a","b","c"]},"A more constrained and structured approach to developing user interfaces is to build them using user interface patterns. A UI pattern (sometimes referred to simply as a pattern) is a configurable, reusable user interface unit designed to let users accomplish a specific but generically-defined task, such as searching for business objects, and editing the objects that are retrieved. Generally, each UI pattern has a specific semantic meaning and defined interaction behavior. In one implementation, each UI pattern includes a predefined arrangement of UI elements. Using UI patterns promotes uniform design throughout an application or group of applications because similar tasks are represented and handled in the same manner. For example, a user can always search in the same way, whether searching for a sales order, a business partner, or a product.","UI patterns can be defined at various levels, and can be nested within each other, thus creating hierarchies of patterns. At the top level of the hierarchy, a pattern can act as a \u201cfloor plan\u201d for a user interface that is designed to help end-users complete a specific business process. The floor plan defines the user interface by specifying an overall screen layout for the user interface and managing and orchestrating any nested patterns.","One example of an important business process is working with business documents. A business document (e.g., a sales order or an invoice) is a high-level business object that can contain references to other business objects (e.g., objects corresponding to the items in a sales order and to the customer that placed the sales order). The process of working with business documents typically involves finding an existing business document or creating a new business document, and then displaying and editing the document. To help a user accomplish these tasks, an application should include a user interface that assists the user in locating the business document to be edited, and then presents the logical parts of the business document (e.g., the referenced objects that contain the customer data and the sales order items) in a clear and structured manner. The user interface should display the relevant data in an appropriate format for the given context (e.g., in a table, a form, or a chart). The user interface should also provide input help where applicable, and supply application documentation if needed. After the user has finished editing the business document (including objects referenced by the document), the user interface should also help the user carry out post-editing tasks, such as printing out the business document, and performing document lifecycle actions (e.g., saving, deleting, creating, or updating).","An example floor plan for such a user interface can specify that an application screen is to be divided into three sections, with a top section for searching for and selecting business objects, a middle section for showing the details of an object selected in the top section, and a bottom section for showing the details of a sub-object of the object in the middle section.","More detailed, lower-level patterns can be used for each of the sections specified in a floor plan. For example, an object identification pattern (OIP) can be used for the top section in the floor plan specified above. An OIP pattern (an example of which is provided below), can specify, for instance, that a section of the screen is to include a search bar with various text entry fields and buttons at the top, and an area below the search bar where content (i.e., the content returned as a result of a search) is to be displayed.","This process can continue with the definition and hierarchical nesting of even lower-level patterns. For example, the OIP pattern above can specify that the content display area is to include a table control for displaying the results of a search. The table control can be a complex control that lets users perform tasks such as selecting and sorting rows in the table, and editing entries directly in the table. In this scenario, the table control itself can be thought of as a low-level pattern.","The user interface  shown in  illustrates an example of a pattern-based user interface. The user interface  has a floor plan that includes an object identification pattern (OIP)  and two object data patterns (ODPs)  and . As described below, object identification pattern  and object data patterns  and  are made up of embedded lower-level patterns, such as a data view, a form pane, a list pane, or a chart pane. Each embedded pattern can include further embedded patterns, including, for example, tool bars, tables, tab strips, and other UI pattern elements.","Object identification pattern  is a pattern that provides an interface for searching for objects (using zero or more selected criteria), and for displaying objects found to meet those criteria. Like the floor plan pattern, OIP  is itself a pattern with several embedded elements. Object identification pattern  includes a title bar , a search bar , a tool bar , and a content area .","Title bar  orients the user. Search bar  enables the user to enter zero or more search criteria to locate objects of interest. For example, search bar  includes a drop down element that lists the fields for which the user can enter a search term. Drop down element illustrated in  shows that the user has selected the field \u201cStatus\u201d for searching. Search bar  also includes a text box element that allows a user to enter a search term to identify the objects of interest. Text box element illustrated in  shows that the user has entered \u201cOpen\u201d as the value to find in the \u201cStatus\u201d field. Search bar  also includes a \u201cGo\u201d button element that initiates the search based on user input in elements and . With the word \u201cGet\u201d located in front of drop down element , search bar  reads \u201cGet Status Open Go\u201d, which provides a reusable and intuitively understandable mechanism for initiating user searches.","Search bar  also includes an \u201cAdvanced\u201d button element that allows a user to initiate an advanced search. Upon pushing button , a form pane is rendered between search bar  and tool bar . The form pane can include, for example, each of the fields that are in drop down element , and a text box besides each field. Thus, the user can enter search terms for multiple fields to create more focused searches, thereby limiting the number of objects that appear in content area .","Tool bar  provides functions that the user can perform on the objects displayed in the content area , such as create, save, and add to and delete from the user's list of favorite objects. Tool bar  also includes a toggle control that allows a user to toggle the layout of content area  between different types of panes that provide different representations of the objects retrieved by a search. For example, a list pane displays a tabular representation of the objects (as illustrated in ). A form pane displays the object that is currently selected, with each field in the object having a control (e.g., a text box, a pull down menu, or a check box) to enable a user to change data associated with that field. As another example, a chart pane can display a graphical representation of the retrieved data. Panes can be developed to meet specific needs, and can be integrated as low-level patterns into high-level patterns such as OIPs and ODPs.","As indicated above, content area  displays those objects that meet the search criteria specified by the user. Selecting an object in content area  determines what is displayed in object data pattern (ODP) . ODP  is a pattern that displays detail data associated with the selected object from content area . ODP  includes a tab bar , a tool bar , and a content area . Tab bar  selects the type of data that is displayed in content area .  depicts the \u201cProducts\u201d tab as having been selected, so the data in content area  corresponds to product data (e.g., a list of products with item numbers, product descriptions, quantities, and the like) associated with the object selected in content area . Tool bar  includes a toggle button that allows a user to toggle the layout of content area  between a list pane (as currently illustrated in ) and another type of pane (e.g., a form pane or a chart pane).","Selecting an object in content area  determines what is displayed in object data pattern (ODP) . ODP  is a pattern that displays detail data associated with the selected object from content area . ODP  includes a tab bar  and a content area . Tab bar  selects the type of data that is displayed in content area .  depicts the \u201cItem Detail\u201d tab as selected, so the data in content area  corresponds to item detail data (e.g., a form pane with item details such as product description, quantity, net value, status, and the like) associated with the object selected in content area .","As an example of a different floor plan, ODP  can be replaced with a guided data entry pattern (GDP). A GDP is a pattern that guides the user through a sequence of operations in a task. A GDP can contain a operation bar and a data entry area, similar to tab strip  and content area  of ODP . The operation bar of the GDP however, represents the operations of the guided process. For example, using tab strip  for illustration, the \u201cItem Detail\u201d tab would be a \u201cStep 1\u201d tab, the \u201cProduct Information\u201d tab would be a \u201cStep 2\u201d tab and so on. In execution, the GDP would start on the \u201cStep 1\u201d tab and display in the data entry area the fields that the user must enter for the first operation of the process. When the user clicks on the \u201cStep 2\u201d tab, the data entry area would change for the second operation of the process. In one implementation of a GDP, the user is not permitted to perform operations out of sequence (e.g., to go from the \u201cStep 1\u201d tab to the \u201cStep 3\u201d tab), or to proceed to the next operation until the current operation is completed (e.g., the user is not allowed to select a subsequent tab or enter data for a subsequent tab until data entry for the current tab is complete). In another implementation, whether or not the user is allowed to perform operations out of sequence is left as a choice for the application developer to specify as part of a configuration for a GDP.","The UI patterns described above and in the remainder of this application (e.g., OIPs, ODPs, and GDPs) are meant to serve only as illustrative, concrete examples of patterns. Patterns can be created to let users accomplish any generically-defined task, and the concepts and techniques described in this application apply to and can be used with all such patterns, and are not to be restricted to the example patterns discussed herein.","Configuring UI Patterns","User interface  of  illustrates a particular application that is based on the patterns described above. Such an application will be referred to as a pattern-based application, a pattern application, or simply an application. As explained above, UI patterns are reusable user interface units designed for generic tasks\u2014for example, an OIP pattern is designed for the task of searching for and selecting business objects stored in a back-end system (e.g., a database). In order to create a concrete user interface (e.g., user interface  with OIP ), UI patterns need to be configured.  illustrates an example in which a Ul pattern  is configured (shown using arrows  and ) to create two UI applications  and . Configuration one  is used to create application one , and configuration two  is used to create application two .","Configuration is the process through which a UI pattern is developed into an actual user interface (or portion thereof) for an actual application. For illustrative purposes, this might be compared to instantiating an object of a specified class\u2014the UI pattern (comparable to a class) specifies the general properties of a portion of a user interface, and a configured pattern (comparable to an instantiated object) specifies the actual properties of the portion of the user interface for an actual application. UI pattern  represents the general properties of the UI portion\u2014for example, that a table is included in that UI portion, and that the location of the table is under a title bar. Configuration one  represents the process of specifying the specifics of the UI portion (for example, the specific columns that will be included in the table when the table is rendered), so as to create an application (for example, application one ) that displays a UI with a table under the title bar with specific columns defined by configuration one . Similarly, application two  displays a table, but with specific columns as defined by configuration two .","A configuration can also specify what back-end systems and data are to be used for a pattern. For example, configuration one  can specify a particular back-end system (e.g., a local or remote database system) and a particular service to use to access the data on that back-end system that is to be displayed in the table in the UI pattern . Examples of services that can be used to access a host system include web services, Enterprise Java Beans (EJBs), Business Application Programming Interfaces (BAPIs) developed by SAP AG of Walldorf (Baden), Germany (SAP), and other business logic services.","As another example of a configuration, an OIP might specify that a user interface is to include a search bar at the top of the interface and a content area below the search bar. The search bar is to include a drop down box for selecting a search field, a text box for entering a query string, and a \u201cGo\u201d button for executing searches. Configuring such a pattern is the process of providing specifics for the pattern for an actual application. For example, to configure the OIP pattern, an application developer can specify the search fields to be included in the drop down box, the query to run when the \u201cGo\u201d button is pressed, the back-end system in which to run the query (i.e., the system where the actual data is located), and the columns from the returned results to display in the content area.","In some implementations, a UI pattern can have a number of predefined layouts (e.g., a grid layout and a flow layout), and the application developer can decide which of the available layouts to use as part of the configuration process. Moreover, each layout can be further configurable, providing the application developer with further configuration options (e.g., an option to create groupings of fields or other elements). In yet other implementations, a pattern can be defined to have a fully configurable layout, giving the application developer complete freedom to modify the arrangement of the elements in the pattern (e.g., by using a graphical configuration tool to specify screen positions for each element in the patter).","Thus, the degree to which each UI pattern is configurable can vary. For example, the degree to which the arrangement of elements in a pattern can be configured can vary across a spectrum\u2014for some patterns, the arrangement of UI elements can be fully predefined, leaving no configuration options for the application developer; for some patterns, the application developer can be given an option to choose between a handful of predefined arrangements; and for other patterns, the application developer can be given full freedom to define a custom arrangement of elements.","Other pattern properties can also be partially or fully configurable. For example, a developer can be given no options or a few options regarding the actions to be performed by a UI element in a pattern. Or the developer can be allowed to define and associate a custom action with an element in a pattern.","As can be seen from the prior discussion, the term \u201cconfiguration\u201d can be used in multiple ways. First, \u201cconfiguration\u201d is the process by which a pattern is developed into a concrete user interface (or portion thereof) for a concrete application. A \u201cconfiguration\u201d also refers to the data that is produced as a result of the configuration process (i.e., it is the set of data that defines a concrete user interface based on a pattern). Finally, \u201cconfiguration\u201d can also be used to refer to the set of options provided during the configuration process. As used in this manner, a selected option in a configuration produces a defined item of configuration data.","The use of patterns to develop applications creates two potential levels of re-use. First of all, patterns serve as re-usable building blocks for building user interfaces. For example, an OIP can be used to create two different user interfaces\u2014a first configuration can define a user interface for searching for business objects related to customers (customer objects), and a second configuration can define a second user interface for searching for business objects related to inventory (inventory objects).","In addition, configurations can be reused, meaning that the configurations themselves can serve as re-usable building blocks for building applications. Thus, in the example above, the OIP configuration that defines a user interface for searching for customer objects can be integrated and used in two different applications (e.g., a customer relationship management application and a billing application).","The configuration of a UI pattern can be done either manually (e.g., with a text editor), or through the use of a configuration application. A configuration application facilitates the process of configuring a UI pattern. In one implementation, the configuration application displays multiple configuration options for the application developer to select. As the selections are made, the configuration application displays a WYSIWYG representation of the resulting configured user interface, thereby allowing the application developer to preview his selections and make any necessary modifications. The configuration options can include lists of the available back-end systems, queries, query fields, and query results.","Once the application developer has finished selecting the configuration options, the selections are stored as configuration data for the UI pattern. The configuration data can include associations between one or more of the UI elements in the UI pattern and one or more of the back-end entities to be used with the UI pattern. As an example, configuration data for the OIP described above can include a specification of the back-end system to be used, the query to be run in the back-end system, the query fields to show in the drop down box, and the result fields to display in the content area.","The configuration data can also include customization data for one or more of the UI elements in the UI pattern. The customization data can specify local changes to the business objects associated with the UI elements. For example, a drop-down menu item might be associated with a back-end query field called \u201cUID\u201d. The customization data may specify that the \u201cUID\u201d field should be displayed using a more user-friendly label, for example, \u201creference number\u201d. Such a customization applies only to the particular UI element in the particular application being configured, and does not affect how the business object is represented in the back-end system or how the business object is represented by other UI elements in other applications that use the same UI pattern.","The configuration data can be stored in a configuration repository. In one implementation, the configuration data is stored in one or more files. Such files can be nested to reflect a hierarchical arrangement of further UI patterns. The configuration data can then be read by a pattern component, which generates the implementation of the actual user interface for the application based on the configuration data.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 3","b":["305","310","315","320","325","305","315","325","305","325"]},"The generation of a pattern-based application based on a configuration can be done either immediately after the configuration has been completed, or at a subsequent point in time, such as when the pattern-based application is executed.","For example, in the scenario described above where a configuration application produces configuration data for a pattern component, the pattern component can read the configuration data and generate the pattern-based application immediately after the configuration data has been produced. This is referred to as a design-time generation of a pattern-based application, since the generation occurs when the configuration is produced (i.e., when the configured pattern or application is designed).","Alternatively, the pattern component can read the configuration data and generate the implementation of the corresponding pattern-based application when the pattern-based application is executed by an end-user. This is referred to as a run-time or on-demand generation of a pattern-based application. In one implementation, the choice of whether the implementation of a pattern should be generated at design time or at run time is left as an option for the application developer. The use of configuration data to generate an implementation of a pattern (e.g., a configured pattern component) is described in more detail below.","In the illustrated implementation, the configuration application  includes a graphical configuration tool . Graphical configuration tool  can allow a non-technical user, such as an application developer, to visually configure a pattern. The graphical configuration tool can provide an intuitive way in which to configure an application. An example of a graphical configuration tool is discussed in more detail below.","Application Development Framework",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 5","b":["500","500","510","510"]},"To enable applications to execute on different platform layers , framework  includes a platform independent component development and run-time layer . In this environment, applications can be developed using modules known as components. Components can be stored in a component repository and reused\u2014that is, each component can have more than one instance, where the component instances are used in multiple applications, or multiple times in the same application. Components can be embedded (nested) within other components, and they can have zero or more visual representations. In one implementation, each component provides three separate interfaces\u2014a programming interface, a data binding interface, and a visual interface. The programming interface can be used by an embedding entity (a component embedder\u2014e.g., a higher level component, or an application) to interact with the embedded component. The visual interface can be used by a component embedder to access and use the visual representations of the embedded component (for example, to form the component embedder's own visual representation). The data binding interface can be used by the component embedder to exchange data with the embedded component.","An example platform independent component development and runtime layer  is the Web Dynpro environment manufactured by SAP. The Web Dynpro environment is based on the Web Dynpro programming model, which conforms to the model-view-controller programming paradigm described below with respect to . In one implementation, platform independent layer  provides a framework for defining application components in a declarative and\/or graphical manner, without needing to program the components for a particular platform layer . Platform independent layer  also provides interfaces, tools, services, and other features to enable the application components to execute on a specific platform layer . In another implementation, platform independent layer  additionally provides functionality to enable application components to render user interfaces on a number of different clients, with platform independent layer  performing the appropriate transformations for specific clients.","Building on top of platform independent layer , framework  includes a pattern layer  with one or more generic UI patterns. Each UI pattern is generic because it defines a particular pattern (e.g., a floor plan pattern, an OIP, an ODP, a GDP, and the like), but not the specific content that is included for a specific application that uses that pattern. The specific content for a specific application is created by configuring the pattern as described above.","In one implementation, each UI pattern includes a configuration application and a pattern component. The configuration application and the pattern component for each UI pattern can be applications that are developed and executed on the platform independent layer  shown in . Using this approach, the configuration application and the pattern component for each UI pattern can take advantage of the features offered by platform independent layer , including, for example, platform independence, client independence, and various functionality offered by platform independent layer , such as automatic input help and validation based on declared data types.","In one implementation, each UI pattern is implemented as a single Web Dynpro application , illustrated in . The single Web Dynpro application has two components, a configuration component  that performs the functionality of the configuration application, and an execution component  that performs the functionality of the pattern component. Alternatively, as illustrated in , the Web Dynpro application  can be developed using a single component  with two entry points\u2014one for configuration  and one for execution . The application  uses a different entry point depending on whether it is being used for configuration or execution of the pattern.","Yet another alternative, illustrated in , is for each UI pattern to be implemented as two separate Web Dynpro applications\u2014one for configuration  and one for execution . Each of the two Web Dynpro applications is developed using a separate component (i.e., the configuration application  includes a configuration component, and the execution application  includes a pattern or execution component).","Referring back to , the top layer, application layer , contains the actual applications to be run by end-users. In this framework, an end-user application is made up of one or more configured UI patterns. In an implementation where each UI pattern includes a pattern component, an end-user application is made up of one or more configured pattern components (e.g., pattern components and their corresponding configurations). An end-user application can be stored in a configuration repository in the form of configuration data and references to the associated pattern components.","Framework  thus enables application developers to develop applications by configuring generic pattern components into components for specific applications (e.g., components that display the actual fields illustrated in UI ). In one implementation, as described in more detail below, configuration data (e.g., data in a configuration repository or in one or more configuration files) is used to configure a generic pattern component into a component for a specific application. The configuration data can be defined through the use of declarative and\/or graphical tools that are included, for example, in a configuration application, thus dramatically simplifying the task of developing applications. If, for example, the configuration application has access to a meta data repository that specifies the fields available for a particular back-end system for which an application is being developed, the application developer can develop an application (e.g., create a configuration) by simply choosing the fields in the meta data repository to be included (e.g., displayed) in the application.","Framework  can be thought of as creating a role-based programming methodology, where layers , , , and  correspond to different roles for different developers. Framework  is illustrated as a triangle to represent graphically that complexity and difficulty decrease for each role as one moves from the base layer to the top layer. Thus, a developer who is responsible for building and maintaining the platform independent layer  has the most complex and difficult job, and must be familiar with the programming languages, tools, and other intricacies of one or more platform layers . A developer who is responsible for building and maintaining UI patterns (e.g., configuration applications and pattern components) has a simpler job, as he or she can take advantage of the features and functionality offered by the platform independent layer , as described above. Finally an application developer (a developer who is responsible for developing end-user applications) has the least complex job, as he or she can create applications simply by configuring predefined UI patterns. Where the configuration process is as simple as using a configuration application to choose the desired fields from a set of available fields, the application developer may not need to have any advanced programming skills.","Example OIP Pattern Component","As described above, an application can be built by configuring a generic pattern component.  illustrates an example of a generic pattern component  for an OIP. Component  follows a model-view-controller (MVC) paradigm, and as such includes a model , a view , and a controller . In the MVC paradigm, models generally implement application logic. Each model can have multiple views, where each view displays information about the model to a user. A controller of the application receives events, for example, raised by a user interacting with a view to manipulate the model. A model can have multiple controllers. Controllers can relate to zero or more views. Controllers can also relate to an application in general, or to one or more application parts or components. Models and controllers typically include application code. When changes occur in a model, the model can update its views. Data binding can be used for data transport between a view and its model or controller. For example, a table view can be defined to display data from a corresponding table that is stored in a model or controller. The table view is thus bound to the table, indicating that the table is to be used as the data source for the table view. As another example, the table view can be replaced by a further view, such as a linked list, that binds against the same table. In this case, the further view can display the table data without requiring any changes to be made to the controller or the model.","As explained earlier, an OIP can provide an interface to search for and select objects. Accordingly, the model  in the OIP component  includes a query  (e.g., a query class). Because an OIP is a generic UI pattern, query  represents a generic query. In one implementation, query  includes an input structure  of n parameters allowed for queries, and a result structure  of m fields returned for each object meeting the search criteria.","View  of component  defines a user interface with a generic arrangement of UI elements for performing searches. View  includes a title bar  that displays a caption to orient the user. View  also includes a search bar with a drop down element  in which the user can select from the available input parameters selected from the input structure . The search bar also includes a text entry box  in which the user can enter a match criterion for a search, and a \u201cGo\u201d button  to initiate the search.","Controller  of component  binds the UI elements of view  (e.g., UI elements , , and ) to data elements in a storage area (referred to as a context) that is associated with the controller . The context is a structured storage area with hierarchically arranged nodes and attributes. The context associated with the controller  includes a query node  that includes an input structure . The input structure  in the controller context corresponds to the input structure  in the model , and can include up to the n parameters included in the input structure .","When the OIP pattern component  executes, the component receives configuration data (e.g., from a configuration repository or one or more configuration files), and, based on that configuration data, generates child elements for the input structure context node , and binds those elements to elements in the view  and the model .","As an example, consider an application that allows end-users to search for and retrieve information about a company's customers. To create such an application, a developer can configure an OIP pattern to use a specific back-end system with customer information (e.g., a system represented by back-end specific model ). Back-end specific model  indicates that the back-end system in this example can execute a query called customer query  that takes up to three input parameters (a customer number, customer name, and customer city, as specified in the customer query input structure ), and returns records with six fields (the six fields specified in the customer result structure ). In an example configuration, an application developer might specify that users should be able to run searches based on any of the three available input parameters (i.e., that all three of the input parameters in the customer query input structure  should be listed in the drop down element ). The developer might further specify that the content display area below the search bar in view  should display all six of the available return fields listed in customer result structure .","The preceding configuration can be specified as configuration data, an example of which is shown as XML data  in . The XML configuration data , which is discussed in more detail below, can be used to generate the execution-related entities in the pattern component  that are required to implement the specified configuration for the OIP pattern. For example, in an implementation in which applications (including pattern components) are structured according to the Web Dynpro programming model, several types of entities can be generated based on the configuration data, including UI elements (e.g., controls in views), data structures (e.g., context entities such as nodes and attributes), and bindings (e.g., context bindings, which serve to couple UI elements and context entities, and model bindings, which serve to couple context entities and model entities).","As a specific example, the XML configuration data  includes a first section of data  that indicates that the pattern component  is to execute searches using a query object named \u201cCustomerQuery\u201d in a back-end service module named \u201cCustomer.\u201d A service module is a grouping of functionality in a back-end system; the functionality can include business functionality that defines business objects or other entities (e.g., customers), and that provides access to such entities (e.g., through query objects such as CustomerQuery). In this example, the CustomerQuery query object is represented by the customer query object  in the model .","As discussed above, the application developer has chosen a configuration in which end-users are to be able to execute searches using any of the three available input parameters in the customer query object . This selection of input parameters is indicated in a second section of configuration data , which lists all three parameters (Number, Name, and City) from the input structure  in the customer query object .","In particular, the Number parameter  in the input structure  is listed in the section of configuration data . The Number parameter  represents customer numbers, and its selection as an available search parameter means that application end-users are to be able to search for customers by providing a customer number (as well as possible additional parameters). To enable such searches, a number of execution-related entities are added to the pattern component , including a Number UI element  and a Number context attribute .","The Number UI element  is added to the view  so that an end-user can type in a customer number in that UI element. Though not shown in the preview of the view  in , the UI element  can be displayed and enabled in the view , for example, when an end-user selects an \u201cadvanced search\u201d option that exposes a form with multiple fields in which the end-user can enter search criteria. Based on the configuration data , the UI element  is given the label \u201cCustomer No.\u201d Moreover, because the configuration data  indicates that string-type input is to be provided for the Number input parameter, the UI element  is set to be a control that is operable to receive such input (e.g., a text box).","The Number attribute  in the context associated with the controller  can be used by the pattern component  to store input data provided by an end-user in the UI element . As with the type of the Number UI element , the type of the Number attribute  can be set based on the data type indicated in the configuration data  (in this case, a \u201cstring\u201d type). The coupling between the Number UI element  and the Number attribute  can be enabled by binding the Number UI element  and the Number attribute . Bindings between other types of entities can also be created\u2014for example, a context attribute (e.g., the Number attribute ) can be bound to a model entity (e.g., the Number parameter  in the input structure  of the query object ). Such a binding, known as a model binding, generally serves to couple an item with a model entity that represents an abstraction of business logic in a back-end system.","Similar entities (e.g., UI elements, data structure elements, and bindings) can be generated for the other two input parameters (Name and City) specified in the section of configuration data . In addition, many other types of entities can be generated based on the configuration data specified by an application developer. Such entities can be used by a pattern component for purposes of navigation and for other Ul-related issues. For example, various entities can be generated for purposes of implementing advanced UI functionality, such as input help and input validation.","The use of configuration data to generate execution-related entities for a pattern component can be carried out at various times, including, for example, in a pre-execution operation (e.g., after the configuration data has been specified), when the pattern component or application is loaded into a runtime system or otherwise launched, or during execution of the pattern component or application. In one implementation, the entities are generated on an on-demand basis as they are needed. For instance, in the preceding example, the Number UI element  can be generated when the view  is first displayed, or even when the Number UI element  first becomes visible (e.g., when the end-user exposes an \u201cadvanced search\u201d form in the view ).","Example Configuration Data","To configure a UI pattern (e.g., as in the example configuration described above), a developer can associate the pattern with a specific back-end system and the entities (e.g., queries, input structure, input parameters, input fields, result structure, and\/or result fields) available within that back-end system. As described above, such an association can be specified as configuration data stored in a configuration repository or in one or more configuration files. The application developer can use a configuration application that assists him in selecting a back-end system, determining which parameters and other entities exist in the back-end system, selecting an appropriate set of those entities for an application, and specifying all such selections as formatted configuration data (e.g., in a formatted configuration file).","In one implementation, the configuration application uses an interface layer that provides a generic interface to back-end systems. An example of such an interface layer is the interface layer in the Enterprise Service Framework (ESF) developed by SAP. The interface layer includes a repository with meta data corresponding to the back-end data.","Using the example in , the back-end specific model  can be stored as meta data in the meta data repository of an interface layer. The application developer can determine from this meta data that the customer query  (defined by the back-end system) is one used to find customer objects. The meta data repository further includes the parameters  of the input to the query, namely a number, a name, and a city. The configuration application enables the application developer to select any combination of input parameters  that is to be presented in drop down element  when view  is rendered. The application developer can also select which of the fields in result structure  are to be displayed when result objects are returned from the back-end system in response to a query.","An example of configuration data that defines the search portion of a specific application (i.e., that specifies a configuration for a search pattern) is shown below:",{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d ?>"},{"entry":"<SearchView Caption=\u201cCustomer Search\u201d>"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Query Service Module=\u201cCustomer\u201d Query=\u201cCustomerQuery\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<QueryParameters>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Number Label=\u201cCustomer No.\u201d Type=\u201cstring\u201d\/>"]},{"entry":[{},"<Name Label=\u201cLast Name\u201d Type=\u201cstring\u201d\/>"]},{"entry":[{},"<City Label=\u201cCity\u201d Type=\u201cstring\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/QueryParameters>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Query>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/Search View>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In this example, the configuration data is represented using XML. Taking the data in order, the first line defines the version and encoding of the XML file. The next line defines the caption that is inserted into the generic caption text  of pattern view . As indicated, the application associated with this configuration displays \u201cCustomer Search\u201d in the title bar to orient the user that he or she is searching for customers. The next line specifies that the query to be executed for this application is the \u201cCustomerQuery\u201d query within the \u201cCustomer\u201d service module in the back-end system.","The next five lines specify the input parameters selected by the application developer to be included in drop down element . As indicated in the data, the application developer has selected all three of the available input parameters , namely \u201cNumber\u201d, \u201cName\u201d, and \u201cCity\u201d. Further, the application developer has defined more user-friendly labels for each of the parameters. The configuration data also defines the data type for each of the parameters, so view  can provide an appropriate control for each selected field. For example, in an advanced search view, a checkbox can be provided for a Boolean type input parameter, rather than the text entry box that is typically used for string type input parameters.","Although an application developer can generate configuration data directly, the use of a configuration application can advantageously enforce the required schema for the configuration data, so as to ensure that the configuration data is successfully merged with a generic pattern component to generate a specific application.",{"@attributes":{"id":"p-0110","num":"0109"},"figref":"FIG. 7","b":["712","717","715","725","717","710"]},"To create a specific application  for a specific type of business process, an application developer  can configure a floor plan pattern that corresponds to that type of business process (as well as possibly one or more nested patterns). In the implementation shown in , the process of configuring a pattern involves the use of a configuration application  to create configuration data  for a corresponding pattern component . The configuration application  can be designed to be very simple to use\u2014e.g., it can be designed to let an application developer configure a pattern by simply choosing among multiple alternatives for each required piece of configuration data. Accordingly, application developers need not have programming skills\u2014rather, they can be non-technical people, such as program managers or business executives who are experts in a particular application or business area.","Multiple application development scenarios are possible. For example, patterns can be delivered by a pattern provider to a customer either with or without corresponding configurations. In the former scenario, an application developer on the pattern provider side configures a pattern and delivers a fully-configured pattern-based application  that is ready to be used by an application end-user  on the customer side. In the latter scenario, the pattern provider delivers only the patterns (e.g., the configuration applications and the pattern components) to the customer, and an application developer on the customer side creates a pattern application  by configuring one or more of the patterns. As another possible scenario, an application developer on the pattern provider side can create and deliver pre-configured applications, which can either be used directly by an end-user, or further adapted by an application developer on the customer side (e.g., by modifying the delivered configurations) in order to meet the specific needs of the customer.","Graphical Configuration Tool","As mentioned previously, a graphical configuration tool can be used to assist a user such as an application developer in configuring an application. For example, a graphical configuration tool can present an application developer with an intuitive interface for configuring a pattern. The interface can include a graphic representation of the pattern being configured. The graphic representation of the pattern can include graphic objects corresponding to the pattern elements in the pattern (e.g., the user interface elements, or other patterns nested in the pattern).","As an example, an OIP can be defined to include multiple pattern elements, such as a search form (e.g., the search bar  described in conjunction with ), a query in a back-end system that is executed using the search criteria specified by an end-user in the search form, a list pane that displays the results retrieved from the execution of the query using a list or table format, and a form pane that displays the details of a selected entry in the list pane. Each of the above pattern elements can be represented as a graphic object, and the graphic objects can be connected in a way that intuitively represents the relationship between the pattern elements in the OIP. For example, a graphic object that represents the search form can be connected with an arrow to an inbound connector in a graphic object that represents the query. Similarly, an arrow from the outbound connector of the graphic object that represents the query can be connected to a graphic object that represents the list view. Finally, the graphic object that represents the list view can be connected in a similar manner to a graphic object that represents the form view.","In a graphical configuration tool that represents patterns as described above, an application developer can indicate interest in an object (e.g., by clicking on the object), and thereby receive information about the object. For example, if an application developer clicks on a graphic object that corresponds to the search form, the graphical configuration tool can display the parameters that have been selected for searching.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 8","b":["800","810","840","810","812","812","820","822","824","826","828"]},"Data input graphic object  represents the input of user data for an application. The data can indicate variables for one or more functions that can be performed on a set of data. In the example, the functions include searching for data for OIP . Searching for data can entail using parameters (e.g., fields) for searching and a search range (e.g., a variable). Back-end entity graphic object  represents the back-end entity and\/or functions for the data manipulation (e.g., search). Data output graphic object  and data output graphic object  represent the format for displaying the results of the data manipulation. In this example, data output graphic object  represents a list of data, and data output graphic object  represents a form for data. In operation, an end-user can switch between data output graphic object  and data output graphic objects  by activating a toggling icon.","Data input graphic object , back-end entity graphic object , data output graphic object , and\/or data output graphic object  can provide additional information about their functions and\/or parameters to a user. To accomplish this, the information can be presented when a user indicates interest in one of the graphic objects (e.g., by clicking on the graphic object). The additional information can include selected parameters and user interface elements for the associated pattern components.","In one mode of operation, data input graphic object , back-end entity graphic object , data output graphic object , and data output graphic object  are be presented to a user in a generic form. That is, the specific content for an application (e.g., search parameters and result fields) are unspecified. For the illustrated implementation, when a user specifies something about the application, the search parameters and the result fields associated with that query can be determined. This can, for example, occur when a user specifies data about a back-end entity for the OIP. The back-end entity data can include system, module, and\/or query. Once data about the back-end entity is known, it may be possible for the graphical configuration tool to determine an appropriate query, and, hence, search parameters and results.","Determining appropriate search parameters and results can be accomplished by interrogating a meta data repository that specifies the fields available for a particular back-end system for which the application is being developed. The configuration information can be expressed in an XML format, which can be used to generate the execution-related entities in the pattern component that are required to implement the specified configuration for OIP .","In particular implementations, an automated selection of configuration information for OIP  can be performed for the user. For example, when a user configures OIP  by dropping a query onto storyboard area , the search parameters and result fields can be preselected by default. The user can then execute OIP  without having to make further selections. The user can also specify which, if any, parameters should not be searched. Also, the available types of output data can automatically be placed in data output graphic object  and data output graphic object  for the user. Again, if he so desires, the user can specify which, if any, output data should not be displayed.","OIP  also includes a data port tag . Data port tag  can represent the data presented in data output graphic object  and data output graphic object  and data related to the presented data. Related data can, for example, be other data from a table that contains the presented data. Relations can be modeled in the back-end system, and meta data regarding the relations can be retrieved. Associating data port tag  with an ODP (e.g., by dragging and dropping the tag) binds the data to the ODP and can allow the data represented by the tag to be displayed in the ODP.","Second portion  includes data for OIP . Second section  includes a task section  and a data section . Task section  allows a user to switch between different tasks for OIP . For example, a user can select a logical element task to see which logical elements can be added to OIP  (e.g., a chart), or a user can select a properties task to see fields of a selected graphic object. Data section  includes data for a task selected in task section  and\/or OIP .","As illustrated, data section  includes a drop-down box  containing back-end systems, a drop-down box  containing back-end modules associated with the back-end system shown in drop-down box , and a scroll box  containing queries associated with the module shown in drop-down box . Drop-down boxes and scroll boxes are one example of selection elements. In particular implementations, these boxes can be automatically generated for the user so that he can select the information therein and have it applied to OIP .",{"@attributes":{"id":"p-0126","num":"0125"},"figref":"FIG. 9","b":["900","910","940","910","912","912","920","922","924","926","922","920","924","926","924","926","920","820"]},"Back-end entity graphic object , data output graphic objects , and data output graphic objects  can provide further information about their functions and parameters to a user. To accomplish this, the information can be presented when a user selects (e.g., clicks on) one of the graphic objects. Information regarding the graphic objects can then be displayed in user interface . The information can include the fields selected for the associated pattern component and the user interface elements.","The illustrated implementation has three data output graphic objects . Through these graphic objects, different data can be presented to a user. In particular, each of the graphic objects  can correspond to a tab in the actual presentation of ODP . Thus, the presentation of the ODP can have a \u201cFlight Meal\u201d tab, a \u201cFlight Booking\u201d tab, and a \u201cFlight Key\u201d tab. The tabs can represent the data from the OIP or related data. By selecting different tabs, the user is presented with different information.","Data output graphic objects  can be similarly presented to a user. Also, a user can switch between data output graphic objects  and data output graphic objects  by activating a toggling icon.","In one mode of operation, back-end entity graphic object , data output graphic objects , and data output graphic objects  would be presented to a user in a generic form (e.g., with the available and result parameters unspecified). Then, when the user specified something about the applications, the output data can be determined. For example, if the user specified the back-end entity that was to supply the data, the available output data can be determined. Additionally, if the user associated an data port tag with the ODP, the available output data can be determined.","In particular implementations, an automated selection of configuration information for ODP  can be performed for the user. For example, if a user configures the ODP by dragging a data port tag of an OIP and dropping it on storyboard area , or on the floor plan containing the ODP, the ODP can be created with data fields preselected. The number of actions required from the user to make an executable pattern can therefore be reduced. The user can also specify which, if any, related data shown be shown and fields of data that should be shown.","ODP  also includes data port tags . Data port tags  represent additional data associated with the data presented in data output graphic objects . Associating one of data port tags  with another ODP (e.g., by dragging and dropping it) can allow the data represented by the tag to be displayed in that ODP.","Second portion  includes data for ODP . Second section  includes a task section  and a data section . Task section  allows a user to switch between different tasks for ODP . For example, a user can select a logical element task to see which logical elements can be added to ODP  (e.g., a chart), or a user can select a properties task to see fields of a selected graphic object. Data section  includes data for a task selected in task section  and\/or ODP .","As illustrated, data section  includes a scroll box  containing data fields for the back-end system and a scroll box  containing properties of the data fields in scroll box . In particular implementations, these boxes can be automatically generated for the user so that he can select the information therein and have it applied to ODP .",{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 10","b":["1000","1010","1040","1010","1012","1012","1020","1020","1022","1024","1026","1020","820","920"]},"OIP graphic object  can serve as an anchor point for floor plan pattern . That is, based on the output data specified in OIP graphic object , the data for ODP graphic object  can be determined. ODP graphic object , in turn, can serve as an anchor point for ODP graphic objects . That is, based on the output data specified in ODP graphic object , the data for ODP graphic objects  can be determined.","In one mode of operation, OIP graphic object , ODP graphic object , and ODP graphic objects  can be presented to a user in generic form (e.g., with the input and output parameters unspecified). Then, if a user decides to configure part of the floor plan pattern related to the OIP, he selects OIP graphic object  and is presented with a graphic representation of the OP (e.g., OIP ) that presents pattern components related to the OIP (e.g., data input graphic objects, back-end entity graphic objects, and data output graphic objects). The user can then specify configuration information (e.g., search parameters, query service modules, result lists, and result forms) for the OP. In the same way, if the user decides to configure the portion of the floor plan pattern related to one of the ODP, he selects ODP graphic object  and is presented with a graphic representation of the ODP (e.g., ODP ) that presents pattern components related to the ODP. The user can then specify configuration information for the ODP. This ability to \u201czoom in\u201d to specific pattern components of the floor plan pattern allows a user to better appreciate the layout and functions of the different pattern components and can also define for a user a set of possible logical elements and actions that the user can perform on the pattern.","A user can also receive further information about OIP graphic object , ODP graphic object , and ODP objects . To accomplish this, the information can be presented when a user selects (e.g., clicks on) one of the graphic objects.","Graphically presenting the OIP, ODP, floor plan assists a user in intuitively understanding the responsibilities of each part of a configuration. Also, it can restrict a user to those actions that are possible for configuring a pattern. Additionally, by allowing a user to \u201czoom in\/zoom out,\u201d the user is presented with a high level pattern diagram (i.e., OIP and connected to it ODP and sub-ODP pattern components).","Second portion  includes data for floor plan pattern . Second section  includes a task section  and a data section . Task section  allows a user to switch between different tasks for floor plan pattern . For example, a user can select a logical element task to see which logical elements can be added to floor plan pattern  (e.g., a chart), or a user can select a proprieties task to see fields of a selected graphic object. Data section  includes data for a task selected in task section  and\/or floor plan pattern .","As illustrated, data section  includes a drop-down box  containing back-end systems and a drop-down box  containing back-end modules associated with the back-end system shown in drop-down box . In particular implementations, these boxes can be automatically generated for the user so that he can select the information therein and have it applied to floor plan pattern .","Using a graphical configuration tool similar to the one under discussion, configuration can be accomplished in a model-based approach (i.e., the user can focus on data-model side of configuration). In operation, a user can first select a system and back-end entity (e.g., service module). The user can then select a query and drop it on the OIP diagram. From this, information about query search parameters and result fields can be retrieved and, accordingly, displayed in search form and result list and result form views. When the user creates an ODP, information about related data can be retrieved and displayed as tabs automatically, so that user can focus on selecting which related data he needs for the floor plan. When the ODP is configured, the user can continue configuration, by, for example, configuring a sub-ODP. A sub-ODP can be configured by dragging and dropping data port tags corresponding to configured related ODPs. In this configuration process, the user can focus primarily on data modeling side of floor plan configuration and receive a better overview of available data modeling cases.","A graphical configuration tool can also allow charts to be readily associated with output data and configured. For example, a user can specify (e.g., drop and drop) a chart object for a result list or a form view and select the chart type, mode, categories and series. After that, when the associated floor plan is executed, a corresponding chart with selected fields is displayed with data from the back-end system.",{"@attributes":{"id":"p-0144","num":"0143"},"figref":"FIG. 11A-B","b":["1100","900","1100"]},"In the example, a chart is being configured for data output graphic object of ODP . Thus, the data used to form the chart can include the data available in data output graphic object ","As mentioned previously, configuring a chart can be a multi-operation process. In the example, the user is guided through the process with an operation bar . For the stages in the operation, the user is allowed to indicate information in input section .","In , the user is presented with selection elements  in input section , for indicating information about the chart itself and its display. As illustrated, selection elements  are drop-down boxes. Through selection elements , the user can indicate the type of chart, the dimension of the chart, and the mode of the chart. Fewer or additional selection elements can be presented based on what the user selects in input section .","In , the user is presented with selection elements  in input section , for indicating the data to be used in the chart. As illustrated, selection elements  are scroll boxes in which the user can select the appropriate data. The data types in the scroll boxes can be generated based on the data in data output graphic object . Fewer or additional selection elements can be presented based on what the user selects in input section .","The configuration process can continue similarly to that shown in  until all of the parameters for the chart have been specified. During execution, the chart can be displayed once a user has specified that the back-end data associated with the chart is of interest.","Visually presenting information in a chart format often helps users to understand and draw conclusions from large amounts of data. Providing a way for a user to readily configure charts for the data in the list and data forms makes this data available.",{"@attributes":{"id":"p-0151","num":"0150"},"figref":["FIG. 12","FIG. 12"],"b":["1200","1200","1200"]},"OIP  includes a query area , a back-end entity area , and a result area . Query area  includes a first search area  and a second search area . First search area  and second search area  contain data input graphic objects for OIP , which, in this example, are search parameters graphic objects , , respectively. Back-end entity area  contains representations of back-end entities for the OIP, which, in this example, are query graphic objects . Result area  contains representations of data output graphic objects for the OIP, which, in this example, are data view graphic objects .","Query area  and result area  are visual areas of OIP . That is, these are the areas that an actual end user will see. These areas can be realized via states.","Query area  has three search parameters graphic objects , . Search parameters graphic object  represents a search for an employee by a component of the employee's name (e.g., first, middle, or last name). Search parameters graphic objects  represent a search for an employee by a one or more parameters. Search parameters graphic object allows a search for an employee by one or more components of the employee's name, and search parameters graphic object allows a search for an employee by one or more components of the employee's organizational unit (e.g., division, branch, or section). An application developer can also configure additional queries. In operation, search parameters graphic objects  can be displayed at the same time so that an end user can choose which query to execute.","Search parameters graphic objects  can make use of query services for a meta data interface layer. An example interface layer is the Enterprise Service Architecture (ESA) developed by SAP. The ESA includes a repository with meta data corresponding to back-end data.","Depending on the search selected by an end user, the back-end entity accessed can differ. In this example, two query graphic objects  are used. Query graphic object is linked to search parameters graphic object  and search parameters graphic object . Query graphic object is linked to search parameters graphic object . Thus, search data from search parameters graphic object  and search parameters graphic object is sent to query graphic object , and search data from search parameters graphic object is sent to query graphic object . Also, a different set of query parameter configurations can be used.","Furthermore, depending upon which search an end user selects, a different result view may be needed. In the illustrated example, data view graphic object is associated with query graphic object , and data view graphic object is associated with query graphic object . OIP  illustrates the linkage between data view graphic object and query graphic object and data view graphic object and query graphic object . Thus, the results from query graphic object are conveyed to data view graphic object , and the results from query graphic object are conveyed to data view graphic object ","OIP  also includes data port tags , which represent ports of data view graphic object and data view graphic object . Together, the ports can represent the visible interface of OIP  to an embedder, an OIP-ODP application component. The semantics in terms of Web Dynpro terminology is a component interface event (sending information to the embedder) or a method (receiving information from the embedder) with a certain signature.","Additional elements can also exist. For example, a navigational link is an extension of a data link; it not only transports data, but also executes a navigation. As another example, there can be special kinds of operators (e.g., a sort operator to sort the result set of a service using a certain criteria and a condition operator for choosing between several possible states that one can show). As a further example, an infoset can represent the data that is transported. An infoset can have a designated structure. One type of infoset is a data object in ESA. Infosets may not be visualized in the graphical configuration tool, but may be configured using property sheets. As an additional example, restrictive stereotypes can be defined by the pattern developer in order to restrict the flexibility of the runtime for the purpose of user interface standardization. Restrictive stereotypes represent a collection of constraints on a component. Restrictive stereotypes can be deactivated by a business expert in order to have a higher degree of flexibility.","While this illustration of OIP  presents a semantical picture for the business expert, it can suppress many details to keep the complexity of the operation small. These details can be implicit assumptions for the graphical configuration tool, and can be realized in the implementation of the OIP Web Dynpro component.","Some of the implicit assumptions in the illustration are that second search area  is opened by a button \u201cOpen Advanced Search\u201d displayed in first search area  and that when second search area  is selected, first search area  is deactivated, but still visible. Also, it is assumed that a close button exists in second search area , which activates first search area  again. Also, in the implementation there are at least four ports that are outgoing of the OIP components instead of the displayed two. For example, one extra port per result view is required to distinguish between the information that the result view has been opened versus the selected row in the result view being changed. Additionally, when the application is launched via an object link, OIP  displays only one business object in the dataview list. The dataview is minimized to one row. Furthermore, in general, the patterns have minimized, normal, and maximized perspectives. The semantics of this can depend on the pattern definition and is, therefore, not necessarily generic.",{"@attributes":{"id":"p-0162","num":"0161"},"figref":"FIG. 13","b":["1300","1310","1310","1312","1320","1320"]},"Pattern  includes a back-end entity graphic object  that has various output ports. One of the ports is associated with a key, which can provide a link to sibling aspects. Sibling aspects can be presented to a user for selection for data output graphic objects.","An aspect is a meta model class that represents an object (e.g., a data structure) in a back-end entity. For example, in an object oriented back-end, an aspect can represent a business object such as employee, customer, order, address, or product. In a database back-end, an aspect can represent a database row. An aspect itself can be table.","Aspects can be related and\/or siblings. Related aspects have an explicitly defined relationship. For example, a \u201ccustomer order\u201d aspect can include multiple \u201corder item\u201d aspects that describe the items included in a particular order. Thus, an explicit relationship would be defined (i.e., that a \u201ccustomer order\u201d aspect includes an aggregation of \u201corder item\u201d aspects). Aspects are siblings if they have a common key aspect (e.g., search parameter).","In operation, when a user drops a data port tag into a pattern\u2014an ODP, for example\u2014output parameters can be displayed in result list and form view. But the user can also choose not to use this aspect, but a sibling aspect. In the illustration, the sibling aspects entries are presented in a context menu . The context menu can be presented when the user drags from an output port. The sibling aspects can also be presented in any other appropriate manner.",{"@attributes":{"id":"p-0167","num":"0166"},"figref":"FIGS. 14A-E"},{"@attributes":{"id":"p-0168","num":"0167"},"figref":"FIG. 14A","b":["1400","1410","1450","1400","1412","1420","1420","1430","1430","1432","1434","1436","1438"]},"Second portion  includes a data area . Data area  presents and allows a user to specify configuration information for floor plan pattern . In , data area  includes a drop-down box  by which a user can select a back-end system for OP . The graphical configuration tool can, for example, determine the available back-end systems by querying a meta model of the back-end systems and place descriptions of them in drop-down box .",{"@attributes":{"id":"p-0170","num":"0169"},"figref":"FIG. 14B","b":["1410","1450","1400","1410","1412","1430","1420","1430","1432","1434","1436","1438"]},"Second portion , however, now presents a drop-down box  by which a user can select a module of the back-end system selected in drop-down box . A module can, for example, be a set of queries, business objects, or actions. The graphical configuration tool can, for example, determine the available modules of the selected back-end system by querying a meta model of the back-end system and place descriptions of the modules in drop-down box .",{"@attributes":{"id":"p-0172","num":"0171"},"figref":"FIG. 14C","b":["1410","1450","1400","1410","1412","1430","1420","1430","1432","1434","1436","1438"]},"Second portion , however, now presents a drop-down box  by which a user can select a query of the module selected in drop-down box . A query can, for example, be a database call. The graphical configuration tool can, for example, determine the available queries of the selected module by querying a meta model of the module and place descriptions of the available queries in drop-down box . Upon selection of a query in drop-down box , a graphic representation  of the selected query is shown in storyboard area .","At this time, the query parameters and fields can be determined for OP . This can, for example, be accomplished by querying a meta model of the selected module based on the selected query. The retrieved information is processed by the graphical configuration tool and displayed in OIP  as fields in data input graphic object , data output graphic object , and data output graphic object . A user can then select the data he needs for the pattern and perform any customization desired for the selected fields. The back-end entity can also defined by this operation, and subsequent calls to retrieve search parameters and result fields.","After configuring OIP , the user can generate an ODP for floor plan pattern .  illustrates the generation of an ODP  for floor plan pattern . As illustrated, user interface again includes first portion  and second portion , and first portion  include storyboard area .","ODP  is generated by dragging and dropping an OIP outgoing data port in first portion and specifying that the outgoing port is to be associated with an ODP. Upon specifying the association, ODP  can be generated, as shown in . In other implementations, a floor plan pattern may already have an ODP specified (e.g., OIP-ODP-OPD), which needs to be configured by a user.","The graphical configuration tool can then determine the aspects related to the outgoing port. To accomplish this, the tool can query meta data that describes the aspect and any related aspects. Additionally, queries with the same result aspect can be found. This information is processed by the tool and is displayed in first portion , and can be used for the configuration of advanced queries. Second portion  displays information regarding the fields of the aspects for a selected data output graphic object.","The queries to obtain information regarding the back-end systems, modules, queries, fields, and aspects can be performed by Java components that use the meta model to access R\/3 meta data. In particular implementations, the Java components can act as an agent for the graphial configuration tool. The description can be represented in XML, and the Java components can run on a J2EE server and be accessible by an XML-based protocol over HTTP. The results can be displayed in a discovery task section of a user interface.","Additionally, the client part of the graphical configuration tool can allow these components to browse the back-end meta data. Thus, the user can be presented with a graphical user interface that hides the complexities and allows easy browsing of the meta data and configuration of patterns. For example, a user can look through a list of available queries in a service module before picking a query to use. Also, by dropping a query, the user can readily check its parameters and result fields.","The Java components can be accessed by using a protocol handler (entry point for requests) that creates Java components based on the information in an XML request. The set of components can be independent from each other and, in this way, allow easy extensibility. In case additional browsing components are required, a component can be implemented without any changes to other components. The requests to these components will contain information about it, and the protocol handler will automatically instantiate the component and forward the request to it. The Java components can also support caching of heavily instantiated cool objects. Each user session can have its own cache.","Furthermore, the client part can be used independent from graphical configuration tool and, thus, can be accessed from other client. An example access protocol can be based on XML over HTTP.","The Java components can be part of Java Debug Interface (JDI) and, hence, can benefit from all its capabilities, like versioning in a design time repository (DTR), packaging and deployment, and central server builds.","The above-described techniques can be implemented in digital electronic circuitry, in computer hardware, firmware, or software, or in combinations thereof. Particular implementations can be as a computer program product (i.e., a computer program tangibly embodied in an information carrier (e.g., in a machine-readable storage device or in a propagated signal)) for execution by, or to control the operation of, a data processing apparatus (e.g., a programmable processor, a computer, or multiple computers). A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers, at one site or distributed across multiple sites and interconnected by a communication network.","Method operations can be performed by one or more programmable processors executing a computer program to perform display functions of the invention by operating on input data and generating output. Method operations can also be performed by, and an apparatus can be implemented as, special purpose logic circuitry (e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit)). Modules can refer to portions of the computer program and\/or the processor\/special circuitry that implements that functionality.","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory, a random access memory, or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data (e.g., magnetic, magneto-optical disks, or optical disks). Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices (e.g., EPROM, EEPROM, and flash memory devices), magnetic disks (e.g., internal hard disks or removable disks), magneto-optical disks, and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in special purpose logic circuitry.","To provide for interaction with a user, the above described techniques can be implemented on a computer having a display device (e.g., a CRT (cathode ray tube) or an LCD (liquid crystal display) monitor) for displaying information to the user and an input device (e.g., a keyboard and a pointing device (e.g., a mouse or a trackball)) by which the user can provide input to the computer (e.g., interact with a user interface element). Other kinds of devices can be used to provide for interaction with a user as well. For example, feedback provided to the user can be any form of sensory feedback (e.g., visual, auditory, or tactile), and input from the user can be received in any form, including acoustic, speech, or tactile input.","The above described techniques can be implemented in a distributed computing system that includes a back-end component (e.g., a data server), a middleware component (e.g., an application server), and\/or a front-end component (e.g., a client computer having a graphical user interface and\/or a Web browser through which a user can interact with an example implementation). The components of the system can be interconnected by any form or medium of data communication (e.g., a communication network). Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d) (e.g., the Internet), and include both wired and wireless networks.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","The invention has been described in terms of particular implementations, but other implementations can be achieved, and are within the scope of the following claims. For example, the operations of the invention can be performed in a different order and still achieve desirable results. In certain implementations, multitasking and parallel processing may be preferable. As another example, although the use of UI patterns has been described in connection with business objects and business data, patterns can be used with other types of objects and with data that is not business-related.","Patterns can also be developed using different development processes in different development environments, and executed in different run-time systems. For example, patterns can be developed using an integrated development environment (IDE) that incorporates tools for building, testing, deploying, and maintaining applications (e.g., configuration applications and pattern components). Such tools can include visual development tools, templates (e.g., code templates), and class libraries. A class library can include base classes that provide basic functionality (e.g., input\/output, string manipulation, and network communication), as well as specialized classes that provide enhanced functionality (e.g., classes for building and using graphical user interfaces on clients, and for offloading application functionality onto smart clients). Where an IDE supports multiple languages, class libraries can provide a consistent development interface across those languages.","In addition, some IDEs also provide services and functionality that can be used to reduce the amount of code that needs to be written manually. Such functionality can include, for example, the ability to declare and bind to data types and the ability to bind application elements such as controls and data structures.","IDEs can also provide code generation capabilities\u2014for example, the ability to automatically generate plumbing code (e.g., code for drawing windows or accessing Web services), or the ability to automatically generate run-time code (e.g., by using code generators, compilers, or both). The automatic generation of run-time code allows programs to be targeted to multiple platforms. For example, a code generator can be used to automatically generate run-time code for one or more specific platforms based on the program code produced by a developer. Alternatively, the developer code can be compiled for a run-time system, which can be hosted in multiple environments (e.g., servers, clients, or a combination of servers and clients).","Some IDEs also provide the ability to create meta data that specifies descriptive information about an application, and that can be used by a run-time system to provide services to the application. Meta data can be explicitly declared by a developer, generated in the process of generating run-time code, or both.","Examples of IDEs that can be used to develop patterns include IDEs that are built using the open Eclipse Platform supported by the Eclipse Foundation (e.g., the Web Dynpro IDE developed by SAP, or the WebSphere Studio IDE developed by IBM Corp. of Armonk, N.Y.), as well as proprietary IDEs (e.g., the Visual Studio NET IDE developed by Microsoft Corp. of Redmond, Wash.).","The overall process of developing a pattern (including, for example, developing a configuration application and a pattern component) can include a design time aspect and a run-time aspect. The design time aspect can involve use of the IDE to write code and to declare attributes, bindings, and other meta data. The code and the meta data can then be used to generate run-time code to be executed in a run-time system. Some development environments can be coupled to a corresponding run-time system, which allows programs developed in such development environments to take advantage of services offered by the corresponding run-time systems. For example, in the Web Dynpro environment discussed in conjunction with , applications can take advantage of services such as input help and validation offered by the Web Dynpro runtime, which frees developers from having to code such functionality manually into their programs.","Run-time systems provide a code execution environment that generally includes core services (e.g., memory, process, and session management), as well as enhanced services (e.g., input help and validation). In addition to the Web Dynpro runtime, other examples of run-time systems include virtual machines (e.g., the Java Virtual Machine), and the Common Language Runtime (a run-time system developed by Microsoft Corp.) As specified above, run-time systems can be hosted in multiple environments, including servers and clients. Servers generally provide a core operating environment for applications (e.g., by providing a run-time system in which the applications can execute). An example of a server is a J2EE-compliant server, such as the Web Application Server from SAP or the WebSphere Application Server from IBM Corp."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 4A-4C"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 6A-6B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 8-10"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 11A-B"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 14A-E"}]},"DETDESC":[{},{}]}
