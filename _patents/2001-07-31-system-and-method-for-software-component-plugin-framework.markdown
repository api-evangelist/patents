---
title: System and method for software component plug-in framework
abstract: The invention provides a software component plugin framework. The system described supports dynamic loading, instantiation, and unloading of interface implementations (plugin modules), together with encapsulation of these interface implementations. The many benefits provided by the invention include software reuse, interoperability and fast product development cycles.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06996832&OS=06996832&RS=06996832
owner: BEA Systems, Inc.
number: 06996832
owner_city: San Jose
owner_country: US
publication_date: 20010731
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims priority from provisional application \u201cSYSTEM AND METHOD FOR SOFTWARE COMPONENT PLUG-IN FRAMEWORK\u201d, Application Ser. No. 60\/294,467, filed May 30, 2001, and incorporated herein by reference.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The invention relates generally to object component models and specifically to a system and a method for enabling plugin applications in a framework architecture.","Today's business environment has become increasingly dependent on electronic commerce or \u201ce-commerce\u201d applications for their day to day operations. E-commerce applications typically define such enterprise-wide functions as supply chain management purchasing, sales, finance, manufacturing, enterprise resource planning, and data processing. An e-commerce application is typically designed to operate or run on a dedicated computer server or group of servers known collectively as an e-commerce or transaction server. Such server products include the TUXEDO\u2122 product from BEA Systems, Inc., San Jose, Calif.; Weblogic Server\u2122, also from BEA Systems; Commerce Server\u2122 from Microsoft Corporation in Redmond, Wash.; and both Avila\u2122 and CRM\u2122 from IBM Corporation, Armonk, N.Y.","The key requirements for such servers are that they be proven, reliable, and scalable so as to meet the needs of a growing organization. Some products are also designed with flexibility in mind. Particularly, TUXEDO is geared towards providing a powerful and flexible end-to-end e-commerce solution that can be used to connect and empower all users, while integrating all of a corporations corporate data.","One of the primary disadvantage of such e-commerce or transaction servers is that they tend to be very large applications in and of themselves. The typical e-commerce server ships as a server application that must be compiled to form an engine or kernel through which client applications may then communicate. Once compiled, very little can be added or modified to the server application, and hence to the system, without requiring a reconfiguration of this kernel.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},"Traditionally, in order to add personalities or extensions the server kernel must be re-configured and recompiled at each step. This necessitates server downtime and greatly increases the risks that errors will be introduced either during the recompile process or during the attempt to get the server running again in the shortest possible time. As shown in , switching to a TUXEDO personality, adding a connection module extension, and then adding a security module extension, may take as many as three server downtimes and kernel recompiles. Such compile problems are also encountered when adding routine server application updates and software patches. The traditional server architecture likewise does not lend itself to reuse of Module code when the server kernel is itself replaced. Much time and cost is spent re-writing code for new releases of a server product that does much the same as the last version of the code. Customers who develop custom code to run with or within their server product find their code unusable with server releases of the server product. The overall result is one of redundant coding, expense and wasted time.","To address this issue, the inventors have concluded that it would be advantageous to break the existing application transaction server or e-commerce server into a set of more manageable components. This would also address the following goals:","Allow commerce and transaction server customers to reuse their client applications with newer or future server products.","Eliminate additional steps of porting and recertifying other, related server-based products because of changes to the currently offered server infrastructure.","Address the needs of e-commerce server customers who suffer because their server-based products include bugs that have been corrected in the latest version of the server system.","Reduce the amount of code copied\/changed across products through \u201ccomponentization\u201d, and encourage the reuse of software code to minimize redundant coding.","Consequently, to address these goals, the inventors propose an e-commerce server architecture wherein a server engine component, referred to herein as an \u201cengine\u201d, plays a center role in providing some basic services, and also a plugin mechanism that allows the customization of the engine. This customization may include well-defined interfaces to the engine, and call-outs from the engine. Personalities are provided through plugin modules, including any customizations to the engine's set of extensions.","Within the server engine, dynamic linking and loading of a plugin module (referred to herein as an interface implementation), and encapsulation of that interface implementation, occurs in such a manner that the interface implementation is totally hidden from the interface user (i.e., the component acting as a client or client application).","As disclosed herein, the invention provides a plugin framework that may be incorporated into, or as part of, an application server engine to allow dynamic customization of the engine interfaces in terms of extending them through plugin modules. These plugin modules are in turn provided by personalities, and engine extensions. Application server engines that may be used with the invention include both e-commerce transaction and application engines. One embodiment of the engine Plugin Framework provides the following features:","A formal plugin module integration model;","A common infrastructure for dynamic loading, linking and unloading of plugin modules;","A common registry mechanism for plugin modules; and","Plugin application programming interfaces (APIs) that act as extensions to the engine provided interfaces","Both DLL (Dynamic Link Library) and non-DLL types of containers for plugin modules may be supported through various embodiments of the framework architecture. A system incorporating this new architecture can be visualized as a pool of software components interacting with each other through a client-server relationship. As used herein, a software component is considered a \u201cclient\u201d when it asks for a service provided by another component, and is considered a \u201cserver\u201d when it provides a service being requested by another component. The set of services offered by a component is accessed through a well defined interface. A component can offer multiple sets of either interrelated or not interrelated (i.e. independent from each other) services through corresponding interfaces. To the client, a component thus appears as a set of interfaces. The client does not care how these interfaces are actually implemented by the component. Components as used in this context of this application are thus the implementation provider for a given set of interfaces they support. A component can be removed from an application and replaced with another component, so long as the new component provides an implementation for the same interface as the old component did.","When implementing such an interface architecture one of the early design decisions regarding the use of components is to decide on the medium or container for making the component available during run-time. There should be a backing implementation for each interface being invoked by a client. This implementation library can be dynamically linkable, if the requirement is for separating the client from the interface implementation, and dynamically loadable if the requirement is to not load the component until it is actually needed. The library may be another process on the same (i.e. local), node or on a remote node.","Included below is a brief glossary of terms, acronyms, and abbreviations which will be useful in understanding the detailed description of the embodiments that follows:\n\n","[. . . ] indicates an optional item.","<. . . > indicates a token which can be replaced by a real value conforming to the syntax specified. The value between <and > is often replaced with a plugin-specific name to retrieve plugin-specific functions.",{"@attributes":{"id":"p-0040","num":"0059"},"figref":["FIG. 2","FIG. 2"],"b":["200","200","201","202","206","208","204","205"]},"As shown, the PIF enables the implementation and support of a component model architecture in which:","A component is a set of software modules that are bundled together, and which provide implementations for a set of services specified by the corresponding interfaces.","An interface is a contract about a set of services between the requesters (clients) and the providers (servers) of the services. This contract specifies a set of functions with the associated syntactical and semantical properties, for example the input\/output parameters and the return values, etc. Components utilize a client\/server relationship, and communicate with each other through interfaces.","With this architecture, the engine  can be further visualized as shown in  as a pool of software components interacting with each other through a client-server relationship. A component  is considered a client when it invokes a service ,  provided by another component, and a server ,  when it provides a service being invoked by another component. The set of services offered by each server component can be accessed through a well-defined interface , . A server component can offer multiple sets of services through the corresponding interfaces which may be interrelated or not interrelated (independent from each other).","An interface is a binding point between a client component and the server component. The client component need not know how these interfaces are implemented by a server component. In other words, the server component backing the interface is totally transparent to the client component. This means that an implementation ,  (a plugin) of an interface  can be replaced by other plugins at run-time, without impacting the client application code.","To a client, an interface may for example be a C language data type structure of which every member is a function pointer pointing to the plugin functions implementing the services defined by the corresponding interface. An interface is thus only a formal specification of a set of services until it (and its corresponding implementations or plugins) is registered and subsequently realized. As such, an interface has to be realized before its services can be invoked. The interface realization process consists of locating the specified implementation, loading it into the caller's address space, and populating an internal table of pointers with the addresses of the plugin functions implementing the services defined by the corresponding interface.","Interface Definition","One method of defining an interface is to use a standard specification such as the Object Management Group's (hereinafter referred to as OMG) Interface Definition Language (hereinafter referred to as IDL), or a subset of it. However, one can alternatively use any language which supports a \u201cstructure\u201d, \u201crecord\u201d, or an equivalent type of data structure with double-indirection support, (e.g. the struct command used in C or C++). The method of actually defining an interface is not necessary for an understanding of the present invention and can be left to the interface developer.","The interface developer is however expected to provide the following software modules which are then linked by the clients and\/or the plugins of that interface prior to run-time:","Header Files: Both the client applications and the plugins use header files to define interfaces, function prototypes of the interface functions, and the macros for the invocations of various interface functions. These header files are included into the client application and the plugin's source code.","Client stub files: The client application uses client stub files for invoking the interface functions. A client stub defines an interface as a set of language-specific data types and routines, one for each function (method) that is part of the interface. These client stubs are compiled and linked into the client application.","Plugin skeleton files: A plugin uses the plugin skeleton files to map client invocations of interface functions to the actual function implementations in the interface implementation (i.e. the plugin).","Interface Identity","In one embodiment of the invention, every interface has a name that serves as the compile-time type in the code that uses that interface. These programmatic types are defined in header files provided by the interface developer.","The programmatic name for an interface is only a compile-time type used within the application source code. Each interface also has a unique run-time identifier <interface id>, with the following syntax:\n\n","It will be evident to one skilled in the art that the particular variable names and syntaxes given here are for exemplary purposes, and that the invention is not limited to the specific syntax described herein.","In accordance with one embodiment, there is one universal namespace for recording <interface id>s in the engine PIF. Each <interface id> is unique within this namespace. In addition to <interface id>, every interface may also have a version associated with it, specified as two numbers, a <major version number> and a <minor version number>. The combination of an <interfaceid> together with a version uniquely identifies a particular version of an interface.","Versions are used to indicate compatibility among interfaces, and particularly between releases of the same interface. A <major version number> change implies a different interface. Different major versions of an interface are not expected to be compatible with respect to each other. However, the same <major version number>s, but different <minor version number>s of an interface should be compatible in the sense that a version with higher <minor version number> should be downward compatible with the version with lower <minor version number>. Both the <major version number> and the <minor version number> can be given by a numeric string representing a number between 0 and 256.","Each engine's personality and extension has a unique <component name>. An <interface name> should be unique within a component which owns it. The component provider (who may be a third-party vendor or developer) is responsible for assigning <interface name>s, <major version number>s and <minor version number>s to the interfaces which they provide.","Implementation Identity","In accordance with an embodiment of the invention every implementation of a supported interface has a unique implementation ID (implid) with respect to the interface it is implementing. This implementation ID has the following syntax:\n\n","There is one universal namespace for recording <impl id>s in the engine PIF. Each <impl id> is unique within this namespace.","Version Control","Interface version compatibility is an important issue between an interface requested or invoked by a particular caller, and the interface implementation or plugin which backs or realizes the interface. In accordance with one embodiment of the invention, every interface has a version number that can be specified in terms of major and minor version numbers. A plugin is an implementation of a specific version of an interface. The following rules apply with regard to version compatibility between the interface being realized and the plugin being considered to back the interface during the realization process (the processing of epifrealize( ) function):","Each plugin has a run-time knowledge of the version of the interface for which it is providing an implementation. If the major version number of the interface which the caller is attempting to realize and the major version number of the interface which the specified plugin implements are different, then the interface and the plugin are not compatible and in this case the realization of the interface fails.","If the major version number of the interface the caller is attempting to realize, and the major version number of the interface which the plugin specified implements are the same, then the following subset of rules apply:","An interface with a higher minor version number is downward compatible (in terms of functionality, and function signatures) with interfaces with lower minor version number and identical <interface id>.","An interface with a lower minor version number and identical <interface id> is a subset of an interface with a higher minor version number.","During the realization process, the backing plugin (i.e., the one which is realizing the interface) must have a minor version number which is equal or higher than the minor version number of the interface being realized. Otherwise, the interface and the plugin are not compatible.","The Vtbl returned by a plugin implementing an interface with a higher minor version number is allowed to grow only in a downward compatible way in terms of both size and content with the Vtbl of a plugin implementing the same interface, but with a lower minor version number. The term Vtbl used herein takes its common meaning and is a term known to one skilled in the art.","The rules described above are given to illustrate a particular embodiment of the invention and particularly version numbers used within that embodiment. It will be evident to one skilled in the art that other rules can be substituted for or added to those shown above while remaining within the spirit and scope of the invention.","Plugin Profiles","PIF profiles provide a way of associating a PIF client (the caller of a PIF external interface function,whether it is an application process or a system process) with a set of PIF related attributes during run-time. A PIF client may want to use its own implementation for a specific interface or it may want to realize a different implementation.","PIF profiles are identified by unique profile identifiers called <profile id>s. The syntax of a <profile id> is specified below.\n\n","There is one universal namespace for <profile id>s in the engine PIF. Each <profile id> is unique in this namespace. The PIF can be configured to always search the profile <profile id> specified by an EVPIFPROFILE environment variable in <interface id> or <impl id>, before it searches for the default system-wide profile. A group of clients may be associated with the same profile and consequently refer to the same set of interface\/implementation object attributes. A PIF client maybe associated with an existing PIF profile by setting the EVPIFPROFILE environment variable to the desired <profile id>.","PIF Registry","The PIF needs to locate the necessary plugin container, which can be a DLL (which contains the specified plugin), in order to load it into the registry Therefore it needs to know its image path and also other attributes about the interfaces and the interface implementations it is dealing with. To accomplish this, an embodiment of the invention uses a persistent storage based data repository for storing this kind of information. The PIF does not require a particular structuring for the persistent storage based plugin related information. Instead, the PIF describes this plugin information and specifies a set of command utilities for registering and unregistering plugins and for querying and\/or updating the stored plugin information. Within this document, the data repository that is used for storing PIF related information is referred to as the \u201cregistry\u201d. In the registry, interfaces and interface implementations are identified by <interface id>s and <impl id>s, respectively.","Both the interface, and the implementations backing it, have an associated set of attributes. In addition, an implementation is always associated with the interface it implements. Given a particular interface, there may be multiple implementations for that interface. An interface identifier <interface id> is an attribute of an interface implementation, identifying the interface this particular interface implementation implements. An implementation identifier <impl id> is an attribute of an interface it is associated with the implementation.","In object-oriented terminology, the registry may be considered a persistent store for PIF related objects and their associated attributes. These PIF related objects and their attributes are described in table 1, table 2 and table 3. Table 1 lists some interface objects, table 2 implementation objects, and table 3 profile objects. It will be evident to one skilled in the art that other objects can be stored within the registry to supplement or replace those shown, while remaining within the spirit and scope of the invention.",{"@attributes":{"id":"p-0074","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Interface Object"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Value of",{}]},{"entry":["Attribute","Attribute","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Interface Id","<interface id>","Interface id of an interface"]},{"entry":[{},{},"specification"]},{"entry":["Major Version","<major version","Major version number of the interface."]},{"entry":["Number","number>"]},{"entry":["Minor Version","<minor version","Minor version number of the interface."]},{"entry":["Number","number>"]},{"entry":["Selector","<selector>","A string of alpha numeric characters"]},{"entry":[{},{},"& \u2018\u2019. It is unique among the"]},{"entry":[{},{},"<selector>s associated with an"]},{"entry":[{},{},"interface object. Multiple <selector>s"]},{"entry":[{},{},"can be defined for an interface object."]},{"entry":["<selector>","<impl id>","Used for aliasing a plugin"]},{"entry":[{},{},"implementing the associated"]},{"entry":[{},{},"interface object. A <selector> is"]},{"entry":[{},{},"independent of the version of the"]},{"entry":[{},{},"interface."]},{"entry":["Default Impl","<impl id>","Implementation id of the default"]},{"entry":[{},{},"interface implementation, per major"]},{"entry":[{},{},"version of an interface object."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0075","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Implementation Object"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Attribute","Value of Attribute","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["ImplId","<impl id>","Implementation id of an interface"]},{"entry":[{},{},"implementation."]},{"entry":["Image Path","<Container path name>","Path name of the container or DLL containing"]},{"entry":[{},{},"the associated interface implementation."]},{"entry":["Entry Func","<ecpifinstantiate>","Name of instantiation function of the interface"]},{"entry":[{},{},"implementation object."]},{"entry":["Impl Major","<major version number>","Major version number of the implementation"]},{"entry":["Version",{},"object that is different than the major version"]},{"entry":[{},{},"number of an interface object."]},{"entry":["Impl Minor","<minor version number>","Minor version number of the implementation"]},{"entry":["Version",{},"object that is different than the minor version"]},{"entry":[{},{},"number of an interface object."]},{"entry":["Params","<string>","A string of characters to be passed to"]},{"entry":[{},{},"implementation object's instantiation function"]},{"entry":[{},{},"if defined. Multiple Params attribute can be"]},{"entry":[{},{},"defined for an implementation object."]},{"entry":["Inherits From","<impl id>","<impl id> of the interface implementation this"]},{"entry":[{},{},"implementation inherits from."]},{"entry":["Interception","STACK or Fanout","This attribute specifies the type of interceptor"]},{"entry":["Type",{},"sequence specified with the corresponding"]},{"entry":[{},{},"InterceptionSequence attribute of the"]},{"entry":[{},{},"implementation object."]},{"entry":["Interception","<impl id>, . . . , <impl id>","Ordered sequence of implementation ids of"]},{"entry":["Seq",{},"the interface implementations whose"]},{"entry":[{},{},"methods are invoked in the specified order"]},{"entry":[{},{},"(left-to-right). The interface implementations"]},{"entry":[{},{},"specified are all associated with the same"]},{"entry":[{},{},"interface."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0076","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Profile Object"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Attribute","Value of Attribute","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Profile Id","<profile id>","A unique (within the"]},{"entry":[{},{},{},"registry) profile id"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A set of Interface Objects",{}]},{"entry":[{},"A set of Implementation Objects"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Before an interface implementation can be used (i.e., before it can be realized), it must be installed in the system and registered within the registry. Unregistration and\/or uninstallation of the interface implementation is required to later remove all the relevant information from the registry. To accomplish these tasks, the PIF provides the following command utilities:","epifreg ( ) for registering a plugin.","epifunreg ( ) for unregistering a plugin.","epifregedt ( ) for editing registry based PIF related information.","The functions epifreg, epifunreg, epifregedt and the other functions described below, are given these function names for purposes of illustration. It will be evident to one skilled in the art that the invention is not limited to using the specific functions described herein.","Dynamically Loadable Library (DLL)","In one embodiment of the invention a dynamically loadable library (DLL) is used as the component server or container. Implementations of the interfaces (plugins) are contained inside DLLs. In accordance with one embodiment a DLL may contain only one plugin although their embodiments may support multiple plugin DLL's . A plugin may not span over multiple DLLs. A DLL may contain multiple plugins which may or may not be for the same interface. A DLL may contain a derived plugin, which implements only a subset of the functions which make up the corresponding interface, and which inherits the implementation of the remaining functions of the interface from another plugin.","The PIF provides the following functions or services for loading and unloading a DLL to and from the caller's address space, and for getting the address of a function in a loaded DLL:",{"@attributes":{"id":"p-0084","num":"0113"},"sub":["\u2014","\u2014","\u2014"]},{"@attributes":{"id":"p-0085","num":"0114"},"sub":["\u2014","\u2014","\u2014"]},{"@attributes":{"id":"p-0086","num":"0115"},"sub":["\u2014","\u2014","\u2014"]},{"@attributes":{"id":"p-0087","num":"0116"},"sub":["\u2014","\u2014","\u2014"]},"These functions can be provided as a library tailored to each desired or supported personality. For example, for use with TUXEDO, the functions may be provided through a TUXEDO standard libgp library.","Plugin Framework External Interfaces","The PIF external interface comprises the following functions:",{"@attributes":{"id":"p-0090","num":"0119"},"sub":["\u2014","\u2014","\u2014"]},{"@attributes":{"id":"p-0091","num":"0120"},"sub":["\u2014","\u2014","\u2014"]},{"@attributes":{"id":"p-0092","num":"0121"},"sub":["\u2014","\u2014","\u2014"]},{"@attributes":{"id":"p-0093","num":"0122"},"sub":["\u2014","\u2014","\u2014"]},{"@attributes":{"id":"p-0094","num":"0123"},"sub":["\u2014","\u2014","\u2014"]},{"@attributes":{"id":"p-0095","num":"0124"},"sub":["\u2014","\u2014","\u2014","\u2014"]},{"@attributes":{"id":"p-0096","num":"0125"},"sub":["\u2014","\u2014","\u2014"]},"Realization of An Interface",{"@attributes":{"id":"p-0097","num":"0126"},"figref":"FIG. 4","b":["238","240","230","234"]},"Following the registration process, the registry thus contains a list of all current implementations. When a client application makes a request to use an implementation they must realize the interface. This is performed through an epifrealize routine. Other routines, such as epifgetinfo allow the client application to get additional information about the interface. A call to realize the interface is passed to a kernel portability layer . The kernel portability layer allows the PIF  itself to be independent of the operating system layer . The PIF translates the realize request from the client into a series of function requests  to the kernel portability layer to load the appropriate implementation container. The PIF also issues requests  to the appropriate container to instantiate a particular implementation (and later passes requests  to release that implementation).","For an interface to be useful, an interface has to have a language binding, an implementation, and a well defined set of rules for interaction between the client and the implementation of the interface. This set of rules comprises the \u201cinterface realization protocol.\u201d The interface realization protocol encompasses rules governing client invocation, virtual function tables, plugin instantiation and reference counting. In accordance with an embodiment of the invention, the client of any particular interface must have a handle (pointer) to a newly created instantiation of a plugin backing the interface before it can invoke any of the functions of the interface. It acquires this handle for the interface by invoking the epifrealize function, an example of which is shown in listing 1(TM32U is used to refer to an unsigned integer variable, other variable types can be used):",{"@attributes":{"id":"p-0100","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014"]}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IN\u2003\u2003const char *pIId,","\/* pointer to interface id\u2003*\/\u2003\u2003I"]},{"entry":["\u2003\u2003\u2003const char *pImplId,","\/* pointer to implementation id *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IN\u2003\u2003const struct epifiversion *version, \/* interface version *\/"},{"entry":"IN\u2003\u2003const void *data, \/* data passed to plugin from caller *\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["IN\u2003\u2003long datalen,","\/* size of buffer data points to *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"OUT\u2003void **pI, \/* interface pointer *\/"},{"entry":"IN\u2003\u2003TM32U\u2003\u2003\u2003\u2003\u2003flags\u2003\u2003\u2003\/* flags *\/"},{"entry":")"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The pointer to the implementation id (implementation id pointer), hereinafter referred to as pImplId can be specified as either an <impl id> or a <selector>, or NULL. If pImplId is specified as NULL, then the <impl id> of the default implementation defined in the registry database (Defaultimpl attribute) is used instead. This default implementation is searched according to the search rules associated with the registry database, such as, for example, the first client's (caller's ) profile and then the system-wide profile for the interface ids.",{"@attributes":{"id":"p-0102","num":"0131"},"figref":["FIG. 5","FIG. 5"],"b":["252","253","254","255","256","257"]},"The interface realization in this example involves only a single implementation (with no inheritance) and is further described in . In , a calling application (caller)  uses the PIF  to realize an implementation plugin A . The dashed lines in the Figure indicate the invocation sequence and the handles returned to various components during the realization of an interface. The solid lines in  indicate the relationships among the data structures involved in interface realization. The caller  issues a request  to the PIF  to realize an interface. The PIF uses this request information and the information stored in the registry to send an instantiate request  to a plugin A . The PIF uses the information stored within the plugins Vtbl , private data store , and per-instance data structure , to create a proxy Vtbl . A pointer  to the proxy Vtbl is then returned to the caller. The caller uses this pointer to thereafter communicate  with the interface and the implementation. Each of these processes is described in further detail below.","As shown in , the handle returned (ip) is a pointer to a data structure in memory, called a Proxy Virtual Function Table (Proxy Vtbl). In one embodiment, the Virtual Function Table (Vtbl) is a C struct of function pointers pointing to the actual functions comprising the implementation for the interface being realized. Every plugin is required to maintain (e.g. allocating a memory block and populating it) its own Vtbl. Plugins are also responsible for managing per instance private data and plugin-wide struct epifplugininfo data structure. The PIF is responsible for presenting to a client a realized interface as a C struct, of which the members are pointers to functions implementing the function signatures which the interface specifies.","As part of interface realization process, the PIF loads the container or DLL containing the target plugin for backing the interface, and then invokes <ecpifinstantiate>( ) function of the plugin, if it is available and registered. Otherwise, it invokes a DLL-wide ecpifinstantiate( ) function to instantiate an instance of the plugin. Both ecpifinstantiate( ) and <ec pifinstantiate>( ) functions have the same function signature. Given a pointer to an <interface id> and a pointer to an <impl id>, they instantiate a plugin and return three handles: the address of the plugin's Vtbl; the address of the plugin instance specific private data; and the address of the plugin's epifplugininfo structure.","The epifplugininfo structure contains information relevant to the implementation of the interface. In particular, an EFPIFSINGLETON flag indicates to the PIF that the implementation is a \u201csingleton\u201d. When a singleton implementation is instantiated, new calls to instantiate the implementation result in a reference to the first plugin instance. The PIF may use this singleton indication to optimize reference handling for other epifrealize( ) calls to this implementation (since the PIF is not required to call the ecpifinstantiate( ) function). If a particular implementation turns off this indication, then the PIF will always call the ecpifinstantiate( ) function every time the client realizes the implementation. Realization of a non-singleton plugin always results in a new plugin instance.","Plugin Lifetimes","The term Interface Lifetime Control is used herein to refer to the mechanism and the set of rules which are used to determine when to unload the container or DLL which contains the implementations of the interfaces that are currently in use. One of the goals of the invention is to make the caller or client immune to replacement of an interface's current implementation by another implementation. To the client, a component is the interfaces it supports. In most cases, the client does not know anything about the actual implementation of the interface provided by the component. Thus, the client can not directly control the lifetime of a DLL since different parts of a program may refer to different interfaces and\/or multiple instantiations of the same interface supported by the DLL. In practice, a client will not want to unload the DLL when it is finished with one interface, but still using another interface. Determining when to release a DLL gets increasingly complicated with an increase in the complexity of the client application program. The PIF can be used to manage this lifecycle.","To accomplish this, the PIF provides two functions, namely, epifdupref( ) and epifrelease( ) which can be invoked by PIF's clients for plugin lifetime control purposes. The PIF maintains a reference count for each plugin instance. When a client gets an interface pointer, the corresponding reference count is incremented by calling the epifdupref( ) function of the interface. When the client is finished using an interface, the reference count is decremented by calling the epifrelease( ) function of the interface. When all the reference counts of all the interfaces supported by a DLL falls to 0, the DLL is unloaded from memory.","In addition to these two functions provided by the PIF, plugins may provide an implementation of the ecpifdestroy( ) function. The PIF invokes this function when the reference count for a plugin falls to 0. Effective use of a reference counting scheme imposes some rules on the parties involved, which are as follows:\n\n","Every implementation of an interface should provide the ecpifcopy( ) function in support of the PIF's epifdupref( ) function. In one embodiment when the epifdupref( ) function is called with a EFPIFDEEPCOPY flag and the plugin is not a singleton, the PIF calls the plugin's ecpifcopy( ) function to obtain a copy of the private data of the plugin instance. Then, the PIF creates a new instance of the implementation.","Each plugin container (DLL) also provides a ecpifinstantiate( ) for instantiating a plugin which the container contains. This function is invoked by the PIF during realization of an interface if the selected plugin does not provide its own <ecpifinstantiate>( ) function and does not set the value of its registry attribute EntryFunc to the name of its <ecpifinstantiate>( ) function.","When calling member functions, the caller must include the interface pointer to the plugin instance (which is returned from the corresponding epifrealize( ) function) as the first parameter. In accordance with an embodiment of the invention every plugin of a defined interface is required to obey the following rules:\n\n","The PIF allows one interface implementation to inherit the implementation of a subset of interface methods or functions from another interface implementation within the same interface. This inheritance relationship between any two interface implementations of the same interface is specified with an InheritsFrom attribute. The InheritsFrom attribute is an attribute of the plugin which is inheriting and the value of this attribute identifies the interface implementation inherited from. This attribute takes an <impl id> as its value.","The PIF may support single or multiple inheritance. With single inheritance the implementation that is inherited from may in turn inherit from another interface implementation by setting its InheritsFrom attribute to the <impl id> of the plugin it is inheriting from.","The memory layout of the interface realization through implementation inheritance is described in . As shown in , dashed lines indicate the invocation sequence and the handles returned to various components during the realization of an interface; solid lines indicate the relationships among the data structures involved in interface realization. As before, a calling client  issues a request  to the PIF  to realize an interface. The PIF uses the information in the request and in the registry to send an instantiate request  to plugin A . Information from plugin A's vtable , private data store , and per-instance data structure  is used to populate part of the proxy vtable . This allows plugin A to fulfill a subset of the interface functions. The remaining interface functions are provided by a derived plugin B . Derived plugin B provides information from its Vtbl , private data store , and per-instance data structure , to populate the remaining functions in the proxy Vtbl. The caller then uses a pointer , as before, to communicate with the interface and the backing implementation via the proxy vtable. The following rules apply to the interface realization process:","All of the plugins involved in the implementation inheritance or in the inheritance sequence should have a major version number that is equal to that of the interface being realized.","At least one of the plugins involved in the implementation inheritance should have a minor version number that is equal to or higher than, that of the interface being realized.","The minor version number of the derived plugin (the final output of implementation inheritance process) is that of the plugin with the highest minor version number among all the plugins involved in the implementation inheritance process.","If any of the above rules are violated during the inheritance process, then the interface realization process may fail and an EEPIFVERSIONMISMATCH error value returned to the caller of epifrealize( ).","The Proxy Vtbl should not have NULL or invalid address valued entries.","The specific rules described above are give for purposes of illustrating a specific embodiment of the invention, and to demonstrate the flexibility of the PIF system. These rules need not be implemented in whole or in part in order to operate the invention, and other rules may be substituted for those described above, while remaining within the spirit and scope of the invention.","The PIF may also support interface inheritance the process of which operates similarly to that shown for plugin inheritance.","Interceptors","Interceptors provide a flexible means of adding services to a system. They allow the binding between the client and the target objects to be extended and specialized to reflect the mutual requirements of both. Interceptors can be logically thought of as being interposed in the invocation and response code paths between the client application making a request and the implementation of the object on which the request is made. As such, interceptors are the functions or methods of the configured interface implementations or plugins which provide the services being interposed.","In one embodiment of the invention the engine supports two types of interceptors: Fanout type interceptors and Stack type interceptors. Interceptors are specified with a pair of attributes, namely, Interception Type and Interception Seq.. These attributes are associated with an interface implementation <impl id>. The InterceptionType attribute specifies the type of interception (either Fanout or STACK) while the InterceptionSeq attribute defines an interception sequence.","An InterceptionSeq attribute specifies the intercepting plugins and their interception order. In one embodiment its value is a comma separated ordered set of <impl id>s, describing the order of the plugins whose methods are invoked in the order specified when the functions of the corresponding interface are called. Wherever a verb of the interface is referred to in a code path, the corresponding functions of the interface implementations specified in the data field of InterceptionSeq value are invoked in the order specified.","Fanout Type Interceptors","Fanout type interception is illustrated in . As depicted in , Fanout type interception can be implemented totally independently from the PIF. The PIF does not need to be aware of its existence and as far as the PIF is concerned, the interception sequence is no more than a group of plugins comprising the interception sequence specified with the InterceptionSeq attribute. In this approach however, the Fanout plugin needs to know how to access the registry to get the value of the corresponding InterceptionSeq attribute. This can be accomplished by exposing the registry application programming interface (API) or by using the PIF's help to support access by the Fanout type interceptors.","In one embodiment the PIF may provide the necessary support with ecpifinstantiate( ) and epifinterceptionseq( ) functions. Referring again to , in this model of interception, the calling client or caller  invokes the methods of plugin A , but is not aware of the intercepting plugins , , , . During the instantiation of plugin A, the intercepting plugins as specified by the InterceptionSeq attribute of plugin A are also instantiated by the PIF and the sequence of ordered addresses of these instances of the intercepting plugins is passed to plugin A via ecpifinstantiate( ). Subsequent method invocations by the client or interface caller results in invocation of the corresponding methods of intercepting plugins in the order specified by the InterceptionSeq attribute.","The key characteristics of this interception model can be specified as follows:","Given that client invokes method X of plugin A (denoted as  in ) method X of plugin A invokes method Xs of the intercepting plugins in the Fanout order specified by the InterceptionSeq attribute of plugin A as follows:\n\n","The methods of intercepting plugins return success or failure on function returns.","The sequenced method invocation stops with the first method returning failure condition, and the status returned to the client.","All of the plugins involved in the interception implement the same interface, i.e., their corresponding methods have the same signatures.","Multiple occurrences of the same plugin are not allowed in an interception sequence.","No intercepting plugin in a Fanout type interception sequence is allowed to be a Fanout type plugin or a stack-type plugin.","A plugin is not allowed to be both a Fanout type plugin and a stack-type plugin.","FanOut type plugins are not allowed to be derived (i.e., inheriting) plugins.","The specific rules described above are give for purposes of illustrating a specific embodiment of the invention, and to demonstrate the flexibility of the PIF system. These rules need not be implemented in whole or in part in order to operate the invention, and other rules may be substituted for those described above, while remaining within the spirit and scope of the invention.","Stack Type Interceptors","Stack type interception is illustrated in . In the Stack type interception model shown in , the client  invokes the methods of plugin A , but is not aware of the intercepting plugins , , . The PIF is responsible for loading and instantiating the intercepting plugins, as specified by the relevant InterceptionSeq attribute, in addition to plugin A during interface realization, and for building and maintaining the interception sequence.","Subsequent invocations of methods of plugin A by the client (interface caller) result in invocations of the corresponding methods of intercepting plugins in the order specified by the InterceptionSeq attribute. During the realization of an interface involving stack type interception sequence, the PIF passes the interface pointer to the next plugin in the interception sequence via <ecpifinstantiate>( ) function of each plugin in the sequence.","The key characteristics of this interception model can be specified as follows:","Given that client invokes method X of plugin A (shown as  in ), method Xs of the intercepting plugins are invoked in the order specified by the InterceptionSeq attribute of plugin A as follows:\n\n","As with the Fanout type interceptors, with Stack interceptors, all of the plugins involved in the interception implement the same interface, i.e., their corresponding methods have the same signatures.","Sequenced method invocation stops with the first method returning failure condition, and this status returned to the client.","All the plugins involved in a stack-type interception sequence are required to be stack-type plugins except that the last intercepting plugin in the sequence is allowed to be a non-intercepting (neither Fanout type nor Stack-type) plugin.","Multiple occurrences of the same plugin are not allowed in an interception sequence.","A plugin is not allowed to be both a Fanout type plugin and a Stack-type (Stack-aware) plugin.","Stack-type plugins are not allowed to be derived (i.e., inheriting) plugins.","The specific rules described above are give for purposes of illustrating a specific embodiment of the invention, and to demonstrate the flexibility of the PIF system. These rules need not be implemented in whole or in part in order to operate the invention, and other rules may be substituted for those described above, while remaining within the spirit and scope of the invention.","Process Threading","In one embodiment of the invention, the PIF can serialize calls to a particular implementation's ecpifinstantiate( ), ecpifcopy( ), and ecpifdestroy( ) function, and make use of separate processing threads. This can contribute greatly to the overall performance of the system.","Interface Function Utilities","The following section illustrates various functions that are used with the PIF system to register implementations and to realize interfaces. It will be evident to one skilled in the art that additional or alternative functions can be used within the spirit and scope of the invention.",{"@attributes":{"id":"h-0022","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The edlload function maps the specified executable module into the address space of the calling process.",{"@attributes":{"id":"p-0152","num":"0220"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014"]}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"filename of"]},{"entry":[{},"executable module *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["OUT ETDLHANDLE *dllhandle,","\/* DLL handle *\/"]},{"entry":["IN TM32U\u2003\u2003\u2003flags","\/* flags *\/"]},{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"sub":"\u2014","ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["dllpath is a pointer to a null-terminated string that names the DLL file. If the string specifies a path but the file does not exist in the specified directory, the function fails. If the string does not specify a full path name, the function uses a standard search strategy to find the file.","dllhandle is the DLL handle to be used in subsequent edlunload and edlgetfuncaddr functions.\n\nedlunload\n"]}},"The edlunload function unloads a DLL:",{"@attributes":{"id":"p-0154","num":"0224"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014","\u2014","\u2014"]}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"loaded library module *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IN TM32U\u2003flags \/* flags *\/"]},{"entry":[{},") ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Theedlunload function unloads the specified library from the address space of the calling process. After this call, the specified handle is no longer valid, wherein:\n\n","The edlgetfuncaddr function returns the address of the specified exported dynamic-link library (DLL) function:",{"@attributes":{"id":"p-0157","num":"0228"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014","\u2014","\u2014"]}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"to loaded library module *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"IN\u2003\u2003const char *pFuncName,\u2003\u2003\u2003\u2003\/* name of function *\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["OUT\u2003void **pfa,","\/* pointer to pointer to func address *\/"]},{"entry":["IN\u2003\u2003TM32Uflags","\/* flags *\/"]},{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The edlgetfuncaddr function returns the address of the specified exported dynamically loadable library (DLL) function in pfa, wherein:\n\n","The edladdref function increments the reference count associated with a loaded DLL:",{"@attributes":{"id":"p-0160","num":"0235"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{"sub":["\u2014","\u2014","\u2014","\u2014"]}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IN ETDLHANDLE dllhandle,","\/* DLL handle *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IN TM32U\u2003\u2003flags","\/* flags *\/"]},{"entry":[{},") ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The edladdref increments the reference count of the DLL specified by dllhandle. It should be called for every new copy of a pointer to an instant of a plugin, wherein:\n\n","The ecpifinstantiate function instantiates a plugin:",{"@attributes":{"id":"p-0163","num":"0239"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014"]}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IN\u2003\u2003const char *pIId,","\/* pointer to interface id\u2003*\/"]},{"entry":["IN\u2003\u2003const char *pImplId,","\/* pointer to implementation id *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IN\u2003\u2003const struct epifiversion *version, \/*interface version *\/"},{"entry":"IN\u2003\u2003const struct epifdata *pData, \/* data passed from caller"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"and\/or registry *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"IN\u2003\u2003const struct epifinterceptiondata *pInterceptionData,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/* interception data *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"INOUT struct epifinstancehandles *pI, \/* instance cookies *\/"},{"entry":"IN\u2003\u2003TM32U flags\u2003\u2003\/* flags *\/"},{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The ecpifinstantiate( ) function is a container-wide, default plugin instance instantiate function (<ecpifinstantiate>( )), invoked by the Plugin Framework (PIF) during the realization of an interface (i.e. as a result of a client invoking epifrealize( )). It is implemented by a plugin implementer and is invoked only if plugin specific instantiate function is not available. If a plugin specific <ecpifinstantiate>( ) function is provided, then this function is invoked rather than the DLL-wide ecpifinstantiate( ) function. The plugin specific <ecpifinstantiate>( ) function has the same function signature as that of ecpifinstantiate( ) function, wherein:\n\n","The ecpifinstantiate( ) function, given a pointer to an <interface id>, version of the interface and a pointer to an <impl id>, instantiates a plugin implementing the interface being realized and returns a set of handles about the plugin and the instance of the plugin being instantiated in a memory block pointed to by pI. The version specifies the version of the interface whose <interface id> is pointed to by pIId.","The pInterceptionData points to a in-core data structure of data type struct epifinterceptiondata defined as follows:",{"@attributes":{"id":"p-0167","num":"0249"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct epifinterceptiondata {"},{"entry":"struct epifiversion mpifversion ; \/* vers of this structure *\/"},{"entry":"void const * *fanoutinterceptionseq ; \/* ordered sequence of"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"instance addresses in fanout"]},{"entry":[{},"type interception sequence *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"TM32U fanoutinterceptionseqlen ; \/* number of addresses in"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"the interception sequence *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"void *nextip ; \/* address of plugin instance next (relative to"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"callee) in the stack type interception sequence *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The pointer pI points to a memory block of data type struct epifinstancehandles defined as follows:",{"@attributes":{"id":"p-0169","num":"0251"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"struct epifinstancehandles { struct epifiversio mpifversion"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[";","\/* version of this structure *\/"]},{"entry":["void *pVtbl ;","\/* address of plugin Vtbl *\/"]},{"entry":["void *pPrivData ;","\/* address of private data *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct epifplugininfo *pPluginInfo ;\u2003\u2003\u2003\/* plugin info *\/"},{"entry":"} ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In the pInterceptionData structure the pVtbl contains the address of the Vtbl of the plugin being instantiated. The pPrivData contains the address of the private data of the instance of the plugin being created. pPluginInfo contains the address of the memory block of type struct epifplugininfo, containing plugin information specific to the plugin being instantiated. It is the responsibility of the plugin to populate the fields of this structure. The struct epifplugininfo is declared as follows:",{"@attributes":{"id":"p-0171","num":"0253"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct epifplugininfo {"},{"entry":"struct epifiversion mpifversion ;\/* version of the Plugin"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Framework *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"struct epifiversion miversion ; \/* version of the interface"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"implemented by the plugin *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"char * mimplid ;\u2003\u2003\/* interface implementation id *\/"},{"entry":"char * minterfaceid ;\u2003\u2003\/* interface id *\/"},{"entry":"int mVtblsize ;\/* size of Vtbl in terms of number of entries *\/"},{"entry":"char * mvendor ;\u2003\u2003\/* vendor name *\/"},{"entry":"char * mproductname ; \/* product name *\/"},{"entry":"char * mvendorversion ; \/* vendor assigned version number *\/"},{"entry":"TM32U mflags;\u2003\/* flags *\/"},{"entry":"\/* addresses of PIF imposed functions *\/"},{"entry":"TM32I (*destroy) (TCADEF, const struct"},{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014"]}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"to destroy the plugin *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"TM32I (*copy) (TCADEF, const struct epifinterceptiondata *,"},{"entry":"struct epifinstancehandles *, TM32U) ;\u2003\/* function called"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"by the PIF to copy the plugin's private data *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} epifplugininfo, *pepifplugininfo;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The epifplugininfo structure contains information relevant to the implementation of the interface. The mflags field defines flags set by the implementation and interpreted by the PIF. In one embodiment of the invention, the following flags are defined:","EFPIFSINGLETON\u2014signal or flag that the implementation is a singleton object","EFPIFSTACK\u2014signal that the implementation is a stack-type intercepting plugin","EFPIFFANOUT\u2014signal that the implementation is a Fanout type intercepting plugin","EFPIFCONCURRENCYAWARE\u2014signal that the implementation (whether it is a derived implementation or a head of a Fanout or STACK type interception sequence) is concurrency aware","The EFPIFSINGLETON flag is a hint to the Plugin Framework to indicate whether the implementation is a singleton. When a singleton implementation is instantiated, new calls to instantiate the implementation result in a reference to the first plugin instance. The PIF can use this hint to optimize reference handling for other epifrealize( ) calls to this implementation (in that the Plugin Framework is not required to call the ecpifinstantiate( ) function).","The flags specified by mflags field are not mutually exclusive. EFPIFQUERY is one example of such a flag. When it is set, ecpifinstantiate( ) populates pVtbl and pPluginInfo fields of struct epifinstancehandles pointed to by pI without instantiating the plugin.",{"@attributes":{"id":"h-0023","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The epifrealize function realizes an interface:",{"@attributes":{"id":"p-0180","num":"0262"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014"]}},{"entry":"IN\u2003\u2003const char *pIId,\u2003\u2003\u2003\u2003\u2003\u2003\/* pointer to interface id *\/\u2003I"},{"entry":"\u2003\u2003\u2003const char *pImplId,\u2003\/* pointer to implementation id *\/"},{"entry":"IN\u2003\u2003const struct epifiversion *version, \/* interface version *\/"},{"entry":"IN\u2003\u2003const void *data, \/* data passed to plugin from the caller *\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IN\u2003\u2003long datalen,","\/* size of buffer data points to *\/"]},{"entry":["OUT\u2003void\u2003\u2003\u2003\u2002**pI,","\/* interface pointer *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IN\u2003\u2003TM32U\u2003\u2003flags \/* flags *\/"},{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The epifrealize function realizes an interface specified by pIId and version by instantiating the interface implementation specified by pImplId. The client of an interface should have a pointer to newly created instantiation of a plugin backing the interface before it invokes any function of the interface. It acquires this handle for the interface by invoking the epifrealize function.","The pImplId is either the <impl id> of or a <selector> for the plugin to be instantiated.","If pImplId is specified as NULL, then the default implementation (DefaultImpl) for the interface <interface id> is loaded to back the interface. If no default implementation for the interface is set, then a registered implementation with the equal major version number to that of the interface (being realized) and the highest minor version number is loaded to back the interface subject to the version control rules specified below:","The major version number of the target plugin should match the major version number of the interface. Otherwise, the interface being realized and the target implementation are not compatible.","The minor version number of the target plugin should be equal to or higher than that of the interface being realized. Otherwise, the interface and the target implementation may not be compatible.","If the target implementation is inheriting from other plugins, all of the plugins in the inheritance sequence should have a major version number equal to that of the interface being realized.","If the target implementation is inheriting from other plugins, at least one of the plugins in the inheritance sequence should have a minor version number that is equal to or higher than that of the interface being realized.","If pImplId is specified and EFPIFEXACTMATCH flag is set, then the plugin specified by pImplId is loaded subject to version control rules as specified above. If it is not registered (i.e., not found), then this function fails and returns an EEPIFNOTREGISTERED error value is returned.","If pImplId is specified, but not registered or found, and the EFPIFEXACTMATCH flag is not set, then the system attempts to locate the default implementation for the interface. If the default implementation is not compatible or not found, then the system will attempt to locate a compatible implementation with the highest minor version equal to or greater than the value specified in the version argument. If a compatible implementation does not exist, then the function fails, returning an EEPIFNOTREGISTERED error. The specified plugin is then located according to the search rules associated with the registry such as, for example, first the client's (caller's) profile and then the system-wide profile for the interface ids.","The data point to data passed to the plugin from the caller, and datalen specifies the length of the buffer pointed to by data.",{"@attributes":{"id":"h-0024","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The epifdupref function increments the reference count associated with a loaded plugin instance or duplicates a plugin instance:",{"@attributes":{"id":"p-0192","num":"0274"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{"sub":["\u2014","\u2014","\u2014","\u2014"]}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IN\u2003\u2003void\u2003* pI,","\/* pointer to plugin instance *\/"]},{"entry":[{},"OUT\u2003void\u2003**ppdup,","\/* duplicated plugin instance *\/"]},{"entry":[{},"IN\u2003\u2003TM32U flags","\/* shallow or deep copy *\/"]},{"entry":[{},") ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The epifdupref increments the reference count of the plugin instance pointed to by pI and duplicates the address of the plugin instance into ppdup. It should be called for every new copy of a pointer to an instant of a plugin.","The flag may include EFPIFDEEPCOPY, which if specified, causes the Plugin Framework to create a duplicate copy of the instance specified by pI and return an interface pointer to the duplicate copy into ppdup. The duplicate instance has its own memory block for its private data (if such exists), life control and unique interface pointer.",{"@attributes":{"id":"h-0025","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The epifrelease function decrements the reference count associated with a loaded plugin instance:",{"@attributes":{"id":"p-0196","num":"0278"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"sub":["\u2014","\u2014","\u2014","\u2014"]}]},{"entry":[{},"IN void * pI, \/* pointer to plugin instance to be released *\/"]},{"entry":[{},"IN TM32U\u2003\u2003flags\u2003\/* flags *\/"]},{"entry":[{},") ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The epifrelease decrements the reference count of the plugin instance pointed to by interface pointer pi. If the reference count of the specified plugin instance falls to 0, then the plugin instance is destroyed.",{"@attributes":{"id":"h-0026","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The epifis compatible function checks if a specified interface version is supported by a plugin instance:",{"@attributes":{"id":"p-0199","num":"0281"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014"]}},{"entry":"IN void\u2003\u2002* pI,\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* pointer to plugin instance *\/"},{"entry":"IN const struct epifiversion *version, \/* interface version *\/"},{"entry":"IN TM32U\u2003\u2002flags\u2003\u2003\u2003\u2003\u2003\u2003\/* flags *\/"},{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The epifiscompatible checks to see if the plugin instance specified by pI is compatible with the interface version specified by version.",{"@attributes":{"id":"h-0027","num":"0000"},"sub":["\u2014","\u2014","\u2014","\u2014"]},"The epifinterceptionseq function returns an ordered sequence of addresses of the instances of the plugins in the interception sequence:",{"@attributes":{"id":"p-0202","num":"0284"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014","\u2014"]}},{"entry":"IN\u2003void\u2003\u2003\u2002* pI,"},{"entry":"OUT const struct epifinterceptiondata**ppInterceptionData,"},{"entry":"\/* interception data *\/"},{"entry":"IN TM32U\u2003\u2003\u2003flags \/* flags *\/"},{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"There may be only one plugin in the sequence, Regardless, the epifinterceptionseq returns the addresses of the instances of the intercepting plugins in the calling sequence relative to the plugin instance specified by pI into an in-core data structure of data type struct epifinterceptiondata pointed to by *ppInterceptionData.","The data structure struct epifinterceptiondata is defined as follows:",{"@attributes":{"id":"p-0205","num":"0287"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct epifinterceptiondata {"},{"entry":"struct epifiversion mpifversion ;\/* version of this structure *\/"},{"entry":"void\u2002**fanoutinterceptionseq ;\u2003\/* ordered sequence of instance"},{"entry":"addresses in fanout type interception sequence *\/"},{"entry":"TM32U fanoutinterceptionseqlen ; \/* number of addresses in the"},{"entry":"interception sequence *\/"},{"entry":"void **nextip ;\u2003\u2003\u2003\u2002\/* address of plugin instance next (relative"},{"entry":"to callee) in the stack type interception sequence *\/"},{"entry":"} ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"If the caller is a fan-out type plugin, then n ordered sequence of the addresses of the Fanout intercepting plugin instances which make up the interception sequence for the Fanout plugin is returned into an array *fanoutinterceptionseq. The fanoutinterceptionseqlen variable specifies the number of addresses in this array.","In the case of stack type intercepting plugins, the address of the next plugin instance in the calling sequence is returned into *nextip. If the plugin instance specified by pi is the last plugin instance in the interception sequence, then a NULL is returned in *nextip.",{"@attributes":{"id":"h-0028","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The epifthis function is used to return the address of the private data area:",{"@attributes":{"id":"p-0209","num":"0291"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"sub":["\u2014","\u2014","\u2014","\u2014"]}]},{"entry":[{},"IN\u2003\u2003void *pI,"]},{"entry":[{},"IN const void *pVtbl,"]},{"entry":[{},"OUT\u2003void **ppriv,"]},{"entry":[{},"IN TM32U\u2003\u2003flags \/* flags *\/"]},{"entry":[{},") ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The epifthis returns the address of the private data area of the plugin instance specified by pI. The pVtbl handle points to the plugin specific Vtbl. This is the same Vtbl whose address is returned from <ecpifinstantiate>( ) function during the creation of the instance of the plugin.",{"@attributes":{"id":"h-0029","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The epifgetinfo function is used to get information about a loaded plugin:",{"@attributes":{"id":"p-0212","num":"0294"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"sub":["\u2014","\u2014","\u2014","\u2014"]}]},{"entry":[{},"OUT TM32U\u2003*infoseqlen,"]},{"entry":[{},"OUT const epifplugininfopublic * const **pInfo,"]},{"entry":[{},"IN TM32U\u2003\u2003flags\u2003\u2003\u2003\/* flags *\/"]},{"entry":[{},") ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The epifgetinfo gets information about a plugin instance specified by pi. This information is returned into the epifplugin-info-public structure pointed to by pInfo:",{"@attributes":{"id":"p-0214","num":"0296"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct epifplugininfopublic {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["struct epifiversion\u2003mpifversion ;","\/* version of PIF *\/"]},{"entry":["struct epifiversion\u2003miversion ;","\/* version of the interface"]},{"entry":"implemented by the plugin *\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["char\u2003* mimplid ;","\/* interface implementation id *\/"]},{"entry":["char\u2003* minterfaceid ;","\/* interface id *\/"]},{"entry":["char\u2003* mvendor ;","\/* vendor name *\/"]},{"entry":["char\u2003* mproductname ;","\/* product name *\/"]},{"entry":["char\u2003* mvendorversion ;","\/* vendor assigned version number *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"TM32U\u2003\u2002mflags ;"},{"entry":"} epifplugininfopublic, *pepifplugininfopublic ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The mflags field defines flags set by the implementation and interpreted by the PIF, and include EFPIFSINGLETON, EFPIFSTACK, EFPIFFANOUT, and EFPIFCONCURRENCYAWARE, all of which are described in further detail above. Concurrency awareness always imply composite behavior\u2014if the plugin is a derived plugin or a head of an interception sequence, then this means that all of the plugins involved in the composition are concurrency aware and that if one of the components does not support concurrency, then the composition is not concurrency aware. Consequently, in this case the concurrency aware flag is not returned.","The flags argument specifies optional flags, for example the EFPIFDETAILEDINFO flag. If it is specified, epifgetinfo( ) returns detailed information about the plugin specified. If the plugin specified is a derived implementation, then the information about all the implementations involving in the derivation of the plugin are returned, starting from the most derived implementation. If the plugin specified is the head of a Fanout type or STACK type interception sequence, then the information about all the plugins involved in the interception sequence is returned, starting from the plugin specified (head of interception sequence) followed by the intercepting plugins, left-to-right in case of Fanout type, and top-down in case of STACK type.",{"@attributes":{"id":"h-0030","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The ecpifdestroy function is used to destroy a plugin instance:",{"@attributes":{"id":"p-0218","num":"0300"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014"]}},{"entry":"INOUT struct epfinstancehandles\u2003*pIhandles,\/* instance cookies"},{"entry":"*\/"},{"entry":"IN TM32U\u2003\u2003\u2002flags\u2003\u2003\u2003\u2002\/* flags *\/"},{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The ecpifdestroy releases the plugin instance specific system resources specified by pIhandles. The pIhandles points to a memory block of data type struct epifinstancehandles defined as follows:",{"@attributes":{"id":"p-0220","num":"0302"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct epifinstancehandles {"},{"entry":"struct epifiversion\u2003mpifversion ;\u2003\u2002\/*\u2003\u2002version of this"},{"entry":"structure *\/"},{"entry":"void\u2003\u2003\u2003*pVtbl ;\u2003\u2003\u2003\u2003\/* address of plugin Vtbl *\/"},{"entry":"void\u2003\u2003\u2003*pPrivData ;\/*\u2003address of plugin instance specific"},{"entry":"private data *\/"},{"entry":"struct epifplugininfo\u2003\u2003*pPluginInfo ;\u2003\u2002\/* plugin info *\/"},{"entry":"} ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}],"sub":["\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014"]},"The ecpifcopy function creates a duplicate copy of a plugin instance:",{"@attributes":{"id":"p-0222","num":"0304"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"sub":["\u2014","\u2014","\u2014","\u2014"]}},{"entry":"IN\u2003\u2003const struct epifinterceptiondata *pInterceptionData,\u2003\/*"},{"entry":"interception data *\/"},{"entry":"INOUT struct epifinstancehandles\u2003\u2003*pIhandles, \/* instance"},{"entry":"cookies *\/"},{"entry":"IN TM32U\u2003flags\u2003\u2003\/* flags *\/"},{"entry":") ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"sub":["\u2014","\u2014","\u2014"]},"The pInterceptionData points to an in-core data structure of data type struct epifinterceptiondata (defined above), while the pIhandles points to a memory block of data type struct epifinstancehandles (also defined above).","The pVtbl is a pointer containing the address of the Vtbl of the plugin instance whose private data are being duplicated. pPrivData is a pointer containing the address of the plugin instance private data. If no private data are used by the plugin instance, then NULL is returned. The pPluginInfo pointer contains the address of the memory block of type struct epifplugininfo, containing plugin instance specific information which is declared as follows:",{"@attributes":{"id":"p-0225","num":"0307"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct epifplugininfo {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["struct epifiversion mpifversion ;","\/* version of the Plugin"]},{"entry":"Framework *\/"},{"entry":["struct epifiversion miversion ;","\/* version of the interface"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"implemented by the plugin *\/"},{"entry":"char * mimplid ;\u2003\u2003\/* interface implementation id *\/"},{"entry":"char * minterfaceid ;\u2003\u2003\/* interface id *\/"},{"entry":"int mVtblsize ;\u2003\u2003\u2003\u2003\/* size of Vtbl in terms of number of"},{"entry":"entries *\/"},{"entry":"char * mvendor ;\u2003\u2003\/* vendor name *\/"},{"entry":"char * mproductname ; \/* product name *\/"},{"entry":"char * mvendorversion ; \/* vendor assigned version number *\/"},{"entry":"TM32U mflags;\u2003\/* flags *\/"},{"entry":"\/* addresses of PIF imposed functions *\/"},{"entry":"TM32I (*destroy) (TCADEF, const struct epifinstancehandles *,"},{"entry":"TM32U) ;\u2003\u2003\/* function called by the PIF to destroy the plugin *\/"},{"entry":"TM32I (*copy) (TCADEF, const struct epifinterceptiondata *,"},{"entry":"struct epfinstancehandles *, TM32U) ; \/* function called by the"},{"entry":"PIF to copy the plugin's private data *\/"},{"entry":"} epifplugininfo, *pepifplugininfo;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The epifplugininfo structure contains information relevant to the implementation of the interface. The mflags field defines flags set by the implementation and interpreted by the PIF. Flags may include EFPIFSINGLETON, EFPIFSTACK, EFPIFFANOUT, and EFPIFCONCURRENCYAWARE \/*, all of which are described in further detail above.","epifreg","The epifreg function or command registers a plugin implementation, and uses the following syntax:",{"@attributes":{"id":"p-0228","num":"0310"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"epifreg\u2003-p implid -i interfaceid -v Major.Minor -f imagePath \\"]},{"entry":[{},"[-e entryFunction]\u2003[-b baseImplid]\u2003[-o profileId]"]},{"entry":[{},"[-u userParameters]\u2003\\"]},{"entry":[{},"[-s InterceptorType [:implid1 ,..., implidN] ]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The epifreg function can take a variety of options as indicated above, wherein the options have the following meaning:\n\n","The epifunreg function unregisters a plugin:\n\n","The epifunreg command unregisters the specified plugin. The -p option specifies the implementation identifier of the plugin to be unregistered. If this option is used alone then, the plugin's data stored in the Plugin Framework is unregistered (including the data stored in all of the existing profiles). The -o option can be optionally used to specify that the information about the plugin should be removed from the specified profileld. This command does not remove the data about the related plugin's interface, which can be removed with the epifregedt command.","epifregedt","The epifregedt function edits the attributes of implementations, interfaces, and profiles stored in the Plugin Framework registry:\n\n","The Plugin Framework searches the specified profile in the registry for the specified interface and\/or implementation object data. The <Profileid> or <ObjId> can be specified as \u201c*\u201d to indicate that the edit operation applies to all existing profiles or interface\/implementation ids, respectively. \u201cSYSTEM\u201d is the <Profile id> for the default system-wide profile.","The -a option is used to specify the attributes involved in the editing operation on the specified object. The AttrName is the name of an attribute of the edited object and AttrValue is the value assigned to this attribute. Some attributes can be used to narrow the scope of the particular editing operation (such as a set, create, or delete).","The following options specify the editing operation performed by the epifregedt command:",{"@attributes":{"id":"p-0235","num":"0000"},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":["-g Get the values of the selected attributes of the specified object. If no attributes are specified with the -a option then, all attributes of the object are retrieved. Otherwise, only the specified attributes are retrieved. With this and all the other options, if AttrValue is supplied, it is specified, then it is used to narrow the scope of this operation. In the case of multiple AttrName attributes with the corresponding AttrValue values are specified, then only the objects with the identical AttrValue values for the corresponding AttrName attributes are retrieved.","-s Set, create, or change the values of the selected attributes of the specified object. Some attributes are required when a new object is created in the registry. These attributes are specified with the -a option.","-d Delete the selected attributes of this specified object. If no attributes are specified with the -a option then, the object and all its attributes are removed from the registry. Otherwise, only the specified attributes are deleted.","-c Copy the specified object to another profile. The new profile should be specified with the -a option using the Profileld as the value for AttrName and the new profile identifier as the value of AttrValue.","-m Move the specified object to another profile. The new profile should be specified with the -a option using the Profileld as the value for AttrName and the new profile identifier as the value of AttrValue. If the target profile does not exist then, a new profile is created.\n\nExample Implementation\n"]}},"This section provides a sample code illustration demonstrating how to construct a PIF compliant client application and a corresponding plugin. The following files are shown merely for demonstration purposes to better illustrate the invention. It will be evident to one skilled in the art that the procedures used may be extended to apply to more complex situations and applications, and that the invention is not limited to the C language examples give below.","The plugin can be defined in a metalanguage format using a plugin wizard or similar tool. The metalanguage defines the plugin operations, and also such variables as the plugin name, the interface name, and the interface version number.","Plugin Description File","The following plugin description file (dummy.pi) is an example of a description file used to define a plugin. The plugin description may, in some embodiments, be created by a plugin wizard or plugin design tool. At a minimum it should contain a plugin name (in this case \u201cdummy\u201d), an interface name (\u201csec\u201d), and an interface version number (\u201c1.2\u201d). The plugin should also contain a number of operations (in this example denoted as op 1, op 2, op 3, and op 4. The operations define the functions the plugin will actually provide to the calling application.",{"@attributes":{"id":"p-0239","num":"0341"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"========= dummy.pi ========="]},{"entry":[{},"@plugin dummy"]},{"entry":[{},"@interface sec"]},{"entry":[{},"@interfaceversion\u200312"]},{"entry":[{},"@operations"]},{"entry":[{},"void op1(int i, double k)"]},{"entry":[{},"int op2(void *foo)"]},{"entry":[{},"void *op3(const char *x)"]},{"entry":[{},"char * op4( )"]},{"entry":[{},"@end"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The dummy.h file below is an example of a generated include or header file which is output by the plugin wizard. The header file must be included at compile time into each plugin implementation and client application. The include file provides a specification of the particular interface in which the plugin operates.",{"@attributes":{"id":"p-0241","num":"0343"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"========= dummy.h ========="]},{"entry":[{},"#ifndef dummyh"]},{"entry":[{},"#define dummyh"]},{"entry":[{},"#include \u201ceengpif.h\u201d"]},{"entry":[{},"struct sec12 ;"]},{"entry":[{},"typedef struct\u2003sec12Vtbl {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void\u2003\u2003(*op1) (struct sec12 *, int i, double k);"]},{"entry":[{},"int\u2003\u2003\u2003(*op2) (struct sec12 *, void *foo);"]},{"entry":[{},"void*\u2003\u2003(*op3) (struct sec12 const char *x);"]},{"entry":[{},"char *\u2003\u2003(*op4) (struct sec12 *);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} sec12, *sec12ptr ;"]},{"entry":[{},"#define sec12op1 ( ip, a1, a2) \\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(ip->op1 (ip, (a1), (a2)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#define sec12op2 (ip, a1) \\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(ip->op2 (ip, (a1)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#define sec12op3 (ip, a1) \\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(ip->op3 (ip, (a1)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#define sec12op4 (ip) \\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(ip->op4 (ip))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#endif \/* dummyh *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this example, the include file includes a name (\u201cdummy\u201d), and a data structure definition that defines the data structure for the particular interface and version number (in this case sec. 1.2). The data structure includes pointers for all of the operations supported by this particular interface and version number.","Plugin Application File","The dummy.c file below is an example of the generated skeleton template, and represents the actual plugin application. The only modifications from the generated .h file is the replacement of the generated comments in each of the operation implementations with actual code, and the addition of private data members to the Private data structure. The c file when compiled is used to provide the actual plugin implementation. Certain verbs (such as pif-destroy and pif-copy) are required in order for the interface to handshake successfully with a calling application. Other verbs (op1, op2, op3, op4) provide the functional operations of the plugin framework.",{"@attributes":{"id":"p-0244","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"========= dummy.c ========="},{"entry":"#include \u201cdummy.h\u201d"},{"entry":"#include <malloc.h>"},{"entry":"#include <string.h>"},{"entry":"#include \u201ceengpif.h\u201d"},{"entry":"typedef struct {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"....."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} Privatesec12, *Privatesec12ptr;"},{"entry":"int"},{"entry":"sec12ecpifdestroyimpl(const"},{"entry":"struct epifinstancehandles *pI)"},{"entry":"{"},{"entry":"\u2002...."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (pI->pPrivData != NULL)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"free (pI->pPrivData );"},{"entry":"}"},{"entry":"int"},{"entry":"sec12ecpifcopyimpl(const"},{"entry":"struct\u2003\u2002epifinterceptiondata"},{"entry":"*pInterceptionData, struct epifinstancehandles *pI) {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"....."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"static void"},{"entry":"sec12op1impl(struct sec12\u2003*ip , int i, double k)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"....."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"static int"},{"entry":"sec12op2impl(struct sec12\u2003*ip ,\u2003void *foo)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"....."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"static void *"},{"entry":"sec12op3impl(struct sec12 *ip , const char *x)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"....."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"static char *"},{"entry":"sec12op4impl(struct sec12 *ip)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"....."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"static const epifplugininfo sec12plugininfo = {"},{"entry":"\/* mpifversion.imajorversion *\/ 1,"},{"entry":"\/* mpifversion.iminorversion *\/ 0,"},{"entry":"\/* miversion.imajorversion *\/ 1,"},{"entry":"\/* miversion.iminorversion *\/ 2,"},{"entry":"\/*\u2003mimplid\u2003\u2003*\/ \u201csec1\u201d,"},{"entry":"\/* minterfaceid *\/ \u201csec\u201d,"},{"entry":"\/* mVtblsize *\/ 4,"},{"entry":"\/* mflags *\/ 0,"},{"entry":"\/* Plugin Vendor Info *\/"},{"entry":"\/* mvendor\u2003\u2003\u2003*\/ \u201cRSA\u201d,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002\/* mproductname\u2003*\/ \u201cRoadrunner Exterminator\u201d,"]},{"entry":[{},"\/* mvendorversion *\/ \u201c2000\u201d,"]},{"entry":[{},"\/* PIF imposed functions *\/"]},{"entry":[{},"sec12ecpifdestroyimpl,"]},{"entry":[{},"sec12ecpifcopyimpl,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"static sec12Vtbl Vtblsec12 = {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"sec12op1impl,"]},{"entry":[{},"sec12op2impl,"]},{"entry":[{},"sec12op3impl,"]},{"entry":[{},"sec12op4impl,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"#ifdef cplusplus"},{"entry":"extern \u201cC\u201d"},{"entry":"#endif"},{"entry":"#ifdef WIN32"},{"entry":{"sub":"\u2014"}},{"entry":"#endif"},{"entry":"int"},{"entry":"sec12instantiate ("},{"entry":"IN\u2003\u2003\u2002const char *pIId, \/* pointer to interface id"},{"entry":"IN\u2003\u2003const char *pImplId,\u2003\/* pointer to implementation id *\/"},{"entry":"IN\u2003\u2003struct epifiversion *version,\u2003\u2003\/* interface version *\/"},{"entry":"IN\u2003\u2003const struct epifdata\u2003\u2003*pData\u2003\u2003\/* data passed from"},{"entry":"caller and\/or registry *\/"},{"entry":"IN\u2003\u2003const struct epifinterceptiondata\u2003\u2003*pInterceptionData,"},{"entry":"\/* interception data *\/"},{"entry":"INOUT\u2003\u2003\u2002struct epifinstancehandles\u2003\u2003\u2003*pI,\u2003\/* pointer to"},{"entry":"instance of plugin"},{"entry":"IN\u2003\u2003TM32U flags \/* flags *\/"},{"entry":")"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Privatesec12ptr priv;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003....."},{"entry":"if (flags & EFPIFQUERY) {"},{"entry":"pI->pPluginInfo = & sec12plugininfo ;"},{"entry":"}"},{"entry":"else {"},{"entry":"priv = (Privatesec12ptr) calloc(1, sizeof *priv) ;"},{"entry":"if ( ! priv ) {"},{"entry":"\u2002return EEPIFNORESOURCE ;"},{"entry":"}"},{"entry":"pI->pVtbl = &Vtblsec12 ;"},{"entry":"pI->pPrivData = priv ;"},{"entry":"pI->pPluginInfo = & sec12plugininfo ;"},{"entry":"}"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"....."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"return ;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The test.c file shown below is an example of a client application that loads and invokes operations on the plugin. The client application is written so as to call the required interface definitions (specified in dummy.h). The client application must successfully realize the desired interface (sec) with the specified plugin. Thereafter it uses a pointer (pin) to refer to an implementation vtable (Vtbl). The operations themselves are called through a series of put commands.",{"@attributes":{"id":"p-0246","num":"0348"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"========= test.c ========="},{"entry":"#include <stdio.h>"},{"entry":"#include \u201ceengpif.h\u201d"},{"entry":"#include \u201cdummy.h\u201d"},{"entry":"main( )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct sec12 *pin;"]},{"entry":[{},"struct epifiversion version;"]},{"entry":[{},"version.imajorversion = 1 ;"]},{"entry":[{},"version.iminorversion = 2 ;"]},{"entry":[{},"if (epifrealize(\u201csec\u201d,\u2003\u201csec1\u201d, &version,\u2003NULL, NULL,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"&pin, NULL, 0) != EEPIFSUCCESS) {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"puts(\u201ccan't realize interface with the specified plugin\u201d);"]},{"entry":[{},"exit(1);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"puts(\u201c>>> Calling op4\u201d) ;"]},{"entry":[{},"puts(sec12op4(pin) ) ;"]},{"entry":[{},"puts(\u201c>>> Calling op3\u201d) ;"]},{"entry":[{},"puts( (char *) sec12op3(pin, \u201chello world!\u201d) ) ;"]},{"entry":[{},"puts(\u201c>>> Calling op4\u201d) ;"]},{"entry":[{},"puts(sec12op4(pin) ) ;"]},{"entry":[{},{"sub":["\u2014","\u2014","\u2014"]}]},{"entry":[{},"......."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The client does not need to specify an actual implementation (although it does in this example). When an implementation is not specified the client is given the default implementation for that interface.","Function Design Specification","In this section, an example of a design for the function-by-function realization of an interface process supporting both (a) implementation inheritance and (b) no implementation inheritance cases is presented. The example design supports interface inheritance even though it may not be a requirement for all embodiments of the engine. The key aspects of this particular design are as follows:","The client is presented a realized interface as a C struct, of which the member variables are the pointers to functions of an implementation that are implementing the function signatures of the interface, regardless of whether the implementation backing the interface is a single implementation, or a derived implementation. The client is not aware of whether the realized interface is an original interface or a composite or inherited interface, and instead sees it as a single interface.","The interface method invocations pass an interface pointer to the plugin instance as the first argument.","The implementation methods may access per instance private data by invoking an epifthis( ) function provided by the PIF.","The realization and implementation process of this particular design embodiment is shown in . As shown in , the process includes a realization phase, interceptor phase, load and unload phases, and a rehears phase. These are discussed in further detail below.",{"@attributes":{"id":"h-0037","num":"0000"},"sub":["\u2014","\u2014"],"b":"390"},"The epifrealize function  calls pifinit to initialize a mutual exclusion lock routine (mutex). A mutex is an abstract structure that enforces a policy of mutual exclusion. Traditionally, only one process thread at a time may hold a particular mutex, and threads trying to lock a held mutex will block until the mutex is unlocked. Mutexes must be exited in the opposite order in which they were entered, and that they cannot be reentered before exiting.","If the registry plugin is not already realized, then the process will attempt to realize it. This instance of the registry plugin can be cached for performance benefits. The count of active plugin's is incremented to reflect the new plugin and the mutex is then unlocked.","Since the process does not know when the framework will no longer be needed it keeps track of how many plugin instances are active at any given time. Whenever this count drops to zero the cached registry plugin is released. The use of cache for optimization is only useful when there will be at least one active plugin instance when other plugins are being realized. If the design model is such that only one plugin is ever active at a time, then the registry plugin will be realized and released each time. A side effect of caching the registry plugin is that the underlying registry being used does not see registry changes until the registry is closed and re-opened.","The process then calls the realizefrontend function . If this is not successful then the mutex is locked the active plugin count is decremented. If the active count goes to zero then the registry plugin is released, and the mutex unlocked.","realizefrontend( ) ","The process continues with a realizefrontend function  which as a first step constructs a PIFRARGS stack using supplied arguments and calls realizeinternal . If realizeinternal finds a singleton plugin value then the corresponding singleton is returned. If realizeinternal finds a stack interceptor then the handle or pointer of the first plugin in the stack is returned. If realizeinternal returns anything else but SUCCESS then an error is returned. If none of the above criteria are met, the plugin is constructed from its components. The realizefrontend function loops through each implementation and verifies the major version number, while at the same time looking for both the highest minor version number and the largest Vtbl size.","A verification step ensures that the highest minor version number is greater than or equal to that requested. The size block of memory required is computed and allocated. One block of memory is allocated for the variable sized PIFCONTROL block, the Proxy Vtbl, the fan-out interceptor array, and the array of infopublic pointers.","The PIFCONTROL block is filled in, as is the Proxy Vtbl by looping through each implementation's Vtbl, and filling in empty entries in the Proxy Vtbl with non-nil entries from the Vtbls.","The the filled-in Proxy Vtbl is checked for empty entries, and if any are found, a NORESOURCE error is returned.","realizeinternal( ) ","One of the additional arguments is an array of the PIFPINFO data structure that is declared as a local. This array is used so all the implementations making up the complete plugin can be instantiated first so that the realization process knows how big a chunk of dynamic memory to allocate. This is dependent on both the depth of implementation inheritance, and on the size of the largest Vtbl within all the implementations that make up the complete plugin. Because this array is allocated before the process knows the actual depth of implementation inheritance the framework may impose an implementation restriction on the maximum depth of implementation inheritance allowed. If during the realization process this limit is reached the process will fail and an returned.","If no implementation identifier is specified then the first read of the registry is to call GetIntf  using the specified interface identifier and major version number of the interface. If the DefaultImpl attribute is non-null then it is used as the implementation identifier.","If no implementation identifier is specified and the DefaultImpl attribute mentioned above is nil then the HighestMinorImpl attribute is looked at.","If an implementation identifier is specified, or one is determined from the above steps, the next step is to see if the identifier is a selector or alias by calling GetAlias . If no match is found then the implementation identifier is not an alias. If a match is found then what is now known to be an alias is used as an attribute name and it's value is read from the registry. The value of this attribute is then used as the implementation identifier, but is first checked recursively to see if the alias mapped to another alias.","Using the interface identifier argument and the resultant implementation identifier a list of singleton plugins that have already been realized (and have not yet been released) is checked for one whose most derived implementation's info structure has the appropriate minterfaceid and mimplid fields. If a match is found then pepfdupref is called on the matching plugin and the new pointer is returned. The search for an existing matching singleton is not done when the implementation being instantiated as a base implementation.","Using the resultant implementation identifier GetImpl  is called. If the implementation does not exist, an error is returned, unless the identifier used is the one originally specified by the caller, in which case the process starts at the top as if the caller had not specified an implementation identifier.","The realizeinternal next checks the InterceptionType attribute. If this attribute indicates anything other than \u201cNoInterceptor\u201d then it calls an internal routine that handles the realization of an interceptor. This step is skipped if the implementation being realized is one that was specified in a stack Interception Sequence.","If the InterceptionType attribute is set then the process calls realizeinterceptor .","If the InterceptionType is STACK then a pointer is alos set to the next stack member.","The edlload function is called using either the ImagePath attribute or the implId.","The edlgetfuncaddr function  is called using either the EntryFunc attribute or the default \u201cepdlinstantiate\u201d. The plugin's epdlinstantiate function is then called.","The appropriate infopublic structure (mpinfo in the PIFPINFO struct) is initialized from the corresponding implementations private info structure.",{"@attributes":{"id":"h-0040","num":"0000"},"sub":["\u2014","\u2014","\u2014"],"b":"404"},"The value of the ImagePath attribute is passed to gpdlload. Then the value of the EntryFunc attribute is passed to gpdlgetfuncaddr  to get the address of the plugin's instantiation routine. The instantiation routine is called with the appropriate arguments that come from those passed in to pepfrealize and internally generated.","The realizeinternal checks the InheritsFrom attribute. If this attribute exists then it calls realizeinternal recursively with the value of the said attribute The implementation identifier specified in the InheritsFrom attribute when realized by the framework is realized as if the EFPFEXACTMATCH flag was specified.","Once control is returned to pepfrealize from realizeinternal then the size of the Proxy Vtbl needed is determined, and the depth of inheritance is known.","At this time the system can now check to make sure that there exists at least one implementation making up the complete plugin that implements at least the minimum minor version number requested by the caller. This check is made by looking at each implementation's epfplugininfo data structure. If this check fails then a version mismatch error is returned.","A PIFCONTROL data structure can now be allocated. The stack local array of PIFPINFO data structures is copied to the mpi field.","The Proxy Vtbl is now also filled in. Starting with the most derived implementation and ending with the least derived implementation the following is done. For every non-nil entry in the implementations static Vtbl for which there is a nil pointer at the same offset in the Proxy Vtbl, the pointer from the implementations static Vtbl is copied to the Proxy Vtbl.","The Proxy Vtbl is checked to make sure there are no nil pointers. If any are found, then everything is released and an error returned.","The mpublicinfo field of every member of the mpi field of the PIFCONTROL structure can be initialized by simply copying the corresponding fields from each corresponding implementation's private \u201cinfo\u201d structure. The vector of pointers pointed to by the mpublic info field of the PIFCONTROL structure is initialized to point to the appropriate mpublic info fields in the array of PIFPINFO structures (mpi).","Each implementation's info data structure is checked to see if the msingleton flag is set. If every implementation has this flag set then the PIFSINGLETON flag in the PIFCONTROL structure is set. If this flag is set then the PIFCONTROL structure is linked into a linked list of singleton plugins using the mnextSingleton pointer.","realizeinterceptor( ) ","Clients or calling applications (callers) make calls to realizefrontend on each implId in the sequence with rdepth+1 and the EXACTMATCH and IGNOREISEQ flags.","The returned pointer ip is stored in the PIFRARGS structure. If it is a Fan-out interception type then fanoutLen (PIFRARGS) is set to the sequence length. For both interception types the implementation identifiers specified in the InterceptionSeq attribute when realized by the framework are realized as if the EFPFEXACTMATCH flag was specified.","For a FAN-OUT type of interceptor the realizeinternal function is called N times with the same arguments as the original call to pepfrealize except for the implementation identifier argument which is replaced with the corresponding one from the sequence. N is the number of implementation identifiers in the sequence. The realizeinternal function is then called again, this time with a sequence of pointers to the realized intercepting plugins.","For a STACK type of interceptor the realizeinternal function is also called N times with the same arguments as the original call to pepfrealize. This time the sequence of implementation identifiers is traversed backwards. Additionally, on each call to realizeinternal, except the first, a single pointer to the last intercepting plugin realized is passed. If the ImagePath registry attribute exists on the registry key that defined the interceptor sequence, the key is treated as if it were the first plugin in the stacked interception sequence.",{"@attributes":{"id":"h-0042","num":"0000"},"sub":["\u2014","\u2014","\u2014"],"b":"406"},"In the non-deep copy case the reference count stored in the PIFCONTROL data structure is simply incremented and the same pointer returned.","In the deep copy case the following is done: A new PIFCONTROL data structure is allocated.","If the PIFSTACKI flag is set then pepfdupref  is called on the next plugin in the stack. The new pointer returned is saved in the minterceptors field of the new PIFCONTROL data structure allocated. The recursion is done first because the pointer to the next plugin in the new stack is needed before any of the copy routines for any of the implementations for the current plugin are called.","If the PIFFANOUTI flag is set then epfdupref  is called on each of the plugins in the fan-out interception sequence and the returned pointers stored in the corresponding fields of the new PIFCONTROL data structure. This recursion is done first because the new sequence is needed before any of the copy routines for any of the implementations for the current plugin are called.","The new PIFCONTROL data structure is populated from the original PIFCONTROL data structure, and the reference count of the new PIFCONTROL set to 1. Using the new PIFCONTROL data structure the plugin's copy routine (pointed to by its epfplugininfo data structure) is called. In the case of implementation inheritance each plugin in the inheritance list has it's copy routine called.",{"@attributes":{"id":"h-0043","num":"0000"},"sub":["\u2014","\u2014","\u2014"],"b":"396"},"The reference count in the PIFCONTROL data structure is decremented, and if the count after being decremented is greater than zero (0) then it simply returns.","The first thing that is done when the reference count goes to 0 is to call the plugin's destroy routine so it can release any of it's resources. In the case of implementation inheritance the destroy routine of the most derived implementations are called first.","If the plugin being released is part of a stacked interceptor chain then pepfrelease is called recursively on the next plugin in the chain.","If the plugin being released is a fan-out plugin, then each of the corresponding intercepting plugin's is released.","If the PIFSINGLETON flag is set in the PIFCONTROL data structure then the linked list of realized singleton plugin's is checked to see if this plugin is on that list, and if so it is removed from that list.","Finally, the dynamic library handle is unloaded , and then the PIFCONTROL data structure freed.","When the count of active plugins goes to zero the cached registry plugin reference is released.","If a release flag is set, then the epifrelease function is called on the next stack interceptor (if any) and on the sequence of fan-out intercepting plugins.",{"@attributes":{"id":"h-0044","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The process then simply indexes through the array of PIFPINFO's in the PIFCONTROL looking for one whose pVtbl instance handle matches the passed in key. If a match is found return the corresponding pPrivData pointer is returned.",{"@attributes":{"id":"h-0045","num":"0000"},"sub":["\u2014","\u2014","\u2014","\u2014"]},"A pointer to the minterceptors field in the PIFCONTROL is returned.",{"@attributes":{"id":"h-0046","num":"0000"},"sub":["\u2014","\u2014","\u2014"]},"The length and pointer to the array of public info pointers from the PIFCONTROL is returned.","It will be evident to one skilled in the art that while some functions and routines described herein were specified as having certain characteristics, features, and constraints on conforming to certain rules, that these rules need not be adhered to in full or in part in order to operate the invention, and that the examples given are for the purposes of illustrating an embodiment of the invention.","Example Deployment",{"@attributes":{"id":"p-0303","num":"0405"},"figref":"FIG. 13","b":["370","372","374","376","378","380","382"],"sub":["\u2014","\u2014","\u2014"]},"The foregoing description of preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obviously, many modifications and variations will be apparent to the practitioner skilled in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence."],"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTICE","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
