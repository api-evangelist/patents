---
title: Method and data processing system providing checkpoint/restart across multiple heterogeneous computer systems
abstract: Bulk data is read or written by an application on a first computer system to a file on a second heterogeneous computer system. Alternatively it is read or written as bulk data directly between applications on these heterogeneous systems. Jobs or tasks are started from one system to execute on a second heterogeneous system. Results are then returned to the first system. Checkpointing and later restarting is also initiated from a first system for execution on the second heterogeneous system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07082551&OS=07082551&RS=07082551
owner: Bull HN Information Systems Inc.
number: 07082551
owner_city: Billerica
owner_country: US
publication_date: 20010629
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is related to our patent application entitled \u201cMETHOD AND DATA PROCESSING SYSTEM PROVIDING FILE I\/O ACROSS MULTIPLE HETEROGENEOUS COMPUTER SYSTEMS\u201d, filed of even date herewith and assigned to the assignee hereof.","This application is related to our copending patent application entitled \u201cMETHOD AND DATA PROCESSING SYSTEM PROVIDING REMOTE PROGRAM INITIATION AND CONTROL ACROSS MULTIPLE HETEROGENEOUS COMPUTER SYSTEMS\u201d, filed of even date herewith and assigned to assignee hereof.","This application is related to our patent application entitled \u201cMETHOD AND DATA PROCESSING SYSTEM PROVIDING BULK RECORD MEMORY TRANSFERS ACROSS MULTIPLE HETEROGENEOUS COMPUTER SYSTEMS\u201d, filed on even date herewith and assigned to the assignee hereof, which issued as U.S. Pat. No. 6,615,217 on Sep. 2, 2003.","This application is related to our copending patent application entitled \u201cMETHOD AND DATA PROCESSING SYSTEM PROVIDING DATA CONVERSION ACROSS MULTIPLE HETEROGENEOUS COMPUTER SYSTEMS\u201d, filed of even date herewith and assigned to the assignee hereof.","The present invention generally relates to interconnected heterogeneous data processing systems, and more specifically to reading and writing files by an application on a first system to a disk on a heterogeneous second system.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1","b":["20","20","22","24","26","24","30","32","34","36","37","38","30","32","28","30","32","24","30","32","33","32","30","30"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2","b":["110","120","114","120","114","114","114","112","124","116","112","126","116","122","124"]},"In the preferred embodiment of this invention, the first computer system  is a GCOS\u00ae 8 mainframe system that operates utilizing 36-bit words with either 4 9-bit or 6 6-bit characters per word. The preferred second computer system  is a UNIX system utilizing 8-bit bytes. The preferred UNIX variant is IBM's AIX. One application that is commonly utilized here is the dumping of a database on the GCOS 8 system  to a \u201cflat\u201d file . The \u201cflat\u201d file is then moved as bulk data to a Teradata system  from NCR, where the \u201cflat\u201d file  is loaded into a second database utilizing a \u201cFastLoad\u201d program  from NCR.","There are a number of problems with this implementation. Most notably, it is necessary to write the data twice, once on each system, and read it twice, again, once on each system. In large systems, this overhead can be substantial.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3","b":["116","112","130","110","116","136","112"]},"This functionality is available in some homogeneous computer systems. For example, the Solaris operating system sold by Sun provides a Remote File System functionality that allows an application on a first computer system  to write files  on a second computer system . Microsoft Windows (various levels) also supports similar functionality.","However, this functionality has been limited in the prior art to homogeneous computer systems such as Solaris or Windows. It has not been available between heterogeneous computer systems. There are a number of reasons for this. One reason that this functionality has been limited in prior art systems to homogeneous computer systems is that in such cases, there is no requirement to perform any translation between systems, such as between 9 and 8 bit bytes as required in the preferred embodiment of this invention.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4","b":["130","110","136","112"]},"Another problem encountered when utilizing heterogeneous computer systems is that of synchronizing jobs executing on the two computer systems , . Many variants of UNIX provide the capability to start jobs or tasks on other UNIX systems, to wait for results from the execution of those jobs or tasks, and to receive and act upon those results. However, this capability has not been available in the prior art between heterogeneous computer systems. Some of the problems that have prevented this in the prior art are different formats of data on the two systems, different methods of starting jobs or tasks, and different methods of returning job or task status information. It would thus be advantageous to be able to execute jobs or tasks on a second computer system  started from a first heterogeneous computer system , which then receives the results of that execution when the jobs or tasks complete.","Another problem encountered when utilizing heterogeneous computer systems is that of checkpointing and restarting jobs or tasks operating on. Again, this feature has been present to some extent when operating across multiple homogeneous computer systems, but not across multiple heterogeneous computer systems. Part of the reason for this problem is that each computer architecture involved utilizes its own unique methods of checkpointing and restarting jobs or tasks. It would thus be advantageous to be able to order checkpointing on a second computer system  from a first heterogeneous computer system , and then later optionally restarting the checkpointed job or task on that second computer system .","Bulk data is read or written by an application on a first computer system to a file on a second heterogeneous computer system. Alternatively it is read or written as bulk data directly between applications on these heterogeneous systems. Jobs or tasks are started from one system to execute on a second heterogeneous system, Results are then returned to the first system. Checkpointing and later restarting is also initiated from a first system for execution on the second heterogeneous system.","Returning to , functionality is described hereinbelow that allows an application  on a first computer system  to read data from or write data to a file  on a second heterogeneous computer system . The data is read and\/or written as bulk data, in a similar manner as provided by typical file read and writes. An application  on the second computer system  can then read or write the file . The two computer systems , , may be coupled  by a direct channel connection, such as SCSI or Fiber Channel. Alternatively, the two systems may be coupled utilizing communications links and a communications protocol such as TCP\/IP. Finally (not shown), the two computer systems , , may share memory and utilize message passing between the two computer systems ,  for this transfer.","In the preferred embodiment, a program  in the first computer system  opens one or more files  on the second heterogeneous computer system . The program  then writes to and\/or reads from these files .",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 5","FIG. 3"],"b":["140","110","142","142","140","144","146","112","148","112"]},"This provides an efficient mechanism for bulk transfer data from one computer system  to files on another heterogeneous computer system .","Returning to , functionality is described hereinbelow that allows an application  on a first computer system  to read data from or write data directly to an application  on a second heterogeneous computer system . The data is read and\/or written as bulk data, in a similar manner as provided by typical file read and writes. When the second computer system  is a UNIX system, the application  reading or writing the bulk data typically does so utilizing UNIX pipes. These can be coupled (by standard UNIX command language) to \u2018stdin\u2019 and \u2018stdout\u2019. The two computer systems , , may be coupled  by a direct channel connection, such as SCSI or Fiber Channel. Alternatively, the two coupled utilizing communications links and a communications protocol such as TCP\/IP. Finally (not shown), the two computer systems , , may share memory and utilize message passing between the two computer systems ,  for this transfer.","In the preferred embodiment, a first program  in the first computer system  starts execution of one or more programs  on the second heterogeneous computer system . A first pipe is coupled to \u2018stdin\u2019 on each started program , and a second pipe is coupled to \u2018stdout\u2019 and \u2018stderr\u2019 on each such started program . Then, using the same file read and write interfaces used for remotely reading and writing files in , the first program  writes bulk record data that is read by the started program  via its \u2018stdin\u2019 file, and reads bulk record data that has been written by the started program  on its \u2018stdout\u2019 and \u2018stderr\u2019 files. The two programs ,  receive end-of-file notifications from each other when so indicated. Finally, the started program  provides a result or error code and optionally an error string to the first program  upon completing.","Note that when the second computer system  is a UNIX system, all of the standard UNIX utilities are available for remote execution in this manner. Also, as is typical in UNIX, multiple UNIX utilities can be concatenated together using pipes. The first program  would thus provide input to the first UNIX program, and receive output from the last in the piped chain. Finally note that a single program  on the first system  may have multiple files open on the second system , as well as pipe connections to multiple started programs on that second system. The same interface is utilized for reading and writing all of such.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 6","FIG. 5"],"b":["140","110","142","142","140","144","146","112","147","112","148","112"]},"This provides a mechanism to efficiently transmit bulk record data to\/from an application  executing on a first computer system  from\/to an application  executing on a second heterogeneous computer system .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 7","b":["150","110","142","142","154","154","156","156","158","162","112","162","164","166","160","112","166","112"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 8","b":["150","110","142","142","154","154","152","112","112","168","168","166","160","112","166","112"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 9","b":["150","110","171","160","166","112","181","171","181","170","180","172","182","174","184","158","176","186","152","158","174","110","156","158","162","184","112","152","176","110","167","186","112","167","168","178","112","110","160","166","112","148","188","110"]},"The USL  starts and monitors jobs or tasks on the second system  upon command from the first system . Results of the execution of those jobs or tasks are returned to the first system . This allows applications  on that first system  to control execution of applications  on the second system  in a similar way as applications are controlled in a single system. In the preferred embodiment, both an error code and\/or an error message is returned to the application  on the first system  if the application  on the second system  fails to execute properly. Testing of the error return can allow the application  to determine whether subsequent steps of its execution should be eliminated because of the failure of application  to complete its task.","In the case of checkpoint\/restart, typically the application  on the first system  will perform a checkpoint itself and issue a command that the application  on the second system  also perform a checkpoint. In the case of a UNIX system, this will typically consist of a \u201cflush\u201d followed by recording the position of the file being written or read. Then, if it is necessary to restart the applications , , the first application  with restart itself and rolling back as appropriate and command its peer application  to roll back as required. The information from the previous checkpoint needed to synchronize both applications ,  is saved in a restart file  on the second system .","Another improvement has been made to the prior art. The application  on the first computer system  can specify what data conversions are to be performed by the interface between systems. Since the data transfers between systems is typically on a (blocked) record basis, this data conversion can be selected on a per field basis, and is performed on each selected field in each record transferred. Thus, some fields can be converted automatically from 36-bit integers to 32 bit integers (and potentially reversing the \u201cendian\u201d for the integers at the same time), while other fields can be converted from 9-bit ASCII to 8-bit ASCII.","In the preferred embodiment, a \u201cData Transform Request (DTR) File\u201d (see Appendix A for format of this file) is a parameter to an X_ETL_DEFINEREC API function call and specifies the conversions that are to be performed. In alternate embodiments, this information is specified by other means, such as by Cobol record formats or a database schema or subschema. Also, in other embodiments, this information can be provided in memory instead of as a file. In the preferred embodiment, this conversion is performed on the first system. However, in other embodiments, this conversion can be performed on the second (UNIX) system.","The preferred embodiment of the present invention consists of a GCOS 8 mainframe computer system as the first computer system , and an AIX UNIX computer system as the second computer system . It should be understood that this is illustrative only, and that the present invention includes other heterogeneous computer systems.","The remainder of this document describes the design of a product (\u201cFast ETL\u201d) that allows GCOS 8 applications to send a stream of bulk data to a UNIX system connected via normal TCP\/IP communication links. GCOS 8 applications are provided with an API that can be accessed via Cobol 85. This API allows data to be streamed both to and from GCOS 8. The same API also allows GCOS 8 applications to stream data to or from a DBSP via its SCSI links. This API allows a GCOS application to open multiple files on a UNIX system. It also allows the GCOS application to start multiple programs on the UNIX system. UNIX pipes are connected to \u2018stdin\u2019, \u2018stdout\u2019, and \u2018stderr\u2019 for each started program. The GCOS application can then read and\/or write these UNIX files and pipes interchangeably.","The Fast-ETL system described more fully below is constructed in part utilizing existing Data Base Server Processor (DBSP) code currently being sold by assignee of this invention. More extensive documentation for this product, including documentation for any modules not fully discussed below, is commercially available from assignee upon request. However, this added documentation is not required by persons of ordinary skill in this area of expertise to implement this invention.","1 Overview","1.1 Purpose","This document describes a Fast-ETL system. It discloses a system that allows a mainframe (such as GCOS\u00ae 8 sold commercially by the assignee of this invention) applications to send a stream of data to a UNIX system connected via normal TCP\/IP communication links. It provides that the system provides an API that is accessible via Cobol 85, and that mainframe applications also be allowed to receive a stream of data. Furthermore, this disclosure provides the same data transmission capability with a DBSP via SCSI links.","The UNIX application that is streaming data with the mainframe (GCOS) application may be either a standard UNIX command, a user-written application, or an application provided with the Fast-ETL product. Assignee's application either reads or writes a UNIX file of standard UNIX file format, thereby allowing the mainframe application to either read or write a standard UNIX file. In the other cases, the Fast-ETL system provides a standard UNIX command or the application with a data stream through the UNIX \u2018stdin\u2019 and \u2018stdout\u2019 file descriptors.","1.2 Basic Design Approach","Two APIs are disclosed\u2014a GCOS 8 Cobol 85 API and a UNIX C API. Those APIs are disclosed in more detail below. Run-time procedures are typically bound with the GCOS 8 and UNIX applications using the Fast-ETL service. In the case of Fast-ETL to a normal UNIX system, these procedures use sockets to transmit the data between GCOS 8 and the UNIX system. In the case of Fast-ETL to a DBSP, these procedures use the services of the SID and IO-MAN components of the DBSP product to transfer the data. SID and IO-MAN are enhanced over the existing products from assignee to provide new functions in support of data streaming; these functions are specifically designed to provide better performance for data streaming than the existing message-exchange service.","Since the Fast-ETL system relies upon the services of either sockets or SID to handle data transfers on the mainframe side, the remainder of this document often refers to Fast-ETL as working in the \u2018sockets environment\u2019 or the \u2018SID environment\u2019. However, a Fast-ETL application may use data streams in both environments. Depending upon the environment being used to support a stream, the stream is referred to as a \u2018socket stream\u2019 or a \u2018SID stream\u2019.","In general, the services of Fast-ETL are equally applicable to both the SID and sockets environments The exceptions to this rule are noted below, where the SID environment is more restrictive.","2 Architecture (Highest Level Design)","2.1 Description","Returning to ,  illustrates the major components of Fast-ETL over sockets. The new software components being developed for Fast-ETL are:\n\n",{"@attributes":{"id":"p-0056","num":"0059"},"figref":"FIG. 7","ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["GCOS File Interface Procedure (GFIP)","Unix File Interface Procedure (UFIP)","Unix File Read\/Write Application (UFAP)"]}}}},"The UFAP shown in  is identical to its counterpart in . The GFIP and UFIP components shown in  are similar, but not identical, to their counterparts in . The primary difference between the components in the two FIGs. is that in  the components interface to sockets while in  they interface with SID and IO-MAN.","In , there is no Unix Sockets Listener. The functions of listening for data from GCOS 8 and starting UNIX applications are performed by IO-MAN, an already existing component of the DBSP product. SID and IO-MAN are being enhanced to provide better performance for Fast-ETL.","Use of the Fast-ETL system is the same for both Fast-ETL over Unix and Fast-ETL to the DBSP. Operation of Fast-ETL starts with a user application on GCOS 8. This application uses the Fast-ETL API to open a connection to and start a UNIX application. Once this step is complete, the GCOS 8 application may use one of four modes of operation:\n\n","At any time while the connection is open, either the UNIX or the GCOS 8 application may signal an error condition to its partner using the Fast-ETL API. Also at any time while the connection is open, the GCOS 8 application may use the Fast-ETL API to signal the UNIX application that a commitment or a rollback to a previous commitment point is required. These requests from the GCOS 8 application are NOT tied to GCOS 8 commitments and rollbacks. The following is suggested:\n\n","When a UFAP application receives a Fast-ETL commitment request, it saves restart information in a file in the UNIX user's home directory. The information that it saves in this file includes:\n\n","Either the UNIX or the GCOS 8 application may use the Fast-ETL API to close the connection and terminate the use of the Fast-ETL service. The 166 termination of the connection causes the UNIX application to terminate.","In order to provide a Fast-ETL for RDBC functionality, two GCOS activities are utilized. This solution allows a GCOS application to gather data and write it to a UNIX file using the Fast-ETL API. The second activity that would normally run a Teradata utility that bad been ported to GCOS 8, would now use an RSHELL activity in the GCOS JCL to start and monitor the Teradata utility on the Teradata machine. In this way the RDBC users can move from an environment where execution of the utilities are on GCOS 8 to an environment where the utilities are executed on UNIX but controlled from GCOS 8.","A temporary file is no longer created on GCOS, but is created instead on UNIX using the ETL function. The RDBC utility is started by an RSHELL command that transfers the results of the utility execution back to GCOS for analysis and action.","For Teradata utilities, such as FastExport, that return data to GCOS 8; the two activity GCOS process uses RSHELL in activity one to ran the utility, then a Fast-ETL in activity two to read the data from the UNIX output file and into a GCOS program for storage in a GCOS file.","In moving the data between GCOS 8 and the Teradata UNIX, the Fast-ETL will typically handle data conversions.","RDBC utilities that will be supported include BTEQ, FastLoad, MultiLoad, FastExport, and TPUMP.","2.2 Environment","While the target environment for the UNIX components is any UNIX platform (SUN, HP, BULL), these components are being built and initially tested on Assignee platforms running UNIX.","3 Component Design",{"@attributes":{"id":"p-0069","num":"0087"},"figref":"FIG. 9","ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":["1. GFIP \u2014GCOS File Interface Procedure","2. UFIP \u2014Unix File Interface Procedure","3. UFAP  and UEXEC","4. USL \u2014Sockets Listener"]}},"The existing DBSP components that are being enhanced for Fast-ETL are SID  and IO-MAN .","3.1 GCOS File Interface Procedures (GFIP) ","As  shows, GFIP  and UFIP  are similar in their decomposition and they consist of the sub-components entitled:\n\n","GFIP's ECM  component provides the GCOS 8 user application with the API defined in the Section entitled \u201cEIS","GCOS 8 Cobol-85 API\u201d. ECM  manages the Fast-ETL connections established by an application, creates and responds to records with the record-type codes defined hereinbelow, and uses the services of Record Manager  to block and unblock records.","The remainder of this section uses a number of diagrams that portray the actions taken by GFIP and UFIP for various ETL calls. In these diagrams, the lines with arrows (e.g., ) show when data crosses the socket from GFIP to UFIP or vice versa. These diagrams do not show successful status being returned for an ETL call; the return status is shown only when it is an error or exception status.","3.1.1.1 Open","A transfer between GCOS  and UNIX  is typically initiated by the GCOS application calling X_ETL_OPEN. One of the parameters to this function indicates which direction records are being transferred. The following Table 3.1.1.1 illustrates the interaction between GFIP  and UFIP  for this function: REFER TO .","When records are being sent from UNIX to GCOS, GFIP immediately flushes the buffer containing the open request record (as is shown in the preceding paragraph). However, when records are being sent from GCOS to UNIX, GFIP does not immediately flush the buffer containing the open request record. Instead, it waits until the application performs a subsequent ETL call such as X_ETL_WRITEREC or X_ETL_CLOSE.","There is no response to the open request. The response is not present in order to speed up transfers, especially short ones, If the UNIX application encounters an error processing the open request, the error is reported to the GCOS application when it performs a subsequent ETL call (e.g., X_ETL_CLOSE).","3.1.1.2 Close","The close function terminates a transfer. The close process is started by the node sending records. The close function waits for a response from the other node, so that the sender can verify that all the records sent have been processed successfully.","When GCOS is sending records to UNIX, the GCOS application calls the close function first to indicate the end of the transfer. The following Table 3.1.1.2.1 illustrates the interaction between GFIP  and UFIP  in this case: REFER TO .","When GCOS is receiving records from UNIX, the UNIX application calls the close function first to indicate the end of the transfer. The following Table 3.1.1.2.2 illustrates the interaction between GFIP and UFIP in this case: REFER TO .","3.1.1.3 Abnormal Close","The close function terminates a transfer. The close process is normally started by the node sending records. In case of an error, the receiving node can call close to initiate an abnormal close.","The following Table 3.1.1.3.1 shows an abnormal close occurring while sending data from GCOS to UNIX. REFER TO .","The following Table 3.1.1.3.2 shows an abnormal close occurring while sending data from UNIX to GCOS. REFER TO .","NOTE:",{"@attributes":{"id":"p-0084","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":"When either node sends an error record, that node enters a loop receiving records sent by the other node. While in this loop, records are discarded until the error response record is received.\n\n3.1.1.4 Write Record\n"}}}},"The write record function works in conjunction with the read record function on the other node.","The following Table 3.1.1.4.1 shows the GCOS application sending records to the UNIX application. The write is shown occurring before the read, but this is not required. If the read is executed before the sender has executed a write, the read will be delayed until a record is received (or until the specified timeout occurs). REFER TO .","The following Table 3.1.1.4.2 shows the GCOS application receiving records from the UNIX application. The write is shown occurring before the read, but this is not required. If the read is executed before the sender has executed a write, the read will be delayed until a record is received (or until the specified timeout occurs). REFER TO .","3.1.1.5 Read Record","The read record function works in conjunction with the write record function on the other node. The diagrams in the previous section show this.","3.1.1.6 Execute Command","The following Table 3.1.1.6.1 shows the GCOS application executing a UNIX command: REFER TO .","3.1.1.7 Checkpoint","The following Table 3.1.1.7.1 shows the GCOS application executing a Checkpoint Request. REFER TO .","The following Table 3.1.1.7.2 shows the GCOS application executing a Rollback Request. REFER TO .","3.1.2 Record Manager ","GFIP's Record Manager  component is called by ECM  and provides ECM  with services that are independent of Fast-ETL record-type. These services include:\n\n","getrec\n\n","Record Manager  calls SIDI  when a Fast-ETL connection is established over SCSI hardware to a DBSP. SIDI  calls SID's Send Message and Receive Message functions. SIDI  provides the following functions to Record Manager:\n\n","Record Manager  calls SOCKI  when a Fast-ETL connection is established over TCP\/IP to a UNIX platform. SOCKI  calls the Sockets  functions of Accept, Close, Connect, Send, and Recv. SOCKI  provides the same functions to Record Manager as SIDI , and those functions are described in the preceding section.","3.2 UNIX File Interface Procedures (UFIP)","UFIP  is identical in its design to GFIP , which is described above. The code is not identical because of the following differences:\n\n","This application is used when the records sent to and received from GCOS are to be written to or read from a UNIX file. It supports all three formats described below (i.e. ETLASCII, ETLRAW, ETLBITS). It uses the interface described below. It will be described in the documentation as an example.",{"@attributes":{"id":"p-0098","num":"0135"},"figref":"FIG. 10","b":["210","212","214","216","218","219"]},"3.4 UNIX Sockets Listener (USL) ","The USL  component is a daemon to start application programs on UNIX when requested to by GCOS clients. It is used when the sockets  interface is used. When the SCSI hardware interface is used, IO-MAN  performs the function of starting application programs.","When the UFAP  server is requested, USL  will execute it from the installed location. When a command is to be executed, a Korn shell will be launched to process the command.","The USL  is typically started when UNIX starts and executes continuously. This is usually done by placing an entry in the UNIX\/etc\/inittab file. The ETL installation script typically provides a mechanism to help a user do this. If the USL  aborts for some reason, administrator intervention will be required. There is no interaction between the service processor and the USL .","The USL  requires \u201croot\u201d privilege. This allows it to load and execute each application program as the requested userid. The GCOS userid in use will be sent by GFIP to the USL. The USL will expect to find a UNIX userid of the same name. Its home directory will be made the current directory for the command\/open. In addition, a file must be present in this home directory with the name \u2018.etlhosts\u2019.","The USL will search for an optional file in the home directory, with the name \u2018.environment.etl\u2019. If found, this file will be passed to the KORN shell to establish environment variables for the command.",{"@attributes":{"id":"p-0104","num":"0141"},"figref":"FIG. 11","b":["168","220","222","224","226","168","222","222","228"]},"3.5 Server Interface Domain (SID) ","To support optimal Fast-ETL performance, SID  provides two new functions, Send Message and Receive Message. These functions differ from SID's Pass Messages function, which is the function used to exchange SQL data with a DBSS, in that they do not require a DBSS message for every GCOS message and vice-versa.","Like the Pass Messages function, the Send Message and Receive Message functions do not send the GCOS UNLINK message to IO-MAN . SID sends the GCOS UNLINK message as a result of calls to SID  from GCOS 8's Integrity Control Software. Since UFIP  always tells SID  that the commitment mode is Oracle Mode, SID  sends the GCOS UNLINK message for a Fast-ETL application at end of program for batch or end of transaction for TP8.","SID  does not allow a GCOS application to mix stream (Fast-ETL) and DBSP modes. SID  determines the mode of the application when the application calls SID  for the first time. If the first call to SID  is a Pass Messages call, then SID  classifies the application as a DBSP application and returns an error status if the application subsequently calls its Send Message or Receive Message functions. Similarly, if the first call to SID  is a Send Message or Receive Message call, then SID  classifies the application as a stream application and returns an error status if the application subsequently calls its Pass Messages function.","The interface to SID's Send Message and Receive Message functions is specified below. The remainder of this section provides an operational description of these new functions.","3.5.1 Send Message Function","When its Send Message function is called, SID sends the caller's data in a GCOS_stream message to the designated DBSS. SID does not wait for a response from the DBSS.","SID and the DBSS employ a flow-control mechanism to ensure that a GCOS application does not overflow the buffers of the DBSS when the GCOS application is sending data faster than it can be processed by the DBSS. This flow-control mechanism works as follows.\n\n","Because of this flow-control mechanism, a Send Message caller may be delayed while SID waits for credit. If credit is not received within the caller's timeout period, SID returns to the caller with a timeout status. The Send Message caller may specify a small timeout value (e.g., 5 milliseconds) to prevent a significant delay.","The following four Tables illustrate the message exchanges between SID and IO-MAN when an application is streaming data to a DBSS. If you view this document on your PC, use the page layout view for these diagrams. REFER TO .","Note that the dbsp_credit message can be received in response to any read I\/O performed by SID. If all of SID's users are sending stream data, then SID does not issue a read I\/O until it is close to exhausting its credit for one of the users. SID issues this read I\/O for the sole purpose of obtaining one or more dbsp_credit messages.","3.5.2 The Receive Message Function","When its Receive Message function is called, SID examines its buffers to determine whether it has a dbsp_stream message for the application. If it does, SID returns this message to the application. If not, then SID waits for a dbsp_stream message to be transmitted by the specified DBSS. If this message does not arrive within the caller's timeout period, then SID returns to the caller with a timeout status. The Receive Message caller may specify a very small timeout value (e.g., 5 milliseconds) indicating that it cannot be delayed waiting for a message to arrive.","SID and the DBSS employ a flow-control mechanism to ensure that a DBSS does not overflow SID's buffers when the DBSS is sending data faster than it can be processed by the GCOS application. This flow-control mechanism works like the mechanism for the Send Message function.\n\n","SID typically must buffer multiple messages for an application when a DBSS sends dbsp_stream messages faster than the GCOS application receives them. Because of the credit mechanism, SID is not required to buffer more messages than the number of credits that it has extended to a DBSS. When SID buffers multiple messages for an application, it leaves the messages in their original input buffers and employs fields in the message header to place the messages in a receive queue for the application.","The following four Tables illustrate the message exchanges between SID and IO-MAN when a DBSS is streaming data to a GCOS application. REFER TO .","Table 3.5.2.5 below depicts the interactions between the Fast-ETL components for a GCOS stream (i.e. a data stream going from GCOS 8 to UNIX). REFER TO .","Table 3.5.2.6 below depicts the interactions between the Fast-ETL components for a UNIX stream (i.e. a data stream going from UNIX to GCOS 8). REFER TO .","3.6 DBSP I\/O Manager (IO-MAN)","3.6.1 Link Support","3.6.1.1 Link Change","The typical buffer containing the link request to start a stream is expected to contain more than one GCOS_streaming message following the link request. These GCOS_streaming messages will not have been associated with a linked SC (their DBSP_Token's are zero), so there is no SC to send them to. Previously, if a data message was received with a DBSP_Token of zero, it was treated as an \u201corphan\u201d. It was determined that the existing \u201corphan\u201d processing logic was insufficient because it could handle only one message. The fact that this logic would require some work to handle what is expected to be a common case led to an evaluation of many alternatives.","3.6.1.1.1 Replacement of Orphan Processing with Immediate Queuing","The existing orphan logic in idt.c and scct.c will be replaced. Rather than putting an entry in the orphan list, data messages received without a DBSP_Token will be placed into the appropriate SC message queue.","Table 5.6.1 below for a state transition diagram that depicts the sequence of events for a typical link followed by GCOS_stream messages that have an undefined dbsp token.","3.6.2 Buffer Sequencing Support","Message buffers coming from GCOS will contain a 36 bit sequence number as previously mentioned in the Issues section. Module idt.c, the definition of structure MsgHdr in dct.h and function decoder.c will be expanded to handle the 36 bit number and corresponding rollover potential.","3.6.3 Credit Support","A credit extension will be issued from idut.c to SID once the number of processed messages for the SC equals the issued credit minus 4. For example, if the credit extended to SID is 32, than once 28 messages (predominately GCOS_stream messages) have been processed, idut.c will send a dbsp_credit message with an additional 8 credits (40 total). The reason for sending the credit before it is exhausted is to ensure that SID does not stall and possibly time-out waiting for the credit. Either of those two reactions would be detrimental to performance.","The key variables used to support credit management are: REFER TO .","The input message sequence number is the MsgHdr IgBufSeqNum which is defined in dct.h and decoded from the SID DBSP Protocol Message Header by decoder.c.","3.6.4 GCOS_Stream Message Handling Strategy","The strategy for sending GCOS_stream messages from idt to the ETL SC will differ from other transfers (e.g., data messages). The prior art message passing implementation consists of IDT placing the message header in the SC queue and the message content into shared memory (shared memory 4). The problem is that with this strategy the SC must have visibility to IO_MAN's shared memory 4. With users writing SC stream processing code, this could lead to both accidental and malicious problems.","An efficient solution to getting the GCOS_stream to the SC without using shared memory is to put the entire message in the SC queue. The data content memory is then managed by AIX and IO_MAN's shared memory will not be visible to the SC application's GCOS_stream processing software.","3.6.5 The New IOMI Module","New functions are added to interface the ETL processing logic with IO_MAN in a new module named IOMI. These include:\n\n","Both GFIP and UFIP send a socket header before each buffer. The socket header is shown below in Table 4.1.1: REFER TO .","4.1.2 GFIP\/UFIP Buffer Format","GFIP  and UFIP  block records into buffers for efficiency. In the preferred embodiment, in order to maintain compatibility with the LCB interface, the buffer size is limited to 32 k bytes.","In the preferred embodiment, buffers are defined and exchanged in a 9-bit byte format. This allows GFIP  to be more efficient in GCOS CPU cycles, with the tradeoff being more UNIX CPU cycles.","The buffer format is defined below in Table 4.1.2.1: REFER TO .","Records are NOT split across buffers. Therefore, the maximum record size in bytes that can be accommodated is calculated as follows:",{"@attributes":{"id":"p-0135","num":"0191"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":["Maximum","record","size"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},{"mrow":{"mo":"=","mrow":{"mrow":[{"mn":"64","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"k"},{"mi":["max","SID","hdr"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mi":["ETL","header"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}],"mo":["-","-"]}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mrow":{"mo":"=","mrow":{"mn":["65536","256","128"],"mo":["-","-"]}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mrow":{"mo":"=","mn":"65152"}}]}]}}}},"However, the X_ETL_WRITEREC function and its counterpart on UNIX restrict the amount of data that an application can send in one record to an even 64,000 bytes.","4.1.3 Fast-ETL Record Types","The data exchanged between GFIP and UFIP consists of records, each with a header, supplying its type and length. These records are grouped into a buffer, to improve performance by avoiding a call to SIDI or SOCKI for each record. When the SCSI hardware is used, the buffer built by GFIP or UFIP is encapsulated by SID or IO-MAN respectively, into GCOS Stream Messages and DBSP Stream Messages. These stream messages are described hereinbelow. When the sockets interface is used, GFIP\/UFIP buffers are encapsulated by a socket header.","The following record types are exchanged between GFIP and UFIP:\n\n","The following records are only sent from GFIP to UFIP. They do not normally have a response. An error record can be sent in response if an error occurs.\n\n","The following records are only sent from GFIP to UFIP and have a record defined for a successful response. An error record can be sent instead of the normal response, if an error occurs.\n\n","The following records are only sent from UFIP to GFIP and do not have a response.\n\n","The following records may be sent by either GFIP or UFIP. The Close Request Record and the Error Record have a response; the other records in the list do not.\n\n","Integers are passed between the GCOS and UNIX with the most significant byte sent first with less significant bytes following. This is the natural GCOS byte order. However, other orders are also within the scope of this invention.","\u2018C\u2019 strings in the following definitions are ASCII characters, each in an 8-bit byte. Trailing white space has been truncated and a NULL character terminates the string.","Records have a common header with the following format shown below in Table 4.1.3: REFER TO .\n\n","An Open Request record is sent from GCOS to UNIX when an application calls the X_ETL_OPEN procedure: REFER TO .\n\n","An Execute Request record is sent from GCOS to UNIX when an application calls the X_ETL_EXECUTE procedure. It is utilized to remotely execute commands on a UNIX system from a GCOS system. REFER TO .\n\n","The close request record is only used for connections established by X_ETL_OPEN. It is sent from the sender to the receiver. If the \u2018Open Action\u2019 field in the open request record was ETLWRITE, GCOS is the sender. If it was ETLREAD, Unix is the sender. This record is sent following the data records. REFER TO .","4.1.7 Close Response",{"@attributes":{"id":"p-0149","num":"0000"},"ul":{"@attributes":{"id":"ul0039","list-style":"none"},"li":"A Close Response record is sent by the receiving node when a Close This record is sent by the UNIX server when a Close Request is successfully processed. REFER TO .\n\n4.1.8 Terminate Request\n"}},"The terminate request record is sent by GCOS to UNIX to terminate a command. REFER TO .","4.1.9 Terminate Response","The Terminate Response record is sent by Unix to GCOS when a terminate request has been processed. REFER TO .","4.1.10 Data Record","The GCOS data record contains application data sent from GCOS to UNIX or from UNIX to GCOS. REFER TO .","4.1.11 Checkpoint Request Record","A Checkpoint Request record is sent from GCOS to UNIX. REFER TO .","4.1.12 Checkpoint Response Record","The checkpoint response record is sent from UNIX to GCOS after a checkpoint request is successfully processed. If there is a processing a checkpoint request, an error record is sent instead of a checkpoint response record. REFER TO .","4.1.13 Rollback Request Record","A Rollback Request record is sent from GCOS to UNIX requesting a rollback. REFER TO .","4.1.14 Rollback Response Record","A Rollback Response record is sent from UNIX to GCOS after a Rollback Request is successfully processed. If an error is encountered processing a Rollback Request, an Error Record is sent instead of a Rollback Response record. REFER TO .","4.1.15 Error Record","An Error record is sent when an error has been encountered. These are discussed above. REFER TO .","The Error Source is defined as:",{"@attributes":{"id":"p-0158","num":"0000"},"ul":{"@attributes":{"id":"ul0040","list-style":"none"},"li":{"@attributes":{"id":"ul0040-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0041","list-style":"none"},"li":["1 UFIP","2 UFAP","3 UEXEC","4 AIX\n\nAn Error Code is a 4 byte integer. The following statuses are recognized by both nodes, and translated to the status appropriate for the node:\n","1 no checkpoint for rollback request","2 connection closed prematurely","3 executable not found","4 executable not executable (e.g. insufficient permission)\n\n4.1.16 Error Response Record\n"]}}}},"The error response record is sent to acknowledge an error record. REFER TO .","4.1.17 EOF Record","The EOF record is used only for connections established by X_ETL_EXECUTE. GCOS sends this record type to UNIX to close stdin. UNIX sends it to GCOS to close stdout. There is no EOF response record. REFER TO .","4.2 Fast-ETL Message Types","SID and IO-MAN utilize four new message types to support Fast-ETL. These message types are:\n\n","The Restart Information File is used only for connections established by X_ETL_OPEN. This file is used by UFAP to process \u2018X_ETL_CHECKPOINT\u2019 and \u2018X_ETL_ROLLBACK\u2019 requests from the GCOS client. It is located in the following directory:\n\n","The \u2018base file name\u2019 is the first 24 characters of the AIX file name after removing leading directory names. If necessary to ensure uniqueness, a sequence number is added to the base file name to produce the file name. The \u2018sequence number\u2019 is a decimal number consisting of eight ASCII digits.","Whenever Restart Information File is used, the path name contained within it (see Table 4.3.1) must be compared to be sure that the correct file is being accessed. REFER TO .\n\n","This section specifies the GCOS 8 Cobol-85 interface for the Fast-ETL product. The interface provides a record oriented connection between the programs using it. The program on GCOS 8 acts as a client, and the Fast-ETL program on UNIX acts as a server.","5.1.1 Copy File","The copy file \u2018ETL_DATA_H\u2019 contains the following definitions in Table 5.1.1: REFER TO .","5.1.2 GCOS Status Return Structure and Codes","GFIP (GCOS File Interface Procedures) is the name of the software component of the ETL product that provides the GCOS API for ETL, GFIP returns status to the caller in the ETL-STATIJS-RTN structure, which is located in the copy file described in Section A.1.1. This structure follows the format defined for Virtual Mode Programmatic Services (VMPS). Specifically, it follows the format identified as \u2018unpacked\u2019 in the VMPS Reference Manual (LC35). The remainder of this section describes the individual fields of the ETL-STATUS-RTN structure.","GFIP uses the ETL-PRIMARY-STATUS field to report the overall result of the call to the ETL function. GFIP sets ETL-PRIMARY-STATUS to one of three values:","1. Service Successful (a value of 0)","2. Service Exception (a value of 2)","3. Service Failed (a value of 3)\n\n","Table 5.1.2 below shows all the codes that GFIP stores in the ETL-PRIMARY-STATUS, ETL-IMMD-MAJOR, and ETL-IMMD-MINOR fields. GFIP also places the major and minor codes shown in Table 5.1.2 in the ETL-ORIG-MAJOR and ETL-ORIG-MINOR fields whenever it places \u2018AFTA\u2019 in ETL-ORIG-FCGI. REFER TO .","5.1.3 Open","CALL \u201cX_ETL_OPEN\u201d USING ETL-STATUS-RTN,\n\n","This procedure is one of two (X_ETL_EXECUTE is the other) that establish a connection to a server on UNIX. This procedure establishes a connection to the UNIX file server (UFAP) using the sockets interface.","The connection established by this procedure is a uni-directional connection used to read or write UNIX files from a GCOS program. Subsequent READ, or WRITE procedures get data from or put data to the specified UNIX file. The direction supported by a connection (i.e. read or write) is determined by the ETL-OPEN-ACTION parameter. Each invocation of this procedure starts a new instance of the file server, and the UNIX file specified will be created or accessed.","The \u201cX_ETL_OPEN\u201d procedure blocks execution until a connection is established or an error occurs.","ETL-STATUS-RTN\n\n","ETL-FILE-ID\n\n","ETL-PARAMETER-BLOCK\n\n","ETL-PATHNAME\n\n","Status codes returned by X_ETL_EXECUTE include: REFER TO .","5.1.4 Execute","CALL \u201cX_ETL_EXECUTE\u201d USING ETL-STATUS-RTN,\n\n","This procedure is one of two (X_ETL_OPEN is the other) that establish a connection to a server on UNIX. This procedure establishes a connection to a UNIX shell using the sockets interface.","The connection established by this procedure is a bi-directional connection used to interact with a specified UNIX command. X ETL_WRITEREC procedures executed for this connection send data to the re-directed standard input of the command. X_ETL_READREC procedures executed for this connection will obtain data from the re-directed standard output of the command.","The GCOS application obtains data written to stderr by calling X_ETL_READREC just as it does for data written to stdout. ETL software indicates that a record is from stderr instead of stdout by applying a prefix of \u2018*ETL*E\u2019 to the data from stderr.","Each invocation of X_ETL_EXECUTE starts a new instance of a UNIX shell to execute the specified command.","The connection established by this procedure uses a single ETL-FILE-ID to refer to stdin, stdout, and stderr for the UNIX command. Normally, X_ETL_CLOSE is called to close stdin after all data intended for stdin has been sent with calls to X_ETL_WRITEREC. This causes the UNIX command to receive an end-of-file for stdin. X_ETL_TERMINATE is called after an end-of-file is received from calling X_ETL_READREC for this connection.","The \u201cX_ETL_EXECUTE\u201d procedure blocks execution until a connection is established or an error occurs.","ETL-STATUS-RTN\n\n","ETL-FILE-ID\n\n","ETL-PARAMETER-BLOCK\n\n","ETL-COMMAND\n\n","Status codes returned by X_ETL_EXECUTE include: REFER TO .","5.1.5 CLOSE","CALL \u201cX_ETL_CLOSE\u201d USING ETL-STATUS-RTN,\n\n","This procedure closes a connection identified by ETL-FILE-ID and begun with a call to either X_ETL_OPEN or X_ETL_EXECUTE.","ETL-STATUS-RTN\n\n","ETL-FILE-ID\n\n","ETL-FILE-JD is used to access three files (stdin, stdout, and stderr). X_ETL_CLOSE may be used only to close stdin. The call to X_ETL CLOSE causes the UNIX command to receive an end-of-file for stdin. The GCOS program normally calls X_ETL_CLOSE after it has sent all data intended for stdin via calls to X_ETL_WRITEREC.","After calling X_ETL_CLOSE, the GCOS program normally calls X_ETL_READREC to receive the data that the UNIX command writes to stdout and stderr. When X_ETL_READREC returns an end-of-file indication for stdout, the GCOS program would then call X_ETL_TERMINATE to end the connection.","X_ETL_CLOSE does not wait for any response from the server when the connection is established by X_ETL_EXECUTE. Any errors reported by the server are handled when the GCOS program calls X_ETL_READREC.","The call to X_ETL_CLOSE may be omitted for a connection established by X_ETL EXECUTE. In this case, X_ETL_TERMINATE closes stdin. When X_ETL_TERMINATE is used to close stdin, the GCOS program is not given the opportunity to receive any data written by the UNIX server to stdout or stderr. So, the GCOS program should use X_ETL_CLOSE if it is interested in receiving any data written by the UNIX server.","Status Codes:","Status codes returned by X_ETL CLOSE include: REFER TO .","5.1.6 Terminate","CALL \u201cX_ETL_TERMINATE\u201d USING ETL-STATUS-RTN,\n\n","ETL-COMMAND-STATUS.","This procedure closes stdin immediately, unless stdin has already been closed by a previous call to X_ETL_CLOSE. It then waits for the command to terminate. If the command does not terminate (which is indicated by an end-of-file for stdout) within the time specified by ETL-MAX-TIME, this procedure terminates the command forcefully.","This procedure blocks execution until the server program responds with a status indicating that it has completed, until an error occurs, or until the specified time has elapsed.","ETL-STATUS-RTN\n\n","ETL-FILE-ID\n\n","ETL-MAX-TIME\n\n","ETL-COMMAND-STATUS\n\n","Status codes returned by X_ETL_TERMINATE include: REFER TO .","5.1.7 Write a Record","CALL \u201cX_ETL_WRITEREC\u201d USING ETL-STATUS-RTN.\n\n","This procedure sends a record to the UNIX server program. X_ETL_WRITEREC moves the record located in \u2018ETL-record\u2019 into a collection buffer for the connection. The collection buffer is sent to the server when one of the following occurs:\n\n","The number of bytes sent from \u2018ETL-record\u2019 is specified by the ETL-REC-LENGTH parameter.","This procedure does not normally block execution. X_ETL_WRITEREC returns to the caller after placing the record in a collection buffer. If the buffer is full and cannot be written (e.g. the server is not reading records for some reason), this function waits until one of the following occurs:\n\n","ETL-STATUS-RTN\n\n","ETL-FIELD\n\n","ETL-REC-LENGTH\n\n","ETL-RECORD\n\n","Status codes returned by X_ETL_WRITEREC include: REFER TO .","5.1.8 Read a Record","CALL \u201cX_ETL_READREC\u201d USING ETL-STATUS-RTN,\n\n","This procedure gets a record sent by the server program. The maximum number of bytes that may be returned is specified by the \u2018length of ETL-buffer\u2019 parameter. The number of bytes returned in the record is in ETL-RETURNED-LENGTH. A return length value of zero bytes means that the server sent a zero-length record.","If a record is not available, execution is blocked until the server program returns a record or until a timeout\/error occurs.","This procedure returns the status ETLEOF (end-of-file) only after all of the records sent by the server program have been read. Since X_ETL_READREC also generates an exception condition if and only if it returns the end-of-file status, GCOS programs may supply the optional \u2018ON EXCEPTION\u2019 clause to control the processing of end-of-file.","ETL-STATUS-RTN\n\n","ETL-FILE-ID\n\n","Length of ETL-buffer\n\n","ETL-Buffer\n\n","ETL-RETURNED-LENGTH\n\n","Status codes returned by X_ETL_READREC include: REFER TO .","5.1.9 Checkpoint","CALL \u201cX_ETL_CHECKPOINT\u201d USING ETL-STATUS-RTN,\n\n","This procedure causes an ETL-CHECKPOINT-BLOCK to be sent to the UNIX server program. This data is saved by UFAP so that it can be returned in response to a subsequent call to X_ETL_ROLLBACK. When the UNIX server is a customer application, that application is responsible for saving the data along with sufficient information to re-establish the current data-processing state. The ETL-CHECKPOINT-BLOCK can be used to help restart execution following a program failure, communications failure, disk failure, etc. There is no relationship between GCOS commits\/rollbacks and this capability.","The X_ETL_CHECKPOINT procedure may be executed on any connection established by X_ETL OPEN. If X_ETL_EXECUTE was used to establish the connection, then user written software on UNIX must respond to checkpoint and rollback requests.","Execution is blocked until either the server program returns success or an error occurs.","The GCOS application and the UNIX server must cooperate to accomplish the checkpoint and a subsequent rollback. UFAP does this for reading and writing files on UNIX. The user application on GCOS cooperates by restarting at the appropriate point.","ETL-STATUS-RTN\n\n","ETL-FILE-ID\n\n","ETL-CHECKPOINT-BLOCK\n\n","Status codes returned by X_ETL_CHECKPOINT include: REFER TO .","5.1.10 Rollback","CALL \u201cX_ETL_ROLLBACK\u201d USING ETL-STATUS-RTN,\n\n","This procedure retrieves ETL-CHECKPOINT-BLOCK from the last successful checkpoint. This information would normally be used to restart execution following a program failure, communications failure, disk failure, etc. There is no relationship between GCOS commits\/rollbacks and this capability. Both need to be considered by the programmer independently.","The X_ETL_ROLLBACK procedure may be executed on any connection established by X_ETL_OPEN. If X_ETL_EXECUTE was used to establish the connection, then the software on UNIX must respond to checkpoint and rollback requests.","Execution is blocked until either the server program returns success or an error occurs.","The GCOS application and the UNIX server must cooperate to accomplish a checkpoint and a subsequent rollback. UFAP does this for reading and writing files on UNIX. The application on GCOS cooperates by restarting at the appropriate point.","ETL-STATUS-RTN\n\n","ETL-FILE-ID\n\n","ETL-CHECKPOINT-ID\n\n","ETL-CHECKPOINT-BLOCK\n\n","Status codes returned from X_ETL_RESTART are:","Status Codes:","Status codes returned by X_ETL_RESTART include: REFER TO .","5.1.11 Define Records","CALL \u201cX_ETL_DEFINEREC\u201d USING ETL-STATUS-RTN,\n\n","This procedure assigns a record definition to the connection identified by ETL-FILE-ID. The record definition specifies the data conversions that subsequent X_ETL_READREC and X_ETL_WRITEREC procedures perform.","The specified GCOS file is read to obtain a record definition. The record definition conforms to that described in the RDBC Data Warehouse manuals available from Assignee. The textual record definition is parsed and used to define the conversions that read and write will use.","This procedure does not communicate with the UNIX server, and so always returns immediately. It causes subsequent procedures for the specified connection to behave differently.","ETL-STATUS-RTN\n\n","ETL-FILE-ID\n\n","ETL-PATHNAME\n\n","Status codes returned from X_ETL_DEFINEREC are:","Status Codes:","Status codes returned by X_ETL_DEFINEREC include: REFER TO .","Both the description of the format of ETL-PATHNAME and the list of status codes are incomplete. The processing of this function is mainly being performed by RDBC-related software that is distinct from the general ETL software. Further documentation is commercially available from Assignee of this invention.","5.1.12 Connection States and State Transitions","Tables 5.1.12.1 and 5.1.12.2 show the connection states and the state transitions that occur when ETL functions are executed.\n\n","Two general rules apply that are not explicitly shown in the tables.\n\n","The state transitions caused by the end-of-file status are explicitly shown in the three tables.","The conventions followed in Tables 5.1.12.1 and 5.1.12.2 are as follows:",{"@attributes":{"id":"p-0263","num":"0000"},"ul":{"@attributes":{"id":"ul0152","list-style":"none"},"li":["1. Items in parentheses, ( ), represent input parameters to the called function.","2. Items in brackets, [ ], represent status values returned to the caller of the function. When no brackets are shown, successful status is implied.","3. The number in a table element identifies the state that the ETL connection enters at the completion of the call.","4. Table elements containing \u2018X\u2019 represent states in which the function is invalid.","5. Table elements containing \u2018\/\u2019 represent situations which cannot occur.","6. Table elements containing \u2018=\u2019 represent situations where no state transition occurs; i.e., the state of the connection does not change as a result of the execution of the function.","7. \u2018eof\u2019 stands for the end-of-file status. The end-of-file status code is:\n    \n    ","8. \u2018error\u2019 stands for any status other than successful.","9. \u2018fatal error\u2019 stands for any error with a major status of either ETLSVCERR (value=2) or ETLINTERR (value=3). REFER TO .\n\n5.2 UNIX API\n"]}},"The stdin, stdout, and stderr files provide the UNIX interface for ETL. UNIX applications receive records from the GCOS application by reading stdin. UNIX applications send records to the GCOS application by writing to stdout and stderr. While ETL software passes data written to stdout to the GCOS application without change, ETL software attaches a prefix of \u2018*ETL*E\u2019 to data written to stderr before passing it to the GCOS application.","If a GCOS application uses the X_ETL_CHECKPOINT and X_ETL_ROLLBACK functions, then the UNIX application must deal with prefixes on the records pertaining to those functions. The prefix characters shown in Table 5.2.1 are used. REFER TO .","The following rules apply to all records with a prefix:",{"@attributes":{"id":"p-0266","num":"0000"},"ul":{"@attributes":{"id":"ul0154","list-style":"none"},"li":{"@attributes":{"id":"ul0154-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0155","list-style":"none"},"li":["The Checkpoint Request record that the UNIX application receives consists of the \u2018*ETL*C\u2019 prefix followed by the data provided by the GCOS application in ETL-CKPT-DATA.","The Checkpoint Response record that the UNIX application sends in response to the checkpoint request record consists solely of the \u2018*ETL*C\u2019 characters.","The Rollback Request record that the UNIX application receives consists solely of the \u2018*ETL*R\u2019 characters.","The data that a UNIX application places after the \u2018*ETL*R\u2019 prefix of the rollback response record is passed to the GCOS application in ETL-CKPT-DATA.\n\n5.3 UNIX Internal Interface\n"]}}}},"This section specifies an internal interface for the UNIX portion of the Fast-ETL product. This interface is the interface to UFIP that is used by UFAP and UEXEC.","5.3.1 Include File","The include file \u2018ETLUxInterface.h\u2019 contains the prototypes for the functions specified here and the following constants:",{"@attributes":{"id":"p-0269","num":"0510"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":["ETLWRITE","A","Records will be sent by the GCOS client"]},{"entry":["ETLREAD","B","Records will be received by the GCOS client"]},{"entry":["ETLASCII","C","Records are exchanged in ASCII mode."]},{"entry":["ETLRAW","D","Records are exchanged in 8 out of 9 mode."]},{"entry":["ETLBITS","E","Records are exchanged in binary mode."]},{"entry":["ETLMQUE","F","Configure a UNIX message queue"]},{"entry":["ETLSDFLT","G","Configure the default port"]},{"entry":["ETLSREQP","H","Configure the specified port"]},{"entry":["ETLSSRCH","I","Search for an available port"]},{"entry":["ETLSSOCK","J","Use an already connected socket"]},{"entry":"Error Codes"},{"entry":["ETLTooMany","\u2212A","Too many connections are in use."]},{"entry":["ETLUnknownID","\u2212B","Invalid Connection ID."]},{"entry":["ETLNoPortsAvail","\u2212C","No ports available."]},{"entry":["ETLPortNotAvail","\u2212D","The specified port is not available."]},{"entry":["ETLEndOfFile","\u2212E","All records have been sent."]},{"entry":["ETLUnexpClose","\u2212F","Unexpected call to ETLClose."]},{"entry":["ETLDisconnect","\u2212G","The client has disconnected."]},{"entry":["ETLNotAllowed","\u2212H","Operation is not allowed for this connection."]},{"entry":["ETLSockErr","\u2212I","Error from socket routine."]},{"entry":["ETLTooLarge","\u2212J","Record is too large."]},{"entry":["ETLTimeout","\u2212K","Specified time has expired."]},{"entry":["ETLNoInterrupt","\u2212L","No interrupt is present."]},{"entry":["ETLPathTooLong","\u2212M","path name from the GCOS client is too long for"]},{"entry":[{},{},"the buffer"]},{"entry":["ETLInfoTooLong","\u2212N","the open file info from the GCOS client is too"]},{"entry":[{},{},"large for the buffer."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0156","list-style":"none"},"li":"Constants \u201cA\u201d through \u201cN\u201d are arbitrary constants assigned by the implementers. The standard \u201cC\u201d convention of utilizing negative numbers as error codes is utilized here, but is not required to practice this invention.\n\n5.3.2 ETLInitConnection\n"}},"int ETLInitConnection (int connMode,\n\n","ETLMQUE configure a UNIX message queue","ETLSDFLT configure the default port","ETLSREQP configure the specified port","ETLSSRCH search for an available port","ETLSSOCK use an already connected socket","When successful, a positive connection ID is returned, and if the sockets interface was requested, the port number configured is stored in \u2018returnedPortNo\u2019 (except for ETLSSOCK mode). The connection ID is used in subsequent calls, including ETLAcceptOpen.","This function does not block. When an error occurs, a negative error code is returned:","ETL TooMany Too many connections are in use.","ETLNoPortsAvail No ports available.","ETLSockErr Error from socket routine.","5.3.3 ETLAcceptOpen",{"@attributes":{"id":"p-0281","num":"0000"},"ul":{"@attributes":{"id":"ul0159","list-style":"none"},"li":"int ETLAcceptOpen (int connectionID, int maxTime);"}},"This function listens on the port established for the specified connection by a previous call to \u2018ETLGetPort\u2019 or \u2018ETLSetPort\u2019. The function blocks until a connection is established from a client program, or until the specified time has passed. The \u2018maxTime\u2019 parameter is the maximum number of milliseconds to wait. A value of zero specifies no timeout, i.e. the function will return immediately unless an open request has already been received from the client.","When successful, this function returns zero.","When an error occurs, a negative error code will be returned:",{"@attributes":{"id":"p-0285","num":"0531"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ETLInvalidID","Invalid Connection ID."]},{"entry":[{},"ETLDisconnect","The client has disconnected."]},{"entry":[{},"ETLSockErr","Error from socket routine"]},{"entry":[{},"ETLTimeout","Specified time has expired."]},{"entry":[{},"ETLPathTooLong","path name from the GCOS client is too long"]},{"entry":[{},{},"for the buffer"]},{"entry":[{},"ETLInfoTooLong","the open file info from the GCOS client is"]},{"entry":[{},{},"too large for the buffer."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"int ETLReadRecord (int connectionID,\n\n","This function returns the next record sent by the client. If one is not available, it blocks until a record is sent by the client, or until the \u2018maxTime\u2019 has expired (in milliseconds). A value of zero specifies no timeout, i.e. the function will return immediately unless a record has already been received from the client. The maximum number of bytes that can be received is specified by the \u2018bufferSize\u2019 parameter.","If the buffer supplied is too small to contain the record sent, \u2018ETLTooLarge\u2019 will be returned, the first \u2018bufferSize\u2019 bytes of the record will be put into \u2018buffer\u2019 and the remainder is discarded. The next call to this function will return the next record; i.e. there is no mechanism to obtain the truncated portion of a record.","Each byte put into the \u2018buffer\u2019 parameter will contain the least significant 8 bits of each byte sent from GCOS. In other words, the most significant bit of each GCOS byte is thrown away when obtained by this function. Data is put into the buffer in the same order as it exists in GCOS memory.","When successful, this function returns the number of bytes in the record received. A return value of zero means that the client sent a zero-length record. This function returns ETLEndOfFile only after all of the records sent by the client have been read. The integer pointed to by \u2018retRecType\u2019 is set to the record type retrieved when successful.","When an error occurs, a negative error code will be returned:",{"@attributes":{"id":"p-0292","num":"0543"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ETLInvalidID","Invalid Connection ID."]},{"entry":[{},"ETLDisconnect","The client has disconnected."]},{"entry":[{},"ETLNotAllowed","This operation is not allowed for this"]},{"entry":[{},{},"connection."]},{"entry":[{},"ETLSockErr","Error from socket routine"]},{"entry":[{},"ETLTooLarge","Record is too large."]},{"entry":[{},"ETLEndOfFile","All records have been sent."]},{"entry":[{},"ETLTimeout","Specified time has expired."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"int ETLWriteRecord (int connectionID,\n\n","This function sends a record to the GCOS client. It will not normally block, but the socket routines that it uses may cause delays. The number of bytes sent is specified by the \u2018writeSize\u2019 parameter. A \u2018writeSize\u2019 of zero is valid, and will cause the client to receive a zero length record.","Each byte sent from the \u2018buffer\u2019 parameter will be put into the least significant 8 bits of each byte in GCOS memory. The most significant bit of each GCOS byte is will be set to zero. Data is put into GCOS memory in the same order as it exists in the \u2018buffer\u2019 parameter. The \u2018recType\u2019 parameter specifies the record type to send.","When successful, this function returns zero. When \u2018ETLUnexpClose\u2019 is returned, this means the client has called \u2018ETLClose\u2019 before receiving all the records. When an error occurs, a negative error code will be returned:",{"@attributes":{"id":"p-0297","num":"0551"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ETLInvalidID","Invalid Connection ID."]},{"entry":["ETLDisconnect","The client has disconnected."]},{"entry":["ETLNotAllowed","This operation is not allowed for this connection."]},{"entry":["ETLSockErr","Error from socket routine"]},{"entry":["ETLTooLarge","Record is too large."]},{"entry":["ETLUnexpClose","Unexpected call to ETLClose."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"int ETLClose (int connectionID,\n\n","This function closes the file begun with the \u2018ETLAcceptOpen\u2019 function. This function will not return until the client program executes a corresponding close function, or until the specified \u2018maxTime\u2019 (in milliseconds) has expired. A value of zero specifies no timeout, i.e. the function will return immediately unless a close has already been sent by the GCOS client","If this connection is sending (\u2018ETLAcceptOpen\u2019 returned \u2018ETLREAD\u2019 for the \u2018returnedOpenAction\u2019 parameter), any partial buffers will be flushed and sent. An end of file indication will be sent to the client.","If this connection is receiving (\u2018ETLAcceptOpen\u2019 returned \u2018ETLWRITE\u2019 for the \u2018returnedOpenAction\u2019 parameter), any records sent by the client, but not received by calls to \u2018ETLReadFile\u2019 will be discarded.","If \u2018errorMesg\u2019 is non-NULL, the client will receive a status of ETLCONNERR, and the text in \u2018errorMesg\u2019 will be supplied to the client. When successful, this function returns zero. When an error occurs, a negative error code will be returned:",{"@attributes":{"id":"p-0303","num":"0559"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ETLInvalidID","Invalid Connection ID."]},{"entry":[{},"ETLDisconnect","The client has disconnected."]},{"entry":[{},"ETLSockErr","Error from socket routine"]},{"entry":[{},"ETLTimeout","Specified time has expired."]},{"entry":[{},"ETLUnexpClose","Unexpected call to ETLClose."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Normally, the sending node (the node issuing writes) will call close after all the records to be sent have been written. This will cause the receiving node to get an end-of-file status after all the records have been read. The receiving node then calls close to notify the sending node that all of the records have been successfully received. The close functions in both nodes then receive a zero status.","If the receiving node calls close before a close has been received from the sending node, the data will potentially be truncated. The close functions in both nodes will receive an \u2018ETLUnexpClose\u2019 status in this case. The receiving node can use this mechanism to prematurely end a transfer.","6 SID Interface","6.1 Send Message Interface","GFIP calls SID's Send Message function to send a block of data to a DBSP that provides the Fast-ETL service. The Send Message interface is similar to the interface to SID's Pass Messages function, which is the function originally defined for exchanging data with a DBSP. The interfaces differ primarily in that the Send Message interface does not provide for an input buffer parameter. The Send Message call is shown below.","Calling Sequence","ICLIMB \u2018S$DBSP_APP_SVC\u2019,4","Input Parameters (Via Parameter Stack)",".PS+0=V Block",".PS+1=R Block",".PS+2=Surrogate Client ID",".PS+3=Output Buffer","6.1.1 V Block Parameter Refer to .","Version Number","The version number for the Send Message function has a value of 19980901.","Function Code","The function code for the Send Message function has a value of two.","Output Buffer Size\n\n","Maximum Delay Time\n\n","FCGI\n\n","Sub-Function\n\n","Major Status\n\n","Minor Status\n\n","Error Message Line Length\n\n","Number of Error Message Lines\n\n","Error Message Area\n\n","DBSS Name\n\n","Application Name\n\n","Executable Name\n\n","Commitment Mode\n\n","Command Name\n\n","HA Preference\n\n","File ID\n\n","ICLIMB \u2018S$DBSP_APP_SVC\u2019,5","Input Parameters (Via Parameter Stack)",".PS+0=V Block",".PS+1=R Block",".PS+2=Surrogate Client ID",".PS+3=Null",".PS+4=Input Buffer","6.2.1 V Block Parameter Refer to .","Version Number","The version number for the Receive Message function has a value of 19980901.","Function Code","The function code for the Receive Message function has a value of three.","Input Buffer Size","Input Buffer Size specifies the size in words of the buffer where SID places the message from the DBSP. The valid range for Input Buffer Size is 0 to 8128 inclusive.","Maximum Delay Time","Maximum Delay Time specifies the maximum amount of time that the caller is willing to be delayed while SID waits for a DBSP message. The Maximum Delay Time is an unsigned binary number that is in units of tenths of a millisecond. Values less than 50 are treated as if they are equal to . Times greater than 24 hours mean wait forever.","6.2.2 R Block Parameter","The R Block Parameter for the Receive Message function is identical to that of the Send Message function, described above.","6.2.3 Surrogate Client ID Parameter","The Surrogate Client ID Parameter for the Receive Message function is identical to that of the Send Message function; described above.","6.2.4 Input Buffer Parameter","This parameter locates the buffer where SID places the message from the DBSP.","7 Example USAGE","The following examples use a pseudo-code notation, to show how a Cobol  application would use the GCOS API. Many of the details are omitted, but would be obvious to a person reasonably skilled in this area.","7.1 UNIX Command Needs No Input, Ignore Output","ETLexecute using \u201cmkdir\/home\/dbsp\/ . . . \u201d","ETLterminate maxTime=30 sec.\u2014closes stdin, stdout; cleans up ETL on both sides","7.2 UNIX Command Needs No Input; Display Output","ETLexecute using \u201cIs-al\/home\/dbsp\/ . . . \u201d while (not eof)\n\n","ETLterminate maxTime=\u2014closes stdin, stdout; cleans up ETL on both sides","7.3 UNIX Command Needs Input, Ignore Output","ETLexecute using \u201csort>otfile\u201d while (not eof)\n\n","ETLterminate maxTime=30 sec.\u2014closes stdin, stdout; cleans up ETL on both sides","7.4 UNIX Command Needs Input, Display Output","ETLexecute using \u201csort\u201d while (not eof)\n\n","ETLClose\u2014close stdin while (not eof)\n\n","ETLterminate maxTime=0\u2014closes stdout; cleans up ETL on both sides","7.5 Bulk Load, Separate File","ETLopen \u201c\/home\/dbsp\/input\u201d while (not eof)\n\n","ETLclose","ETLexecute using \u201cfastload . . . \u201d while (not eof)\n\n","ETLClose\u2014close stdin while (not eof)\n\n","ETLterminate maxTime=0\u2014closes stdout; cleans up ETL on both sides","7.6 Interactive Command",{"@attributes":{"id":"p-0357","num":"0000"},"ul":{"@attributes":{"id":"ul0214","list-style":"none"},"li":{"@attributes":{"id":"ul0214-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0215","list-style":"none"},"li":["ETLexecute using \u201cftp . . . \u201d","ETLwrite \u201cmode binary\u201d","ETLread . . . \u2014get prompt","ETLwrite \u201csend<file-name>\u201d","ETLread . . . \u2014get prompt","ETLwrite \u201cquit\u201d","ETLTerminate maxTime=0"]}}}},"Those skilled in the art will recognize that modifications and variations can be made without departing from the spirit of the invention. Therefore, it is intended that this invention encompass all such variations and modifications as fall within the scope of the appended claims.","Claim elements and steps herein have been numbered and\/or lettered solely as an aid in readability and understanding. As such, the numbering and\/or lettering in itself is not intended to and should not be taken to indicate the ordering of elements and\/or steps in the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The features and advantages of the present invention will be more clearly understood from the following detailed description taken in conjunction with the accompanying FIGURES where like numerals refer to like and corresponding parts and in which:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 12\u201368"}]},"DETDESC":[{},{}]}
