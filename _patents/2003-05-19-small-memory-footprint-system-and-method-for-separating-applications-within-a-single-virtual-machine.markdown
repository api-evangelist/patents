---
title: Small memory footprint system and method for separating applications within a single virtual machine
abstract: A system and method for isolating the execution of a plurality of applications. The applications may utilize or share one or more “original” classes. Only one copy of each original class is maintained, regardless of how many applications utilize it. Static fields are extracted from the original classes. A separate copy of the static fields is created for each of the utilizing applications. A static field class which includes instance fields corresponding to the static fields may be created, wherein each instance of the static field class corresponds to one of the utilizing applications. Access methods for the one or more static fields may be created, wherein the access methods are operable to access the corresponding separate copy of the static fields based upon the identity of the utilizing application. A single access methods class may be created for each original class, wherein the single access methods class includes the access methods for accessing the extracted fields from the original class. The method and system may be optimized by exempting from extraction static fields that are classified as secure for utilization by the plurality of applications without inter-application interference. The secure set of static fields may include final static fields of primitive types, final static strings, immutable arrays of primitive types, and/or other appropriate fields.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06938247&OS=06938247&RS=06938247
owner: Sun Microsystems, Inc.
number: 06938247
owner_city: Santa Clara
owner_country: US
publication_date: 20030519
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation application of U.S. patent application Ser. No. 09\/513,291, filed Feb. 25, 2000 now U.S. Pat. No. 6,567,974.","1. Field of the Invention","The present invention relates generally to computer software. More particularly, the present invention relates to the efficient isolation of applications executing concurrently in a multi-processing environment.","2. Description of the Relevant Art","The growing popularity of the platform-independent programming language Java\u2122 has brought about an increased need for executing multiple Java\u2122 applications co-located on the same computer. Ideally, such applications should be protected from one another. In other words, an application should not be able to corrupt the data of another, and the application should not be able to prevent another application from performing its activities. At the same time, marginal systems resources needed to start new Java\u2122 applications should be as small as possible so that the number of concurrently executing applications can be as high as possible.","One approach to Java\u2122 multiprocessing is to rely on the operating system (OS) for protection. Typically, this means running multiple copies of the Java\u2122 Virtual Machine (JVM), one per application, starting each application in a separate copy of the JVM, which effectively is spawning a new operating system process for each application. This provides a strong process-level separation in that applications are totally isolated from one another (although they can communicate, for instance, via sockets, RMI, etc), but uses large amounts of resources in terms of virtual memory and startup time, and makes inter-application communication expensive. In addition, this approach tends to scale poorly.","A project at the University of Utah resulted in two variants of Java\u2122 operating systems which demonstrate how a process model can be implemented in Java\u2122 and how an underlying OS protection can be exploited for Java\u2122 multiprocessing. See Back, G., Tullmann, P., Stoller, L., Hsieh, W., and Lepreau, J., , Technical Report UUCS-98-015, Department of Computer Science, University of Utah, August 1998. The first system, GVM, is structured much like a monolithic kernel and focuses on complete resource isolation between processes and on comprehensive control over resources. A GVM process comprises a class loader-based name space, a heap, and a set of threads in that heap. In addition to their own heaps, all processes have access to a special, shared system heap. For every heap, GVM tracks all references leading to other heaps and all references pointing into it. This information is used to implement a form of distributed garbage collection. The CPU management in GVM combines CPU inheritance scheduling with the hierarchy introduced by Java\u2122 thread groups: thread groups within processes may hierarchically schedule the threads belonging to them.","A second variant of a Java\u2122 operating system developed at the University of Utah, Alta, closely models a micro-kernel model with nested processes, in which a parent process can manage all resources available to child processes. Memory management is supported explicitly, through a simple allocator-pays scheme. The garbage collector credits the owning process when an object is eventually reclaimed. Because Alta allows cross-process references, any existing objects are logically added into the parent memory. This makes the parent process responsible for making sure that cross-process references are not created if full memory reclamation is necessary upon process termination. Both GVM and Alta are implemented as considerable modifications to the JVM. Both systems support strong process models: each can limit the resource consumption of processes, but still permit processes to share data directly when necessary.","Advocates of process-based Java\u2122 application separation point out that a failure of one process terminates only this particular application and may potentially affect other applications only through an absence of service. Common wisdom states that processes are more reliable than implementations of JVMs. This reasoning implies that executing multiple applications in a single copy of the JVM puts them at a risk of being abruptly terminated because another application triggers an action, which will cause the whole JVM to go down. However, it does not necessarily have to be so. Processes still execute on top of an underlying operating system, and no major operating system kernel is guaranteed to be bug-free. Ultimately, one trusts software, whether it is an OS or a runtime of a safe language. The reliability issues of the Java\u2122 platform and of an OS kernel are essentially the same. Moreover, safe language has less potential for crashing because of software problems.","The SPIN extensible operating system, written almost entirely in a safe subset of Modula-3, utilizes both hardware and software protection. See Bershad, B., Savage, S., Pardyak, P., Sirer, E., Fiuczynski, M., Becker, D., Eggers, S., and Chambers, C., 15ACM Symposium on Operating Systems Principles, Copper Mountain, Colo., December 1995. Hardware protection is used to isolate address spaces; software protection protects the OS kernel from extensions. However, it is the view of the SPIN authors that protection is a software issue, and that with a well-designed inter-application isolation in a safe language, there should be no need for hardware protection. See Bershad, B., Savage, S., Pardyak, P., Becker, D., Fiuczynski, M., Sirer, E., , 5Workshop on Hot Topics in Operating Systems, Orcas Island, Wash., May 1995.","An alternative approach is to execute applications in the same instance of the JVM. Typically, each application is loaded by a separate class loader. See Liang S., and Bracha, G., , In Proceedings of ACM OOPSLA'98, Vancouver, BC, Canada, October 1998. This code replication is especially wasteful in the presence of just-in-time compilers (JITs). Currently available class loading mechanisms separately compile and separately store the JITed code of each loaded class, regardless of whether the class has already been loaded by another application or not. This can easily lead to significant memory footprints, since, on the average, a byte of bytecode may translate into about five bytes of native code, where the term bytecode refers to compiled Java\u2122 code. See Cramer, T., Friedman, R., Miller, T., Seberger, D., Wilson, R., and Wolczko, M., , IEEE Micro, May\/June 1997. Combined with the safety of the language, this approach leads to systems where applications are mostly isolated from one another. The place where the isolation breaks is the interaction of applications through static fields and static synchronized methods of system classes (as they are not subject to per-application replication).","A simple example of a Java\u2122 multiprocessing utilizing class loaders is the class library Echidna. With a reasonable degree of transparency, it allows multiple applications to run inside a single JVM. Applications can cleanly dispose of important resources when they are killed. For example, when a process is killed all its windows are automatically removed.","A more complex example of a class loader based approach to application protection is the J-Kernel. See Hawblitzel, C., Chang, C-C., Czajkowski, G., Hu., D. and von Eicken, T., Implementing Multiple Protection Domains in Java, In Proceedings of USENIX Annual Conference, New Orleans, La., June 1998. The J-Kernel adds protection domains to Java and makes a strong distinction between objects that can be shared between tasks and objects that are confined to a single task. Each domain has its own class loader. The system, written as a portable Java\u2122 library, provides mechanisms for clean domain termination (e.g., no memory allocated by the task is \u201cleft over\u201d after it is terminated) and inter-application communication (performed via deep object copies or methods arguments and return values).","Balfanz and Gong designed a multiprocessing JVM in order to explore the use of the Java\u2122 security architecture to protect applications from each other. See Balfanz, D., and Gong, L., -, Technical Report 560-97, Department of Computer Science, Princeton University, September, 1997. The proposed extensions enhance the standard JVM so that it can support multiprocessing. An important part of the work is clear identification of several areas of the JDK that assume a single-application model.","Two current trends cast doubt on the future usefulness of these two approaches to Java\u2122 multiprocessing. On one end of the computing power spectrum, high-end high-throughput servers have to deal with large volumes of concurrently executing Java\u2122 programs. Increasingly, in addition to traditional, large and self-contained applications, smaller entities (e.g., applets, servlets, and JavaBeans\u2122 components) are part of the computation system. The OS-based approach to Java multiprocessing is often unacceptable in these settings since it requires allocating large amounts of system resources for starting many copies of the JVM and thus tends to scale very poorly. Using class loaders has the potential for better scaling performance but it also wastes resources on replicating application code when more than one application executes the same program. Indicated isolation inconsistencies make this approach unsafe in general.","On the other end of the spectrum, small-footprint JVMs are emerging which target small devices. They typically lack many features available in fully blown implementations of the JVM available on general-purpose computers. An example is the K Virtual Machine (KVM) from Sun-Microsystems, Inc. Since the KVM specification does not require that its implementations provide class loaders, multiprocessing in a single instance of the KVM is possible only when all applications are trusted and guaranteed not to interfere with one another. Process-based multiprocessing using KVM is also problematic since small devices for which it is meant do not necessarily provide a process model with adequate strong application separation guarantees. Another example of a Java\u2122-based system without an underlying OS process abstraction is JavaOS\u2122.","As stated above, systems offering Java\u2122 multiprocessing can be classified as either based on an underlying operating system, which typically means running one process for each Java\u2122 application, or as using class loaders. However, using operating system processes is expensive, scales poorly, and does not fully exploit the protection features inherent in a safe language. Class loaders replicate application code, obscure the type system, and non-uniformly treat \u201ctrusted\u201d and \u201cuntrusted\u201d classes, which leads to subtle but nevertheless potentially harmful forms of undesirable inter-application interaction.","One way to achieve multi-tasking in a single processing space is through the use of threads. Multithreaded applications may be written in languages such as C and C++, but writing multithreaded C and C++ applications may be difficult. Furthermore, there are no assurances that third-party libraries are thread-safe. As used herein, \u201cthread-safe\u201d means that a given library function is implemented in such a manner that it can be safely executed by multiple concurrent threads of execution. Thread-safe programming often relies on \u201clocks\u201d or \u201cmonitors,\u201d which are used synonymously herein. One major problem with explicitly programmed thread support is that acquiring and releasing the locks needed at the right time tends to be difficult. For example, if a method returns prematurely, or if an exception is raised, and a related lock has not been released, deadlock usually results.","The Java\u2122 Language provides some built-in support for threads. The Java\u2122 library provides a Thread class that supports a rich collection of methods to start a thread, run a thread, stop a thread, and check on a thread's status. This built-in support for threads provides Java\u2122 programmers with a powerful tool to improve interactive performance of graphical applications. If an application desires to run animations and play music while scrolling the page and downloading a text file from a server, for example, then multithreading provides fast, lightweight concurrency within a single process space. Threads are sometimes referred to as lightweight processes or execution contexts.","Java\u2122 thread support includes a sophisticated set of synchronization primitives based on the widely used monitor and condition variable paradigm introduced twenty years ago by C. A. R. Hoare and implemented in a production setting in Xerox PARC's Cedar\/Mesa system. Java\u2122 supports multithreading at the language (syntactic) level and via support from its run-time system and thread objects. At the language level, Java\u2122 specifies that methods within a class that are declared \u201csynchronized\u201d do not run concurrently. Such methods run under control of monitors to ensure that variables remain in a consistent state. Every class and instantiated object has its own monitor that comes into play if required When a synchronized method is entered, it acquires a monitor on the current object. The monitor precludes any other synchronized methods in that object from running. When a synchronized method returns by any means, its monitor is released. Other synchronized methods within the same object are then free to run.","While other systems have provided facilities for multithreading (usually via \u201clightweight process\u201d libraries), building multithreading support into the language as Java\u2122 has done provides the programmer with a much more powerful tool for easily creating thread-safe multithreaded classes. Other benefits of multithreading are better interactive responsiveness and real-time behavior.","Nonetheless, the built-in support for multithreading in the Java\u2122 Language has its drawbacks. For example, applications may contend for the execution of a static synchronized method. A synchronized method acquires a monitor lock before it executes, and a static method is invoked without reference to a particular object. For a static synchronized method, the lock associated with the class object for the method's class is used. One application may acquire a lock on a static synchronized method and refuse to release the lock, thereby preventing other applications from invoking the method.","Therefore, an improved system and method for efficiently isolating applications within a single virtual machine are desired.","The problems outlined above are in large part solved by various embodiments of a system and method for isolating the execution of a plurality of applications as disclosed herein. The applications may include applets, servlets, operating system services, components, JavaBeans\u2122, or other suitable executable units or programs. \u201cApplication\u201d and \u201cprogram\u201d are herein used synonymously. In one embodiment, the applications are executable in a platform-independent programming environment such as the Java\u2122 environment. In one embodiment, the applications are executable on a single instance of a virtual machine, such as a Java\u2122 Virtual Machine, which is implemented in accordance with a platform-independent virtual machine specification, such as the Java\u2122 Virtual Machine Specification. The plurality of applications may utilize one or more \u201coriginal\u201d classes. In other words, the original classes may be shared by a plurality of applications. The general approach taken by the system and method as disclosed herein is to create new classes to replace the original classes in order to isolate the execution of the applications, such that different applications cannot typically access the same static fields. In one embodiment, only one copy of each original class is maintained, regardless of how many applications utilize it. Classes are transparently and automatically modified, so that each application has a separate copy of its static fields. This provides for a minimal collective footprint, with strong application isolation. In addition, this allows class loaders to be removed from the type system.","In one embodiment, one or more static fields are extracted from one or more original classes utilized by any of the plurality of applications, wherein each of the one or more original classes includes at least one static field. In one embodiment, a separate copy of the one or more static fields is created for each of the plurality of applications, wherein each of the separate copies corresponds to one of the plurality of applications. Creating the separate copy of the one or more static fields may include creating a static field class which includes instance fields corresponding to the one or more static fields, wherein each instance of the static field class corresponds to one of the plurality of applications. In one embodiment, one or more access methods for the one or more static fields may be created. The access methods are operable to access the corresponding separate copy of the one or more static fields based upon the identity of the utilizing or calling application. Creating access methods for the one or more static fields may include creating a single access methods class for each original class which includes the access methods for accessing the extracted fields from the original class.","In one embodiment, the method for isolating the execution of the applications is transparent to the utilizing applications. In various embodiments, the extraction of the static fields, creation of the separate copies of the static fields, and creation of the access methods may be performed at run-time or at compilation, and at the source level or the bytecode level. In a further embodiment, the method may be performed upon structures rather than classes, such as in a programming environment that is not object-oriented.","Further optimizations to the method for isolating the execution of the applications may be performed. A set of static fields may be classified as secure for utilization by the plurality of applications without inter-application interference. The secure set of static fields may include final static fields of primitive types, final static strings, immutable arrays of primitive types, and\/or other appropriate fields. The secure set of static fields may then be preserved within the one or more classes. In other words, the set of static fields may be exempted from the one or more static fields which are extracted from the one or more classes.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawing and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","FIG. : A Typical Computer System","Turning now to the drawings,  is an illustration of a typical, general-purpose computer system  which is suitable for implementing the system and method for application isolation as disclosed herein. As discussed with reference to , the system and method for application isolation may include providing multiple copies of static fields to isolate the execution of the applications, such that different applications cannot typically access the same static field.","The computer system  includes at least one central processing unit (CPU) or processor . The CPU  is coupled to a memory  and a read-only memory (ROM) . The memory  is representative of various types of possible memory media: for example, hard disk storage, floppy disk storage, removable disk storage, or random access memory (RAM). The terms \u201cmemory\u201d and \u201cmemory medium\u201d may include an installation medium, e.g., a CD-ROM or floppy disk, a computer system memory such as DRAM, SRAM, EDO RAM, Rambus RAM, etc., or a non-volatile memory such as a magnetic media, e.g., a hard drive, or optical storage. The memory medium may include other types of memory as well, or combinations thereof. In addition, the memory medium may be located in a first computer in which the programs are executed, or may be located in a second different computer which connects to the first computer over a network. In the latter instance, the second computer provides the program instructions to the first computer for execution.","As shown in , typically the memory  permits two-way access: it is readable and writable. The ROM , on the other hand, is readable but not writable. The memory  and\/or ROM  may store instructions and\/or data which implement all or part of the system and method described in detail herein, and the memory  and\/or ROM  may be utilized to install the instructions and\/or data. In various embodiments, the computer system  may take various forms, including a personal computer system, desktop computer, laptop computer, palmtop computer, mainframe computer system, workstation, network appliance, network computer, Internet appliance, personal digital assistant (PDA), embedded device, smart phone, television system, or other suitable device. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device having a processor which executes instructions from a memory medium.","The CPU  may be coupled to a network . The network  is representative of various types of possible networks: for example, a local area network (LAN), wide area network (WAN), or the Internet. The system and method for application isolation in accordance as disclosed herein may therefore be implemented on a plurality of heterogeneous or homogeneous networked computer systems  through one or more networks . The CPU  may acquire instructions and\/or data for implementing system and method for application isolation in accordance as disclosed herein over the network .","Through an input\/output bus , the CPU  may also coupled to one or more input\/output devices that may include, but are not limited to, video monitors or other displays, track balls, mice, keyboards, microphones, touch-sensitive displays, magnetic or paper tape readers, tablets, styluses, voice recognizers, handwriting recognizers, printers, plotters, scanners, and any other devices for input and\/or output. The CPU  may acquire instructions and\/or data for implementing the system and method for application isolation as disclosed herein through the input\/output bus .","The computer system  is operable to execute one or more computer programs. The computer programs may comprise operating system or other system software, application software, utility software, Java\u2122 applets, and\/or any other sequence of instructions. Typically, an operating system performs basic tasks such as recognizing input from the keyboard, sending output to the display screen, keeping track of files and directories on the disk, and controlling peripheral devices such as disk drives and printers. Application software runs on top of the operating system and provides additional functionality. Because applications take advantage of services offered by operating systems, and because operating systems differ in the services they offer and in the way they offer the services, an application must usually be designed to run on a particular operating system. The computer programs are stored in a memory medium or storage medium such as the memory  and\/or ROM , or they may be provided to the CPU  through the network  or I\/O bus .","In one embodiment, the computer programs executable by the computer system  may be implemented in the Java\u2122 Language. The Java\u2122 Language is described in by Gosling, Joy, and Steele (Addison-Wesley, ISBN 0-201-63451-1), which is incorporated herein by reference. A general discussion of the Java\u2122 Language follows. The Java\u2122 Language is an object-oriented programming language. In an object-oriented programming language, data and related methods can be grouped together or encapsulated to form an entity known as an object. All objects in an object-oriented programming system belong to a class, which can be thought of as a category of like objects which describes the characteristics of those objects. Each object is created as an instance of the class by a program. The objects may therefore be said to have been instantiated from the class. The class sets out variables and methods for objects which belong to that class. The definition of the class does not itself create any objects. The class may define initial values for its variables, and it normally defines the methods associated with the class (i.e., includes the program code which is executed when a method is invoked.) The class may thereby provide all of the program code which will be used by objects in the class, hence maximizing re-use of code which is shared by objects in the class.","FIG. : The Java\u2122 Platform","The Java\u2122 Platform which utilizes the object-oriented Java\u2122 Language is a software platform for delivering and running the same applications on a plurality of different operating systems and hardware platforms. As will be described in further detail below, the Java\u2122 Platform includes system-dependent portions and system-independent portions, and therefore the Java\u2122 Platform may be thought of as having multiple embodiments. The Java\u2122 Platform sits on top of these other platforms, in a layer of software above the operating system and above the hardware.  is an illustration of the Java\u2122 Platform and the relationships between the elements thereof in one embodiment. The Java\u2122 Platform has two basic parts: the Java\u2122 Virtual Machine , and the Java\u2122 Application Programming Interface (Java\u2122 API). The Java\u2122 API may be thought of as comprising multiple application programming interfaces (APIs). While each underlying platform has its own implementation of the Java\u2122 Virtual Machine , there is only one Virtual Machine specification. The Java\u2122 Virtual Machine specification is described in by Lindholm and Yellin (Addison-Wesley, ISBN 0-201-63452-X), which is incorporated herein by reference. By allowing the Java\u2122 applications  to execute on the same Virtual Machine  across many different underlying computing platforms, the Java\u2122 Platform can provide a standard, uniform programming interface which allows Java\u2122 applications  to run on any hardware on which the Java\u2122 Platform has been implemented. The Java\u2122 Platform is therefore designed to provide a \u201cwrite once, run anywhere\u201d capability.","Developers may use the Java\u2122 Language and Java\u2122 APIs to write source code for Java\u2122-powered applications . A developer compiles the source code only once to the Java\u2122 Platform, rather than to the machine language of an underlying system. Java\u2122 programs compile to bytecodes which are machine instructions for the Java\u2122 Virtual Machine . A program written in the Java\u2122 Language compiles to a bytecode file which can run wherever the Java\u2122 Platform is present, on any underlying operating system and on any hardware. In other words, the same Java\u2122 application can run on any computing platform that is running the Java\u2122 Platform. Essentially, therefore, Java\u2122 applications  are expressed in one form of machine language and are translated by software in the Java\u2122 Platform to another form of machine language which is executable on a particular underlying computer system.","The Java\u2122 Virtual Machine  is implemented in accordance with a specification for a \u201csoft\u201d computer which can be implemented in software or hardware. As used herein, a \u201cvirtual machine\u201d is generally a self-contained operating environment that behaves as if it were a separate computer. As shown in , in one embodiment, the Java \u2122 Virtual Machine  is implemented in a software layer. Various implementations of the Java\u2122 Virtual Machine  can run on a variety of different computing platforms: for example, on a browser  sitting on top of an operating system (OS) on top of hardware ; on a desktop operating system on top of hardware ; on a smaller operating system on top of hardware ; or on the JavaOS operating system  on top of hardware . Computer hardware , , , and may comprise different hardware platforms. JavaOS  is an operating system that is optimized to run on a variety of computing and consumer platforms. The JavaOS  operating environment provides a runtime specifically tuned to run applications written in the Java\u2122 Language directly on computer hardware without requiring another operating system.","The Java\u2122 API or APIs form a standard interface to Java\u2122 applications , regardless of the underlying operating system or hardware. The Java\u2122 API or APIs specify a set of programming interfaces between Java\u2122 applications  and the Java\u2122 Virtual Machine . The Java\u2122 Base API  provides the basic language, utility, I\/O, network, GUI, and applet services. The Java\u2122 Base API  is typically present anywhere the Java\u2122 Platform is present. The Java\u2122 Base Classes  are the implementation of the Java\u2122 Base API . The Java\u2122 Standard Extension API  provides additional capabilities beyond the Java\u2122 Base API . The Java\u2122 Standard Extension Classes  are the implementation of the Java\u2122 Standard Extension API . Other APIs in addition to the Java\u2122 Base API  and Java\u2122 Standard Extension API  can be provided by the application or underlying operating system. A particular Java\u2122 environment may include additional APIs  and the classes  which implement them. Each API is organized by groups or sets. Each of the API sets can be implemented as one or more packages or namespaces. Each package groups together a set of classes and interfaces that define a set of related data, constructors, and methods, as is well known in the art of object-oriented programming.","The porting interface  lies below the Java\u2122 Virtual Machine  and on top of the different operating systems , , and  and browser . The porting interface  is platform-independent. However, the associated adapters , , and are platform-dependent. The porting interface  and adapters , , and enable the Java\u2122 Virtual Machine  to be easily ported to new computing platforms without being completely rewritten. The Java\u2122 Virtual Machine , the porting interface , the adapters , , and , the JavaOS , and other similar pieces of software on top of the operating systems , , and may, individually or in combination, act as means for translating the machine language of Java\u2122 applications , APIs  and , and Classes  and  into a different machine language which is directly executable on the underlying hardware.",{"@attributes":{"id":"h-0007","num":"0000"},"figref":"FIGS. 3","b":["4","5"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIGS. 3","b":["4","5"]},"It is further recommended that thread termination and suspension requests are deferred whenever the thread executes non-reentrant native code and are effective immediately upon return. It is recommended that no part of native code should both be non-reentrant and blocking. Using monitors may enables such structuring of the native code. Without meeting this recommendation, the system and method for application isolation as described herein may still be used to isolate applications, but their clean termination may be difficult.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 3","b":["310","320","310","320","304","308","302","304","306","308"]},"In the absence of application-defined native code (as recommended above), inter-application communication through static fields can be performed by explicit manipulation of static fields  and  or by invoking methods which access these fields. This use of static fields  and  can lead to unexpected and incorrect behavior depending on how many applications use the same class with static fields.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4","b":["310","320","304","304","302","302","308","306","304","304","306","308","306"],"i":["a ","b ","a ","b","a ","b"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 5","FIGS. 3 and 4","FIG. 5"],"b":["310","320","310","502","504","506","508","320","502","504","506","508","310","320","310","320"],"i":["a ","a ","b ","b "]},"The approach shown in  combines the best features of the OS-based approach and the class-loader based approach. First, it permits a plurality of applications to execute in a single virtual machine. This capability has all the advantages of class loaders over processes in that switching from one application to another does not require a costly process context switch, startup time is faster, and fewer resources per application are necessary, which improves the overall system scalability. Second, only one copy of a class is loaded into the system, regardless of how many applications use it. This improves over both existing approaches (as discussed with reference to ) in terms of both saved code space and saved repeated compilation time. Third, applications are isolated from one another, i.e., they cannot exchange data through shared variables of any class, be it an application class or a system class, and they cannot block one another from calling synchronized methods. This is a separation level expected from an operating system approach and an improvement over what class loaders can offer. Finally, no new application-programming interface is introduced. In particular, existing applications' bytecode does not have to be modified in order to execute under the proposed isolation model.",{"@attributes":{"id":"h-0008","num":"0000"},"figref":"FIGS. 6","b":["7","8"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIGS. 6","b":["7","8","5"]},"The applications may include applets, servlets, operating system services, components, JavaBeans\u2122 or other suitable executable units or programs. \u201cApplication\u201d and \u201cprogram\u201d are herein used synonymously. In one embodiment, the applications are executable in a platform-independent programming environment such as the Java\u2122 environment as discussed with reference to FIG. . In one embodiment, the applications are executable on a single instance of a virtual machine, such as a Java\u2122 Virtual Machine, which is implemented in accordance with a platform-independent virtual machine specification, such as the Java\u2122 Virtual Machine Specification.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 6","FIG. 6"],"b":["602","606","602"]},"In step , a separate copy of the one or more static fields is created for each of the plurality of applications, wherein each of the separate copies corresponds to one of the plurality of applications. Creating the separate copy of the one or more static fields may include creating a static field class which includes instance fields corresponding to the one or more static fields, wherein each instance of the static field class corresponds to one of the plurality of applications. In these new classes, the type modifier of the fields is converted from static to simple instance fields. These fields may hereinafter be referred to as static instance fields.","In step , one or more access methods for the static fields may be created. As used herein, an \u201caccess method\u201d is a method that provides access to storage locations such as static fields. The access methods are operable to access the corresponding separate copy of the one or more static fields based upon the identity of the utilizing or calling application. Creating access methods for each of the one or more static fields may include creating a single access methods class for each original class which includes the access methods for accessing the extracted fields from the original class. The new class which contains the access methods for the new static instance fields may hereinafter be referred to as the static instance field access class or access methods class.","In one embodiment, as described above and illustrated by , any original class  containing static fields  is transparently and automatically split into three classes: the original class including instance fields  and methods  but without the static fields , referred to as the modified original class ; a new class containing all the static fields which are now instance fields , referred to as the static instance field class or static field class ; and a new class containing methods  to access these folds, the static instance field access class or access methods class . The access methods class  maintains a copy (i.e., instance) of each static field class  per application domain and is operable to access the proper copy (i.e., instance) of this class based on the application identity extracted from the current thread. In one embodiment, only one copy of the modified original class and access methods class  is present in the virtual machine regardless of the number of applications using the original class. In this manner, the amount of class replication is minimized, and the overall memory footprint is minimized as a result. Also, any fields prone to inter-application interference are replicated and isolated to assure a secure processing environment for each application. The system and method shown in  may also allow class loaders to be removed from the type system.","In another embodiment, the method for separating static fields from original classes may be performed upon structures rather than classes, such as in a programming environment that is not object-oriented.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 8","b":["802","804","802"]},"In one embodiment, the transformations affect only static fields and the way they are accessed. The original class, Counter, undergoes the following modifications. In one embodiment, all static fields are removed from Counter. A new method, hidden$initializer( ), is added. It contains a modified version of the code of the static initializer of Counter. It is invoked whenever a new domain uses the static fields of counter for the first time. The code for hidden$initializer( ) is presented in resulting classes .","The second new class, Counter$sFields, contains all the static fields of Counter. In one embodiment, all modifiers (static, final, private, etc) are removed from the fields so that they have package access. Thus, all static fields of Counter become instance, non-final, package-access fields of the new class Counter$sFields, as shown in resulting classes .","The third and final generated class is Counter$aMethods. It contains a table mapping domain identifiers onto per-domain copies of Counter$sFields. For each field from Counter$sFields there is a pair of get$( ) and put$( ) methods in Counter$aMethods. In this example, there is only one static field, and thus Counter$aMethods has only two such access methods: put$cnt( ) and get$cnt( ). Each of them looks up the copy of Counter$sFields corresponding to the current domain and then accesses the named field. If the lookup does not succeed, it means that this domain's copy of Counter$sFields has not been generated yet and that the appropriate initialization must be made. In an alternate embodiment, the field(s) in Counter$sFields and the methods of Counter$aMethods could be stored in the original class file of Counter. In embodiments using the Java\u2122 Language, it should be noted that this is possible for proper classes only; interfaces typically cannot have non-abstract methods.","Once these modifications are performed, the code of each method is inspected as follows. In one embodiment, each access to a static field is automatically replaced with the appropriate get$( ) or put$( ) method. At the bytecode-to-bytecode transformation level, this becomes a replacement of each getstatic or putstatic instruction with get$( ) orput$( ), respectively.","In one embodiment, the automatic transformations described above may be augmented with manual re-coding of several atypical classes. For example, in some implementations of the JVM, the System.out field is initialized by the runtime. It is important to ensure that each application has an access to System.out (if a security policy of a given environment allows this) and, at the same time, that this static field is not directly shared by the applications. System properties are another example. Policy decisions may be made concerning whether applications can write to a shared copy of system properties, or whether each application should see a separate, read-only copy, or whether some other solution is appropriate. In general, resources that are shared by all classes should be identified for each particular JVM. However, such manifestations of a single-processing original nature of Java\u2122 are very rare. Therefore, manually dealing with these manifestations may be appropriate for only a handful of system classes. Simply wrapping objects and marking the wrapped classes as non-transformable may be the most effective solution.","According to the system and method discussed with reference to , classes can be modified one-by-one. In other words, there generally is no need to analyze another class before ending the modifications to the current class (\u201cpeephole code modification\u201d). Another desirable property of the system and method is that the changes may involve source-to-source post-compilation transformation and as such are portable.","Optimizations","In various embodiments, there are a number of optimizations for the system and method which may be performed as source-to-source transformations. As such, they do not break portability, but some may require analyzing more than one class before optimized modifications to a particular class can be completed.","One category of optimizations is preserving selected final static fields in their original classes. In such cases, original getstatic (and, in initialization code, putstatic) instructions are left unmodified whenever accessing such preserved fields. This avoids the need to look up the current application identifier and then to find the corresponding $sFields object.","The most straightforward optimization is to preserve final static fields of primitive types in their original classes since this does not lead to any inter-application interference. When applying this optimization, it may be appropriate to scan the bytecode of referenced classes in order to determine whether or not a field named in getstatic or putstatic is final.","Another optimization may be to preserve static final strings in their original classes. Strings are immutable, so their fields or methods cannot act as a data communication channel between applications. However, if an application uses a static final string as a monitor object for a synchronized statement, another instance of this application may compete for the same lock. Thus, preserving static final strings may sometimes lead to unwanted interference at the level of accessing mutual exclusion code.","In general, it is recommended that objects be preserved in their original classes only if they are not used as synchronization objects and if they are immutable. A special category of such objects is arrays of primitive types. A simple, conservative analysis often suffices to determine that a given static final array is in fact immutable. Preserving such immutable arrays in their original classes may lead to significant performance gains in some special cases.","In one embodiment, therefore, a set of static fields may be classified as secure for utilization by the plurality of applications without inter-application interference. The secure set of static fields may include final static fields of primitive types, final static strings, immutable arrays of primitive types, and\/or other appropriate fields. The secure set of static fields may then be preserved within the one or more classes. In other words, the set of static fields may be exempted from the one or more static fields which are extracted from the one or more classes.","Some further optimizations may also be performed. For example, for actual classes (i.e., not interfaces), all the new get$( ) and put$( ) methods may actually be added to the class itself. This technique effectively merges the $aMethods classes into their original classes, although the performance gains from this method are uncertain.","The approach described above minimizes the amount of resources needed for running multiple applications in the same copy of a virtual machine such as the JVM. Only one copy of each class exists in the system. This leads to fast startup of applications whose instances are already running and minimizes the space needed for code, especially for the JITed code. As has been discussed above, applications can be protected from one another both at the level of data access and at the level of access to static synchronized methods.","In one embodiment of the invention using a Java\u2122 Virtual Machine, the isolation system and method described above may be added to the JVM runtime. The rationale behind implementing them in a custom runtime is (1) to minimize the overheads, (2) to simplify the implementation, and (3) to remove bytecode editing from the critical \u201cfetch class file-load-execute\u201d path when bytecode editing cannot be done off-line. In one embodiment, an efficient way to modify the runtime may be to provide the per-application copies of static fields along with the loaded class image. This tends to ensure that no bytecode has to be modified. In particular, no new classes are generated and no field access modifiers are changed, which addresses security concerns. Past experience with moving from a bytecode-editing prototype to a custom runtime (in order to account for computational resources) indicates that in the case of application isolation, the overheads can be reduced by an order of magnitude. See Czajkowski, G., and von Eicken, T., , In Proceedings of ACM OOPSLA'98, Vancouver, BC, Canada, October 1998. The price is the loss of portability of the multiprocessing layer, inherent in customizing the runtime.","FIG. : Threads And Static Synchronized Methods",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 9","b":["902","904","910","908","902","904","908","910","908","902","902","910","908","902","902","910","902","910","902","908"],"i":["a ","a ","b ","b ","a ","b ","a ","a ","b "]},"FIGS.  and : Isolation of Static Synchronized Methods",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIGS. 10 and 11"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 10","b":["902","902","1008","1008","910","910","904"],"i":["a ","b ","a ","b"]},"In one embodiment, the synchronized method  is a static synchronized method such as in the Java\u2122 Language. In one embodiment, each monitor  corresponds to one of the plurality of applications  which calls the synchronized method ; i.e., there is a one-to-one correspondence between applications  and monitors . In various embodiments, the source code or the bytecode for the synchronized method  may be transformed by removing a method-level monitor, which would be shared among applications, and adding the plurality of monitors inside the method by using a monitor for each instance of the static field class, which would be specific to each application.","In one embodiment, the method for isolating the execution of the applications may be transparent to the utilizing applications. It should also be noted that in various embodiments, the extraction of the static fields, creation of the separate copies of the static fields, creation of the access methods, and replacement the static synchronized methods may be performed at run-time or at compilation, and at the source level or the bytecode level. Also, it should be noted that in a further embodiment, the method may not be limited to formal classes, but may also be applied to structures, such as in a programming environment that is not object-oriented.","Referring back to  above, suppose that the add( ) function of Counter is a synchronized method. This may lead to the following problem in the transformed code: one application calls add( ) and while the calling thread executes the body of the method, it is suspended by another thread from the same application. This may result in a serious denial-of-service problem since the suspended thread still holds a lock and no other application is able to execute Counter.add( ). This problem does not exist if multiple applications using the class Counter are loaded by separate class loaders. However, if class loaders are eliminated through the application of the system and method for application isolation shown in , the problem remains.","As shown in the example of , a relatively simple transformation to the method code may address these problems. This transformation may be performed in conjunction with the transformation described above with reference to . As described above, the original class may be shared by a plurality of applications, and include at least one static synchronized method. Typically, each static synchronized method includes an executable block of code which comprises the body of the method.","As shown in , the original static synchronized method  modifies the static class variable counter. In the transformation of the static method (and optionally the static field separation described with reference to FIGS.  through ), the synchronization for static methods is replaced by synchronization on the $sFields object owned by the current (i.e., utilizing or invoking) application. Specifically, in the example code of the transformed method , it may be seen that the method itself is no longer synchronized. Instead, the instance of the static field class corresponding to the calling application is retrieved and synchronized over the scope of the method body. Hence, the \u201cstatic\u201d instance variables of the class (which are accessible only by the current application) are modified in a way that restricts lock contention to concurrently executing threads in the current application. In order to permit the generic solution as shown in , it is recommended that $sFields objects be generated even for original classes which lack static fields.","Various embodiments may further include receiving or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Suitable carrier media may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network  and\/or a wireless link.","While the present invention has been described with reference to particular embodiments, it will be understood that the embodiments are illustrated and that the invention scope is not so limited. Any variations, modifications, additions and improvements to the embodiments described are possible. These variations, modifications, additions and improvements may fall within the scope of the invention as detailed within the following claims."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF SEVERAL EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 3 through 5"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIGS. 10 and 11"}]},"DETDESC":[{},{}]}
