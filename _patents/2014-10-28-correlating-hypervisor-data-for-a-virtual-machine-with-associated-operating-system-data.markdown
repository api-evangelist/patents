---
title: Correlating hypervisor data for a virtual machine with associated operating system data
abstract: The disclosed embodiments relate to a system for analyzing the performance virtual machines. During operation, the system obtains hypervisor data for a set of virtual machines, wherein the hypervisor data was received from one or more hypervisors while the set of virtual machines was running on the hypervisors. The system also obtains operating system data for the set of virtual machines, wherein the operating system data was received from a set of operating systems while the set of operating systems was running on the set of virtual machines. Next, the system correlates hypervisor data for a virtual machine with corresponding operating system data for the virtual machine. Finally, the system presents the correlated hypervisor data and operating system data for the virtual machine to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471362&OS=09471362&RS=09471362
owner: SPLUNK INC.
number: 09471362
owner_city: San Francisco
owner_country: US
publication_date: 20141028
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application claims priority under 35 U.S.C. \u00a7119(e) to U.S. Provisional Application Ser. No. 62\/054,264, entitled \u201cCorrelating Hypervisor Data for a Virtual Machine with Associated Operating System Data,\u201d by inventors Alok A. Bhide and Adrian Hall, filed on Sep. 23, 2014, the contents of which are herein incorporated by reference.","1. Field of the Invention","The disclosed embodiments generally relate to techniques for analyzing performance in computer systems. More specifically, the disclosed embodiments relate to a technique for correlating hypervisor data for a virtual machine with associated operating system data.","2. Related Art","Organizations are increasingly relying on cloud-based computing systems to perform large-scale computational tasks. Such cloud-based computing systems are typically operated by hosting companies that maintain a sizable computational infrastructure, often comprising thousands of servers sited in geographically distributed data centers. Customers typically buy or lease computational resources from these hosting companies. The hosting companies in turn provision computational resources according to the customers' requirements and then enable the customers to access these resources.","Cloud-based computing systems often provide a virtualized computing environment, wherein tasks run on \u201cvirtual machines\u201d that execute on underlying physical host systems. Such virtualized computing environments enable computational tasks to be easily moved among host systems to facilitate load balancing and fault tolerance. However, they also complicate the process of diagnosing and resolving performance problems because such performance problems can arise: at the virtual-machine level; at the host-system level; and also between virtual processes that run inside the virtual machines.","Existing performance-monitoring tools for virtual machines typically operate by gathering virtual-machine performance parameters from a hypervisor, which is responsible for instantiating and executing virtual machines on an underlying host system. For example, virtual-machine performance parameters can specify processor utilization or memory utilization parameters for virtual machines that are executing on the hypervisor. However, these virtual-machine performance parameters do not tell the whole story. To determine the root cause of a performance problem, it is often advantageous to analyze performance parameters for virtual processes that run inside operating systems within the virtual machines.","Unfortunately, such virtual-process performance parameters cannot be obtained from the hypervisor. It is typically necessary for an administrator to obtain such virtual-process performance parameters from another diagnostic tool that gathers process-level performance parameters from operating systems that execute within the virtual machines. Note that these operating systems keep track of different types of performance data within the virtual machine, including performance parameters for virtual processes that run within the virtual machines. Even when such process-level performance parameters can be gathered, it is difficult to correlate these process-level performance parameters with virtual-machine performance parameters obtained from a hypervisor.","Hence, what is needed is a system that facilitates efficiently analyzing performance parameters for virtual machines together with performance parameters for associated virtual processes without the drawbacks of existing techniques.","The disclosed embodiments relate to a performance-monitoring system that facilitates correlating hypervisor performance data for virtual machines with associated operating system data for virtual processes that execute on the virtual machines. This performance-monitoring system is described in more detail below, but first we describe the structure of an event-based system in which this performance-monitoring system operates.","1.1 System Overview","Modern data centers often comprise thousands of host computer systems that operate collectively to service requests from even larger numbers of remote clients. During operation, these data centers generate significant volumes of performance data and diagnostic information that can be analyzed to quickly diagnose performance problems. In order to reduce the size of this performance data, the data is typically pre-processed prior to being stored based on anticipated data-analysis needs. For example, pre-specified data items can be extracted from the performance data and stored in a database to facilitate efficient retrieval and analysis at search time. However, the rest of the performance data is not saved and is essentially discarded during pre-processing. As storage capacity becomes progressively cheaper and more plentiful, there are fewer incentives to discard this performance data and many reasons to keep it.","This plentiful storage capacity is presently making it feasible to store massive quantities of minimally processed performance data at \u201cingestion time\u201d for later retrieval and analysis at \u201csearch time.\u201d Note that performing the analysis operations at search time provides greater flexibility because it enables an analyst to search all of the performance data, instead of searching pre-specified data items that were stored at ingestion time. This enables the analyst to investigate different aspects of the performance data instead of being confined to the pre-specified set of data items that was selected at ingestion time.","However, analyzing massive quantities of heterogeneous performance data at search time can be a challenging task. A data center may generate heterogeneous performance data from thousands of different components, which can collectively generate tremendous volumes of performance data that can be time-consuming to analyze. For example, this performance data can include data from system logs, network packet data, sensor data, and data generated by various applications. Also, the unstructured nature of much of this performance data can pose additional challenges because of the difficulty of applying semantic meaning to unstructured data, and the difficulty of indexing and querying unstructured data using traditional database systems.","These challenges can be addressed by using an event-based system, such as the SPLUNK\u00ae ENTERPRISE system produced by Splunk Inc. of San Francisco, Calif., to store and process performance data. The SPLUNK\u00ae ENTERPRISE system is the leading platform for providing real-time operational intelligence that enables organizations to collect, index, and harness machine-generated data from various websites, applications, servers, networks, and mobile devices that power their businesses. The SPLUNK\u00ae ENTERPRISE system is particularly useful for analyzing unstructured performance data, which is commonly found in system log files. Although many of the techniques described herein are explained with reference to the SPLUNK\u00ae ENTERPRISE system, the techniques are also applicable to other types of data server systems.","In the SPLUNK\u00ae ENTERPRISE system, performance data is stored as \u201cevents,\u201d wherein each event comprises a collection of performance data and\/or diagnostic information that is generated by a computer system and is correlated with a specific point in time. Events can be derived from \u201ctime series data,\u201d wherein time series data comprises a sequence of data points (e.g., performance measurements from a computer system) that are associated with successive points in time and are typically spaced at uniform time intervals. Events can also be derived from \u201cstructured\u201d or \u201cunstructured\u201d data. Structured data has a predefined format, wherein specific data items with specific data formats reside at predefined locations in the data. For example, structured data can include data items stored in fields in a database table. In contrast, unstructured data does not have a predefined format. This means that unstructured data can comprise various data items having different data types that can reside at different locations. For example, when the data source is an operating system log, an event can include one or more lines from the operating system log containing raw data that includes different types of performance and diagnostic information associated with a specific point in time. Examples of data sources from which an event may be derived include, but are not limited to: web servers; application servers; databases; firewalls; routers; operating systems; and software applications that execute on computer systems, mobile devices, and sensors. The data generated by such data sources can be produced in various forms including, for example and without limitation, server log files, activity log files, configuration files, messages, network packet data, performance measurements and sensor measurements. An event typically includes a timestamp that may be derived from the raw data in the event, or may be determined through interpolation between temporally proximate events having known timestamps.","The SPLUNK\u00ae ENTERPRISE system also facilitates using a flexible schema to specify how to extract information from the event data, wherein the flexible schema may be developed and redefined as needed. Note that a flexible schema may be applied to event data \u201con the fly,\u201d when it is needed (e.g., at search time), rather than at ingestion time of the data as in traditional database systems. Because the schema is not applied to event data until it is needed (e.g., at search time), it is referred to as a \u201clate-binding schema.\u201d","During operation, the SPLUNK\u00ae ENTERPRISE system starts with raw data, which can include unstructured data, machine data, performance measurements or other time-series data, such as data obtained from weblogs, syslogs, or sensor readings. It divides this raw data into \u201cportions,\u201d and optionally transforms the data to produce timestamped events. The system stores the timestamped events in a data store, and enables a user to run queries against the data store to retrieve events that meet specified criteria, such as containing certain keywords or having specific values in defined fields. Note that the term \u201cfield\u201d refers to a location in the event data containing a value for a specific data item.","As noted above, the SPLUNK\u00ae ENTERPRISE system facilitates using a late-binding schema while performing queries on events. A late-binding schema specifies \u201cextraction rules\u201d that are applied to data in the events to extract values for specific fields. More specifically, the extraction rules for a field can include one or more instructions that specify how to extract a value for the field from the event data. An extraction rule can generally include any type of instruction for extracting values from data in events. In some cases, an extraction rule comprises a regular expression, in which case the rule is referred to as a \u201cregex rule.\u201d","In contrast to a conventional schema for a database system, a late-binding schema is not defined at data ingestion time. Instead, the late-binding schema can be developed on an ongoing basis until the time a query is actually executed. This means that extraction rules for the fields in a query may be provided in the query itself, or may be located during execution of the query. Hence, as an analyst learns more about the data in the events, the analyst can continue to refine the late-binding schema by adding new fields, deleting fields, or changing the field extraction rules until the next time the schema is used by a query. Because the SPLUNK\u00ae ENTERPRISE system maintains the underlying raw data and provides a late-binding schema for searching the raw data, it enables an analyst to investigate questions that arise as the analyst learns more about the events.","In the SPLUNK\u00ae ENTERPRISE system, a field extractor may be configured to automatically generate extraction rules for certain fields in the events when the events are being created, indexed, or stored, or possibly at a later time. Alternatively, a user may manually define extraction rules for fields using a variety of techniques.","Also, a number of \u201cdefault fields\u201d that specify metadata about the events rather than data in the events themselves can be created automatically. For example, such default fields can specify: a timestamp for the event data; a host from which the event data originated; a source of the event data; and a source type for the event data. These default fields may be determined automatically when the events are created, indexed or stored.","In some embodiments, a common field name may be used to reference two or more fields containing equivalent data items, even though the fields may be associated with different types of events that possibly have different data formats and different extraction rules. By enabling a common field name to be used to identify equivalent fields from different types of events generated by different data sources, the system facilitates use of a \u201ccommon information model\u201d (CIM) across the different data sources.","1.2 Data Server System",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1","b":["100","100","101","105","102","103"]},"During operation, the forwarders  identify which indexers  will receive the collected data and then forward the data to the identified indexers. Forwarders  can also perform operations to strip out extraneous data and detect timestamps in the data. The forwarders next determine which indexers  will receive each data item and then forward the data items to the determined indexers .","Note that distributing data across different indexers facilitates parallel processing. This parallel processing can take place at data ingestion time, because multiple indexers can process the incoming data in parallel. The parallel processing can also take place at search time, because multiple indexers can search through the data in parallel.","System  and the processes described below with respect to  are further described in \u201cExploring Splunk Search Processing Language (SPL) Primer and Cookbook\u201d by David Carasso, UM Research, 2012, and in \u201cOptimizing Data Analysis With a Semi-Structured Time Series Database\u201d by Ledion Bitincka, Archana Ganapathi, Stephen Sorkin, and Steve Zhang, SLAML, , each of which is hereby incorporated herein by reference in its entirety for all purposes.","1.3 Data Ingestion",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2","b":["201","202"]},"Next, the indexer determines a timestamp for each event at block . As mentioned above, these timestamps can be determined by extracting the time directly from data in the event, or by interpolating the time based on timestamps from temporally proximate events. In some cases, a timestamp can be determined based on the time the data was received or generated. The indexer subsequently associates the determined timestamp with each event at block , for example by storing the timestamp as metadata for each event.","Then, the system can apply transformations to data to be included in events at block . For log data, such transformations can include removing a portion of an event (e.g., a portion used to define event boundaries, extraneous text, characters, etc.) or removing redundant portions of an event. Note that a user can specify portions to be removed using a regular expression or any other possible technique.","Next, a keyword index can optionally be generated to facilitate fast keyword searching for events. To build a keyword index, the indexer first identifies a set of keywords in block . Then, at block  the indexer includes the identified keywords in an index, which associates each stored keyword with references to events containing that keyword (or to locations within events where that keyword is located). When an indexer subsequently receives a keyword-based query, the indexer can access the keyword index to quickly identify events containing the keyword.","In some embodiments, the keyword index may include entries for name-value pairs found in events, wherein a name-value pair can include a pair of keywords connected by a symbol, such as an equals sign or colon. In this way, events containing these name-value pairs can be quickly located. In some embodiments, fields can automatically be generated for some or all of the name-value pairs at the time of indexing. For example, if the string \u201cdest=10.0.1.2\u201d is found in an event, a field named \u201cdest\u201d may be created for the event, and assigned a value of \u201c10.0.1.2.\u201d","Finally, the indexer stores the events in a data store at block , wherein a timestamp can be stored with each event to facilitate searching for events based on a time range. In some cases, the stored events are organized into a plurality of buckets, wherein each bucket stores events associated with a specific time range. This not only improves time-based searches, but it also allows events with recent timestamps that may have a higher likelihood of being accessed to be stored in faster memory to facilitate faster retrieval. For example, a bucket containing the most recent events can be stored as flash memory instead of on hard disk.","Each indexer  is responsible for storing and searching a subset of the events contained in a corresponding data store . By distributing events among the indexers and data stores, the indexers can analyze events for a query in parallel, for example using map-reduce techniques, wherein each indexer returns partial responses for a subset of events to a search head that combines the results to produce an answer for the query. By storing events in buckets for specific time ranges, an indexer may further optimize searching by looking only in buckets for time ranges that are relevant to a query.","Moreover, events and buckets can also be replicated across different indexers and data stores to facilitate high availability and disaster recovery as is described in U.S. patent application Ser. No. 14\/266,812 filed on 30 Apr. 2014, and in U.S. application patent Ser. No. 14\/266,817 also filed on 30 Apr. 2014.","1.4 Query Processing",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 3","b":["301","302","303"]},"Then, at block , the indexers to which the query was distributed search their data stores for events that are responsive to the query. To determine which events are responsive to the query, the indexer searches for events that match the criteria specified in the query. This criteria can include matching keywords or specific values for certain fields. In a query that uses a late-binding schema, the searching operations in block  may involve using the late-binding scheme to extract values for specified fields from events at the time the query is processed. Next, the indexers can either send the relevant events back to the search head, or use the events to calculate a partial result, and send the partial result back to the search head.","Finally, at block , the search head combines the partial results and\/or events received from the indexers to produce a final result for the query. This final result can comprise different types of data depending upon what the query is asking for. For example, the final results can include a listing of matching events returned by the query, or some type of visualization of data from the returned events. In another example, the final result can include one or more calculated values derived from the matching events.","Moreover, the results generated by system  can be returned to a client using different techniques. For example, one technique streams results back to a client in real-time as they are identified. Another technique waits to report results to the client until a complete set of results is ready to return to the client. Yet another technique streams interim results back to the client in real-time until a complete set of results is ready, and then returns the complete set of results to the client. In another technique, certain results are stored as \u201csearch jobs,\u201d and the client may subsequently retrieve the results by referencing the search jobs.","The search head can also perform various operations to make the search more efficient. For example, before the search head starts executing a query, the search head can determine a time range for the query and a set of common keywords that all matching events must include. Next, the search head can use these parameters to query the indexers to obtain a superset of the eventual results. Then, during a filtering stage, the search head can perform field-extraction operations on the superset to produce a reduced set of search results.","1.5 Field Extraction",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 4","FIG. 4"],"b":["402","404","404","104","102","402","402"]},"Upon receiving search query , query processor  sees that search query  includes two fields \u201cIP\u201d and \u201ctarget.\u201d Query processor  also determines that the values for the \u201cIP\u201d and \u201ctarget\u201d fields have not already been extracted from events in data store , and consequently determines that query processor  needs to use extraction rules to extract values for the fields. Hence, query processor  performs a lookup for the extraction rules in a rule base , wherein rule base  maps field names to corresponding extraction rules and obtains extraction rules -, wherein extraction rule  specifies how to extract a value for the \u201cIP\u201d field from an event, and extraction rule  specifies how to extract a value for the \u201ctarget\u201d field from an event. As is illustrated in , extraction rules - can comprise regular expressions that specify how to extract values for the relevant fields. Such regular-expression-based extraction rules are also referred to as \u201cregex rules.\u201d In addition to specifying how to extract field values, the extraction rules may also include instructions for deriving a field value by performing a function on a character string or value retrieved by the extraction rule. For example, a transformation rule may truncate a character string, or convert the character string into a different data format. In some cases, the query itself can specify one or more extraction rules.","Next, query processor  sends extraction rules - to a field extractor , which applies extraction rules - to events - in a data store . Note that data store  can include one or more data stores, and extraction rules - can be applied to large numbers of events in data store , and are not meant to be limited to the three events - illustrated in . Moreover, the query processor  can instruct field extractor  to apply the extraction rules to all the events in a data store , or to a subset of the events that has been filtered based on some criteria.","Next, field extractor  applies extraction rule  for the first command \u201cSearch IP=\u201c10*\u201d to events in data store  including events -. Extraction rule  is used to extract values for the IP address field from events in data store  by looking for a pattern of one or more digits, followed by a period, followed again by one or more digits, followed by another period, followed again by one or more digits, followed by another period, and followed again by one or more digits. Next, field extractor  returns field values  to query processor , which uses the criterion IP=\u201c10*\u201d to look for IP addresses that start with \u201c10\u201d. Note that events  and  match this criterion, but event  does not, so the result set for the first command is events -.","Query processor  then sends events - to the next command \u201cstats count target.\u201d To process this command, query processor  causes field extractor  to apply extraction rule  to events -. Extraction rule  is used to extract values for the target field for events - by skipping the first four commas in events -, and then extracting all of the following characters until a comma or period is reached. Next, field extractor  returns field values  to query processor , which executes the command \u201cstats count target\u201d to count the number of unique values contained in the target fields, which in this example produces the value \u201c2\u201d that is returned as a final result  for the query.","Note that query results can be returned to a client, a search head, or any other system component for further processing. In general, query results may include: a set of one or more events; a set of one or more values obtained from the events; a subset of the values; statistics calculated based on the values; a report containing the values; or a visualization, such as a graph or chart, generated from the values.","1.6 Exemplary Search Screen",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 6A","FIG. 6B"],"b":["600","600","602","612","600"]},"After the search is executed, the search screen  can display the results through search results tabs , wherein search results tabs  includes: an \u201cevents tab\u201d that displays various information about events returned by the search; a \u201cstatistics tab\u201d that displays statistics about the search results; and a \u201cvisualization tab\u201d that displays various visualizations of the search results. The events tab illustrated in  displays a timeline graph  that graphically illustrates the number of events that occurred in one-hour intervals over the selected time range. It also displays an events list  that enables a user to view the raw data in each of the returned events. It additionally displays a fields sidebar  that includes statistics about occurrences of specific fields in the returned events, including \u201cselected fields\u201d that are pre-selected by the user, and \u201cinteresting fields\u201d that are automatically selected by the system based on pre-specified criteria.","1.7 Acceleration Techniques","The above-described system provides significant flexibility by enabling a user to analyze massive quantities of minimally processed performance data \u201con the fly\u201d at search time instead of storing pre-specified portions of the performance data in a database at ingestion time. This flexibility enables a user to see correlations in the performance data and perform subsequent queries to examine interesting aspects of the performance data that may not have been apparent at ingestion time.","However, performing extraction and analysis operations at search time can involve a large amount of data and require a large number of computational operations, which can cause considerable delays while processing the queries. Fortunately, a number of acceleration techniques have been developed to speed up analysis operations performed at search time. These techniques include: (1) performing search operations in parallel by formulating a search as a map-reduce computation; (2) using a keyword index; (3) using a high performance analytics store; and (4) accelerating the process of generating reports. These techniques are described in more detail below.","1.7.1 Map-Reduce Technique","To facilitate faster query processing, a query can be structured as a map-reduce computation, wherein the \u201cmap\u201d operations are delegated to the indexers, while the corresponding \u201creduce\u201d operations are performed locally at the search head. For example,  illustrates how a search query  received from a client at search head  can split into two phases, including: (1) a \u201cmap phase\u201d comprising subtasks  (e.g., data retrieval or simple filtering) that may be performed in parallel and are \u201cmapped\u201d to indexers  for execution, and (2) a \u201creduce phase\u201d comprising a merging operation  to be executed by the search head when the results are ultimately collected from the indexers.","During operation, upon receiving search query , search head  modifies search query  by substituting \u201cstats\u201d with \u201cprestats\u201d to produce search query , and then distributes search query  to one or more distributed indexers, which are also referred to as \u201csearch peers.\u201d Note that search queries may generally specify search criteria or operations to be performed on events that meet the search criteria. Search queries may also specify field names, as well as search criteria for the values in the fields or operations to be performed on the values in the fields. Moreover, the search head may distribute the full search query to the search peers as is illustrated in , or may alternatively distribute a modified version (e.g., a more restricted version) of the search query to the search peers. In this example, the indexers are responsible for producing the results and sending them to the search head. After the indexers return the results to the search head, the search head performs the merging operations  on the results. Note that by executing the computation in this way, the system effectively distributes the computational operations while minimizing data transfers.","1.7.2 Keyword Index","As described above with reference to the flow charts in , event-processing system  can construct and maintain one or more keyword indices to facilitate rapidly identifying events containing specific keywords. This can greatly speed up the processing of queries involving specific keywords. As mentioned above, to build a keyword index, an indexer first identifies a set of keywords. Then, the indexer includes the identified keywords in an index, which associates each stored keyword with references to events containing that keyword, or to locations within events where that keyword is located. When an indexer subsequently receives a keyword-based query, the indexer can access the keyword index to quickly identify events containing the keyword.","1.7.3 High Performance Analytics Store","To speed up certain types of queries, some embodiments of system  make use of a high performance analytics store, which is referred to as a \u201csummarization table,\u201d that contains entries for specific field-value pairs. Each of these entries keeps track of instances of a specific value in a specific field in the event data and includes references to events containing the specific value in the specific field. For example, an exemplary entry in a summarization table can keep track of occurrences of the value \u201c94107\u201d in a \u201cZIP code\u201d field of a set of events, wherein the entry includes references to all of the events that contain the value \u201c94107\u201d in the ZIP code field. This enables the system to quickly process queries that seek to determine how many events have a particular value for a particular field, because the system can examine the entry in the summarization table to count instances of the specific value in the field without having to go through the individual events or do extractions at search time. Also, if the system needs to process all events that have a specific field-value combination, the system can use the references in the summarization table entry to directly access the events to extract further information without having to search all of the events to find the specific field-value combination at search time.","In some embodiments, the system maintains a separate summarization table for each of the above-described time-specific buckets that stores events for a specific time range, wherein a bucket-specific summarization table includes entries for specific field-value combinations that occur in events in the specific bucket. Alternatively, the system can maintain a separate summarization table for each indexer, wherein the indexer-specific summarization table only includes entries for the events in a data store that is managed by the specific indexer.","The summarization table can be populated by running a \u201ccollection query\u201d that scans a set of events to find instances of a specific field-value combination, or alternatively instances of all field-value combinations for a specific field. A collection query can be initiated by a user, or can be scheduled to occur automatically at specific time intervals. A collection query can also be automatically launched in response to a query that asks for a specific field-value combination.","In some cases, the summarization tables may not cover all of the events that are relevant to a query. In this case, the system can use the summarization tables to obtain partial results for the events that are covered by summarization tables, but may also have to search through other events that are not covered by the summarization tables to produce additional results. These additional results can then be combined with the partial results to produce a final set of results for the query. This summarization table and associated techniques are described in more detail in U.S. Pat. No. 8,682,925, issued on Mar. 25, 2014.","1.7.4 Accelerating Report Generation","In some embodiments, a data server system such as the SPLUNK\u00ae ENTERPRISE system can accelerate the process of periodically generating updated reports based on query results. To accelerate this process, a summarization engine automatically examines the query to determine whether generation of updated reports can be accelerated by creating intermediate summaries. (This is possible if results from preceding time periods can be computed separately and combined to generate an updated report. In some cases, it is not possible to combine such incremental results, for example where a value in the report depends on relationships between events from different time periods.) If reports can be accelerated, the summarization engine periodically generates a summary covering data obtained during a latest non-overlapping time period. For example, where the query seeks events meeting a specified criteria, a summary for the time period includes only events within the time period that meet the specified criteria. Similarly, if the query seeks statistics calculated from the events, such as the number of events that match the specified criteria, then the summary for the time period includes the number of events in the period that match the specified criteria.","In parallel with the creation of the summaries, the summarization engine schedules the periodic updating of the report associated with the query. During each scheduled report update, the query engine determines whether intermediate summaries have been generated covering portions of the time period covered by the report update. If so, then the report is generated based on the information contained in the summaries. Also, if additional event data has been received and has not yet been summarized, and is required to generate the complete report, the query can be run on this additional event data. Then, the results returned by this query on the additional event data, along with the partial results obtained from the intermediate summaries, can be combined to generate the updated report. This process is repeated each time the report is updated. Alternatively, if the system stores events in buckets covering specific time ranges, then the summaries can be generated on a bucket-by-bucket basis. Note that producing intermediate summaries can save the work involved in re-running the query for previous time periods, so only the newer event data needs to be processed while generating an updated report. These report acceleration techniques are described in more detail in U.S. Pat. No. 8,589,403, issued on Nov. 19, 2013, and U.S. Pat. No. 8,412,696, issued on Apr. 2, 2011.","System for Collecting Hypervisor Data and Operating System Data for a VM",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 7","FIG. 7"],"b":["702","712","722","702","712","722","702","704","706","712","714","716","722","724","726"]},"Note that all of these virtual machines ,  and  and associated hypervisors ,  and  operate under control of a management server, which is referred to as a \u201cvirtual center\u201d . Virtual center  performs operations to facilitate centralized management, operational automation, resource optimizations and high availability for the virtual machines ,  and , which execute on hypervisors ,  and . Virtual center  additionally obtains performance-related data from hypervisors ,  and . This performance-related data is sent to a forwarder , which forwards the performance-related data to an indexer , wherein indexer  stores the data in data store . In some embodiments, forwarder  obtains this performance-related data by making calls through an application programming interface (API) provided by virtual center .","The performance-related data obtained from hypervisors ,  and  is referred to as \u201chypervisor data\u201d . For example, hypervisor data  can include, but is not limited to: resource utilization parameters for virtual machines; resource utilization parameters for physical hosts; performance metrics for virtual machines; and performance metrics for physical hosts.","The system also obtains performance-related data from operating systems within the virtual machines. To illustrate how this performance-related data is gathered, the internal structure for a specific virtual machine  is illustrated in . The specific virtual machine  includes an operating system , which is responsible for managing the execution of various applications and processes . For example, operating system  can include the Linux\u2122 operating system. A special forwarder  is installed on operating system  to forward performance-related data to indexer .","This performance-related data obtained from inside virtual machine operating systems is referred to as \u201coperating system\u201d (OS) data . For example, OS data  can include, but is not limited to: resource utilization parameters for virtual processes running inside the virtual machines; performance metrics for the virtual processes; identifiers for owners associated with the virtual processes; and performance data obtained from the set of operating systems and log data from operating system logs maintained by the set of operating systems. Note that this log data can include data from: underlying system logs; security logs for authentication; configuration change logs; and Internet information services (IIS) logs.","It can also be useful to know which owners are associated with specific virtual processes. For example, an owner of a process that executes inside a virtual machine is typically an administrator or a service owner. Hence, when the system determines that a standard user, who is not an administrator or a service owner, is running a process on a virtual machine, the system can determine that this circumstance is a security exception and can deal with the process accordingly.","Another piece of software, which is referred to as a technology add-on (TA) , is installed over special forwarder . TA  specifies how to collect OS data , including specifying the sources of the OS data and the frequency of collection. For example, OS data can be collected from various operating system logs, such as an event, log a security log, or an event-scheduling \u201ccron\u201d log. The OS data can also be collected from internal operating system kernel data structures to obtain information about the performance of specific virtual processes. TA  directs the collected OS data to special forwarder , and special forwarder  in turn forwards OS data  to indexer .","Correlating Hypervisor Data and OS Data for a VM",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 8","b":["802","804"]},"Next, the system correlates the hypervisor data for a virtual machine with corresponding operating system data for the virtual machine (step ). For example, the system can match hypervisor data for a virtual machine with corresponding operating system data for the same virtual machine by identifying the data with reference to a medium-access control (MAC) address associated with the virtual machine.","Note that a MAC address can serve as a unique identifier for the virtual machine. Hence, if a MAC address is stored along with the performance data by the hypervisor and also by the operating system, the MAC address can subsequently be used to identify the virtual machine that generated the performance data. This enables the system to correlate hypervisor and operating system performance data for the virtual machine. For example, suppose the system retrieves an event containing memory-utilization performance data from the hypervisor, wherein the event includes a MAC address for the virtual machine. Additionally, suppose the system retrieves another event containing memory-utilization performance data from an operating system in the same virtual machine, wherein the event also includes the MAC address for the virtual machine. In this example, the system can match the events based on the MAC address for the virtual machine, and can display the corresponding data from the hypervisor and from the operating system together in a single display for the virtual machine as is described in more detail below with reference to . Note that this type of correlation can be performed automatically or manually.","The system can additionally use other types of information to identify a virtual machine that generated the data, such as (1) one or more IP addresses for the virtual machine, and (2) a host name identifying a physical host on which the virtual machine executes. Also, note that to uniquely identify a host, the system can use one or more MAC addresses, plus one or more IP addresses. (Because a MAC address is unique on a network, it is also unique within a hypervisor and hence can be used for correlation.)","Next, the system presents the correlated hypervisor data and operating system data for the virtual machine to a user (step ). For example, the system can present the hypervisor and operating system data together in a single view to enable the user to understand relationships between the hypervisor data and operating system data. In another example, the system facilitates executing a single query, which is specified in a query language, wherein the single query operates on both the hypervisor data and the operating system data for the set of virtual machines to generate a query result. In yet another example, the system can use the hypervisor data and the operating system data to establish a baseline to facilitate subsequently determining when the system undergoes a noteworthy change.","The information that is presented in this way can be quite useful. For example, the information can enable an administrator to determine whether an application is using more memory than it has been allocated, and to make a decision about whether the memory allocation needs to be increased for this application. In another example, the administrator can determine that a process is a \u201crogue process\u201d that should not be running on a virtual machine, and can take steps to shut down the rogue process.","In some embodiments, the system additionally computes differences between performance metrics in the hypervisor data and corresponding performance metrics in the operating system data (step ), and the system presents the computed differences to the user (step ). Note that informing the user about a significant difference between a performance metric that appears in the hypervisor data and the same performance metric that appears in the operating system data makes the user aware of an uncertainty in measuring the performance metrics, and thereby enables the user to look for a cause of the discrepancy. A number of factors can cause this type of discrepancy, including the overhead involved in running the operating system on the virtual machine, and the overhead involved in running the virtual machine itself on the hypervisor.","Displaying Hypervisor Data with Operating System Data",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 9","FIG. 9"],"b":["900","902","903","907"]},"The middle section of display  presents a memory utilization graph , which includes a solid line  representing memory utilization for the entire virtual machine as a percentage of the total memory that has been allocated to the virtual machine. Note that line  is constructed from information obtained from hypervisor data . Memory utilization graph  also includes a dashed line  representing memory utilization for a selected process as a percentage of the total memory that has been allocated to the virtual machine. Note that dashed line  is constructed from information obtained from OS data .","The bottom section of display  presents a CPU utilization graph , which includes a solid line  representing CPU utilization for the entire virtual machine as a percentage of the total CPU capacity that has been allocated to the virtual machine. This solid line  is constructed from information obtained from hypervisor data . CPU utilization graph  also includes a dashed line  representing CPU utilization for a selected process as a percentage of the total CPU capacity that has been allocated to the virtual machine. Note that dashed line  is constructed from information obtained from OS data .","When a user selects one of processes - within top section , the system displays the corresponding memory utilization and CPU utilization information for the selected process in the graphs that appear in the middle section  and bottom section  of display . This enables the user to determine, for example, whether an increase in CPU utilization for the virtual machine can be attributed to an increase in CPU utilization for a specific process. The user can also double-click on one of the processes in top section  to expose other types of operating-system-level information for the process.","The display illustrated in  is merely an example of a type of display that can be used to present both hypervisor data and operating system data for a virtual machine at the same time. In general, many different types of user interface can be used. For example, the system can provide a workflow that lets a user drill down from the perspective of the specific applications and processes into virtual machines associated with the specific applications and processes, as opposed to drilling down starting from a virtual machine hierarchy. This enables an administrator to more easily investigate the root cause of performance problems for specific applications and processes.","The preceding description was presented to enable any person skilled in the art to make and use the disclosed embodiments, and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art, and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the disclosed embodiments. Thus, the disclosed embodiments are not limited to the embodiments shown, but are to be accorded the widest scope consistent with the principles and features disclosed herein. Accordingly, many modifications and variations will be apparent to practitioners skilled in the art. Additionally, the above disclosure is not intended to limit the present description. The scope of the present description is defined by the appended claims.","The data structures and code described in this detailed description are typically stored on a computer-readable storage medium, which may be any device or medium that can store code and\/or data for use by a system. The computer-readable storage medium includes, but is not limited to, volatile memory, non-volatile memory, magnetic and optical storage devices such as disk drives, magnetic tape, CDs (compact discs), DVDs (digital versatile discs or digital video discs), or other media capable of storing code and\/or data now known or later developed.","The methods and processes described in the detailed description section can be embodied as code and\/or data, which can be stored on a non-transitory computer-readable storage medium as described above. When a system reads and executes the code and\/or data stored on the non-transitory computer-readable storage medium, the system performs the methods and processes embodied as data structures and code and stored within the non-transitory computer-readable storage medium.","Furthermore, the methods and processes described above can be included in hardware modules. For example, the hardware modules can include, but are not limited to, application-specific integrated circuit (ASIC) chips, field-programmable gate arrays (FPGAs), and other programmable-logic devices now known or later developed. When the hardware modules are activated, the hardware modules perform the methods and processes included within the hardware modules."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
