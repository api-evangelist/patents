---
title: Method and software for facilitating interaction with a personal information manager application at a wireless communication device
abstract: Software executable by a wireless communication device may include instructions for receiving at least one markup language document containing a markup language definition defining a query of a notional database table. The notional database table may be characterized by a set of notional fields, each corresponding to a field of a data record within an information category maintained by each of a plurality of wireless communication device-executable personal information manager (PIM) software applications. The software may further include instructions for instantiating, based on the markup language definition, an instance of at least one object-oriented class containing code for effecting the query through interaction with one PIM software application, executable at said wireless communication device, of the plurality. Software for defining the query in markup language may also be provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07904468&OS=07904468&RS=07904468
owner: Research In Motion Limited
number: 07904468
owner_city: Waterloo, Ontario
owner_country: CA
publication_date: 20080227
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF TECHNOLOGY","BACKGROUND","DETAILED DESCRIPTION"],"p":["The present disclosure relates to a method and software for facilitating interaction with a personal information manager application at a wireless communication device.","Personal information manager (PIM) software applications are computer programs which allow a user to maintain and organize various types of personal information and which provide electronic mail (email) functionality. PIM software applications (or simply \u201cPIM applications\u201d) typically maintain personal information in distinct information categories. The information categories that are maintained usually include an email message inbox, an email message outbox, a set of previously transmitted email messages or \u201csent items\u201d, an address book containing contact information, a scheduling calendar (or i.e. a set of appointments, notes, and a list of tasks to be completed. Microsoft Outlook\u2122 is an example of a PIM software application. PIM applications may be designed for execution by a wireless communication device, such as a two-way paging device, a Windows CE operating system based device, a PalmOS device, a Wireless Application Protocol (WAP) enabled mobile telephone, or the like.","Within an information category of a PIM application, an individual data item, such as an email message, contact, or appointment (as appropriate), may be stored in the form of a data record. The format of the data record may be PIM application-specific. A PIM application may include an application programming interface (API) to allow other programs to interact with the PIM application or to access information stored within one or more information categories. Because data record formats and APIs may vary from PIM application to PIM application, however, it may be difficult to develop software that is capable of interacting with different PIM applications or different types of wireless communication devices.","A solution which addresses this problem would be desirable.","The present description generally pertains to a method and software for facilitating interaction with a personal information manager application at a wireless communication device. Some embodiments, such as the one described hereinafter, may be implemented in the context of a system for presenting data from a server-based application at a wireless communication device, as described in U.S. Patent Publication No. 2003\/0060896 entitled SOFTWARE, DEVICES AND METHODS FACILITATING EXECUTION OF SERVER-SIDE APPLICATIONS AT MOBILE DEVICES for example, which is hereby incorporated by reference hereinto.","In one aspect of the below-described embodiment, there is provided a machine-readable medium comprising instructions that, when executed by a processor of a wireless communication device, adapt said wireless communication device to: receive at least one markup language document containing a markup language definition defining a query of a notional database table, said notional database table having a set of notional fields, each of said notional fields corresponding to a field of a data record within an information category maintained by each of a plurality of wireless communication device-executable personal information manager (PIM) software applications; and instantiate, based on said markup language definition, an instance of at least one object-oriented class containing code for effecting said query through interaction with a PIM software application of said plurality of PIM software applications, said PIM software application being executable at said wireless communication device.","In another aspect of the below-described embodiment there is provided a method comprising, at a wireless communication device: receiving at least one markup language document containing a markup language definition defining a query of a notional database table, said notional database table having a set of notional fields, each of said notional fields corresponding to a field of a data record within an information category maintained by each of a plurality of wireless communication device-executable personal information manager (PIM) software applications; and instantiating, based on said markup language definition, an instance of at least one object-oriented class containing code for effecting said query through interaction with a PIM software application of said plurality of PIM software applications, said PIM software application being executable at said wireless communication device.","In yet another aspect of the below-described embodiment there is provided a machine-readable medium comprising instructions that, when executed by a processor of a computing device, adapt said computing device to: present at least one graphical user interface control for specifying a notional database table corresponding to an information category maintained by each of a plurality of wireless communication device-executable personal information manager (PIM) software applications, said notional database table being characterized by a set of notional fields, each of said notional fields corresponding to a field of a data record within said information category; and generate, based on user interaction with said at least one graphical user interface control, a markup language definition defining a query of said notional database table.","In overview, and referring to , which provides a high-level overview of an exemplary embodiment, a developer  interacting with a Rapid Application Development tool (described hereinafter) generates an application definition file . The application definition file  is a markup language document, such as an Extensible Markup Language (XML) document for example, containing markup language describing various aspects of a \u201cmobile application\u201d, i.e., an application to be executed at a wireless communication device (not illustrated). The aspects of the mobile application that are described in this document generally include a graphical user interface for the mobile application defining multiple Graphical User Interface (GUI) screens, a flow of control from GUI screen to GUI screen, and a format of one or more database tables to be used to store data related to the application at the wireless communication device. The mobile application (also referred to simply as an \u201capplication\u201d) may be designed to exchange messages with and emulate a server-based application for example, as described in U.S. Patent Publication No. 2003\/0060896, referenced above. The markup language in the document is interpreted at the wireless communication device by \u201cvirtual machine\u201d software , which effects the desired functionality described in the application definition file, as described in the above-referenced publication and in Appendix \u201cA\u201d of the present application.","As shown in , application definition file  includes a set  of five markup language definitions , , ,  and , each defining an aspect (in some cases, a relatively narrow aspect) of the application. Each definition is a markup language fragment containing one or more, possibly nested, markup language elements having markup language attributes.","The first markup language definition  defines a format for a database table for storing data related to the application at the wireless communication device herein as described in Appendix \u201cA\u201d. The table defined in definition  is referred to herein as a \u201cuser-defined\u201d table because the user (i.e. developer ) has defined its structure by way of the RAD tool, which is used to generate the application definition file .","The second definition  defines a query of the database table that is defined by the first definition . A query defines search parameters for extracting desired records from a specified database table at run time. For example, the extracted records may be used to populate a GUI screen of the mobile application with relevant application data at run time, as described in Appendix \u201cA\u201d (see Section 5.2).","The third markup language definition  defines a query in a similar manner as the second definition , except that the specified database table is not a user-defined table but rather is a pre-existing, notional database table representing a PIM application information category, as will be described.","The fourth markup language definition  defines a rule for dynamically updating the notional database table of definition  (e.g. adding or updating records in the table) based on messages received from the server-based application for example.","The fifth markup language definition  defines a \u201cSENDMAIL\u201d action which, at run time, causes an email message that is \u201chard-coded\u201d within the definition  by developer  to be sent to a developer-specified email address upon the occurrence of a specific event, such as the pressing of a button on a GUI screen of the mobile application for example.","When the developer has finalized the application definition file , it is downloaded to the wireless communication device and interpreted by the virtual machine software  to implement the desired mobile application functionality. At run time, an object , , ,  and  corresponding to each of the five markup language definitions , , ,  and , respectively, is instantiated from the appropriate object-oriented classes, and the data members of the objects are populated with the markup language element and attribute values of the corresponding definitions so as to \u201ccustomize\u201d the objects for effecting the desired functionality. The objects , , ,  and  are part of an overall set of objects  instantiated by the virtual machine software  responsive to the application definition file  for implementing the overall functionality of the mobile application.","In order to implement the functionality defined within the set of definitions , the virtual machine software  interacts with other applications  hosted at the wireless communication device, namely, a database management system (DBMS) , having an associated database , and a PIM application . The interaction is motivated or governed by the markup language definitions , however, the details of the interaction are \u201chard-coded\u201d within the objects , , ,  and  and thus are transparent from the perspective of developer . This is done intentionally, so that the developer is not required to learn the low-level details of the interaction.","For example, table object  invokes DBMS-specific code  at run time for the purpose of creating and accessing a database table  within database , which table  is consistent with the user's table definition . Query object , on the other hand, invokes methods (i.e. routines) within table object  to effect a query of the table  at run time that is consistent with the user's query definition .","In another example, query object  may invoke methods of table object  in order to access information stored within one of the information categories  maintained by the PIM application, such as the email inbox category . Unlike table object , table object  is not instantiated based on a markup language table definition  however. Rather, the table object  is \u201chard-coded\u201d or pre-existing within the virtual machine software . This is due to the fact that the structure of the notional table that is used to abstract the information category , in terms of the notional fields that make up individual records of the table, is predetermined so as to correspond to (predetermined) data fields of a data record within information category  within the PIM application . These notional fields also correspond to fields of a data record within information category  in other wireless communication device-executable PIM applications with which the virtual machine software  may intercommunicate on other types of wireless communication devices. The table object  simply provides a convenient mechanism for accessing or manipulating data within the information category . It allows that PIM information category  (i.e. the email inbox) to be made to appear to the developer , as a database table having a predetermined name and predetermined fields. The fields represent common data fields within email inboxes which would exist in any PIM application that the developer  may attempt to access by way of table object . When the developer  uses the RAD tool to author query definition  which defines a run-time access or manipulation of PIM data, the developer  can refer to the predefined table and its notional fields by name in the same way as he refers to a table and fields of a user-defined table, without actually having to define the table from scratch within the application definition file  as he must do for user defined database tables. Indeed, the developer  cannot define the table in the application definition file , since the notional fields are predetermined. In the case of information category  (i.e. an email inbox), the notional fields include only the data fields that are common to email inboxes across a number of PIM applications with which the virtual machine software  may interact on different wireless communication devices. Thus the developer  can advantageously define and use markup language-defined queries, whose format should be familiar to him based on his past authoring of queries for accessing user-defined database tables, to access PIM data. From the perspective of developer , PIM data is accessed or manipulated by way of a notional database table operation (e.g. add, delete or update record). The format of the markup language-defined queries is the same regardless of whether the table is notional or user-defined. That is, in both cases, the markup language definitions conform to the same markup language schema (not illustrated). Meanwhile, the actual operation is effected by table object , in the form of PIM API calls  to PIM API  which may be proprietary or specific to the PIM application , in a manner that is transparent to the developer.","The table object  may be used by a rule object  to dynamically update the content of notional database table (i.e. PIM email inbox data) based on messages received at the wireless communication device at run time. The impact of a message upon PIM data is conveniently expressed in the form of a conventional database operation (e.g. add, delete or update record). The table object  essentially \u201ctranslates\u201d the conventional database operations to one or more appropriate PIM API calls  that achieve the desired result.","For each of the remaining information categories , , , ,  and  of PIM application , a table object analogous to table object  for accessing the relevant category of PIM data also exists within objects . These table objects are collectively referred to as table objects .","As well, an action object  makes appropriate PIM API calls  to cause an email message to be sent by PIM application  upon the occurrence of a specified event. The email addressee(s) and the substance of the email message are defined by the developer  within the markup language definition . From the developer's perspective, all that must be done in order to cause virtual machine software  to send an email message to a specified addressee at run time is to create a \u201cSENDMAIL\u201d action  in the application definition file . This results in an appropriate PIM API call  to PIM API  by action object  at run time for sending the desired email message, of which the developer  need not be aware. The developer  is thus shielded from the details of using the (PIM application-specific) PIM API  for causing an email message to be sent from virtual machine software .",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2","b":["100","40"]},"The system  of  includes an application server , a transaction server , a network gateway , a pair of exemplary wireless communication devices (also referred to as \u201cmobile devices\u201d herein and in U.S. Patent Publication No. 2003\/0060896)  and , and a Rapid Application Development (RAD) tool . The application server , transaction server , network gateway , and wireless communication devices  and  are analogous to the application server , middleware server , network gateway , and mobile devices  and , respectively, of U.S. Patent Publication No. 2003\/0060896, and will thus not be described in great detail, except to the degree that these components are modified from their implementation as described in the above-noted publication.","Application server  is a server which hosts at least one conventional software application  to which wireless communication device access is desired. The application  receives and generates data. The role of system  is to present data generated by the application  at wireless communication devices  and\/or  and to send data generated at wireless communication devices  and\/or  (e.g. responsive to user interaction with the devices) back to the application . The application server  sends and receives this data to and from transaction server  over a data network , which may be the Internet or a private data network for example, e.g. using HTTP running on top of a standard TCP\/IP stack. In the present embodiment, the application  is an electronic mail (email) application, however in alternative embodiments, application  could be another type of application.","Transaction server  corresponds to middleware server  of U.S. Patent Publication No. 2003\/0060896. As described in that publication, the role of transaction server  is essentially twofold. First, the transaction server  stores application-specific markup language documents (referred to as application definition files in the above-noted U.S. patent publication and hereinafter) for downloading by wireless communication devices ,  desirous of presenting data from an application  executing at application server . The application definition files dictate the behavior and user interface (GUI) of the wireless communication devices. Second, once presentation of data from application  at a wireless communication device  or  has begun, the transaction server acts as an intermediary for communications between the application server  and the wireless communication device  or .","Network gateway  is a gateway between data network , which may be the Internet or a private data network for example, and a wireless network . In combination, data network , network gateway , and wireless network  facilitate communication of application data between the transaction server  and wireless communication devices  and .","Wireless communication devices  and  may for example be two-way paging devices, WinCE based devices (e.g. Pocket PC devices), PalmOS devices, Wireless Application Protocol (WAP) enabled mobile telephones, or the like, which are capable of presenting data from remote applications as described in detail in the above-referenced U.S. Patent Publication. In the illustrated embodiment, wireless communication device  is of a different type than device , i.e., it executes a different operating system and may have different physical characteristics such as differently sized display screen or different processor. Each device  and  also hosts a PIM application. The PIM application hosted at the device  is different from the PIM application hosted at device . However, as will be appreciated, the virtual machine software hosted at each of devices ,  is tailored to the local PIM application.","RAD tool  is a computing device , such as an Intel\u00ae-Processor based personal computer (PC) for example, executing software that allows a developer to create master definition files for uploading to transaction server . A master definition file is a markup language document similar to an application definition file, except that its contents may dictate user interface appearance and control flow of a mobile application for more than one type of wireless communication device. Application definition files are created from master definition files at transaction server , as described in the above-referenced U.S. Patent Publication No. 2003\/0060896. Application definition files  are downloaded to wireless communication devices  and  where they are interpreted by virtual machine software. Uploading of the master definition file to from the RAD tool  to the application server  may be performed over a data network , which may be the Internet or a private data network for example.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":["118","118","118","132","135","136","138","146"]},"Network interface  enables device  to transmit and receive data over a wireless network .","Memory  is volatile memory such as static random access memory (SRAM). At run time, memory  stores an operating system , virtual machine software , a database management system  and a PIM application .","Operating system  is software representing a mobile operating system, which in the case of device  is the WinCE operating system. Operating system  includes graphical user interface and network interface software having suitable application programmer interfaces (APIs) for use by applications executing at device . The operating system  is different from the operating system executing on the other wireless communication device  (), which may be the PalmOS operating system for example.","Virtual machine software  is software that enables wireless communication device  to present a user interface for server-side applications such as application  (). The virtual machine software  may be downloaded over wireless network  to the device  from transaction server , where it may be stored as instructions (e.g. machine-executable code) on a machine-readable medium such as a hard disk drive or a removable optical disk  () for example. As previously noted, the operation of virtual machine software  is governed by the application definition file . Virtual machine software  is described below in greater detail.","Database management system (DBMS)  is a conventional DBMS which facilitates storage of data to and manipulation of data from database  which is resident in secondary storage  of device . DBMS  may be a commercially available database management system, such as Sybase\u2122, Microsoft\u00ae Pocket Access, Microsoft\u00ae SQLCE, Oracle, or J2ME MIDP storage, for example, capable of execution at a wireless communication device. DBMS  is capable of executing queries, such as structured query language (SQL)-type queries, for extracting desired data from the database . DBMS  provides an Application Programming Interface (API) for query execution.","PIM software application , in the present embodiment, is the Microsoft Outlook\u2122 computer program for devices executing the WinCE operating system. As described above, PIM application  provides email capability and maintains personal information in distinct information categories. The information categories that are maintained include an email message inbox , a email message outbox , a set of previously transmitted email messages or \u201csent items\u201d , an address book containing contact information , a scheduling calendar , notes , and a list of tasks  to be completed.","User interface  provides a mechanism for entering data at wireless communication device  and for viewing a displayed graphical user interface. The interface  typically includes a keypad and a display such as a touch-screen.","Secondary storage  is non-volatile memory, such as flash memory for example, which stores an application definition file , and a database , described below.","Application definition file  is an application-specific markup language document which governs the operation of the wireless communication device . In the present embodiment, the application definition file  is an Extensible Markup Language (XML) document. The XML may for example be formed in accordance with the Extensible Markup Language (XML) 1.0 (Third Edition) W3C Recommendation dated 4 Feb. 2004, which is provided at www.w3.org\/TR\/2004\/REC-xml-20040204\/and is hereby incorporated by reference hereinto. The XML document contains a markup language definition  () defining a query of a notional database table which represents an information category maintained by the PIM application , in addition to other markup language definitions , ,  and  () described previously. Based on the XML elements (including any attributes thereof) contained in the application definition file , the virtual machine software  instantiates corresponding objects at run time to present data from the server-side application  and to accept user input for transmission back to the application  at application server , as will be described.","Database  comprises one or more electronic files storing data related to application  for access by the virtual machine software  via DBMS . In the present embodiment, the data is stored in tables, such as table , within the database . Each table contains records (rows) with user-defined fields (columns). The database  may for example be a relational database, but this is not required.","Object classes  are precompiled classes (object code) authored in an object-oriented language such as Java or C++. Each class corresponds to an XML element that may be defined within the application definition file . A description of most of the XML elements which may appear within the file  is provided in the AIRIX\u2122 markup language (ARML) specification of Appendix \u201cA\u201d attached hereto; other XML elements, such as those associated with markup language definitions ,  and  (), are described in the remainder of the description. A person of ordinary skill will readily appreciate that these collective XML entities are exemplary only, and may be extended, or modified as desired. The collective XML entities may be defined by way of a Document Type Definition (DTD) or other XML schema, both of which are well known in the art. At run time, the virtual machine software  instantiates one or more instances of at least some of object classes  in memory  of wireless communication device  () based on XML elements appearing within application definition file  and their attributes. The objects  of  are examples of such instances. Each object class  () defines methods which capture certain behaviours that are performed by all instances of the class (e.g. a button class may include a highlight( ) method which, if invoked for any instance of the button class, executes the same code to cause the relevant button to become highlighted), as well as data members which are set upon instantiation of a class instance in order to \u201ccustomize\u201d the characteristics or behavior of the instance (e.g. the button class may also include X and Y coordinate data members which are set to unique values for each button class instance to define a unique location for the represented button on an encompassing GUI screen). The classes  may be loaded from machine-readable medium  () along with the rest of the virtual machine software .","The structure of wireless communication device  is similar to that of wireless communication device , with the exception of its operating system and certain physical characteristics, such as display size for example.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 4","FIG. 2"],"b":["122","122","220","222","220","224","226","222","220","228","230","220","188","122","134","234","14"]},"The application development software  provides a graphical user interface which facilitates \u201cdrag and drop\u201d development of mobile applications. As a user develops a mobile application using UIM , the RAD tool  automatically generates a dynamically-accessible representation of the corresponding hierarchy of XML elements (e.g. in accordance with Appendix \u201cA\u201d within memory  and the below description) in the form of a master definition Document Object Model (DOM) tree  data structure. A DOM tree is essentially a dynamically-accessible representation of an XML document that is well understood in the art (DOM trees are described at www.w3.org\/DOM\/). The RAD software  may be implemented as a set of plug-ins to a generic integrated design environment (IDE) framework such as the Eclipse framework. As is known in the art, the Eclipse platform is designed for building integrated development environments that can be used to create various applications such as web sites, embedded Java\u2122 programs, C++ programs, and Enterprise JavaBeans\u2122 for example. The platform exposes mechanisms to use and rules to follow to tool providers via well-defined APIs, classes and methods. Application development software  may be written in Delphi, using an SQL Server database for example, and may be loaded into PC  from a machine-readable medium, such as an optical disk .","The master definition file  in secondary storage  is a serialized representation of the master definition DOM tree . The master definition file  is created by the application development software  when the user indicates that development of the mobile application is complete. The file  is stored in secondary storage  pending its transmission to the transaction server , where it is used to create an application definition file  that is downloaded to the wireless communication device .","In operation, a developer uses the RAD tool  () to develop a mobile application for the wireless communication device . To develop a mobile application, the developer: designs one or more graphical user interface screens along with the screen-to-screen control flow for the mobile application; specifies a format of data (e.g. XML packages) to be exchanged with the server-side application  via wireless network  (); and specifies a format of data (e.g. a database table such as table  of ) for storing application data in database  ().","The procedure for developing a mobile application consists of creating a visual hierarchy or \u201ctree\u201d of icons which correlates to a logical hierarchy of XML elements (e.g. as defined in Appendix \u201cA\u201d and as further defined below) using application development software . Each icon represents a building block of the application (e.g. a GUI screen, a database table, a database query, etc.) and corresponds to a defined XML element having (in most cases) associated attributes. As a user creates icons and assigns properties to them, the RAD tool  automatically generates a dynamically-accessible representation of the corresponding hierarchy of XML elements and attributes within memory  within the master definition DOM tree  data structure. When the user of tool  has completed development of the mobile application, the application is \u201cpublished\u201d, i.e. the master definition DOM tree  is serialized to form a master definition file .","The RAD software  presents a GUI  as shown in  to facilitate mobile application development. The GUI  includes various components, such as a toolbar , a project explorer , and a main design area .","The toolbar  provides a menu list and icons for performing various development activities during mobile application development, such as creating or opening a project (which corresponds to a mobile application) or serializing a master definition file DOM tree  to create a master definition file .","The project explorer  contains a visual hierarchy of icons  that is created by the developer to represent the mobile application. A detailed view of an exemplary project explorer is provided in .","The main design area  is for displaying an application component, such as a GUI screen or GUI screen component, whose icon  is currently selected in the project explorer . This area may include a screen designer window  and a properties window . When an icon  is selected in the visual hierarchy, a graphical representation of the relevant component\u2014a GUI screen in the case of icon \u2014is displayed in the screen designer window , and its properties are displayed in the properties window . The screen designer is a \u201cscreen painter\u201d which displays a graphical representation of the relevant wireless communication device type (a \u201cvirtual device\u201d) for which GUI screens are being created. In , a virtual Pocket PC device is show in the screen designer . The screen designer  permits a developer to design a GUI screen by dragging and dropping display elements (such as textual components, buttons, edit boxes, or other widgets) to the virtual device screen in the window, offering a \u201cwhat you see is what you get\u201d (WYSIWYG) view of the GUI screen under development. The properties window  displays the properties of a currently selected GUI component and allows them to be modified. The properties of a selected component generally correspond to attributes of an XML element within the master definition file DOM tree  corresponding to the selected component.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 6","FIG. 1"],"b":["254","270","70","270","272","274"]},"Platform-independent components  are application building blocks which are present in each platform's version of the mobile application. Put another way, all application definition files which will ultimately represent the mobile application at a wireless computing device will contain components , regardless of the platform of the device. Platform-specific components , on the other hand, may differ between wireless communication devices of different types, such as devices  and . Typically, it is the GUI screens of a wireless communication device application which will differ in some measure between wireless communication device types, due to differences in the capabilities of the devices (e.g. display\/screen size and supported display elements).","As shown in , the platform-independent components , which comprises the Device Independent branch of the visual hierarchy , include application events , data rules  and database tables .","Application events  are definitions of occurrences which trigger processing within the mobile application regardless of the application's status (e.g. regardless of which GUI screen is presently displayed). For example, the receipt of an XML package (a form of message) at the wireless communication device  or  at run time can be defined as an application level event. Beyond application level events, a developer may also define screen level events (arrival of an XML package when a specific GUI screen is displayed) and control level events (user manipulation of a GUI control such as a button press), however these are defined in the platform-specific constructs branch . It is noted that at least one action is normally defined in conjunction with each event to define the processing that will occur upon the occurrence of the event.","Data rules  dictate how XML packages received from enterprise applications such as application  affect data stored in database tables associated with an application. A rule defines which field(s) of a user-defined table or a notional database table representing a PIM information category (referred to as a \u201cnotional PIM table\u201d, described below) will be impacted by incoming data and the nature of the impact. Because rules make reference to database tables, if a rule pertains to a user-defined table, logically the rule should be defined after the table has been defined. If the rule pertains to a notional PIM table, the rule can be defined at any time because notional PIM tables are pre-existing (i.e. their definitions are hard-coded in the hierarchy  at ). Like application-level events , data rules  are wireless computing device type-independent. It is noted that rules can also be used to dictate the manner in which changes should be applied to database tables from XML created in an outgoing XML transaction in the context of an ARML action (although that is not a focus of the present description).","The procedure for defining a rule may be as follows. The icon corresponding to the Data Rules section  may initially be selected with a mouse (or similar user input mechanism ) of the RAD tool  (). A right-click (or similar user action) may cause a pop-up menu to be displayed. The pop-up menu may present a list of options in the context of the selected data rules section . An \u201cAdd Rule\u201d option may permit the user to define a new rule. Selection of that menu option may cause a new rule icon  to be created below icon , as shown in , and a Rule Properties window , as shown in , to be displayed in the main design area  ().","Referring to , the Rule Properties window  permits the user to enter properties of the newly defined rule. The window  includes a Rule Name text field  for user entry of a rule name for identifying the rule. The name that is entered in field , \u201cAddEmailToInbox\u201d, will be displayed as part of the icon  (see ).","A Package type field  () allows the user to specify the name (i.e. package type) of the XML package whose receipt at the wireless communication device  will trigger the table updates defined by the present rule. It is the responsibility of the developer to know the name of this XML package, which is generated by the back-end application  (). The name should match the TYPE attribute of the PKG element of the relevant XML package. For example, assuming that the XML package  shown in  is the package to be processed by the present rule, the package type \u201cME\u201d (shown at , line ) is entered in field , as shown in . The term \u201c{wrapper tags}\u201d (line ) refers to the ARML header XML elements (omitted for brevity) that surround the package so that the transaction server  and virtual machine software  knows which application and device (here, application  and application server ) the package from. In the illustrated embodiment, these are added by the application server  () before submitting the package to the transaction server .","Referring to , the Send to App check box  should be checked if the rule defined in Rule Properties window  pertains to the processing of an \u201coutgoing\u201d XML package (i.e. an XML package that is generated at the wireless communication device  and sent back to the application server  of  at run time). In the present example, the rule defines processing for an incoming package, thus check box  is left unchecked.","The rules for modifying one or more user-defined or notional PIM database tables are specified in grid  of window  in the form of one or more table updates. A table update specifies the modifications to be made to a single user-defined database table or notional PIM database table when the relevant package is processed (i.e. received, in the present example) at the wireless communication device  at run time. A table update is added by selecting the Add Table Update button . Each table update appears as a row within the grid  and represents a particular type of update (e.g. add record, delete record or update record) to a specified table. In , the grid  contains two table updates  and .","Referring first to table update , the table to be modified, \u201cPIMINBOX\u201d, is indicated in the \u201cTable Name\u201d column of grid . The \u201cPIM\u201d prefix the table name identifies the table as a notional PIM database table in the present embodiment. To specify this name, the user may select from a drop-down list identifying by name all of the pre-existing notional PIM database tables and user-defined tables (also represented iconically in the \u201cDatabase Tables\u201d branch  of , described below). As is known in the art, each selectable entry within a drop-down list is a form of selectable GUI control. The value \u201cADD\u201d of the \u201cUpdate Type\u201d column indicates that the present table update specifies an addition of a record to the named table. To specify an overwrite or update of specified fields in a table, the update type should be set to \u201cUPDATE\u201d; alternatively, to delete specific records, the update type should be set to \u201cDELETE\u201d. If the Update Type had been \u201cUPDATE\u201d or \u201cDELETE\u201d, a Where Field is typically specified in the \u201cIdentifier\u201d column of grid . When indicated, the Where Field, in conjunction with a Where Parameter in the \u201cParam\u201d column, effectively specify a where clause for identifying records of the named table (\u201cPIMINBOX\u201d) to which the table update  should be made. For example, if the \u201cIdentifier\u201d column contained the value \u201cVARFROM\u201d and the \u201cParam\u201d column contained the value \u201cFROM\u201d, table update  would only be applied to rows of the PIMINBOX table in which the VARFROM field matches the value of the \u201cFROM\u201d parameter (i.e. \u201cJoe Smith\u201d\u2014see , line ) of the received XML package.","The value \u201cMAIL\u201d of the \u201cElement\u201d column of grid  identifies the section of the relevant XML package within which the data to be ADDed to the PIMINBOX table is to be found. The term \u201csection\u201d merely refers to an XML element (or set of nested XML elements) within the XML package. For example, the \u201cMAIL\u201d section is shown at lines - of , and contains a nested \u201cDATA\u201d element.","The value \u201cNO\u201d of the \u201cMulti-row\u201d field column of grid  indicates that identified section, \u201cMAIL\u201d, of the XML package associated with the rule contains only one \u201cdata record\u201d (i.e. XML element) to be processed.","The table update  also has a number of associated parameter-field associations (not shown in ). A parameter-field association evidences a relationship between a parameter within the XML package (which is either an XML element or an XML attribute) and a data field within the relevant table to be updated. When the XML package is processed at run time, for each parameter-field association defined for a table, the value of the specified parameter within the package is written to the specified field of the relevant table. For table updates of type ADD or UPDATE, at least one parameter-field association should be specified in order to indicate the manner in which the XML package impacts upon the relevant table (which is either a user-defined database table or notional PIM database table). For table updates of type DELETE, no parameter-field associations are required, as the latter type of update simply results in the wholesale deletion of one or more records from the relevant table.","For each parameter-field association that is specified, the parameter type is specified as either an attribute or an element of the XML package. A parameter type of \u201cattribute\u201d indicates that the update data for the specified data field of the table is located in an attribute of either the XML element named in the \u201cElement\u201d column of grid  or in a nested XML element identified in the \u201cIdentifier\u201d column (in the case where Multi-Row Elements has a value of \u201cYES\u201d). In contrast, a parameter type of \u201celement\u201d indicates that the update data for the specified data field of the table is the value of the XML element identified in the \u201cIdentifier\u201d column, whether it is a nested element (e.g. as in the case where Multi-Row Elements has a value of \u201cYES\u201d) or a root-level element. Access to nested elements could alternatively be facilitated by using XPATH, which should be familiar to those of skill in the art.","It is noted that, if more than one parameter is specified within a table update, only a single parameter should have an \u201celement\u201d Parameter type. The remaining parameters in the update should have \u201cattribute\u201d parameter types. This is due to the fact that an XML element will have only one value but may have many attributes.","For the table update  of , four parameter-field associations are defined, as shown in Table 1 below:",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Parameter-Field Associations"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PARAMETER","FIELD","PARAMETER TYPE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"MSGID","LNGMESSAGEID","Attribute"]},{"entry":[{},"FROM","VARFROM","Attribute"]},{"entry":[{},"SUBJECT","VARSUBJECT","Attribute"]},{"entry":[{},"MAIL","MEMBODY","Element"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"The names in the \u201cFIELD\u201d column of Table 1 above are commensurate with the PIMINBOX table definition under the \u201cDatabase Tables\u201d branch  of , which is discussed in more detail below.","The second table update  of  is similar to table update , except that the table identified in the \u201cTable Name\u201d column of grid  is a user-defined table (as indicated by the \u201cTBL\u201d prefix) rather than a notional PIM database. Also, the value \u201cYES\u201d in the \u201cMulti-row\u201d field column of grid  indicates that identified section, of the XML package (\u201cRECIPS\u201d) contains multiple \u201cdata records\u201d (i.e. XML elements) to be processed, each named \u201cRCP\u201d (see lines - of ). The parameter-field associations for table update  would be similarly specified, but are omitted for brevity.","It is noted that, as a general rule of thumb, the field identified within a database table as the primary key should not be updated by table updates. This is to guard against updates which might inadvertently cause the primary key to lose its uniqueness within the table.","Additional rules beyond rule  may be defined within the visual hierarchy of icons  ().","The database tables  section of the hierarchy  contains definitions of two types of tables: notional PIM database tables and user-defined database tables. Eight tables in total are defined in . Each is represented by a distinct icon in the database tables  section.","The first seven tables , PIMINBOX, PIMOUTBOX, PIMSENTITEMS, PIMCONTACTS, PIMAPPOINTMENTS, PIMNOTES, and PIMTASKS, are notional PIM database tables corresponding to information categories , , , , ,  and , respectively, of PIM application  (). These tables are pre-existing within the project explorer  of RAD tool  and cannot be modified by the user, since the fields of each table (which fields correspond to data fields within records of the corresponding information categories of the PIM application) are predetermined. The fields of each table represent the fields that are common to data records of the relevant information category across multiple PIM software applications (including PIM application ) that are executable on one of the wireless communication device types upon which virtual machine software  is to be executed. The seven tables  are represented within the visual hierarchy of icons  to allow the user of RAD tool  to see the available information categories from which PIM data may be queried, and to which PIM data can be added, at run time. They may each be selected and examined to identify data fields therein, but the data fields are not open to modification by the user because the structure of each table is predetermined.","The last table, TBLRECIPIENTS, results in the run-time creation of a comparable database table  in the database  of wireless communication device  ().","Selection of a table icon within database table section \u2014in this case, the PIMINBOX table icon\u2014causes a table properties window , as shown in , to be displayed. The table name is indicated in the Table Name field . A primary key (i.e. a field that contains a unique value, used to differentiate between records in the table) is specified in the Primary Key field . The fields of the table are indicated in grid . Each field is represented by a row within the grid. The first column, Field Name, identifies the name of the field within the table. The second column, Type, identifies the type of the field, which may be one of the following: \u201cINT\u201d (Long Integer)\u2014e.g. numeric values between \u22122147483648 and 2147483647; \u201cSTRING\u201d (string)\u2014e.g. a set of alphanumeric characters up to a maximum of 255 characters, possibly limited to less than 255 characters by setting of the Field Size field in the third column; \u201cMEMO\u201d\u2014similar to a STRING, except that MEMO fields can contain more than 255 characters; \u201cAUTOINC\u201d (Auto-incrementing or identity field) data added to a AUTOINC field automatically increments itself, ensuring that each record has a unique value in this field. Values in an AUTOINC field are not capable of update, nor can data be inserted this type of field; or \u201cDATETIME\u201d (Date and Time data) typically in the RFC 1123 format (dd mmm yyyy hh:nn:ss). The fourth column, Indexed, indicates whether the field is indexed so as to permit the device database management system to perform quicker searches and queries on the data. Finally, the fifth column, Allow Null, indicates whether or a null value in the field is permissible at run time.","The information within Table Properties window  is read-only in the case of a notional PIM database table. The Add Field button  for permitting the user to add a field to a user-defined table is therefore inactive in , to keep the user from attempting to add to the predetermined, notional fields of the notional PIM table. Moreover, the ARML tab  for displaying a read-only version of the ARML (XML) code generated by the a user-defined table and the Data tab  for displaying an editable graphical display of a user-defined table similar to that of well-known database design and modification software of  are also inactive. The ARML tab  is inactive because predetermined notional database tables need not be defined in the application definition file. These tables need not be defined in the application definition file because the virtual machine software  () \u201chard-codes\u201d these tables, as their structure is predetermined. The Data tab  is inactive in  because predetermined notional database tables are not editable. For user-defined tables, such as TBLRECIPIENTS (), information within Table Properties window  () is editable and all controls of window  are active.","The TBLRECIPIENTS database table is assumed to have been previously defined by the developer  through interaction with other controls of GUI  (e.g. context-specific pop-up menus allowing the definition of a new table and of fields within that table, as might be found in a database application for example).","Referring back to , the \u201cOperating System\u201d branch  comprises the platform-specific components section  of visual hierarchy . This branch permits the definition of platform-specific aspects of a mobile application, which primarily comprise the displayable GUI screens and control flow of a mobile application. In , only one exemplary GUI screen definition  is illustrated. This screen appears within the \u201cPocket PC\u201d branch , indicating the screen is a screen for a Pocket PC device such as device  (). Other GUI screen definitions are omitted for brevity.","Screen definition  defines the GUI screen  of  for displaying a list of email messages from a particular sender, Joe Smith. Referring to , it can be seen that GUI screen  has a grid  and a button . It is desired that a first column the grid  be populated with the value of an ID field entitled \u201cLNGMESSAGEID\u201d of the notional PIM database table \u201cPIMINBOX\u201d (which is also shown in ) and that a second column the grid  be populated with the value of a subject field entitled \u201cVARSUBJECT\u201d of the same notional PIM database table. This is to occur only when the value of the \u201cVARFROM\u201d field (which represents the email sender's name) is \u201cJoe Smith\u201d. The population of the grid with this data is achieved by way of a query, described below. Also, upon user selection of the button , it is desired for a \u201ccanned\u201d (i.e. predetermined) acknowledgement email message to be sent to Joe Smith.","Referring back to , below screen definition  within the hierarchy , two icons  and  are created. The first icon  represents the grid  of . The second icon  represents the button  of . Each of these application components may be created by right-clicking the icon , choosing the appropriate new display element (from a pop-up menu or a toolbar for example), and defining the new element's properties in properties window  ().","A ButtonClick event  is defined below the button icon  of . This event represents the selection of the button  of  by a user of wireless communication device . Right-clicking of the event icon  in project explorer  causes another pop-up menu to be displayed. The options that are presented on the displayed pop-up menu include an Add Action option. This option is used to add actions icon .","Action icon  (\u201cAction \u201d) represents a \u201cSENDMAIL\u201d action which causes a predetermined email message to be sent to a developer-specified email address at run time by way of an appropriate PIM API call. The definition of properties for this action in the properties window  is illustrated in . Turning to that figure, a name field  allows the developer to enter a name (\u201cAction \u201d) that will be displayed in the project explorer  as part of the icon . A \u201cType\u201d field  provides a drop-down list which lists each type of action that may be performed by a Pocket PC wireless communication device. In , the list is illustrated in a dropped-down state, with one entry, namely SENDMAIL, being selected (as indicated by reverse video), to indicate that the action  of  is a \u201cSENDMAIL\u201d action. Selection of the \u201cSENDMAIL\u201d action type results in the further display of a set of text entry fields , , ,  and  in properties window , wherein the developer specifies the recipient email address, CC email address, BCC email address, subject, and body (respectively) of the predetermined email message to be sent upon execution of the \u201cSENDMAIL\u201d action responsive to a clicking of the button  ().","Referring again to , a queries section  under screen icon  contains the definition of queries for retrieving data to be used for populating the screen  () of wireless communication device  at run time. Generally, queries facilitate the development of complex mobile applications, because queries permit application data to be accessed and possibly combined with other data in various ways. A query can retrieve data either from a user-defined database table or from a notional PIM database table, and can be thought of as a run-time \u201csnapshot\u201d of the database  or of an information category of PIM application . Queries defined in section  are automatically refreshed when the \u201cparent\u201d screen (screen  of ) is redisplayed. Between refreshes, the data is stored by the query and may be accessed by application components (such as the grid defined at  of ).","In , only one query  is defined in the queries section . The query  represents a query of notional table PIMINBOX. The procedure for defining query  may be as follows. The icon corresponding to the queries section  may initially be selected with a mouse (or similar user input mechanism ) of the RAD tool  (). A right-click (or similar user action) may cause a pop-up menu to be displayed. The pop-up menu may present a list of options in the context of the selected queries section . An Add Query option may permit the user to define a new query. Selection of that menu options may cause a new query icon  to be created below icon , as shown in , and a Query Properties window , as shown in , to be displayed in the main design area  ().","Referring to , the Query Properties window  provides selectable GUI controls which permit the user to enter properties of the newly defined query. The Query Properties window  includes a Query Name field  for entering a unique query name that is not already in use by any other query. The name uniqueness constraint ensures that each query may be uniquely referenced from other areas of the visual hierarchy . In the present example, it is assumed that the name \u201cQUERY\u201d has been entered. That name is displayed as part of the icon at  (). A Table Name field  () allows the developer to select the name of the table against which the query is to be performed. In the present embodiment, a prefix of \u201cPIM\u201d in the table name indicates that the table is a notional PIM database table, while a prefix of \u201cTBL\u201d would indicate that the table is a user-defined database table. The field  is a drop-down list enumerating the notional and user-defined tables of the present mobile application. In the example, the table \u201cPIMINBOX\u201d has been selected from that list. The Order By field  specifies that the query results (i.e. the data from the PIM inbox which matches the query's search criteria) should be automatically sorted by a field table named \u201cVARFROM\u201d. The drop-down list  is automatically populated with a set of fields for the information category  () associated with the table selected in field . Field  can be left blank if the query is designed to return a single record or if the results do not require sorting. When the Order By field  has been specified the Sort Order field  can be set to either ASC (ascending) or DESC (descending) to control the ordering of query results.","Selection of the Add button  of  permits a \u201cwhere clause\u201d to be defined. As is known in the art, a where clause specifies the search parameters for a query. An exemplary where clause  is illustrated in . The where clause  specifies a Field Name, an Operator and a Value. The Field Name indicates which field of the table specified in field  is to be examined. The Operator indicates the nature of the operation to be performed (Equals, Not Equal To, Less Than, Greater Than, or in the case of string fields, Begins With) in respect of that field, which is generally a comparison of the field value against another value. The Value is the value against which the named field is to be compared. Thus, the where clause  of  causes records to be returned in which the \u201cVARFROM\u201d field equals \u201cJoe Smith\u201d (i.e. email messages from Joe Smith). To define additional where clauses, the Add button  may be selected again. A new where clause, which would appear as another row below clause  in the Where Clauses grid , may be similarly defined. For each where clause defined in addition to the first, the AND\/OR field is also specified to indicate whether the overall set of where clauses is conjunctive or disjunctive. A where clause may be removed using the Remove button . The user can also specify a temporary, named, \u201cscratchpad\u201d value stored at the device to effect a dynamic comparison.","When development of the mobile application using RAD tool  is complete, the developer may select a \u201cSave\u201d button, or similar GUI construct, of the application development software  (). When this is done, the application definition DOM tree  is serialized to form a textual XML markup language document, i.e. master definition file , which is stored in the secondary storage  of RAD tool  (). The master definition file  is then uploaded to the transaction server  and used to create application definition files for each of mobile devices  and , as described in the above-referenced U.S. Patent Publication No. 2003\/0060896. The application definition file  (), which is created for wireless communication device , is then downloaded to the wireless communication device .","The application definition file  is illustrated in greater detail in . The file  contains XML elements representing all of the application constructs defined within the project explorer  of , including each of the markup language definitions , , ,  and  of . In , many XML elements are omitted for brevity (as indicated by colons). Most of the XML elements shown in  are detailed in Appendix \u201cA\u201d, attached hereto. The XML elements are interpreted by the virtual machine software  and govern the presentation of server-side application  at mobile device  ().","It will be appreciated that lines of  with the prefix \u201c\/\/\u201d, such as lines , , ,  and , are comments that are intended to facilitate reader comprehension of these figures. They are not valid markup language elements and are not actually present in the generated document .","Lines - () of the application definition file  contain an AXDATAPACKET markup language element and various nested (i.e. subordinate) markup language elements which collectively define the \u201cAddEmailToInbox\u201d rule  () whose properties are shown in . The two table updates  and  of  are represented at lines - and - of , respectively.","Lines - pertain to the update of the notional database table PIMINBOX which is the subject of markup language definition  (). These lines describe how to update the PIMINBOX table each time that an XML package of type \u201cME\u201d is received at the wireless communication device  at run time. The XML element and attribute names of lines - are generally as described in section 3.3 of Appendix \u201cA\u201d. Briefly, the BODY=\u201cME\u201d attribute corresponds to field  of , and the SENDTOAPP=\u201cNO\u201d attribute corresponds to check box  (with the SENDTOMOBILE=\u201cYES\u201d being a further indicator that this rule pertains to the processing of an incoming XML package at the wireless communication device ).","Lines - of the TUPDATE element includes various attributes which capture the values contained in the column of the first table update  of grid  (). Specifically, the TABLE=\u201cPIMINBOX\u201d attribute corresponds to the Table Name column; the UPDATETYPE=\u201cADD\u201d attribute corresponds to the Update Type column; the WHEREFIELD=\u201c \u201d attribute corresponds to the Field column; the WHEREPARAM=\u201c \u201d attribute corresponds to the Param column; the SECTION=\u201cMAIL\u201d attribute corresponds to the Element column; the MULTIROW=\u201cNO\u201d attribute corresponds to the Multi-Row column; and the MULTIROWIDENT=\u201c \u201d attribute corresponds to the Identifier column. The WHERETYPE=\u201cPROP\u201d attribute is not shown in  but is indicative of whether the WHEREPARAM (if set) is an attribute (\u201cPROP\u201d) or an element (\u201cVALUE\u201d). In , the attribute value \u201cPROP\u201d is a result of a default setting and is not significant, since the WHEREPARAM value is not set.","Lines - capture the parameter-field associations of Table 1, above. Lines - correspond to rows 1-4 of Table 1 respectively, as will be apparent to one of ordinary skill in the art.","Lines - () describe how to update a different table, TBLRECIPIENTS, each time an XML package of type \u201cME\u201d is received at the wireless communication device  at run time. Lines - are similar to lines - described above, except that the MULTIROW=\u201cYES\u201d attribute indicates that the parameter-fields associations defined at lines - of  are to be effected not once per XML package, but once for each RCP element in the XML package (e.g. once for each of the three RCP elements at lines - of ).","Turning to , the markup language definition  of a user-defined database table is shown at lines -. The TDEF markup language element and subordinate FIELDS and FLD elements at lines - cumulatively define a table \u201cTBLRECIPIENTS\u201d for storing information about email message recipients. The XML element and attributes at lines - are generally as described in the table definitions section 3.2 of Appendix \u201cA\u201d. It should be appreciated this definition, and indeed any definition of a table in the application definition file, will be that of a user-defined database table. This is because predetermined, notional database tables, such as any one of the seven notional PIM database tables represented in , are not described in the application definition file .","Lines - of  contain a SCREEN element and various subordinate XML elements which cumulatively define the screen  of .","A GRID XML element and subordinate XML elements associated with grid definition  of  will be used to defining grid  of . In , these XML elements are omitted from  for brevity. The omitted XML elements would generally follow the description in the grid section 5.10 of Appendix \u201cA\u201d however. Notably, the GRDSRC attribute of the GRID element would refer to the query \u201cQuery\u201d (as defined by definition , ) in order to facilitate the population of the grid  with data from the PIMINBOX notional database table. The \u201cQuery\u201d markup language definition  () is described in more detail below.","A BTN element and various subordinate XML elements lines - of  cumulatively define the button  of  for sending a developer-specified email message to a developer-specified recipient at run time. The \u201cSENDMAIL\u201d action that achieves this result is defined at lines - of . These lines correspond to the markup language definition  of . At lines - of , the attributes TO, CC, BCC and SUBJECT of the MESSAGE element have values matching the developer-specified values in fields , ,  and  (respectively) of , while the MESSAGE element value at line  of  matches the value of field  of .","Lines - of  contain a QUERY element and subordinate W element which correspond to query  of . The values of the NAME, TABLE, ORDERBY and ORDERDIR attributes at line  are taken from the Query Name field , Table Name field , Order By field  and Sort Order field  of , respectively, as set by the developer. The W element at line  represents where clause  of .","The application definition file  of  is transmitted to the wireless communication device  on demand, as described in U.S. Patent Publication No. 2003\/0060896. Upon receipt of the application definition file , an XML parser at wireless communication device  parses the XML text of application definition file . The parser converts the XML document  into a DOM tree representation. The DOM tree is used to facilitate the instantiation of objects  () from locally stored object-oriented classes  () and the population of their data members with element and attribute values from the document  (as described below). For each XML element that is encountered during the traversal, a corresponding object  () may be instantiated from one of the object-oriented classes . Instantiation of each object  may be facilitated by a fromXML( ) \u201cconstructor\u201d method within the corresponding class, which populates the object's data members based on XML element\/attribute values. For example, the constructor method may receive the XML fragment which defines the XML element in the application definition file  and, based on element and attribute values within the fragment, automatically populate the newly-instantiated object's data members with like values. It is noted that the constructor method may or may not meet the strict definition the term \u201cconstructor\u201d as it is understood in the context of certain object-oriented programming languages (e.g. the method may not have the same name as the class). Once the objects  have been instantiated and so populated, the DOM tree may be deallocated.","Beginning with the device-independent constructs, parsing of the AXDATAPACKET element at lines - of  results in the instantiation of the rule object  () from a Rule class , which is illustrated in pseudocode form in , and the invocation of its fromXML( ) method, shown at , lines -. In , text following a \u201c\/\/\u201d delimiter denotes a comment (this is also true in , A-C, A-B and ). The fromXML( ) method causes local data members \u201cbody\u201d, \u201csendtomobile\u201d and \u201csendtoapp\u201d (lines - of ) to be set to the attribute values of the same name from the AXDATAPACKET element XML that is passed as an input parameter. Class  is one of the object classes  of .","Thereafter, for each TABLEUPDATE element subordinate to the AXDATAPACKET element, the fromXML( ) method: (1) instantiates a new TableUpdate object from the TableUpdate class  of  (described below) and adds it to its Tupdates array (declared at lines  of ); and (2) passes the XML for the TABLEUPDATE element to the fromXML( ) method of the newly declared Table Update object. In the illustrated example, two TABLEUPDATE elements are declared in the application definition file  (at lines - and - of the application definition file  of ), therefore two TableUpdate objects are instantiated from class . Class  is another one of the object classes  of .","The TableUpdate class  is illustrated in pseudocode form in . The fromXML( ) method (lines - of ) causes local data members (in this case \u201ctable\u201d, \u201cupdatetype\u201d, \u201cwherefield\u201d, \u201cwhereparam\u201d, \u201cwheretype\u201d, \u201csection\u201d, \u201cmultirow\u201d and \u201cmultirowident\u201d\u2014see lines - of ) to be set to the attribute values of the same names from the XML that is passed as an input parameter. Thereafter, for each PKGFLD element subordinate to the TABLEUPDATE element, the fromXML( ) method: (1) instantiates a new PFAssociation object to represent a parameter-field association (as described above) and adds the PFAssociation object to its PFAssns array (declared at line  of ); and (2) passes the XML for the PKGFLD element to the fromXML( ) method of the newly declared PFAssociation object. In the illustrated example, four PKGFLD elements are declared in the application definition file  (at lines - of the application definition file  of ), therefore four PFAssociation objects are instantiated. Data members of each PFAssociation object are thereafter set to capture the value of the relevant PKGFLD element and its attributes from the application definition file .","Processing of the user-defined table definition, i.e. the TDEF element at lines - of , results in the instantiation of the \u201cTBLRECIPIENTS\u201d table object  () from a Table class  which is illustrated in pseudocode form in , and in the invocation of its fromXML( ) method, shown at , lines -. The fromXML( ) method causes local data members \u201cname\u201d, \u201cupdatetype\u201d, \u201cpk\u201d and \u201cdelindex\u201d (lines - of ) to be set to the attribute values of the same name from the TDEF element XML that is passed as an input parameter. Thereafter, for each FLD element subordinate to the TDEF element, the fromXML( ) method: (1) instantiates a new Field object to represent a database table field and adds it to its Fields array (declared at line  of ); and (2) passes the XML for the FLD element to the fromXML( ) method of the newly declared Field object. In the illustrated example, three PKGFLD elements are declared in the application definition file  (at lines - of the application definition file  of ), therefore three Field objects are instantiated. Data members of each Field object are thereafter set to capture value of the relevant FLD element and its attributes from the application definition file . The purpose of the Field objects, which are not expressly shown, is to capture information regarding the structure of the \u201cTBLRECIPIENTS\u201d table. It will be appreciated that different versions of class  may exist. In each version, the instructions for interacting with the PIM API  or DBMS  are tailored to a particular PIM application  or DBMS . The appropriate version is loaded into the memory of the wireless communication device, as part of objects classes  (), based on the identity of the PIM application  and DBMS  that are to be executed on that wireless communication device.","Next, a connector object (declared at line  of ) connects to the DBMS  in order to facilitate future interaction with the DBMS . If the table object represents a notional PIM table, the connector object would instead connect to the PIM API  for purposes of facilitating access to the appropriate one of information categories  represented by the notional table. Thereafter (at lines - of ), appropriate DBMS API calls are made in order to create a table  in database  () that corresponds to the TDEF declaration of . This is not done if the table is a notional PIM table because, in that case, the \u201ctable\u201d actually represents a PIM information category that already exists in PIM application .","At this stage, operating system-specific constructs of application definition file  (which are described starting at line  of at ), including screen, grid, button and event objects, are instantiated and their data members are initialized in a similar \u201ccascade\u201d fashion. The event object represents a run-time selection of the button  of . The event object has a subordinate action object  () representing the \u201cSENDMAIL\u201d action that is to be performed when the button is selected. The action object  is instantiated from Action class , which is illustrated in pseudocode form in , based on the ACTION element at lines - of . When the fromXML( ) method of the action object is executed (lines - of ), the method simply sets the type data member to the value of the type attribute, which in this case is \u201cSENDMAIL\u201d. It will be appreciated that, as with Table class , different versions of the Action class  may exist. In each version, the instructions for interacting with the PIM API  or DBMS  are tailored to a particular PIM application  or DBMS . The appropriate version is loaded into the memory of the wireless communication device, as part of the object classes  of , based on the identity of the PIM application  and DBMS  that are to be executed on that wireless communication device.","With reference to , parsing of the QUERY element at lines - results in the further instantiation of the query object . Query object  represents a query of the notional \u201cPIMINBOX\u201d table represented by table object  () that is re-executed every time the screen  of  is displayed at run time. The object  is instantiated from Query class  (another one of the object classes  of ) which is illustrated in pseudocode form in , and in the invocation of its fromXML( ) method, shown at , lines -. The fromXML( ) method causes local data members \u201cname\u201d and \u201ctable\u201d (lines - of ) to be set to the attribute values of the same name from the QUERY element XML that is passed as an input parameter. The \u201cwhereparams\u201d data member (line ) is populated by parsing the subordinate W element and populating a WhereParam object for each W element.","Thereafter, the runQuery( ) method (lines - of ) is invoked to cause the query to be executed. The query is executed at this stage so that a snapshot of notional PIM table data that meets the query's where parameter will be available during instantiation of GUI screen objects (such as the grid  of ) whose textual aspects are initialized based on the retrieved data. The runQuery( ) method first identifies the appropriate table object (in this case, table object  of ) based on the name of the table stored in the \u201ctable\u201d data member. This identification may be facilitated by a \u201ctable broker\u201d construct (possibly incorporating a hash table) within virtual machine software  which accepts a table name string and returns the corresponding table object. Then the runQuery( ) method passes the query object as an \u201cin\u201d parameter to the executeQuery( ) method of the table object (see , lines -), which executes the query as described below.","The executeQuery( ) method of the table object  is illustrated at lines - of . Because table object  represents a notional PIM table, logic within the executeQuery( ) method causes appropriate PIM API calls  () to be made (rather than DBMS API calls) to identify matching records in the Inbox information category . This may entail composing a Structured Query Language (SQL)-like query string from using the in query parameter and passing that string to the PIM API . The resulting matching records are passed back to the invoking query object  in the \u201crecords\u201d out parameter. These records may be indexed by other objects  by way of the getField( ) method (, lines -) or similar methods, which may set or reference the \u201ccurrent\u201d index (, line ). The records are maintained until overwritten by a re-execution of the query.","Referring to , lines -, further screens also defined for the Pocket PC platform by the developer  using RAD tool  (not shown) result in additional XML elements in application definition file  (omitted for brevity). It is assumed that, in conjunction with one of these screens, a query of user-defined database table  () is defined, resulting in the markup language elements shown at lines -. This exemplary query returns records having a \u201cVARFULLNAME\u201d field that begins with \u201cJ\u201d. When these markup language elements are processed, query object  () will be instantiated and its fromXML( ) method invoked. Thereafter, the runQuery( ) method (lines - of ) is invoked to cause the query to be executed. The query is executed at this stage so that a snapshot of matching user-defined table data will be available during instantiation of GUI screen objects whose textual aspects are initialized based on the retrieved data. When the executeQuery( ) method of the table object  is executed, logic within the executeQuery( ) method causes appropriate DBMS specific code  or instructions () to be executed (rather than PIM API calls, as in table object ) to identify matching records database table . The instructions may interact with an API of DBMS  (e.g. may invoke API functions, routines, procedures or methods). The instructions may be DBMS-specific and will be known to those skilled in the art. An exemplary set of instructions is described at www.w3schools.com\/ado\/ado_reference_connection.asp, which is hereby incorporated by reference hereinto. The resulting matching records are passed back to the invoking query object  in the \u201crecords\u201d out parameter.","Once the above-described cascade of invocations of fromXML( ) methods through the various instances of object classes  has successfully completed, the result is a set of objects  (). The appearance of the screen  when it is first displayed will be as shown in , with contents of the grid  being determined by the matching records present at that time in the PIM inbox information category .","If it is desired to send an acknowledgement email message to Joe Smith, the button  may be selected by the wireless communication device user. Selection of the button  triggers, by way of operating system callback and a cascade of calls from higher-level button and event objects (not illustrated), the invocation of the doAction( ) method of an Action object  which corresponds to the \u201cSENDMAIL\u201d action. The doAction( ) method is illustrated in pseudocode form at lines - of . The purpose of the doAction( ) method, in this instance of the Action class  of , is to perform the \u201cSENDMAIL\u201d action. This purpose is captured in the value \u201cSENDMAIL\u201d of the type data member. The sending of an email message is achieved by connecting to the PIM application  and making appropriate calls to PIM API  () to cause an email message to be sent. The substance of the email message, which was originally specified in the child MESSAGE element of the ACTION element in the application definition file  (see , lines -), is stored in the form of a child Message object to the Action object  (see , line ).","For example, the following Java\u2122 code fragment outlines how to programmatically send a message from a BlackBerry wireless communication device while setting some additional parameters prior to sending using the package net.rim.blackberry.api.mail:",{"@attributes":{"id":"p-0134","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/retrieve the sent folder"},{"entry":"\u2003\u2003Folder[ ] folders = store.list(Folder.SENT);"},{"entry":"\u2003\u2003Folder sentfolder = folders[0];"},{"entry":"\u2003\u2003\/\/create a new message and store it in the sent folder"},{"entry":"\u2003\u2003Message msg = new Message(sentfolder);"},{"entry":"\u2003\u2003Address recipients[ ] = new Address[1];"},{"entry":"\u2003\u2003try {"},{"entry":"\u2003\u2003\u2003recipients[0]= new Address(\u201cuser@company.com\u201d, \u201cuser\u201d);"},{"entry":"\u2003\u2003\u2003\/\/add the recipient list to the message"},{"entry":"\u2003\u2003\u2003msg.addRecipients(Message.RecipientType.TO, recipients);"},{"entry":"\u2003\u2003\u2003\/\/set a subject for the message"},{"entry":"\u2003\u2003\u2003msg.setSubject(\u201cTest email\u201d);"},{"entry":"\u2003\u2003\u2003\/\/sets the body of the message"},{"entry":"\u2003\u2003\u2003msg.setContent(\u201cThis is a test email from my BlackBerry Wireless"},{"entry":"Handheld\u201d);"},{"entry":"\u2003\u2003\u2003\/\/sets priority"},{"entry":"\u2003\u2003\u2003msg.setPriority(Message.Priority.HIGH);"},{"entry":"\u2003\u2003\u2003\/\/send the message"},{"entry":"\u2003\u2003\u2003Transport.send(msg);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003catch (Exception me) {"},{"entry":"\u2003\u2003\u2003System.err.printIn(me);"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"For a Pocket PC device, creation of an outgoing email message using C++ is described at www.codeproject.com\/ce\/cemail.asp, which is hereby incorporated by reference hereinto.","Subsequently, operation of the application  at application server  of system  () may result in the generation of an XML package  (), which is received at device . An operating system callback or similar mechanism at the device  results in the invocation of the doRule( ) method of the Rule object  (), which is described in pseudocode at lines - of . Essentially, the method takes the received XML package as its input, and, for each table update defined in conjunction with the represented rule, the doUpdate( ) method of the corresponding TableUpdate child object is invoked in turn, with the XML package being passed as an input parameter for each invocation.","As shown at lines - of , the doUpdate( ) method identifies the appropriate table object backed on the \u201ctable\u201d data member (e.g. using a table broker, as noted above) and then invokes the table object's effectUpdate( ) method, which is responsible for putting the update into effect based on the TableUpdate object and XML package input parameters.","Referring now to , pseudocode for the effectUpdate( ) method is shown at lines -. The body of the method contains a large switch statement which causes different instructions to be executed based on the value of the \u201cupdatetype\u201d data member of the tupdate TableUpdate object parameter (declared at , line ) and based upon whether the table is user-defined or a notional PIM table. In the case of the first tupdate parameter (corresponding to lines - of ), the type is \u201cADD\u201d and the table is a notional PIM table (as can be determined by checking whether its \u201cname\u201d data member is included in an internally stored list of PIM table names), thus the effectUpdate( ) method: instantiates a new data record for the relevant PIM information category (category \u2014); fills in the new record with values from the XML package based on the PFAssns array data member of the TableUpdate object; and invokes appropriate PIM API calls for adding the record as dictated by the data members of the tupdate parameter. For example, if the tupdate parameter's \u201cmultirow\u201d data member indicates that the XML package has multiple elements, each requiring the addition of a record into the PIM information category, then appropriate PIM API calls are made to add multiple records.","If the value of the \u201cupdatetype\u201d data member of the tupdate parameter had been \u201cDELETE\u201d or \u201cUPDATE\u201d, the instructions executed would have been for the purpose of deleting or updating records of information category  via the PIM API  (), as described in pseudocode at lines - and - of , with multiple records being affected if the tupdate parameter's \u201cmultirow\u201d data member indicates that the XML package has multiple elements","Having executed the doUpdate( ) method of the first child TableUpdate object of the Rule object  (), the doUpdate( ) method of the second child TableUpdate object is invoked next. Its execution is similar to that described above, except that it results DBMS API via table object  calls rather than PIM API calls via table object , since the relevant table in this case is a user-defined database table (as evidenced by fact that the value of the table attribute of the TUPDATE element at line  of  is not in the internally stored list of PIM table names).","From the above description, it can be seen that each of the table objects  and  \u201ctranslates\u201d conventional database operations to one or more appropriate PIM API calls  or DBMS specific calls  (respectively) that achieve the desired result, with the developer  advantageously being shielded from the low-level details of such transactions. Conveniently, the developer  may simply treat each PIM information category  as a notional database table when designing a mobile application using RAD tool  () and may interact with the notional table in the same manner as he interacts with a user-defined database table, e.g. when performing queries. The queries may be used for purposes of populating a GUI screen with data from the PIM application .","As will be appreciated by those skilled in the art, modifications to the above-described embodiment can be made without departing from the essence of the invention. For example, markup language documents need not be written using XML. Alternative markup languages (e.g. Standard Generalized Markup Language, of which XML is a subset) could be employed. Moreover, the choice of markup language element and attribute names may differ from those described above.","In alternative embodiments, the DBMS may not support structured query language. Another form of query language may be supported instead.","Other modifications will be apparent to those skilled in the art and, therefore, the invention is defined in the claims. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the figures which illustrate example embodiments of the present disclosure:",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIGS. 6 and 7","FIG. 5"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 8","FIG. 3"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 9","FIG. 5"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 10","FIG. 3"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIGS. 11 and 12","FIG. 5"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIGS. 13A-13C","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 14","FIG. 3"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIGS. 15A-15B","FIG. 3"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIGS. 16A-16C","FIG. 3"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIGS. 17A-17B","FIG. 3"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 18","FIG. 3"]}]},"DETDESC":[{},{}]}
