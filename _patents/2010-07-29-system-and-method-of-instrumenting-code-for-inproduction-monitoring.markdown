---
title: System and method of instrumenting code for in-production monitoring
abstract: A system and method configured to instrument code for in-production monitoring provides a polling thread. A main thread executes the code of an instrumented application program and the polling thread executes in the background. Therefore the polling thread does not reduce the performance of the application program execution while monitoring activities are performed. Additionally, the polling thread is configured to simplify the process of instrumenting code for Java management extensions (JMX) by navigating the application program structure to locate administrative objects to bind to JMX and registering the administrative objects with JMX to enable monitoring of the instrumented code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08667472&OS=08667472&RS=08667472
owner: Disney Enterprises, Inc.
number: 08667472
owner_city: Burbank
owner_country: US
publication_date: 20100729
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates to the field of instrumenting and monitoring of application programs and, in particular, to a system and method instrumenting code for in-production monitoring.","2. Description of the Related Art","A conventional technique for instrumenting the code of an application program written in the object-oriented language, Java, requires a developer to construct a JavaBean object and then construct a dynamic management \u201cbean\u201d (MBean) that references the JavaBean object using Java management extensions (JMX) application programming interfaces (APIs).","The state of a JavaBean object is stored in variables and the behaviors of the JavaBean object are implemented with methods. Variables are named records in which you can store data for later use. Methods are named pieces of code that implement behaviors the JavaBean object is configured to perform. In object-oriented terminology, each implementation or manifestation of a JavaBean object is an \u201cinstance\u201d of the generic class of the object. Each instance of the object has specific state associated with that particular instance, but every instance has the same methods defining its behavior. When created, each JavaBean object has memory allocated to it to hold its instance variables, i.e., the state for the object. Once the JavaBean object is created, the instance methods of the JavaBean may be called to execute the JavaBean object. The JavaBean object exposes one or more specific properties of the application program.","An MBean represents a resource to be managed, such as an application, device or service, and has a management interface consisting of the named and typed attributes that can be read and written, the named and typed operations that can be invoked, and the typed notifications that can be emitted by the MBean. A management tool may be configured to monitor the MBean to change settings, perform an administrative action, or to gather metrics related to the application program. A dynamic MBean is an MBean that defines its management interface at runtime.","An MBean may have an attribute representing a latency property of a calculation performed by the application program. The MBean may be configured to capture timestamps of the property exposed by the JavaBean and a JMX server may be configured to monitor the captured timestamps. In another example, an MBean representing an application program's configuration may have attributes representing the different configuration parameters, such as a cache size. Reading the Cachesize attribute of the MBean returns the current size of the cache. Writing the Cachesize attribute updates the size of the cache, potentially changing the behavior of the running application.","An MBean must be registered in a core managed object server, such as a JMX server before the MBean can be used. An MBean server acts as a management agent, runs on most devices enabled for the Java programming language, and is a repository of MBeans. Each MBean is registered with a unique name within the JMX server. Other objects or application programs do not access an MBean directly, but rather access the MBean by name through the JMX server.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1","b":["100","105","110","105","110","115","120"]},"As the foregoing illustrates, there is a need in the art for an improved technique of instrumenting code for in-production monitoring.","Embodiments of the invention include a system and method instrumenting code for in-production monitoring. A main thread executes the code of an instrumented application program and a polling thread executes in the background. The polling thread is configured to simplify the process of instrumenting code for a management server by navigating the application program structure to locate application (i.e., administrative) objects to bind to the management server and then registering the application objects with the management server to enable monitoring of the instrumented code. With such an architecture, the developer is not burdened with the tasks of constructing a management object to encapsulate the application object and register the management object with the management server. More particularly, in an embodiment of the invention that implements a Java framework, the developer is not burdened with the tasks of constructing an MBean to encapsulate the instance object (JavaBean) and register the MBean with JMX.","One embodiment of the invention provides a computer-implemented method for instrumenting an application program. The method includes executing the application program by a main execution thread of a processor and executing a polling thread by the processor. The polling thread is configured to navigate a graph of the application program to locate an instance of an application object, construct a management object corresponding to the located application object, and register the management object with a management server to produce the instrumented application program.","One advantage of the techniques described herein is that the polling thread executes in the background and therefore does not reduce the performance of the application program execution while monitoring activities are performed.","A polling thread is used to simplify the process of instrumenting code for JMX by navigating the application program structure to locate administrative objects to bind to JMX and registering the administrative objects with JMX to enable monitoring of the instrumented code. The main thread executes the instrumented application program and the polling thread executes in the background so that performance of the main thread is not negatively impacted by the monitoring functions. Therefore, the application program may be monitored during the QA process and also during in-production. The developer inserts information into the application program that is used by the polling thread to encapsulate the JavaBean into an MBean. The polling thread then registers the MBean with JMX and maintains an inventory of registered MBeans.","In one embodiment, a developer provides information to the poller using annotations in the application program. Examples of annotations include @JMXEntryPoint, @BindToMBean, and @ExposeToJMX. The @JMXEntryPoint annotation is primarily a marker that flags the entry point for the polling thread and returns an instance of a profiler object (JavaBean). The @BindToMBean annotation marks an object instance of interest. As the \u201cpoller\u201d thread traverses the object graph starting with the entry point, the poller looks for @BindToMBean annotations and registers an MBean passing the object of interest. The annotated method must return the target object. The @ExposeToJMX annotation indicates the interesting properties and functions of the bound object. The annotations are generally \u201cgetter\u201d methods that return the target objects. The reset( )method is an example of an action that can be executed, i.e., a function. The reset( )method provides the ability for an external tool to clear the statistics counters and reset them to some initial state.","The class shown in TABLE 1 is an example of a code functioning as a mediator for handling all profiler statistics gathering and event handling for an application program.",{"@attributes":{"id":"p-0023","num":"0022"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class InvocationProfiler implements java.io.Serializable {"},{"entry":"\u2003private static InvocationProfiler mInstance;"},{"entry":"\u2003private Map<Stats, Stats>mStatsMap = new ConcurrentHashMap( );"},{"entry":"\u2003public InvocationProfiler( ) {"},{"entry":"\u2003\u2003mInstance = this;"},{"entry":"\u2003}"},{"entry":"\u2003@JMXEntryPoint"},{"entry":"\u2003@BindToMBean(name = \u201cSFProfiler\u201d, displayName = \u201cService Framework Profiler\u201d,"},{"entry":"\u2003\u2003\u2003description = \u201cService Framework Profiler\u201d)"},{"entry":"\u2003public static InvocationProfiler getInstance( ) {"},{"entry":"\u2003\u2003return mInstance;"},{"entry":"\u2003}"},{"entry":"\u2003@BindToMBean(name = \u201cstatistics\u201d, displayName = \u201cInvocation statistics\u201d,"},{"entry":"\u2003\u2003\u2003description = \u201cInvocation statistics\u201d)"},{"entry":"\u2003public Stats[ ] getStatistics( ) {"},{"entry":"\u2003\u2003List<Stats> sl = new ArrayList( );"},{"entry":"\u2003\u2003for (Map.Entry<Stats, Stats> e : mStatsMap.entrySet( ))"},{"entry":"\u2003\u2003\u2003sl.add(e.getValue( ));"},{"entry":"\u2003\u2003return sl.toArray(new Stats[sl.size( )]);"},{"entry":"\u2003}"},{"entry":"\u2003public Map<Stats, Stats>getStatisticsMap( ) {"},{"entry":"\u2003\u2003return mStatsMap;"},{"entry":"\u2003}"},{"entry":"\u2003@ExposeToJMX(name = \u201creset\u201d, operation = true, displayName = \u201cresetStats\u201d,"},{"entry":"\u2003\u2003\u2003description = \u201cReset counters\u201d)"},{"entry":"\u2003public void reset( ) {"},{"entry":"\u2003\u2003mStatsMap = new ConcurrentHashMap( );"},{"entry":"\u2003}"},{"entry":"\u2003public Stats getStatistics(String caller, String callee) {"},{"entry":"\u2003\u2003Stats 1 = new Stats(caller, callee);"},{"entry":"\u2003\u2003return mStatsMap.get(1);"},{"entry":"\u2003}"},{"entry":"\u2003public void invokedEvent(String caller, String callee, long elapsedTime) {"},{"entry":"\u2003\u2003Stats 1= new Stats(caller, callee);"},{"entry":"\u2003\u2003Stats stats = mStatsMap.get(1);"},{"entry":"\u2003\u2003if (stats == null) {"},{"entry":"\u2003\u2003\u2003stats = 1;"},{"entry":"\u2003\u2003\u2003mStatsMap.put(stats, stats);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003stats.incCumulativeServiceTime(elapsedTime);"},{"entry":"\u2003\u2003if (elapsedTime > stats.getPeakServiceDuration( ))"},{"entry":"\u2003\u2003\u2003stats. setPeakServiceDuration(elapsedTime);"},{"entry":"\u2003\u2003stats.incServicedCount( );"},{"entry":"\u2003}"},{"entry":"\u2003public long currentTime( ) {"},{"entry":"\u2003\u2003return System.nanoTime( );"},{"entry":"\u2003}"},{"entry":"\u2003public class Stats implements java.io.Serializable {"},{"entry":"\u2003\u2003private AtomicLong mPeakServiceDuration = new AtomicLong(0L);"},{"entry":"\u2003\u2003private AtomicLong mCumulativeServiceTime = new AtomicLong(0L);"},{"entry":"\u2003\u2003private AtomicLong mServicedCount = new AtomicLong(0L);"},{"entry":"\u2003\u2003private String mCallee = null;"},{"entry":"\u2003\u2003private String mCaller = null;"},{"entry":"\u2003\u2003public Stats(String caller, String callee) {"},{"entry":"\u2003\u2003\u2003mCaller = caller;"},{"entry":"\u2003\u2003\u2003mCallee = callee;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003@ExposeToJMX(name = \u201ccallee\u201d, key = true, displayName = \u201ccallee\u201d, "},{"entry":"\u2003\u2003\u2003description = \u201cCalled method\u201d)"},{"entry":"\u2003\u2003public String getCallee( ) {return mCallee; }"},{"entry":"\u2003\u2003@ExposeToJMX(name = \u201ccaller\u201d, key = true, displayName = \u201ccaller\u201d, "},{"entry":"\u2003\u2003\u2003description = \u201cCalling method\u201d)"},{"entry":"\u2003\u2003public String getCaller( ) { return mCaller; }"},{"entry":"\u2003\u2003@ExposeToJMX(name = \u201cservicedCount\u201d, displayName = \u201cservicedCount\u201d,"},{"entry":"\u2003\u2003\u2003description = \u201cServiced Count\u201d)"},{"entry":"\u2003\u2003public long getServicedCount( ) {return mServicedCount.get( ); }"},{"entry":"\u2003\u2003public void incServicedCount( ) {mServicedCount.getAndIncrement( ); }"},{"entry":"\u2003\u2003public void setServicedCount(long servicedCount) {"},{"entry":"\u2003\u2003\u2003mServicedCount.set(servicedCount); }"},{"entry":"\u2003\u2003@ExposeToJMX(name = \u201ccumulativeServiceTime\u201d, displayName ="},{"entry":"\u2003\u2003\u2003\u201ccumulativeServiceTime\u201d, description = \u201cCumulative Service Time\u201d)"},{"entry":"\u2003\u2003public long getCumulativeServiceTime( ) {return mCumulativeServiceTime.get( ); }"},{"entry":"\u2003\u2003public void incCumulativeServiceTime(long elapsedTime) {"},{"entry":"\u2003\u2003\u2003mCumulativeServiceTime.getAndAdd(elapsedTime); }"},{"entry":"\u2003\u2003@ExposeToJMX(name = \u201cavgServiceTime\u201d, displayName = \u201cavgServiceTime\u201d,"},{"entry":"\u2003\u2003\u2003description = \u201cAverage Service Time\u201d)"},{"entry":"\u2003\u2003public double getAverageServiceDuration( ) {"},{"entry":"\u2003\u2003\u2003double avg = mServicedCount.get( ) == 0L ? (double)"},{"entry":"\u2003\u2003\u2003\u2003mCumulativeServiceTime.get( ) :"},{"entry":"\u2003\u2003\u2003\u2003(double) (mCumulativeServiceTime.get( ) \/ mServicedCount.get( ));"},{"entry":"\u2003\u2003\u2003return avg \/ 1000000;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003@ExposeToJMX(name = \u201cpeakServiceDuration\u201d, displayName ="},{"entry":"\u2003\u2003\u2003\u201cpeakServiceDuration\u201d, description = \u201cPeak Service Duration\u201d)"},{"entry":"\u2003\u2003public long getPeakServiceDuration( ) { return mPeakServiceDuration.get( ) \/ 1000000; }"},{"entry":"\u2003\u2003public void setPeakServiceDuration(long peakServiceDuration) {"},{"entry":"\u2003\u2003\u2003mPeakServiceDuration.lazySet(peakServiceDuration);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003@ExposeToJMX(name = \u201cprofiler\u201d, displayName = \u201cprofiler\u201d, description ="},{"entry":"\u2003\u2003\u2003\u201cReference to parent\u201d)"},{"entry":"\u2003\u2003public InvocationProfiler getProfiler( ) { return InvocationProfiler.this; }"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2A","b":["200","200","205","210","215"]},"At step  the poller registers the constructed MBean with a JMX server. The JMX server may then monitor the instrumented application program. Steps , , and  may be performed in periodically by the poller to maintain an inventory of the registered MBeans. At step  the execution of the application program by the main thread continues. The main thread may execute asynchronously with the poller thread. In contrast with conventional methods, the JMX server interactions to monitor the instrumented application program are performed on the poller execution thread instead of on the main thread. Consequently, the interactions do not result in reduced performance of the main execution thread, i.e., the application program. The poller thread allows for instrumenting of the application program for debug or quality assurance (QA) purposes as well as for in-production monitoring.","The poller thread maintains an inventory of the registered MBeans, registering new MBeans as they are constructed and removing MBeans that were constructed for JavaBeans that disappear. When multiple objects of the same type are used, the poller uses a unique name, e.g., a JMX object name, for each one of the multiple objects.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2B","FIG. 2B"],"b":["250","250","255","260","275","265","270"]},"At step  the poller thread determines if any previously registered MBeans in the inventory maintained by the poller thread correspond to instances of JavaBeans that are missing (i.e., no longer exist) in the application program. If none of the previously registered MBeans correspond to JavaBeans that are missing, then at step  the poller thread execution is complete. Otherwise, at step  the inventory is updated to remove each previously registered MBean that corresponds to a missing JavaBean.","The application program to be monitored and the poller thread for instrumenting the application program each comprise an ordered listing of executable instructions for implementing logical functions. The application program and the poller thread can be embodied in any computer-readable medium for use by or in connection with an instruction execution system, apparatus, or device, such as a computer-based system, processor-containing system, or other system that can fetch the instructions from the instruction execution system, apparatus, or device and execute the instructions.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3","b":["300","100","310","315","330","330","335","340","340","342","342","340","344","346","300","310","346","342"]},"One advantage of the systems and methods described herein is that the polling thread executes in the background and, therefore, does not reduce the performance of the application program execution while monitoring activities are performed. Additionally, the polling thread is configured to simplify the process of instrumenting code for JMX by navigating the application program structure to locate JavaBeans to bind to JMX, exposing the JavaBeans using MBeans, and registering the MBeans with JMX to enable monitoring of the instrumented code.","Various embodiments of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored.","The invention has been described above with reference to specific embodiments and numerous specific details are set forth to provide a more thorough understanding of the invention. Persons skilled in the art, however, will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
