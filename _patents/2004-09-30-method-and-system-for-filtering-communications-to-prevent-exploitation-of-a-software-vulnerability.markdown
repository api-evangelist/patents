---
title: Method and system for filtering communications to prevent exploitation of a software vulnerability
abstract: A method and system for protecting an application that implements a communication protocol against exploitation of a communication-based vulnerability is provided. A protection system provides a protection policy that specifies how to recognize messages that expose a specific vulnerability and specifies actions to take when the vulnerability is exposed. A protection policy specifies the sequence of messages and their payload characteristics that expose a vulnerability. The protection system may specify the sequences of messages using a message protocol state machine. A message protocol state machine of an application represents the states that the application transitions through as it receives various messages. The message protocol state machine of the protection policy may be a portion of the message protocol state machine of the application relating to the vulnerability. The protection system uses the message protocol state machine to track the states that lead up to the exposing of the vulnerability.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07694022&OS=07694022&RS=07694022
owner: Microsoft Corporation
number: 07694022
owner_city: Redmond
owner_country: US
publication_date: 20040930
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION(S)","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/547,131, filed on Feb. 24, 2004, entitled \u201cMETHOD AND SYSTEM FOR FILTERING COMMUNICATIONS TO PREVENT EXPLOITATION OF A SOFTWARE VULNERABILITY,\u201d which is hereby incorporated by reference.","The described technology relates generally to detecting and preventing an exploitation of a vulnerability of an application.","Although the Internet has had great successes in facilitating communications between computer systems and enabling electronic commerce, the computer systems connected to the Internet have been under almost constant attack by hackers seeking to disrupt their operation. Many of the attacks seek to exploit vulnerabilities of the application programs or other computer programs executing on those computer systems. One of the most destructive methods of attacking a computer system has been to send a \u201cworm\u201d to a computer program. A worm is a self-propagating attack that exploits a vulnerability by taking control of the computer system and using that computer system to launch attacks (i.e., send the same worm) against other computer systems with the same vulnerability. A worm is a message or sequence of messages designed to exploit a vulnerability of the receiving computer program. Upon receiving the message or messages, the computer program performs some action that allows the worm to take control of the computer system.","Developers of applications and administrators of computer systems go to great effort and expense to identify and remove vulnerabilities. Because of the complexity of applications, however, it is virtually impossible to identify and remove all vulnerabilities before applications are released. After an application is released, developers can become aware of vulnerabilities in various ways. A party with no malicious intent may identify a vulnerability in an application and may secretly notify the developer so the vulnerability can be removed before a hacker identifies and exploits it. If a hacker identifies a vulnerability first, the developer may not learn of the vulnerability until it is exploited\u2014sometimes with disastrous consequences.","Regardless of how a developer finds out about a vulnerability, the developer typically develops and distributes to system administrators \u201cpatches\u201d that remove the vulnerability. If the vulnerability has not yet been exploited (e.g., might not be known to hackers), then a developer can design, implement, test, and distribute a patch in a disciplined way. If the vulnerability has already been widely exposed, then the developer may rush to distribute a patch without the same care that is used under normal circumstances. When patches are distributed to the administrators of the computer systems, they are responsible for scheduling and installing the patches to remove the vulnerabilities.","Unfortunately, administrators often delay the installation of patches to remove vulnerabilities for various reasons. When a patch is installed, the application and possibly the computer system on which it is executing may need to be shut down and restarted. If the vulnerability is in an application that is crucial to the success of an organization, then the administrator needs to analyze the tradeoffs of keeping the application up and running with its associated risk of being attacked and of shutting down a crucial resource to install the patch. Some administrators may delay the installation of the patch because they fear that, because of a hasty distribution, it might not be properly tested and have unintended side effects. If the patch has an unintended side effect, then the application (or the computer system) may be shut down by the patch itself. Administrators need to factor in the possibility of an unintended side effect when deciding whether to install a patch. These administrators may delay installing a patch until experience by others indicates that there are no serious unintended side effects.","Other methods are available for preventing the exploitation of vulnerabilities in applications. For example, if the source of an exploitation is known, then all messages from that source can be intercepted and discarded before they reach the application. The source of the attack, however, may not be precisely identifiable, resulting in messages from many benign sources also being discarded. As another example, a message that is attempting to exploit a vulnerability may have a characteristic (e.g., a file name that is too long) that can be detected and discarded before it is sent to the application.","Current methods for preventing exploitation of vulnerabilities are not completely satisfactory for various reasons. The installation of patches is not completely satisfactory because some administrators simply may not install patches fast enough to prevent exploitation of the vulnerabilities. Moreover, a patch could itself have side effects that are more disastrous than the exploitation of the vulnerability. The intercepting of messages to identify an attempted exploitation is also not completely satisfactory because the identifications are based on known exploitations and may not prevent unknown exploitations of the same vulnerability. It would be desirable to prevent the exploitation of vulnerabilities in a way that does not require patches and that is independent of any particular exploitation of the vulnerability.","A method and system for identifying when a condition of a communication protocol of a component is to be satisfied is provided. In one embodiment, the system provides a specification that specifies at least a portion of the communication protocol (i.e., a model of the communication protocol) and indicates within the specified portion of the communication protocol when the condition is satisfied. When a communication for the component is received, the system determines, before the processing of the communication by the component, whether the received communication would satisfy the condition as specified by the provided specification. The system can then take appropriate action depending on whether the condition is satisfied. For example, if the condition relates to the exposing of a vulnerability of the component, then the system may take the action of not providing the communication to the component when the condition is satisfied to prevent the exposing of the vulnerability.","A method and system for protecting a component, such as an application, that implements a communication protocol (e.g., message-based or stream-based protocol) against exploitation of a communication-based vulnerability is provided. In one embodiment, a protection system provides a \u201cprotection policy\u201d that specifies how to recognize messages that expose a specific vulnerability and specifies actions to take when the vulnerability is exposed. A protection policy specifies the sequence of messages and their payload characteristics that expose a vulnerability. The protection system may specify the sequences of messages using a message protocol state machine. A message protocol state machine of an application represents the states that the application transitions through as it receives various messages. The message protocol state machine of a protection policy may be a portion of the message protocol state machine of the application relating to the vulnerability. The protection system uses the message protocol state machine to track the states that lead up to exposing the vulnerability. The protection policy may specify actions to be performed depending on the current state and the received or current message. These actions may include checking the payloads of the messages to determine whether certain conditions are met, identifying a next state for the message protocol state machine, discarding a message, disconnecting from the source of a message, and so on. Because the protection policy is based on the message protocol associated with the vulnerability, it is independent of any exploitation of the vulnerability. The protection system thus models the communication-based protocol that is used by the application so that conditions such as the exposing of vulnerabilities can be detected and prevented.","In one embodiment, a protection policy describes a vulnerability of an application and actions to protect against exploitation of the vulnerability. A protection policy has two parts. The first part defines protocol states, events, and generic application-level protocol information, such as ports used, locations of event types, session identifiers, and sequence numbers in a packet, and message boundary markers. The second part defines handlers (i.e., sets of actions) and message payload parsing instructions. The handlers are executed at runtime to examine a message payload and identify any exploitation of the vulnerability, and to take countermeasures to prevent its exploitation or to record session information that is needed for a later identification of an exploitation. Prior to runtime, the protection system parses the handlers and the payload instructions of a protection policy and stores them in a syntax tree for more efficient processing at runtime. The protection system stores the first part of the protection policy and the syntax tree as a \u201cvulnerability specification.\u201d The vulnerability specification may include triplets of state, event, and handlers.","When the protection system receives a message before it has been sent to the application, it identifies the event corresponding to the message and the current state of the message protocol state machine of the application. The protection system then identifies and executes the handler associated with the current state and the current event as indicated by the triplets. The handler may analyze the message, including its payload, to determine whether characteristics leading to the exposing of the vulnerability are present, may change the current state to a next state that depends on the characteristics of the message, may save state information needed to make subsequent determinations when other messages are received, may perform counteractions against identified exploitations, and so on. If the protection system determines that a message would expose the vulnerability, it does not provide the message to the application. The protection system thus prevents the exploitation of a vulnerability of an application without patching the application. Moreover, the protection system provides a generic framework that can be used to prevent exploitation of vulnerabilities for many different message-based applications.","In one embodiment, the protection system operates between the transport layer and the application layer of the network protocol. One skilled in the art will appreciate, however, that the protection system can operate in between or within various network protocol layers and multiple protocol layers simultaneously. For example, some applications may provide hooks for pre-processing messages before the application performs its processing. With such applications, the protection system can operate at the application layer and process the messages before the application processes the message. If the protection system determines that a vulnerability is exposed, then it can discard the message, abort the application, or take some other appropriate action.","Applications that service multiple clients may assign a session identifier to each client for use in identifying which client sent a message. A single client may have multiple sessions and thus multiple session identifiers. In which case, a session identifier identifies a particular session of a client. A sequence of messages within a session can expose a vulnerability. Thus, the protection system tracks the state of messages on a session-by-session basis. The protection system creates a new instance of state information when a new session is identified. Each message identifies the target application and session. When a message is received, the protection system identifies the application and the session from the message. The protection system may identify the application based on a port number stored in header information of the message and the session based on an application-specific indication of where session information is stored within the message. The vulnerability specification of an application may specify the port numbers associated with that application and describe the location of a session identifier within the messages of that application. In addition, the vulnerability specification of an application may specify the location of other information within a message such as the location of message type and the location of a message boundary. If the message is the first of a session, then the protection system may allocate a state information data structure for that session. The vulnerability specification of an application may define the data structure based on the information that needs to be stored from message to message. The protection system initializes the state information, which may include setting the current state for the session to an initial state defined by the vulnerability specification. Whenever a new message is received, the protection system identifies the application and session, retrieves the state information for that application and session, and then invokes a state machine engine to select a handler to execute based on the current state and an event specified by the received message.","In one embodiment, the protection system handles application-level messages that may not arrive as a single message unit. The scattered arrival of a single application-level message as multiple message units may be a result of TCP congestion control, specific message handling implementations of an application, and so on. For example, a UDP server may make multiple calls to receive a single application-level message. In such a case, the protection system recognizes the arrival of multiple message units for the application-level message. When the session identifier or the message type is not received in a single message unit or not enough of the application-level message has been received for a handler to finish its processing, the protection system makes a copy of the needed portions of each message unit until the application-level message can be processed by a handler. The protection system could store the partial message information on a session-by-session basis, which might require the allocation of a buffer for each session. When, however, multiple sessions are sent through the same socket, the protection system may be able to store the partial message information on a socket-by-socket basis. Sockets typically have the characteristic that a complete message for a session will be received before any portion of a different message is received via that same socket. Because there may be fewer sockets than sessions, fewer buffers may need to be allocated when storing the information on a session-by-session basis. A buffer can be associated with only a socket before the session identifier is received. Once the session identifier is received, the buffer can be associated with the session.","In general, the protection system does not need to save partially arrived fields, nor does it need to save the entire portion of the application-level message that has been received. For example, if two bytes out of a four-byte session identifier have been received, then the protection system need only save those two bytes of the message. The protection system may use a field parsing state per application-level message to track which field is being parsed and how many bytes have been received. The protection system maintains the parsing state of the current field being parsed for each application-level message, even when it has been determined that the message will not lead to an exploitation. If the state was not maintained, then other parts of the application-level message might be treated as a new message. In such a case, a message might be crafted by an attacker to cause an inconsistency between the actual message state of the application and the emulated message state of the protection system.","The protection system may buffer application-level messages that are received out of order so that they can be processed in order. For example, when UDP is used, application-level messages can be received out of order. The protection system uses the sequence number as specified in a protection policy for the application. In addition, some application message protocols allow for fragmentation and reassembly of application-level messages. The fragments can be received in order (e.g., with TCP) or out of order (e.g., with UDP). The protection system can handle the fragments received in order in a manner similar to the partial-field processing described above. If the fragments are received out of order, the protection system can save them and process them in order.","In one embodiment, the principles of the protection system can be applied to augment a message protocol. For example, it might be desirable to improve the security of an application by adding authentication processing at some state of the message protocol. The developer of the application may be, however, reluctant to do so. In such a case, a system (e.g., an authentication system) similar to the protection system could be implemented. The authentication system may have a server side and a client side. The server side would use a specification of states, events, and handlers and a state machine engine to identify the appropriate state and event when authentication should occur. The handler for that state and event could send a challenge to a client before providing the message to the application. Upon receiving the challenge, the client side of the authentication system could detect that a challenge has been received and send the appropriate response. The client side may have specifications and a state machine engine for detecting the challenge. When the server side receives the response, it can validate the response and provide the message to the application as appropriate. More generally, a generic architecture is provided that can track message protocol states and perform the desired processing prior to processing by the target application. Although the architecture may be symmetric on a client and a server, the specifications are asymmetric because of the different processing needs of a server and its client. The generic architecture could be used to implement an encryption scheme, logging of messages, debugging of problems, and so on.","In one embodiment, the protection system may intercept messages by instrumenting application programming interfaces (\u201cAPIs\u201d) to process the messages. For example, the receive function of a sock layer API may be instrumented to invoke the underlying, non-instrumented receive function and then to pass a buffer containing the message to the protection component. If the protection component determines that the message will exploit a vulnerability, the protection may discard the message or tear down the communication session, and the instrumented receive function may return an error. Otherwise, the instrumented receive function may return the buffer as would the non-instrumented receive function. The protection system may be used to intercept messages or portions of messages at various levels in a hierarchy of APIs. A hierarchy of APIs includes APIs that invoke lower-level APIs, which in turn invoke still lower-level APIs. A programmer of an application typically develops the application to invoke the highest level APIs. For example, an application may invoke a get order function of a customer relationship management system (\u201cCRM\u201d) API to retrieve a new order from a customer. The get order function may invoke a get header function and repeatedly invoke a get line item function of a lower-level ordering API to aggregate the order information for return to the application. The get line item function may invoke the receive function of the socket layer API to retrieve the next line item message sent from the customer. The get order function of the CRM API may be instrumented to pass the new order to the protection system. The protection system may have handlers to analyze a new order parameter, and determine whether it would exploit a vulnerability. The protection system may be used here to detect and correct the parameters that would exploit a vulnerability. For example, the protection system may be used to determine whether a new order from a customer can be authenticated. If not, the protection system can discard the new order and return an error to the application. Thus, the protection system can be used to analyze the semantics of messages at various levels of abstraction.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["110","130","140","120","111","112"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2","b":["211","215","221","224","211","211","221","212","215","212","222","213","215","213","223","214","215","214","224","215","221","222","223","214"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["301","303","304","305","306","302","307"]},"The computing device on which the protection system is implemented may include a central processing unit, memory, input devices (e.g., keyboard and pointing devices), output devices (e.g., display devices), and storage devices (e.g., disk drives). The memory and storage devices are computer-readable media that may contain instructions that implement the protection system. In addition, data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communications link. Various communications links may be used, such as the Internet, a local area network, a wide area network, or a point-to-point dial-up connection.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3"},"The protection system may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, and so on that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. The term \u201capplication\u201d refers to any type of executing software such as drivers, kernel-mode code, operating systems, system utilities, web servers, database servers, and so on.","Table 1 illustrates a portion of a protection policy in one embodiment. The protection policy may be developed using a special-purpose language. A protection policy has a first part with application and state machine information, and a second part with handlers and payload instructions. The lines that start out with \u201c#\u201d are comments. The application information (lines 1-5) describes location and port information. The state machine information (lines 6-28) describes the states, events, and triplets. The handlers (lines 46-67) define processing to be performed. The payload instructions (lines 29-45) specify how to parse the field of a message of the application. The payload instructions need only to define the field used in detecting an exploitation. The other fields can be lumped together and skipped over during field parsing. The handlers could theoretically be written in any programming language. A language should be used that would make it difficult to attack the protection policies themselves. A special-purpose programming language has been developed to help prevent such attacks. In the handlers of Table 1, the language uses data types of Boolean, counter (e.g., integer), and word and byte arrays. The language also provides various operations such as drop a message, tear down a session, determine message length, and so on. The operation \u201c>>payload\u201d (e.g., line 49) indicates to parse the payload (e.g., payload is \u201cP_RPCRequest buffer size) according to the specified payload instructions. The language may also allow statements such as if-then statements, special-purpose for-loops, and so on. The special-purpose for-loops are used for iterative payload structures. In one embodiment, the handlers are interpreted at runtime by an interpreter.",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u20021 \u2003# SHIELD (Name, Transport_Protocol, (port-list))"},{"entry":"\u20022 \u2003SHIELD (Vulnerability_Behind_MSBlast, TCP, (135, 139, 445))"},{"entry":"\u20023 \u2003# where to retrieve SESSION_ID and MSG_TYPE from"},{"entry":"\u20024 \u2003SESSION_ID_LOCATION = (12, 4);"},{"entry":"\u20025 \u2003MSG_TYPE_LOCATION = (2, 1);"},{"entry":"\u20026 \u2003INITIAL_STATE S_WaitForRPCBind;"},{"entry":"\u20027 \u2003FINAL_STATE S_Final;"},{"entry":"\u20028 \u2003STATE \u2003S_WaitForRPCBindAck;"},{"entry":"\u20029 \u2003STATE \u2003S_WaitForRPCAlterContextResponse;"},{"entry":"10 \u2003STATE \u2003S_WaitForRPCRequest;"},{"entry":"11 \u2003STATE \u2003S_WaitForSessionTearDown;"},{"entry":"12 \u2003# EVENT eventName = (<eventTypeValue>, <direction>)"},{"entry":"13 \u2003EVENT E_RPCBind = (0x0B, INCOMING);"},{"entry":"14 \u2003EVENT E_RPCBindAck = (0x0C, OUTGOING);"},{"entry":"15 \u2003EVENT E_RPCBindNak = (0x0D, OUTGOING);"},{"entry":"16 \u2003EVENT E_RPCAlterContext = (0x0E, INCOMING);"},{"entry":"17 \u2003EVENT E_RPCAlterContextResponse = (0x0F, OUTGOING);"},{"entry":"18 \u2003EVENT E_RPCRequest = (0x0, INCOMING);"},{"entry":"19 \u2003EVENT E_RPCShutdown = (0x11, OUTGOING);"},{"entry":"20 \u2003EVENT E_RPCCancel = (0x12, INCOMING);"},{"entry":"21 \u2003EVENT E_RPCOrphaned = (0x13, INCOMING);"},{"entry":"22 \u2003STATE_MACHINE = {"},{"entry":"23 \u2003# (State, Event, Handler),"},{"entry":"24 \u2003(S_WaitForRPCBind, E_RPCBind, H_RPCBind),"},{"entry":"25 \u2003(S_WaitForRPCBindAck, E_RPCBindAck, H_RPCBindAck),"},{"entry":"26 \u2003(S_WaitForRPCRequest, E_RPCRequest, H_RPCRequest),"},{"entry":"27 \u2003..."},{"entry":"28 \u2003};"},{"entry":"29 \u2003# payload parsing instruction for P_Context"},{"entry":"30 \u2003PAYLOAD_STRUCT {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["31 \u2003\u2003SKIP BYTES(6)","dummy1,"]},{"entry":["32 \u2003\u2003BYTES(1)","numTransferContexts,"]},{"entry":["33 \u2003\u2003SKIP BYTES(1)","dummy2,"]},{"entry":["34 \u2003\u2003BYTES(16)","UUID_RemoteActivation,"]},{"entry":["35 \u2003\u2003SKIP BYTES(4)","version,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"36 \u2003\u2003SKIP BYTES (numTransferContexts * 20) allTransferContexts,"},{"entry":"37 \u2003} P_Context;"},{"entry":"38 \u2003# payload parsing instruction for P_RPCBind"},{"entry":"39 \u2003PAYLOAD_STRUCT {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["40 \u2003\u2003SKIP BYTES(24)","dummy1,"]},{"entry":["41 \u2003\u2003BYTES(1)","numContexts,"]},{"entry":["42 \u2003\u2003SKIP BYTES(3)","dummy2,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"43 \u2003\u2003P_Context[numContexts] contexts,"},{"entry":"44 \u2003..."},{"entry":"45 \u2003} P_RPCBind;"},{"entry":"46 \u2003HANDLER H_S_RPCBind (P_RPCBind)"},{"entry":"47 \u2003{"},{"entry":"48 \u2003\u2003# if invoking the RemoteActivation RPC call"},{"entry":"49 \u2003\u2003IF (>>P_RPCBind.contexts[0] =="},{"entry":"\u2003 \u2003\u20030xB84A9F4D1C7DCF11861E0020AF6E7C57)"},{"entry":"50 \u2003\u2003\u2003RETURN (S_WaitForRPCBindAck);"},{"entry":"51 \u2003\u2003FI"},{"entry":"52 \u2003\u2003RETURN (S_Final);"},{"entry":"53 \u2003};"},{"entry":"54 \u2003HANDLER H_RPCBindAck (P_RPCBindAck)"},{"entry":"55 \u2003{"},{"entry":"56 \u2003\u2003RETURN (S_WaitForRPCRequest);"},{"entry":"57 \u2003};"},{"entry":"58 \u2003HANDLER H_RPCRequest (P_RPCRequest)"},{"entry":"59 \u2003{"},{"entry":"60 \u2003\u2003IF (>>P_RPCRequest.bufferSize > 1023)"},{"entry":"61 \u2003\u2003\u2003TEARDOWN_SESSION;"},{"entry":"62 \u2003\u2003\u2003PRINT (\u201cMSBlast!\u201d);"},{"entry":"63 \u2003\u2003\u2003# since other RPC requests can come as well"},{"entry":"64 \u2003\u2003\u2003RETURN (S_Final);"},{"entry":"65 \u2003\u2003FI"},{"entry":"66 \u2003\u2003RETURN (S_WaitForSessionTearDown);"},{"entry":"67 \u2003};"},{"entry":"68 \u2003# ... other PAYLOAD_STRUCTs and Handlers not included here ..."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["401","402","403","404","405","407","405","406","407","407","408","405","408"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 5","FIG. 3"],"b":["510","511","512","501","502","503"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 6","b":["610","601","602","611","612","613"]},"One skilled in the art will appreciate that although specific embodiments of the protection system have been described herein for purposes of illustration, various modifications may be made without deviating from the spirit and scope of the invention. For example, if the payload of a message is encrypted, the protection system may request the application for a decryption key. The protection system can then decrypt the message and process the decrypted message. The protection system can provide the un-decrypted version of the message to the application. Alternatively, the protection system may retrieve the decryption key from a key vault of the application. A decryption key may also be provided to the protection system by a system administrator or key escrow system. As another example, if ports are dynamically assigned to an application, a vulnerability specification can be developed to detect such a port and register the port for that application with the vulnerability specification store. Although the protection system has been described primarily in the context of message-based protocols, the principles of the protection system can also be applied to stream-based protocols. Also, the protection policies may use regular expressions in place of a finite state machine. The protection system may be used in conjunction with the techniques described in U.S. Provisional Patent Application No. 60\/547,415, entitled \u201cMETHOD AND SYSTEM FOR DYNAMIC SYSTEM PROTECTION,\u201d and filed on Feb. 23, 2004, which is hereby incorporated by reference. As described in that application, protection policies can be automatically enabled or disabled depending on the patches that have been applied to an application. The protection system can be used to detect attempted exploits of vulnerabilities based on invoking application programming interfaces (\u201cAPIs\u201d) of an application. An API provides an interface through which programs can access the services of the application. The interface defines a communication protocol for a program to communicate with the application. Thus, the term \u201ccommunication protocol\u201d refers to procedures and rules for communicating between components and is not limited to the protocols of the ISO protocol stack. Accordingly, the invention is not limited except by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
