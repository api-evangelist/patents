---
title: Suspending and resuming a graphics application executing on a target device for debugging
abstract: Debugging a graphics application executing on a target device. The graphics application may execute CPU instructions to generate graphics commands to graphics hardware for generation of graphics on a display. A breakpoint for the graphics application may be detected at a first time. In response to detecting the breakpoint, one or more graphics commands which were executed by the graphics hardware proximate to the first time may be displayed. Additionally, source code corresponding to CPU instructions which generated the one or more graphics commands may be displayed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09298586&OS=09298586&RS=09298586
owner: Apple Inc.
number: 09298586
owner_city: Cupertino
owner_country: US
publication_date: 20111129
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY INFORMATION","FIELD","DESCRIPTION OF THE RELATED ART","SUMMARY","DETAILED DESCRIPTION OF THE EMBODIMENTS","Terms"],"p":["This application claims benefit of priority of U.S. provisional application Ser. No. 61\/546,041 titled \u201cDebugging a Graphics Application Executing on a Target Device\u201d filed Oct. 11, 2011, whose inventors were Andrew M. Sowerby, Benjamin N. Lipchak, Jean-Francois Roy, Max Drukman, Matthew Firlik, and Christopher Friesen, which is hereby incorporated by reference in its entirety as though fully and completely set forth herein.","The present embodiments relate to the field of computer graphics, and more particularly to debugging graphics applications.","Many modern devices include high end graphical processing systems for presenting graphics on a display. Due to their complexity, development of graphical software applications for such devices is often difficult. For example, it is difficult for developers to perform debugging on target devices which uses a different graphics system than the development system. Accordingly, in order to assist developers in creating graphical software applications, improved tools are desired for debugging these applications.","Various embodiments are presented of a system and method for debugging graphics applications executing on a target device.","The target device and a host device may be paired together. The host device may execute a development application to perform development and\/or debugging of an application on the target device. The host device may deploy the application to the target device and begin execution of the application on the target device. The host device may also deploy other programs on the target device in order to capture information regarding the execution of the application on the target device and\/or debug the application. For example, the host device may deploy one or more measurement and\/or debugging applications for performing debugging.","The target device may include a graphics system which includes both a central processing unit (CPU) and a graphics processing unit (GPU). The CPU and GPU may together execute the application. For example, the graphics application may execute CPU instructions which generate graphics commands for provision to the GPU for providing graphics on a display of the target device. A breakpoint (or capture event) may be reached during execution of the application (e.g., which was inserted in the graphics application or invoked response to user input, e.g., during execution, as desired). In response to the breakpoint, the target device may suspend execution of the application, e.g., saving the current state of the application for later resumption. Additionally, the target device may capture information, e.g., for use in debugging the application. For example, the target device may capture information related to the current graphics frame (e.g., the first full frame after the breakpoint is reached), such as the graphics commands executed to generate the current frame. This information may be provided back to the host device for performing the debugging.","Graphics commands that were executed proximate to the breakpoint (e.g., the graphics commands of the first full frame after the breakpoint) may be displayed, e.g., on a display of the host device to a developer of the application. Additionally, source code corresponding to the CPU instructions which generated the one or more graphics commands may be displayed. Further, graphics data corresponding to the graphics command may also be displayed. In one embodiment, a user may select one of the graphics commands, and the corresponding source code which caused the graphics command may be displayed. Additionally, the corresponding graphics of the graphics command may also be displayed. Thus, a user may be able to view the inter-related source code, graphics command, and\/or graphics data. More specifically, the user may be able to view the source code and\/or graphics data associated with a graphics command executed in the frame after the breakpoint (although other embodiments are envisioned, e.g., where graphics commands prior to the breakpoint may be displayed). These debugging actions may be performed in conjunction with a debug application executing on the target device (e.g., acting to provide saved information interactively or simply at the beginning of the debugging). In one embodiment, the debug application may provide the ability to replay graphics (e.g., GPU) commands that occurred proximate to the breakpoint and provide that information to the host device.","After debugging is completed, e.g., after a user ends the debugging or requests that the application resume execution, the target device may resume execution of the application, e.g., by loading the saved state and continuing execution of the application. In one embodiment, the process of suspending the application, performing debugging (e.g., using a debugging application executing on the target device, e.g., in conjunction with the development environment executing on the host device), and resuming the application may be performed in a seamless manner, e.g., which is transparent to the user.","While embodiments described herein are susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the embodiments to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present embodiments as defined by the appended claims.","The following is a glossary of terms used in the present application:","Memory Medium\u2014Any of various types of memory devices or storage devices. The term \u201cmemory medium\u201d is intended to include an installation medium, e.g., a CD-ROM, floppy disks, or tape device; a computer system memory or random access memory such as DRAM, DDR RAM, SRAM, EDO RAM, Rambus RAM, etc.; a non-volatile memory such as a Flash, magnetic media, e.g., a hard drive, or optical storage; registers, or other similar types of memory elements, etc. The memory medium may include other types of memory as well or combinations thereof. In addition, the memory medium may be located in a first computer in which the programs are executed, or may be located in a second different computer which connects to the first computer over a network, such as the Internet. In the latter instance, the second computer may provide program instructions to the first computer for execution. The term \u201cmemory medium\u201d may include two or more memory mediums which may reside in different locations, e.g., in different computers that are connected over a network. The memory medium may store program instructions (e.g., embodied as computer programs) that may be executed by one or more processors.","Carrier Medium\u2014a memory medium as described above, as well as a physical transmission medium, such as a bus, network, and\/or other physical transmission medium that conveys signals such as electrical, electromagnetic, or digital signals.","Computer System\u2014any of various types of computing or processing systems, including a personal computer system (PC), mainframe computer system, workstation, network appliance, Internet appliance, personal digital assistant (PDA), personal communication device, smart phone, television system, grid computing system, or other device or combinations of devices. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device (or combination of devices) having at least one processor that executes instructions from a memory medium.","Automatically\u2014refers to an action or operation performed by a computer system (e.g., software executed by the computer system) or device (e.g., circuitry, programmable hardware elements, ASICs, etc.), without user input directly specifying or performing the action or operation. Thus the term \u201cautomatically\u201d is in contrast to an operation being manually performed or specified by the user, where the user provides input to directly perform the operation. An automatic procedure may be initiated by input provided by the user, but the subsequent actions that are performed \u201cautomatically\u201d are not specified by the user, i.e., are not performed \u201cmanually\u201d, where the user specifies each action to perform. For example, a user filling out an electronic form by selecting each field and providing input specifying information (e.g., by typing information, selecting check boxes, radio selections, etc.) is filling out the form manually, even though the computer system must update the form in response to the user actions. The form may be automatically filled out by the computer system where the computer system (e.g., software executing on the computer system) analyzes the fields of the form and fills in the form without any user input specifying the answers to the fields. As indicated above, the user may invoke the automatic filling of the form, but is not involved in the actual filling of the form (e.g., the user is not manually specifying answers to fields but rather they are being automatically completed). The present specification provides various examples of operations being automatically performed in response to actions the user has taken.",{"@attributes":{"id":"h-0008","num":"0000"},"figref":"FIGS. 1A-1E"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1A","b":["100","150","100","150","150","100","150"]},"As shown in , the computer system  may include a display device configured to display a graphical user interface (GUI), e.g., of a control or development application executing on the computer system . The graphical user interface may include any type of graphical user interface, e.g., depending on the computing platform. The computer system  may include at least one memory medium on which one or more computer programs or software components may be stored. For example, the memory medium may store the control application, e.g., which may be executable to perform at least a portion of the methods described herein. Additionally, the memory medium may store a programming development environment application (or developer's tools application) used to create applications, e.g., for execution by the target device . The memory medium may also store operating system software, as well as other software for operation of the computer system. Various embodiments further include receiving or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium.","As also shown in , the target device  may include a display, which may be operable to display graphics provided by an application executing on the target device . The application may be any of various applications, such as, for example, games, internet browsing applications, email applications, phone applications, productivity applications, etc. The application may be stored in a memory medium of the target device . The target device  may include a central processing unit (CPU) and a graphics processing unit (GPU) which may collectively execute the application. For example, the CPU may generally execute the application as well as a graphics framework (e.g., OpenGL, DirectX, etc.) and graphics driver which may handle any graphics calls or commands that are provided by the application during execution. The graphics driver may in turn provide GPU commands to the GPU, which may execute these commands to provide display capabilities for the application. As used herein, a \u201cgraphics application\u201d refers to an application which provides graphics commands for displaying graphics of the application on a display. In other words, the term \u201cgraphics application\u201d refers to a software application that, when executed, causes the display of various graphics on a display, e.g., via graphics commands.","The memory medium of the target device  may also store one or more programs for implementing embodiments described herein. For example, the memory medium of the target device  may store a program for capturing information regarding graphics commands received from the application. The memory medium of the target device  may also store a program for debugging the application, e.g., which may be provided from the computer system . In further embodiments, the programs may be stored on the computer system  and may be read onto the target device  for execution.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1B","b":["100","150","125","125","100","150"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1C","b":["100","150","175","175","150","150","175","150","175"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIGS. 1D and 1E","FIG. 1D","FIG. 1E"],"b":["100","100","190","100","190","125"]},{"@attributes":{"id":"h-0009","num":"0000"},"figref":"FIGS. 2A-2B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIGS. 2A and 2B","FIGS. 2A and 2B"]},"More specifically,  illustrates one embodiment of a hardware architecture of a target device and\/or computer system, such as , ,  or . As shown, the CPU  and CPU memory  may be coupled together (e.g., over a system bus) and GPU  and GPU memory  may also be coupled together. The CPU  and GPU  (and their corresponding memories) may be coupled via bus interface . For example, in one embodiment, the GPU  and GPU memory  may be implemented as a video system having a different system interface than the CPU  and CPU memory . For example, the GPU  and GPU memory  may be implemented as a video card that is plugged in to a slot of the computer system  or . The video card may be implemented as a PCI, PCIe, AGP, etc. card. Accordingly, bus interface  may interface with the system bus of the CPU  and the bus of the video card. The target device, , ,  or  may also include display logic (not shown) as well as various other logic.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2B","b":["150","175","202","204","258","260","258","204","150","175"]},"It should be noted that the above hardware architectures of the graphics system are exemplary and are provided for illustration purposes only. Thus, various modifications (e.g., of blocks or connectivity) resulting in different hardware architectures are envisioned.",{"@attributes":{"id":"h-0010","num":"0000"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3"},"As shown in , the host  may execute a development environment or control application . The development environment  may be used to develop applications for execution on the target device . The development environment  may also control execution of a developed application , a playback application , a debug application , etc. that may be executing on the target device .","As also shown in , the target device  may execute a variety of programs, including application , debug application , playback application , graphics framework , and graphics driver . While this diagram largely shows programs that are executed by the CPU of the target device , note that the GPU of the target device  may also execute programs, e.g., shaders, that may be provided by the application .","In more detail, the application (or graphics application)  may be an application that is under development or testing, e.g., within the development environment . For example, a developer may be developing the application on the host  for ultimate deployment and execution on the target device, and may periodically need to test or debug the application while it is executing on the target device . Correspondingly, the development environment  may be used to deploy the application to the target device  for execution and testing.","The development environment  may also deploy other software to the target device  to assist in developing the application , e.g., once the developer has designated that the target device  is used for development of the application . For example, the development environment  may deploy the debug application  which may be used to debug the application  on the target device , e.g., as described herein. In some embodiments, the playback functionality implemented by the playback application  may be incorporated in the debug application , as desired.","The graphics framework  may be any of various types of graphics frameworks, e.g., various versions of openGL (including openGL for embedded systems (ES)), DirectX, etc. The graphics framework  may receive API calls from the application  for performing graphics framework functions. In turn, the graphics framework  may provide commands to the graphics driver , which may also be executing on the target device . Finally, the graphics driver  may provide GPU commands to the GPU. The CPU executing the graphics framework  and the graphics driver , along with the GPU may form a graphics pipeline, such as those embodiments described in  below.","Note that the above software architecture is exemplary only and other variations and modifications are envisioned. For example, in some embodiments, the graphics framework  may not be necessary and\/or may be implemented as part of the application  rather than being a separate executable.",{"@attributes":{"id":"h-0011","num":"0000"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIGS. 4A and 4B","FIG. 4A","FIG. 4B","FIGS. 4A and 4B","FIGS. 4A and 4B","FIG. 2A or 2B","FIG. 3","FIGS. 4A and 4B"],"b":["150","100","100"]},"In the graphics pipeline of , the pipeline may begin with vertex data in . The vertex data may specify the vertices of the graphics data to be rendered. In one embodiment, the vertex data may include data about polygons with vertices, edges and faces that constitute an entire scene.","In , the vertex data of  may be processed by a vertex shader. More particularly, the vertex shader may be run for each vertex, e.g., by the GPU. This process may transform each vertex's 3D position in virtual space to the 2D coordinate at which it will appear on the display. The vertex shader may manipulate various properties, including position, color, texture coordinate, etc. As shown, the vertex shader  may be informed by texture data  and\/or shader uniform data .","In , primitives may be assembled from the vertices output from . For example, in this stage vertices may be collected and converted into geometric shapes, e.g., triangles.","In , the primitives may be used in rasterization. More particularly, the primitives from  may be filled with pixels or fragments.","In , the fragment shader (e.g., executed by the GPU) may add textures and final colors to the fragments. Fragment shaders may typically take into account scene lighting and related effects, such as bump mapping and color toning. As shown, the fragment shader may be informed by texture data  and shader uniform data .","In , various per-fragment operations may be performed. For example, the operations may combine the final fragment color, its coverage, and\/or degree of transparency with the existing data stored at the associated 2D location in the frame buffer to produce the final color for the pixel to be stored at that location.","In , the data may be stored in physical memory which holds the actual pixel values displayed on the screen. The frame buffer memory may also store graphics commands, textures, and\/or other attributes associated with each pixel. This data may be used to output the final image to the display.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 4B","FIG. 4A"],"b":["402","454","404","406","408","412","414","410","418","408"]},"Thus,  illustrate exemplary graphics pipelines that may be utilized in embodiments described herein. However, other, different graphics pipelines are envisioned.",{"@attributes":{"id":"h-0012","num":"0000"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 5","FIG. 5"]},"In , a target device may be coupled (or paired) to a host device. As indicated above, the target device and host device may be coupled together in a variety of ways, e.g., directly via a wired or wireless connection, or indirectly, over a network (e.g., an Intranet or the Internet).","In , an application may be executed on the target device. For example, the application may be developed using a development environment program executed by the host device. The user (e.g., the developer) may compile the application for execution and\/or deploy the application to the target device using the development environment. For example, in response to a command to run the application on the target device, the development environment may automatically perform those actions. As indicated above, the development environment program may also deploy other programs to the target device, e.g., debugging programs or other programs as desired.","Once the application is deployed on the target device, the development environment program may initiate execution of the application (and\/or any other programs, such as those described above) on the target device, e.g., by sending an execution command to the target device. In one embodiment, the user may select a \u201cplay\u201d button, which may cause the application to be compiled (if necessary), deployed (if necessary), and executed by the target device. Thus, in , execution of the application by the target device may be initiated.","In , a breakpoint may be reached or detected at a first time. For example, the breakpoint may be identified in the source code of the application (and correspondingly in CPU instructions resulting from compilation or interpretation of the application). For example, the developer of the application may have manually inserted a breakpoint into the code using the development environment, e.g., indicating that the application should cease execution upon reaching a particular point in the application. Accordingly, the breakpoint may have been compiled into the application, and upon execution, one or more CPU instructions may be used to implement the breakpoint to cease execution at the specified location of the application. Alternatively, or additionally, a user may provide input to initiate a breakpoint during execution of the application. For example, while monitoring execution of the application, e.g., visually, the user may provide input to cause the application to cease executing. In one embodiment, the user may provide the input to the host device, e.g., using a keyboard or mouse, or may provide the input to the target device, as desired. Thus, the breakpoint may be initiated in a variety of manners. Note that the breakpoint may also be considered a \u201ccapture event\u201d or a \u201ccapture trigger event\u201d which results in the actions described herein. In some embodiments, such an event may be implemented via a CPU breakpoint. Thus, the term \u201cbreakpoint\u201d, as used herein, includes embodiments where it is implemented as a \u201ccapture event\u201d.","In , in response to the breakpoint, the target device may suspend or cease execution of the application, e.g., automatically. Depending on how the breakpoint was specified, this suspension may be initiated in a variety of manners. For example, if the breakpoint was compiled into the application, the breakpoint may be caused by a CPU instruction executed by a processor of the device. Accordingly, in this embodiment, the breakpoint may be detected locally. Similarly, if the breakpoint is specified via user input to the target device, the breakpoint may be detected locally. However, where the input is received to the host device, the breakpoint may be detected by the target device via a command sent from the host device. For example, in one embodiment, the user may provide input to stop execution of the application to the host device, e.g., using a keystroke to initiate the breakpoint, and, in response, the host device may provide a command to the target device to cease execution of the application. As discussed below, regarding , the target device may save various information (e.g., state information) regarding the application to suspend the application, e.g., so that the application may be resumed at a later point.","Additionally, in , information may be received from the target device, e.g., for use in debugging the information. More specifically, the target device may automatically capture this information and provide the information to the host device. For example, the target device may capture information related to the current graphics frame, such as the graphics commands executed in the current frame, e.g., of the graphics framework. For example, the target device may capture information of a graphics frame immediately following the breakpoint. However, note that this embodiment is exemplary only, and the target device may capture information for frames prior to the breakpoint (e.g., using a measurement application executing concurrently with the application, as discussed herein).","The information may include data related to any step of the graphics pipeline, e.g., from the application, the graphics framework, the graphics driver, and\/or the GPU, among other possibilities. Thus, the information may be any of various data that may be gathered from the target device to assist in performing debugging. As discussed below, the information may be used to display various graphics commands and graphics data to the user, e.g., in the development environment on the host device.","In one embodiment, the information may be captured by a measurement application executing on the target device, e.g., concurrently with the application. For example, the measurement application may gather CPU load information, GPU load information, and\/or other information. In further embodiments, the measurement application may intercept and record graphics commands provided by the application. Thus, the information may include those graphics commands (e.g., encoded in a bitstream) and may be provided back to the host device for performing the debugging, as discussed below.","Note that the gathering of information and suspension of the application in  and  may be performed in a different order or may be performed concurrently, e.g., as a single step.","In , graphics commands that were executed proximate to the breakpoint may be displayed, e.g., on a display of the host device to a developer of the application. In one embodiment, the displayed graphics commands may correspond to those called in the frame immediately following the breakpoint. In one embodiment, a frame may be considered the list of commands (e.g., graphics commands) that are executed between one buffer render and the next (e.g., initiated by a frame render command). In most cases, the render buffer is redrawn in full each frame, although this need not be the case\u2014for example, if the application does not clear the render buffers, then the results of a previous frame can remain in the buffers, e.g., for further modification in the next frame render.","Alternatively, or additionally, the displayed graphics commands may correspond to those called prior to the breakpoint (e.g., for one or more frames prior to the breakpoint). However, the graphics commands may span over any desired length of time, depending on how they were captured. For example, as discussed above, a measurement application may have captured graphics commands for any desired length of time during execution of the application up to the point in time of the breakpoint.","In one embodiment, the graphics commands may be displayed in a pane of the development environment executing on the host device. Additionally, individual ones of the graphics commands may be selectable by a user, e.g., to view other code or graphics data associated with the selected graphics commands, as discussed below. In one embodiment, a user may select a first graphics command that interests the user, e.g., to view more information about the state of the application or graphics framework at that point in time.","The graphics commands discussed above may be graphics commands along any portion of the graphics pipeline. For example, as discussed above regarding , the graphics application may include source code which uses certain graphics API calls. This source code may be compiled into CPU instructions which call functions of the graphics API. Accordingly, during execution of the application, certain graphics framework commands may be initiated or triggered in response to the CPU. The graphics framework may in turn use the graphics driver to initiate graphics instructions executed by the GPU of the target device. As used herein, \u201cgraphics commands\u201d may refer to any of the graphics functions or instructions that are outside of the application, e.g., those of the graphics framework, graphics driver, GPU, etc. In one specific embodiment, the graphics commands may refer to those of the graphics framework, which are initiated by the application. Note that these graphics commands are triggered by the application.","Additionally, in , source code corresponding to the CPU instructions which generated or triggered the one or more graphics commands may be displayed. For example, the source code of the application may be displayed in another pane of the GUI of the development environment. As discussed above, the user may select an individual graphics command. In response, the portion of the source code that initiated the graphics command may be visually indicated, e.g., in the development environment. For example, the graphics command may have been initiated (e.g., directly or indirectly) by a particular portion of the source code. Accordingly, the method may automatically determine the originating source code and highlight that portion of the source code, e.g., in response to user selection of the graphics command. Thus, a user may easily determine the originator of a particular graphics command, which may make the process of debugging the application substantially easier when a graphics glitch or issue is noticed by the user. Thus, instead of the user manually figuring out the initiating source code of the bug, the method may automatically identify the source code from the specified graphics command.","Note that the process may also operate in the reverse fashion. For example, the user may be able to select a portion of source code and the corresponding graphics commands may indicated, e.g., visually, in the development environment.","Further, in , graphics data corresponding to the graphics commands may also be displayed. For example, as discussed above, a first graphics command may be selected, e.g., by the user. Accordingly, graphics data that was displayed in response to the first graphics command or at the time of the first graphics command may be automatically displayed, e.g., within a portion of the development environment. For example, the displayed graphics data may correspond to what was shown on the target device's display. In some embodiments, the particular portion of the graphics data that was affected or modified by the graphics command may be visually highlighted within the graphics data.","Similar to embodiments discussed above, the process may operate in the reverse fashion for the graphics data. For example, a user may select a portion or object of the graphics data and the graphics command(s) and\/or source code which resulted in that portion may be visually indicated, e.g., highlighted. In one embodiment, the user may be able to view a sequence of graphics data corresponding to the changes implemented by each graphics command performed during the period of time (e.g., the last data frame or the portion of time where the information was gathered), e.g., \u201cscrubbing\u201d through the sequence of modifications to the graphic based on the graphics commands. Accordingly, the user may stop the graphics data at a particular point in time and view the graphics commands and\/or source code associated with that graphics data\/point in time.","Thus, in one embodiment, a user may select one of the graphics commands, and the corresponding source code which caused the graphics command may be displayed. Additionally, the corresponding graphics of the graphics command may also be displayed. Thus, a user may be able to view the inter-related source code, graphics command, and\/or graphics data. More specifically, the user may be able to view the source code and\/or graphics data associated with a graphics command executed proximate to (e.g., within a frame) the breakpoint. These debugging actions may be performed in conjunction with a debug application executing on the target device (e.g., acting to provide saved information interactively or simply at the beginning of the debugging).","In one embodiment, the debug application may provide the ability to replay the graphics commands, e.g., that occurred proximate to the breakpoint, and provide that information to the host device. For example, render data or information stored in a buffer may be necessary to display graphics data corresponding to a graphics command. Accordingly, the host device may request the render data and the target device may execute one or more graphics commands to generate or retrieve the render data and supply it back to the host. For example, the target device may replay the frame (e.g., the set of graphics commands) up to and including the point of the requested data to calculate the state at that point. Other types of data and queries and responses between the host and target devices are envisioned. Thus, in some embodiments, rather than providing all of the necessary debugging information upon reaching the breakpoint and\/or suspending the application, the host device and target device may iteratively request and provide information (respectively) during the debugging process.","After debugging is completed, e.g., after a user ends the debugging or requests that the application resume execution, the target device may resume execution of the application, e.g., by loading the saved state and continuing execution of the application, as discussed in more detail below regarding . However, in further embodiments, execution of the application may be stopped or closed upon reaching the breakpoint rather than suspended. Additionally, the application may be re-executed rather than resumed. Thus, the suspension of the application and resumption of the application may not be necessary\u2014other embodiments are envisioned.",{"@attributes":{"id":"h-0013","num":"0000"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 6","FIG. 6","FIG. 6","FIG. 5"]},"In , an application may be executed on the target device, e.g., similar to  described above.","In , a breakpoint may be detected, e.g., as discussed above in .","In , information related to the application may be captured automatically, and in , execution of the application may be suspended automatically. For example, the current state of the application may be saved for later resumption. In some embodiments, the state information and\/or other information that may be used for later resumption may be stored in non-volatile memory (e.g., the target device's long term storage device) and\/or volatile memory (e.g., RAM), as desired. Note that the capturing of state information may be related to any portion of the target device, e.g., within the graphics pipeline, such as the application, the graphics framework, the graphics driver, the GPU, the CPU, etc.","In one embodiment, in addition to capturing state information, various portions of the target device may be locked in order to suspend execution of the application. For example, the graphics framework may be locked using a framework command to suspend the current state of the graphics framework. This locking may apply to various subsystems within the target application, e.g., without affecting other processor or applications executing on the target device. For example, in this particular example, access to the graphics framework may be locked for the target application only, not for every process or application of the target device. In one embodiment, the locking may be performed to allow for orderly suspension and\/or resumption of the target application. More precisely, debugging commands or operations may or may not be executed before or after suspension on one or more subsystems (e.g., the graphics framework). These commands or operations may or may not require exclusive access, within the target application, to the subsystem they affect. In one embodiment, locking may be necessary because execution of these commands or operations need to occur within the execution context of the application. Similar embodiments apply to other portions of the target device, either in software or hardware.","In , a debugging application may be executed by the target device. The debugging application may be configured to provide information to the host device to perform debugging. Similar to embodiments discussed above, this debugging information may be provided initially, e.g., upon suspension of the application, or in an iterative manner, e.g., numerous times, in response to requests from the host device. For example, as discussed above, the initial information may indicate the set of graphics commands executed in the graphics frame proximate to the breakpoint, although other periods of times are envisioned (e.g., prior to the breakpoint). The additional information could include requested data from a render buffer, which may require re-execution of some of the graphics commands by the target device to determine the current state of the render buffer. Said another way, the re-execution of the graphics commands may restore the state of the requested render buffer to a point in time (e.g., location in the captured sequence of graphics commands) specified in the requests, such that the resulting state of the render buffer may be obtained from the target device and provided to the host device. Accordingly, that data may be automatically determined and provided to the host device in response to the request.","In some embodiments, the debugging application may be distributed among multiple applications or software components. For example, functionality of the debugging application may be split among a measurement or capture application that may be executed concurrently with or even within the application of  and\/or a playback application executed after suspension of the application of . For example, the initial debugging information may be captured in addition to the state data at the point in time of  above. In one embodiment, a measurement application (or even the application itself) may gather the initial debugging information provided to the host device, such as the set of graphics commands executed prior to or after the breakpoint (e.g., corresponding to the graphics frame immediately after to the breakpoint). For example, this measurement application may intercept graphics commands resulting from execution of the application, which may be used for later playback, e.g., in a bitstream format. In some embodiments, this measurement application may be executed to capture this information for as long or as short a period as desired (e.g., the measurement application could capture the information throughout execution of the application, such as when a debugging option has been invoked). The measurement application could even be compiled into the application when requested.","Accordingly, this initial debugging information may also allow a playback application to re-execute the graphics commands in order to reproduce the data within the captured time period. More specifically, the debugging application in  may be used to re-execute graphics commands (or generally re-enact execution of the graphics framework) during the captured period of time, such as the graphics frame immediate after the breakpoint. This re-execution may be necessary in order to provide necessary debugging information to the host device during the debugging process.","Accordingly, in , debugging information related to the application may be provided to the host device, e.g., at a single time, such as initially, or multiple times in an iterative fashion.","Note that the specific order of , , , and  may be performed in a different order, as desired. For example, the initial debugging information may be gathered before the application is suspended. In another embodiment, the state data may be gathered after the application is suspended. Thus, any of a variety of feasible orders may be used for -. Similar remarks generally apply to any of the method elements described herein.","In , execution of the application may be resumed, e.g., after debugging has been performed. For example, a user may request that the target device resume execution of the application by providing input to the host device. Accordingly, the host device may provide a command to the target device to resume execution of the application. Resumption of execution may be performed by reloading the state data saved in , unlocking portions of the target device with respect to the application (e.g., as discussed above such as regarding the graphics framework), ceasing execution of the debugging application, etc. Accordingly, the application may resume execution at the point of suspension, proximate to the point that the breakpoint was reached (e.g., the frame after the breakpoint was reached) thereby providing a smoother debugging experience for the developer.","In one embodiment, the process of suspending the application, performing debugging (e.g., using a debugging application executing on the target device, e.g., in conjunction with the development environment executing on the host device), and resuming the application may be performed in a seamless manner, e.g., which is transparent to the user. For example, the user may not be aware that the application is suspended, that a new debugging application was launched, that the debugging application was ended, and the application was resumed in the debugging process.","Note that the methods described above may be used for purposes other than or in addition to debugging, as desired. For example, various other testing that may require or benefit from suspension of execution of an application may be performed using the above-described methods. Thus, the methods described herein are not limited to only performing debugging.","Specific Embodiment Related to the Method of ","The following describes one specific embodiment related to the method of . This embodiment is provided as an example only, and is not intended to limit the scope of the systems and methods described herein.","Upon reaching a breakpoint, debugging information may be captured from the executing application. When the capture session finishes, and a \u201csuspend after capture\u201d option has been enabled (e.g., at the time the capture session was initiated), code injected in the inferior, i.e., the application being debugged, may engage a global graphics framework (e.g., OpenGL) lock to prevent any progress in the graphics subsystem, and may then suspend the inferior using kernel functionality, such as APIs. This process may ensure that the application is suspended as soon as the graphics framework capture finishes, thus minimizing the latency (and any change in the state of the program) between the end of the capture and suspension of the application.","Accordingly, a debugging application (e.g., a playback application) may be launched, and the inferior may be placed in the background. This operation may only be a visual operation at that point since the inferior has already been suspended. The debugging application may provide debugging information to the host device initially and\/or multiple times to assist in performing debugging, as discussed herein.","When the developer is done debugging the frame and desires resumption of execution of the application (e.g., by selecting \u201ccontinue\u201d), the frame debugger may notify a monitoring process running on the target device. The notification may request to resume the inferior process (e.g., using kernel functionality) and bring the inferior process back to the foreground (e.g., using OS SPIs). When the process resumes execution, the code injected in the inferior may unlock the global graphics framework lock to allow forward progress in the graphics subsystem. Under memory pressure, the target device may be free to page out read-only code and data pages. They may be reloaded from memory when next accessed.",{"@attributes":{"id":"h-0015","num":"0000"},"figref":["FIGS. 7A-9C","FIG. 5"]},{"@attributes":{"id":"p-0090","num":"0089"},"figref":["FIGS. 7A-9C","FIGS. 5 and 6"]},"As shown in , multiple graphics commands within a frame are shown in the tree structure on the left hand side of the GUI. This portion of the GUI is shown in larger form in . In this particular case, the graphics command \u201c1341 glDrawElement(GL_TRIANGLES, 21006, GL_ . . . \u201d is selected. Correspondingly, on the right hand side, shown in more detail in , the source code which called the graphics command is shown. Additionally, in the middle portion, shown in more detail in , the present graphic corresponding to the graphics command is displayed. Further, the object being modified by the graphics command is highlighted within the graphic. Said another way, the center panel shows the state of the frame buffer at that point in the frame with the geometry for the current draw call highlighted by a wire frame. Other panels show other diagnostic information related to the application.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 8A","FIG. 7A","FIG. 8B"]},"Finally, in , a specific point in the CPU call stack is selected (\u201c0-[Renderer renderStructureWithGroupSetup:]\u201d), shown in more detail in . In response, the center panel of the GUI has changed to the source code corresponding to that element, which is shown in more detail in . In this particular example, it is the same command highlighted in  in the right hand panels, shown in more detail in .","In one embodiment, the GUI shown in  may be used in the following manner, which is described in relation to the GUI shown in . The user may step throughout the graphics commands in the frame, e.g., by selecting them in the navigator window on the left, the hierarchy control on the top, or the frame-scrubber control in the debug bar (above the bottom windows). At the current command, the user may be shown the state of the graphics framework (e.g., the OpenGL in this case) at that point with the current contents of the current render-target front and center. In the window to the right, current objects (e.g., resources) that are currently bound may be shown, and below that, the line of source code corresponding to the graphics command. In the windows at the bottom, the full list of all the graphics framework (e.g., OpenGL) state may be shown in detail.","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present embodiments can be obtained when the following detailed description of the preferred embodiment is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 1A-1E"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 4A-B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIGS. 7A-9C","FIGS. 5 and 6"]}]},"DETDESC":[{},{}]}
