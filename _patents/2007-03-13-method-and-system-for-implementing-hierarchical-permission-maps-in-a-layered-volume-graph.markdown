---
title: Method and system for implementing hierarchical permission maps in a layered volume graph
abstract: The invention is for a method of mapping hierarchical volume permission to top level permissions in a layered volume graph of a virtual data storage system with hierarchy of storage volumes requiring permission at every volume level and the top level volume exposed to the hosts via intelligent switches comprising: applying volume level permissions on a volume of the volume graph and mapping condensed permission hierarchically for the entire volume graph to the top level volume from said individual volume level permission.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07849281&OS=07849281&RS=07849281
owner: EMC Corporation
number: 07849281
owner_city: Hopkinton
owner_country: US
publication_date: 20070313
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present application claims the priority to India Patent Application No. 298\/KOL\/2006, filed on Apr. 3, 2006, entitled METHOD AND SYSTEM FOR IMPLEMENTING HIERARCHICAL PERMISSION MAPS IN A LAYERED VOLUME GRAPH, the contents and teachings of which are hereby incorporated by reference in their entirety.","The present invention relates to a system having a hierarchy of storage volumes requiring permissions at every volume level, and more particularly to a mechanism of mapping hierarchical volume permissions to top level permissions in a volume graph structure supported by intelligent multi-protocol switches.","Storage virtualization or just \u201cvirtualization\u201d is defined as the process of taking many different physical storage networks and devices, and making them appear as one \u201cvirtual\u201d entity for purposes of management and administration. The view of the storage device structure may not correspond to the actual physical storage system (hence, \u201cvirtual\u201d). Virtualization using intelligent multi-protocol switches separates host commands into Slow Path and Fast Path. Slow Path commands consist of all Non-READ\/Non-WRITE Small Computer System Interface (\u201cSCSI\u201d) commands in an input-output (IO) stream, viz. INQUIRY, READ CAPACITY, TEST UNIT READY, etc.; whereas all READ\/WRITE SCSI commands qualify as Fast Path commands. All Slow Path commands can be faulted back to the Storage Application and appropriate response can be generated. Fast Path commands on the other hand directly go the back-end.","Storage Applications may rely on \u201cvolumes\u201d of data. These are \u201clogical volumes\u201d or \u201clogical objects\u201d. In order for many Storage Applications to work in tandem (e.g. Mirroring a Snapshot), volumes must be organized as a hierarchical graph structure where each Storage Application \u201cowns\u201d a layer in the graph. Since each Storage Application should be able to work independently of each other, every Storage Applications can apply individual permissions on the volumes it owns.","In Switch based virtualization, the permissions applied on various volume levels, need to be applied at the switch ports where IOs can either be faulted or let through based on the permissions. Switch vendors provide an application programming interface (API) to allow storage applications to set permissions, whereby Storage Applications put volume permissions to control the behavior of Fast Path commands. The permissions determine whether Fast Path IO will get faulted back to the Storage Application, will be held at the switch port or will be allowed. Examples of Storage Applications can be Clones, Data Mobility, Snapshot, etc.","Storage area network (SAN) with controlled access to the hosts connected to the network is well known in the art. \u201cHost computers\u201d can be any type of computers, for application processing, operating systems and data management applications. The host computers may be connected over a network. This network may include switching nodes, although any other form of network may be used. There are number of granted patents in the field that discloses methods for storage virtualization, access control, handling of overlapping requests and mapping of permission for different hosts in the control memory block. Some of these prior art patents in the field are briefly described below.","U.S. Pat. No. 6,993,589 discloses a method and apparatus for providing secure access to a computer system resource. The computer system includes a plurality of logical volumes of data that are visible to a host computer and a storage system. In accordance with one aspect of the invention, a request, from a requester having less than system administrator access privileges, to perform an action directly on the one of the plurality of raw storage devices is granted, so that a logical channel is provided for the direct access without the said logical channel being mapped by a file system\/LVM mapping layer contained in the host computer. According to another aspect, a plurality of volumes of storage are visible to the application layer, and access privileges less than the root access privileges are assigned to the at least one application program to access the plurality of volumes of storage.","Another approach for managing access to a plurality of storage resources in a computer system has been described in U.S. Pat. No. 6,993,581. In one aspect, requests to access one of the plurality of storage resources from the application layer are intercepted, and at least one of the interests is modified in a manner that will impact the access facility in determining whether the requestor satisfies the privilege level to be granted access to the one of the plurality of storage resources.","Yet another approach has been taken in the US 2004 0098424 A1, wherein metadata that relates logical block addresses of data used by a file system with the physical block addresses at which the data is stored is maintained in nodes that are arranged into a hierarchical volume map tree that extends from a root node to a plurality of leaf nodes. A method and apparatus is described for efficiently copying distributed data files. A copy of the volume map tree root node is maintained in a covolume and the modifications to that volume map tree copy is maintained as a new covolume by creating a new delta.","U.S. Pat. No. 6,535,891 discloses a technique for identifying accesses to a repository of logical objects stored on a storage system based upon information identifying accesses to physical storage locations. The repository is mapped from application space to physical space to create mapping information identifying which units of storage in physical space store the repository, and the mapping information is made visible to the application space. An incremental operation is executed on the repository of logical objects. A further aspect is directed to a storage system that identifies to the host accesses to a repository of logical objects based upon accesses to corresponding units of storage in physical space.","Further, a technique for host volume mapping for shared storage volumes in a multi-host computing environment has been disclosed in WIPO Publication No. WO 01\/20470 A1. The method for controlling access to a shared storage device includes the steps of associating a locally unique identifier with each of the plurality of computers, defining a data structure in a memory identifying which particular ones of the computers based on the locally unique identifier may be granted access to the device; and querying the data structure to determine if a requesting one of the computers should be granted access to the device.","Furthermore, U.S. Pat. No. 6,842,843 discloses a digital data storage subsystem including arrangement for increasing cache memory addressability. A memory access request receiver module of a memory manager is configured to receive an access request requesting an access operation in connection with the memory, the access request including an address. A memory access operation control module of a memory manager is configured to perform an access operation in connection with the memory using an absolute address generated by an address translation module. The address in an access request includes a segment identifier and an offset, the address translation module being configured to process the segment identifier and offset to generate an absolute address identifying at least one storage location.","Another approach for storage mapping and partitioning among multiple host processors has been described in U.S. Pat. No. 6,799,255. A storage controller for controlling access to data storage has a memory and at least one data port for a data network including host processors. When the storage controller receives a data access request from a host processor, it decodes a host identifier from the data access request, and searches the memory for a host identifier matching the host identifier decoded from the request. Upon finding a match, the respective specification of the respective subset for the host processor is accessed to determine whether or not storage specified by the storage access request is contained in the respective subset. If so, then storage access can continue, and otherwise, storage access is denied.","However, current limitation in switch implementation is that they do not support hierarchical volume permissions, that is, the multi-protocol intelligent switches do not support permissions which are applied at various individual volume levels in a volume graph. On the contrary, they require the permissions to be applied only at the top level volume of the graph which is exposed to the host via the intelligent port. Therefore, the challenge is to create a mapping mechanism which can convert permissions at an individual volume level to be translated and applied at the top level. This kind of layered permissions is called a hierarchical permission map. Thus, in order to make hierarchical Storage Applications, e.g. data mobility or a cloned volume, there is a need for a mechanism to map hierarchical permissions to top level permissions, supported by the switches. The present invention aims to solve this technical problem for a storage area network (SAN).","The invention deals with development of an algorithm to allow maintenance of hierarchical permission maps and the ability to condense the permissions by \u201cORing\u201d the permissions hierarchically, into a combined, condensed and cumulative permission map, which can be applied on the switches at the top level volume. The invention also allows for maintaining the hierarchical permission semantics and at the same time, applying cumulative permissions on the switch. Apart from these to and fro mappings, said algorithm provides condensation of the permission map by reducing redundancy and merging adjacent regions having same permissions.","Accordingly, the present invention provides a method of mapping hierarchical volume permissions to top level volume permissions in a layered volume graph structure of a virtualized data storage system having a hierarchy of storage volumes requiring permissions (or access control) at every volume level, wherein said top level volume is exposed to the host via intelligent multi-protocol switch(es), said method comprising the steps of applying volume permissions on a volume within said volume graph structure; and mapping condensed permissions hierarchically for the said entire volume graph structure to the top level volume from said individual volume permission.","The present invention also provides a system for implementing hierarchical permission maps in a layered volume graph structure of a virtualized data storage volume having a hierarchy of storage volumes requiring permissions (or access control) at every volume level, said system comprising:","Intelligent multi-protocol switch(es) between host server(s) and virtualized data storage volume, said switch(es) being adapted to read the hierarchical volume permission set at the top most level of said volume graph structure;","means for storage virtualization;","means for applying volume permissions on a volume within said volume graph structure and","means for condensing permissions from the individual volume levels to the top most volume level of said volume graph structure hierarchically for the entire volume graph structure for access control through said intelligent switch(es).","The present invention further provides a storage area network connected to a plurality of host computers, wherein the storage is a virtual storage with a hierarchical volume structure and the storage application is adapted to set permission for individual volumes in the volume graph and also map the hierarchical top level volume permission by condensing, combining and accumulating individual volume level permissions to the top level volume in the hierarchy comprising:","at least one physical storage device configured to virtual storage volumes with a hierarchical structure;","a plurality of host computers connected to the virtual storage volumes through multi-protocol intelligent switch(es);","a controller device, being a generic computing device that runs the applications for storage virtualization, for applying individual volume level permissions and for mapping the hierarchical permissions to the top most level of the volume graph by combining, condensing and accumulating the individual volume level permissions to the top most level,\n\nwherein said application for mapping the top most level hierarchical permission initially sets ALLOW permission as the default permission for the entire region of the top most level volume in the hierarchy and then rolls up the individual volume level permissions to the top level volume whenever interrupted by a negative or hold permission in the corresponding region of next or subsequent child volume in the hierarchy;\n\na communication channel between the host computer(s) and virtual volumes through said intelligent switch(es) wherein all I\/Os from the hosts are broken into fast path or slow path and depending on the volume permission as read by the switch from the mapped top level hierarchical permission the fast path I\/O is faulted back to the storage application or allowed access to the respective physical storage as per the mapping module while generating appropriate message for the host when the access is denied or kept on hold and\n\na table comprising the permission map with rolled up permission of all individual volume level permission to the top most level of the hierarchical volume graph, wherein said table is embedded in a memory of said controller device to allow, hold or deny access to the host requesting the permission.\n","The present invention further provides a computer-operable program implementing the inventive method. In this connection, there is provided a computer program product comprising a computer readable storage medium having a computer program embedded therein, said program being adapted to map the volume level permission at the individual volumes to top level volume permission in a hierarchical volume graph of a virtual storage by rolling up the respective volume level permission to the top most level of the hierarchical volume graph, wherein the permission applied to a corresponding region of a parent volume always gets precedence over the permission applied on the same region of child in the hierarchy.","The present invention provides these and other advantages as will be apparent to those having ordinary skill in the art upon reading of the following detailed description of the invention with reference to the accompanying drawings as briefly described below.","For purposes of the specification and claims, a \u201cvolume\u201d, as illustrated in , also called a Logical Unit (LU), represents a virtual contiguous storage space. It refers to a logical entity and may map to a physical disk or another volume, that is, it generally corresponds to a logical abstraction of physical storage. Regions in a volume are addressed by using the logical block address (LBA). LBA for a volume starts from 0 and ends at the maximum capacity of the volume. Volumes can be stacked and layered above one another forming a hierarchical graph structure. The top level root volume of the graph represents the entire graph range. Typically, IOs flow from top level root volume down the graph and take various paths depending on the IO range (offset, length).","A brief definition of the various terms that are used in the description is given below in order to facilitate understanding of the present invention. The invention is illustrated with reference to the properties of a volume, which include its type, capacity and the permission map it contains. There can be various types of volumes like slice, concat, stripe, simple and mirrored. , and give examples of how volumes can be constructed.","Slice Volume","A slice volume, as shown in , represents a subset of an existing volume on which it is created. Its attributes are the offset into the original child volume (LBA) and its capacity (Length). The length of the Slice Volume V in , is just taken as an example. The Client application which creates the Slice Volume decides on the length.\n\nConcat Volume\n\nA concat volume, as shown in , represents an aggregate of an existing set of volumes. The capacity of the concat volume is the sum of the capacities of its child volumes. The address space of the new concat volume is a serial join of the address spaces of the child volumes.\n\nMirror Volume\n\nA mirror volume, as shown in , represents a volume where every IO is replicated over all its children, i.e. Mirrored. The capacity of the mirror volume is same as each of its child, and all child volumes of a mirror have identical capacities.\n\nVolume Graph\n\nAs mentioned hereinbefore, a volume is a logical entity and can be constructed in various ways using other volumes. Similarly, volumes of various types (slice, concat, mirror) can be combined to form a more complex structure called a volume graph.  shows an exemplary layout of volumes configured with a hierarchical architecture. This is called layered Volume Graph, and is also known as Hierarchical Volume Graph. Here a concat volume has been constructed out of three mirror volumes. As can be seen in the diagram, a volume graph can be viewed as a hierarchy of volumes.\n\nVolume Permissions\n\nAs IO is done on a volume, it can be thought of being passed top-down through the volume graph. For example if IO is done on volume V in , it will pass down the graph via V and either V, V or V, depending on the LBA range on which the IO was done and its mapping in the child volumes. At every volume, certain permissions can be applied which can control the action which ought to be taken in the event of an IO happening on a certain LBA range within that volume.\n\nPermissions can be Either:\n\nFAULT_ON_READ: Any READ IO on the specified range will result in the IO being faulted back to the storage application.\n\nFAULT_ON_WRITE: Any WRITE IO on the specified range will result in the IO being faulted back to the storage application.\n\nALLOW_IO: Allow both READ and WRITE to proceed on the specified range.\n\nHOLD_IO: Hold all IO until the permission is changed.\n\nA permission consists of the permission attributes (FAULT_ON_READ, FAULT_ON_WRITE, ALLOW_IO, HOLD_IO) and the region (offset, length) in the corresponding volume affected thereby. These permissions can be applied on an LBA range within a volume. At any point in time, there can be multiple permissions on a volume on different LBA ranges, as shown in . In this example, if an IO happens in the LBA range 0 to 1000, all READ operations will get faulted back to the storage application. Further, if an IO happens in the LBA range offset: 1000 Length: 2000, both the READ and WRITE operations will be continued. Furthermore, if an IO happens in the LBA range offset: 3000 Length: 1000, all WRITE operations will get faulted back to the storage application. In a volume graph, permissions could be independently applied at any volume level.\n\nVolume Extent\n\nA volume extent is defined as a region in a volume. It is represented by the (offset, length) tuple where offset is zero based from the start of the volume, and length represents the size of the region. The basic unit of offset and length is blocks. Typically, an entire volume range can be broken down into a list of contiguous extents.\n\nPermission Mask\n\nA permission mask enumerates the various permissions that have been applied to a volume extent. In the algorithm, this mask is represented as an enum:\n",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"enum VolumePermissionMask {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ALLOW,"]},{"entry":[{},"FAULT,"]},{"entry":[{},"HOLD"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"struct VolumePermissionMapEntry {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"uint32_t\u2003\u2003\u2003\u2003offset ;","\/\/ Region Offset"]},{"entry":[{},"uint32_t\u2003\u2003\u2003\u2003length ;","\u2003\u2003\/\/ Region Length"]},{"entry":[{},"VolumePermissionMask readPermission ;","\/\/ Fault\/Allow\/Hold on"]},{"entry":[{},{},"Read"]},{"entry":[{},"VolumePermissionMask writePermission ;","\/\/ Fault\/Allow\/Hold on"]},{"entry":[{},{},"Write"]},{"entry":[{},"struct permissionRefCount {"]},{"entry":[{},"\u2003\u2003uint32_t holdCount ;","\/\/ hold count"]},{"entry":[{},"\u2003\u2003uint32_t readFaultCount ;","\/\/ read fault count"]},{"entry":[{},"\u2003\u2003uint32_t writeFaultCount ;","\/\/ write fault count"]},{"entry":[{},"} ;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{},{}]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5"},"A volume graph can consists of heterogeneous volume types (concat, slice, mirrored etc.). Since the volumes are stacked hierarchically over each other, there is a parent-child relationship already established. To attain the objective of the present invention, every volume type is expected to provide functionality for two basic models:","(A) mapRegionInChild","This method allows a region in a parent volume to be mapped into corresponding regions in the child volume(s). A volume graph can consist of heterogeneous volume types (concat, simple, mirror) and each volume type will have a different algorithm for mapping regions in its child volumes. It may be assumed that such a mapping function is available for every type of volume. In object oriented terminology, this is assumed to be a polymorphic method available in the generic volume class.","The behavior of the function for different kinds of parent volume types (and in particular for Slice and Concat volume types) is explained below:",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 6","i":["a ","b "],"b":"6"},"mapRegionInChild for a Slice Volume","In this case, there is only one child volume possible and the region in the parent volume gets offseted by the ChildOffset, as shown by the example illustrated in ","mapRegionInChild for a Concat Volume","A concat is made up of many child volumes and a region in a concat volume can map into more than one child volumes depending on the range, as shown by the example illustrated in ","The expected output of the function mapRegionInChild is a list, each element of which contains the tuple (ChildVolume, Mapped LBA range), as depicted in aforesaid and ","(B) mapChildRegion","This method works the other way from mapRegionInChild. It allows a region in a child volume to be mapped to the corresponding region in the parent volume. A volume graph can consist of heterogeneous volume types (concat, slice, mirror etc.) and each volume will have a different algorithm for mapping child regions in its corresponding parent volumes. It may be assumed that such a mapping function is available for every type of volume.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIGS. 7","i":["a ","b "],"b":"7"},"mapChildRegion for a Slice Volume","A region in a child volume with a Slice volume as its parent just maps the LBA range directly with adjustment done for the ChildOffset, as shown by the example illustrated in ","mapChildRegion for a Concat Volume","A region in a child volume with Concat volume as its parent, maps in the corresponding area in the parent volume which the said child volume represents, as shown by the example illustrated in ","The expected output of the function mapChildRegion is the tuple containing the parent volume and the mapped region in the parent volume.","Apart from the above described two main methods, each volume object is adapted to maintain a local permission map, which represents the permissions applied at that volume.","The calculation of cumulative permissions, according to the present invention, is depicted in . The calculation is based upon the concept of condensing or \u201cORing\u201d of permissions. Permissions can be applied by storage applications at any level in the hierarchy. More than one permission can be applied on a given volume resulting in a permission map for that volume. This map can dynamically change as per the current permission settings. To attain the objective of the present invention, this map is required to be applied on the switches, for which it needs to be condensed into a single map for the entire volume graph.","The example depicted in  shows a typical hierarchical permission map, where individual volumes (V and V) have permissions set on certain regions and the effective condensed permission map is calculated for the entire graph at the top level volume (TLV).","A permission of FAULT_ON_READ has been applied on the volume V of the layered volume graph, on the LBA range offset: 100 Length: 50, whereas another permission FAULT_ON_WRITE has been applied on the volume V, on the LBA range offset: 300 and Length: 30.","The calculation of cumulative permissions on the top level volume (V) is started from the lower most volume (leaves of the graph), working the way upwards. The regions in the leaves are mapped to the corresponding regions in parent volumes and so on till the top level volume is reached. In the event of any permission being found set for a region on the way, a note of it is made. If the corresponding region in the parent volume has a different permission set, then the permissions of the parent take precedence. In the event of the mapped regions in the parent being set to ALLOW_IO, the corresponding child permissions are continued, that is promoted. This process continues till all the regions in the leaves are mapped and effective permissions calculated.","Applying this method to the hierarchical volume graph in , permission FAULT_ON_READ on child volume V (LBA range offset: 100, Length: 50) maps to the corresponding region offset: 300, Length: 50 in its parent volume V. Since, the corresponding region in the parent volume V already has a permission FAULT_ON_WRITE set on the LBA range offset: 300, Length: 30, applying the aforesaid logic of precedence, parent permission for the length of 30 blocks is maintained and child volume permission is promoted for the rest of the parent length i.e. for 20 blocks. Accordingly, effective permissions at volume V stand as shown in . Continuing this logic throughout the hierarchical volume graph leads to the final cumulative permissions for the top level volume(TLV) V, which is the effective Top Level Volume Permissions as shown in the diagram of .","The size of the various volumes in the hierarchical volume graph may be suitably modified to meet the needs of a particular computer implementation.","The mechanism of mapping hierarchical volume permissions to top level permissions in a volume graph structure and the application of cumulative permissions on the intelligent multi-protocol switch, according to the present invention, involves two main sub-steps:","Applying the permission locally on a volume.","Calculating the condensed permissions hierarchically for the entire volume graph.","Applying Volume Permissions on a Volume","Each volume maintains a local permission map which contains the permissions applied on that volume. Said local permission map is maintained as a list of permission map entries. Each of the permissions is reference counted in order to allow the same permissions to be set by multiple clients. In order to reduce the complexity and the number of entries in the volume permission map, the algorithm provides for condensation of the permission map by reducing redundancy and applies merge logic which combines adjacent extents in a volume if they happen to have similar permissions. The merge logic is explained hereinafter.","When a request to apply new permissions is received, the algorithm works by calculating the existing regions in the volume which get affected.  shows how a permission map for a volume changes as and when various permissions are applied to the volume. The previous permissions are overwritten with newly modified permissions.","Local volume permission maps get modified in the following manner:\n\nOld Permission Map+New Permissions=New Permission Map\n\nCalculating Condensed Permissions\n","Once the local volume permission map has been applied, it needs to be rolled up to the top level volume or the root of the volume graph for calculating the effective permission for the entire graph. For every region in the root volume which has permission set to ALLOW, the corresponding region is mapped into its child volumes, using the mapRegionInChild method. If the corresponding child regions have non ALLOW permissions, those permissions are rolled up to the root level. In case the corresponding region in child is also set to ALLOW, then the process continues to the next child level. It continues until either all root ALLOW regions have been filled up by rolling child permissions or we have reached the end of the graph. If the end of the graph is reached, the corresponding root region gets set to ALLOW.","The basic idea underlying this technique is that ALLOW is considered as a hole and whenever there is a hole detected, all child permissions in the volume graph are explored to ascertain whether permissions from a lower level can be promoted to fill the hole. The default permission being ALLOW, which is the least restrictive in nature, is applied at the top level of the graph, and the entire graph is explored from the top through down the graph looking for more restrictive ones.","At any volume level, if adjacent regions of a volume have similar permissions, then it can be thought of as though the same permissions were applied to the combined region. This facilitates in merging of the adjacent regions into a single region with a bigger size, hence reducing the number of permission entries in a permission map. Consequentially, the size of the permission map is reduced. The technique of merging adjacent regions of a Volume Permission Map, according to the present invention, is shown in .","In the process of mapping condensed permissions to the top level volume, an appropriate message is generated for a host trying to access a volume extent with FAULT_ON_READ or FAULT_ON_WRITE or HOLD_IO permission.","Pseudo Code","There is no restriction on programming language for implementing the algorithm. The various methods, according to the present invention, may be implemented in any programming language (like \u201cC\u201d, \u201cC++\u201d or \u201cJava\u201d). For purpose of illustration only, the pseudo code is represented here in a C++ style of coding. For the purpose of the algorithm, a volume is represented as a class containing the above methods.  shows Class Diagram of Volume in accordance with the present invention.",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003typedef ListOf <VolumePermissionMapEntry> VolumePermission"},{"entry":"\u2003Map ;"},{"entry":"Class Volume"},{"entry":"{"},{"entry":"\u2003public :"},{"entry":"\u2003\u2003UpdateLocalPermissionMap(VolumePermissionMapEntry*"},{"entry":"\u2003\u2003mapEntry) ;"},{"entry":"\u2003\u2003CondensePermissions (VolumePermissionMapEntry* mapEntry,"},{"entry":"\u2003\u2003\u2003\u2003\u2003VolumePermissionMap* condensedPermissionMap) ;"},{"entry":"\u2003private :"},{"entry":"\u2003\u2003VolumePermissionMap volumeMap ;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In considering the specific manner in which the invention operates, the two main sub-steps involved in carrying out the methodology of the invention are as follows:","The method UpdateLocalPermissionMap updates the local permission map of a volume. It basically works by calculating existing map entries which will get affected and then overwriting the new permissions. If the new region intersects any old map entry regions, the old regions are split.","The method CondensePermissions condenses the permissions for a region specified by mapEntry argument. It traverses down the graph to every child volume until permissions for the entire mapEntry region are calculated or the end of the graph is hit.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIGS. 13","i":["a ","b "],"b":"13"},"Applying Volume Permissions (Permission locally on a volume)","To attain the objective of the present invention, at every volume level a method called \u2018update\u2019 needs to be implemented as follows:",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Volume: :UpdateLocalPermissionMap(VolumePermissionMapEntry*"},{"entry":"mapEntry)"},{"entry":"{"},{"entry":"\u2003for (every permissionMapEntry affected)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003if the mapEntry's read and write permissions are HOLD"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003node - >permissionRefCount.holdCount++"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003else if (mapEntry's read and write permissions are ALLOW &&"},{"entry":"\u2003\u2003\u2003\u2003node ->permissionRefCount.holdCount != 0)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003node - >permissionRefCount.holdCount\u2212\u2212"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (read permission of mapEntry is ALLOW)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003node - >permissionRefCount.readFaultCount\u2212\u2212"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else if (read permission of mapEntry is FAULT)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003node - >permissionRefCount.read FaultCount++"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003if (write permission of mapEntry is ALLOW)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003node - >permissionRefCount.writeFaultCount\u2212\u2212"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else if ( write permission of mapEntry is FAULT)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003node - >permissionRefCount. writeFaultCount++"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003if (node - >permissionRefCount.holdCount is non-zero"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Set node's read and write permissions to HOLD"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (node->permissionRefCount.readFaultCount is zero)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Set node's read permission to ALLOW"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Set node's read permission to FAULT"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003if (node->permissionRefCount.writeFaultCount is zero)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Set node's read permission to ALLOW"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Set node's write permission to FAULT"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003Merge the start and the end nodes calculated above with their adjacent"},{"entry":"nodes incase the\u2003\u2003permissions and reference counts match and"},{"entry":"modify the offset and length accordingly."},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"figref":"FIG. 13","i":"a","b":["1","2","3","4","5","6","7","8","9","10","11","12","13"]},"Based on the reference counts, new permissions are set. If HOLD reference count is a non zero value (block ), the node's READ and WRITE permissions are set to HOLD (block ). On the contrary, if READ FAULT reference count corresponds to zero (block ), then the node's READ permission is set to ALLOW (block ), otherwise it is set to FAULT (block ). Similarly, if WRITE FAULT reference count corresponds to zero (block ), then the node's WRITE permission is set to ALLOW (block ), otherwise it is set to FAULT (block ).","At this point there may be adjacent permission map entries in the map which might have similar permissions and reference counts. The method terminates at block  where the entries can be merged in order to create a compact map.","Calculating Condensed Permissions","The cumulative permissions for a mapEntry region are calculated, as illustrated in , starting from the top level volume going down to children until the permissions are no longer ALLOW or there are no more children.",{"@attributes":{"id":"p-0083","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Volume: :CondensePermissions(VolumePermissionMapEntry* mapEntry,"},{"entry":"\u2003\u2003\u2003\u2003\u2003VolumePermissionMap* condensedPermissionMap)"},{"entry":"{"},{"entry":"\u2003for (every mapNode from the start to end of the entries)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003if (mapEntry->readPermission != ALLOW)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003mapNode.readPermission = mapEntry->readPermission"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003if (mapEntry->writePermission != ALLOW)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003mapNode.writePermission = mapEntry->writePermission"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003if (this volume has children and any of the mapNode"},{"entry":"\u2003\u2003\u2003\u2003\u2003permissions(read or write) is ALLOW)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Map the mapNode in the child volumes and get the corresponding"},{"entry":"mappedRegion list."},{"entry":"\u2003\u2003\u2003for (each region in the mappedRegion list)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003region.readPermissions = mapNode.readPermission"},{"entry":"\u2003\u2003\u2003\u2003region.writePermissions = mapNode.writePermission"},{"entry":"\u2003\u2003\u2003\u2003child.CondensePermissions(&region,"},{"entry":"condensedPermissionMap)"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Get the mappedRegion list corresponding to this mapNode in the"},{"entry":"top level\u2003\u2003\u2003\u2003\u2003\u2003volume (volume where the process started)."},{"entry":"\u2003\u2003\u2003for (each region in the mappedRegion list)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003region.readPermissions = mapNode.readPermission"},{"entry":"\u2003\u2003\u2003\u2003region.writePermissions = mapNode.writePermission"},{"entry":"\u2003\u2003\u2003\u2003condensedPermissionMap->add(region)"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003Merge the start and the end nodes calculated above with their adjacent"},{"entry":"nodes incase the permissions and reference counts match and modify the"},{"entry":"offset and length accordingly."},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The method of calculating effective cumulative permissions starts at block a and continues, via block b, where in the event of mapEntry's READ permission being set to ALLOW, the READ permission of mapnode is taken to be equal to the mapEntry's READ permission (block c). On the contrary, if the mapEntry's WRITE permission is set to ALLOW (block d), then the WRITE permission of mapnode is taken to be equal to the map Entry's WRITE permission (block e).","If the volume has children and any of the mapNode's READ or WRITE permission is set to ALLOW (block f), then the parent region is passed to the child volume and the process of condensing of the region permissions is continued (blocks g, h and i), as a result of which, a list of corresponding mapped Region in the child volume is obtained. On the contrary, if the permissions are no longer ALLOW or the volume has no children, the region is mapped back to the top level volume (that is the volume where the process started) and added to the condensed Permission Map (blocks j, k and l).","At this point there may be adjacent permission map entries in the map which might have similar permissions and reference counts. The method terminates at block m where the entries can be merged in order to create a compact map.","This technique can be applied to any system having a hierarchy of objects requiring permissions (or access control) at every object level. The algorithm is generic in nature and can be used to calculate effective object graph permissions (or access control).","The present invention typically runs on a generic controller hardware which has connectivity to the intelligent switches.  illustrates an exemplary diagram of a system for implementing the present invention. The controller device resides in the network as shown in the diagram of . The storage area network (SAN) of the system, as illustrated in , is connected to a plurality of host computers (such as \u2018Host\u2019, \u2018Host\u2019, \u2018Host\u2019, etc.), and physical storage arrays (such as \u2018Storage \u2019, \u2018Storage \u2019, etc.). In a preferred embodiment, controller device and the applications running on the controller virtualize the physical storage into a virtual storage with a hierarchical volume graph structure and said storage application is also adapted to apply permission for individual volumes in the volume graph and for condensing, combining and accumulating individual volume level permissions to the top level volume so that intelligent switch(es) connected to the top level volume in the hierarchy may read the resultant top level hierarchical permission as set for access control.","As an alternative to above preferred embodiment, the application for storage virtualization, and\/or for applying permission at individual volume level and\/or for setting condensed, combined and accumulative hierarchical permission at the top most level may also run on the intelligent switch(es) instead of running on a separate controller device.","The number of storage devices, hosts and intelligent switches, as shown in , are just for the example. There is no theoretical limit on these numbers as such. The controller device could be any network device capable of running this algorithm with processing capability and network connectivity.","Each virtualized storage volume can be presented to a cluster of hosts. The permissions on the volume are not affected by the number of hosts connected to the volume, in as much as, it is the storage applications which set permissions. The storage applications run on the controller device. I\/O initiated by the hosts gets affected due to permissions placed on the volume. If permissions on a volume change, it affects I\/O from all hosts connected to it.","The host does not have direct access to the storage. All I\/O goes through the intelligent switch(es), where it gets broken into Fast Path or Slow Path.  shows how the I\/O issued by host is split into Fast Path and Slow path by the intelligent switch. Which physical storage device the I\/O finally lands on, is determined by the mapping logic running on the intelligent switch port. The volume permissions are controlled by the software running on the controller device or the intelligent switch(es) as the case may be. The volume permissions determine whether the Fast Path I\/O should get faulted back to the storage application or allowed to go to the physical storage as per the mapping rules.","While the invention has been described with particular reference to the illustrated embodiment, numerous modifications thereto may be apparent to those skilled in the art. Accordingly, the above description and accompanying drawings should only be taken as illustrative of the invention and not in a limiting sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 2","i":["a","b ","c "],"b":["2","2"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 6","i":["a ","b "],"b":"6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 7","i":["a ","b "],"b":"7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 13","FIG. 13"],"i":["a ","b "]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
