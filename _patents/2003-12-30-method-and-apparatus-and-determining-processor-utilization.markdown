---
title: Method and apparatus and determining processor utilization
abstract: A method and an apparatus for determining processor utilization have been disclosed. In one embodiment, the method includes determining processor utilization in a data processing system and synchronizing execution of a number of threads in the data processing system to prevent interrupting the determining of the processor utilization. Other embodiments have been claimed and described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07617488&OS=07617488&RS=07617488
owner: Intel Corporation
number: 07617488
owner_city: Santa Clara
owner_country: US
publication_date: 20031230
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["Embodiments of the invention relate generally to a processing core in a data processing system, and more particularly, to determining the processor utilization.","In many data processing or computer systems, various tasks or applications contend for processing time to execute on one or more processors, also referred to as central processing units (CPU), or similar processing devices. Activity in many highly multi-tasking environments tends to be bursty, having periods of latency or inactivity followed by periods of intense processing activity. Accordingly, it is useful to analyze the utilization of processors and other similar data processing system devices for a variety of reasons. For example, high processor utilization during periods in which few or no user tasks are scheduled may be indicative of a virus program or of some correctable fault in task scheduling resulting in thrashing or other inefficient system behavior.","In theory, processor utilization may be determined by accumulating processor idle time across a sampling interval to determine the percentage of time the processor is inactive. An operating system (OS) may maintain a list of ready-to-run threads or tasks. A thread in the current description refers to a distinct process executed on a processor, which may be a physical processor or a logical processor. When this ready-to-run list is empty, no task is executed and the processor is idle. Accordingly, a processor-independent timer is read and the processor is essentially deactivated. The processor may be put in a predefined processor power state, such as the C2 or C3 states defined by the well known Advanced Configuration and Power Interface Specification, Revision 2.0, Jul. 27, 2000 (ACPI).","In the C2 state, clock signals are removed from the functional units of the processor while the memory subsystem remains active and \u201csnoopable\u201d by other devices. In a C3 state, the clock signal is also removed from the memory subsystems and hence, a so-called \u201cdeep sleep\u201d state is entered. When a new task is added to the ready-to-run list, the processor is placed in an active state (such as the C0 ACPI state) and the timer is read again. The difference between the first and second timer reads multiplied by the timer's period represents the idle time of the processor. The accumulation of the idle time across a sampling interval can be used to determine the processor utilization. Unfortunately, this measure of processor utilization is difficult to calculate outside of the OS through a supported application programming interface (API) because the API is generally unaware of the ready-to-run list, which is typically known only to the OS.","An existing solution for the above problem is to use on-die performance counter hardware capable of counting clock ticks for which the processor is not in a low power state. The performance counter thus provides a measure of time the processor spent performing useful work. Software can then periodically sample a register of this performance counter, and calculate the processor utilization based on the following formulae:\n\nBusyTicks=Sum(across sampling interval)[CurrentTickCount\u2212InitialTickCount]\n\nEffectiveFrequency=BusyTicks\/Samplinglnterval(s)\n\nProcessor utilization(%)=EffectiveFrequency\/ActualFrequency*100%\n","However, the above technique does not apply satisfactorily to a system with simultaneous multi-threading (SMT) technology enabled (hereinafter, a SMT system) or a multi-processor system because of at least two issues, including the OS and the system interrupt mechanism.","Since the OS has multiple physical or logical processors in the multi-processor system or the SMT system, the OS scheduler can be executed on any one of the processors. The scheduler may preempt the thread that is calculating an effective frequency for determining the processor utilization in the middle of the frequency calculation. When the processor resumes execution of the thread, the sampling interval that the thread uses and the processor clock ticks may be out of sync, and thus, resulting in an incorrect frequency.","The second issue of the above technique involves the system interrupt mechanism, such as System Management Mode (SMM). SMM is a shared mode between all processors in a system. During SMM, the states of execution of all the processors are saved and the system enters SMM. When the system exits out of SMM, the state of the processors are restored and the execution resumes from where it was stopped. So, if the frequency calculating thread is executing on one processor and the other processor causes a switch to SMM, the frequency calculating thread is also halted and the system as a whole enters SMM. Upon exit from SMM, the frequency calculating thread is resumed as if nothing has happened. This could lead to an incorrect frequency calculation in determining the processor utilization.","A method and an apparatus for determining processor utilization and\/or effective frequency within a data processing system are disclosed. More particularly, in one embodiment, a method for determining processor utilization includes determining processor utilization in a data processing system and synchronizing execution of a number of threads in the data processing system to prevent interrupting the determining of the processor utilization.","Reference in this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment, nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover, various features are described which may be exhibited by some embodiments and not by others. Similarly, various requirements are described which may be requirements for some embodiments but not other embodiments.","In this description, various terms peculiar to nomenclature used by Intel Corporation of Santa Clara, Calif., will be used to describe signals and architectural components. The use of these terms is intended to be by way of example only and is thus non-limiting.","In the following detailed description, numerous specific details are set forth in order to provide a thorough understanding. However, it will be apparent to one of ordinary skill in the art that these specific details need not be used to practice some embodiments of the present invention. In other circumstances, well-known structures, materials, circuits, processes, and interfaces have not been shown or described in detail in order not to unnecessarily obscure the description.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 1","FIG. 1"],"b":["1010","1020","1030","1020","1040"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2","FIG. 2"]},"Referring now to , at block  and , Processors A and B are started or initialized. At , Processor B remains waiting until Processor A fires Wait Sync Event. At , Processor A fires Wait Sync Event to indicate that Processor A is about to execute a thread to determine processor utilization of Processor A. Then at , Processor A waits until Processor B fires Wait Sync Event ACK. After Processor A has fired Wait Sync Event, at block , Processor B fires Wait Sync Event ACK to acknowledge Wait Sync Event has been fired by Processor A. After Processor B has fired Wait Sync Event ACK, at block , Processor A starts to calculate an effective frequency of Processor A for determining processor utilization. The details of an exemplary embodiment of the process to calculate effective frequency are discussed below with references to .","After calculating the effective frequency at block , Processor A fires Done Sync Event at block  and the thread running on Processor A ends at . After firing Wait Sync Event ACK at block , Processor B checks at  whether Processor A has fired Done Sync Event at . If not, Processor B pauses at  and then returns to block  to check again. Processor B repeats blocks  and  until Processor A fires Done Sync Event. After Processor A has fired Done Sync Event, Processor B repeats block  to wait for Processor A to fire Wait Sync Event. By causing Processor B to repeat the checking and pausing operations at blocks  and , the thread running on Processor B and the frequency calculation thread running on Processor A are substantially synchronized and Processor B is prevented from causing an interrupt on Processor A, such as a System Management Interrupt (SMI), while Processor A is running the frequency calculation thread. As discussed above, such an interrupt may cause Processor A to halt in the middle of the frequency calculation, and consequently, to miscalculate the effective frequency of processor A. Therefore, preventing Processor B from causing an interrupt while Processor A is calculating the effective frequency helps to ensure the correct determination of processor utilization by Processor A.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 3 to 5"},"Referring to , at block , the platform hardware in an exemplary data processing system is initialized or started. At , the platform hardware determines if a processor in the data processing system is in a low power state. If the processor is not in a low power state then, at , a performance monitor counter in the data processing system is started. If at any stage during execution of the operations described, the hardware platform determines that the processor is in a low power state, then the performance monitor counter is stopped at block .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},"Referring to , at block  the application initializes. At block , a performance monitor event type is initialized. At block  a system timer is read and saved as a value called \u201cTime.\u201d At block  a periodic call back event is enabled. This allows the operation shown in  to be executed periodically, for example every 300 milliseconds. Enabling periodic call back at block  may be implemented in a variety of manners including timer based interrupts, system management events, or operating system directed sleep requests that put a thread to sleep for discrete intervals of time.","Referring now to , at block  the periodic call back event is started. At block , the performance monitor counter is read and its value is saved as a value known as \u201cTicks\u201d. At block , the performance counter is reset to prevent overflow. At block , the system timer is read and saved as \u201cTime.\u201d At block  an \u201cElapsedTime\u201d is calculated wherein: ElapsedTime=(Time\u2212Time)*TickPeriod, and wherein TickPeriod is the period between each tick of a performance monitor, such as the performance monitor  shown in . More details of the performance monitor will be discussed below.","Referring to , at block , the time values are updated wherein Time is saved as Time. This ensures that the calculated value for elapsed time is the actual time interval between the successive readings of the system timer. At block , an effective frequency is calculated, wherein EffectiveFreq=Ticks\/ElapsedTime. At block , a percentage utilization for a processor of the CPU core  is calculated, wherein Percentage_Utilization=(EffectiveFreq\/by Actual Frequency)\u00d7100.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 6","FIG. 6"],"b":["230","124","126","230","120","120"]},"In an alternate embodiment, the system has two or more physical processors such that the processors can execute a number of distinct threads substantially in parallel. Such a system is also referred to as a multiprocessor system. Referring to , the additional processors may be coupled to the North Bridge  through the PSB  as indicated by the additional arrow  in the PSB .","Communications between the CPU core  and north bridge circuit  occurs via a data pathway, which includes a processor system bus (PSB) , a bus interface , and a data input\/output (I\/O) bus . The bus interface  includes a clock control unit . and a performance monitoring (PMON) unit .. Functions of the clock control unit . and the PMON unit . in the context of some embodiments of the present invention will be explained below.","The architecture shown in  includes a number of configurable performance monitors  (only one of which has been shown) to monitor various performance related aspects of the CPU core . The performance monitor  may include an on-die register (not shown) that is accessible via a high privilege or ring  application. The performance monitor  communicates with the PMON unit . and various other PMON units .-. within the CPU core  via a performance monitoring bus .","In one embodiment, the performance monitor  monitors an event type known as CPU_CLKS_UNHALTED so that the performance monitor  can monitor clock control signals from the CPU core  as described in greater detail below. A clock signal  may be generated by a phase locked loop (PLL)  and fed to the CPU core  via a clock gate . In one embodiment, the clock gate  gates off or de-asserts the clock signal  whenever the clock control unit . generates a gate signal . The clock signal may be also fed directly to the CPU core . Many components within the CPU core  use the gate signal . However, some components may use the clock signal .","The clock control unit . generates the gate signal  in response to the halt (HLT) signals  and break (BREAK) signals  from the CPU core . The CPU core  may send HLT signals  to turn off clocking to one of the functional units of the CPU core . If the bus interface  is busy, then the HLT signals  are ignored, otherwise the clock control unit . sends the gate signal  to gate the clock signal . The CPU core  asserts the BREAK signals  when the clock signal  is to be ungated. The bus interface  may ungate the clock signal  due to some PSB  activity even when the break signal  is not asserted. In this case, the CPU core  continues to send the HLT signals  until the PSB  activity subsides. The HLT signals  may be generated either directly by software (e.g., microcode) or indirectly by hardware (e.g., sleeping thread counters).","In one embodiment, some motherboard logic (not shown) generates a stop clock (STPCLK#)  signal that passes through the bus interface  with little processing. The bus interface  matches the STPCLK# signal  with the clock signal  which represents a free-running clock or a system clock.","One should appreciate that the CPU core  may assert the HLT signals  for execution of an Auto Halt instruction, a STPCLK# assertion, internal faults, etc. Events that cause the BREAK signal  to be asserted may include STPCLK# de-assertion, external interrupts, resets, etc.","In one embodiment, the clock control unit . uses the HLT signals  and BREAK signals  generated during a clock cycle of the clock signal  to generate another signal known as PMCPUCLKUNHALTED#. PMCPUCLKUNHALTED# is input to the bus PMON unit ..","A high privilege application in the form of a ring  driver may be used to configure performance monitor  to monitor an event known as CPU_CLKS_UNHALTED. In one embodiment, whenever the CPU_CLK_UNHALTED event selection is detected, the PMON bus . drives the PMCPUCLKUNHALTED# signal  onto PMON bus . This causes a register of performance monitor  to increment on each core clock that assertion of the PMCPUCLKUNHALTED# signal  is detected. Thus, in effect, the performance monitor  serves as a counter to measure a length of time (in terms of ticks) for which the CPU core  has requested clock control unit . to allow the clock signal  to be asserted. Since the CPU core  executes application code when the clock signal  is asserted, the length of time that the PMCPUCLKUNHALTED# signal  is asserted is the length of time in a cycle of the system clock during which the CPU core  is used.","Some embodiments of the present invention include a utilization application that includes the high privilege or a ring  driver to configure and read performance monitor  during a time sampling interval as described above. Furthermore, the utilization application may include a low privilege or ring  application to use the ring  driver to control the performance monitor  to monitor the PMCPUCLKUNHALTED# signal  in order to calculate the processor utilization within the CPU core .","Referring now to , an architectural system diagram depicting the operation of a data processing system according to one embodiment of the present invention is illustrated. In the illustrated embodiment, a plurality of application programs  such as the processor utilization application  interact with various platform hardware devices  including, such as, the CPU core  illustrated in , via an operating system  such as the Windows\u2122 operating system from Microsoft Corporation, one or more device drivers , and basic input\/output system (BIOS) code . The illustrated system is interrupt-driven both with respect to the multitasking of the various applications  and communication between applications  and platform hardware .","Accordingly, in one embodiment, an application  requests for a hardware resource from within platform hardware  can cause an interrupt, such as a System Control Interrupt (SCI) or a System Management Interrupt (SMI) to be generated and an interrupt handler routine to be responsively executed. A device driver  and BIOS  enable interaction between the operating system  and platform hardware . In one embodiment, BIOS  contains information such as physical device addresses of the various devices  coupled to the data processing system  and is useful with respect to the actual transmission of data. By contrast, device driver  is typically specific to a particular hardware device and is usually concerned with the translation of data between various device formats.","The utilization application  may include a periodically executing applet or application. Each time the applet is executed, the processor utilization is determined as described above.","As noted above, the performance monitor  increments when the CPU core  is not in an idle state or a similar state. Thus, in one embodiment, the ring  driver application  starts and stops the performance monitor  based on a power state of the CPU core  as illustrated in  above. The count result is used to determine processor utilization. Furthermore, the performance monitor  may include multiple counters in a multi-processor system or a SMT system to keep track of the time of each individual physical processor or logical processor spent in a certain power state. However, the counts returned by these counters may be incorrect if these counters are interrupted in the middle of counting. Such potential interruption may be reduced in one embodiment of a process to determine processor utilization as discussed above with references to .","Referring now to , a conventional data processing system  useable with some embodiments of the present invention is illustrated. Data processing or computer system  is comprised of a system unit , output devices such as display  and printer , and input devices such as keyboard , and mouse . Data processing system  receives data for processing by the manipulation of input devices  and  or directly from fixed or removable media storage devices such as disk  and network connection interfaces (not shown). Data processing system  then processes data and presents resulting output data via output devices such as display , printer , fixed or removable media storage devices like disk  or network connection interfaces.","Referring now to , there is depicted a high-level block diagram of the components of a data processing system  such as that illustrated by . In an exemplary computer system, system unit  includes a processing device such as central processing unit (CPU)  connected to a level two (L2) cache  over a processor system bus (PSB) . Processor system bus (PSB)  is in turn coupled to an expansion bus such as local bus  and a memory  via a north bridge circuit . Local bus  may include a peripheral component interconnect (PCI), a Video Electronics Standards Association (VESA) bus or the like, coupled to CPU core  and PSB  to permit high-speed access to select devices such as display device .","Memory  may include read-only (ROM) and\/or random access (RAM) memory devices such as a synchronous dynamic random access memory (SDRAM) module capable of storing data as well as instructions to be executed by CPU . Access to data and instructions stored within memory  is provided via a memory controller (not shown) within north bridge circuit . L2 cache  is similarly used, typically in a hierarchical manner, to store data and instructions for direct access by CPU . Display device  may include a cathode ray tube (CRT) display such as display , liquid crystal display (LCD), or a similar device for displaying various kinds of data to a computer user. For example, image, graphical, or textual information may be presented to the user on display device . System unit  of data processing system  also features an expansion or \u201ccompatibility\u201d bus  such as the Industry Standard Architecture (ISA) bus, and a south bridge circuit  coupling it to local bus  to facilitate the attachment of other, relatively slower devices to the system . South bridge circuit  includes a universal serial bus (USB) port  as well as other direct connections for devices such as a network interface card , a data storage device, such as a magnetic hard disk drive , and an audio device  such as a speaker or sound card.","Other devices not directly coupled to south bridge  may be coupled to the system  via the expansion bus  as illustrated. A floppy disk drive (FDD)  providing additional data storage capacity on removable media storage devices such as disk , and input devices such as a keyboard  and a cursor control device  are each coupled to expansion bus  in this manner to communicate data, instructions, and\/or command selections to central processing unit . Cursor control device  may comprise a conventional mouse, such as mouse  of , a trackball, or any other device to allow cursor manipulation. Similarly, expansion bus  includes an input\/output (I\/O) controller having standard serial and parallel port functionality for connecting other I\/O devices such as printer  to the system.","The system of one embodiment of the present invention may include software, information processing hardware, and various operations. The features and operations of some embodiments of the present invention may be embodied in machine or computer executable instructions embodied within one or more machine-readable media. The instructions can be used to cause a general purpose or special purpose processor such as CPU core , which is programmed with the instructions to perform the described operations. Alternatively, the features or operations of some embodiments of the present invention may be performed by specific hardware components that contain hard-wired logic for performing the operations, or by any combination of programmed computer components and custom hardware components.","For the purposes of this specification, a machine-readable medium includes any mechanism that provides (i.e. stores and\/or transmits) information in a form readable by a machine (e.g. computer) for example, a machine-readable medium includes read-only memory (ROM), random access memory (RAM), magnetic disk storage media, optical storage media, flash memory devices, electrical, optical, acoustical, or other form of propagated signals (e.g. carrier waves, infra red signals, digital signals, etc.), etc.","Although the current description is made with reference to specific exemplary embodiments, it will be evident that various modification and changes can be made to these embodiments without departing from the broader spirit and scope of the appending claims. Accordingly, the specification and drawings are to be regarded in an illustrative sense rather than in a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 3 to 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 8B","FIG. 8A"]}]},"DETDESC":[{},{}]}
