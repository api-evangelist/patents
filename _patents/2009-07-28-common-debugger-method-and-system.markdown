---
title: Common debugger method and system
abstract: Disclosed are approaches for operating a plurality of debugger tools. A common debugger receives first-type commands for processing. Each first-type command references one of the debugger tools. Each debugger tool provides control over a respective set of one or more components of the electronic system and recognizes a respective set of tool-specific commands. Each input first-type command is translated into a respective tool-specific command that is compatible with the one of the debugger tools specified in the first-type command. Each respective tool-specific command from the common debugger is provided to the one of the debugger tools specified in the input first-type command from which the respective tool-specific command was translated. Each translated tool-specific command is performed by the targeted debugger tool.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08402442&OS=08402442&RS=08402442
owner: Xilinx, Inc.
number: 08402442
owner_city: San Jose
owner_country: US
publication_date: 20090728
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention generally relates to tools for debugging electronic circuit designs.","In developing an electronic system, a number of different tools are sometimes used to debug the different components of the system. For example, a video analytic design includes a microprocessor, a hardware-based video processing pipeline including DSP modules, and several input\/output (I\/O) interfaces to external peripherals. Some DSP modules may be developed using a high-level modeling system (e.g., System Generator for DSP from XILNX, Inc.), while other modules are written in low-level hardware description languages (HDLs). Some DSP modules are emulated in hardware under the control of a hardware co-simulation tool. Other DSP modules written in HDL are simulated using an HDL simulator. A logic analyzer may be used to capture data that appears at the I\/O interfaces of the emulated hardware. Still other modules may be implemented as software and an embedded system software debugger is used to debug the program.","In debugging such a complex system, the different tools may be used in sequence or concurrently to control the simulation and gather the desired data. However, working with the different tools and having to switch between them is cumbersome. Having to simultaneously interact with multiple ones of the tools is even more difficult.","The present invention may address one or more of the above issues.","In one embodiment of the invention, a method is provided for operating a plurality of debugger tools in an electronic system. The method includes inputting first-type commands to a debugger that is executing on a computing arrangement. Each first-type command references one of the debugger tools, and each of the debugger tools provides control over a respective set of one or more components of the electronic system. Each debugger tool recognizes a respective set of tool-specific commands for operating the debugger tool, and the tool-specific commands are incompatible between debugger tools. Each input first-type command is translated into a respective tool-specific command that is compatible with the one of the debugger tools specified in the first-type command. Each respective tool-specific command is output from the common debugger to the specified one of the debugger tools. The specified one of the debugger tools performs the respective tool-specific command.","In another embodiment, a method for operating two or more debugger tools in an electronic system includes coupling the debugger tools to a common debugger. Each of the debugger tools provides control over a respective set of one or more components of the electronic system via a respective command entry interface. For each one of the debugger tools, in response to input to the one debugger tool of a command referencing a component of the respective set controlled by another one of the debugger tools, the component controlled by the another one of the debugger tools is accessed from the command entry interface of the one debugger tool via the common debugger. In response to a script of commands input to the common debugger, in which one or more of the commands specifying a particular one of the debugger tools, the commands of the script are translated into tool-specific commands for the particular one debugger tool, and the tool-specific commands are provided to the particular one debugger tool.","An article of manufacture is provided in another embodiment. The article of manufacture comprises a processor-readable storage device storing executable instructions for operating a plurality of debugger tools in an electronic system. The instructions when executed by one or more processors cause the one or more processors to perform the operations including inputting first-type commands to a debugger that is executing on a computing arrangement. Each first-type command references one of the debugger tools, and each of the debugger tools provides control over a respective set of one or more components of the electronic system. Each debugger tool recognizes a respective set of tool-specific commands for operating the debugger tool, and the tool-specific commands are incompatible between debugger tools. Each input first-type command is translated into a respective tool-specific command that is compatible with the one of the debugger tools specified in the first-type command. Each respective tool-specific command is submitted from the common debugger to the specified one of the debugger tools. The specified one of the debugger tools performs the respective tool-specific command.","It will be appreciated that various other embodiments are set forth in the Detailed Description and Claims which follow.","The embodiments of the invention provide interoperability between different debugger tools and integrate the capabilities of the tools by providing a common interface for accessing the different tools. A common debugger runtime environment (CDRE) acts as a bridge that makes different debugger tools interoperable. One debugger tool can be operated via its native interface to control and access debugger information pertaining to design components controlled by another debugger tool. The CDRE translates a debugger operation entered in one tool into a corresponding operation for another debugger tool. The CDRE also provides an application programming interface (API) which may be used to access the capabilities of the different debugger tools in a uniform and tool-independent manner. The API makes it easy for a designer to create a script to programmatically control the interactions of the different debugger tools, as well as to automate testing of the entire design.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":"100"},"The debugger tools include one or more software modules that provide a user interface for controlling the debugger tool. Some debugger tools also simulate a portion of the design in software. Thus, certain modules of the debugger tools include software that executes on a computing arrangement. In , the example debugger tools include a hardware debugger , an embedded system debugger , an HDL simulator\/debugger , and a hardware co-simulation simulator . The hardware debugger, embedded system debugger, HDL simulator\/debugger, and hardware co-simulation simulator execute on computing arrangement , which includes, for example, one or more processors, a memory, and suitable input\/output capabilities. The embodiments of the present invention operate with two or more of the debugger tools.","The different debugger tools permit a portion of the design to be simulated on the computing arrangement  and a portion of the design to be emulated on a test\/debug platform . The test\/debug platform includes hardware resources for emulating selected portions of the design. Such a test\/debug platform may include one or more printed circuit boards and one or more programmable logic devices (PLDs)  such as field programmable gate arrays (FPGAs). The PLD may include an embedded processor  for executing software portions of the design.","The example system under test includes software (not shown) executing on processor , a pipelined subsystem , and a simulation model , which is generated from an HDL specification, for example. The pipelined subsystem includes a plurality of pipelined logic modules , , and , for example. The processor is coupled to the logic modules via bus . The different debugger tools provide debugger access to these components of the system.","The hardware debugger  allows the capture and examination of signals in a design while using the actual hardware device. The hardware debugger interacts with the system under test via a JTAG interface . A logic analyzer  is created using PLD resources, and the logic analyzer samples states of one or more signals. The states of the selected signals are provided to the hardware debugger.","The embedded system debugger  supports debugging of software executing on embedded processor . A processor debugger module  is implemented in PLD programmable logic for reading state information from or providing state information to the processor as defined by debugging needs. The embedded system debugger interfaces with the debugger module via JTAG interface . An example of software that includes an embedded system debugger is the Embedded Development Kit for software development from XILINX.","The HDL simulator  simulates all or part of the system under test as a software model  of the design. The HDL simulator may operate in conjunction with the hardware co-simulation simulator , which interacts with a portion of the design emulated on the PLD. The portion of the example system which is emulated on the PLD is the pipelined subsystem . The hardware co-simulation interface  provides the interface through which the hardware co-simulation simulator  interacts with the pipelined subsystem . An example HDL simulator is the ISim HDL simulator from XILINX, and an example hardware co-simulation simulator is provided with System Generator for DSP, also from XILINX.","In one embodiment, a designer may enter commands via one of the debugger tools and those commands may reference a component of the design controlled by another one of the debuggers. For example, the designer may enter a command via the user interface of hardware debugger  where the command references a component of the design, for example, the pipelined subsystem , which is controlled by the hardware co-simulation simulator . Each of the debugger tools is adapted to recognize a reference to a component that is controlled by another one of the debuggers. When such a component is referenced, the command is forwarded to the common debugger runtime environment (CDRE) , which translates the command into a format suitable for the debugger tool which controls the referenced object. The CDRE then submits the reformatted command to the proper debugger tool, and the debugger tool performs the specified command. Any data obtained by the debugger tool in processing the command is returned to the CDRE and then to the debugger tool from which the command was entered.","In another embodiment, a common debugger application programming interface  (API) is provided for interfacing with the CDRE . The common debugger API allows programs or scripts  to access the functions of the CDRE by way of program calls to those functions.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},"The input command  may be from one of the debugger tools, from a script, or provided as a parameter in a function call to the common debugger by a debugger application program.","At step , the CDRE determines which debugger tool is targeted by the command. A command generally includes the name of the command and one or more parameters. One of the parameters references the component that is targeted by the command. In CDRE, a hierarchical path identifier is used to uniquely identify a component in the design. Since a design may include both hardware and software components, the objects may include ports, signals, modules, or variables. The first part of the hierarchical path specifies the debugger tool. A hierarchical path identifier has the following format:","<application identifier>:\/\/<path component >\/<path component >\/ . . . .","The application identifier specifies the debugger tool through which the component is controlled. The path component i parts of the hierarchical path identifier specify the hierarchical components of the design from the highest to lowest level of the hierarchy.","The command is translated into a tool-specific command that is compatible with the debugger tool specified in the hierarchical path at step . At step , the translated command is submitted as input to the targeted debugger tool.","Any data returned by the debugger tool that processed the command is returned to the CDRE at step . At step , the output data is returned to the debugger tool that initiated the command by the CDRE. When the initiating debugger tool initially received the command and forwarded that command to the CDRE, the initiating debugger was put into a state to wait for a response. The CDRE provides any data returned in processing the command to the waiting debugger tool.","Table 1 describes the commands recognized by an example CDRE and the associated functions in the different debugger tools.",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Hardware ","Hard-","Embedded ",{}]},{"entry":[{},"co-","ware","system","HDL "]},{"entry":[{},"simulation","debugger","debugger","simulator"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["read","read the ","read the ","read the ","read the "]},{"entry":[{},"current ","current","current","current"]},{"entry":[{},"value of a ","value of","value of","value of a "]},{"entry":[{},"signal, a ","a signal","a ","signal"]},{"entry":[{},"shared ","or the","variable",{}]},{"entry":[{},"register or ","last ","or a ",{}]},{"entry":[{},"a shared ","captured ","memory",{}]},{"entry":[{},"memory ","samples","location",{}]},{"entry":[{},"location","of a signal",{},{}]},{"entry":["write","modify the ","modify ","modify ","modify "]},{"entry":[{},"value of a","the ","the value ","the "]},{"entry":[{},"signal, ","value ","of a ","value "]},{"entry":[{},"a shared ","of a ","variable","of a "]},{"entry":[{},"register, or a","signal","or a","signal"]},{"entry":[{},"shared ",{},"memory ",{}]},{"entry":[{},"memory",{},{},{}]},{"entry":[{},"location",{},"location",{}]},{"entry":["frame","obtain data ","obtain ","obtain ","obtain "]},{"entry":[{},"such as","data ","data ","data "]},{"entry":[{},"input and","such as","such as","such as"]},{"entry":[{},"output port ","values ","local ","input "]},{"entry":[{},"values, ","of","variables","and"]},{"entry":[{},"of a module ","captured ","and function","output port "]},{"entry":[{},"of the ","samples,","arguments ","values of a "]},{"entry":[{},"current","of the","of a","module of "]},{"entry":[{},"design","current","frame in ","the current "]},{"entry":[{},"clock cycle","capture buffer","the current ","simulation"]},{"entry":[{},{},{},"call stack","cycle"]},{"entry":["step","advance the ","advance the ","advance the","advance the"]},{"entry":[{},"design clock","signal ","program ","simulation "]},{"entry":[{},"for a","capture","execution","for a"]},{"entry":[{},"specified ","for a speci-","for a speci-","specified "]},{"entry":[{},"number of","fied number","fied number ","number"]},{"entry":[{},"cycles","of samples","of instruction ","of cycles"]},{"entry":[{},{},{},"units",{}]},{"entry":["continue","continue ","continue ","continue ","continue "]},{"entry":[{},"the design ","the ","the","the"]},{"entry":[{},"execution","signal","program","design "]},{"entry":[{},"by re-","capture","execution","simulation"]},{"entry":[{},"enabling",{},{},{}]},{"entry":[{},"the design ",{},{},{}]},{"entry":[{},"clock",{},{},{}]},{"entry":["break","pause the ","pause ","pause","pause "]},{"entry":[{},"design","the","the ","the "]},{"entry":[{},"execution by ","signal","program","design"]},{"entry":[{},"disabling the","capture","execution","simulation"]},{"entry":[{},"design clock",{},{},{}]},{"entry":["trigger","set up an ","set up ","set up a ","set up a"]},{"entry":[{},"interrupt to","one or ","software","breakpoint"]},{"entry":[{},"disable","more match ","or hardware","to pause"]},{"entry":[{},"the design ","units to ","breakpoint to","the"]},{"entry":[{},"clock","trigger the ","pause the ","simulation "]},{"entry":[{},"and pause","capture","program","under"]},{"entry":[{},"co-","under","execution ","given "]},{"entry":[{},"simulation","given","at a specified ","conditions"]},{"entry":[{},"under given","conditions","location",{}]},{"entry":[{},"conditions",{},"under given",{}]},{"entry":[{},{},{},"conditions"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"As mentioned above, one embodiment of the invention includes an API through which functions of the CDRE may be accessed by a program or script. The API follows the style of dynamic programming languages, for example, Python, Ruby, or JavaScript, where values are dynamically typed. A value can be a simple \u201cscalar\u201d such as Number, Boolean, and String, or a complex \u201ccontainer\u201d such as Sequence and Dictionary, or a \u201chigher-order object\u201d such as Function. The CDRE handles the conversion of values into respective values\/objects in each debugger tool. Object identifiers (objectID) are specified in the hierarchical format described above.","Table 2 provides examples of function signatures of the commands in Table 1.",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"value = Read(objectlD)"},{"entry":"Write(objectlD, value)"},{"entry":"value = Frame(objectlD)"},{"entry":"Step(objectID, value)"},{"entry":"Continue(objectID)"},{"entry":"Break(objectID)"},{"entry":"Trigger(objectID, predicate, callback)"},{"entry":"\u2003predicate is a Function with signature: "},{"entry":"\u2003booleanValue = Function(arguments)"},{"entry":"\u2003callback is a Function with signature: "},{"entry":"\u2003Function(objectID, arguments)"},{"entry":"\u2003arguments is a Sequence of values."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3","b":["302","304","306","308","310","312"]},"If the command is not from the CDRE, the process proceeds to decision step , to check which debugger tool controls the component that is referenced in the command. If the referenced component is controlled by another debugger tool, the command is forwarded to the CDRE at step  for dispatch to the proper debugger tool. Otherwise, the command is processed by the debugger tool through which the command was initially entered.","The description accompanying  provides example use cases involving the CDRE with a hardware co-simulation simulator, a hardware debugger, an embedded system debugger, and an HDL simulator.  shows an example of a portion of a hierarchical design including a top level , module , module , and an embedded processor . Module  includes a logic analyzer module  which is generally accessed by a hardware debugger. Part of the example design includes software executing on embedded processor  and is accessed during system simulation using an embedded system debugger.","Table 3 shows example commands entered into a hardware co-simulation simulator for accessing module  as a hardware co-simulation component and accessing signalA via the CDRE and hardware debugger.",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"mod1 = Hwcosim (\u2018toplevel\/module1\u2019);"},{"entry":"\/\/access regular hardware co-simulation object"},{"entry":"value = read (mod1, \u2018portB\u2019);\/\/ read the current value of portB"},{"entry":"write (mod1, \u2018portA\u2019, 123);\/\/ write a value to portA"},{"entry":"run (mod1, 2);\/\/ step the clock for 2 cycles"},{"entry":"ila0 = Hwcosim(\u2018chipscope:\/\/toplevel\/"},{"entry":"module2\/logicanalyzer\u2019); \/\/ access the logic analyzer core"},{"entry":"values = read (ila0, \u2018signalA\u2019, 10); \/\/ read the last 10 samples of signalA"},{"entry":"run (ila0, 10);\/\/ advance the capture for 10 more samples"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Table 4 shows example commands entered when using an embedded system debugger where one of the objects accessed is a component controlled by the hardware co-simulation simulator.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":">load hwcosim:\/\/toplevel \/\/ access to hardware co-simulation object"},{"entry":">print module1.portB"},{"entry":"\u2003\/\/ Read the current value of portB in module1 through "},{"entry":"\u2003hardware co-simulation simulator."},{"entry":"\u2003\/\/ The module is treated as a struct and the "},{"entry":"\u2003ports are treated as fields of the struct."},{"entry":"\u2003\/\/ The embedded system debugger command is "},{"entry":"\u2003translated into the following hardware co-simulation"},{"entry":"\u2003\/\/ simulator command: read (mod1, \u2018portB)."},{"entry":">step"},{"entry":"\u2003\/\/ Step the design clock 1 cycle."},{"entry":"\u2003\/\/ The embedded system debugger command is "},{"entry":"\u2003translated into the following hardware co-simulation"},{"entry":"\u2003\/\/ simulator command: run (mod1, 1)."},{"entry":">watch module1.portB <3"},{"entry":"\u2003\/\/ Break when the value of portB is less than 3."},{"entry":">break module2.signalA"},{"entry":"\u2003\/\/Break when the value of signalA in module2 changes."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Table 5 shows an example in which hardware debugger commands are entered for viewing a component controlled by the hardware co-simulation simulator.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":">scope hwcosim:\/\/toplevel\/module1 \/\/ "},{"entry":"access to hardware co-simulation object"},{"entry":">show value ports"},{"entry":"\u2003\/\/ Read the current value of portB in module1 through the "},{"entry":"\u2003hardware co-simulation simulator"},{"entry":"\u2003\/\/ The module is treated as a struct and the ports are "},{"entry":"\u2003treated as fields of the struct"},{"entry":"\u2003\/\/ The hardware debugger command is translated into the "},{"entry":"\u2003following hardware co-simulation simulator"},{"entry":"\u2003\/ command: read (mod1, \u2018port13\u2019)"},{"entry":">put value portA 2"},{"entry":"\u2003\/\/ Write 2 to portA in module1 through the "},{"entry":"\u2003hardware co-simulation simulator"},{"entry":"\u2003\/\/ The hardware debugger is translated into the following "},{"entry":"\u2003hardware co-simulation simulator command:"},{"entry":"\u2003\/\/ write (mod1, \u2018portA\u2019, 2)"},{"entry":"> run 10 ns"},{"entry":"\u2003\/\/ Step the design clock for 1 cycle "},{"entry":"\u2003(assuming a clock period =10 ns)"},{"entry":"\u2003\/\/ The hardware debugger command is translated into the "},{"entry":"\u2003following hardware co-simulation simulator"},{"entry":"\u2003\/\/ command: run (mod1, 1)"},{"entry":">isim condition add {portB}{stop}"},{"entry":"\u2003\/\/ Break when the value of portB in module1 is less than 3."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Table 6 shows the common debugger API  equivalent to the commands in Table 3.",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"mod1 = CDRE_GetObject (\u2018hwcosim:\/\/toplevel\/module1\u2019); "},{"entry":"\/\/ access hardware co-simulation object"},{"entry":"value = read (mod1, \u2018portB\u2019);\/\/ read the current value of portB"},{"entry":"write (mod1, \u2018portA\u2019, 123);\/\/ write a value to portA"},{"entry":"step (mod1, 2);\/\/ step the clock for 2 cycles"},{"entry":"ila0 =CDRE_GetObject (\u2018chipscope:\/\/toplevel\/module2\/logicanalyzer\u2019); "},{"entry":"\/\/ access the logic analyzer core"},{"entry":"values =read (ila0, \u2018signalA\u2019, 10);\/\/ read the last 10 samples of signalA"},{"entry":"step (ila0, 10);\/\/ advance the capture for 10 more samples"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5"},"Computing arrangement  includes one or more processors  coupled to a memory\/storage arrangement . The architecture of the computing arrangement depends on implementation requirements as would be recognized by those skilled in the art. The processor  may be one or more general purpose processors, or a combination of one or more general purpose processors and suitable co-processors, or one or more specialized processors (e.g., RISC, pipelined, etc.).","The memory\/storage arrangement  is representative of hierarchical storage commonly found in computing arrangements. Such hierarchical storage typically includes multiple levels of cache memory, a main memory, and local and\/or remote persistent storage such as provided by magnetic disks (not shown). The memory\/storage arrangement may include one or both of local and remote memory\/storage, remote storage being coupled to the processor arrangement via a local area network, for example.","The processor arrangement  executes the software stored in memory\/storage arrangement , and reads data from and stores data to the memory\/storage arrangement according to the processes described above. An operating system (not shown) manages the resources of the computing arrangement. The common debugger module  provides the CDRE for use in combination with the debugger tools  as described above. The debugger tools simulate an electronic circuit design using various simulation models . As described in , one or more of the debugger tools may be used in emulating part of the design in hardware, while others of the tools simulate parts of the design in software. The results  of the simulation and emulation may be stored in the memory arrangement or output to a display device.","The present invention is believed to be applicable to a variety of systems for debugging electronic circuit designs. Other aspects and embodiments of the present invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and illustrated embodiments be considered as examples only, with a true scope and spirit of the invention being indicated by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Various aspects and advantages of the invention will become apparent upon review of the following detailed description and upon reference to the drawings, in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4","b":["1","2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
