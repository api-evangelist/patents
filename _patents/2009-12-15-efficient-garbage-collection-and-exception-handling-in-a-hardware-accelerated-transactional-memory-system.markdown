---
title: Efficient garbage collection and exception handling in a hardware accelerated transactional memory system
abstract: Handling garbage collection and exceptions in hardware assisted transactions. Embodiments are practiced in a computing environment including a hardware assisted transaction system. Embodiments includes acts for writing to a card table outside of a transaction; handling garbage collection compaction occurring when a hardware transaction is active by using a common global variable and instructing one or more agents to write to the common global variable any time an operation is performed which may change an object's virtual address; acts for managing a thread-local allocation context; acts for handling exceptions while in a hardware assisted transaction. A method includes beginning a hardware assisted transaction, raising an exception while in the hardware assisted transaction, including creating an exception object, determining that the transaction should be rolled back, and as a result of determining that the transaction should be rolled back, marshaling the exception object out of the hardware assisted transaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08402218&OS=08402218&RS=08402218
owner: Microsoft Corporation
number: 08402218
owner_city: Redmond
owner_country: US
publication_date: 20091215
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","Background and Relevant Art","BRIEF SUMMARY","DETAILED DESCRIPTION","Detailed Examples of Some Embodiments That May Be Implemented"],"p":["Computers and computing systems have affected nearly every aspect of modern living. Computers are generally involved in work, recreation, healthcare, transportation, entertainment, household management, etc.","Often computing system implement transactional operations where for a given set of operations, either all of the operations should be performed or none of the operations are performed. The set of operations that should all be performed or not performed may sometimes be referred to as an atomic block of operations. For example, a banking system may have operations for crediting and debiting accounts. When operations are performed to exchange money from one account to another, serious problems can occur if the system is allowed to credit one account without debiting another account. However, transactional computing maintains historical information such that operations can be rolled back if all operations in an atomic set of operations cannot be performed. If all of the operations in the atomic set of operations have been performed, then any changes to data stored in memory are committed and become globally available to other actors for reading or for further operations. Transactional computing can be implemented, in some systems, using specialized hardware that supports transactional memory. In systems where hardware does not support hardware assisted transaction computing, transactional computing can be performed by using software techniques.","Challenges may arise at the intersection of hardware acceleration of transactional memory and automatic memory management via garbage collection (GC). GC involves the traversal of memory to find objects that are no longer in use to reclaim memory space. Typically GC works by finding live objects and deducing that the rest of memory contains dead objects. This may be particularly manifest on virtual machines such managed code .NET\u00ae languages running on the Microsoft Common Language Runtime, or through Java running on a Java Virtual Machine.","Assuming use of a hardware accelerated unbounded transaction management system that works well for explicit (manual) memory management, the introduction of automatic memory management introduces some problems. In particular, inadvertent (and programmer-unavoidable) contention and the ensuing transaction reexecutions will arise when multiple threads' accesses to managed objects in turn access internal memory manager data structures. For example, automatic memory management may use card marking tables for garbage collection. In particular, garbage collectors typically traverse memory for objects that are still in use. Scanning the entire memory heap for live objects may be particularly resource intensive, so generation scans may be performed where scanning of more recently created objects is performed more often than scanning of older objects. When a reference to a new object is stored into an old object, a card marking table may be used to indicate that the old object should be scanned. However, the card marking table may be shared such that multiple agents use the same memory for card marking table purposes. In addition to that, a card table typically uses a compact representation, for example, a single Boolean field in the table may represent the existence of old-to-new pointers in a large region of memory. Thus, a write to the card marking table may cause a hardware transaction to abort, due to contention. Other implementations of \u201cremembered sets\u201d of intergenerational object references may suffer from similar issues.","Another issue that may arise is that compacting garbage collectors may quietly move objects to new addresses during a collection. Thus, while fine for automatic garbage collection, this movement presents problems in hardware assisted transactional memory systems, since a thread could be monitoring, using a hardware transaction, changes to an object at its old location, while the GC moves the object to a new location, unbeknownst to the hardware transaction, since the GC doesn't change any of the object's contents at the old location.","Additional issues may arise with hardware transaction systems due to 1) the sojourn through the OS when the exception is raised, 2) successfully catching and handling the exception without aborting the transaction, and 3) in the event the exception is uncaught and leaves the atomic block, with validating the transaction and then correctly marshalling the exception object, which is potentially only present only in buffered cache lines, out of the transaction, before aborting the transaction and invalidating the buffered lines.","Note that when an exception is raised, it is possible to abort the cache resident transaction, flush hardware buffered state, and reexecute the transaction in a simple STM mode, to rerun to the point of the exception, but this wastes the time and energy already invested in advancing the computation to the exception site. Furthermore, in some cases, by having a transaction transition to software transactional memory, can cause all the extant cache resident implicit transaction managed transactions in the system to abort and reexecute in a slower and more expensive mode.","The subject matter claimed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather, this background is only provided to illustrate one exemplary technology area where some embodiments described herein may be practiced.","One embodiment includes a method practiced in a computing environment including a hardware assisted transaction system. The method includes acts for writing to a card table, the method includes beginning a hardware assisted transaction, determining that a write entry needs to be made to a card table to store a reference from one object to another object while the transaction is running and performing an un-buffered non-transacted write to an entry in the card table outside of the transaction.","Another embodiment includes a method practiced in a computing environment including a hardware assisted transaction system. The method includes acts for handling garbage collection compaction occurring when a hardware transaction is active. The method includes beginning a hardware assisted transaction, as part of the hardware assisted transaction, setting a read monitor on a common global variable, and instructing one or more agents to write to the common global variable any time an operation is performed which may change an object's address.","Another embodiment includes a method practiced in a computing environment including a hardware assisted transaction system. The method includes acts for handling exceptions while in a hardware assisted transaction. The method includes beginning a hardware assisted transaction, raising an exception while in the hardware assisted transaction, including creating an exception object, determining that the transaction should be rolled back, and as a result of determining that the transaction should be rolled back, marshaling the exception object out of the hardware assisted transaction.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","Additional features and advantages will be set forth in the description which follows, and in part will be obvious from the description, or may be learned by the practice of the teachings herein. Features and advantages of the invention may be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. Features of the present invention will become more fully apparent from the following description and appended claims, or may be learned by the practice of the invention as set forth hereinafter.","The following presentation is organized into a broad description of the invention and surrounding context, followed by detailed examples of some embodiments that may be implemented.","Fast Flexible Unbounded Transactional Memory (UTM)","Many modern computer systems comprise multiple processors, caches, and a memory system hierarchy that provides a shared memory to multiple threads running on the processors. Threads may concurrently access shared data structures in the shared memory.","It can be difficult to program such machines. Shared data may be accessed at any moment by other threads. It can be difficult to keep other threads from visiting a data structure while it is being modified, to guarantee data structure invariants across threads, etc. For example, consider a job scheduler that tracks the number of running jobs and finished jobs with counter variables. The sum of these counters should always equal the total number of jobs. The following C code illustrates a typical computation:\n\nvoid end_job(){\u2212\u2212running; ++finished;}\n","If the function end_job() is run on one thread while another thread reads the variables \u2018running\u2019 and \u2018finished\u2019, it is possible for the second thread to read (.7 6 a inconsistent data, for example, reading the new value of running but the old value of finished.","Transactional memory (\u201cTM\u201d) may provide a better programming model for multithreaded shared memory applications. Transactional memory promises to provide code with isolation from other threads' accesses, serialization, as if only one transaction runs to completion at a time, and atomicity, so that either all of the data written within a transaction take effect, or none do so.","An atomic block construct may be added to programming models or languages to provide TM semantics. This control structure delineates (defines the scope of) the statements in a transactional memory transaction. For example:\n\nvoid atomic_end_job(){atomic{end_job()}}\n","In this example, atomic_end_job() begins a transaction, calls end_job() which accesses the counter variables, and then tries to commit the transaction. The function end_job() is run within a transaction; the programmer depends upon the TM system to ensure the counter updates are isolated, atomic, and serialize with respect to any accesses from other threads. The example also illustrates that code such as end_job() may be executed in absence of transactions or while within a transaction.","TM may be implemented in various ways. One approach, called bounded hardware TM (\u201cHTM\u201d), seeks to extend and repurpose the cache coherence machinery in a shared memory multiprocessor to provide two key mechanisms needed for correct implementation of TM semantics: conflict detection and version management.","Conflict detection discovers that data read in a transaction in one thread is concurrently written by another agent; or that data written in a transaction is concurrently read or written by another agent. Conflict detection makes transaction isolation and serializability possible. If throughout the lifetime of a transaction there are no data conflicts with any data read or written in the transaction, the transaction will serialize with respect to other agents' memory accesses and transactions.","Version management is used to buffer speculative writes to data in a transaction, until the transaction commits all such writes so they become permanent and globally observed by other agents. In the event of a data conflict, a transaction aborts, by rolling back any speculative writes it performed, and optionally starting over to reexecute the body of the atomic block.","The cache coherence system in a shared memory multiprocessor is a starting point in building a hardware transactional memory system. A plurality of processors with a plurality of caches, possibly private, are coordinated so as to provide software with the illusion of a single, fast shared memory. Sometimes data is found in system memory, and sometimes the latest version is found in one or more data cache lines. When an agent writes its cache's copy of the data, that data is the newest version of the data. If another agent attempts to read the same data, it sources it from the first agent's copy, rather than the stale copy in some other cache or in system memory. This is accomplished by means of a cache coherence protocol such as MESI. MESI (modified, exclusive, shared, invalid) is named for the cache line sharing state and state machine associated with each cache line in each coherent cache in the system. A cache coherence protocol may require agents to observe (\u201csnoop\u201d) external reads and writes by the other agents in the system. As one agent reads data or writes data, a request is sent that is snooped by other agents' caches. This may cause a copy of the data cached in one cache to be invalidated, updated. or shared with other caches or with system memory.","These per-line coherence state machine transitions also correspond to the kinds of data conflicts that an HTM needs to detect. If a thread's cache line contains data read in a transaction, and then another agent writes it, the thread's cache's state may be changed. A similar process holds for a transactional write. Some embodiments provide indicators \u201cread monitor\u201d (\u201cRM\u201d) and \u201cwrite monitor\u201d (\u201cWM\u201d), as will be illustrated in further detail in  below, at  and  respectively, and associated behaviors to each cache line entry, to identify which lines are transactionally read and\/or written within a transaction, it is possible for cache hardware to detect conflicting accesses to the transaction's sets of read data and written data.","A cache also provides a basis upon which to implement data version management. If a cache is private to an agent, then during a transaction its cache lines may be repurposed to buffer speculatively written data from within the transaction. In some embodiments cache line entries may also comprise a \u201cbuffering indicator\u201d (\u201cBUF\u201d), as illustrated in  below at , to identify transactionally written lines. Buffered cache data lines are temporarily exempt from cache coherence processing. If another agent requests the latest version of a cache line, the cache does not forward its buffered line because the transaction has not committed and its writes should not be observed by other agents. HTM transaction commit clears buffering indicators across all cache lines such that these lines are again globally observed. HTM transaction abort invalidates any cache lines marked with buffering indicators so any speculatively written data on those lines is discarded.","In some embodiments new instructions enable software to begin, commit, abort, suspend, and handle aborts for HTM transactions. A transaction begin (e.g. \u201cTB\u201d) instruction puts the thread in \u201cHTM mode\u201d wherein all subsequent memory accesses are implicitly transactional, setting RM on memory loads and setting WM and BUF on memory stores; a transaction exit and commit (e.g. \u201cTXCOM\u201d) instruction tries to commit the transaction, atomically clearing RM, WM, and BUF on cache lines; and so forth. For example, the following illustrates assembly code using the new instructions included in the extended instruction set architecture (\u201cISA\u201d) approximately corresponding to the atomic_end_job() function:\n\nTB ;begin transaction\n\nDECR running ;\u2212\u2212running;\u2032 implicitly transactional R+W\n\nINCR finished ;++finished; implicitly transactional R+W\n\nTXCOM ;try to exit and commit the transaction\n","This implementation of TM may be designated a cache resident, implicitly transactional TM (\u201cCRITM\u201d).","When a transaction's set of memory accesses do not fit in the cache, the cache necessarily evicts a monitored or buffered cache line. In some embodiments this may cause the transaction to abort. Retrying the transaction may not help. In an n-way set associative cache based implementation, a transaction may abort after as few as n+1 memory accesses. Therefore an HTM in itself may not serve as the sole basis of a general purpose transactional memory system.","Nevertheless, some embodiments may elect to run small, simple transactions in an HTM mode and fall back to a more general mechanism when necessary.","Some embodiments may expose to software the RM, WM, and BUF properties that are logically associated with each cache line sized block of memory in the system, and physically associated with the set of cached lines in the cache at a given time. Making these properties visible to the instruction set architecture allows software to explicitly set these properties on an address to monitor it against conflicting accesses by other agents, to explicitly buffer selected data, to test these properties on an address, and to observe any loss of these properties. In some embodiments each thread has its own private copy of these properties.","TM may also be implemented entirely in software (\u201cSTM\u201d). For a given memory load or store in the program in the scope of execution of a transaction, an STM system employs an STM read or write barrier that wraps the load or store with code to perform conflict detection and version management. In some embodiments, an STM associates some STM state with each data item or chunk of data. In some embodiments, the state is a word of memory stored alongside or otherwise correlated to the data\u2014for example, a \u201cTMW\u201d\u2014a TM metadata word\u2014that at different times may hold a lock for the data, or a version number of timestamp for the data. Different transactions across threads may inspect data's TMWs to perform conflict detection, e.g. to determine if the data is locked by another transaction, or if the data has been written by another transaction since it was read by this transaction. In some embodiments an STM write barrier may attempt to lock the data (via its TMW) against access by other threads and log its original value in case the write may need to be rolled back, and an STM read barrier may check the data's TMW to determine whether the data is locked, and note the data's version or timestamp, in addition to performing a store or load respectively. STM barrier bookkeeping overheads can impact the performance of software executed in an STM implementation.","In some embodiments transactional memory programming constructs such as atomic blocks fully compose with other constructs such as loops. It has been observed that if a data access occurs within a loop in a transaction, the data access' TM barrier may be performed for the same data over and over again at considerable overhead. In some embodiments it suffices to take a TM read or write barrier once per transaction per data item. Therefore a significant performance optimization may be to apply a \u201cbarrier filter\u201d to a TM barrier code sequence, which employs a filter indicator state per address per transaction, and first tests this indicator to determine whether the barrier has already been performed for this data address in this transaction; if so, the rest of the barrier is skipped; if not, the rest of the barrier is performed and the indicator is set to record the read or write barrier has been performed for this data item for this transaction.","It is expensive for a software implementation to maintain and consult this filter indicator for each data item accessed in a transaction. Therefore it may be beneficial to provide hardware assistance to associate per-transaction per-address state for each data item that may be accessed. In some embodiments the RM, WM, and BUF indicators described above, in addition to their roles in conflict detection monitoring and write buffering, may also be used as filter indicators, where the processor instruction set includes instructions to explicitly set, reset, and test the state of these respective indicators. For example in some embodiments the instructions to test RM, WM, and BUF properties for an address might be designated TESTRM, TESTWM, and TESTBUF. In some embodiments such test instructions might set a processor condition code or similar branch predication indicator if a property is set for the address. In some embodiments the processor condition code is already present in a legacy ISA from which an extended ISA is derived. One such processor condition code is the carry flag CF implemented in many ISAs.","Therefore, a hardware accelerated STM (\u201cHASTM\u201d) may be implemented such that on processors with this transactional memory hardware support, the RM, WM, and BUF indicators may be used by HASTM read and write barriers to perform redundant barrier filtering by testing the presence of a indicator for an accessed data item. If set, the barrier has already been performed for the item and the rest of the barrier code can be skipped; if not set, it may be the barrier has not yet been performed, or it may be the indicator was lost when the cache line holding the indicator was evicted or invalidated. If not set, the rest of the barrier including the STM conflict detection and version management bookkeeping are performed as before and the indicator is set for the data item.","To further increase the performance of the TM system, in some embodiments it may be possible to run each threads' transactions (if any) in transaction execution modes specific to the size, duration, and complexity of each respective transaction. If a transaction is small and simple, it may successfully execute and commit using CRITM execution mode. If a transaction is large, long running, or complex, it may require execution in an STM or HASTM execution mode. If a transaction is run on an older legacy processor that lacks TM hardware extensions, it may have to run in STM mode. Other threads sharing the same shared memory may be running code non-transactionally (in the \u2018non-transactional\u2019 TM mode). So multiple threads may simultaneously run various transactions in various transaction execution modes.","This approach may offer the best of both worlds: the efficiency of hardware TM execution when possible and the generality of software TM otherwise. However a TM system should operate correctly even when there are potential or actual data access conflicts across threads running in different modes. So STM threads' conflict detection and version management data structures and algorithms can be made compatible with HTM threads' cache based approaches.","In some embodiments this may be accomplished by a \u201ccache resident implicitly-transactional STM-compatible TM\u201d (\u201cCRISTM\u201d) TM execution mode. Like CRITM, CRISTM performs conflict detection and data versioning in hardware, implicitly as data items are accessed, and also CRISTM employs read and write barriers that first test the data's STM lock state (e.g. in its TMW) if any to ensure it is not locked by another STM thread. This implicitly sets a read monitor on the data's lock. In this way, CRISTM-mode threads respect STM locks, and subsequent STM data writes on other threads may be observed (for example, via loss of read monitoring) by CRISTM based threads. Similarly, CRISTM write barriers obey the particular STM's data, lock, versioning, and\/or timestamp discipline particular to a given STM algorithm. For example, if after an STM transaction, a data item's TMW is updated with a new version so that other STM transactions may detect a read-write data conflict, then in the same way, a CRISTM write barrier will (in addition to writing the data) write an updated version in the data item's TMW. Because CRISTM writes are buffered, this TMW write is write buffered and only becomes globally observed when and if its CRISTM transaction commits.","In some embodiments such approaches allow multiple threads to concurrently execute multiple transactions using multiple transactional execution modes, correctly and efficiently. A transaction may start in a hardware accelerated mode like CRISTM and on abort, roll back the transaction and reexecute it using a software based TM implementation, and do so without disturbing execution of code including TM code that may be executing on other threads.","Implicit and Explicit Hardware Transactional Memory Semantics","A cache based HTM as described above provides an efficient implementation of TM for transactions that fit in the limited capacity of the thread's private view of its cache.","It may be desirable to reduce the set of data accesses that receive hardware transactional memory semantics such as data conflict monitoring and speculative write buffering. In particular, when executing a transaction, some data accesses, such as to data shared with other threads, may require TM semantics, whereas other data accesses, such as to thread private variables on the stack, may not. If there were a way for software to differentiate the two cases to hardware, it may be possible to run a larger transaction in a given cache by selectively providing TM semantics to just the subset of the data accesses that require it.","In some embodiments such as the HTM described above, an instruction or other ISA mechanism is performed to establish an ambient HTM transaction execution mode on\u2014the thread such that data accesses are implicitly and automatically given TM semantics.","In some embodiments, an instruction or other ISA mechanism may be performed to selectively perform a data access that does not receive TM semantics within an HTM transaction execution mode.","In some embodiments, an instruction or other ISA mechanism may be performed to perform a data access that receives TM semantics even if the thread is not in an HTM execution mode.","In some embodiments, such as the Intel x86 and Intel64 architecture, most instructions may have memory operands that implicitly perform read and\/or write memory accesses. In some embodiments a possibly optional instruction prefix may designate the memory accesses of the instruction to be explicitly transactional, explicitly not-transactional, or to explicitly receive the current thread ambient transactional semantics, or to explicitly receive the opposite of the current thread ambient transactional semantics, or otherwise modify the default transactional semantics the instruction would otherwise receive.","In some embodiments such as the Intel x86 and Intel64 architecture, memory operands on instructions refer to a default segment selector such as DS: or CS: or SS:, and instructions may also encode alternate selectors. In some embodiments of an HTM, the segment selector may be repurposed to also selectively control whether the data access specified by the instruction's memory operand should receive or not receive transactional semantics. In some embodiments, the specific transactional semantics associating behavior of each selector or sets of selectors in this configuration may be accomplished by setting a selector transaction indication mode control field in a special register in the thread context. In some embodiments various settings of this mode control field may make some or all segment selectors designate explicitly transactional, explicitly non-transactional, thread-ambient, or explicitly contra-thread-ambient transactional semantics for their data accesses.","Some embodiments may eschew implicitly transactional access modes and memory accesses, and instead implement an STM-compatible cache resident hardware TM that uses explicitly transactional memory access instructions. Such a transactional execution mode might be designated \u201ccache resident, explicitly-transactional, STM-compatible TM\u201d (\u201cCRESTM\u201d). Like CRISTM, CRESTM performs conflict detection and data versioning in hardware, for example via read and write monitors and write buffering. Like CRISTM, CRESTM uses STM compatible read and write barriers that in some embodiments 1) load and test the data's STM lock state (e.g. in a TMW) (e.g. via a load-and-explicitly-set-read-monitor instruction where one example may be referred to herein as \u201cMOVXM\u201d) to check it is not already locked by another STM thread; and 2) store (e.g. via a store-and-explicitly-set-buffering instruction where one example may be referred to herein as \u201cMOVXB\u201d) a new version (or timestamp, etc.) to the data's TMW. These barriers explicitly set a read monitor on the data's TMW and a write monitor and buffering on the data's TMW so that a subsequent conflicting access to transaction data by a thread running an STM execution mode can be observed by a CRISTM or CRESTM mode thread as a loss of read monitoring, write monitoring, or buffering.","Hardware transactional memory solutions may be implemented using cache memory. Referring now to , an example environment is illustrated.  illustrates a plurality of processors ---. When referred to generically herein, the processors may be referred to simply as processor . In fact any component referred to using a specific appendix designator may be referred to generically without the appendix designator, but with a general designator to which all specific examples belong. Each of the processors implements one or more threads (referred to generically as ). In the present example, each of the processors --- supports a single thread --- respectively. However, embodiments may be implemented where processors support multiple threads. Each of the threads --- includes an instruction pointer ---, general registers ---, and special registers ---. Each of the special registers --- includes a transaction control register (TCR) --- and a transaction status register (TSR) ---. The functionality of these registers will be explained in more detail below in conjunction with the description of .","Reference once again to  further illustrates that connected to each processor is a level 1 data cache (LID$) -, - and -. Details of a LID$ are now illustrated with reference to .  illustrates that a LID$  includes a tag column  and a data column . The tag column  typically includes an address column  and a MESI column . The MESI indicator is used for implementing the Illinois MESI protocol and indicates a state of data in a cache line. MESI stands for the modified (or dirty), exclusive, shared and invalid states respectively. Because in a cache hierarchy there may be several different copies of a particular piece of data, an indicator is used to indicate the state and sharing of data at a particular location. If the indicator indicates that the data is modified, that means that the data at that location was modified by an agent at that location and no other agents have a cached copy of the data. If the indicator indicates that data is exclusive, this means that no other agents have a cached copy of the data. If the indicator indicates that the data is shared, this means that other agents may share the same version of the data. If the data is indicated as invalid, then the data at the current location is invalid and will not be used.","In a cache-coherent multiprocessor, a level of data cache that is logically private to one processor (usually level one data cache (LID$)) may be extended with additional MESI states and behavior to provide cache coherence based detection of conflicting data accesses from other agents, and to locally buffer speculative writes in a private cache such that other agents in the system do not observe speculatively written data until the data's state transitions from speculatively written to globally observed.","The address column  includes a physical address for data stored in the data column . In particular, as illustrated in , a computing system generally includes system memory . The system memory may be, for example semiconductor based memory, one or more hard-drives and\/or flash drives. The system memory  has virtual and physical addresses where data is stored. In particular, a physical address identifies some memory location in physical memory, such as system DRAM, whereas a virtual address identifies an absolute address for data. Data may be stored on a hard disk at a virtual address, but will be assigned a physical address when moved into system DRAM.","In the present example, the tag column  includes three additional columns, namely a read monitor column (RM) , a write monitor column (WM)  and a buffer indicator column (BUF) . Entries in these columns are typically binary indicators. In particular, a RM entry in the RM column  is set on a cache line basis for a particular thread, and indicates whether or not a block of data in the data column  should be monitored to determine if the data in the data column  is written to by another thread. A WM entry in the WM column  is set on a cache line basis for a particular thread, and indicates whether or not the block of data in the data column  should be monitored to determine if the data in the data column is read by or written to by another thread. A BUF entry in the BUF column is set on a cache line basis for a particular thread , and indicates whether or not data in an entry of the data column  is buffered data or if the data is cached data. In particular, the BUF entry can indicate whether a block of data is taken out of cache coherence or not.","Notably, while the RM column , the WM column , and BUF column  are treated as separate columns, it should be appreciated that these indicators could be in fact combined into a single indicator. For example, rather than using one bit for each of the columns, two bits could be used to represent certain combinations of these indicators collectively. In another example, RM column , the WM column , and BUF column  may be represented together with the MESI indicators in the MESI column . These seven binary indicators (i.e. M, E, S, I, RM, WM, and BUF) could be represented with fewer bits.","Notably, the indicators in the RM column , the WM column , and BUF column  may be accessible to a programmer using various programming instructions made accessible in a processor's instruction set architecture.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 1B","b":["112","104","112","112","134","136","138"]},"Illustrating now an example, a software designer may code instructions that when executed by the thread - cause a read monitor indicator to be set for a memory block. If another thread writes to an address in the monitored memory block, such a conflicting access causes the read monitor indicator to be reset, and accumulates in the loss of read monitor entry . A similar case applies when a write monitor indicator is set, and another thread reads or writes to an address in the monitored memory block, causing the write monitor to be reset, and accumulates in the loss of write monitor entry .",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 1B","b":["114","114","114","140","142","146"]},"For example, and continuing with the example above where a software designer has coded instructions that when executed by the thread - cause a read monitor indicator to be set for a memory block, if another thread writes to an address in the memory block, in addition to noting such access in the read monitor entry , the read monitor indicator in the read monitor column  may be reset.","Embodiments may include the use of specialized hardware instructions to address garbage collection, exception handling and transactional memory correctness and efficiency concerns.","Card Tables","When executing in implicit cache resident CRITM (hardware only implicit mode) or CRISTM (hardware assisted implicitly buffered and monitored software mode) mode, both the managed code and the native code in the managed execution engine (CLR-STM) implicitly monitor\/buffer all data accesses. This can lead to false contention and unavoidable transaction rollback and reexecution. For example, in the common language runtime (CLR), a store to an object-reference-typed field of an object in the heap always incurs a card marking GC write barrier code sequence to record establishment of certain inter-generational object references. As noted, GC involves the walking of memory to find objects that are in use to as to reclaim memory space that is no longer in use. Typically, newer generations of memory contain the most objects that are no longer in use. Thus generational garbage collection focuses on newer created objects while de-emphasizing older objects. However, references to newer generational objects can sometimes be store in fields of older generational objects. Thus, mechanisms nonetheless are included to check older objects by marks in the card table to indicate that some regions of older generations may include older generational objects where references to newer generational objects have been stored. This lets the GC scan the compact card table looking for potential young-to old references, instead of having to scan all live objects in the older generations.","The barrier maps the object pointer to an entry in a \u201ccard table\u201d, which in some embodiments is represented using a single byte, then does a byte store of 0xFF to that entry, or similarly marks the entry as set. Under CRTM or CRISTM, that store establishes a write monitor and buffering (WM+BUF) on its monitored or buffered blocks of memory (MBLK\/BBLK). The current CLR implementation of card marking uses a 1 B card to represent 1 KB of heap. So for MBLK_SIZE-64 B, two threads (one of which is in a cache resident transaction) could suffer a write-write conflict upon any concurrent object reference field stores to the same 64 KB aligned heap region.","To avoid such false sharing contention, in one embodiment such card marking code uses an explicit transaction escape action to perform non-monitored\/buffered accesses to such infrastructure data structures. Embodiments may be implemented where the CLR write barrier code sequence uses a specialized instruction where data load and store instructions are explicitly unmonitored and unbuffered to write the card table entry without adding it to the thread's transaction's write set. One example of this instruction may be represented herein as \u201cMOVXU.B\u201d If all such accesses to the card marking tables do not establish read or write monitoring, then these accesses can safely proceed concurrently, commute safely, etc.","This approach is correct even if a transaction's execution causes a card to be marked and then the transaction is subsequently rolled back, because it is benign (from a correctness perspective) to set a card. This merely notes there may be intergenerational object references from this card's memory block. This causes only extra work on the first subsequent GC when a check for objects no longer in use at the pointed to object are made, after which the card bit(s) are cleared if no intergenerational references remain there.","Also note, when used with a handler-based cache resident transaction, such escape actions tolerate being interrupted at any point (the handler is able to restore invariants) and such escape actions either guarantee that any MOVXU will not hit a buffered line, or tolerate skid due to MOVXU.","In an alternative embodiment, such escape actions are implemented by suspending and resuming an implicitly-buffered transaction, which allows execution of the escape action without modifying it to use MOVXU instructions.","Embodiments may refer to a number of methods and method acts that may be performed. It should be noted, that although the method acts may be discussed in a certain order or illustrated in a flow chart as occurring in a particular order, no particular ordering is necessarily required unless specifically stated, or required because an act is dependent on another act being completed prior to the act being performed. Further, it should be understood that the methods may be practiced by a computer system including one or more processors and computer readable media such as computer memory. In particular, the computer memory may store computer executable instructions that when executed by one or more processors cause various functions to be performed, such as the acts recited in the embodiments.","Referring now to , a method  is illustrated. The method  may be practiced in a computing environment including a hardware assisted transaction system. The method includes acts for writing to a card table. The method  includes beginning a hardware assisted transaction (act ). For example, as described above, reads and writes can be buffered and monitored to prevent conflicting reads and writes using the isolated cache memory structure described above.","The method  may further include determining that a write entry needs to be made to a card table to store a reference from one object to another object while the transaction is running (act ). For example in a generational garbage collection system, references may be made need to be made in a card table so that newer object created in older generational objects can be discovered. In particular, the method  may be practiced where performing an un-buffered non-transacted write to an entry in the card table in outside of the transaction is performed as part of intergenerational garbage collection.","The method  further includes performing an un-buffered non-transacted write to an entry in the card table outside of the transaction. For example, writing to the card table outside of the transaction may include executing a specialized instruction that performs an explicitly non-hardware transacted load and\/or store. Alternatively, the method  may further include suspending the transaction and writing to the card table outside of the transaction may be performed while the transaction is suspended. The method  may further include resuming the transaction after writing to the card table.","The method of  may further include aborting the hardware assisted transaction and rolling back any buffered writes performed during the transaction without rolling back the un-buffered non-transacted write to the card table. In particular, the write to the card table survives an aborted transaction. Thus, the method  may further include performing a garbage collection including checking for objects no longer in use at a location pointed to by the un-buffered non-transacted write to the card table. Clearing the card table entry once no intergenerational references remain as indicated by the card table entry may also be performed.","Heap Segment Allocation","GC modes typically use generational collection, in which most collections concentrate on the youngest generation, evacuating the live objects, leaving the youngest generation mostly empty. Allocation in the young generation is contiguous \u201cbump pointer\u201d allocation: there is a free pointer indicating the boundary between allocated and free space, and allocation determines whether there is enough space for a request; and, if so, increments the free pointer by the size of the allocation request and returns its old value. Inasmuch as the young generation is shared by all threads, this increment is performed using an atomic hardware operation.","However, performing all allocations this way would lead to unacceptable contention on the free pointer. Therefore, each thread allocates a thread-local allocation context, a block of free space of some moderate size, from the shared allocation space, and then allocates objects from this allocation context. In as much as the allocation context is local to its owning thread, no atomic hardware operations are necessary to allocate within it. When an allocation context is exhausted, the thread discards it and allocates a new one. Thus, the allocation contexts that a thread has used may be scattered somewhat randomly in the youngest generation.","In one embodiment, the CLR maintains a large object heap, in which objects larger than approximately 80K are allocated. Objects in the large object heap are not relocated. So consideration should be given to allocation in the large object heap.","The CLR is implemented such that when a GC occurs, the heap is (or can be made to be) walkable, (i.e. filled densely with objects, so that given a pointer to one object, a system can find the start of the next object by adding the current object size to the pointer). Thus, the only unallocated areas of the heaps should be the unallocated portions of in-use allocation contexts (which can be filled in with garbage objects before GC).","Embodiments may be implemented under the assumption that rollback is relatively rare, and thus allow some amount of garbage to be created as a result of an aborted transaction. Some embodiments try to avoid false sharing whenever possible, by preventing different threads from allocating on the same cache line.","Two implementations of small-object allocation are described: one in which all allocations are tentative, another in which all allocations are durable. These correspond somewhat naturally to the implicit and explicit hardware modes. However, special instructions allow durable writes in implicit mode, or tentative writes in explicit mode. Thus, embodiments can selectively choose to do definite allocations in implicit mode, or tentative allocations in explicit mode. Implementations of all four possibilities are described.","Implicit Mode\/Tentative Allocation. In implicit mode, writes are by default buffered, and a special action (either temporarily suspending the transaction, or using a specialized load and store instruction illustrated herein as PUMOV) is used to accomplish a durable store, i.e. one that will survive the transaction. A PUMOV store always writes to memory, but, if the target cache line is buffered, it also writes to the buffered version of the cache line. If the line is buffered, the PUMOV is potentially more expensive than a normal store, inasmuch as it may need to write to two cache lines.","Referring now to , when a (hardware) transaction starts, the thread executing the transaction will have a current allocation context , with some amount of free space. Before starting the hardware transaction, this remaining space will be filled with one or two \u201cgarbage objects:\u201d The CLR has a special type for this purpose, distinct from all user allocated types\u2014it is similar to an array in that it has a dynamic size, but does not need to have its elements initialized. First, (if needed) the end of the allocation context is rounded down to a cache-line boundary, and the remainder is filled with a small \u201calignment garbage object .\u201d Next, the remaining free space is filled with a (presumably) larger \u201cfill garbage object .\u201d The free pointer  of the allocation context remains unchanged, however, pointing to the start of the fill garbage object . The purpose of this fill garbage object  will be explained presently.  shows the state of initialize allocation context  before the start of the hardware transaction. In this state, the hardware transaction now starts. Allocations within allocation contexts are performed using the normal instruction sequences so that loads and stores are implicitly monitored and buffered (i.e. they are tentative). In particular, the free pointer  of the allocation context will be modified transactionally, and allocated space will be initialized transactionally\u2014this initialization includes writes to object header word, method table pointer, array size for arrays, and contents for ref-containing objects and arrays.","At some point the transaction may exhaust this allocation context and allocate a new one. In the CLR, the thread keeps no record of previously-used allocation contexts. This explains the purpose of the garbage objects: if the transaction aborts, the objects that were \u201callocated over\u201d the \u00a2Fill Garbage Object  disappear, leaving just the garbage object. This maintains the walkability of the heap.","As illustrated in , to allocate the new allocation context in implicit mode, the transaction is first suspended. Suspending the transaction can be accomplished using various instructions that cause the hardware to enter a non implicitly transactional state or a string of explicitly non-transactional loads and stores can be used. As discussed, the extra expense of exiting the transaction is affordable because allocation contexts are allocated infrequently. The new allocation context is allocated using the normal atomic compare-and-swap. Before resuming the transaction, the newly-allocated context is set up much as above. In this case, however, alignment garbage objects  and  are allocated at both ends of the allocation context if needed, the initial free  and end  pointers are adjusted as necessary, and a \u201cFill Garbage Object\u201d  is set up in the middle.","When the transaction commits, all of its modifications, in particular all of the initializations of objects it has allocated, are \u201creified\u201d\u2014inasmuch as these have overwritten the fill garbage objects, these have essentially disappeared. The final value of the free pointer  in the current allocation context is confirmed, and this context is now available for use by subsequent non-transactional code.","The above handles small-object allocation within allocation contexts. The following addresses large-object allocation. Added expense here is acceptable in view of the fact that large object allocation is both rare and expensive (the expense being dominated by the cost of zeroing the large object contents). Therefore, the transaction is suspended to accomplish the allocation.","Implicit Mode\/Durable Allocations. In general, it is a good idea in implicit mode to use durable, unbuffered\/monitored writes when possible, to reduce cache usage for buffering and monitoring that can lead to capacity-related aborts. Therefore it is useful to consider a variant in which, even in implicit mode, allocations are performed durably. This may interact synergistically with so-called new-object optimizations, where accesses to objects allocated within the current transaction do not need to be transacted, since they are not visible to other threads before the transaction commits. Thus, in a hardware-supported mode, such accesses could be made without monitoring or buffering. In an implicit hardware mode exploiting so-called \u201cnaked\u201d code generation, in which the code executed for the transactional and non-transactional version of a method is the same, embodiments may only exploit static new-object optimizations\u2014accesses to objects that embodiments can statically prove are allocated in the current transaction (if the method is executed in a transaction), may use a possibly-durable write or an unmonitored read, via a durable PUMOV instruction. For example, writes in constructors can always use PUMOV. The allocation stores that initialize an object to make it walkable can also use PUMOV. In a more optimal scenario when these encompass all the stores to a cache line, because there is never an additional implicitly buffered store, then embodiments can avoid buffering that cache line. In a less optimal scenario, however, there could be a price, inasmuch as a PUMOV may need to write to both a buffered line and to memory is therefore potentially more expensive than either a regular store or a buffered store.","Explicit Mode\/Durable Allocation. In explicit mode, transactional loads and stored are accomplished using explicit special hardware instructions (EML=Explicitly Monitored Load, and ESB=Explicitly Buffered Store). Normal loads and stores are non-transactional\u2014but a non-transactional store to a cache line that the thread has previously monitored or buffered causes the thread to lose monitoring or buffering, which generally means it is doomed. PUMOV will act like a non-transactional store if the target cache line is not buffered, or like an ESB if it is.","In view of the preceding, allocation can be accomplished as follows: All allocations will be definite: they will survive an aborting transaction. Large objects and allocation contexts are allocated normally, that is, non-transactionally. Explicit modes can be run with or without enabling automatic transition to an ejector handler on loss of monitoring or buffering. An ejection handler is a routine which the software instructs the hardware to invoke in case a hardware transaction is aborted, either synchronously by the code executing it, or asynchronously due to loss of monitoring or buffering, or due to overflowing the cache. If an ejector is enabled, embodiments, explicitly disable it while allocating large objects and allocation contexts, so that an asynchronous transfer to an ejector does not leave the heap in an inconsistent state.","Referring now to , within an allocation context, object of is allocated, which is then manipulated via transactional stores. In particular, embodiments store to the part of the o that extends onto the second cache line, causing the entire cache line to be buffered. If embodiments then allocate object o, and initialize its header and method table with non-transactional stores, buffering will be lost, and the transaction will be doomed. Therefore, embodiments use a PUMOV to do these initializing stores. This PUMOV writes through to memory as well as to a buffered cache line if the target cache line is buffered. Updates to the free pointer of the allocation context are performed non-transactionally.","Generally there is a free choice between zeroing out the contents of an allocation context when it is allocated, or on a per-object basis as they are allocated. The tradeoff is economies of scale for the bulk zeroing, against the possibility that cache lines will be brought in twice, once to zero and once to actually initialize in a constructor. In the definite allocation scheme, if embodiments zero at allocation time they will do so with the more-expensive write-through PUMOV. This may tip this trade-off in favor of zeroing at context allocation time.","If the ejector handler is enabled, object allocations occur too frequently to disable and re-enable. This can be handled, however, by paying careful attention to the order of operations during allocation. Space above the free pointer is considered garbage until the free pointer changes. Therefore, embodiments can initialize the object before incrementing the free pointer. If the transaction aborts before this, embodiments have just modified garbage; if after, the object is definitely allocated.","Explicit Mode\/Tentative Allocation. The unused space is initialized in an allocation context with allocation and fill garbage objects using durable writes just as in implicit mode. In explicit mode, embodiments can call a special allocation routine, so embodiments do not have to worry about the same allocation code being used inside and outside a transaction. This special allocation routine could use buffered writes to initialize objects.","In the discussion of tentative allocation, one embodiment filled a region with a garbage object durably, then overwrote it with tentative objects. When new-object allocations were discussed, it was suggested that embodiments might do some writes to objects durably, even in implicit mode. Care should be taken to ensure that these writes do not affect the walkability of the heap in the case where the transaction aborts. To be concrete, assume that a \u201cfiller garbage object\u201d looks like an integer array, containing an object header word, a method pointer, and an array size. Now assume that embodiments overwrite that by allocating a non-array object \u201co\u201d whose first field is \u201cf.\u201d The address of \u201co.f\u201d is the same as that of the array size field of the filler garbage object. If a constructor initializes \u201co.f\u201d durably, then the heap will not be walkable if the transaction aborts. Embodiments could fix this by not overwriting the filler garbage object, instead starting allocation after the header of this object, and tentatively overwriting the size field with 0. To optimize this, embodiments can write a single garbage object to be both the initial alignment garbage object, and the filler garbage object. The durable write would be the combined size, and embodiments would then tentatively overwrite this to only be the size necessary for alignment, and start allocation after this alignment size (ensuring that this is at least large enough to prevent the garbage object header from being overwritten.)","Another issue that can be taken into account with the \u201cfiller alignment\/garbage object\u201d plan is that unless embodiments take steps to prevent it, transactions that allocate no objects will gradually eat up allocation space by allocating filler objects. Embodiments might prevent this by keeping track of whether a transaction has allocated any memory. A transaction that commits without allocating memory could explicitly revert (using non-transactional stores after the hardware commit) to a recorded free-pointer value in the current local allocation context.","Garbage Collection Compacting","Certain TM modes rely on hardware read monitoring to continually validate the read set of a transaction\u2014including cache resident TM modes and some explicit HASTM modes. If a transaction on thread  reads some objects (or TMWs) and a GC occurs and on thread  the objects are copied elsewhere and computation continues, subsequent writes to those objects (at new addresses) will not cause a loss of read monitoring on thread , and this now inconsistent transaction may erroneously commit. Normally such a situation is averted by the GC suspending thread , which induces a transaction abort, but in some cases the GC may not require thread  to stop, in which case its transaction may survive ensuing in the above inconsistency,","A solution to this hazard is to have every such transaction first establish read monitoring on a common global variable, illustrated herein by example as GCMonitor, via an explicit instruction such as, is illustrated herein as SETRM (set read monitor), and have the memory manager write to GCMonitor each time it does any operation which may change objects' virtual addresses (such as a GC heap compaction). This will cause all hardware assisted transactions to abort so that garbage cllection activities can be completed.","Referring now to , a method  is illustrated. The method  may be practiced in a computing environment including a hardware assisted transaction system. The method  include acts for handling garbage collection compaction occurring when a hardware transaction is active. The method  includes beginning a hardware assisted transaction (act ). As part of the hardware assisted transaction, the method  includes setting a read monitor on a common global variable (act ). In one embodiment, setting a read monitor on a common global variable includes using an explicit set read monitoring instruction included as part of an instruction set architecture for the hardware used in the hardware assisted transaction. The method further includes instructing one or more agents to write to the common global variable any time an operation is performed which may change an object's virtual address (act ).","The method  may further include, an agent writing to the common global variable, causing the hardware assisted transaction to abort. In some embodiments, the agent writing to the common global variable may be a memory manager. The memory manager may write to the common variable as a result of the memory manager performing a memory heap compaction.","Exception Handling","Embodiments may also be configured to implement an overall-high performance unbounded TM system with rich semantics, to go beyond what can be achieved with a bounded hardware TM, including allowing fast cache resident transactions to execute alongside software TM transactions (even those on software threads that are not scheduled to cores).","One of the sub problems is to implement correct and functional managed code exception handling in the two anticipated cache resident modes, CRITM and CRESTM. In particular embodiments are configured to handle 1) the sojourn through the OS when the exception is raised, 2) successfully catch and handle the exception without aborting the transaction, and 3) in the event the exception is uncaught and leaves the atomic block, with validating the transaction and then correctly marshal the transactionally updated state, which is present only in buffered cache lines, out of the transaction, before aborting the transaction and invalidating the buffered lines. In the embodiments illustrated below, marshaling is accomplished by serializing the transactionally updated state out of the transaction before rolling back the transaction, thus preserving the transactionally updated state.","Note that when an exception is raised, it is possible to abort the cache resident transaction, flush hardware buffered state, and reexecute the transaction in a simple STM mode, to rerun to the point of the exception, but this wastes the work already invested in advancing the computation to the exception site. Furthermore, in some cases, by having a transaction transition to STM, can cause all the extant CRITM transactions in the system to abort and reexecute in a slower and more expensive mode such as CRESTM, HASTM, or STM. As such, embodiments may be optimized to dispatch and handle the exception in the original cache resident mode.","A first part of some embodiments includes the ability to have a UTM hardware assisted transaction executing, with certain cache lines monitored and buffered, and sojourn into the kernel on an exception, and resume to user mode SEH (structured exception handling) exception dispatch, without necessarily losing the monitored and buffered lines.","A description of what happens in kernel\/user exception dispatch in x86 SEH can be found at http:\/\/www.nynaeve.net\/?p=201, which is incorporated herein by reference in its entirety. This description reads as follows: \u201cKiUserExceptionDispatcher is the routine responsible for calling the user mode portion of the SEH dispatcher. When an exception occurs, and it is an exception that would generate an SEH event, the kernel checks to see whether the exception occurred while running user mode code. If so, then the kernel alters the trap frame on the stack, such that when the kernel returns from the interrupt or exception, execution resumes at KiUserExceptionDispatcher instead of the instruction that raised the fault. The kernel also arranges for several parameters (a PCONTEXT and a PEXCEPTION RECORD) that describe the state of the machine when the exception occurred to be passed to KiUserExceptionDispatcher upon the return to user mode. (This model of changing the return address for a return from kernel mode to user mode is a common idiom in the Windows kernel for several user mode event notification mechanisms.)\u201d","\u201cOnce the kernel mode stack unwinds and control is transferred to KiUserExceptionDispatcher in user mode, the exception is processed locally via a call to RtlDispatchException, which is the core of the user mode exception dispatcher logic. If the exception was successfully dispatched (that is, an exception handler handled it), the final user mode context is realized with a call to RtlRestoreContext, which simply loads the registers in the given context into the processor's architectural execution state.\u201d","Returning now to the present embodiments consideration is given to what happens next in CRITM (cache resident, implicit TM) mode and CRESTM (cache resident, explicit, STM-locks-respecting, TM mode).","In either mode, the SEH exception dispatch chain is walked in search of an exception handler that handles the exception. If one handles the exception (EXCEPTION_EXECUTE_HANDLER), the stack is unwound (calling unwind handlers) and execution resumes at the handler. If a handler causes the faulted instruction to reexecute (EXCEPTION_CONTINUE_EXECUTION), then the instruction reexecutes. In either case, in CRITM, if a loss of monitoring or buffering occurs, embodiments can transfer to the transaction's ejection handler, the transaction will be aborted and reexecuted. If (CRESTM) monitoring or buffering is lost, execution continues normally but the transaction becomes doomed.","If every handler does not handle the exception (EXCEPTION_CONTINUE_SEARCH) then embodiments may eventually come to the exception handler for the atomic block. In .NET\u00ae STM the semantics of an unhandled exception (whether an \u201casynchronous\u201d exception or user-thrown object) leaving the Atomic.Do() block are 1) abort the transaction while 2) propagating the exception further. Inasmuch as aborting a cache resident transaction ensures all of its buffered updates are discarded, embodiments marshal the transaction state to non-buffered data, then abort the hardware transaction support, then unmarshal it into a new exception object and rethrow that.","The following develops representative code using .NET\u00ae code generated from an Atomic.Do block that supports CRITM and CRESTM execution, given the context for the interaction between the block's exception handler for CRESTM transaction abort, and the CRITM ejection handler+setjmp\/longjmp for \u201casynchronous\u201d CRITM transaction abort.","Transaction Boundaries. Attention is now directed to how a lexical atomic block should be translated. Because this is complicated, three translaaations are presented. The first assumes that that CRESTM and STM are the only execution modes, the second will assume that CRITM is the only execution mode, and the third will attempt to allow for all three possibilities.","If CRESTM and STM are the only execution modes, then the translation is:",{"@attributes":{"id":"p-0120","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"atomic { S }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2192"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"curtx = CreateTx(curtx, ConstantSiteId);"]},{"entry":[{},"<save live locals to \u201cshadow variables\u201d on stack.>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2002L:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"curTx.StartHWTx( ); \/\/ Begin the current hw tx if embodiments are"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"using it."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"try {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ First arg indicates transform style."]},{"entry":[{},"STMTransform(CGSTYLE_TV, S); \/\/ transaction virtual"]},{"entry":[{},"transform style"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} catch (Object ex) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<restore locals from shadow variables on stack>"]},{"entry":[{},"curtx.HandleEX(ex); \/\/ Roll back TX and return, else throw."]},{"entry":[{},"goto L;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the preceding, embodiments start creating the transaction. After that, embodiments start the HW transaction if the current execution mode is using hardware acceleration. The transaction executes. If it rolls back, embodiments reach the catch clause, inasmuch as embodiments are using exception-based rollback. Embodiments may marshal and rethrow an aborting user execution.","If CRITM is the only execution mode, then the translation is:",{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"atomic { S }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2192"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"curtx = CreateTx(curtx, ConstantSiteId);"]},{"entry":[{},"<save live locals to \u201cshadow variables\u201d on stack.>"]},{"entry":[{},"curtx.SaveSetjmpState( );"]},{"entry":[{},"if (curtx.IsRexec( )) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<restore locals from shadow variables on stack>"]},{"entry":[{},"\/\/ Could decide on (re-)execution mode here."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"curTx.StartHWTx( ); \/\/ Begin the current hw tx"]},{"entry":[{},"try {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ First arg indicates transform style."]},{"entry":[{},"STMTransform(CGSTYLE_NK, S); \/\/ naked transform style"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} catch (Object ex) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<restore locals from shadow variables on stack>"]},{"entry":[{},"curtx.HandleEx(ex); \/\/ Marshal ex; Roll back TX; throw."]},{"entry":[{},"assert(false);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The ejector will restore the saved register values, and jump to the saved IP. Note, by the way, that the \u201cnaked\u201d (indicated by NK) transformation of S is not precisely equal to S: embodiments will still have to do some explicit things to commit the transaction when control flow leaves S. Inasmuch as embodiments are using longjmp-based rollback, only user-level exceptions that are being thrown reach the catch clause. HandleEx would deep-clone the exception, abort the hardware transaction, and then re-throw the cloned exception.","A combined translation, then, could be something like",{"@attributes":{"id":"p-0126","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"atomic { S }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2192"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"curtx = CreateTx(curtx, ConstantSiteId);"]},{"entry":[{},"<save live locals to \u201cshadow variables\u201d on stack.>"]},{"entry":[{},"if (curtx.LongjmpRollback( )) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"curTx.SaveSetjmpState( );"]},{"entry":[{},"if (curtx.IsRexec( )) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<restore locals from shadow variables on stack>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Could decide on (re-)execution mode here."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"L: curtx.StartHWTx( ); \/\/ Begin the current hw, if HW is being used."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"try {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (curtx.CodeGenStyle( ) == CGSTYLE_NK) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ First arg indicates transform style."]},{"entry":[{},"STMTransform(CGSTYLE_NK, S);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STMTransform(CGSTYLE_TV, S);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} catch (Object ex) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<restore locals from shadow variables on stack>"]},{"entry":[{},"curtx.HandleEx(ex); \/\/ Roll back TX and return, else throw."]},{"entry":[{},"goto L;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"CRITM_Tx::HandleEx(ex) is called for CRISTM running in implicit cache resident transaction mode (MB_DATA or MB_ALL). CRESTM_Tx::HandleEx(ex) is called for CRESTM running in explicit cache resident mode. In either case, when the thrown user exception will escape the atomic block, embodiments serialize the exception object, abort the transaction, then deserialize a copy of the exception, and rethrow that.","In the .NET\u00ae STM there are at least two good ways to do that. 1) the CLR has a built-in native object graph cloner that is used to efficiently marshal\/unmarshal objects (including exceptions) that are passed between AppDomains. 2) the .NET\u00ae Serialization framework supports for serializing\/deserializing objects to MemoryStream or byte[].","Either way, as embodiments serialize or clone the exception, embodiments read its current fields using the transactions' view, e.g. read fields from their possibly buffered lines, and embodiments write the serialized byte stream using direct (non-buffered) writes. There is a simple implementation of this. If in CRISTM, embodiments can start an escape action by suppressing implicit mode (TX). Embodiments will still read the buffered lines of the exception object graph, meanwhile any writes performed to allocate and write the MemoryStream are direct (not buffered) and will survive the rollback of the cache resident state, assuming embodiments arrange for no newly allocated serialization objects to share BBLKs with buffered ones. (Alternately embodiments can play it safe by using MOVXU for all such stores.)",{"@attributes":{"id":"p-0130","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Simple sketch; note, called while CRITM transaction still extant and"},{"entry":"valid"},{"entry":"\/\/"},{"entry":"\/\/ Marshal object state out of transaction, abort the transaction, and"},{"entry":"rethrow."},{"entry":"\/\/ Simple return causes reexecution when transaction was inconsistent"},{"entry":"\/\/"},{"entry":"object CRITM_Tx::HandlerEx(ex) {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"_asm { TX } \/\/ suppress implicit mode transactions"]},{"entry":[{},"using (MemoryStream s = new MemoryStream( )) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BinaryFormatter f = new BinaryFormatter( );"]},{"entry":[{},"f.Serialize(s, ex); \/\/ reads buffered data, and establish"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"monitoring, but directly writes data into \u2018s\u2019"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"_asm { TXC } \/\/ rollback\/clear UTM state"]},{"entry":[{},"\/\/ if embodiments got here, the transaction was valid at the"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"point of serializing the exception"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"s.Position = 0; \/\/ rewind"]},{"entry":[{},"throw f.Deserialize(s);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The code is similar for CRESTM, but embodiments explicitly validate the transaction before rethrowing the deserialized exception.",{"@attributes":{"id":"p-0132","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Simple sketch; note, called while CRESTM transaction still extant"},{"entry":"\/\/"},{"entry":"\/\/ Marshal object state out of transaction, abort the transaction, and"},{"entry":"rethrow."},{"entry":"\/\/ Simple return causes reexecution when transaction was inconsistent"},{"entry":"\/\/"},{"entry":"object CRESTM_Tx::HandlerEx(ex) {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ arrange for this code to be in a CRESTM escape action -- that is,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"do not instrument this code"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ with CRESTM read\/write barriers and buffered stores"]},{"entry":[{},"using (MemoryStream s = new MemoryStream( )) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BinaryFormatter f = new BinaryFormatter( );"]},{"entry":[{},"f.Serialize(s, ex); \/\/ reads buffered data, and establish"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"monitoring, but directly writes data into \u2018s\u2019"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"bool fValid = this.Validate( );"]},{"entry":[{},"_asm { TXC } \/\/ rollback\/clear UTM state"]},{"entry":[{},"if (!fValid)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return; \/\/ reexecute the transaction"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"s.Position = 0; \/\/ rewind"]},{"entry":[{},"throw f.Deserialize(s);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Referring now to , a method  is illustrated. The method  may be practiced in a computing environment including a hardware assisted transaction system. The method  includes acts for handling exceptions while in a hardware assisted transaction. The method  includes beginning a hardware assisted transaction (act ). The method  further includes raising an exception while in the hardware assisted transaction, including creating an exception object (act ). The method  further includes determining that the transaction should be rolled back (act ). As a result of determining that the transaction should be rolled back, the method  includes marshaling the exception object out of the hardware assisted transaction (act ).","The method  may further include rolling back the hardware assisted transaction after the exception object is marshaled out of the hardware assisted transaction. This embodiment may further include determining that the hardware assisted transaction was valid after rolling back the hardware assisted transaction, and as a result, re-throwing the exception object marshaled out of the hardware assisted transaction.","The method  may further include determining that the hardware assisted transaction was invalid by the time the exception object is marshaled out of the hardware assisted transaction, and as a result, re-executing the transaction. Re-executing the transaction may include re-executing using a hardware assisted transaction, as in the first instance, using a hardware assisted transaction that respects software locks, (such as CR*STM discussed above) or using a software only transaction.","The method  may be practiced where marshaling the exception object out of the hardware assisted transaction includes performing monitored and buffering obeying reads from the source exception object and non-buffered writes of the marshalled exception object.","Embodiments of the present invention may comprise or utilize a special purpose or general-purpose computer including computer hardware, as discussed in greater detail below. Embodiments within the scope of the present invention also include physical and other computer-readable media for carrying or storing computer-executable instructions and\/or data structures. Such computer-readable media can be any available media that can be accessed by a general purpose or special purpose computer system. Computer-readable media that store computer-executable instructions are physical storage media. Computer-readable media that carry computer-executable instructions are transmission media. Thus, by way of example, and not limitation, embodiments of the invention can comprise at least two distinctly different kinds of computer-readable media: physical storage media and transmission media.","Physical storage media includes RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store desired program code means in the form of computer-executable instructions or data structures and which can be accessed by a general purpose or special purpose computer.","A \u201cnetwork\u201d is defined as one or more data links that enable the transport of electronic data between computer systems and\/or modules and\/or other electronic devices. When information is transferred or provided over a network or another communications connection (either hardwired, wireless, or a combination of hardwired or wireless) to a computer, the computer properly views the connection as a transmission medium. Transmissions media can include a network and\/or data links which can be used to carry or desired program code means in the form of computer-executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. Combinations of the above should also be included within the scope of computer-readable media.","Further, upon reaching various computer system components, program code means in the form of computer-executable instructions or data structures can be transferred automatically from transmission media to physical storage media (or vice versa). For example, computer-executable instructions or data structures received over a network or data link can be buffered in RAM within a network interface module (e.g., a \u201cNIC\u201d), and then eventually transferred to computer system RAM and\/or to less volatile physical storage media at a computer system. Thus, it should be understood that physical storage media can be included in computer system components that also (or even primarily) utilize transmission media.","Computer-executable instructions comprise, for example, instructions and data which cause a general purpose computer, special purpose computer, or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be, for example, binaries, intermediate format instructions such as assembly language, or even source code. Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the described features or acts described above. Rather, the described features and acts are disclosed as example forms of implementing the claims.","Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations, including, personal computers, desktop computers, laptop computers, message processors, hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, mobile telephones, PDAs, pagers, routers, switches, and the like. The invention may also be practiced in distributed system environments where local and remote computer systems, which are linked (either by hardwired data links, wireless data links, or by a combination of hardwired and wireless data links) through a network, both perform tasks. In a distributed system environment, program modules may be located in both local and remote memory storage devices.","The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is, therefore, indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order to describe the manner in which the above-recited and other advantages and features can be obtained, a more particular description of the subject matter briefly described above will be rendered by reference to specific embodiments which are illustrated in the appended drawings. Understanding that these drawings depict only typical embodiments and are not therefore to be considered to be limiting in scope, embodiments will be described and explained with additional specificity and detail through the use of the accompanying drawings in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
