---
title: Inheritance context for graphics primitives
abstract: An inheritance context is created for a graphics primitive object that is a property of a visual element. The inheritance context can be used to make some element information (e.g., information in resource dictionaries, name dictionaries, and inheritable properties that reside in the element tree containing the visual element) available to the graphics primitive object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07743387&OS=07743387&RS=07743387
owner: Microsoft Corporation
number: 07743387
owner_city: Redmond
owner_country: US
publication_date: 20051018
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","EXAMPLE 1","EXAMPLE 2","EXAMPLE 3","EXAMPLE 4","EXAMPLE 5","EXAMPLE 6","EXAMPLE 7","EXAMPLE 8"],"p":["In some interactive systems, visual elements can be implemented in an interface. In some such systems, the visual elements are organized in a tree structure (i.e., an element tree). The various elements of the element tree can have properties and resources that can be \u201cinherited\u201d by other \u201cchild\u201d elements of the element tree. Further, the visual elements may be implemented using graphics primitives such as brushes, pens, transforms, geometry and the like. For example, a button being displayed in a user interface (UI) can be implemented so that it has a specified background color. However, the graphics primitives are generally not linked to the element tree in a way that allows the graphics primitives to use the inheritance features of the element tree. This background information is not intended to identify problems that must be addressed by the claimed subject matter.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detail Description Section. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","According to aspects of various described embodiments, implementations are provided for creating an inheritance context for a graphics primitive object that is a property of a visual element. The inheritance context can advantageously make some element information (e.g., information in resource dictionaries, name dictionaries, and inheritable properties that reside in the element tree containing the visual element) available to the graphics primitive object.","Embodiments may be implemented as a computer process, a computer system (including mobile handheld computing devices) or as an article of manufacture such as a computer program product. The computer program product may be a computer storage medium readable by a computer system and encoding a computer program of instructions for executing a computer process. The computer program product may also be a propagated signal on a carrier readable by a computing system and encoding a computer program of instructions for executing a computer process.","Various embodiments are described more fully below with reference to the accompanying drawings, which form a part hereof, and which show specific exemplary embodiments for practicing various embodiments. However, other embodiments may be implemented in many different forms and should not be construed as limited to the embodiments set forth herein; rather, these embodiments are provided so that this disclosure will be thorough and complete. Embodiments may be practiced as methods, systems or devices. Accordingly, embodiments may take the form of a hardware implementation, an entirely software implementation or an implementation combining software and hardware aspects. The following detailed description is, therefore, not to be taken in a limiting sense.","The logical operations of the various embodiments are implemented (1) as a sequence of computer implemented steps running on a computing system and\/or (2) as interconnected machine modules within the computing system. The implementation is a matter of choice dependent on the performance requirements of the computing system implementing the embodiment. Accordingly, the logical operations making up the embodiments described herein are referred to alternatively as operations, steps or modules.","Exemplary Operating Environment",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":["100","100","100","100"]},"Embodiments are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the embodiments include, but are not limited to, personal computers, server computers, hand-held or laptop devices, tablet devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","Embodiments may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, and so forth, which perform particular tasks or implement particular abstract data types. Embodiments may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system includes a general purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, Accelerated Graphics Port (AGP) bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","The computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and includes both volatile and nonvolatile media, and removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules  and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk  , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, discussed above and illustrated in , provide storage of computer-readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules  and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers herein to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a tablet (electronic digitizer) , a microphone , a keyboard  and pointing device , commonly referred to as mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . The monitor  may also be integrated with a touch-screen panel  or the like that can input digitized input such as handwriting into the computer system  via an interface, such as a touch-screen interface . Note that the monitor and\/or touch screen panel can be physically coupled to a housing in which the computing device  is incorporated, such as in a tablet-type personal computer, wherein the touch screen panel  essentially serves as the tablet . In addition, computers such as the computing device  may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface  or the like.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface  or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Example Layered Architecture One aspect is generally directed towards providing smooth, complex animations and\/or media on computer systems. To this end, as generally presented in , a media integration layer architecture  is provided. An application program, control or other similar higher-level program code (e.g., a user interface of an operating system component)  accesses the media integration layer architecture  via a set of application programming interfaces (APIs)  or the like, to access (write or read) graphical information. Note that although many of the examples described herein will refer to an application program interfacing with the APIs, it is understood that other higher-level program code and components (e.g., a user interface of the operating system) will also be able to interface with the lower-level components described herein. As such, any reference to such higher-level program code, whether referred to as an application program, user interface, and so on, should be considered equivalent.","In one implementation, the media integration layer architecture  includes a high-level composition and animation engine , timing and animation components , and a low-level composition and animation engine . As used herein, the terms \u201chigh-level\u201d and \u201clow-level\u201d are similar to those used in other computing scenarios, wherein in general, the lower a software component relative to higher components, the closer the component is to the hardware. Thus, for example, graphics information sent from the high-level composition and animation engine  may be received at the low-level compositing and animation engine , where the information is used to send graphics data to the graphics subsystem including the hardware.","In general, the high-level composition and animation engine (also referred to herein as the high-level compositor and animator or the high-level engine or component)  builds a display element tree to represent a graphics scene provided by the application program , while the timing and animation components provide declarative (or other) animation and timing control. The low-level compositing and animation engine (also referred to herein as the low-level compositor and animator or low-level engine or component)  composes the renderings for the scenes of multiple applications, and with rendering components, implements the actual rendering of graphics to the screen. Note, that it is still possible to do time-consuming or application-specific rendering at a higher levels, and pass references to a bitmap or the like to the lower layers.","The high-level composition and animation engine  builds the element tree structure and traverses the structure, creating rendering instructions and simple animation intervals to be passed to the low-level compositing and animation engine . The rendering instructions generated by the high-level compositor may contain timing and animation information. The low-level compositing and animation engine  takes the rendering instructions and animation intervals and manages the animating, rendering and composing the scene that is then provided to the graphics subsystem (e.g., the graphics software and hardware) . Alternatively or in addition to locally displayed output, the high-level composition and animation engine  (or one similar thereto) may provide the rendering and animation instructions in an appropriate format to lower-level printing code  for sending fixed image data to a printer  or the like, and\/or may provide rendering instructions and simple animation intervals in an appropriate format to a lower-level terminal transport server  for transmission to remote machines . Note that richer information also may be passed across the network, e.g., it may be desirable to have the remote machine handle mouse rollover effects locally, without any network traffic.","In this implementation, the media integration layer architecture  thus separates graphics processing into multiple levels, and each of these levels performs some intelligent graphics processing which together allows applications' user interfaces and the like  to output graphics with smooth animation, composite the graphics with the graphics of other applications, and work with video frames. The animation and\/or compositing may also be synchronized with audio output. For example, by synchronizing audio with the frame rate at the low-level component, the timing of audio can essentially be exact with that of video or graphics, and not dependent on the ability of task-scheduled, complex pre-processing to keep up with the refresh rate.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3","b":["302","304","304","314"]},"In general, an element is an object in the element layer that participates in the property system, triggering and layout\/presentation system. The parser  finds tags and decides if those tags help to define an element or a resource object. In the special case of a VisualBrush, for example, the same tags may be interpreted as elements or also interpreted as resource objects, depending on the context of where those tags appear, e.g., depending on whether appearing in complex property syntax or not, as described in U.S. patent application Ser. No. 10\/401,717.","In addition to being present inline in the markup, a resource instance may be located elsewhere (e.g., in the markup or in a file, which can be local or on a remote network and appropriately downloaded), and referenced by a name, (e.g., a text name, reference or other suitable identifier). In this manner, a scene designer can reuse an element in the element tree throughout a scene, including elements described by the complex property syntax.","The parser  handles markup in the complex property syntax by accessing the type converter  as necessary, and also by matching specified parameters to the object properties, thereby handling the complexity for the scene designer. Thus, the parser  does not just set up the objects, but also sets properties on the objects. Because the same rendering model is shared between the element level and the API level, many of the objects are essentially the same. This makes parsing\/translation highly efficient, and also allows different types of programming languages (e.g., C#-like languages) the ability to easily convert from the markup to its own syntax, and vice-versa. Note that as represented in , another such programming language  (which may comprise compiled markup) can add elements to the element tree , or can directly interface with the visual API layer .","As also represented in , the same markup  may be used to program at an element level and a resource level. In general, the element level gives the scene designer full programmability, usage of the property system that provides inheritance (e.g., style-sheet like features), and triggering (e.g., whereby an element may have attached code to change its appearance, position and so forth in response to a user input event or action). However, various embodiments also provide a resource-level mechanism by which scene designers can essentially shortcut the element tree and program directly to the visual API layer. For many types of static shapes, images and the like where element-level features are not needed, this provides a more efficient and lightweight way to output the appropriate object.","For purposes of controlling animation and media output, a timing tree comprising clocks is also maintained. In general, the high-level compositor and animator engine  performs complex processing (sometimes referred to as compiling) that significantly simplifies the amount of processing and significantly reduces the amount of data that lower levels need to deal with to render the correct output. Note, however, that the amount and type of processing that is performed by the higher level may be dependent to a significant extent on the load, configuration and capabilities of the lower levels. For example, if high capability graphics hardware is present, the higher level may do a lesser amount of processing, and vice-versa. The high-level and low-level layers are adaptive to these factors.","In general, animation is accomplished by both the high-level compositor and animation engine  and the low-level compositor and animation engine . In one implementation, the high-level engine  traverses the scene and updates animation parameters with intervals for later interpolation, and packages these simplified data structures into instructions that get passed to the lower-level engine . This may be done in a synchronous and\/or asynchronous manner. The interval data can be considered as including the timing endpoints (start and end timing data), as well as the parameterized values for the rendering instruction. Note that the high-level engine  can perform some or all of a requested interpolation, e.g., if an interpolation or other motion function is too complex for the lower-level engine  to handle, or the lower-level cannot keep up with the processing demands placed thereon, the higher-level engine can perform some or all of the calculations and provide the lower-level with simplified data, instructions, tessellations, and so on to accomplish the desired result.","In a typical case when the lower level does perform interpolations, for each frame of animation, the low-level engine  interpolates the parameter intervals to obtain instantaneous values, and decodes the instructions into rendering commands executed by the graphics device. The graphics device composes the final scene adding any video frames that might be present in the scene. Other data also may be added, such as content protected by digital rights management.","The high-level engine  thus traverses the scene data-structures, computes an interval describing each animated parameter for a period of time, and passes these intervals and simplified parameterized drawing instructions to the low-level engine . The parameter data includes start time, end time, interpolator and interpolation data. By way of example, instead of erasing and redrawing an image so that it appears to move, the high-level compositor and animation engine  can instruct the low-level compositor and animation engine  as to how the image should change over time, e.g., starting coordinates, ending coordinates, the amount of time (interval) that the image should move between the coordinates, and a motion function such as linear; (note that motion is not required for animation, as a stationary object may be animated by changing its color property, for example). The low-level compositor and animation engine  will interpolate to determine new positions between frames, convert these into drawing instructions that the graphics device can understand, and pass the commands to the graphics device. Each pass of the high-level engine  preferably provides sufficient data for the low-level engine  to perform smooth animation over several frames.","The low-level (e.g., fast-tick) engine  is a separate task from the high-level engine . The low-level engine  receives the simplified parameterized drawing instructions and parameter intervals describing the scene from the high-level engine . The low-level engine maintains and traverses these data structures until new ones are provided by the high-level engine . The low-level engine may service multiple high-level engines , maintaining separate data structures for each. The one-to-many relationship between the low-level engine  and high-level engine  allows the system to smoothly animate multiple scenes simultaneously.","The low-level engine  interpolates essentially instantaneous animation parameters based on the high-level engine's provided intervals, updates drawing instructions and renders the scene for every frame. The low-level engine  task runs at a high priority on the system, to ensure that frames are ready for presentation such as at the graphics hardware screen refresh rate. The interpolations performed by the low-level engine  are thus typically limited to simple, fast functions such as linear, piecewise linear, cubic spline and those of similar speed.","With respect to animation and media, a program such as the application program , specifies animation property values along with timing information, referred to as clocks or clock properties, to the high-level component . As described below, essentially any independent animation or media (e.g., linear media such as video and audio), as well as a storyboard that coordinates specified animations, will have a clock maintained for it at the high-level component. In general, the author specifies timeline data that is instantiated into the clocks as appropriate to keep them synchronized.","In general, animations and linear media are associated with a set of clocks which are related to each other by synchronization primitives and rules. The clocks may be hierarchically arranged, e.g., the application program has a parent clock, and animated objects of the application program are children, which in turn may have other children. When a property of a clock is defined or modified, any children of that clock are affected. For example, pausing a parent clock pauses any of its child clocks, and doubling the speed of a parent clock doubles the speed of any of its child clocks.","These clock properties may be modified by source events comprising interactive control events initiated by the application at run-time. Thus, the clocks are interactive, in that each clock can be individually started, paused, resumed and stopped at arbitrary times by the application, e.g., in response to user input. In addition, new clocks can be added to the timing structure, and existing clocks can be removed.","As described in aforementioned U.S. patent application Ser. No. 10\/693,822,the high-level timing component may generate an interval list for each clock based on a stored list of events (begin, pause, and so forth) and the associated synchronization primitives. The activation intervals are straightforward, non-overlapping segments that describe the time expressed by a given clock at different points in real-world time.","Graphics Primitives","As used herein, graphics primitives are objects that support cloning, such as Freezables, (e.g., brush, transform, geometry and the like). Graphics primitives are used to set properties of visual elements such as FrameworkElement of the class hierarchy defined in the programming model for a version of the Windows\u00ae operating system developed by Microsoft Corporation, Redmond, Washington. For example, a brush is a Freezable that can set the background of a button or panel by cloning the original background information and then operating on the cloned information, such that the original information may be restored. Note that Freezable is a subclass of DependencyObject in the aforementioned class hierarchy (which is above FrameworkElement in the class hierarchy). An example element tree with visual element objects are described below.","Example Element Tree with Inheritance Context",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 4","b":["400","400","402","404","406","408","400"]},"Further, in this example, button  includes a graphics primitive for at least one of its properties. In accordance with this embodiment, the graphics primitives include inheritance context that provides a link between the graphic primitive (and its children, if any) and button . In one embodiment, the inheritance context is provided only for unshared graphics primitives. An example is described in conjunction with  below.","The inheritance context allows the graphic primitive to find button  (and its parent elements) and the properties, name dictionaries and resource dictionaries of button  and its parents (e.g., listbox  and window ). In some scenarios, the graphic primitive can implement databinding with a data source such as, for example, a property or name dictionary. The inheritance context allows the databinding to work in both markup and code. Similarly, for a dynamic resource reference in a graphics primitive, the resource reference can be resolved because the inheritance context allows the graphics primitive to walk up the element tree to find the resource.","In contrast, in some conventional systems, a databinding on a graphics primitive would have to be done in code (e.g., the databinding is explicitly given a source) in order for the binding to work for inheritable properties and name dictionaries residing in the element tree. Further, the dynamic resource reference would not be able to resolve because there is no \u201cmechanism\u201d by which the graphics primitive will know which element to begin walking up to find the dynamic resource. Example  below illustrates this unworkable scenario.",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Window>"]},{"entry":[{},"\u2003\u2003<Window.Resources>"]},{"entry":[{},"\u2003\u2003\u2003<Color x:Key=\u201dStop1\u201d>Red<\/Color>"]},{"entry":[{},"\u2003\u2003\u2003<Color x:Key=\u201dStop2\u201d>Blue<\/Color>"]},{"entry":[{},"\u2003\u2003<\/Window.Resources>"]},{"entry":[{},"\u2003\u2003<Rectangle>"]},{"entry":[{},"\u2003\u2003\u2003<Rectangle.Fill>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<LinearGradientBrush>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<SolidColorBrush Color=\u201d{DynamicResource Stop1}\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003<SolidColorBrush Color=\u201d{DynamicResource Stop2}\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/LinearGradientBrush>"]},{"entry":[{},"\u2003\u2003\u2003<\/Rectangle.Fill>"]},{"entry":[{},"\u2003\u2003<\/Rectangle>"]},{"entry":[{},"..."]},{"entry":[{},"<\/Window>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In Example 1, a Rectangle is to be filled using a graphics primitive object LinearGradientBrush. The \u201cendpoint\u201d colors of the LinearGradientBrush are SolidColorBrush objects that each references a dynamic resource for the colors. It is intended that the rectangle will be filled with a color that linearly varies from one color to another color; however, because the visual element are not parent of graphic primitives in conventional systems, the SolidColorBrush objects cannot find the dynamic resource library.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 5","FIG. 4"],"b":["500","500","408","400","502","408"]},"In this example, button  has a property for the background color of the button, which is defined using a linearly graded brush  (i.e., a graphics primitive object). Linear gradient brush  in turn has properties defining the endpoint colors of the linear gradient brush. In this example, linear gradient brush  includes as properties a red solid color brush  and a blue solid color brush . Thus, when displayed, button  will have a background that ranges from blue at one end and linearly varies to red at the other end. The colors red and blue for solid color brushes  and  may be stored as a dynamic resource.","Returning to Example 1 above, in an embodiment using an element tree such as element tree  () and an appropriate graphics primitive tree similar to graphics primitive tree , the markup of Example 1 would work in this embodiment because the inheritance context provides a way for the SolidColorBrush objects to walk up element tree to find the dynamic resource library. Example 2 below illustrates a part of a DependencyObject (of which graphics primitives are a subclass) that is useable to implement inheritance context.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"..."},{"entry":"\/\/ Get the context"},{"entry":"internal virtual DependencyObject GetInheritanceContext( )"},{"entry":"{"},{"entry":"\u2003\u2003return null;"},{"entry":"}"},{"entry":"\/\/ You have a new context"},{"entry":"internal virtual bool OnNewContextAvailable (DependencyObject context)"},{"entry":"{"},{"entry":"}"},{"entry":"\/\/ Something above GetInheritanceContext has changed"},{"entry":"internal void OnInheritanceContextChanged( )"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ Fire the event that databinding\/resources listen to"},{"entry":"\u2003\u2003InheritanceContextChanged( new EventArgs( ) );"},{"entry":"\u2003\u2003\/\/ Let subclasses respond too"},{"entry":"\u2003\u2003OnInheritanceContextChangedCore( );"},{"entry":"\u2003\u2003\/\/ Notify DPs of the new context"},{"entry":"\u2003\u2003LocalValueEnumerator enumerator = GetLocalValueEnumerator( );"},{"entry":"\u2003\u2003while (true)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003DependencyObject doCurrent = enumerator.Current as"},{"entry":"\u2003\u2003\u2003DependencyObject;"},{"entry":"\u2003\u2003\u2003if (doCurrent != null"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/ \u2018this\u2019s inheritance context changed, and doCurrent has"},{"entry":"\u2018this\u2019"},{"entry":"\u2003\u2003\u2003\u2003\/\/ for its inheritance context, so it's got a new overall"},{"entry":"context"},{"entry":"\u2003\u2003\u2003\u2003if (doCurrent.GetInheritanceContext( ) == this)"},{"entry":"\u2003\u2003\u2003\u2003\u2003doCurrent.OnInheritanceContextChanged( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":"internal virtual void OnInheritanceContextChangedCore( )"},{"entry":"{"},{"entry":"}"},{"entry":"\/\/ Event for OnInheritanceContextChanged"},{"entry":"internal event EventHandler InheritanceContextChanged"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ Storing handlers in an uncommon field or EventHandlersStore."},{"entry":"\u2003\u2003\u2003add { } remove { }"},{"entry":"}"},{"entry":"\/\/ By default, consider this object to be un-shared, since"},{"entry":"\/\/ it doesn't even have one context."},{"entry":"internal virtual bool HasSharedContext( )"},{"entry":"{"},{"entry":"\u2003\u2003return false;"},{"entry":"}"},{"entry":"..."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As illustrated by Example 2,this embodiment of DependencyObject includes a virtual method to get the dependency context, and a method to indicate that the inheritance context has changed. This embodiment of DependencyObject can: (a) call a method to fire an event that can trigger actions in the listeners (e.g., databindings and dynamic resources); (b) call a method to let subclasses of DependencyObject (e.g., Visual, UIElement, FrameworkElement) respond to the inheritance context change; and (c) recursively call a method to notify its DependencyProperties (e.g., graphics primitives such as Freezables) so that all of the DependencyProperties are notified. Each instance of a DependencyObject subclass object (e.g., a Freezable object) can implement an event handler to handle the events that are fired when the inheritance context changes.","Example 3 below illustrates a part of a DependencyObject that sets the inheritance context for a graphics primitive object.",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"..."},{"entry":"public void virtual SetValue( DependencyProperty dp, Object value )"},{"entry":"{"},{"entry":"\u2003\u2003..."},{"entry":"\u2003\u2003\/\/ If there's an existing value, this DO is no longer its context"},{"entry":"\u2003\u2003object current = ReadLocalValueInternalRaw(dp,metadata);"},{"entry":"\u2003\u2003DependencyObject doCurrent = current as DependencyObject;"},{"entry":"\u2003\u2003if (doCurrent!= null && doCurrent.GetInheritenceContext( ) == this)"},{"entry":"\u2003\u2003\u2003doCurrent.OnNewContextAvailable (null);"},{"entry":"\u2003\u2003..."},{"entry":"\u2003\u2003\/\/ Become the context of the new value. This occurs after"},{"entry":"\u2003\u2003\/\/ invalidation, so that FE has a chance to hook up the"},{"entry":"\u2003\u2003\/\/ logical tree first."},{"entry":"\u2003\u2003DependencyObject do = value as DependencyObject;"},{"entry":"\u2003\u2003if (do!= null)"},{"entry":"\u2003\u2003\u2003do.OnNewContextAvailable (this);"},{"entry":"\u2003\u2003..."},{"entry":"}"},{"entry":"..."},{"entry":"public void virtual ClearValue( DependencyProperty dp )"},{"entry":"{"},{"entry":"\u2003\u2003..."},{"entry":"\u2003\u2003DependencyObject do = value as DependencyObject;"},{"entry":"\u2003\u2003if (do!= null && do.GetInheritenceContext( ) == this)"},{"entry":"\u2003\u2003\u2003do.OnNewContextAvailable (null);"},{"entry":"\u2003\u2003..."},{"entry":"}"},{"entry":"..."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As illustrated by Example 3,this embodiment of DependencyObject includes a method to set the inheritance context of a DependencyProperty (e.g., a graphics primitive object). If the method is called, the DependencyObject instance provides itself as the inheritance context for the DependencyProperty. For example, a button (i.e., a DependencyObject) will provide a pointer to itself to a SolidColorBrush (i.e., a DependencyProperty of the button) to serve as the inheritance context. Further, as illustrated in Example 3,this embodiment of DependencyObject includes a method to clear the inheritance context of a DependencyProperty.","The following example (Example 4) illustrates how a graphics primitive object supports inheritance context in one embodiment.",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"private bool _isShared = false;"]},{"entry":[{},"private DependencyObject _context;"]},{"entry":[{},"internal override DependencyObject GetInheritanceContext( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003return _context;"]},{"entry":[{},"}"]},{"entry":[{},"internal override bool HasSharedContext( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003return _isShared;"]},{"entry":[{},"}"]},{"entry":[{},"internal override bool OnNewContextAvailable"]},{"entry":[{},"(DependencyObject context)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003if (_isShared)"]},{"entry":[{},"\u2003\u2003\u2003\/\/ Graphics primitive is already shared, don't need to know the"]},{"entry":[{},"context"]},{"entry":[{},"\u2003\u2003\u2003return false;"]},{"entry":[{},"\u2003\u2003else if (_context != null)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\/\/ Now being shared, clear the context"]},{"entry":[{},"\u2003\u2003\u2003_isShared = true;"]},{"entry":[{},"\u2003\u2003\u2003_context = null;"]},{"entry":[{},"\u2003\u2003\u2003OnInheritenceContextChanged( );"]},{"entry":[{},"\u2003\u2003\u2003return false;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003else"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\/\/ Pick up the new context"]},{"entry":[{},"\u2003\u2003\u2003_context = context;"]},{"entry":[{},"\u2003\u2003\u2003OnInheritenceContextChanged( );"]},{"entry":[{},"\u2003\u2003\u2003return true;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this embodiment, when the inheritance context changes, the Dependency Object already walks all Dependency Properties (see Example 2 above). Thus, in this embodiment, the graphics primitive object does not need to include anything more to have the OnInheritanceContextChanged percolate down the graphics primitive tree.","Example Inheritance Context for a Visual Element Although inheritance context is described above for graphics primitives, in some embodiments a visual element can also specify an inheritance context (i.e., other than the normal inheritance from a parent visual element). In one embodiment, a visual element can give precedence to normal parent inheritance, and thus will only have an inheritance context when it is not in a visual tree. An Example 5 below illustrates how to determine if a visual element has an inheritance context.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"..."},{"entry":"\/\/ Sparse storage for the pointer to the parent visual element (e.g., a"},{"entry":"VisualBrush)"},{"entry":"private static readonly UncommonField<DependencyObject>"},{"entry":"\u2003\u2003InheritanceContextField = new"},{"entry":"\u2003\u2003UncommonField<DependencyObject>( );"},{"entry":"private DependencyObject InheritanceContext"},{"entry":"{"},{"entry":"\u2003\u2003get { return InheritanceContextField.GetValue(this); }"},{"entry":"\u2003\u2003set { InheritanceContextField.SetValue( this, value ); }"},{"entry":"}"},{"entry":"\/\/ Abstract the \u201cparent\u201d. This is the Visual parent here."},{"entry":"internal virtual DependencyObject ParentForInheritanceContext"},{"entry":"{"},{"entry":"\u2003\u2003get { return _parent };"},{"entry":"}"},{"entry":"\/\/ Get the inheritance context"},{"entry":"internal override DependencyObject GetInheritanceContext( )"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ If this has a visual parent, that is the context"},{"entry":"\u2003\u2003if (ParentForInheritanceContext != null)"},{"entry":"\u2003\u2003\u2003return ParentForInheritanceContext;"},{"entry":"\u2003\u2003\/\/ Otherwise, determine if there is an inheritance context (i.e., likely"},{"entry":"\u2003\u2003\/\/ a VisualBrush)."},{"entry":"\u2003\u2003else if (InheritanceContext != null)"},{"entry":"\u2003\u2003\u2003return InheritanceContext;"},{"entry":"\u2003\u2003\/\/ otherwise, this has no context at all."},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003\u2003return null;"},{"entry":"}"},{"entry":"..."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As illustrated in Example 5, a method GetInheritanceContext returns the parent inheritance unless the visual element does not have a parent inheritance. If there is no parent inheritance, then the method provides the inheritance context, if there is one.","Example 6 below illustrates how a visual element obtains an inheritance context. As described above for graphics primitive objects, the visual element may be used by multiple other visual elements. In accordance with this embodiment, the inheritance context feature is blocked or ignored in a visual element if multiple other visual elements are using this visual element. If other visual elements are not using this visual element, then the inheritance context can be obtained if the visual element does not have a parent.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"..."},{"entry":"\/\/ If this bit is set, multiple DOs have tried to put this in their context"},{"entry":"\/\/ (e.g., this visual element is referenced by multiple other visual"},{"entry":"elements)."},{"entry":"private bool _hasMultipleDOContext;"},{"entry":"\/\/ Receive a new potential inheritance context"},{"entry":"internal override void OnNewContextAvailable"},{"entry":"(DependencyObject context)"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ If this visual element in the context of multiple DOs already, then"},{"entry":"\u2003\u2003\/\/ don't use this new context."},{"entry":"\u2003\u2003if (_hasMultipleDOContext)"},{"entry":"\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\/\/ If there is already a Dependcy Object (DO) context, then stop"},{"entry":"\u2003\u2003\/\/ tracking any DO context. This is similar to the shared"},{"entry":"\u2003\u2003state in Freezable."},{"entry":"\u2003\u2003else if (InheritanceContext != null)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/ Already had a DO context, so clear it, and"},{"entry":"\u2003\u2003\u2003\/\/ go into a semi-shared state."},{"entry":"\u2003\u2003\u2003InheritanceContext = null;"},{"entry":"\u2003\u2003\u2003_hasMultipleDOContext = true;"},{"entry":"\u2003\u2003\u2003\/\/ If there is a visual parent, then InheritanceContext is"},{"entry":"\u2003\u2003\u2003\/\/ being ignored. But if we don't have"},{"entry":"\u2003\u2003\u2003\/\/ a visual parent, then the context is being changed"},{"entry":"\u2003\u2003\u2003\/\/ (to no context), so need to do a notify."},{"entry":"\u2003\u2003\u2003if (ParentForInheritanceContext == null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003OnInheritenceContextChanged( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/\/ Otherwise, there is no InheritanceContext set already,"},{"entry":"\u2003\u2003\/\/ so take this one."},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003InheritanceContext = context;"},{"entry":"\u2003\u2003\u2003\/\/ Again, if there is a visual parent, then the InheritanceContext is"},{"entry":"\u2003\u2003\u2003\/\/ being ignored anyway. But if no visual parent, then"},{"entry":"\u2003\u2003\u2003\/\/ context has been changed, and have to do a notify."},{"entry":"\u2003\u2003\u2003if (ParentForInheritanceContext == null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003OnInheritenceContextChanged( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":"..."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Example 7 below illustrates how to determine whether a visual element is being used by multiple other visual elements. In this embodiment, the visual element has a method HasSharedContext( ) that can be called to determine whether that visual element is being used by multiple other visual elements.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal override bool HasSharedContext( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003if (ParentForInheritanceContext != null)"]},{"entry":[{},"\u2003\u2003\u2003return false;"]},{"entry":[{},"\u2003\u2003else if (_hasMultipleDOContext)"]},{"entry":[{},"\u2003\u2003\u2003return true;"]},{"entry":[{},"\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003return false;"]},{"entry":[{},"}"]},{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"When a visual element gets a new context, it needs to notify its children of the context change. Example 8 below illustrates how in one embodiment the visual element recursively notifies each of its children.",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"..."},{"entry":"protected internal virtual void OnVisualParentChanged(Visual oldParent)"},{"entry":"{"},{"entry":"\u2003\u2003OnInheritanceContextChanged( );"},{"entry":"}"},{"entry":"internal override void OnInheritanceContextChangedCore( )"},{"entry":"{"},{"entry":"\u2003\u2003base.OnInheritanceContextChangedCore( );"},{"entry":"\u2003\u2003foreach (Visual child in Children)"},{"entry":"\u2003\u2003\u2003child.OnInheritanceContextChanged( );"},{"entry":"}"},{"entry":"..."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 6","FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["600","600","600","200","600","600"]},"At a block , a visual element is created. In one embodiment, a composition and animation engine such as high-level composition and animation engine  () builds an element tree structure (including the aforementioned visual element). For example, this visual element can be an element such as a button, text, rectangle, etc.","At a block , a graphics primitive object is set as a property of the visual element. In one embodiment, the aforementioned composition and animation engine can create the graphics primitive object. For example, this graphic primitive object can be a single object such as a brush, or a tree of graphics primitive objects, such as a linear gradient brush with two children solid color brushes to define the range of colors of the linear gradient brush.","At a block , it is determined whether the graphics primitive object already has an inheritance context. For example, in some scenarios, two visual elements may use the same graphics primitive; however, this embodiment does not support inheritance context for two visual elements using the same graphics primitive (i.e., the graphics primitive object is \u201cshared\u201d by two or more visual elements). In one embodiment, the aforementioned composition and animation engine can determine whether the graphics primitive object has an inheritance context. If the graphics primitive object does not have an inheritance context, operational flow can proceed to a block . If the graphics primitive object already has an inheritance context, operational flow can proceed to a block .","At block , the visual element created at block  is set as the inheritance context of the graphics primitive object created at block . In one embodiment, the aforementioned composition and animation engine can set the visual element as the inheritance context of the graphics primitive object. For example, the composition and animation engine can provide to the graphics primitive object an \u201cup\u201d pointer that points to the visual element. Once the inheritance context is set, the graphics primitive object can advantageously use databindings, name dictionaries, and\/or resource dictionaries that are part of the element tree containing the visual element.","At block , the inheritance context for the graphics primitive object is ignored or blocked. In some embodiments, the graphics primitive object may have a property that indicates whether the graphics primitive object is being shared. For example, such a property may be a Boolean property that is set when the graphics primitive object is shared. When set, the inheritance context can be cleared or ignored. In one embodiment, the aforementioned composition and animation engine can block or clear the inheritance context of the graphics primitive object and then place the graphics primitive object into a shared state (e.g., by setting the aforementioned Boolean property).","Although operational flow  is illustrated and described sequentially in a particular order, in other embodiments, the operations described in the blocks may be performed in different orders, multiple times, and\/or in parallel. Further, one or more operations described in the blocks may be omitted or combined in some embodiments.","Further, in some embodiments, operational flow  can also include operations (not shown) to detect or recognize if a graphics primitive object that was shared becomes unshared. For example, a reference count or other mechanism may be maintained (e.g., by the aforementioned composition and animation engine) to detect when a once-shared graphics primitive object becomes unshared. The inheritance context of the visual element that still uses the graphics primitive can then be reset (e.g., by performing block ) or \u201creinstated\u201d.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 7","FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["700","700","700","200","700","700"]},"At a block , an inheritance context change is detected by a graphics primitive object. For example, there may have been a change to an inheritable property (or a dynamic resource dictionary, a name dictionary, etc.) associated with a higher element of the element tree containing the visual element for which the graphic primitive object is a property. In one embodiment, when such a change occurs, a method of the graphics primitive object may be called when such a change occurs. For example, in the embodiment of Example 2, operation that causes the change also calls the method OnInheritanceContextChanged on the graphics primitive object.","At a block , resources and\/or databindings used by the graphics primitive object are notified of the inheritance context change. In one embodiment, the graphics primitive object can fire an event that notifies listeners (i.e., the resources and\/or databindings) of the inheritance context change. For example, in the embodiment of Example 2, a method InheritanceContextChanged(new EventArgs( ) ) is called to fire the event.","At a block , the graphics primitive object then validates itself using the inheritance context. In one embodiment, the graphics primitive object attempts to find values of all of its properties. For values specified by a databinding, name dictionary or resource dictionary, the graphics primitive object can walk up the element tree starting at the visual element for which the graphics primitive object is a property. For example, in the embodiment of Example 2, the graphics primitive element calls a method OnInheritanceContextChangedCore( ) is called to validate its properties.","At a block , any children of the graphics primitive object are notified of the inheritance context change. In one embodiment, the graphics primitive object can walk down its tree of graphics primitive objects (if it has children), and notify each child graphics primitive object that the inheritance context has changed. Further, when notified of this inheritance context change, if unshared, the child can then validate itself as in block . For example, in the embodiment of Example 2, as the graphics primitive object walks down to each of its children (if any), for child it finds it calls the aforementioned method OnInheritanceContextChangedCore( ).","Operational flow  allows a graphics primitive object to detect changes in its inheritance context and validate itself and all of its children.","Although operational flow  is illustrated and described sequentially in a particular order, in other embodiments, the operations described in the blocks may be performed in different orders, multiple times, and\/or in parallel. Further, one or more operations described in the blocks may be omitted or combined in some embodiments.","Reference has been made throughout this specification to \u201cone embodiment,\u201d \u201can embodiment,\u201d or \u201can example embodiment\u201d meaning that a particular described feature, structure, or characteristic is included in at least one embodiment. Thus, usage of such phrases may refer to more than just one embodiment. Furthermore, the described features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","One skilled in the relevant art may recognize, however, that embodiments may be practiced without one or more of the specific details, or with other methods, resources, materials, etc. In other instances, well known structures, resources, or operations have not been shown or described in detail merely to avoid obscuring aspects of the embodiments.","While example embodiments and applications have been illustrated and described, it is to be understood that the invention is not limited to the precise configuration and resources described above. Various modifications, changes, and variations apparent to those skilled in the art may be made in the arrangement, operation, and details of the methods and systems disclosed herein without departing from the scope of the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments are described with reference to the following FIGS., wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
