---
title: Technique for implementing browser-initiated user-transparent network-distributed advertising and for interstitially displaying an advertisement, so distributed, through a web browser in response to a user click-stream
abstract: A technique for implementing in a networked client-server environment, e.g., the Internet, network-distributed advertising in which advertisements are downloaded, from an advertising server to a browser executing at a client computer, in a manner transparent to a user situated at the browser, and subsequently displayed, by that browser and on an interstitial basis, in response to a click-stream generated by the user to move from one web page to the next. Specifically, an HTML advertising tag is embedded into a referring web page. This tag contains two components. One component effectively downloads, from an distribution web server and to an extent necessary, and then persistently instantiates an agent at the client browser. This agent “politely” and transparently downloads advertising files (media and where necessary player files), originating from an ad management system residing on a third-party advertising web server, for a given advertisement into browser cache and subsequently plays those media files through the browser on an interstitial basis and in response to a user click-stream. The other component is a reference, in terms of a web address, of the advertising management system. This latter reference totally “decouples” advertising content from a web page such that a web page, rather than embedding actual advertising content within the page itself, merely includes an advertising tag that refers, via a URL, to a specific ad management system rather than to a particular advertisement or its content. The ad management system selects the given advertisement that is to be downloaded, rather than having that selection or its content being embedded in the web content page.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07155663&OS=07155663&RS=07155663
owner: Unicast Communications Corporation
number: 07155663
owner_city: New York
owner_country: US
publication_date: 20020531
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE DISCLOSURE","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation of patent application Ser. No. 09\/352,398, filed Jul. 13, 1999 now U.S. Pat. No. 6,317,761 entitled \u201cA TECHNIQUE FOR IMPLEMENTING BROWSER-INITIATED USER-TRANSPARENT NETWORK-DISTRIBUTED ADVERTISING AND FOR INTERSTITIALLY DISPLAYING AN ADVERTISEMENT, SO DISTRIBUTED, THROUGH A WEB BROWSER IN RESPONSE TO A USER CLICK-STREAM\u201d which is a divisional of co-pending patent application Ser. No. 09\/237,718, filed Jan. 26, 1999 and entitled \u201cA TECHNIQUE FOR IMPLEMENTING BROWSER-INITIATED USER-TRANSPARENT NETWORK-DISTRIBUTED ADVERTISING AND FOR INTERSTITIALLY DISPLAYING AN ADVERTISEMENT, SO DISTRIBUTED, THROUGH A WEB BROWSER IN RESPONSE TO A USER CLICK-STREAM\u201d, which itself is a continuation-in-part of, now abandoned, patent application Ser. No. 09\/080,165, filed May 15, 1998 and entitled \u201cLOCALLY-SUMMONED NETWORK-DISTRIBUTED CONFIRMED INFORMATIONAL PRESENTATIONS; which are all incorporated by reference herein.","1. Field of the Invention","The invention relates to a technique, specifically apparatus and accompanying methods, for implementing in a networked client-server environment, such as the Internet, network-distributed advertising in which an advertisement is downloaded, from an advertising server to a web browser executing at a client computer, in a manner transparent to a user situated at the browser, and subsequently displayed, by that browser and on an interstitial basis, in response to a click-stream generated by the user to move from one web page to the next.","2. Description of the Prior Art","Currently, Internet usage, and particularly that of the World Wide Web (henceforth referred to as simply the \u201cweb\u201d), is growing explosively, particularly as the number of web sites and users that have access to the Internet continue to rapidly and to a great extent, exponentially, expand.","In essence, after establishing a suitable network connection to the Internet, a user at a client computer can easily employ a graphical web browser, such as the Internet Explorer (\u201cIE\u201d) browser presently available from Microsoft Corporation of Redmond, Wash., to connect to a web site and then download a desired web page by simply supplying a specific address (known as a URL or uniform resource locator) of that page to the browser. The URL identifies both an address of the site, in terms of its Internet domain name, and a page of information at that site, in terms of its corresponding file name. Each web site stores at least one, and often times substantially more pages all arranged in a pre-defined hierarchy, generally beginning, at its root, with a so-called \u201chome page\u201d. Each such page is written in HTML (hypertext markup language) form. A page, in this context, refers to content accessed via a single URL, including, e.g., text, graphics and other information specified in HTML code for that particular page. Once a user supplies a URL of interest, the browser operated by that user sends an appropriate command, using a TCP\/IP protocol (transmission control protocol\/internet protocol), to a remote HTTP (hypertext transport protocol) server, located at the web site and which stores that page, to access and download a corresponding file for that page. In response, the server then sends, using the TCP\/IP protocol, a stored file containing HTML code that constitutes that page back to the browser. As the file that constitutes the page itself is received by the browser, the browser interprets and executes the HTML code in that file to properly assemble and render the page on, e.g., a monitor to a user situated at the client computer. Such a page may itself contain HTML commands that reference other files, residing on the same or different web sites, which, when these commands are appropriately interpreted and executed by the browser, result in those files being downloaded and their resulting content properly assembled by the browser into the rendered page. Once all the content associated with the page is rendered, the user can then position his(her) mouse cursor on a suitable hypertext link, button or other suitable user input field (whichever here implements a \u201chotlink\u201d) displayed on that page and then, through, e.g., a mouse \u201cclick\u201d, effectively download a file for and render another desired page in succession until the user has finished his(her) visit to that site, at which point, the user can transition through a hotlink to a page at another site, and so forth. A hotlink specifies a complete web address of an associated page, including a domain name of its hosting web site at which that page is situated. Consequently, by simply and successively positioning and \u201cclicking\u201d his(her) mouse at an appropriate hotlink for each one of a number of desired web pages, the user can readily retrieve an HTML file for each desired page in succession from its corresponding web site and render that page, and, by doing so, essentially effortlessly jump from site to site, regardless of where those sites are physically located.","Ever since their introduction several years ago, HTML and accompanying browser software, now including, e.g., attendant programming languages such as Java and JavaScript languages (\u201cJava\u201d is a registered trademark of Sun Microsystems in Mountain View, Calif.; \u201cJavaScript\u201d is a trademark of Netscape Communications in Mountain View, Calif.), have undergone rather rapid and continual evolution. A major purpose of which has been and continues to be to provide web page authors with an ability to render increasingly rich content through their pages and, as a result, heighten a \u201cuser experience\u201d for those users who visit these pages. Consequently, web pages are no longer limited to relatively simple textual displays\u2014as occurred with early versions of HTML and browser software, but can now encompass even full-motion multimedia presentations and interactive games that use rather sophisticated graphics.","The simplicity of browsing the web coupled with the relative low-cost of accessing the Internet, and the relative ease through which a web site can be established are collectively fueling unparalleled growth and diffusion of the Internet itself, web sites and the Internet user community throughout the world. In that regard, by establishing web sites, merchants, vendors and other information providers have an unparalleled opportunity, basically unheard of as little as 5\u201310 years ago, to reach enormous numbers of potential consumers\u2014regardless of where these consumers reside\u2014at costs far less than previously thought possible. Moreover, given the staggering amount and wide diversity of information currently available on the web, web browsing is becoming so popular a past-time for sufficient numbers of individuals that browsing is beginning to divert significant viewership away from traditional forms of mass entertainment, such as television and cable. While such diversion is relatively small at present, it is likely to rapidly grow. Moreover, given the ease and convenience with which users, situated at their personal computers and with basically nothing more complicated than a few mouse clicks, can effectively interact with remote web sites, electronic commerce, through which goods and services are ordered through the Internet without ever visiting a physical store, is rapidly emerging as a significant sales medium. This medium is likely to significantly challenge and possibly, over a relatively short time, may even alter traditional forms of retailing.","Given the wide and ever-growing reach of the web as a source of consumer information and the increasing consumer acceptance of electronic commerce, advertisers have clearly recognized the immense potential of the web as an effective medium for disseminating advertisements to a consuming public.","Unfortunately, conventional web-based advertising, for various practical reasons\u2014some being technical in nature and others relating to a nature of traditional web advertisements themselves, has generally yielded unsatisfactory results and thus has usually been shunned by most large advertisers. In that regard, several approaches exist in the art for implementing web based advertisements. However, all suffer serious limitations of one form or another that have sharply restricted their desirability and use.","Currently, a predominant format, referred to as a \u201cbanner\u201d, for a web advertisement takes the form of a rectangular graphical display situated, typically at a fixed location, in a rendered web page. A banner, which can be static or animated, can be situated anywhere within a rendered web page but most often is situated at a top or bottom, or along a vertical edge of that page. A banner, depending on its size, can extend across an entire page width or length, and usually contains, in a graphical eye-catching form, a name of a product or service being advertised. Increasingly, a banner for a given product or service implements a hotlink to enable a consumer to \u201cclick-through\u201d the banner (i.e., generate a mouse click on the banner) in order to transition, via his browser, to a web site maintained by a corresponding advertiser and, from that site, fetch a web page to provide additional information regarding that product or service. Hence, the consumer could easily obtain more information by a click-through; while an advertiser, monitoring counts of such click-throughs that occur in a given period of time, could gain feedback on the effectiveness of the corresponding banner.","A banner is generally produced by properly embedding specific HTML code for that banner within the HTML coding for a given web page in which the banner is to appear. A client browser, as it interprets and sequentially executes the HTML code for a fetched page, will, in turn, compile and execute the embedded code for the banner and hence display the banner, as part of a rendered page and at a specified location thereon.","In implementing a banner, whether static or even animated, its HTML coding generally involved downloading an appropriate file, for that banner, to a client browser. The file may be stored on the same server that stores the HTML file for the page, or accessed from a remote server. The file may contain a graphic itself, such as in a GIF (graphic interchange format) file, or a Java applet which, once interpreted and executed by the browser, generates and renders a desired animated graphic. This file, whether it be a graphic or applet, requires time to download and must be downloaded and assembled by the browser on the page prior to that page being fully rendered. The download time for that file, particularly as it increases in size, clearly, a priori, lengthens a time interval during which that page would completely download, thereby extending the time to fully render the page, including the banner, after a user transitioned to that page. Channel bandwidth to a client computer (e.g., personal computer\u2014PC), such as that provided through a modem connection, is often rather limited. Consequently, if the file size for the banner were relatively large\u2014as would certainly be the case for relatively \u201crich\u201d content, e.g., audio or video content, the delay in downloading such a file over such a limited bandwidth connection could be excessive, and consequently highly frustrating to the user. Hence, a user would likely wait a considerable amount of time before all the page components for multimedia content are fully downloaded to permit that page to be rendered. Such delay, if encountered during a page transition, can be rather frustrating to a user, even to the point at which the user, just to end his(her) waiting, will prematurely terminate the download and transition to another page. Therefore, in an effort to preserve an appropriate \u201ceditorial experience\u201d for a user, content suppliers sharply limit the file size, of such banners to be rendered on their pages, in order to minimize page download and hence latency times.","Unfortunately, such restricted file sizes effectively limit the richness of the content of a banner to a rather simplistic advertisement\u2014even with animation. Thus, banners often failed, as advertisers soon recognized by relatively low click-through counts, to attract sufficient viewer attention to justify their use and expense.","In an effort to overcome the content limitation associated with banners, the art teaches the use of a different advertising modality: so-called \u201cinterstitial\u201d advertisements. See, e.g., U.S. Pat. No. 5,305,195 (issued to A. J. Murphy on Apr. 19, 1994\u2014hereinafter the \u201cMurphy\u201d patent) which discloses the concept of using interstitial advertisements though not in the context of web advertising. As described in the Murphy patent, pre-stored advertisements are displayed at specific intervals on each one of a group of networked ATM (automated transaction machines) terminals. In particular, the advertisements are downloaded, either directly or via a server, from a remote computer and locally stored on each such terminal and subsequently displayed on that terminal while it waits for a response, from a remote mainframe transaction server, to a transaction initiated at that terminal.","Generally speaking and with specific reference to web advertising, interstitial ads are displayed in an interval of time that occurs after a user has clicked on a hot-link displayed by a browser to retrieve a desired web page but before that browser has started rendering that page. Such an interval, commonly referred to as an \u201cinterstitial\u201d, arises for the simple reason that a browser requires time, once a user clicks on a hotlink for a new page, to fetch a file(s) from a remote web server(s) for that particular page and then fully assemble and render that page. The length of an interstitial interval, which is quite variable, is governed by a variety of factors, including, e.g., a number of files required to fully render the new page and the size of each such file, and network and server congestion and attendant delays occurring when the user activated the hotlink.","Interstitial web advertising is taught in, e.g., U.S. Pat. Nos. 5,737,619 and 5,572,643 (both of which issued to D. H. Judson but on Apr. 7, 1998 and Nov. 5, 1996, respectively\u2014hereinafter the \u201cJudson\u201d patents). The Judson patents disclose the concept of embedding an advertisement, as an information object, in a web page file in such a manner that the object will remain hidden and not displayed when the file is executed to render the page. Rather than being displayed, the information object is locally cached by the browser during execution of the code for that page. Then, during a transition initiated by user activation of a hotlink to move from that page to a next successive page, i.e., during an interstitial, the browser accesses the advertisement from local cache and displays it until such time as that next successive page is downloaded and rendered. See also, published International patent application WO 97\/07656 (to E. Barkat et al and published on Mar. 6, 1997) which teaches the concept of \u201cpolite\u201d downloading. Here, a browser, on a local computer (e.g., a client PC) downloads, from a remote advertising system server and ostensibly as a background process, file(s) for a web advertisement only during those intervals when bandwidth utilization of a communication channel (link) connected to the browser is less than a pre-established threshold. Such \u201cpolite\u201d downloading is intended to minimally interfere with other communication applications, then executing on the client PC, which will utilize the link. The browser displays the downloaded ad(s) to the user only after the user has not interacted, as detected by a conventional screen saver process, with his(her) PC for a predefined period of time, such as by neither moving a mouse nor depressing a key on a keyboard during that period. The server selects those advertisements for download to the client PC based on a user-ID and preference information of the user, who is then situated at that PC, and configuration information of that PC, which, when a connection is established between the client PC and the server, the client PC uploads to the server. Though the files associated with an interstitial advertisement can be large, these files are advantageously fetched by a client browser during those intervals when otherwise the browser would be idle and hence bandwidth utilization of its network connection would be relatively low. Such \u201cidle times\u201d would occur, in the absence of processing an interstitial ad, after the browser has fully rendered a web page and a user is viewing the page but has not yet clicked on a hotlink to transition to another page. During such an idle time, the browser would simply wait for further user input.","By reducing, if not eliminating, problems, inherent in banners and engendered by download latency, interstitial web advertisements, by employing idle time downloading and local caching, provide a theoretical promise of conveying very rich media content with a pleasing \u201cuser experience\u201d. However, interstitial advertisements, as conventionally implemented, have serious practical deficiencies which have severely limited their use.","Conventional interstitial, as well as other forms of current, web advertisements\u2014here not unlike banners\u2014rely on embedding HTML ad code, as, e.g., a separate non-displayable object, within HTML coding for a web page. Unfortunately, this approach, inherent in that taught by the Judson patents, can be inflexible and expensive for an advertiser to implement and particularly later should that advertiser, for whatever reason, seek to modify his(her) ad content. In particular and presently, ad coding is manually inserted into each and every content web page that is to carry advertising. Consequently, insertion of increasingly sophisticated embedded advertising, such as multi-media or video or audio, in existing web site content requires a large investment in terms of human resources, time and cost as web sites, particularly large sites, increase a number of content pages available for advertising. In that regard, where a banner usually required insertion of, e.g., a single line of HTML code, content rich advertisements, such as those now implemented by parameterized embedded Java advertising applets, often consist of an entire page of coding and hence require far more extensive and increasingly labor-intensive and costly insertions. Moreover, over time, advertisers do change their ads\u2014such as by replacing one ad with a totally new version. However, once HTML ad coding is embedded within a number of web pages, it can be quite impractical and rather costly for an advertiser to access each and every page in which his(her) ad coding has been inserted and then manually change the ad coding, as desired. The impracticality and attendant cost compound if these pages are copied to other web sites and hence diffuse through the Internet.","Given these deficiencies, the art teaches a concept of implementing web advertising through using so-called \u201cpush\u201d technology. See, e.g., U.S. Pat. No. 5,740,549 (issued to J. P. Reilly et al on Apr. 14, 1998\u2014hereinafter the \u201cReilly et al\u201d patent). In essence and as described in the Reilly et al patent, a client PC, through execution of a \u201cpush\u201d application program (called \u201cadministration manager\u201d), establishes a network connection with an information server, i.e., a \u201cpush\u201d web server, typically during off-hours, such as in the late evening or early morning, or at a predefined interval (e.g., every four hours). The information server then downloads, i.e., \u201cpushes\u201d, to the administration manager, content files, such as for advertisements and\/or other predefined information, that are to be played to the user sometime later. The administration manager, i.e., the \u201cpush\u201d application, in turn, stores all the \u201cpushed\u201d content files into a local database (referred to as the \u201cinformation database\u201d) on a local hard disk and, in response to instructions received from the information server, deletes those previously \u201cpushed\u201d content files which have already been displayed. The administration manager also maintains a user profile, which specifies user preferences as to the specific advertising and\/or other information (s)he wants to receive, in the information database. As such, through each connection, the information server, by selecting content from its database relative to preferences specified in the user profile, attempts to \u201cpush\u201d fresh content to the client PC that is likely to be of interest to the user but without duplicating that which was already displayed. Stored \u201cpushed\u201d content is later displayed, using a data viewer, either on user demand or during those times when the user is not interacting with the system, here too detected by a conventional screen saver procedure.","While push technology reduces download latency, by shifting downloads to occur at off-hours, this technology also suffers serious drawbacks which have greatly restricted its practical acceptance.","In particular, to access \u201cpushed\u201d content, a user must initially download and install to his(her) client PC a separate, platform-specific, software application program, as well as subsequent updates to that program as new push capabilities are released by the manufacturer of the program. Unfortunately, these application programs can often extend to tens of megabytes in length. Since typical Internet users establish modem connections to their Internet service providers, these users will find that downloading these relatively large program files, even in compressed form, will consume an inordinate amount of time and is generally impractical while (s)he is actively using his(her) client PC. Consequently, these users are constrained to purchasing, at some cost, an off-the-shelf version of the application program or downloading that program, typically at no cost for the program itself, at off-hours, when network congestion is relatively light. Furthermore, while some efforts are underway in the art to automatically \u201cpush\u201d and install incremental software updates to a client PC, thus eliminating a need for a user to manually do so, the user still faces the burden associated with the initial download and installation of the \u201cpush\u201d application program.","In addition, \u201cpush\u201d application programs continue to increase in size, often considerably, as they provide added capabilities to a user. Downloading and then regularly updating a push application will reduce, sometimes considerably, the amount of disk space available to the user on his(her) client PC. Furthermore, \u201cpush\u201d applications rely on periodically \u201cpushing\u201d large quantities of media content from a push server to the client PC and storing that content on the hard disk of that PC pending subsequent display. This content, depending on its volume, can consume inordinate amounts of hard disk space. Furthermore, advertisers have discovered, not surprisingly, that relatively few PC users will undertake any affirmative action, such as by downloading and installing an application program\u2014almost regardless of its size, to receive advertisements and other such information.","Faced with these practical, and rather acute, deficiencies inhering in web advertising conventionally provided on either an interstitial or \u201cpush\u201d basis, web advertisers have apparently relegated their efforts to displaying their advertisements on a banner-like approach, through real-time downloading and rendering of advertising HTML files. Here, the advertising files are sited on remote web servers, rather than being embedded within given web page HTML files, with appropriate HTML tags, which reference the ad files, being embedded into the web page files themselves. Such a tag specifies when and where, within the page, an advertisement is to appear.","To surmount the latency problems inherent in such banner-like advertisements, various proprietary media formats have appeared in the art. These formats employ increasingly sophisticated data compression, sometimes in conjunction with video and\/or audio streaming. Rather than waiting for a media file to fully download prior to its being rendered, streaming permits content in a \u201cstreamed\u201d media file to be presented in real-time to the user as that content arrives at his(her) client browser. While this approach clearly provides enhanced richness in content over that obtainable through a conventional banner and thus can heighten a \u201cuser experience\u201d, it nevertheless relies, to its detriment, on a continuous real-time network connection existing to a remote web server.","Unfortunately, any network or server congestion which stops the download, even if temporary, can suspend, i.e., freeze, or totally halt the \u201cstreamed\u201d media presentation to the user prior to its completion. This interruption, if noticeable and sufficiently long, will likely frustrate the user and degrade the \u201cuser experience\u201d.","In spite of these drawbacks, particularly with respect to interstitial advertisements and push technology, and apparently for lack of a better alternative, most web advertising currently in use employs real-time streaming of graphic files with their content being rendered by the browser.","Web advertisements, like other forms of mass advertising, do generate revenue, often in the form of an on-going stream of payments to the host of the ads, in this case web site owners. Accurate user accounting is essential to ensure that an advertiser is not over- or under-charged given an extent to which an ad is actually disseminated. Hence, these payments are often tied to a function of the number of web users whom the ad reached. But with web advertisements, accurately ascertaining that number has been difficult and problematic at best, and, given a basic technique employed to do so, manifestly error-prone, thereby causing unreliable user counts and erroneous ad charges.","In particular and as conventionally employed, delivery of a web advertisement, such as, e.g., a streamed ad, is logged as a \u201cuser impression\u201d at a web server at an instant an advertising file(s), e.g., a streamed file, is served, rather than after the browser has completely rendered the advertisement to the user. Unfortunately, serving these ad files does not guarantee that these files will be ultimately and completely rendered by a client browser to a user. Consequently, web server generated \u201cuser impression\u201d counts can be grossly over- or under-stated. For example, if a user navigates to a new content page after an advertisement has started playing but before that advertisement completes and, by doing so, prematurely terminated the advertisement, a full impression is nevertheless logged\u2014erroneously\u2014since that advertisement was completely served. Additional errors arise if a proxy server is situated between multiple client PCs situated on an intranet or a local area network (LAN) and a web advertisement server situated on the Internet (or other insecure public network). In this case, a request from one of the client PCs for the advertisement files will be routed to the proxy server, which, in turn, will direct that request onward to the advertisement web server. The latter, in response to the request, will serve one complete copy of the advertisement files to the proxy server. The resulting fetched advertisement files will be locally cached in the proxy server and, from there, provided to the requesting client PC. Should any of the other client PCs request the same files, the proxy server will provide these files, totally unbeknownst to the web server, from its local cache rather than directing a request from that other PC back to the web server. Hence, the web server will be totally oblivious to each additional instance in which the proxy server accessed the ad files from its local cache and disseminated the advertisement to any client PC other than that which first requested the ad. Inasmuch as some intranets situated behind a proxy server(s) can be rather extensive with tens or hundreds of thousands of individual client PCs, server-based user impression accounting based on copies delivered by a web server may, owing to the presence of proxy servers, be inordinately low and result in significant under-charges to the advertiser. As of yet, no solution apparently exists in the art that can provide accurate counts of \u201cuser impressions\u201d of web advertisements.","Other conventional approaches aimed at reducing latency times associated with downloading content files through relatively slow speed communication links, e.g., modem connections, have involved development and use of new facilities within various programming languages. These approaches, most notably involving the Java and JavaScript programming languages, while helpful, still cause inefficient use of available link bandwidth and still constrain the size of the content files. These limitations arise from premature terminations of preloaded files whenever a user transitions to a new web page. Specifically, with these approaches, if a user activates a hotlink to transition to a new web page while an ad file is being downloaded but before the downloading has completed, then the downloading simply stops. The downloading will need to be re-started, but from the beginning of the file, the next time that particular ad file is requested. Hence, the time and bandwidth that has then been expended in downloading part of that ad file is completely wasted. In practice, many users tend to quickly navigate through a series of web pages until they reach a desired destination. Consequently, advertisers are constrained to again minimize content file sizes and hence \u201crichness\u201d of their advertisements in an effort to decrease a number of premature terminations per unit time and in doing so reduce latency caused by downloading duplicate sections of the same ad file. Therefore, these approaches have generally proven to be wholly unsatisfactory.","In view of the fundamental drawbacks associated with various web based advertising techniques known in the art, interstitial web advertising appears to hold the most promise of all these techniques. Yet, the limitations inherent in conventional implementations of interstitial advertising have effectively prevented this form of web advertising from effectively fulfilling its promise. Moreover, the deficiencies inherent in all known web advertising techniques have, to a significant extent, collectively inhibited the use of web advertising in general.","Thus, a pressing need exists in the art for a new go web-based interstitial advertising technique which does not suffer from infirmities associated with such interstitial advertising techniques known in the art.","In that regard, this new technique should preferably not embed advertising HTML files within a web page. If this could be accomplished, then advantageously such a technique would likely provide considerable economies to advertisers in saved labor, time and cost in terms of both inserting advertisements into web page files, and later changing any of those advertisements. In addition, such a new technique should preferably function in a manner that is substantially, if not totally, transparent to a user and which neither inconveniences nor burdens that user. In particular, this new technique should preferably not require a user to download and install on his(her) PC a separate application program, let alone any update to it, specifically to receive web advertising, or perform any affirmative act, other than normal web browsing, to receive such advertising. Furthermore, this new technique should preferably be platform independent and, by doing so, operate with substantially any web browser on substantially any PC. Also, this new technique, when in use, should preferably not consume excessive hard disk space on a client PC. Moreover, to provide a pleasing \u201cuser experience\u201d, this new technique should render an ad fully and without any interruptions that might otherwise result from network and\/or server congestion. Lastly, this new technique should provide proper accounting to an advertiser by accurately and validly ascertaining user impressions of fully rendered advertisements.","We believe that if such a new web-based interstitial advertising technique could be provided, then this technique, which should be both effective and desirable, may well achieve broad support and use by advertisers and acceptance by web users; hence, substantially expanding the use of web-based advertising in general.","Advantageously, our present inventive technique satisfies this need by overcoming the deficiencies associated with conventional web-based interstitial advertising techniques.","Our present invention accomplishes this, in accordance with our broad inventive teachings, by: completely \u201cdecoupling\u201d advertising content from a web content page (also hereinafter referred to as a \u201creferring\u201d page); \u201cpolitely\u201d downloading advertising files, through a browser executing at a client computer, into browser caches (e.g., browser disk and RAM cache) at that computer and in a manner that is transparent to a user situated at the browser; and interstitially displaying advertisements through the browser in response to a user click-stream associated with normal user navigation across different web pages.","Specifically, our technique relies on embedding an HTML tag (which, where necessary, to distinguish this tag from other HTML tags, will also be referred to hereinafter as an \u201cadvertising tag\u201d) into a referring page. This tag contains two components. One component effectively downloads, from a distribution HTTP (web) server and to an extent necessary, and then persistently instantiates an agent, implemented as a \u201clight-weight\u201d Java applet, at the client browser. This agent then \u201cpolitely\u201d and transparently downloads advertising files (media and, where necessary, player files), originating from an ad management system residing on a third-party advertising HTTP (web) server, for a given advertisement into browser disk cache (also in the case of media files into the browser RAM cache) and subsequently plays those media files through the browser on an interstitial basis and in response to a user click-stream. The other component is a reference, in terms of a web address, of the advertising management system from which the advertising files are to be downloaded. This latter reference totally \u201cdecouples\u201d advertising content from a web page such that a web page, rather than embedding actual advertising content within the page itself\u2014as conventionally occurs, merely includes an advertising tag that refers, via a URL, to a specific ad management system rather than to a particular advertisement or its content. The ad management system selects the given advertisement that is to be downloaded, rather than having that selection or its content being embedded in the web content page.","Advantageously, the agent operates independently, in the client browser, of the content in any referring web page. Once loaded and started, the agent executes in parallel, with standard browser functionality, continually and transparently requesting and downloading advertisements to browser cache residing in a client computer (e.g., personal computer\u2014PC) and interstitially playing those advertisements.","In particular, once the agent is started, the agent politely and transparently downloads, through the client browser and to the browser cache, both media and player files, originating from the advertisement management server, for an advertisement that are needed to fully play content in that advertisement. The agent also monitors a click-stream generated by a user who then operates the browser. In response to a user-initiated action, e.g., a mouse click, which instructs the client browser to transition to a next successive content web page and which signifies a start of an interstitial interval, the agent, if all the media and player files are then resident on the client hard disk, plays the media files, through the browser and during that interstitial interval, directly from the browser cache. Advertisements are interstitially played typically in the order in which they were downloaded to the client browser. Interstitial play from browser cache advantageously permits previously cached content rich advertisements to be played through the browser without adversely affecting communication link bandwidth then available to the client browser. Thus, the full available link bandwidth can be used, while an advertisement is being played, to download a next successive content web page.","Employing a user click-stream to trigger play of cached advertisements frees the user, for receiving advertising, of any need either to undertake any affirmative action, other than normal web browsing, or to learn any new procedure; thus, advantageously imposing no added burden on the user.","Advantageously, the agent \u201cpolitely\u201d downloads advertisement media and player files, originating from the advertising server, to the browser cache, during what otherwise would be browser idle times, i.e., while a web page is being displayed to a user and the browser is waiting for user input. Caching advertisement files in this fashion advantageously circumvents variable latency and erratic (e.g., intermittent or suspended) play that frequently occurs with conventional streamed and static media delivered over the web.","At the start of an interstitial interval, the agent determines whether all the media and player files required to play a given advertisement (typically that having its so-called AdDescriptor file situated in a head of a play queue) then reside on the disk of the client PC or, with respect to media files, are resident in browser RAM cache. If so, the agent then accesses these files from the disk to \u201cplay\u201d that advertisement. Since all the media and player files are then locally resident, the advertisement, from a user's perspective, is immediately rendered from the client hard disk or browser RAM cache with essentially no downloading delay, thus providing a highly pleasing \u201cuser experience\u201d with rich multi-media content approaching that obtainable through current CD-ROM based delivery. Thereafter, the agent returns control to the browser to permit the browser, if a next successive web page has been downloaded, assembled and ready to be rendered, to render that particular page to the user. If, however, an advertisement is prematurely terminated by a user, that advertisement (in terms of its AdDescriptor file) will remain in a play queue (with its media and player files remaining on the client hard disk or, in the case of media files, in browser RAM cache) and will be re-played from its beginning at the start of a next successive interstitial interval. Furthermore, if download of the media and player files for an advertisement were to be interrupted by a user click-stream, i.e., start of interstitial interval, the agent suspends further downloading until after the ensuing interstitial interval terminates. To conserve communication link bandwidth, the agent then resumes downloading of these files at a point it was suspended, rather than, as conventionally occurs, totally re-starting the download.","In accordance with our specific inventive teachings, the agent contains two applets: a Transition Sensor applet and an \u201cAdController\u201d applet. Only the Transition Sensor applet is itself associated with any content page. Though the AdController applet, once started, executes under the browser, it is not under the control of the browser itself.","The advertising tag is itself embedded in a content web page and references a JavaScript file. The advertising tag also encapsulates a reference, i.e., a URL to a specific ad management server, typically sited on a third party advertising server, containing specific media, that collectively constitutes web advertisements, and accompanying player files. The file, when executed, downloads and implements, through dynamic writing of applet tags, the Transition Sensor applet. This particular applet remains visually transparent to a user who displays, with his(her) browser, the HTML coding for that page. In particular, the advertising tag references a JavaScript file (which contains a \u201cscript\u201d) stored on a distribution server. When the JavaScript file is downloaded and the script it contains is then executed by the browser, the script dynamically writes a predefined number and combination of applet tags, i.e., which collectively form the Transition Sensor applet, into the retrieved web page content in lieu of the advertising tag. Subsequent execution of these tags, by the client browser, invokes the Transition Sensor applet.","In particular, when executed, the Transition Sensor applet instantiates an Applet Registry, which is used for inter-applet communication. Thereafter, the Transition Sensor applet determines whether the AdController applet has been downloaded to the browser disk cache or whether an updated version of this particular applet resides on a distribution server. If an updated version of this applet exists on the distribution server relative to that previously downloaded to the browser disk cache or if this applet has not been download at all onto this cache, the Transition Sensor applet loads the AdController applet from the distribution server into the browser disk cache. The Transition Sensor applet then instantiates the AdController applet. Once this occurs, the Transition Sensor applet then establishes appropriate entries in the Applet Registry for itself and the AdController applet.","The Transition Sensor applet then passes the URL of the ad management system, as specified in the advertising tag, to the AdController applet in order for the latter applet to request delivery of an advertisement, specifically an associated AdDescriptor file, originating from that system. The system then selects the advertisement to be delivered and, via the third party advertising server, so informs the AdController applet by returning the requested AdDescriptor file. For a given advertisement, this particular file, which is textual in nature, contains a manifest, i.e., a list, of: file names and corresponding web addresses of all media files that constitute content for that advertisement and all player files necessary to play all the media files; an order in which the various media files are to be played; and various configuration and other parameters need to configure and operate the operation of each player in order for it to properly play a corresponding media file(s). The AdController then \u201cpolitely\u201d downloads, typically via the advertising distribution server, the associated media and player files, as specified in the AdDescriptor file\u2014and to the extent they do not already reside on the hard disk of the client PC. As noted above, the Transition Sensor applet also monitors a click-stream produced by the current user to detect a user-initiated page transition and hence the start of an interstitial interval.","Advantageously, the AdDescriptor file implements a data abstraction that totally separates the media and player files from the referring web page thus assuring that the advertisement content itself remains completely independent of the content web page that invoked its presentation. This abstraction permits our technique to provide a highly effective, generalized and very flexible mechanism for delivering rich web advertisements, particularly those that require complex sets of media files and players. Through use of this abstraction, our technique is able to handle present and future media formats, regardless of their requirements, including proprietary streaming and other content delivery technologies that rely on Java applets as a delivery mechanism\u2014all transparently to the user. Moreover, since the AdDescriptor file can specify media and player files for different browsers, operating systems and computing platforms then in use, our technique can readily function with a wide variety of different computing and browsing platforms.","The Transition Sensor and AdController applets are each implemented through appropriate Java classes and collectively persist, through storage in the browser disk cache, across different content pages within a site, across different web sites, and across successive browser sessions. Once either of these applets is completely downloaded, providing it is not subsequently flushed from the browser disk cache as the user navigates across web sites on the web, the files for that applet will be loaded from that cache, rather than being downloaded from the distribution server, the next time that applet is required, e.g., when the user next navigates, either during a current browser session or a subsequent session, to any content page that contains an advertising tag.","Whenever the client browser encounters a next successive page containing an advertising tag, then the browser will first and automatically inquire with the distribution server to ensure that executable code for the Transition Sensor applet, if previously downloaded into the browser disk cache, has not been superseded by an updated version. If such an updated version then exists, the browser will collectively download updated files from the distribution server and replace, to the extent necessary, each Transition Sensor applet file residing in the browser disk cache with its updated version. Alternatively, if the Transition Sensor applet has not been previously downloaded into the browser disk cache, then the browser will download all the necessary files for the Transition Sensor applet from the distribution server into that cache. The Transition Sensor applet, once executing, will load, through the browser, the AdController applet. To do so, the browser will, if necessary, obtain an updated version, from the distribution server, in the same manner as it did for the Transition Sensor. As a result, any corrections or enhancements made to the agent (specifically the Transition Sensor and\/or the AdController applets) since the agent was last downloaded to the client browser will be automatically and transparently, from a user perspective, distributed to that browser and downloaded into the browser disk cache the next time the browser encounters a web page containing an advertising tag. By operating in this fashion, the user is totally and advantageously relieved of any need to: both initially load and install an application program to obtain advertising and\/or later update that program.","Furthermore, the agent advantageously persists and functions transparently in background, independent and transparent to user navigation across pages on a common web site and across web sites. The agent effectively implements a background process which runs in parallel with and is transparent to normal HTML and HTTP operations implemented by the client browser.","Moreover, in sharp contrast to conventional server-based accounting of web advertisements, our inventive technique provides highly accurate client-side accounting of each user impression. Each log entry, produced by the AdController applet, specifies a successful presentation of a complete advertisement at a client browser. This entry may include a source of the ad content, i.e., in terms of the URL of the associated ad management system, a title of the advertisement and the URL of the referring web page. Other client-side information can be measured and included in each entry, such as: an amount of time during which the advertisement was rendered by the browser (presumably during which the user dwelled on the advertisement); as well as an identification, in terms of a URL, of a content web page to which the user next navigated (particularly if the user reached that page through a hotlink displayed in the advertisement). Subsequently, the AdController applet uploads the log entries to the advertising server. These entries will be collectively processed, as needed, to permit shared ad revenues from web-based advertisers to be properly allocated among different web page content providers.","Advantageously, our inventive technique, by totally decoupling referring web page content from its corresponding advertising content, easily permits an advertiser to change or update any of its advertisements by just modifying, as needed, appropriate media and AdDescriptor files that reside in the third-party advertising management system. Since a referring web page merely incorporates an advertising tag totally devoid of advertising content, no changes whatsoever need to be made to that page. Hence, use of our inventive technique substantially reduces the burden, time and cost associated with maintaining and updating web-based advertising over that conventionally required.","As a feature, our inventive technique advantageously implements, in conjunction with its persistent agent approach, multi-threaded pipelining. By processing each different advertisement as a different thread, each one of a sequence of different processing operations can be performed, effectively on a pipe-lined parallel basis, on different sequentially occurring advertisements, thereby enhancing a rate (increasing throughput) at which advertisements can be queued for playback. In addition, through such pipe-lining, logging of a fully presented advertisement can occur as a last operation in a pipeline and essentially in parallel either with: presentation of cached advertisement having its AdDescriptor file situated in the play queue immediately behind that for the just presented advertisement, or downloading and caching of a next successive advertisement.","To facilitate understanding, identical reference numerals have been used, where possible, to designate identical elements that are common to the figures.","After considering the following description, those skilled in the art will clearly realize that the teachings of our present invention can be utilized in any networked client-server environment in which advertising or other information is to be presented to a user during interstitial intervals, i.e., during a transition between successively displayed web pages. Such an environment can encompass the Internet or an intranet, or any client-server environment in which a client browser (regardless of whether that browser executes on a dedicated client computer or not) is used to access and download web pages or, more generally speaking, files through a network communication channel (link) from a server (again regardless of whether that server executes on a dedicated computer or not). In that regard, the server can be a separate software application which executes on any computer in the networked environment, even if that computer is itself a client to another server in the network.","For purposes of simplicity and to facilitate reader understanding, we will discuss our present invention in the illustrative context of use in rendering interstitial web-based advertisements to a client personal computer (PC) connected to the Internet, where specifically a client browser executing in the PC is used to download and render web pages from a remote networked Internet accessible web server. Clearly, after considering the ensuing description, anyone skilled in the art will readily appreciate how the teachings of our invention can be easily incorporated into any client-server or other similar distributed processing environment in which a client can encompass not only a specific computer connected to a network but a software process that possesses network connectivity to another such process and requests information from and, in response, obtains information supplied by the latter.","We will first present an overview of our invention, particularly in the context of its use with an Internet web browser in a client PC, followed by describing each basic component of its implementation.","A. Overview","A general deployment of our invention in an Internet environment is collectively shown in , with a detailed view of a portion of the inter-processor agent download\/instantiation operations  shown in these figures being depicted in . The correct alignment of the drawing sheets for , and E and F is shown in , respectively. , for which the correct alignment of the drawing sheets for these figures is shown in , collectively depicts generalized web page HTML code which transparently invokes our invention, and changes which our invention dynamically makes to that code in order to download and render web advertisements. For a understanding, the reader should simultaneously refer to , E and F, and A and B throughput the following discussion.","As shown, client PC , upon which client browser  executes, is connected through communication link  to Internet . Browser  is a conventional web browser, such as Internet Explorer or Netscape Navigator commercially available from Microsoft Corporation or Netscape Corporation, respectively. Preferably, for reasons that will shortly become clear, that browser should preferably support dynamic writing of applet tags. Though, for ease of illustrating inter-computer actions, we depicted Internet  as having portions and , we will collectively refer to both portions as simply Internet . Web server , connected, via link , to Internet  represents any web HTTP (hypertext transfer protocol) server. This server, in response to a request from web browser  to fetch a specific file, downloads that file, using conventional TCP\/IP protocols (transmission control protocols\/internet protocols), through the Internet to browser . Browser  will, in turn, render that file typically on a monitor to a user situated at the client PC.","Advertising distribution HTTP server (also referred to as \u201cagent\u201d server)  is connected, via communications link , to Internet  and stores files that collectively implement a predefined agent, specifically, a light weight Java applet. This agent (referred to herein as the \u201cAdController\u201d agent) transparently pre-loads itself, as well as media rich advertising content, into a local hard disk cache associated with the browser (\u201cbrowser disk cache\u201d) on client PC . Server  downloads the AdController agent in a manner to be described below, to client browser . This agent, once instantiated and started, then transparently and politely downloads (actually pre-loads) advertisements into the browser disk cache, and subsequently plays each of those advertisements, on an interstitial basis, in response to a click stream generated by the user as (s)he navigates, through use of browser , between successive web pages. Such hard disk caching advantageously circumvents variable latency and erratic play associated with conventional streamed and static media delivered over the Internet. The agent enables rich advertising to be presented in a highly-controlled fashion, resulting in user experiences approaching that of CD-ROM.","Third-party ad HTTP server , connected to Internet  via, e.g., communications links  and , hosts ad management system . In essence and as discussed in detail below, this system, in response to a request originating from the AdController agent executing in browser , selects a given advertisement and then downloads, in a \u201cpolite\u201d manner controlled by the agent, media and player files that form that advertisement to the agent for storage in the browser disk cache. Inasmuch as Java applets are currently restricted under constraints inherent in the Java programming language itself to retrieving files from an identical Internet host that served the applet itself, the request for an advertisement to system  as well as resulting media and player files served by system  are routed through agent server  as a proxy server.","Advantageously, our inventive technique completely \u201cdecouples\u201d advertising content from a web content page (also hereinafter referred to as a \u201creferring\u201d page). This, in turn, permits our technique to render media-rich advertisements without requiring inclusion of any advertising content into a referring web page. This \u201cdecoupling\u201d is effectuated through inclusion of an HTML tag into a content web page, which when the latter is downloaded, interpreted and executed by the browser, effectively loads and instantiates the agent and then retrieves advertisement files from an ad management system specified in the tag. Thus, advertising files (both media and player files) can be maintained totally independently of their referring web page(s), with advantageously any changes made to the former having no effect on HTML coding contained in the latter.","In particular, HTML tag  (which, where necessary, to distinguish this tag from other HTML tags, will also be referred to hereinafter as an \u201cadvertising tag\u201d) is embedded by a content provider(s) into HTML code that constitutes each referring web page, e.g., here page . Generally, the position of this tag relative to existing HTML code (shown as HTML code portions and in ) for this page is not critical. Advantageously, very rarely, if ever at all, do any changes need to be made to these code portions to accommodate the tag. As shown and as reproduced in Table 1 below, this tag, which typically consumes one line in a web page, implements a script.",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ADVERTISING TAG"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<SCRIPT SRC=http:\/\/unicast.com\/loadad.js>"]},{"entry":[{},"AdServer=\u201c\u201d"]},{"entry":[{},"<\/SCRIPT>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"One portion of the advertising tag (\u201cSRC=http:\/\/unicast.com\/loadad.js\u201d), when executed by the browser, downloads a JavaScript file (named \u201cloadad.js\u201d) from the agent server. This file, in turn, is then interpreted and executed, as a script, by the browser. The effect of executing this script, as symbolized by block  shown in , is to substitute applet tags, dynamically written by the script, into the referring web page in lieu of advertising tag  so as to form a modified web page, here referring content page \u2032, residing in the browser disk cache. The script, by invoking a feature associated with dynamic writing, completely hides these tags from view should the user then display HTML source code for page \u2032 with his browser. This, in turn, hinders the user, to a certain degree, from readily ascertaining the source of the agent and ad management systems. Collectively, these applet tags form Transition Sensor applet . This script, as described in detail below and is reproduced in Table 2 below, when interpreted and executed by a Java virtual machine (Java interpreter) resident in the browser persistently loads and then instantiates the Transition Sensor itself which, in turn, loads and instantiates the remainder of the agent in the client browser.",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"TRANSITION SENSOR APPLET"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<applet code=\u201ccom.unicast.adcontroller.tools.TransitionSensor\u201d"},{"entry":"codebase=\u201chttp:\/\/www.unicast.com\/java\/classes\/\u201d"},{"entry":"align=\u201cbaseline\u201d width=\u201c0\u201d height=\u201c0\u201d name=\u201cTransitionSensor\u201d"},{"entry":"archive=\u201cadcontroller.jar\u201d>"},{"entry":"<param name=\u201cadURL\u201d"},{"entry":"value=\u201chttp:\/\/www.unicast.com\/media\/fireworks_01_ad_descriptor.txt\u201d>"},{"entry":"<param name=\u201ccabbase\u201d value=\u201cadcontroller.cab\u201d>"},{"entry":"<\/applet>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The value of attribute CODE in the Transition Sensor applet specifies a Java executable that will be executed by the client browser, when it renders this applet, to launch the Transition Sensor. The executable, implemented through an appropriate Java class, was originally compiled from its associated Java source code file. Tags labeled \u201c<WIDTH>\u201d and \u201c<HEIGHT>\u201d jointly specify a rectangular portion of a web page, as displayed by browser , in which the applet will be rendered. Since, here that portion is non-existent, nothing will be rendered. Applets, such as this one, can be delivered transparently over the Internet to the client PC and require no user-assisted installation.","Another portion of the advertising tag (\u201cAdServer=\u201dhttp:\/\/AdManagement_system\u201d) references a URL of a particular ad management system (where \u201cAdManagement_system\u201d represents a web address (URL) of that particular system), here illustratively system , from which the agent is to download an advertisement. As will be seen below, the Transition Sensor applet, during its execution, passes this URL, as part of an advertising download request, to the remainder of the AdController agent to subsequently download appropriate advertising files, also as described below, from that system necessary to interstitially play an advertisement.","If advertisements are to play on client browsers (specifically Microsoft Internet Explorer version 3) that do not support dynamic writing of applet tags, then applet  would need to be inserted by content providers into each referring web page in lieu of advertising tag . Unfortunately, Transition Sensor applet  identifies both the agent server, and an actual advertisement in terms of a URL of its source components (through contents of an \u201cAdDescriptor\u201d file\u2014which will be discussed in detail below\u2014specified in this applet). Since browser technology continues to rapidly advance with most users continually upgrading their browsers, most browsers now in use, and in a very short time nearly all such browsers, will support such dynamic writing. Hence, we see little, and very shortly essentially no need, to embed applet  into any referring web pages, thus minimizing ad insertion cost, effort and time while restricting disclosure of the agent server and advertisement source information.","The agent, during its execution, \u201cpolitely\u201d and transparently downloads advertising files (media, and where necessary player files), originating from ad management system  for a given advertisement into browser disk cache (with the media files also being written into browser RAM cache) and subsequently plays those media files through the browser on an interstitial basis and in response to the user click-stream.","Advantageously, the agent operates independently, in the client browser, of the content in any referring web page. Once loaded and started, the agent executes in parallel, with standard browser functionality, continually and transparently requesting and downloading advertisements to a browser disk cache residing on a local hard disk (\u201cbrowser disk cache\u201d), as well as in the case of media files into browser RAM cache, in a client computer (e.g., personal computer\u2014PC) and interstitially playing those advertisements.","Now, with the above in mind and specific reference to , we will now describe the basic inter-computer actions associated with use of our invention, as well as the basic attendant processing steps that occur in the client PC.","To begin a browsing session, the user first invokes client browser . Once the browser is executing, the browser obtains, as an initial web page\u2014selection of this page being referenced by numeral , an address either of a prior so-called \u201cdefault\u201d content page previously specified by the user and having its URL stored in the browser or of a content page manually entered by the user. The client browser then issues, as symbolized by block , a request to fetch a file for that page; with the request containing a URL of that page (i.e., its complete web address including its file name). We assume for simplicity that the file for that page resides on web server . We also assume that page  is being requested which will invoke an associated interstitial advertisement in accordance with our invention. In response to the request routed to server \u2014as symbolized by line , this particular server downloads, as symbolized by line , to client PC  a file for page , where the coding stored in this file contains advertisement tag . Illustrative contents of this tag are shown in dashed block , as well as in .","Once this file is received as shown in , browser  interprets and then executes, as symbolized by block , the HTML code in page , which includes tag  and thus undertakes the actions shown in agent download\/instantiate\/execute operations . These operations eventually result in the AdController agent being downloaded, instantiated and started in the client browser. Generally speaking, the browser in response to executing the advertising tag, issues a request, as symbolized by line , to agent server  to download the AdController agent. Through various inter-process operations, as shown in further detail in  and which will be described below shortly, server  accesses and downloads, as symbolized by line , the needed files to install the AdController agent to execute under browser  on the client PC. Once files for the agent are downloaded to the browser disk cache on the client PC, the browser then instantiates and starts the agent executing, as symbolized by block . Operations  effectively conclude once the agent begins executing.","Now referring to operations  as shown in further detail in , upon entry into these operations, browser  executes, as symbolized by block , advertising tag . The browser then issues a request, as symbolized by line , to agent server , to download a JavaScript file (named, e.g., \u201cloadad.js\u201d) specified in the request. This file is specified as the first portion of the advertising tag. In response to this request, server  downloads, as symbolized by line , this particular file onto browser  where that file is cached appropriately. Once the file is fully downloaded, it is interpreted and executed by a Java virtual machine (a Java interpreter integrated into the browser and which generates code compatible with and executable by the browser). As indicated by block , the browser then executes the interpreted code for the script which, in turn, dynamically writes applet tags\u2014in the manner generally shown in  and described above\u2014into web page  in lieu of the advertising tag. These tags, which collectively form Transition Sensor applet , include a reference to a specific ad management system as specified in the second portion of advertising tag .","Once these tags are dynamically written into content web page  (to yield modified version \u2032 shown in ), Transition Sensor applet  is instantiated and then executed. In particular, browser  determines whether executable code for the Transition Sensor applet has been previously downloaded to the browser disk cache. If this code has not been downloaded or an updated version of this code exists on agent server , the browser issues, as symbolized by line , a request to download a latest version of the Transition Sensor executable code from the agent server. Server , in response to this request, downloads, as symbolized by line , file(s) for the latest version of the transition sensor code to the browser which, in turn, stores these file(s) into the browser disk cache. Thereafter as symbolized by block , the browser instantiates and starts execution of the Transition Sensor applet. This latter applet, as part of its initial execution, instantiates an Applet Registry. This registry provides a mechanism, within the agent, for inter-applet communication between the constituent Transition Sensor and AdController applets.","Thereafter, the Transition Sensor applet attempts to load, also as symbolized by block , the AdController applet, through the browser, from the browser disk cache. To do so, the browser first determines whether the AdController applet has been downloaded to the browser disk cache or whether an updated version of this particular applet resides on agent server . If an updated version of this applet exists on the agent server relative to that previously downloaded to the browser disk cache or if the AdController applet has not been download at all into this cache, the browser issues a request, as symbolized by line , to download a latest version of the AdController applet from agent server . Server , in response to this request, downloads, as symbolized by line , file(s) for the latest version of the AdController applet to the client browser which, in turn, stores these file(s) into the browser disk cache. Lastly, as symbolized by block , the Transition Sensor applet then instantiates and starts the AdController applet; and thereafter establishes appropriate entries in the Applet Registry for itself and the AdController applet.","Returning to , once operations  have completed, such that the agent is executing under browser , the AdController applet issues, as symbolized by block , a request, via agent server , to download an AdDescriptor file from the ad management system, e.g., ad management system , specified in advertising tag . This request contains the URL of the ad management system contained in advertising tag . Currently, Java applets are restricted under constraints inherent in the Java programming language itself to retrieving files from an identical Internet host that served the applet itself. As such, rather than directing this request to advertising server , on which ad management system  resides, this request, as symbolized by line , is addressed to agent server , which serves as a proxy server between client PC  and advertising server . Both the request and resulting advertising (including media and player) files will be served to the client PC through agent server . As such, once the request has been received by the agent server, this server passes the request onward, as symbolized by line , to advertising server .","In response to this request for an AdDescriptor file, ad management system  then selects a specific advertisement to be delivered to client PC . This selection can be selected on a predefined or random basis, or based on user preference or other user-specific information previously collected from and associated with the user then operating browser . Such user-specific information, such as prior buying patterns, could have been appropriately pre-collected at the client PC, previously uploaded to ad management system  and processed there such that, upon receipt of the AdDescriptor request, system  would then select and download an appropriate advertisement specifically targeted to the user then situated at the client PC. In any event, once system  selects the advertisement, through whatever selection metric it employs, the corresponding AdDescriptor file is then downloaded, as symbolized by line , to agent server  (here being a proxy server) which, in turn, as symbolized by line , supplies that file to the AdController agent then executing under web browser .","To digress slightly, for the selected advertisement, the AdDescriptor file is a text file that contains a manifest, i.e., a list, of file names and corresponding network locations (URLs) at which these files reside, and player instructions and configuration parameter values necessary to play the entire advertisement through web browser  to the user.  shows contents of typical AdDescriptor file  for a PointCast Java advertisement. Specifically and as shown in section C of file , this AdDescriptor file lists file names with partial addresses on the ad management system of all media files that constitute content for that advertisement, and, in section  of this file, all Java player files necessary to play all the media files. This file also respectively specifies, here shown in sections  and B, an order in which the various media files are to be played, and various configuration parameters needed to properly configure the operation of each player to play each corresponding media file.","The AdDescriptor file implements a data abstraction that totally separates the media and player files from the referring web page, here page , thus assuring that the advertisement content itself remains completely independent of the content web page that invoked its presentation. This abstraction permits our technique to provide a highly effective, generalized and very flexible mechanism for delivering rich web advertisements, particularly those that require complex sets of media files and players. Through use of this abstraction, our inventive technique can handle present and future media formats, regardless of their requirements, including proprietary streaming and other content delivery technologies that rely on Java applets as a delivery mechanism\u2014all transparently to the user. Moreover, the AdDescriptor file can contain separate listings (though not contained in file  shown in ) that delineate media and player files for different browsers, client operating systems or computing platforms (to the extent any of these require different versions of the media and\/or player files) then in use. As such, our technique can readily function with a wide variety of different client computers and browsing platforms.","Once the AdDescriptor file is downloaded to the client PC, via agent server , the AdController then \u201cpolitely\u201d downloads, as symbolized by block  shown in , into the browser disk cache each media and player file, as specified in the AdDescriptor file\u2014to the extent that file does not already reside on the hard disk of the client PC. Through so-called \u201cpolite\u201d downloading, media and player files are downloaded to browser  during browser idle time intervals, with the downloading suspended during each ensuing interstitial interval after the user instructs browser  to navigate to a new content web page. In this manner, while a fully downloaded advertisement is interstitially played from browser cache, the new content page is downloaded over the full bandwidth of communications link . Advantageously, the communications link is freed during each interstitial interval to just carry web page content, thereby expediting download of content pages. If, due to the occurrence of an interstitial interval, the AdController applet suspends downloading of an advertisement file, then upon termination of this interval, this applet then resumes downloading at a location in that file at which downloading had stopped, thus conserving communication bandwidth and reducing download time.","In particular, as part of the operations symbolized by block , the AdController applet determines which files, of those listed on the AdDescriptor, do not then reside on the hard disk of client PC . Once it has made that determination, this applet issues a request, as symbolized by line , to agent server , to fetch a first one of these files. The agent server, again serving as a proxy server, issues a request, as symbolized by line , to fetch this file from a networked server, anywhere on Internet , on which that file resides. For simplicity, we assume that all such files reside on server  and are accessible through ad management system . Hence, system , via server , issues a response, as symbolized by line  to agent server , containing this first advertisement file. The agent server, in turn and as symbolized by line , downloads this particular file to client browser  for storage in the browser disk cache. Downloading of advertisement files continues in this manner until, as symbolized by line , a last required file for the advertisement has been downloaded, via agent server , to the browser disk cache on client PC .","As the advertisement files for a common advertisement are being downloaded, the Transition Sensor applet also monitors, as symbolized in block , a click-stream produced by the current user so as to detect a user-initiated page transition. Once such a transition occurs, usually caused by a user engendered mouse click, and hence an interstitial interval starts, the AdController applet plays, also as symbolized by block , a fully cached advertisement (assuming all its media and player files have been downloaded) in the manner specified in its associated AdDescriptor file and using the players specified therein. Also, at the inception of the interstitial interval, the browser issues, also as symbolized by block , a request to fetch the next successive web page to which the user desires to transition. Once the advertisement has fully played, or until the next successive content web page is fully downloaded and assembled, or a user has closed an advertisement window, whichever occurs first (assuming the AdDescriptor file specifies that the advertisement can be prematurely terminated), then control is returned, as symbolized by path , to the client browser to await completion of the download and interpretation of HTML code that forms that next content page and subsequent execution, of an advertising tag therein to invoke agent download\/instantiate\/execute operations  for that page; and so forth.","The Transition Sensor and AdController applets are each implemented through appropriate Java classes and collectively persist, through storage in the browser disk cache, across different content pages within a site, different web sites, and successive browser sessions. Once either of these applets is completely downloaded through operations , providing that applet is not subsequently flushed from the browser disk cache as the user navigates across web sites on the web, the files for that applet will be loaded from that cache, rather than being downloaded from agent server , the next time that applet is required, e.g., when the user next navigates, either during a current browser session or a subsequent session, to any successive content page that contains advertising tag .","Whenever client browser  encounters a next successive content page containing advertising tag , then the browser, will first and automatically inquire with agent server  to ensure that executable code for the Transition Sensor applet, if previously downloaded into the browser disk cache, has not been superseded by an updated version. If such an updated version then exists, the browser will collectively download updated files from the agent server and replace, to the extent necessary, each Transition Sensor applet file residing in the browser disk cache with its updated version. Alternatively, if the Transition Sensor applet has not been previously downloaded into the browser disk cache, then the browser will download all the necessary files for the Transition Sensor applet from the agent server into that cache. The Transition Sensor applet, once executing, will load, through the browser, the AdController applet. To do so, the browser will, if necessary, obtain an updated version, from the agent server, in the same manner as it did for the Transition Sensor. As a result, any corrections or enhancements made to the agent (specifically the Transition Sensor and\/or the AdController applets) since the agent was last downloaded to the client browser will be automatically and transparently, from a user perspective, distributed to that browser and downloaded into that disk cache the next time the browser encounters a web page containing an advertising tag. By operating in this fashion, the user is totally and advantageously relieved of any need to: both initially load and install an application program to obtain advertising and\/or later update that program.","Specifically, cross page persistency of the Transition Sensor agent is accomplished by using a Java \u201csingleton\u201d design. A singleton design allows only a single object to ever be created and is accomplished by declaring a Java class as static. Since all applets run in a same instance of a Java virtual machine, therefore all applets and their associated code share all static class variables. A static Applet Registry class is instantiated automatically by the Transition Sensor applet at its run time and, by implementing the Applet Registry, provides all inter-applet communication between the Transition Sensor and the AdController applets and their threads. The Applet Registry class implements a \u201cloadAdController\u201d method which, in turn, instantiates the persistent AdController applet. Through this method, the Transition Sensor applet downloads the AdController applet only if the latter applet has either been updated, relative to that version of this applet then resident in the browser disk cache, or does not then reside on the browser disk cache. The AdController applet then instantiates all its own threads that collectively implement transparent advertisement downloading and play mechanisms.","The AdController applet is itself created by an Applet Registry singleton object and creates all other objects that collectively constitute a run time agent execution module. This applet extends standard applet class definitions by over-riding standard Java applet init (initialize), start, run, stop and destroy life cycle methods, conventionally implemented in the client browser, with corresponding substitute methods. The substitute stop method ensures that a traditional response provided by the browser of halting execution for either the AdController applet does not occur whenever the browser calls the stop method to terminate the lifecycle of this applet; hence, advantageously providing persistence to the agent across successive content pages. Consequently, the agent continues executing until the user terminates execution of (closes) the browser itself.","Thus, the agent persists and functions transparently in background, independent and transparent to user navigation across pages on a common web site and across web sites. In that regard, the agent effectively implements a background process which runs in parallel with and is transparent to normal HTML and HTTP operations implemented by the client browser.","To significantly simplify the description and the accompanying drawings, we have intentionally omitted from this discussion specific Java classes that constitute the AdController agent as well as, to increase a rate at which advertisements can be queued for playback, an accompanying software architecture for processing these classes on a multi-threaded pipelined basis. Such details are conventional in nature; hence, their use in implementing our present invention would be readily apparent to any one skilled in the art.","B. Client PC",{"@attributes":{"id":"p-0119","num":"0118"},"figref":"FIG. 3","b":"5"},"As shown, the client PC comprises input interfaces (I\/F) , processor , communications interface , memory  and output interfaces , all conventionally interconnected by bus . Memory , which generally includes different modalities, including illustratively random access memory (RAM)  for temporary data and instruction store, diskette drive(s)  for exchanging information, as per user command, with floppy diskettes, and non-volatile mass store  that is implemented through a hard disk, typically magnetic in nature. Mass store  may also contain a CD-ROM or other optical media reader (not specifically shown) (or writer) to read information from (and write information onto) suitable optical storage media. The mass store stores operating system (O\/S)  and application programs ; the latter illustratively containing browser  (see, e.g., ) which implements our inventive technique. O\/S , shown in , may be implemented by any conventional operating system, such as the WINDOWS NT, WINDOWS 95, or WINDOWS 98 operating system (\u201cWINDOWS NT\u201d, \u201cWINDOWS 95\u201d and \u201cWINDOWS 98\u201d are trademarks of Microsoft Corporation of Redmond, Wash.). Given that, we will not discuss any components of O\/S  as they are all irrelevant. Suffice it to say, that the browser, being one of application programs , executes under control of the O\/S.","Incoming information can arise from two illustrative external sources: network supplied information, e.g., from the Internet and\/or other networked facility, through communication link  to communications interface , or from a dedicated input source, via path(es) , to input interfaces . Dedicated input can originate from a wide variety of sources, e.g., an external database. In addition, input information, in the form of files or specific content therein, can also be provided by inserting a diskette containing the information into diskette drive  from which client PC , under user instruction, will access and read that information from the diskette. Input interfaces  contain appropriate circuitry to provide necessary and corresponding electrical connections required to physically connect and interface each differing dedicated source of input information to client PC . Under control of the operating system, application programs  exchange commands and data with the external sources, via network connection  or path(es) , to transmit and receive information typically requested by a user during program execution.","Input interfaces  also electrically connect and interface user input device , such as a keyboard and mouse, to client PC . Display , such as a conventional color monitor, and printer , such as a conventional laser printer, are connected, via leads  and , respectively, to output interfaces . The output interfaces provide requisite circuitry to electrically connect and interface the display and printer to the computer system.","Furthermore, since the specific hardware components of client PC  as well as all aspects of the software stored within memory , apart from the modules that implement the present invention, are conventional and well-known, they will not be discussed in any further detail. Generally speaking, agent server  and third-party ad server  each has an architecture that is quite similar to that of client PC .","C. Software","1. Application Programs ",{"@attributes":{"id":"p-0125","num":"0124"},"figref":"FIG. 4","b":"400"},"As shown, the application programs, to the extent relevant, contain browser  and resident JAVA player files , i.e., files for JAVA media players that have previously been installed onto the hard disk of the client PC. These players may illustratively include audio, streaming audio, video and multi-media players.","Browser  contains AdController agent , when it has been fully loaded for execution into browser cache, browser disk cache  and Java virtual machine  (which has been discussed above to the extent relevant). As noted, this agent persists whenever the user causes browser  to transition across different web content pages or different web sites, and functions independently and transparently of any such pages and sites. The AdController agent includes applet registry  for facilitating inter-applet communication within the agent.","The AdController agent contains two applets: Transition Sensor applet  and AdController applet  (also referred to as applet  in ). As discussed above, the Transition Sensor applet accomplishes three basic functions. First, this applet loads, instantiates and starts the AdController applet. Second, the Transition Sensor applet communicates an Internet address of an advertising server, here server , to request an advertisement, specifically an AdDescriptor file therefor, that is to be downloaded and subsequently presented. Lastly, the Transition Sensor applet, through associated click-stream monitoring (performed by a Transition Sensor implemented by this applet), determines when a user situated at client browser  undertakes an affirmative action, such as, e.g., causing a mouse click, to request a next successive web page be downloaded and rendered, and so notifies the AdController agent of that event. This event signals a start of an ensuing interstitial interval.","AdController applet , which is not embedded in any content page, executes under but is not controlled by browser . This applet, also as discussed above, accomplishes several basic functions. First, it creates all other objects that collectively form a run time agent execution module for the agent. As noted above, this includes extending standard Java applet class definitions by over-riding standard Java applet init, start, run, stop and destroy life cycle methods. Second, the AdController applet \u201cpolitely\u201d downloads advertising (including media and, where necessary, player) files, through the client browser executing at a client computer, into browser disk cache and in a manner that is transparent to a user situated at the browser. Lastly, the AdController applet interstitially plays advertisements through the client browser in response to the user click-stream associated with normal user navigation across different web pages.","Browser disk cache  stores downloaded AdDescriptor files  and accompanying and downloaded media and player files .","2. AdController Agent ",{"@attributes":{"id":"p-0132","num":"0131"},"figref":"FIG. 5","b":"420"},"As shown, the agent specifically contains Transition Sensor applet , AdController applet  and applet registry .","As discussed generally above, the Transition Sensor applet implements, as one of its functions, a transition sensor which detects, through user navigation click-stream monitoring, a user-initiated transition to a new web page, and produces, in response, a corresponding Transition Sensor event. Such a transition occurs in response to an actual user initiated mouse click or key depression to activate a hotlink appearing on a currently displayed content page in order to move to a new content page, either on the same site or on another site. Another such transition occurs whenever a stored history of web pages just visited by the user changes state. The latter is sensed by a JavaScript function that monitors a history stored in browser disk cache  of visited web page URLs and generates an event whenever the history changes state. For ease of reference, we will collectively define the term \u201cclick-stream\u201d to encompass any user-initiated transition to a new content page, whether it is a mouse click, key depression or history state change.","Transition Sensor events are used to trigger the play of an advertisement only if, by then, all the media and player files for that advertisement have been fully cached into browser disk cache . Otherwise, play of that advertisement is deferred until after all those files are cached and the advertisement is ready to be rendered and, importantly, in response to the next user-initiated transition.","Client browser  produces init (initialize) and start and stop Transition Sensor events, as symbolized by line  and , respectively. The init and start events are produced by the browser to initialize (i.e., load and instantiate) and start the Transition Sensor applet. The stop events are also produced by the browser, though through a Transition Sensor stop method which has been substituted for a standard browser stop method, in response to detection, by the Transition Sensor, of user-initiated page transitions. These events control the state of applet . Transition Sensor applet  communicates directly with AdController applet , as symbolized by line \u2014such as to pass an Internet address of an advertising server, and indirectly, as symbolized by line , through applet registry . Registry  passes information, as symbolized by line , to AdController applet .","As noted above, AdController applet  extends standard Java applet class definitions by over-riding standard Java applet init, start, run, stop and destroy life cycle methods. Doing so, particularly in the case of the Stop method (which will be described below in conjunction with ), permits the AdController applet to persist in browser disk cache  as the user navigates across successive pages and web sites.","Advantageously, the AdController applet can readily function in a wide variety of environments, without changes to the coding of the applet itself. This is accomplished through downloading of an external configuration file (specifically file  shown in , which will be discussed below), as part of the applet files, from agent server . Suitably changing parameter values in the configuration file permits the behavior of applet  to be readily changed to suit a desired environment without a need to utilize a different version of that applet for each different environment, otherwise requiring different software classes and with attendant modifications and re-compilation.","Execution of AdController applet  begins by Transition Sensor applet  calling a standard init Applet method, which downloads the external configuration file, followed by extracting and saving its configuration parameters. These parameters are supplied, as symbolized by line , to the AdController applet, during its execution in order to define its behavior given its current execution environment.","As noted above, AdController applet  \u201cpolitely\u201d and transparently downloads advertising (including media and, where necessary, player) files, through browser  into browser disk cache , for each and every advertisement that is to be subsequently and interstitially played. A data path through which advertisements are downloaded is shown in  by dot-dashed lines; while that for advertisement play is shown in this figure by dotted lines.","Specifically, to download and play advertisements, applet  implements Ad Pipeline  (which will be discussed in detail below in conjunction with ). Pipeline  implements various threads (processes) and data structures which collectively load advertising files into browser disk cache  (and, for media files, also into browser RAM cache) and then present fully downloaded advertisements. The pipeline implements Ad Producer, Ad Location and Ad Downloader processes (processes , ,  shown in ,  and , respectively, and discussed in detail below), and download queue  and play queue  (both of which are shown in  and discussed in detail below).","In essence, once Transition Sensor applet , as shown in , supplies AdController applet  with a URL of an AdDescriptor file, Ad Pipeline  then downloads, as symbolized by dot-dashed line , the AdDescriptor file, via agent server  (serving as a proxy server), from a remote advertising management system. As noted above, this file contains a manifest of media and player files necessary to fully play a complete advertisement. Once this AdDescriptor file has been downloaded into Ad Pipeline , pipeline  then \u201cpolitely\u201d downloads, as symbolized by line , each file specified in the manifest\u2014to the extent that file does not already reside on the client hard disk. Pipeline  then, once the downloading (to the extent needed) is complete, writes the AdDescriptor file to the play queue and each downloaded file specified therein to browser disk cache ; hence forming a queued advertisement for subsequent access.","At the inception of an interstitial interval, signaled by a Transition Sensor stop event, the AdController applet interstitially plays an advertisement that has then been completely queued\u2014both in terms of its media and player files. In particular, at the start of that interval, the Ad Pipeline retrieves an AdDescriptor that is then situated at the head of a play queue. Media players  required by that advertisement, as specified in the AdDescriptor file, are started in the order specified in that file along with their corresponding media file(s). A resulting processed media stream, produced by the player(s), and as symbolized by line , is rendered through browser  to the user. Media players  may permanently reside, i.e., apart from being downloaded by agent , on the client hard disk (thus being implemented by resident player files  as shown in ) or be downloaded by pipeline  into browser disk cache  (and also browser RAM cache) for subsequent access and use (thus stored within files  shown in ).","Once an advertisement completely plays, AdController applet , as shown in , establishes an appropriate log entry for a \u201cuser impression\u201d for that advertisement. Advertisement files are retained in the browser disk cache until that cache completely fills, at which point these files, like any other content files stored in that cache, are deleted by the browser on a first-in first-out (i.e., age order) basis. Media players , browser  and browser disk cache  are all shown in dashed lines as these components, while being used by the AdController agent, are not viewed as constituting components solely within the agent itself.",{"@attributes":{"id":"p-0145","num":"0144"},"figref":["FIGS. 6A and 6B","FIG. 6","FIGS. 8"],"b":["600","420","9","9","12","14","19"]},"Upon entry into process  as shown in , which occurs in response to an Transition Sensor init event from browser , block  is performed. Through this block, Transition Sensor applet  instructs the applet registry to load the AdController applet. Once that occurs, block  is performed through which external AdController configuration file  is retrieved from agent server . Thereafter, through decision block , agent  waits, by looping through NO path , until browser  generates a Transition Sensor start event. When such an event occurs, execution proceeds, via YES path  emanating from this decision block, to block . Through this latter block, AdController applet  obtains an Internet address of an advertisement management system (e.g., system ) from which the agent is to retrieve AdDescriptor file . Applet  then passes this address to Ad Pipeline . The Ad Pipeline, as indicated in block , then retrieves AdDescriptor file  from this address and particularly and through agent server  serving as a proxy server. Once this file is retrieved, the agent performs block  which \u201cpolitely\u201d downloads all the media and player files  (to the extent each file does not already reside on the client hard disk), from advertising management system  (residing on advertising server ), and, through block , stores these files into browser disk cache  (and, in the case of media files, into browser RAM cache). As noted above, these files are downloaded via agent server , which here too serves as a proxy server. This downloading continues until either it finishes or a Transition Sensor stop event generated by the browser arises, whichever occurs first. As to the stop event, decision block  tests for its occurrence, with execution looping back, via NO path , in the absence of such an event. However, whenever this event occurs, such as (as discussed above) in response to a user-initiated page transition, decision block  routes execution, via YES path , to block . This latter block then, using media players , plays an advertisement then fully queued in the play queue on the browser disk cache, i.e., an AdDescriptor file for this ad then resides at a head of the play queue and all associated media and player files for that advertisement, as specified in that AdDescriptor file, then reside on the client hard disk.","3. AdController Applet ",{"@attributes":{"id":"p-0148","num":"0147"},"figref":"FIG. 7","b":"424"},"As shown, in response to a Transition Sensor init event produced by the client browser, one thread executes block  to initialize AdController applet . This block performs the downloading (to the extent necessary) and instantiation of applet . In response to a Transition Sensor start event produced by the client browser, another thread, by executing block , starts the AdController applet. Once this applet is started, this applet, in turn and as discussed above, through execution of block , enables downloading of advertising (media and player) files to commence. In response to a received Internet address of a remote ad management system (here, e.g., system  shown in ) supplied by the Transition Sensor applet, a third thread requests, through execution block  shown in , an AdDescriptor file from the ad management system situated at this address and then downloads AdDescriptor file  received in response. If, by this time, block  has enabled advertisement downloading, then advertising files, as specified in AdDescriptor file , are \u201cpolitely\u201d downloaded as required. In response to a Transition Sensor stop event produced by the client browser and which signals an inception of an interstitial interval, another thread, here commencing with execution of block , suspends downloading of advertisement files in favor of displaying a queued advertisement. Once this downloading is suspended, this last thread invokes block  to commence play of an advertisement then situated, in terms of its AdDescriptor file, at a head of the play queue.",{"@attributes":{"id":"p-0150","num":"0149"},"figref":"FIG. 8","b":["800","424"]},"Upon entry into operations , which occurs in response to an init event produced by the Transition Sensor applet, block  is performed. Through this block, the AdController applet is initialized. This includes downloading files, to the extent needed, for this applet from the agent server and then instantiating this applet. Once this occurs, block  tests for an occurrence of AdController start event produced by the Transition Sensor applet. Until this event occurs, execution merely loops back, via NO path , to block . When this event occurs, decision block  routes execution, via YES path , to block . This latter block, retrieves external AdController configuration file  from the agent server. Thereafter, block  occurs through which the AdController applet creates and starts Ad Pipeline . Once the pipeline is fully started, then, block  is performed to enable advertisement files to be \u201cpolitely\u201d downloaded into the Ad Pipeline and to thereafter actually download such files. While advertisement files are being downloaded or thereafter, if such downloading has completed, decision block  tests for an occurrence of a Play Ad event. If no such event occurs, then execution loops back, via NO path , to decision block  to continue any further downloading. If however, a Play Ad event occurs, then decision block  routes execution, via YES path , to block . This latter block suspends further downloading of advertisement files into the Ad Pipeline. Once this occurs, then block , when performed, issues a request to the Ad Pipeline to play an advertisement having its AdDescriptor file then located at the head of the play queue. While the advertisement is being played, decision block  tests for an occurrence of an shutdown event generated by the browser, such as caused by, e.g., a user-initiated transition or the user closing an advertisement window or closing the browser itself. If such an event does not occur, decision block  routes execution, via NO path , back to block  to re-enable \u201cpolite\u201d download of advertisement files once again. If such a shutdown event occurs, then processing operations  terminate, via YES path .",{"@attributes":{"id":"p-0152","num":"0151"},"figref":["FIGS. 9A and 9B","FIG. 9"],"b":["900","424"]},"Upon entry into operations , block  is performed to receive a request, issued by the Transition Sensor applet, to download a next advertisement, specifically a corresponding AdDescriptor file. This request contains an Internet address of a remote ad management system. In response to this request, AdController applet  performs block  to request Ad Producer process (also being a thread)  to download an ad. The Ad Producer process, as will be discussed below in conjunction with , requests advertisement files, specifically an AdDescriptor file, from an Internet address communicated by the Transition Sensor applet. Thereafter, through block , the Ad Producer process blocks (i.e., it actively waits for its input data) until this process receives the Internet address of the remote advertising management system. Thereafter, block  executes to cause Ad Location process (also being a thread)  to block until such time as the AdDescriptor file is fully downloaded by Ad Producer process  and is provided to the Ad Location process. Ad Location process , as will be discussed below in conjunction with , performs the following tasks: (a) on startup of process , this process creates an Ad Producer object; (b) it asks Ad Producer process  for next AdDescriptor file ; and (c) once process  obtains such AdDescriptor file  and if download queue  (see ) is not full, it writes that file into this queue. If this queue is then full, process  simply waits until the queue is not full before writing the AdDescriptor file into the queue. Once the AdDescriptor file has been completely downloaded, Ad Location process  inserts, as shown in block , this file into download queue .","Once AdDescriptor file  is inserted into the download queue, then Ad Downloader process (also being a thread)  executes. This process, as will be discussed below in conjunction with , performs a single chain of tasks.","First, as shown by block , process  blocks until such time as the AdDescriptor file for the advertisement to then be downloaded becomes available in the download queue. During its execution, this process asks download queue  if there is an AdDescriptor file therein, i.e., such a file for which advertising files need to be downloaded. If the download queue is empty, then AdDescriptor process  both waits until that queue is not empty and also retrieves the AdDescriptor file over the network. Once the Ad Downloader process has retrieved the AdDescriptor file, this process, through execution of block , requests browser cache proxy  (shown in ) to download all ad media and player files. In response to this request, browser cache proxy  then downloads, as shown by block , all the advertising files specified in the AdDescriptor file, into browser disk cache (and, in the case of media files, into browser RAM cache). Once all the advertising files have finished downloading, the Ad Downloader process, as shown in block , moves the AdDescriptor file to play queue  (see ). However, if the play queue is then full, the Ad Downloader process will wait until the play queue is not full before moving the AdDescriptor file into this queue.","The Browser Cache Proxy implements an interface to an abstract cache. The cache implementation could be any kind of cache\u2014the browser disk or RAM cache, a Java virtual memory cache, a local raw disk cache, and so forth. Once passed through this cache proxy, the media files that constitute an advertisement will have been downloaded into both disk and RAM cache of the browser. Whenever the Ad Downloader process subsequently tries to access any media file having an identical URL to that downloaded, this process will first attempt to load the files from the browser disk cache or browser RAM cache instead of downloading the file, via the Internet, from its advertising management server; thus leveraging, even across different referring web pages or sites and to the extent possible, a one time download of an advertising file across different advertisements.","Next, should a Transition Sensor stop event occur, i.e., indicative of a start of a next interstitial interval, then Transition Sensor stop method  will request, as shown by execution of block , that AdController applet  then play an advertisement. In response to this request, an event scheduler thread within the applet will block, as shown in block , until such time as applet  responds to this request by initiating play of an advertisement. The event scheduler thread controls playing of advertisements to the user. This thread determines when to execute media players specific to the next advertisement in the play queue (i.e., in terms of corresponding AdDescriptor files situated in that queue), as well as provides a callback method which the player executes when that player has successfully completed presenting an advertisement as specified in its corresponding AdDescriptor file. Once the AdController applet has initiated play of an advertisement, then, as shown by block , the event scheduler retrieves an advertisement, specifically the corresponding AdDescriptor file, then situated at the head of the play queue. Thereafter, the event scheduler, as shown in block , launches execution of the specific media player(s)  (see ), as specified in the corresponding AdDescriptor file, to play this particular advertisement. The browser disk cache provides the associated content files for this advertisement to the media player(s). Once the advertisement has been fully presented, then, as shown in block , AdController applet , through the event scheduler thread, appropriately logs this presentation into a log file maintained in the browser disk cache for subsequent uploading to the agent server. Execution then exits from operations .","A logger process (also implemented as a thread) keeps track of all log entries that need to be sent back to the agent server. This process simply timestamps entries and adds them to a log buffer. Then, periodically, the logger process will flush the log back to the agent server where those entries can be archived and analyzed.","For an advertisement, player mechanisms take associated media files specified in the associated AdDescriptor file from the browser cache and actually display these files to a user via a viewable frame or window. The user will view a pre-cached smoothly playing advertisement out of the browser disk cache and, where appropriate for media files, from browser RAM cache, rather than being streamed in over the Internet. Four modes for displaying advertisements are supported; namely, user-event triggered ad play, frame-targeted ad play, timer-based ad play and PopUp Java frame play. Each of these player mechanisms uses a media player module (contained within media players  shown in ) and a player thread. The player thread provides an actual presentation of advertising media to the user then operating the client browser. The combination of a player and a player thread provides capabilities of: controlling time-based frequency of advertisement play using an agent configurable timer; displaying advertising media files in a browser window or Java frame; waiting a configurable amount of time (usually the length of the advertisement as specified in its AdDescriptor file); and terminating the advertisement visually upon completion, or at a request of the user if the advertisement, as configured in its AdDescriptor file, permits pre-mature termination.","A frame-targeted play renders advertisement media onto a browser window. Such play is interruptible and restartable upon user-demand. Timer-based ad play utilizes a separate thread that continuously loops to: obtain an AdDescriptor file from the play queue; display that advertisement using a player and player thread; and sleep for a specified amount of time before repeating this sequence. Timer-based ad play is also interruptible and restartable upon user-demand. The result of this type of advertisement play is that the user will periodically view advertisements delivered at regular time intervals rather than by user initiated events. The PopUp Java frame play is a separate thread that also continuously loops to: obtain an AdDescriptor file from the play queue; waits for a signal that a user-initiated transition is occurring; pops up a display window (\u201cpop-up\u201d window) in the browser, for a pre-defined period of time, and presents the advertisement in that window; and removes the pop up window before repeating this sequence. The result of the PopUp Java Player is that the user will view successive advertisements each for pre-defined time interval (which can vary from one advertisement to the next, as specified in the AdDescriptor files for each such advertisement) whenever the user transitions between one web page and the next. Once an advertisement is completely played and in the absence, as discussed above of any instructions in the AdDescriptor file to replay that advertisement, such as through, e.g., timer-based ad play, the associated AdDescriptor file is effectively \u201cpulled off\u201d the play queue.","In particular, downloading of advertisement files occurs, as discussed previously, continuously as effectively a background process, using a separate asynchronous thread. The stop method of the Transition Sensor (specifically Transition Sensor stop method  as will be described below in conjunction with ) is responsible for generating a play event to the AdController agent. This event notifies the agent of an opportunity to present a downloaded advertisement to the user. This stop method is called automatically by the client browser whenever a user transitions off a web page that contains the embedded advertising tag. In particular, this method invokes a start player method in the AdController agent. The start player method, in turn, invokes a similarly named method, in the event scheduler, which initiates and controls the presentation of advertisements during content page transitions. The event scheduler ensures all media files for an advertisement have been transparently downloaded before their presentation, as well as exercises control over actual execution of the appropriate player classes required to visibly render the advertisement. In that regard, the event scheduler instantiates and invokes a player class appropriate for the current advertisement by calling a start method of that class. This start method creates the player thread that performs visual rendering of the advertisement. Then, this start method calls a run method of the player thread in order to visually present the advertising media from the browser disk and RAM caches. Upon completion, based on the configuration of the advertisement, the run method, by executing its own stop method, terminates the advertisement either upon detecting a close request by the user or completion of ad play timeout. The stop method performs any player software termination and cleanup, finally executing a callback to the scheduler object.","4. Inter-Applet Events Involving Transition Sensor Applet ",{"@attributes":{"id":"p-0163","num":"0162"},"figref":"FIG. 10","b":["1000","420","422"]},"As shown and discussed above, whenever a browser interprets and then executes advertising tag , specifically tag  therein, situated within content page , this causes, as symbolized by line , the browser to download script  (see ) from the agent server. This applet, in turn, dynamically writes Transition Sensor applet  (also referred to as applet ) into the referring web content page. As discussed above, once this applet is instantiated and executed by the client browser, the applet, in turn, instantiates applet registry .","Once the applet registry is instantiated, the Transition Sensor queries the registry, this operation being symbolized by line , to determine current status of the AdController applet. If, as symbolized by line , the registry indicates that the AdController applet is not loaded and hence is not executing, then Transition Sensor applet  loads, as symbolized by line , AdController applet  from the browser disk cache, and then instantiates and starts this applet. Once the AdController applet is instantiated, the Transition Sensor applet writes, as symbolized by line , appropriate entries, indicating that both the Transition Sensor applet is loaded and, as symbolized by line , that the AdController applet is loaded, into the applet registry. Once this occurs, then the applet registry returns, as symbolized by line , an appropriate handle for the AdController applet to the Transition Sensor in order to permit the latter to refer to the former. Thereafter, as symbolized by line , the Transition Sensor passes, as discussed above a request containing an Internet address of an advertisement management system to the AdController applet to download an AdDescriptor file, for an advertisement, from that address. This address is specified in tag  of advertising tag  and, as symbolized by dashed line , incorporated into the request. Thereafter, the Transition Sensor, in response to a user-initiated transition (click-stream) to a next content web page, executes its stop method (method  shown in ) to instruct, i.e., issue a request to, as symbolized by line , the AdController applet to play a fully downloaded advertisement having its corresponding AdDescriptor file then situated at the head of the play queue. Once this occurs, the Transition Sensor applet terminates its execution until the browser next encounters, interprets and executes a content page containing advertising tag  at which point the Transition Sensor applet is re-loaded and re-started; and so forth.","5. Transition Sensor Applet ",{"@attributes":{"id":"p-0167","num":"0166"},"figref":"FIG. 11","b":"422"},"As shown, in response to a Init (Initialize) Transition Sensor applet event produced by the client browser, a thread commences by executing block  to initialize Transition Sensor applet . This thread, in turn, executes block  to load AdController applet  from browser disk cache or download it from the agent server, if necessary, and then load it. Thereafter, this thread executes block  to obtain the Internet address of an advertising management system (e.g., system  shown in , A and B, and ) in tag  from advertising tag .","As shown in , in response to a Start Transition Sensor applet event generated by the client browser, another thread commences by executing block  to enable Ad Downloader process  (as discussed above, and to be discussed in detail below in conjunction with ) to commence \u201cpolite\u201d downloading an AdDescriptor file and all required and associated advertisement files (both media and player) into the browser disk cache.","Further, as shown in , in response to a Stop Transition Sensor applet event generated by the client browser, a third thread commences by executing block  to disable Ad Downloader process  and thus suspend further downloading of advertisement files. Once this occurs, this thread then executes block  to instruct the AdController applet to play a fully downloaded advertisement having its corresponding AdDescriptor file then situated at the head of the play queue.",{"@attributes":{"id":"p-0171","num":"0170"},"figref":"FIG. 12","b":["1200","422"]},"Upon entry in operations , decision block  tests for an occurrence of an init event produced by the client browser. Until such an event occurs, execution loops back, via NO path , to block . When this event occurs, execution proceeds, via YES path  to block  which, when performed, initializes Transition Sensor applet . Thereafter, block  is performed through which the Transition Sensor applet  instructs, by issuing a request to, the AdController applet to download an advertisement, specifically as discussed above an AdDescriptor file from an ad management server specified in the advertising tag. Once this occurs, decision block  tests for an occurrence of a Transition Sensor start event generated by the client browser. Until such an event occurs, execution loops back, via NO path , to block . When this particular event occurs, execution proceeds, via YES path  to block  which, when performed, enables Ad Pipeline  to download the AdDescriptor file and associated advertising files.","Next, decision block  tests for an occurrence of a Transition Sensor stop event generated by the client browser. Until such an event occurs, execution loops back, via NO path , to block . When a Transition Sensor stop event occurs, execution then proceeds, via YES path  to block  which, when performed, requests that AdController applet , specifically via Ad Pipeline , then play an advertisement.","6. Ad Loader Process ",{"@attributes":{"id":"p-0175","num":"0174"},"figref":"FIG. 13","b":["1300","424","1300"]},"As shown, this process includes Ad Loader API (application programming interface)  which interfaces to Ad Pipeline  and through this pipeline controls how advertisements are presented, as symbolized by block , by the player mechanisms. In particular, the Ad Loader API provides information regarding and, through setting various program variables, permits programmer control over advertisement display and downloading operations. In that regard, these variables provide a callback to the AdController applet indicating when a content page to which the user has just transitioned has completed its downloading; and can be used to: instruct the AdController applet when to download a next advertisement, when to play a next advertisement fully queued in the Ad Pipeline, start and stop a play timer (for use with, e.g., timer-based ad play, as discussed above), log a message, set a mode so as to specify a desired location to display advertisements, suspend and resume download of advertisement files into the Ad Pipeline, suspend a current download for a given period of time, and suspend and resume advertisement play by the player mechanisms.","In that regard, the Ad Loader API configures Ad Pipeline  such that AdDescriptor file  is downloaded, as symbolized by block , from a remote ad management system into the Ad Pipeline in response to receipt of an Internet address of an ad management system and, for targeted advertisements, a URL of a referring web page address. As symbolized by block , the API configures the Ad Pipeline such that advertisement downloading is enabled only when AdController applet  is not playing an advertisement. Furthermore, as symbolized by block , the API configures the Ad Pipeline such that advertisement downloading is disabled whenever the AdController applet is playing an advertisement. Furthermore, as symbolized by block , the API configures the Ad Pipeline such that advertisement play is to commence in response to a request to play a next advertisement, i.e., one that is fully cached in the browser disk cache and having its AdDescriptor file then situated at the head of the play queue.","7. Ad Pipeline ",{"@attributes":{"id":"p-0179","num":"0178"},"figref":"FIG. 14","b":["545","1500","1600","1700"]},"In response to an incoming request to download an advertisement, Ad Pipeline  is invoked. Specifically, within this pipeline, first block  executes to invoke Ad Producer process  in response to an incoming request to download an advertisement. As discussed above, this request, issued by the Transition Sensor applet, includes an Internet address of a remote ad management system (e.g., system  shown in ) on which an advertisement resides and is to be downloaded (through agent server  as a proxy server). Ad Producer process , as will be discussed below in conjunction with , requests advertisement files, specifically an AdDescriptor file (e.g., file ), from an Internet address specified in the request. During its execution, the Ad Producer process waits until it receives the Internet address of the remote advertising management system, whereupon this process then downloads AdDescriptor file  from the specified ad management system. Once this file has been downloaded, block , shown in , executes to invoke Ad Location process  (which will be discussed in detail below in conjunction with ). During its execution, Ad Location process  blocks until such time as AdDescriptor file  is fully downloaded by Ad Producer process  and is provided to the Ad Location process, whereupon the Ad Location process writes this AdDescriptor file into download queue .","After AdDescriptor file  has been written into the download queue, Ad Location process , as will be discussed below in conjunction with , performs the following tasks: (a) on startup of process , this process creates an Ad Producer object; (b) this process asks Ad Producer process  for next AdDescriptor file ; and (c) once process  obtains AdDescriptor file  and, if download queue  is not full, process  writes that file into this queue. If this queue is then full, process  simply waits until the queue is not full before writing the AdDescriptor file into the queue. Once the AdDescriptor file has been completely downloaded, Ad Location process  inserts, as shown in block , this file into download queue .","Once AdDescriptor file  is inserted into the download queue, then block  executes to invoke Ad Downloader process . Process , which will be discussed below in conjunction with , performs a single chain of tasks. First, process  blocks until such time as the downloaded AdDescriptor file has become available in the download queue. During its execution, this process asks download queue  if it contains an AdDescriptor file, e.g., file . If so, then advertising files need to be downloaded for that particular AdDescriptor file. If the download queue is empty, then process  both waits until that queue is not empty and also retrieves the AdDescriptor file over the network. Once Ad Downloader process  has obtained this AdDescriptor file, process  then downloads, all the media and required player files specified in the AdDescriptor file by using Browser Cache Proxy , into browser disk (and RAM) cache . Once all the advertising files have finished downloading, process  moves the AdDescriptor file to play queue . However, if the play queue is then full, the Ad Downloader process waits until play queue  is not full before moving the AdDescriptor file into this queue for subsequent ad play. As discussed above, AdDescriptor file  for a fully queued ad (i.e., with its all the associated media and player residing on the client hard disk) is subsequently retrieved from play queue  in response to a request to play an advertisement, this request being issued in response to a Transition Sensor stop event.","8. Ad Producer Process ",{"@attributes":{"id":"p-0184","num":"0183"},"figref":"FIG. 15","b":"1500"},"As shown, upon entry into process , execution first proceeds to decision block . This block determines whether a URL has been received, from the Transition Sensor, from which to fetch an AdDescriptor file. If such a URL has not yet been received, then execution loops back, via NO path , to this decision block. Alternatively, if such a URL has been received, then execution proceeds, via YES path , to block  which, in turn, stores this URL, as Ad URL , for use during a next successive advertisement download opportunity.","Once this URL has been so stored, execution proceeds to decision block . This block tests for an occurrence of a user-initiated event (click-stream) signifying that advertisement downloading can now occur, such as, e.g., when the user has just closed an existing advertisement frame and a next successive content page to which the user has transitioned is being rendered by the client browser. If such an event has not yet occurred, e.g., the next successive content web page is downloading, then execution merely loops back, via NO path , back to decision block . However, if such an event occurs, then this decision block routes execution, via YES path , to block . This latter block, when executed, downloads AdDescriptor file  using the URL communicated by the Transition Sensor. Once this file is completely downloaded, then block  executes to transfer this file to Ad Location process . Thereafter, execution loops back, via path , to decision block , and so forth.","9. Ad Location Process ",{"@attributes":{"id":"p-0188","num":"0187"},"figref":["FIG. 16","FIG. 14"],"b":["1600","1600","1600","1500","645","1600","645","1430","1600","1600"]},"Upon entry into process  and with respect to advertisement downloading itself, execution proceeds to decision block . This decision block, when executed, determines whether an Internet address (URL) of an ad management system has been received from the Transition Sensor applet from which a next successive advertisement download. If that address has not yet been received, then execution merely loops back, via NO path , to decision block . Alternatively, if such an address has been received but not yet processed, then decision block  routes execution, via YES path , to block . This latter block requests Ad Producer process  to download an AdDescriptor file, e.g., file , from this URL. Once this request occurs, execution proceeds to decision block  to determine whether this AdDescriptor file has been completely downloaded. If this file download is still occurring, then execution merely loops back, via NO path , to block  to await completion of the download. Once this download completes, decision block  routes execution, via YES path , to block . This latter block writes the downloaded AdDescriptor file into download queue  (providing this queue is not full). Once this occurs, execution is directed, via path , back to decision block , and so forth.","10. Ad Downloader Process ",{"@attributes":{"id":"p-0191","num":"0190"},"figref":"FIG. 17","b":["1700","1700","645","1700","1700"]},"In particular upon entry into process , execution proceeds to decision block . This decision block determines whether the download queue then contains an AdDescriptor file, e.g., file . If the queue is empty, then execution merely loops back, via NO path , to this decision block to await such an AdDescriptor file. However, if download queue  then contains such a file, process  obtains the AdDescriptor file then situated at the head of this queue. Thereafter, block  executes. This block downloads all the required advertising files, not then resident on the client hard disk, into browser proxy cache . This block also transfers all the associated media files in the browser proxy cache to the browser RAM cache. Execution then proceeds to decision block  which determines whether all required advertising files have then been downloaded. If any such file remains to be downloaded, then decision block  routes execution, via NO path , back to block  to download that file. Alternatively, if all the required advertising files have been downloaded, then execution proceeds, via YES path , to block . This latter block moves the AdDescriptor file from download queue  to an end of play queue . Once the AdDescriptor file is written into the play queue, the corresponding advertisement is then ready to be presented to the user, in order relative to other AdDescriptor files then queued in the play queue, during an ensuing interstitial interval.","11. Transition Sensor Stop Method ",{"@attributes":{"id":"p-0194","num":"0193"},"figref":"FIG. 18","b":["1800","422"]},"In particular, upon entry into method , decision block  executes to determine if a stop event has been received from browser . If such a stop event has yet not occurred, then execution loops back, via NO path , back to block  to await occurrence of this event. When this event occurs, decision block  directs execution, via YES path , to decision block . This latter decision block determines if AdController applet  is then loaded and executing. If this applet is not then executing, decision block  routes execution, via NO path , to block . This latter block inhibits any request from being made to the AdController applet to play any advertisement until that applet is executing and, once that occurs, a next user-initiated (click-stream) event occurs. Thereafter, execution of method  terminates. Alternatively, if the AdController applet is loaded and executing, then decision block  routes execution, via YES path , to block . This latter block requests the AdController applet to play a next advertisement. Once this request is issued, then execution proceeds to block . This block, in turn, requests the AdController applet to suspend \u201cpolite\u201d background downloading of advertisement files while a next successive web content page, as requested by the user, is being downloaded by the browser. Once block  executes, execution of method  terminates.","12. Transition Sensor Start Method ",{"@attributes":{"id":"p-0197","num":"0196"},"figref":"FIG. 19","b":["1900","422"]},"Specifically, upon entry into method , execution proceeds to decision block  which, when executed, determines if a start event has been received from browser . If such a start event has not yet occurred, then execution loops back, via NO path , back to block  to await occurrence of this event. When this event occurs, decision block  directs execution, via YES path , to decision block . This latter decision block determines if AdController applet  is then loaded and executing. If this applet is not then executing, decision block  routes execution, via NO path , to block . Block  inhibits any request from being made to the AdController applet to download any advertisement until that applet is executing and, once that occurs, a next user-initiated (click-stream) event occurs. Once the AdController applet begins executing and thereafter a next user-initiated (click-stream) event occurs, execution proceeds to block . This latter block requests the AdController applet to resume background downloading of advertisement files. Once this downloading is resumed, method , through execution of block , waits for browser  to call Transition Sensor stop method  whenever the user next unloads a web page currently rendered by the browser, i.e., causes a user initiated-event to transition to a next successive web page. Alternatively, if the AdController applet is loaded and executing, then decision block  routes execution, via YES path , to block . Since at this point the next successive content web page has been fully executed by the browser and is, e.g., rendered to the user, block  issues a request, through the applet registry, to the AdController applet to enable it to resume background downloading of advertisement files. Once this occurs, block  is executed to issue a request to the AdController applet to resume the background downloading. Execution then proceeds to block  to wait for browser  to call Transition Sensor stop method  whenever the user next unloads a web page currently rendered by the browser, i.e., causes a user initiated-event to transition to a next successive web page. Whenever the browser generates a next Transition Sensor stop event, process  terminates.","Although a single embodiment which incorporates the teachings of our present invention has been shown and described in considerable detail herein, those skilled in the art can readily devise many other embodiments and applications of the present invention that still utilize these teachings."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The teachings of the present invention can be readily understood by considering the following detailed description in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 1A","FIGS. 1B and 1C"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIGS. 1B and 1C"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 1D","FIGS. 1E and 1F"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIGS. 1E and 1F","FIGS. 1B and 1C"],"b":"50"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 2","FIGS. 2A and 2B"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIGS. 2A and 2B","b":["35","40","210","40","351"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 3","FIGS. 1B and 1C"],"b":["5","1","1"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 4","FIG. 3"],"b":["400","5"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 5","FIG. 4"],"b":"420"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 6","FIGS. 6A and 6B"]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIGS. 6A and 6B","FIG. 5"],"b":["600","420"]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 7","FIG. 4"],"b":["424","420"]},{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 8","FIG. 7"],"b":["800","424"]},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 9","FIGS. 9A and 9B"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIGS. 9A and 9B","FIG. 7"],"b":["900","424"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 10","b":["420","422"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 11","FIG. 4"],"b":["422","420"]},{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 12","FIG. 11"],"b":["1200","422"]},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 13","b":["1300","424"]},{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 14","FIG. 4"],"b":["545","424"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 15","FIG. 14"],"b":["1500","545"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 16","FIG. 14"],"b":["1600","545"]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 17","FIG. 14"],"b":["1700","545"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 18","FIG. 4"],"b":["1800","422"]},{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 19","FIG. 4"],"b":["1900","422"]},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 20","b":"2000"}]},"DETDESC":[{},{}]}
