---
title: Code interpretation using stack state information
abstract: Executing an instruction on an operand stack, including performing a stack-state aware translation of the instruction to threaded code to determine an operand stack state for the instruction, dispatching the instruction according to the operand stack state for the instruction, and executing the instruction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07424596&OS=07424596&RS=07424596
owner: Intel Corporation
number: 07424596
owner_city: Santa Clara
owner_country: US
publication_date: 20040331
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS OF THE PRESENT INVENTION"],"p":["Interpretation is one of the broadly used technologies to implement Virtual Machine (VM) and runtime systems, with the benefits of portability and maintainability. VMs, runtime systems, and other high level language processors, such as Java Processors, incorporate a stack caching scheme to virtually map bytecode, for example, to an operand stack. One type of stack caching scheme, a mixed stack, may use physical registers and a contiguous memory region as an operand stack. An interpreter plays an important role in many runtime systems. Many modem programming languages, such as Java, Forth, Perl, and Python are still employing various interpreters as their execution engines when they are programmed and run on memory\/computation constraint devices, for example.","The interpretation of stack-based languages may rely on an auxiliary data structure, e.g., operand stack, on which the executions of instructions are operated. Accessing the operand stack may involve memory accesses. In various methods to improve the performance of interpretation. Among those methods, stack caching may be an efficient approach to eliminate most of the accesses to the operand stack and is able to speedup interpretation. Stack caching may promote top-of-stack operands to registers, which may reduce the number of memory accesses and results in higher instructions per cycle.","To manipulate different states of a mixed stack, for example, a stack-caching interpreter may maintain many copies of execution code for each VM instruction. Such a design incurs code explosion which may consume excessive memory and introduce maintenance complexity.","Exemplary embodiments of the invention are discussed in detail below. While specific exemplary embodiments are discussed, it should be understood that this is done for illustration purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without parting from the spirit and scope of the invention.","Embodiments of the present invention may provide a code sharing mechanism for stack caching that avoids code duplication. A stack caching scheme may use a mixed register-stack model, i.e. a mixed stack, that virtually maps to a bytecode (e.g., Java or CLI) operand stack. The mixed stack may consist of two parts: a register stack and a memory stack. The register stack may be comprised of physical registers that may hold several top elements of the operand stack. The memory stack may be a contiguous memory region that may hold the rest of elements of the operand stack.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","101","102"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","200","201","202","203","204","205","201","201","202","201","201","203","204","205"]},"In an exemplary embodiment of the invention, machine instructions may take operands from an operand stack, operate on them, and return results to the stack. A stack may be a 32-bit stack, for example, that may be used to pass parameters to methods and receive method results, as well as to supply parameters for operations and save operation results. In an exemplary embodiment of the invention, a stack may be a mixed stack as is described above.","In an exemplary embodiment of the invention, an interpreter, such as interpreter  may keep most, if not all, bytecode instructions to be operated on in a register stack instead of a memory stack. Doing so may reduce memory accesses and execution time of the instruction.","In an exemplary embodiment of the invention, the interpreter may need to perform shift operations to maintain the top-of-stack elements of the operand stack in the register stack. For example, if one instruction consumes the one register as is shown in , the top-of-stack register R may be removed from the register stack, the resulting value of R may need to be shifted to the top, R to R. Because the memory stack is not empty (register stack underflow), the value in slot  may also be shifted to R so as to keep the register stack fully loaded with values. The memory stack pointer (sp) may also be updated to sp' after slot is drained. On the other hand, as is shown in , if one instruction generates one value that needs to be pushed onto the register stack, R may need to be vacated by shifting values down, i.e., R to slot  (register stack overflow), R to R and then R to R.","While embodiments of the present invention are described in terms of the examples below, this description is for convenience only and is not intended to limit its application. In fact, after reading the following description, it will be apparent to one skilled in the relevant art(s) how to implement the following invention in alternative embodiments (e.g., in a Common Language Runtime Environment).","Furthermore, while the following description focuses interpreting JAVA bytecode, it is not intended to limit the application of the present invention. It will be apparent to one skilled in the relevant art how to implement the following invention, where appropriate, in alternative embodiments. For example, embodiments of the present invention may be applied, alone or in combination, with various virtual machine architectures, such as, but not limited to, Common Language Infrastructure and other virtual execution systems.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 4","FIG. 4"],"b":["400","401","402","402","403","403","401","404"]},"In an exemplary embodiment of the invention, the stack state may be embodied by the number of shift operations that are needed after the execution of the instruction. As used herein, \u03b7(i) denotes the number of shift operations that are needed after the execution of instruction i. For example, referring to , there are three shift operations in .","To illustrate the method as described with respect to , the integer add instruction, iadd, may be used as an example to explain exemplary embodiments of the code-sharing mechanism. In an exemplary embodiment of the invention, a register stack may consist of 2 registers, for example, that include a top-of-stack (tos) register and a next-top-of-stack (nos) register. For the instruction iadd, there may be two possible stack states, depending on \u03b7(iadd), for executing iadd. The IADD_S on line  of execution code  in  may represent the case of interpreting IADD when \u03b7(iadd)=1 and IADD_S on line  in execution code  may correspond to the case with \u03b7(iadd)=0.","In considering the case \u03b7(iadd)=1, \u03b7(iadd)=1 may occur when an operand stack has more than two elements. In other words, \u03b7(iadd)=1 may occur when the memory stack is not empty and the register stack is full. Because the instruction iadd consumes two operands, (i.e., tos and nos respectively) and produces one (new tos), there may only be one shift operation required to move the top item on the memory stack to the register stack as the new nos. The iadd instruction may then be dispatched to line  of the IADD_S case (as shown in ). Line  of the IADD_S case may pop the top element of the memory stack to a temp register, for example. The execution may then fall through to the IADD_S case, in which the register-wise add operation (line ) may interpret the integer add operation. Line  may refill nos by moving temp to nos to keep the top two elements of the operand stack in registers, for example. As described herein, the combination of lines  and  may constitute the shift operation.","In considering the case \u03b7(iadd)=0, \u03b7(iadd)=0 may occur when the operand stack has only two elements (both are in the register stack). In such a case, no shift operation may be needed because there may only be one element left as the result of the add operation. iadd may be dispatched to IADD_S (tos will be the only stack item after execution). As described above, line  may interpret the integer add operation. Execution of the refilling statement (line ) may then become useless and redundant, but may not affect the correctness of the program because only tos may be a legitimate item after execution of IADD. In such a case, the performance penalty may be trivial for the nature of register-register assignment.","As is shown and described, IADD_S and IADD_S may share the same execution code to avoid excessive code duplication. In an exemplary embodiment of the invention, execution code and instruction dispatching for various stack states may be reused with a comprehensively designed layout. In such an embodiment, during the code-threading phase, the stack state for each instruction may be inferred, and then the instruction may be directly dispatched to the appropriate execution entry without a runtime table lookup, for example. Additionally, the translation phase may perform some optimizations to improve the sequence of interpretation.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 5","FIG. 5","FIG. 5"],"b":"500","sub":"k "},"In , SOis the code that corresponds to the shift operation for OP_S. In SO, the shifted elements may be moved to the register stack (RO) after execution of the operation. In an exemplary embodiment of the invention, OPSmay also execute all the code of its subsequent entries, OP_Sto OPS. That is, in such an embodiment, the code of OP_Sto OP_Smay be shared. ID is the code that calls the next instruction.","As an example, consider the case of register stack size M=2 (i.e., there are 2 registers in the register stack as described above). The property of an instruction i may be defined as [X(i), Y(i)], where X(i) denotes the number of operands that i consumes and Y(i) denotes the number of stack items that i produces.  enumerate all possible code layouts for of 0\u2266X(i)\u2266M and 0\u2266Y(i)\u2266M. As an example, the previous iadd example falls into the category of .","For the instructions whose X(i)>M or Y(i)>M, a similar style of code layout may still be applied. In an exemplary embodiment of the invention, when X(i)>M or Y(i)>M, more register-memory shift operations may need to be performed before the execution code.","As is shown in , each code layout represents a particular category [X(i), Y(i)], where X(i) denotes the number of operands that i consumes and Y(i) denotes the number of stack items that i produces. In an exemplary embodiment of the invention, the stack-state-aware translation phase may complement the code layout design. In such an embodiment, the stack-state-aware translation may happen before the instruction is executed. The translator may walk through the bytecode of the instruction in a pseudo-execution manner, for example, and generate the appropriate threaded bytecode entry for each instruction. At each execution point, the translator may be aware of the operand stack state and [X(i), Y(i)] property of the current instruction i. Accordingly the translator may infer \u03b7(i) based on a static table lookup or on a calculation result of a comprehensive formula, such as f(Depth(opstack), M, X(i), Y(i)).","In the described embodiments, the correctness of the stack-state-aware translation may be based on the fact that the stack depth before and after each bytecode instruction can be determined statically (runtime invariant). Such translation may only need one pass for a majority of bytecode instructions. Such embodiments may enable more optimization opportunities that are exposed during the translation.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 7","FIG. 7"],"b":["700","700"]},"Computer , in an exemplary embodiment, may comprise a central processing unit (CPU) or processor , which may be coupled to a bus . Processor  may, e.g., access main memory  via bus . Computer  may be coupled to an Input\/Output (I\/O) subsystem such as, e.g., a network interface card (NIC) , or a modem  for access to network . Computer  may also be coupled to a secondary memory  directly via bus , or via main memory , for example. Secondary memory  may include, e.g., a disk storage unit  or other storage medium. Exemplary disk storage units  may include, but are not limited to, a magnetic storage device such as, e.g., a hard disk, an optical storage device such as, e.g., a write once read many (WORM) drive, or a compact disc (CD), or a magneto optical device. Another type of secondary memory  may include a removable disk storage device , which can be used in conjunction with a removable storage medium , such as, e.g. a CD-ROM, or a floppy diskette. In general, the disk storage unit  may store an application program for operating the computer system referred to commonly as an operating system. The disk storage unit  may also store documents of a database (not shown). The computer  may interact with the I\/O subsystems and disk storage unit  via bus . Such main memory, secondary memory, disk storage units, and removable disk storage devices are all non-limiting examples of what may be termed, \u201cmachine accessible media.\u201d The bus  may also be coupled to a display  for output, and input devices such as, but not limited to, a keyboard  and a mouse or other pointing\/selection device .","The embodiments illustrated and discussed in this specification are intended only to teach those skilled in the art various ways known to the inventors to make and use the invention. Nothing in this specification should be considered as limiting the scope of the present invention. All examples presented are representative and non-limiting. The above-described embodiments of the invention may be modified or varied, without departing from the invention, as appreciated by those skilled in the art in light of the above teachings. It is therefore to be understood that the invention may be practiced otherwise than as specifically described."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Various exemplary features and advantages of embodiments of the invention will be apparent from the following, more particular description of exemplary embodiments of the present invention, as illustrated in the accompanying drawings wherein like reference numbers generally indicate identical, functionally similar, and\/or structurally similar elements.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6D"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6E"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6F"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6G"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
