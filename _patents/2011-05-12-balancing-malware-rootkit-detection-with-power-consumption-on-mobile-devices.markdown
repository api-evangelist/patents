---
title: Balancing malware rootkit detection with power consumption on mobile devices
abstract: The subject disclosure presents a novel technique for balancing the tradeoff between security monitoring and energy consumption on mobile devices. Security/energy tradeoffs for host-based detectors focusing on rootkits are analyzed along two axes: a scanning frequency, and a surface of attack. Experimental results are applied to a hypervisor-based framework, and a sweet spot is identified to minimize both energy consumption and a window of vulnerability for critical operating system objects such as code pages and kernel data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08566935&OS=08566935&RS=08566935
owner: AT&T Intellectual Property I, L.P.
number: 08566935
owner_city: Atlanta
owner_country: US
publication_date: 20110512
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["GOVERNMENT INTERESTS","BACKGROUND OF THE SUBJECT DISCLOSURE","SUMMARY OF THE SUBJECT DISCLOSURE","DETAILED DESCRIPTION OF THE SUBJECT DISCLOSURE"],"p":["This invention was made in part with U.S. Government support under National Science Foundation (NSF) Grant Nos. CNS-0831268, CNS-0915394, CNS-0931992 and CNS-0952128, and the U.S. Army CERDEC. The government has certain rights in this invention.","1. Field of the Subject Disclosure","The subject disclosure relates to balancing malware rootkit detection with power consumption on mobile devices. In particular, the subject disclosure relates to optimizing power consumption by modulating the rootkit detection as a function of time and coverage.","2. Background of the Subject Disclosure","Mobile electronic devices, or mobile devices, have become an integral part of our everyday lives. Cellular telephones, smartphones, netbooks, and several other devices are used by billions to perform everyday tasks for communication, scheduling, etc. Essentially, the core components of historically larger computers, such as transceivers, displays, storage, and powerful processors are being miniaturized and crammed into small portable devices that are becoming more and more ubiquitous.","With the benefits of packing computing power and networking into a small package also come the costs. One increasing problem is that of malicious software, or malware. Malware is created by malicious entities for several nefarious purposes, spreads itself like a computer virus, and may cripple or even completely disable an electronic device. A particularly potent form of malware is a rootkit, so called because they target the root of the system, i.e., the operating system (OS) kernel itself. By infecting the code and data of the OS kernel, rootkits gain control over the layer traditionally considered the trusted computing base (TCB). Rootkits are therefore able to evade standard user-space malware detectors, such as signature-based scanners. Further, rootkits enable other attacks by hiding malicious processes, allow attackers to stealthily retain long-term control over infected devices, and serve as stepping stones for other attacks such as key-loggers or backdoors.","Early rootkits attempted to hide the presence of malicious processes by compromising system utilities that are used for diagnostics. For instance, a rootkit that replaces the UNIX LS and PS binaries with infected versions can hide the presence of malicious files and processes. Such rootkits are easy to detect by an uncompromised TCB that certifies the integrity of user-space utilities with checksums.","The next generation of rootkits attempt to evade detection by affecting the integrity of kernel code. Such corruption is usually achieved by coercing the system into loading malicious kernel modules. Once a rootkit has gained kernel execution privileges, it can mislead all detection attempts from user or kernel space.","A large majority of rootkits today corrupt kernel control data by modifying function pointers in data structures such as the system call table or the interrupt descriptor table. This attack technique allows rootkits to redirect control to attacker code when the kernel is invoked. Finally, a recent study has reported a 600% increase in the number of rootkits in a three year period between 2004 and 2006. As this explosive growth continues, the increasing complexity of the hardware and software stack of mobile devices, coupled with the increasing economic value of personal data stored on mobile devices, point to an impending adoption of rootkits in the mobile malware arena.","Several approaches currently exist for defending against malware. However, as mentioned above, traditional signature based scanning does not protect against subversive rootkits. Signature based scanning may be supplemented with more powerful techniques, such as those that deploy behavior-based detection algorithms. Existing methods for detecting rootkits include the use of code integrity monitors such as Patagonix, and kernel data integrity monitors such as Gibraltar. Patagonix offers protection against malicious code in the kernel by checking the integrity of static code pages (kernel inclusive). Gibraltar offers protection against malicious data in the kernel by scanning the kernel's data segment and ensuring that its data structures satisfy certain integrity properties, which are normally violated in rootkit-infected kernels.","This checking of the integrity of all kernel data structures and executable code is a thorough process, but requires significant processing overhead. With mobile devices, this leads to another problem: excessive power consumption. Security mechanisms today focus on well-provisioned computers such as heavy-duty servers or user desktops. Mobile devices present a fundamental departure from these classes of machine because they are critically resource-constrained.","While advances throughout the last decade in mobile processor, GPU, and wireless capabilities have been staggering, the hard fact is that mobile devices utilize batteries with a limited amount of stored power. Without the limit of resource constraints, security mechanisms will check everything they can, all the time. In a mobile device aggressively performing checks on large sets of security targets will inexorably lead to resource exhaustion and the inability to carry on useful tasks. However, no currently known approach addresses the problem of providing security mechanisms in a battery-constrained environment.","What is therefore needed is a modified rootkit detector or scanner that balances rootkit detection with energy consumption.","The subject disclosure provides a framework to quantify the tradeoff in malware detection on mobile devices between security and power consumption. Existing hypervisor-based rootkit detectors are customized for mobile platforms. These optimizations leverage memory management hardware and may additionally be used for other hypervisor-based memory inspection mechanisms. A system controller regulates how often and to what degree the detectors function to determine a window of vulnerability aggregate. The resulting window of vulnerability aggregate can be used to obtain an optimal compromise between energy and security. The compromise provides a reasonable degree of assurance in the security for a mobile device without completely depleting the battery, and is accomplished by characterizing the tradeoff along two axes. First, security can be traded off by modulating the coverage of the surface of attacks a malware detector will cover. Second, security can be traded off by modulating the frequency with which to invoke malware detection. In other words, one axis quantifies how often the detector performs checks in order to detect the presence of a rootkit, and the other axis is the number and type of data that is covered when performing these checks. The surface of attack includes running code, existing data, and among these are types of data that need not be checked frequently, or at all. Further event-based vs. polling-based modes are compared to trigger security checks.","In one exemplary embodiment, the subject disclosure is a method for adjusting rootkit detection. The rootkit detection is performed on a plurality of pages on a guest domain of a hypervisor within the memory of a mobile device, and includes determining an amount of energy consumed during a rootkit detection, adjusting a frequency of the rootkit detection, and adjusting an attack surface to be detected during the rootkit detection. The adjustments are made to balance security with an amount of energy consumed by comparing the amount of energy consumed with a maximum threshold and a minimum threshold. The frequency and the attack surface are increased when the amount of energy consumed is below the minimum threshold, and are decreased when the amount of energy consumed is below the minimum threshold.","In another exemplary embodiment, the subject disclosure is a computer program product including a plurality of logic units stored on a computer-readable medium, the plurality of logic units including instructions for determining an amount of energy consumed during a rootkit detection, adjusting a frequency of the rootkit detection, and adjusting an attack surface to be detected during the rootkit detection.","In yet another exemplary embodiment, the present subject disclosure is a mobile device, including a processor, a memory coupled to the processor, a hypervisor on the memory, a guest domain on the hypervisor, the guest domain including at least an operating system and user software, and a trusted domain on the hypervisor, the trusted domain including a rootkit detector and a controller configured to determine an amount of energy consumed during a rootkit detection, adjust a frequency of the rootkit detection, and adjust an attack surface to be detected during the rootkit detection. The adjustments are made to balance security with the amount of energy consumed. The mobile device further includes a transceiver enabling communication with a mobile network, wherein the rootkit detector is configured to transmit an infected page to a host-based rootkit detector on the network. A user interface or a hardware switch is provided to enable adjustment of the frequency and the attack surface.","Consequently, mobile system designers will be able to quantify the balance between the security guarantees the platform will offer and its impact on battery life. Manufacturers and service providers can identify best-compromise solution along the surface of attacks being defended against, and the frequency with which defenses are invoked.","The subject disclosure presents a novel technique for balancing the tradeoff between security monitoring and energy consumption on mobile devices. Security\/energy tradeoffs for host-based detectors focusing on rootkits are analyzed along two axes: a scanning frequency, and a surface of attack. Experimental results are applied to a hypervisor-based framework, and a sweet spot is identified to minimize both energy consumption and a window of vulnerability for critical operating system objects such as code pages and kernel data.","\u201cMobile device\u201d, as used herein and throughout this disclosure, refers to any electronic device capable of wirelessly sending and receiving data. A mobile device may have a processor, a memory, a transceiver, an input, and an output. Examples of such devices include cellular telephones, personal digital assistants (PDAs), portable computers, etc. The memory stores applications, software, or logic. Examples of processors are computer processors (processing units), microprocessors, digital signal processors, controllers and microcontrollers, etc. Examples of device memories that may comprise logic include RAM (random access memory), flash memories, ROMS (read-only memories), EPROMS (erasable programmable read-only memories), and EEPROMS (electrically erasable programmable read-only memories).","\u201cLogic\u201d, as used herein and throughout this disclosure, refers to any information having the form of instruction signals and\/or data that may be applied to direct the operation of a processor. Logic may be formed from signals stored in a device memory. Software is one example of such logic. Logic may also be comprised by digital and\/or analog hardware circuits, for example, hardware circuits comprising logical AND, OR, XOR, NAND, NOR, and other logical operations. Logic may be formed from combinations of software and hardware. On a network, logic may be programmed on a server, or a complex of servers. A particular logic unit is not limited to a single logical location on the network.","A mobile device also includes a network interface enabling the transceiver to connect to a network. One example of a network interface is a Subscriber Identity Module (SIM) card. A \u201cnetwork\u201d can include broadband wide-area networks, local-area networks, and personal area networks. Communication across a network is preferably packet-based; however, radio and frequency\/amplitude modulations networks can enable communication between communication devices using appropriate analog-digital-analog converters and other elements. Examples of radio networks include Wi-Fi and Bluetooth\u00ae networks, with communication being enabled by hardware elements called \u201ctransceivers.\u201d Wireless communication devices may have more than one transceiver, capable of communicating over different networks. For example, a cellular telephone can include a GPRS transceiver for communicating with a cellular base station, a Wi-Fi transceiver for communicating with a Wi-Fi network, and a Bluetooth\u00ae transceiver for communicating with a Bluetooth\u00ae device. A network typically includes a plurality of elements that host logic for performing tasks on the network.","The subject disclosure involves detection of rootkit malware and preventing infected pages from being executed. A rootkit is a type of malware that infects the executable code and data of an operating system (OS) kernel. By infecting the kernel itself, rootkits gain control over the layer historically referred to as the trusted computing base (TCB).","A kernel is a central component of most operating systems. A kernel includes at least executable code, and kernel data. Kernel code includes executables such as compiled code, system utilities, and services associated with the operating system. Kernel data includes non-executable control data such as system call tables, interrupt descriptor tables, function pointers, and so on. Further, kernel data includes non-control kernel data such as parameters controlling key cryptographic routines. Both code and data are stored on memory pages, or pages. A page, as used herein and throughout this disclosure, is a unit of granularity for both code and data.","According to the subject disclosure, the OS kernel is stored on a guest domain that resides on a hypervisor, while a rootkit detector, or detector, is stored on a trusted domain on the hypervisor. Generally, a hypervisor is a software layer that mediates the sharing of underlying hardware resources between several virtual operating systems, or domains. A \u201cvirtual machine\u201d is a software implementation or \u201cemulation\u201d of a machine, i.e. a computer, which executes a computer program like a physical machine would. By using a \u201chardware abstraction layer\u201d, the hypervisor will handle interrupts from the operating system to the processor, schedule processor time among the guest operating systems and allocate cores to virtual machines, manage devices and allocate memory. Further, a hypervisor can provide a guest operating system with access to a generic network interface by translating those access calls to a particular device driver, said interface being shared between the different guest operating systems. Such \u201cvirtual network interfaces\u201d enable the creation of a \u201cvirtual network\u201d wherein each virtual machine has its own private unique network address to communicate with each other and with the hypervisor or host operating system. By managing the virtual network, logic on the hypervisor can be deployed to secure each virtual machine using a different security model, such that virtual machines are restricted from accessing data stored on each other's memory units.","For the following description, it can be assumed that most correspondingly labeled structures across the figures (e.g.,  and , etc.) possess the same characteristics and are subject to the same structure and function. If there is a difference between correspondingly labeled elements that is not pointed out, and this difference results in a non-corresponding structure or function of an element for a particular embodiment, then that conflicting description given for that particular embodiment shall govern.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 1","b":["101","103","105","101","104","105"]},"A determination is made S as to the progress of the batch. When the batch reaches a certain quota, all pages in the batch are scanned by the rootkit scanner S. If the quota is not full, a determination is made S as to whether a timer has timed out. This enables scanning of pages even without having a full quota, thereby reducing the window of vulnerability of the system. A window of vulnerability is a period between scans, and its relationship with power consumption is further described below. If the timer has not timed out, the next page is loaded and the process resumes. If the timer has timed out, the batch is scanned S regardless of how large it is. Scanning the batch S includes different steps for different types of pages, as further described below.","Additionally, a power consumption of the mobile device is determined S. This includes measuring the rate of consumption during the scanning, as well as detecting a percentage of power remaining, for instance in a battery. If power consumption is not in excess of a defined threshold or ideal consumption, then the time period and\/or attack surface is adjusted S. This step includes increasing a time period between scans by adjusting the timeout of the timer, adjusting the quota by increasing the size of the batch, or instructing the scanner to scan only some data structures and to ignore other data pages. In case the mobile device is plugged into a constant power source, for instance while the battery is charging, the time period between scans, the size of the batch, and the attack surface are automatically adjusted to provide a maximum level of security. These and other adjustments are further described in more detail below.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIGS. 2A and 2B","FIG. 2A"],"b":["220","222","224","226","228","230","222","230","220"]},"Referring now to , the internal components of mobile device  include a transceiver  in communication with a Central Processing Unit (CPU)  that is in turn in communication with a memory  storing logic . All the components are powered by a battery . CPU  is any Intel\u00ae or ARM\u00ae based microprocessor known in the art and ideal for operating portable electronic devices such as mobile device . Memory  stores logic , as well as other software and databases, such as firmware, hypervisors, host operating systems, etc. Transceiver , via antenna , receives, processes, and transmits radio signals, such as GPRS, cellular radio, Bluetooth\u00ae, Wi-Fi, etc. In other exemplary embodiments, features such as Global Positioning System (GPS) units, accelerometers, infra-red (IR) transceivers, etc. are not shown but can be included in mobile device . Other types of processors can be used and may take different forms depending on whether the mobile device is a cellular telephone, laptop computer, etc.","Logic  includes at least a hypervisor, a guest domain on the hypervisor, and a trusted domain on the hypervisor. The hypervisor includes a controller that receives or intercepts pages being executed or modified by an OS on the guest domain, and the trusted domain includes a malware scanner, such as Patagonix and Gibraltar described above, to scan the pages for rootkit activity. The controller operates via the method described herein, and using the below-described systems.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3","FIGS. 2A-2B"],"b":["340","320","320","340","320","344","354","350","344","354","344","346","354","356","358","340","354","354","320"]},"In this exemplary embodiment, malware scanner  acts in a manner similar to known code integrity monitoring systems such as Patagonix. In other words, it provides mechanisms to ensure that all code  executing on the system belongs to a whitelist of pre-approved code stored in hash database . For instance, rootkits that modify system utilities or kernel code can be detected if the modified code is not in the whitelist, while certain data-modifying rootkits, e.g., those that modify kernel data pages that should not be modified during normal operation, are also detected. A non-executable (NX) page table  is stored on the hypervisor, and is used to detect and identify all executing code, including kernel code, system utilities, and other user processes.","Hypervisor  first sets an NX-bit on all code pages  in guest domain . When a page  is first scheduled for execution, the NX bit causes a processor fault. Hypervisor  receives the fault, pauses the guest domain and places information about the fault in the page table , which is accessed by the scanner  executing in the trusted domain. Scanner  hashes the page, and compares the executing code to a whitelist of known software, the whitelist including hashes of all approved code pages and stored in hash database . Hash database  includes at least an instruction number, a relative position, a process identity and the cryptographic hash for each known page. This information is intended to optimize the search that happens within hash database . The result of the search identifies the page, the originating code, and whether or not this page is populated with well known code that comes from reputed vendors, such as known OS executables and so on. Several different versions of the OS kernel could be used to populate this database as well as well known device drivers and commonly used applications.","Since pages are considered to be either modifiable or executable, once a page is executed and does not change, no further scanning needs to be performed for that page. Thus, beyond this initial bootstrapping phase, the kernel working set and long-lived processes represent no additional work for scanner . Further, scanner  uses optimizations to ensure fast verification of code pages. It remembers pages of code that have been approved and that have not changed. Thus, short-lived by recurring processes, such as \u201cgrep\u201d will result in hypervisor work as new page tables are created, but no scanner work, due to reuse of resident unmodified code pages. The scanner is aware of the entry point of each binary in its whitelist\u2014the first detection of a new binary should match an entry point in the whitelist. For approved binaries, an associated address page (defined by the base address of the current page table) is stored as well as the segment of the address space the binary occupies. In other words, pages within the same segment only match pages of the same binary. The subject disclosure improves the efficiency of this system by enabling the hypervisor to trigger the scanning process at an adjustable frequency, and allowing code pages to be batched for scanning. These modifications are further described below.","Meanwhile,  shows a system for checking data integrity on a mobile device, according to an exemplary embodiment of the subject disclosure. Similar to , a hypervisor  resides on a memory of mobile device . Hardware  includes the components of a mobile device such as the one described in . Hypervisor  mediates between hardware  and domains  and , and guarantees isolation  between the guest domain (the monitored system)  and the trusted domain (the monitoring tool) . In this embodiment, guest domain  includes an operating system having kernel data pages , among other pages that are not shown, such as executable code pages. Trusted domain  includes a malware scanner , such as the Patagonix or Gibraltar scanners described above, a database of invariants , and other minimal logic that is not shown. Hypervisor  and the trusted domain  together form the Trusted Computing Base (TCB) of the system. When trusted domain  detects a compromised page, it is capable of taking over the user interface on the mobile device , alerting the user, and providing containment options.","Hypervisor  includes logic to periodically fetch data pages  from guest kernel , and provide them to scanner  to be reconstructed. Scanner  starts with a set of kernel root symbols, whose memory locations are fixed. Using OS type definitions, scanner  identifies pointers in these root symbols, and recursively fetches more pages that contain data structures referenced by these pointers. Once data structures have been reconstructed, data structure invariants that specify kernel integrity constraints are verified by referring to invariant database . Some invariants are simple to verify: the values of function pointers must be addresses of known functions while the entries of the system call table should remain constant during the execution of the kernel. Other more complex invariants span sophisticated data structures, for instance, each process that is scheduled for execution must have an entry in the linked list of active processes on the system. In this exemplary embodiment, the scanner  undergoes a training phase including observing the execution of an infected kernel, executing several benign workloads, and inferring a large number of data structure invariants.","Besides uniquely modifying integrity scanners to function over a hypervisor, the subject disclosure has also modified traditional kernel integrity scanners by including a shadow page table  within hypervisor . This allows scanner  to focus the application of integrity constraints on just those data pages that are modified by the guest domain . The shadow page table (SPT)  grants fine-grained control over the permission bits of virtual-to-physical memory translation. In particular, SPT  is used to cause faults on a first attempt to modify a page, similar to the NX fault of the previous embodiment. Hypervisor  catches these faults and records them in a \u201clog-dirty\u201d bitmap within SPT . Scanner  then consults this bitmap, and only focuses on pages whose dirty bits are set, and are known to contain data structures of interest subject to integrity constraints. Novel integrity constraints and definitions of data structures of interest are further explained below. Moreover, by adjusting the frequency of scanning and by batch processing data pages , even more efficiency gains are observed, as further highlighted below.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 5","b":["561","563","567","569"]},"The shadow page table optimization has a substantial effect on the number of checks performed by the scanner, thereby leading to reduced power consumption. In experiments using the LMBENCH tool for performance analysis, it was observed that during a 144 second workload, 25 rounds of checks were performed by the optimized version, rather than 5. In other words, for a similar workload (and consequently, power consumption), an optimized scanner verifies the integrity of the kernel data structures 5 times more frequently than the prior art.","According to the subject disclosure, the frequency of checks is adjusted by either periodic polling (where the period is configurable), and\/or by event-based or interrupt-based notifications to trigger the malware scanner. These methods add efficiency by preventing the use of busy loops that burn too much CPU power, and overcome the deficiencies of sleep timers that ignore momentous events. Some existing code scanners, such as Patagonix, use event-based approaches to pause the guest domain each time a new page is scheduled for execution, and check the page for malware. However, the subject disclosure modifies such scanners to batch and perform these checks en masse. In contrast to frequently pausing the guest domain, batching enables detection of malicious code potentially after it has been executed, but ends up being far more efficient. Further, randomizing the period for polling and\/or the number of events in a batch provides a further line of defense against savvy attackers, as is further described herein.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 6","b":["644","640","641","642","645","645","654","656","658"]},"A code page scheduled for execution is intercepted S by controller  within hypervisor . Controller  determines by referring S to table  that this is a first execution of the code page, and modifies the corresponding NX-bit in table . Controller  then communicates S with scanner  in trusted domain  to either scan the page, or add it S to batch queue , depending upon the batch settings in place. This step may not be necessary if controller  is configured to automatically add the page to queue . When batch queue  is full, a notification is transmitted S to controller  that the queue is ready to be processed. Optionally, the notification is transmitted S directly to scanner . Even if queue  is not full, a timeout may occur, which indicates to the controller that a scan is required. In either case, controller  transmits an instruction S to scanner  to scan the contents of batch queue . Scanner  accesses S the NX-bit for each page in queue  from table , and hashes and compares S the executing code to a whitelist of known software stored in hash database . Scanner  then makes a determination S of whether or not the page is infected with a rootkit, this determination being known in the art. The determination is transmitted S back to the controller . In the case of infected code, controller  pauses the executing code S, and raises an alert. Alternatively, scanner  may raise the alert. In the case of non-infected code, database  is updated with the new information for the code page, and the page is allowed to execute. This type of batch scanning substantially conserves processor and battery resources as further shown below.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 7","b":["744","740","741","743","745","745","754","756","759"]},"The process begins with a training phase for scanner , such as Gibraltar. Scanner  is trained S against multiple executions of OS code and data, resulting in a large number of invariants that is populated S in invariant database . After this training process, during normal operation, a data page scheduled for modification is intercepted S by controller  within hypervisor . Controller  determines by referring S to table  that this is a first modification of the data page, and appends a corresponding \u201cdirty bit\u201d in SPTB . Controller  then communicates S with scanner  in trusted domain  to either scan the page, or add it to batch queue , depending upon the batch settings in place. This step may not be necessary if controller  is configured to automatically add the page S to queue . Scanner  only adds vital data pages to queue . These vital data pages include kernel static data, linked lists, and function pointers. Limiting batch queue  to only vital data pages enables large power savings as shown further below. When batch queue  is full, a notification is transmitted S to controller  that the queue is ready to be processed. Optionally, the notification is transmitted S directly to scanner . Even if queue  is not full, a timeout may occur, which indicates to the controller that a scan is required. In either case, controller  transmits an instruction S to scanner  to scan the contents of batch queue . Scanner  accesses S the SPTB  indicating which data page in queue  has been modified, and checks S the integrity of the data with invariant database  as described herein. Scanner  then makes a determination S of whether or not the kernel data page is infected (or highly likely infected) with a rootkit using conventional methods known in the art. The determination is transmitted S back to the controller . In the case of infected code, controller  pauses the system S, and raises an alert. Alternatively, scanner  may raise the alert. In the case of non-infected data, invariant database  is updated with the new information for the data page. This type of batch scanning of only vital data substantially conserves processor and battery resources as further shown below.","As described above, the subject disclosure modifies existing rootkit detectors by controlling a frequency of scanning, and a surface of attack that is to be scanned. Further a balanced profile for scanning is achieved by determining a window of vulnerability, and adjusting the frequency and attack surface to minimize the window of vulnerability while maximizing battery life. The window of vulnerability for a given object is defined as the time elapsed between two consecutive checks on that object. For example, checking the kernel system call table every two seconds gives a rootkit a maximum of two seconds to hijack the system call table, steal user information written to a file via the \u201cwrite( )\u201d command, and optionally restore the table to its pristine state to avoid detection. The window of vulnerability is therefore two seconds. For security systems that check multiple components, the window of vulnerability metrics of each component (each code page or each data structure in this case) may be statistically aggregated into a system-wide value. In other words, a window of vulnerability may be averaged over all components in a system.","Periodic polling systems have a clearly defined set of windows of vulnerability that they expose for each object they check. For a polling period T, the average window of vulnerability will be at least T, plus processing time involved within each round. However, event based systems such as the ones described herein provide a greater degree of assurance. If the hardware immediately alerts the monitor of a potential thread even before it is allowed to happen, then the system effectively provides zero vulnerability. For this reason, the subject disclosure provides interrupt batching for a processor, or signal handling for UNIX processes. In this case, the window of vulnerability widens again depending on the amount of merging performed, or the size of the batch.","A resourceful and knowledgeable author of malware may \u201clearn\u201d the timing mode and parameters of the system, and may craft attacks that break in, exploit, and clean up within the period of time during which security checks are inactive. The subject disclosure recognizes this risk, and mitigates any potential attacks by randomizing the timing parameters. For example, instead of configuring a data integrity scanner like Gibraltar to scan data structures every T seconds, a controller is programmed to trigger checks at an interval determined from a uniform distribution in the interval (T\u2212M, T+M], with M<=T. In other words, the period T is randomly adjusted to between T\u2212M to T+M, with T and M being any values protected from the guest kernel. In one exemplary embodiment, a proper uniform distribution may be generated by using a count of hardware interrupts. Other embodiments may use any source of entropy that is protected from the guest kernel. Because the checking intervals are uniformly distributed in the interval (T\u2212M, T+M], windows of vulnerability and checking overhead will converge to the same values as if a fixed period of T seconds had been chosen.","A similar randomization may be applied to event-based timing modes. The randomization is applied to the number of events that will trigger security checks. This approach may be further augmented with an explicit timeout (which itself could be randomized, if necessary). Moreover, a similar approach may be used to vary the attack surface: randomly triggering coverage of a wider attack surface is useful in catching potential attackers off-guard.","Experimental results shown below use a setup including a Viliv S5 mobile device, equipped with an Intel Atom Z520 1.33 GHz processor rated at 1.5 W, a 4.8\u2033 touchscreen, 32 GB hard drive, 1 GB of memory, Wi-Fi and BLUETOOTH transceivers in addition to a 3G modem, GPS, and a battery rated at 24,000 mWh. This mobile device used Xen paravirtualization, with a Xen 3.4.2 hypervisor, a Fedora 12 stack running a version of Lunix 2.6.27.42 on a trusted domain, and added support for both Patagonix and Gibraltar on this domain. The guest domain ran Linux 2.6.27.5 with Xen paravirtualization patches under a Cent)S 5.5 distribution. Power was measured with a Tektronix TDS-3014 oscilloscope with a Hall effect current probe. The device was powered directly from a 5V source to ensure that the measured current was directly powering the device. The current probe was attached to the charging cord, and a laptop connected to the oscilloscope recorded the current readings over the time of the experiment. It is to be understood that these specifications are for experimental purposes only, and that equivalent hardware and software would achieve similar results. It is to be further understood that the overhead of executing a hypervisor as opposed to a native kernel is negligible.","The experimental workload used to evaluate performance aimed to replicate standard mobile usage by loading a series of popular web pages and checking email. For completeness, the workload included using both 3G and Wi-Fi connectivity, as well as using an IMBENCH CPU workload designed to measure OS performance. The workload is therefore highly customizable, and independent of specific platforms, needing merely the ability to launch browser and email client instances from a script. Other workload configurations are possible and are likely to confirm the experimental results provided herein.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIGS. 8A-8B","FIG. 8A"]},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIGS. 9A-9C","FIG. 9A","FIGS. 9B and 9C"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIGS. 10A-10C"},"The subject disclosure provides similar results for an experimental setup to test the impact on the size of the attack surface, using an identical experimental setup as described above. With rootkits, attacks that modify kernel code, static data, and data structures that hold control data (e.g. the system call table) are more abundant and easy to program than attacks that modify arbitrary kernel data structures. The subject disclosure modifies existing scanners by limiting the attack surface size to include at least function pointers, as opposed to other data structures. The energy dissipated by a security tool can be reduced by decreasing the fraction of the attack surface monitored.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIGS. 11A-11B","FIG. 11A"]},"Referring now to , an integrity scanner such as Gibraltar was configured to monitor five classes of kernel data, containing a) static kernel data, i.e. data that is initialized during kernel boot-up and persists throughout execution of the kernel, b) data structures representing the process list, c) all linked lists, d) all kernel data structures that store function pointers, and e) all data structures. Each class is inclusive, i.e. includes the previous class as a subset. Again, the scanner is set up to continuously monitor data integrity (without adjustments to scanning frequency), and one complete traversal of the kernel's data segment is referred to as a detection round. It is observed that although the total energy dissipated by Gibraltar is significantly higher than Patagonix (likely because Gibraltar continuously contends for CPU cycles), the energy dissipated by Gibraltar varies considerably with the attack surface being monitored. Essentially, the larger the attack surfaces the scanner has to cover, the more adversarial the workload is in terms of memory locality. Decreased memory locality impacts processor cache performance efficiency, and therefore energy efficiency.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIGS. 12A-12B","FIG. 12A","FIG. 12B"]},"The subject disclosure uses these experimental results to construct profiles that end-users may select or adjust to best protect their mobile devices. Energy costs associated with checking code integrity are much lower than the cost of checking data integrity. A reasonable tradeoff may be achieved between energy efficiency and a window of vulnerability for data integrity scanners, with a sweet spot for realistic browsing workloads using a polling interval of 30 seconds. These metrics are used to construct a \u201cbalanced profile\u201d for moderate energy consumption with a high degree of assurance against most rootkit attacks. This profile combines batched checks of kernel code pages, with polling-based integrity checks of static kernel data, linked lists, and data structures containing function pointers, using the T=30 s period identified above. Such a balanced profile has been experimentally shown to have windows of vulnerability for kernel code varying between 0.7 and 2.5 seconds, and windows of vulnerability for kernel data averaging 40 seconds. Moreover, a maximum energy overhead reaches about 14%, with web browsing hovering between 6% and 9%.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 13","b":["1320","1320","1323","1323","1325","1320","1329"]},"In other embodiments, malware scan settings are implemented as hardware controls on the exterior of the mobile device. For example, a hardware slider is attached to the exterior of the mobile device for the user to adjust the security level between more protection and more battery life. Such a hardware control allows the OS of the guest domain to remain on the screen of the mobile device while the button controls the trusted domain to adjust the security level. Further, in case the mobile device is plugged into a constant power source, for instance while the battery is charging, the time period between scans, the size of the batch, and the attack surface are automatically adjusted to provide a maximum level of security.","In conclusion, protecting against code-driven attacks is relatively cheap, while protecting against all data-driven attacks is prohibitively expensive. A sweet spot in the security\/energy tradeoff minimizes both energy consumption and the window of vulnerability. Further, the inventive modifications to existing detectors may be complemented with other methods to sidestep the security-energy tradeoff for detecting certain kinds of malware. For instance, the subject disclosure may be combined with behavior-based techniques such as observing activities on the untrusted domain, including SMS message forwarding, spam email, etc., and generating power profiles for detection of any similar suspicious activity. An adaptive security\/energy profile may be generated to complement the above-discussed balanced profile. The subject disclosure may further be combined with pre-emptive approaches to detect and discard large fractions of malware before they ever reach the mobile device. Such techniques can complement host-based detectors that can run using conservative security\/energy profiles when \u201ctrusted\u201d applications are downloaded and executed. Malware scan settings may be adjusted through a web portal, an application within the trusted domain on the mobile device, or a hardware control on the mobile device.","The foregoing disclosure of the exemplary embodiments of the subject disclosure has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the subject disclosure to the precise forms disclosed. Many variations and modifications of the embodiments described herein will be apparent to one of ordinary skill in the art in light of the above disclosure. The scope of the subject disclosure is to be defined only by the claims appended hereto, and by their equivalents.","Further, in describing representative embodiments of the subject disclosure, the specification may have presented the method and\/or process of the subject disclosure as a particular sequence of steps. However, to the extent that the method or process does not rely on the particular order of steps set forth herein, the method or process should not be limited to the particular sequence of steps described. As one of ordinary skill in the art would appreciate, other sequences of steps may be possible. Therefore, the particular order of the steps set forth in the specification should not be construed as limitations on the claims. In addition, the claims directed to the method and\/or process of the subject disclosure should not be limited to the performance of their steps in the order written, and one skilled in the art can readily appreciate that the sequences may be varied and still remain within the spirit and scope of the subject disclosure."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 2A-2B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 8A-8B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 9A-9C"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 10A-10C"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 11A-11B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 12A-12B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
