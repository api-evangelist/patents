---
title: Method and system for mapping between structured subjects and observers
abstract: A method of binding elements of a structured document to an observer structure includes obtaining the logical structure of a document. Nodes representing information contained in the document are mapped to an observer structure which can include both a user interface or a programming object. The user interface may be a graphical user interface including a display form of a grid-like structure to contain the structured document information. The data binding which maps the structured document information to the observer form may be directionally controllable such that any change made to the information at the observer may be reflected in the source structured document.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09098476&OS=09098476&RS=09098476
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09098476
owner_city: Redmond
owner_country: US
publication_date: 20040629
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Overview","Descriptions and Examples of the Invention"],"p":["This invention relates in general to the field of data translation. More particularly, this invention relates to the mapping of a structured document to an observer form.","The Extensible Markup Language (XML) was originally envisioned as a language for defining new document formats for the World Wide Web. XML can be considered to be a meta-language; a language for defining markup languages. XML is a text-based format that provide mechanisms for describing document structures using markup tags such as words surrounded by \u2018<\u2019 and \u2018>\u2019 symbols.","As XML's usage has grown, it has become generally accepted that XML is not only useful for describing new document formats for the Web but is also suitable for describing structured data. Examples of structured data include information which is typically contained in spreadsheets, program configuration files, and network protocols. XML is preferable to previous data formats because XML can easily represent both tabular data, such as relational data from a database or spreadsheet, and semi-structured data, such as a web page or business document.","With this proliferation of XML data, there is a significant need for tools for visualizing XML documents as well as a common framework upon which these tools can be built. To date, a great many tools for visualizing XML mainly focus on displaying the raw XML text in a well formatted manner and with certain syntax coloring to distinguish various lexical constructs. However, there is no system which describes a system for visualizing XML documents based on their logical structure as opposed to physical structure and which provides a mechanism for visualizing these logical structures.","Thus, there is a need for a method or system to allow a view of the logical structure of a structured document to an observer form such as a graphical user interface or a programming language object. The present invention addresses the aforementioned needs and solves them with additional advantages as expressed herein.","The subject invention relates to a system for binding the nodes of a structured document, based on their logical structure as opposed to physical structure, to observer structures and forms. The observer structures and forms may include traditional graphical user interface components such as grids and trees or programming objects. Aspects of the invention also include providing direction control over the data binding such that a change in the observer form can result in a change to the structured document. One way or two way binding is possible.","As an aspect of the invention, the structured document may be an XML document and the schema used may be an XML schema. The logical structure discerned by an aspect of the invention may be viewed using a XPath document view.","Programmers are increasingly dealing with a wide range of data models that go beyond traditional relational\/tabular or object-oriented forms. At the same time, the so-called rich client is gaining in popularity. Aspects of the invention enable the manipulation of any addressable data source, such as a collection of addressable elements, by rich graphical user interfaces. One approach to the task of allowing a view of the logical structure of a structured document to an observer form is to uncover the logical form, visualize the logical form and then transform the logical view into the desired observer form. One aspect of the invention discloses a method of discerning the logical structure within a structured document and making it available for a viewer. The logical structure, once discerned, may be transformed into an observer form that is beneficial to the user. The observer form may be either a graphical user interface, such as a grid, or it a may be a programmer object useful for some further purpose. One technique to transform the logical structure of a structured document into a suitable observer form is to use an extension of XPath to query and edit the structured data if the structured data is XML. The principles of these approaches is provided along with the exemplary embodiments presented below.","One example use of the invention is to map a logically organized structured document tree into a grid-like structure such as a table.  depicts a logical tree structure  describing a book having a title node  and an author node . Each of these first level nodes has child nodes of title data  and author data  respectively. One aspect of the invention is the ability to bind nodes of the logical tree structure with a grid-like construction  such that a correspondence between nodes and grid cells may occur. In the example of , the data in each node , ,  and  are mapped into the grid cells , ,  and  respectively. In one embodiment of the invention the binding may be a two way binding such that a user viewing the grid-like structure  may edit the structure  and have the edit reflected back into the source tree . In another embodiment, not shown in , the binding can result in a graphical user interface display of a logical or hierarchical tree structure.","In one embodiment of the invention, a structured document, such as an XML document, may be used as the raw source of a tree structure. The tree structure is obtained via the use of a an XML schema and an XPath document is used to assist in the extraction of a logical tree structure since it has XML schema information attached and therefore is schema aware. By utilizing the XML schema of the XPathDocument, a set of XML to user interface mapping rules can be established that enable XML to be displayed in a variety of controls, most notably, the data grid. This approach creates a mapping for the user interface control that is user-friendly in terms of having to write less code at the expense of not being able to define the row structure with restricted XPath expressions. That is, for example, there is no need to control how a row is mapped to the data grid because these rules are implied. This overall approach enables users to load XML into an XPath document in-memory XML store and then create an XPath document view class for this XPath document in order to bind to a user interface.","When binding XML to graphical user interface components it is preferable to ensure that, despite the flexible nature of XML, the data binding process is consistent. For example, consider an XML document that represents information about books that is bound to a grid. If the book element has required attributes, such as title and isbn number, with optional attributes, such as publication-date, it is important that when the XML document is bound to a grid that the optional fields are taken into consideration. In this example having optional attributes, book elements that have no publication-date, the result can be a column in the grid-like format that represents the attribute with a blank or null value.","Given that W3C XML Schema is the industry standard mechanism used to describe the structure of an XML document, the XML data binding process utilizes an XML document's schema to determine how to map it to graphical user interface components such as grids and trees. The data binding process involves mapping the logical structures within an XML document described by an XML schema to an intermediate representation of named lists of nodes which can then be mapped to hierarchical graphical user interface components such as trees and grid-like graphical user interface components such as tables.","In an embodiment of a mapping of an XML schema to a user interface, a data-bound list, a data-bound node and a data-bound node property are used. A data-bound list is a collection of XML nodes that have been data bound to some control and is represented by an XPath document view object. If bound to a data grid, this corresponds to a table in the data grid. A data-bound node is an XML node that has been data bound to some control and is represented by an XPath node view object. If bound to a data grid, this corresponds to a row in the data grid. A data-bound node property is a property of an XML node that has been data bound to some control and is represented by a property descriptor of the XPath node view. A data-bound node property can either be a single item or a list of items. If bound to a data grid, this corresponds to either a column value of a row, if a single item, or a nested table related to a row in the data grid, if a list of items.","The mapping of elements and attributes to data bound lists and items include the building of data-bound lists and nodes. Building data-bound lists is an occurrence of one or more elements that are complex types. The list contains a number of data bound nodes that represent each instance of the complex type that appears in the actual document. For instance, the following complex type declaration maps to a list that contains a single data bound \u201cbooks\u201d node which in turn has a node property which is a list of several data bound \u201cbook\u201d nodes:",{"@attributes":{"id":"p-0021","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003<xs:element name=\u201cbooks\u201d>"]},{"entry":[{},"\u2003\u2003\u2002<xs:complexType>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<xs:sequence>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2002<xs:element name=\u201cbook\u201d type=\u201cbk:bookType\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003maxOccurs=\u201cunbounded\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/xs:sequence>"]},{"entry":[{},"\u2003\u2003\u2002<\/xs:complexType>"]},{"entry":[{},"<\/xs:element>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Specifically, the above schema fragment generates an XPath document view that returns \u201cbooks\u201d when the method GetListName( ) is invoked on it and contains a single XPath node view which has a single property descriptor that represents an XPath document view that returns \u201cbook\u201d when GetListName( ) is invoked on it. A particle containing repeating elements is treated as a data bound list. A particle may be a schema component that corresponds to an xs:element, xs:group, xs:all, xs:sequence, xs:choice or xs:any. More broadly, a particle may apply to any unit of composition as identified by the particular schema mechanism that is used to describe the structure of the subject. For databound lists obtained from repeating instances of xs:group the value returned by GetListName( ) for the generated XPath document view is the name of the group declaration. For other particles the name returned by GetListName( ) is an autogenerated name. Any particle (except for xs:element) that is nested within another particle is treated as a databound list. The name returned by GetListName( ) for the XPath document view that this corresponds to is autogenerated.","Building data-bound nodes is an occurrence of a complex typed element. The attributes of the element become data bound node properties; each containing a single item representing the attribute. The child elements of the complex typed element also become properties of the data bound node. Child elements that have a simple type and do not repeat are properties that contain a single item while child elements that repeat or that have a complex type become properties that contain a list of items. For elements that are complex types with content such as text, the text content is treated as a data bound node property whose name is the name of the element with \u201c_Text\u201d appended to it. For instance, when bound to a data grid, the element <pubDate edition=\u201c2nd\u201d>2001<\/pubDate> maps to the following row:",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Edition","Pubdate_Text"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2nd","2001"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"For elements with mixed content, such as elements which are interspersed with text, the XML content of the element is mapped to a data bound node property whose name is the name of the element with \u201c_Text\u201d appended to it while the child elements of the node are ignored for data binding purposes. For instance, when bound to a data grid, the element <p>I am <b>mixed<\/b> content<\/p> maps to the following row:",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"P_Text"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"I am <b> mixed <\/b> content"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Elements that have simple types can be data bound properties of a data bound node. For an XML document consisting of a single element which has a simple type, that element becomes a data bound node with the value of the element becoming a data bound node property whose name is the name of the element with \u201c_Text\u201d appended to it. Attributes are usually data bound properties of a data bound node unless they are bound to directly. If an element has an attribute and a child element of simple type with the same name then the attribute may be prepended with an \u201c@\u201d sign when its name is exposed as a data bound node property. In situations when attributes in an XML document are bound to directly, such as when an XPath document view is created with a restricted XPath expression, such as \u201c\/books\/book\/@isbn\u201d, then that attribute becomes a data bound node with the value of the attribute becoming a data bound node property whose name is the name of the attribute with \u201c_Text\u201d appended to it.","In one embodiment, comments, processing instructions and namespace nodes may be ignored during the data binding process. Example of ignored items are attributes from the XML namespace, such as, for example, http:\/\/www.w3.org\/XML\/1998\/namespace can be ignored and not be data bound. Also, attributes from the W3C XML Schema instance namespace, such as, for example, http:\/\/www.w3.org\/2001\/XMLSchema-instance may be ignored and are not data bound. Also the effects of an type attributes may be are ignored. For example, if the schema describes a book type and in the instance a periodical subtype derived by extension is substituted using type attributes and elements that were not declared in the base type, then these type attributes can be ignored and are not data bound. In another instance, nodes that match wildcards may be ignored and not data bound.","Once data in a structured document has been logically outlined, it may be expressed in a user interface according to aspects of the invention. One of the aspects of the invention is the expression of the structured document information into an observer form. Many graphical user interface (GUL) applications are based on the so-called model-view-controller or the closely related observer pattern. An objective of these design patterns is to keep a \u201cmodel\u201d or \u201csubject\u201d and one or more \u201cviews\u201d or \u201cobservers\u201d on that model\/subject in sync. In the model-view-controller type pattern there is a category of component called the \u201ccontroller\u201d that coordinates the changes between model and view, in the observer pattern, a view and it's controller are combined into a single observer.","Data-binding is a prime example of this pattern where you bind a data source subject to a graphic user interface (GUI) observer, for instance a dataset bound to a graphical data grid. Changes in the dataset are propagated to the grid and vice-versa. For instance, in the following example, the \u201cText\u201d property of the TextBox control \u201ct\u201d is bound to the property Name of a Person object \u201cp\u201d:\n\n","In this example, the Binder objects b serves as the controller paired with the TextBoxview:t: [Joe]\u2190b\u2192p: Person{Name=\u201cJoe\u201d}. When a change occurs in the TextBox observer, the controller b raises a Parse event, followed by a Format event, the subject is changed, followed by another Format event. The Person subject typically registers a handler for the Parse events. Conversely, the controller raises a Format event when the subject changes, typically the TextBox view registers an event-handler for this.","It is also possible to bind a control to a more structured subject such as a dataset or a hierarchical object graph. In that case, the binding to the subject is done via a simple navigation path that consists of \u201c.\u201d separated property names which selects a particular sub-subject to be bound to the view. For example, assume that a Person has an Address property that itself contains a country property, we can bind to country using the path \u201cAddress.Country\u201d:","Binding b=new Binding(\u201cText\u201d,p,\u201cAddress.Country\u201d); t.DataBindings.Add(b);","The binder pushes changes in the view to the control. However, in order to allow the binder to observe changes in the subject, the subject should expose an event called xxx changed for each property xxx for which changes should be propagated from subject to view. The binder will subscribe to the changed event, when this is fired by the subject, the binder will subsequently raise a Format event.","It one aspect of the invention, a user is able to bind parts of an XML document to grid-like structures such as tables in a relational database or tables in a spreadsheet and hierarchical structures such as tree controls in a graphical user interface or objects in a programming language. Binding refers to a process of mapping certain characteristics of the XML nodes in a document such as their names and values to the core constructs of the target domain. As indicated in the example of , an example of binding is mapping an XML subject such as the following:\n\n",{"@attributes":{"id":"p-0036","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"title","author"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"The Bourne Identity","Robert Ludlum"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"This outcome is as shown in . Alternately, the output may be translated to a programming language object observer \u201cBook\u201d of type:",{"@attributes":{"id":"p-0038","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Book {"]},{"entry":[{},"\u2003string title{ get; set; }"]},{"entry":[{},"\u2003string author{ get; set; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, a mechanism is provided for two way binding. Just like in the normal model-view-controller pattern, two way binding means that when the XML document is mapped to the other structure there is a \u2018live\u2019 link between the XML document and the alternate structure so that updates to the XML document are reflected in the structure and vice versa. For example, when the author column of the Book table above is changed this would also change the underlying XML file. Similarly if the value of the title was changed in an instance of the Book class described above then the underlying XML document would be updated. This works both ways so that changes to the XML document subject would also be reflected in the table or object observers.","To initiate the binding process, the nodes to bind to are identified using a hierarchical addressing mechanism such as the XPath language. Examples of such addresses could be \/book-bind to the <book> element, \/\/title-bind to all the <title> elements. This is an example of binding to a collection of addressable elements. There is also the ability to bind nodes in nested manner; that is, it is possible to bind to subparts of the subject. For example one could create a binding such as \/book \/title. In this case although the <book> element is being bound to only its <title> sub-element is being exposed in the target structure. This would change the above examples to a table observer Book such as:",{"@attributes":{"id":"p-0041","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"title"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"The Bourne Identity"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"or to a programming language object observer Book of type:",{"@attributes":{"id":"p-0043","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Book {"]},{"entry":[{},"\u2003string title{ get; set; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment of the invention, when an XML subject is bound to an observer, it can be indicated whether this binding should be a one-time bind, one way or two way. If it is a one time bind then the XML is bound to the structure and after that neither changes to the values in the structure or changes to the underlying XML are reflected in the other.","As in the instance of a one way binding, a binder coordinates changes in subject and observer. Changes in the observer are pushed to the subject as before, and the binder uses the path to update the appropriate locations in the subject. For this instance, we assume that subjects can support updates at a certain location path. It is notable how the subject communicates changes to binder since it might not be possible or desirable for the subject to expose XYZChanged events for each location XYZ in the subject. Instead, the subject exposes a single Changed event and communicates the location path of the change to the binder as a parameter to the event handler. In other word, we decouple the Changed events from their particular location.","In one embodiment, if changes are synchronized, there may be conflicts if the changes do not conform to the schema of the observer. For example, adding a new element to the XML subject that does not have a counterpart in the table or programming language object could produce a conflict. These conflicts can be either ignored or result on an error being thrown depending on what configuration option was chosen when the binding was initiated. Similarly, changes in the observer may not conform to the schema of the structure of the XML subject. Again, these changes can induce an error or be ignored.",{"@attributes":{"id":"p-0047","num":"0054"},"figref":"FIG. 2","b":["210","230","230","220","210","220","240","240","250","220","240"]},{"@attributes":{"id":"p-0048","num":"0055"},"figref":"FIG. 3","b":["300","300","305","310","315","320","325","330","330","305","330"]},"Exemplary Embodiments of Data-Binding Interfaces","Data binding may be achieved through a set of interfaces. In one embodiment, the interfaces are designated as the ICustomTypeDescriptor interface and the IBindingList interface.","The ICustomTypeDescriptor allows an object to provide type information about itself in a generic fashion. Data-binding takes advantage of this by getting information from the ICustomTypeDescriptors interface. Therefore, any object that implements this interface can be data-bound to for read-only scenarios. The ICustomTypeDescriptor interface exposes a set of PropertyDescriptors which give information about the object upon which it is to be implemented. These PropertyDescriptors are name\/value pairs describing some aspect of the object and its value. For example, for a given object, a PropertyDescriptor may be generated for each Property the object contains. An example follows:",{"@attributes":{"id":"p-0051","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Person : ICustomTypeDescriptor"]},{"entry":[{},"{"]},{"entry":[{},"property string Name = \u201cMark\u201d;"]},{"entry":[{},"property string Address = \u201c1 A Street\u201d;"]},{"entry":[{},"property int Age = 26;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For the above class, three property descriptors would be generated; a PropertyDescriptor with Name \u201cName\u201d which returns \u201cMark\u201d for GetValue( ), a PropertyDescriptor with Name \u201cAddress\u201d which returns \u201c1 A Street\u201d for GetValue( ), and a PropertyDescriptor with Name \u201cAge\u201d that returns 26 for the GetValue( ) call.","In order to support data binding for XML, an implementation desirably would expose an object that has properties that represent an item of data to bind against. This may be achieved with a XPathNodeView class which implements the ICustomTypeDescriptor interface. This class enables properties of the item to be read and updated. Below is an example of an XML document that can be bound to a control.\n\n","Below is an example using XPathNodeView to interact with the above XML document.",{"@attributes":{"id":"p-0055","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"XPathDocument doc = new XPathDocument(\u201cc:\\\\books.xml\u201d);"},{"entry":"\/\/infer schema(s) for document"},{"entry":"Inference testInference = new Inference( );"},{"entry":"doc.SchemaSet ="},{"entry":"testInfer.InferSchema(doc.CreateNavigator( ).ReadSubtree( ));"},{"entry":"\/\/validate document to make it typed"},{"entry":"doc.Validate(null);"},{"entry":"\/\/bind to document"},{"entry":"XPathDocumentView xmlItemCollection ="},{"entry":"new XPathDocumentView (doc);"},{"entry":"XPathNodeView xmlDRView = xmlItemCollection.AddNew( );"},{"entry":"\/\/ Each assignment operation results in a new node being created in the"},{"entry":"tree."},{"entry":"xmlDRView[\u201ctitle\u201d] = \u201cADO.NET and System.Xml V2\u201d;"},{"entry":"xmlDRView[\u201cgenre\u201d] = \u201cTechnical\u201d;"},{"entry":"xmlDRView[\u201cpublicationdate\u201d] = \u201c8\/4\/2003\u201d;"},{"entry":"xmlDRView[\u201cISBN\u201d] = \u201c123456-0000\u201d;"},{"entry":"dataGrid1.DataSource = xmlItemCollection;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, data binding to a list is desirable. Many user interface controls may expect a list of data for binding purposes. An example would be a list of data to be placed in a data grid. To bind to a list of data, some user interface controls may expect to be given an object implementing an IList interface. Some user interface forms expects a data source to either support IList, including arrays or IListSource. This allows the control to iterate through the members of the list and extract out ICustomTypeDescritpors to be used during data binding.","In one embodiment, to implement list data binding, the XPathDocumentView class can implement the IList interface. If it is desirable to bind to a list of nodes resulting from a restricted XPath expression then one of the constructors for the XPathDocumentView that accepts a restricted XPath expression as input can be used. The following example binds a list of book elements to a DataGrid.",{"@attributes":{"id":"p-0058","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/setup XmlFactory to create a validating XML reader"},{"entry":"\u2003XmlFactory f = new XmlFactory( );"},{"entry":"\u2003f.ReaderSettings.Schemas.Add(\u201cbooks.xsd\u201d);"},{"entry":"\u2003f.ReaderSettings.XsdValidate = true;"},{"entry":"\u2003\/\/load from validating reader so document is typed"},{"entry":"\u2003XPathDocument doc ="},{"entry":"\u2003new XPathDocument(f.CreateReader(\u201cbooks.xml\u201d));"},{"entry":"\u2003XPathDocumentView xmlItemCollection = XPathDocumentView(doc,"},{"entry":"\u2003\u201c\/books\/book\u201d);"},{"entry":"\u2003dataGrid1.DataSource = xmlItemCollection;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one aspect of the invention, it is desirable to establish a binding such that changes or edits made to a source structured document or an observer item are reflected in one or the other. For example, an edit made to the underlying XPathDocument may desirably be reflected in the user interface. In one scenario, if a developer creates an XPathEditor on a set of nodes that are currently being displayed and makes updates to the XPathDocument, the XPathDocument can notify the user interface of those changes. As an aspect of the invention, any XPathEditor that causes changes to the XPathDocument may have its changes updated in the user interface. This reflection of changed or edits may be called change notification.","Change notification may be provided through the IBindingList interface. IBindingList can support a number of data binding related features and may also support a data bound user interface querying for support of those features. In order to support change notification, the IBindingList implementation returns \u201ctrue\u201d from SupportsChangeNotification property and raises the ListChanged event when a change occurs. An example is provided below.",{"@attributes":{"id":"p-0061","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/setup XmlFactory to create a validating XML reader"},{"entry":"\u2003XmlFactory f = new XmlFactory( );"},{"entry":"\u2003f.ReaderSettings.Schemas.Add(\u201cbooks.xsd\u201d);"},{"entry":"\u2003f.ReaderSettings.XsdValidate = true;"},{"entry":"\u2003\/\/load from validating reader so document is typed"},{"entry":"\u2003XPathDocument doc ="},{"entry":"\u2003new XPathDocument(f.CreateReader(\u201cbooks.xml\u201d));"},{"entry":"\u2003XPathDocumentView xmlItemCollection ="},{"entry":"\u2003new XPathDocumentView (doc);"},{"entry":"\u2003dataGrid1.DataSource = xmlItemCollection;"},{"entry":"\u2003XPathEditor editor = doc.CreateEditor( );"},{"entry":"\u2003XPathNodeIterator iter = editor.Select(\u201c\/book[@genre=\u2018novel\u2019]\u201d);"},{"entry":"\u2003foreach (XPathNavigator navitem in iter)"},{"entry":"\u2003{"},{"entry":"\u2003iter.MoveToAttribute(\u201cISBN\u201d, \u201c\u201d);"},{"entry":"\u2003\/\/At this point the dataGrid1 displays the new value of ISBN for"},{"entry":"all the book with genre=\u2018novel\u2019"},{"entry":"\u2003editor.SetValue(\u201c0000000000-000\u201d);"},{"entry":"\u2003editor.MoveToParent( );"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, support for editing user interface components is provided to the underlying XPathDocument from interacting with the XPathDocumentView. Such editing may include editing the values of items in the list, For example, changing CustomerName from \u201cFred\u201d to \u201cBill\u201d may be accomplished. Row level transactions on the items in the list are also possible as is adding and removing items from the list.","In a compatible embodiment, the XPathDocument supports update scenarios through an underlying XPathEditor. This means that the implementation of ICustomTypeDescriptor, for example an XPathNodeView, may return PropertyDescriptors that support updating. Setting the value of a PropertyDescriptor can map to one of several calls to an underlying XPathEditor positioned over the XPatlDocument. Thus there are methods compatible with the functionality of XML tools that allow a user to edit data in a data binding environment compatible with the present invention.","Examples of XML Data-Binding Interfaces Using XPathDocument","The following examples demonstrate exemplary results of applying aspects of the present invention with an input sample schema and an input sample structured document written in XML. In this example, the output is a grid-like representation of the implied structure of the data. The example follows.","Sample Schema:",{"@attributes":{"id":"p-0066","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003<xs:schema xmlns:xs=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\u201d"]},{"entry":[{},"\u2003\u2002targetNamespace=\u201curn:xmlns:25hoursaday-com:my-bookshelf\u201d"]},{"entry":[{},"\u2002xmlns:bk=\u201curn:xmlns:25hoursaday-com:my-bookshelf\u201d"]},{"entry":[{},"\u2002elementFormDefault=\u201cqualified\u201d>"]},{"entry":[{},"\u2003\u2003<xs:element name=\u201cbooks\u201d>"]},{"entry":[{},"\u2003\u2009<xs:complexType>"]},{"entry":[{},"\u2003\u2002<xs:sequence>"]},{"entry":[{},"\u2003\u2002 <xs:element name=\u201cbook\u201d type=\u201cbk:bookType\u201d"]},{"entry":[{},"maxOccurs=\u201cunbounded\u201d \/>"]},{"entry":[{},"\u2003\u2002<\/xs:sequence>"]},{"entry":[{},"\u2003\u2009<\/xs:complexType>"]},{"entry":[{},"\u2003\u2003<\/xs:element>"]},{"entry":[{},"\u2003\u2003<xs:complexType name=\u201cbookType\u201d>"]},{"entry":[{},"\u2003\u2009<xs:sequence>"]},{"entry":[{},"\u2003\u2002<xs:element name=\u201ctitle\u201d type=\u201cxs:string\u201d \/>"]},{"entry":[{},"\u2003\u2002<xs:element name=\u201cauthor\u201d type=\u201cxs:string\u201d \/>"]},{"entry":[{},"\u2003\u2002<xs:element name=\u201cpublication-date\u201d type=\u201cxs:date\u201d \/>"]},{"entry":[{},"\u2003\u2009<\/xs:sequence>"]},{"entry":[{},"\u2003\u2009<xs:attribute name=\u201cpublisher\u201d type=\u201cxs:string\u201d \/>"]},{"entry":[{},"\u2003\u2009<xs:attribute name=\u201con-loan\u201d type=\u201cxs:string\u201d \/>"]},{"entry":[{},"\u2003\u2003<\/xs:complexType>"]},{"entry":[{},"\u2003<\/xs:schema>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Sample Structured Document:",{"@attributes":{"id":"p-0068","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<books xmlns=\u201curn:xmlns:25hoursaday-com:my-bookshelf\u201d>"]},{"entry":[{},"\u2003<book publisher=\u201cAddison Wesley\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<title>Essential C++<\/title>"]},{"entry":[{},"\u2003\u2003\u2003<author>Stanley Lippman<\/author>"]},{"entry":[{},"\u2003\u2003\u2003<publication-date>2000-10-31<\/publication-date>"]},{"entry":[{},"\u2003\u2003\u2003<\/book>"]},{"entry":[{},"\u2003\u2003\u2003<book publisher=\u201cWROX\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<title>XSLT Programmer's Reference<\/title>"]},{"entry":[{},"\u2003\u2003\u2003<author>Michael Kay<\/author>"]},{"entry":[{},"\u2003\u2003\u2003<publication-date>2001-04-30<\/publication-date>"]},{"entry":[{},"\u2003\u2003\u2003<\/book>"]},{"entry":[{},"\u2003\u2003\u2003<book publisher=\u201cApress\u201d on-loan=\u201cKevin\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<title>Programmer's Introduction to C#<\/title>"]},{"entry":[{},"\u2003\u2003\u2003<author>Eric Gunnerson<\/author>"]},{"entry":[{},"\u2003\u2003\u2003<publication-date>2001-06-30<\/publication-date>"]},{"entry":[{},"\u2003\u2003\u2003<\/book>"]},{"entry":[{},"<\/books>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Exemplary Results if \/books\/book bound to a grid control:",{"@attributes":{"id":"p-0070","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},{},"publication-","on-"]},{"entry":["publisher","title","author","date","loan"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Addison","Essential C++","Stanley","2000-10-31","(null)"]},{"entry":["Wesley",{},"Lippman"]},{"entry":["WROX","XSLT Programmer's","Michael Kay","2001-04-30","(null)"]},{"entry":[{},"Reference"]},{"entry":["Apress","Programmer's","Eric","2001-06-30","Kevin"]},{"entry":[{},"Introduction to C#","Gunnerson"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0071","num":"0083"},"figref":"FIG. 4"},"Although not required, embodiments of the invention can also be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, appliances, lights, environmental control elements, minicomputers, mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network\/bus or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.",{"@attributes":{"id":"p-0073","num":"0085"},"figref":"FIG. 4","b":["400","400","400","400"]},"With reference to , an exemplary system for implementing an embodiment of the invention includes a general purpose computing device in the fonn of a computer system . Components of computer system  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer system  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, Random Access Memory (RAM), Read Only Memory (ROM), Electrically Erasable Programmable Read Only Memory (EEPROM), flash memory or other memory technology, Compact Disk Read Only Memory (CDROM), compact disc-rewritable (CDRW), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer system , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer system  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM, CDRW, DVD, or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer system . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer system  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory (not shown). In addition to monitor , computer systems may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer system  may operate in a networked or distributed environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer system , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer system  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer system  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer system , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web-enabled interface for applications and computing devices, making computing activities increasingly Web browser or network-oriented.","For example, MICROSOFT\u00ae's .NET\u2122 platform, available from Microsoft Corporation, includes servers, building-block services, such as Web-based data storage, and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device, one or more portions of an embodiment of the invention may also be implemented via an operating system, application programming interface (API) or a \u201cmiddle man\u201d object between any of a coprocessor, a display device and a requesting object, such that operation may be performed by, supported in or accessed via all of .NET\u2122's languages and services, and in other distributed computing frameworks as well.","As mentioned above, while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to implement a method to map structured elements to an observable form. Thus, the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages, names and examples are chosen herein as representative of various choices, these languages, names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same, similar or equivalent systems and methods achieved by embodiments of the invention.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the signal processing services of an embodiment of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While aspects of the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Therefore, the claimed invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating embodiments of the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. Like reference numerals of the exemplary constructions represent similar parts throughout all of the drawings wherein;",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
