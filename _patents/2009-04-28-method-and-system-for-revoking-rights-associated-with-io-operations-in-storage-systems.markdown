---
title: Method and system for revoking rights associated with I/O operations in storage systems
abstract: A machine implemented process and system is provided. The process determines if any right granted to an entity for performing an I/O operation associated with a data container stored at a first storage volume is to be revoked. The right itself may be cached at the first storage volume and resident at a second storage volume. A recall message is sent to the node that manages the second storage volume. Any pending I/O operation is completed, after the message is sent and before the right is revoked. Thereafter, the right is revoked and the cached copies of the right are invalidated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08180961&OS=08180961&RS=08180961
owner: Netapp, Inc.
number: 08180961
owner_city: Sunnyvale
owner_country: US
publication_date: 20090428
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["1. TECHNICAL FIELD","2. RELATED ART","SUMMARY","DETAILED DESCRIPTION","Definitions"],"p":["The present disclosure relates to storage systems.","A storage system typically comprises one or more storage devices where information may be stored and from where information may be retrieved, as desired. The storage system may be implemented in accordance with a variety of storage architectures including, but not limited to, a network-attached storage (NAS) environment, a storage area network (SAN) and a disk assembly directly attached to a client or host computer.","The storage system typically includes a storage operating system that may implement a high-level module, such as a file system, to logically organize information stored at storage volumes as a hierarchical structure of data containers, such as files and logical units. For example, stored files may be implemented as set of data structures, i.e., disk blocks, configured to store information, such as the actual data for the file. These data blocks are organized within a volume block number (vbn) space that is maintained by the file system. The file system typically organizes the data blocks within the vbn space as a \u201clogical volume\u201d; each logical volume may be, although is not necessarily, associated with its own file system.","The storage system may be configured to operate according to a client server model of information delivery to thereby allow many clients to access data containers stored on the system. In this model, the client may comprise an application, such as a database application, executing in a computer that communicates with the storage system. Each client may send input\/output (\u201cI\/O\u201d) requests to read and write data containers.","A plurality of storage systems may be interconnected to service numerous client requests. A striped volume set (\u201cSVS\u201d) may be used for servicing numerous clients. In a SVS, a data container, for example, a file, may be striped across a plurality of volumes. Stripes of data content of the data container are allocated to each volume of the SVS in a manner that balances data across the volumes. Each stripe has a defined size\/width as specified by a set of striping rules associated with the SVS.","In the SVS environment, managing rights associated with I\/O operations is a challenge. One example of such a right is an opportunistic lock (\u201cOpLock\u201d) as used in the Common Internet File System (\u201cCIFS\u201d) protocol. An OpLock lock is typically placed by one or more client application (may also be referred to as \u201ca client\u201d) on a data container residing at a storage volume. The OpLock provides certain rights to the client to perform read and write operations with respect to the data container.","Because multiple clients execute different operations with respect to the same data containers, granting and revoking exclusionary rights (for example, OpLocks) can be challenging in the SVS environment. Continuous efforts are being made to better manage rights for conducting I\/O operations and managing OpLocks.","In one embodiment, a machine implemented process for managing rights granted to clients for performing I\/O operations with respect to a stripped volume set (\u201cSVS\u201d) is provided. The process determines if any right granted to a client (for example, an OpLock granted to a client application executed by a computing device) with respect to an I\/O operation associated with a data container stored at a first storage volume is to be revoked. The OpLock may be resident at a second storage volume and cached at the first storage volume. The OpLock may have to be revoked because the data container has to be migrated from the first storage volume to another storage volume, the storage system may need to perform a failover operation or for any other reason.","After the process determines that the OpLock should be revoked, the process ascertains whether the second storage volume that \u201cowns\u201d the OpLock is local to a first node or remote to the first node. The first node in this context manages the first storage volume. If the second storage volume is local to the first node then the first node simply processes the message locally. If the second storage volume is remote, then the first node sends a message to a second node that manages the second storage volume to revoke the OpLock.","Thereafter, the recall message is sent to the node that interfaces with the client that was granted the OpLock. The node then sends the recall message to the client and any pending I\/O operation is completed by the client. Thereafter, the OpLock is revoked and all cached copies of the right are invalidated by the node that manages the second storage volume.","In another embodiment, a machine implemented method for managing a right granted to a client associated with an input\/output (I\/O) operation on a data container stored in a SVS is provided. The method includes determining if the right granted to the client is to be revoked. The right is cached at a first storage volume and resident at a second storage volume.","If the second storage volume is managed by a second node operationally coupled to a first node that manages the first storage volume, then a recall message is sent from the first node to the second node for revoking the right granted to the client.","The method further includes, sending the recall message to the client for revoking the right; completing any pending I\/O operation after the recall message is sent to the client; revoking the right granted to the client; and invalidating a cached copy of the right at the first storage volume.","In yet another embodiment a machine readable storage medium storing executable instructions, which when executed by a machine, causes the machine to perform a process for managing a right granted to a client associated with an input\/output (I\/O) operation on a data container stored in a SVS is provided. The process includes determining if the right granted to the client is to be revoked. The right is cached at a first storage volume and resident at a second storage volume.","If the second storage volume is managed by a second node operationally coupled to a first node that manages the first storage volume, then a recall message is sent from the first node to the second node for revoking the right granted to the client.","The process further includes, sending the recall message to the client for revoking the right; completing any pending I\/O operation after the recall message is sent to the client; revoking the right granted to the client; and invalidating a cached copy of the right at the first storage volume.","In yet another embodiment, a computer program product is provided. The product includes a computer usable storage medium having computer readable instructions embodied therein for managing a right granted to a client associated with an input\/output (I\/O) operation on a data container stored in a SVS.","The instructions are for determining if the right granted to the client is to be revoked. The right is cached at a first storage volume and resident at a second storage volume.","If the second storage volume is managed by a second node operationally coupled to a first node that manages the first storage volume, then the product includes instructions for sending a recall message from the first node to the second node for revoking the right granted to the client.","The product further includes instructions for sending the recall message to the client for revoking the right; completing any pending I\/O operation after the recall message is sent to the client; revoking the right granted to the client; and invalidating a cached copy of the right at the first storage volume.","In yet another embodiment, a machine implemented method for revoking a right granted to a client associated with an input\/output (I\/O) operation on a data container stored in a striped volume set (SVS) is provided. The method includes receiving a recall message at a second node from a first node for revoking the right cached at a first storage volume and resident at a second storage volume. The first node manages the first storage volume storing striped data and the second node manages the second storage volume.","The method further includes forwarding the recall message to the client that completes any pending I\/O operation after receiving the recall message; and revoking the right granted to the client and invalidating the cached copy of the right at the first storage volume.","This brief summary has been provided so that the nature of this disclosure may be understood quickly. A more complete understanding of the disclosure can be obtained by reference to the following detailed description of the various embodiments thereof in connection with the attached drawings.","The following definitions are provided as they are typically (but not exclusively) used in the computing\/storage environment, implementing the various adaptive embodiments described herein.","\u201cData Container\u201d means a file, a logical unit or any other information. The term file is used interchangeably with data container, throughout this specification.","\u201cI\/O operation\u201d means an input\/output operation for reading a data container or writing a data container in response to an I\/O request.","\u201cOpportunistic Lock\u201d (may also be referred to as \u201cOpLock\u201d) means a lock that is placed by one or more client application (may also be referred to as \u201ca client\u201d) on a data container residing at a storage volume. The OpLock information may be embedded in a data container attribute (for example, the meta-data) for the data container. OpLock, based on client requests, coordinates data caching and coherency between clients and storage systems. Coherent data in this context means data that is the same across a network i.e. data stored by the storage system and locally by the clients is synchronized. OpLocks are defined by the Common Internet File System (\u201cCIFS\u201d) protocol. There are different types of OpLocks, for example, Level 1, Level 2 and other types of OpLocks and the rights associated with an OpLock depends on the OpLock type.","\u201cLevel 1 OpLock\u201d on a data container allows a client to \u201cread-ahead\u201d and cache both read-ahead and write data from the data container locally. The client may request a Level 1 OpLock after opening a data container, for example, a file. If no other client has the data container open, the storage system may grant the OpLock. If another client has opened the file, then the storage system refuses the OpLock request and the client does not use local caching of read and write data. When the storage system opens a data container that already has a Level 1 OpLock on it, the system examines the sharing state of the OpLock before it breaks the Level 1 OpLock.","\u201cLevel 2 OpLock\u201d: A Level 2 OpLock notifies a client that there are multiple concurrent clients of a data container and that none of the clients have modified the data container. This lock allows the client to perform read operations and obtain data container attributes using cached or read-ahead local information, but the client sends all other requests (such as for write operations) to the storage system. The Level 2 OpLock is typically used when one expects other applications to write to a data container at random or read the data container at random or sequentially.","\u201cRevoking OpLock\u201d (or \u201cRecalling OpLock\u201d) means a process of degrading an OpLock that a client application has on a data container so that another client application can open the file, with or without an OpLock. When another client requests an \u201cOpen\u201d operation to access a data container, the storage system delays the open operation and notifies the client holding the OpLock. The client holding the lock then takes appropriate actions based on the type of lock, for example abandoning read buffers, closing the file and others. The storage system opens the file for the client requesting the open operation after the client holding the OpLock notifies the storage system that it is done. However, when a Level 2 OpLock is revoked, the storage system reports to the client but does not wait for any acknowledgment because there is no cached data to be flushed. In acknowledging a break of any exclusive lock (for example, Level 1), the holder of a broken lock typically can request another OpLock through subsequent \u201cOpen\u201d request.","\u201cRights\u201d means a privilege that is granted to an entity, for example, a client application executed at a computing device, with respect to any I\/O operations, for example, read and write operations. One example of such rights includes OpLocks that are described above.","\u201cSVS\u201d means a striped volume set where a data container, for example, a file, may be striped across a plurality of volumes. Stripes of data content of the data container are allocated to each volume of the SVS in a manner that balances data across the volumes. Each stripe has a defined size\/width as specified by a set of striping rules associated with the SVS.","As used in this disclosure, the terms \u201ccomponent\u201d \u201cmodule\u201d, \u201csystem,\u201d and the like are intended to refer to a computer-related entity, either software-executing general purpose processor, hardware, firmware and a combination thereof. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers. Also, these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and\/or remote processes such as in accordance with a signal having one or more data packets (e.g., data from one component interacting with another component in a local system, distributed system, and\/or across a network such as the Internet with other systems via the signal). Computer executable components can be stored, for example, on computer readable media including, but not limited to, an ASIC (application specific integrated circuit), CD (compact disc), DVD (digital video disk), ROM (read only memory), floppy disk, hard disk, EEPROM (electrically erasable programmable read only memory), memory stick or any other storage device, in accordance with the claimed subject matter.","Process Flow:","In one embodiment, a machine implemented process for managing rights granted to clients for performing I\/O operations with respect to a SVS is provided. The process determines if any right granted to a client (for example, an OpLock granted to a client application executed by a computing device) with respect to an I\/O operation associated with a data container stored at a first storage volume is to be revoked. The OpLock may have to be revoked because the data container has to be migrated from the first storage volume to another storage volume, the storage system may need to perform a failover operation or for any other reason.","The OpLock may be resident at a second storage volume and cached at the first storage volume. In this context, the term resident means that the OpLock is managed and \u201cowned\u201d at the second storage volume but also cached at the first storage volume.","After the process determines that the OpLock should be revoked, the process ascertains whether the second storage volume that \u201cowns\u201d the OpLock is local to a first node or remote to the first node. The first node in this context manages the first storage volume. If the second storage volume is local to the first node then the first node simply processes the message locally. If the second storage volume is remote, then the first node sends a recall message to a second node that manages the second storage volume to revoke the OpLock.","Thereafter, the recall message is sent to the node that interfaces with the client that was granted the OpLock. The node then sends the recall message to the client and any pending I\/O operation is completed by the client. Thereafter, all cached copies of the OpLock are invalidated by the node that manages the second storage volume.","The process flow according to one embodiment is now described with respect to . In one embodiment, the process is described with respect OpLocks as used in a SVS environment; however, the process is applicable to any other right similar to OpLocks.","The process starts in block  when a client (for example, , See ) requests a right, for example, an OpLock from a storage system node (for example, N-Module  of , ). Node  then updates a data container attribute and grants the OpLock to the client. Thereafter, client  sends an I\/O request with respect a data container, for example, a file, to node .","In block , the node (for example, D-Module  of node , ) selects a stripped volume to service the I\/O request. The node may use a data container handle (for example, , ) to select the stripped volume. Thereafter, in block , if the selected volume (also referred to as the first volume) does not own the OpLock, i.e., the OpLock is not resident at the first volume, then the node (for example, D-Module , ) acquires a copy of the OpLock from a second volume and operates with a cached copy of the OpLock.","The client  continues to process the I\/O request and in block , the process determines if there is a need to recall the OpLock. One example of a situation where the OpLock may have to be recalled is if, the data container at the first storage volume is migrated to another storage volume. In that case, any pending OpLocks is recalled before the migration can actually take place. Another example, is when the storage system performs a failover operation, a maintenance operation or for any other reason.","If there is no need to recall the OpLock, the process simply loops back and continues to monitor in block  whether there is a need for recalling an OpLock.","If the OpLock needs to be recalled, then an OpLock recall message is sent to the node that manages the second storage volume. In one embodiment, the same node (for example, the same D-Module ) may manage the first and second storage volumes. In such a case, the message is sent via a local process executed by the node.","In another embodiment, a different node (for example, a second node) manages the second storage volume. The second node is remote to the first node that manages the first storage volume. In such a case, a network connection, as described below, is used to send the recall message from the first node to the second node.","Thereafter, the OpLock recall message is sent to a node that interfaces with the client. In one embodiment, the node may be an N-Module  (, described below). The N-Module  then sends the OpLock recall message to the client.","In block , the client completes any pending operations that may be affected by the recall. For example, a client application  (See ) may send some information that may have to be written at the first storage volume where the lock is cached and\/or at the second storage volume where the lock is resident. Thereafter, in block , the OpLock for the client is revoked.","In block , the cached OpLock at the first storage volume is invalidated by the node that manages the second storage volume. In one embodiment, a D-Module that manages the storage volume may maintain a table (not shown) with identifier information of all granted OpLocks and where they may be cached. The D-Module may simply set a flag or an indicator to invalidate the cached copy at the first storage volume. It is noteworthy that all cached copies of the OpLock at all storage volumes are invalidated, before the recall is completed.","In block , the OpLock is cleared from the second storage volume that \u201cowns\u201d the OpLock (i.e. where the OpLock was resident).","In one embodiment, executable blocks , , , , , ,  and  are executed by a processor (for example, A, ) executing programmable instructions, (for example, operating system (, )) out of memory (for example, , ).","Recall Message:  shows an example of an OpLock recall message  (also referred to as Message ), used according to one embodiment of the present disclosure. Message  is sent by a node controlling the first storage volume that requests an OpLock recall, as described above with respect to block  of .","Message  includes a request  to a node to not grant any more OpLocks with respect to the data containers stored at the first storage volume. Message  may also include the OpLock identifiers  that identify one or more OpLocks that need to be revoked.","Message  further includes an identifier  that identifies the originating volume (for example, the first storage volume) where the OpLock is cached. Identifier  assists the node managing the second storage volume in identifying the first storage volume where the OpLock is cached.","To facilitate an understanding of the various embodiments of the present disclosure, the general architecture and operation of a networked, clustered storage system will now be described.","Clustered System:",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 1C","b":["102","100","102","100","102","104","106","104","102","114","112","106","108","110"]},"Nodes  may be interconnected by a cluster switching fabric  which, in the illustrative embodiment, may be embodied as a Gigabit Ethernet switch. It should be noted that while there is shown an equal number of N and D-modules in the illustrative cluster , there may be differing numbers of N and\/or D-modules in accordance with various embodiments of the present invention. For example, there may be a plurality of N-modules and\/or D-modules interconnected in a cluster configuration  that does not reflect a one-to-one correspondence between the N and D-modules. As such, the description of a node  comprising one N-module and one D-module should be taken as illustrative only.","Clients  may be general purpose computers having a plurality of components. These components may include a central processing unit (CPU), main memory, I\/O devices, and storage devices (for example, flash memory, hard drives and others). The main memory may be coupled to the CPU via a system bus or a local memory bus. The main memory may be used to provide the CPU access to data and\/or program information that is stored in main memory at execution time. Typically, the main memory is composed of random access memory (RAM) circuits. A computer system with the CPU and main memory is often referred to as a host system.","Clients  may be configured to interact with the node  in accordance with a client\/server model of information delivery. That is, each client  may request the services of the node , and the node  may return the results of the services requested by the client , by exchanging packets over the network . The client  may issue packets using application  including file-based access protocols, such as the CIFS protocol or Network File System (\u201cNFS\u201d) protocol, over the Transmission Control Protocol\/Internet Protocol (\u201cTCP\/IP\u201d) when accessing information in the form of certain data containers, such as files and directories. Alternatively, the client  may issue packets using application  including block-based access protocols, such as the Small Computer Systems Interface (\u201cSCSI\u201d) protocol encapsulated over TCP (\u201ciSCSI\u201d) and SCSI encapsulated over Fibre Channel (\u201cFCP\u201d), when accessing information in the form of other data containers, such as blocks.","Storage System Node:",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 2","b":["102","202","202","204","210","212","216","213","208","213","214"]},"The cluster access adapter  comprises a plurality of ports adapted to couple node  to other nodes of cluster . In the illustrative embodiment, Ethernet may be used as the clustering protocol and interconnect media, although it will be apparent to those skilled in the art that other types of protocols and interconnects may be utilized within the cluster architecture described herein. In alternate embodiments where the N-modules and D-modules are implemented on separate storage systems or computers, the cluster access adapter  is utilized by the N\/D-module for communicating with other N\/D-modules in the cluster .","Each node  is illustratively embodied as a dual processor storage system executing a storage operating system  that preferably implements a high-level module, such as a file system, to logically organize the information as a hierarchical structure of named directories, files and special types of files called virtual disks (hereinafter generally \u201cblocks\u201d) on disks . However, it will be apparent to those of ordinary skill in the art that the node  may alternatively comprise a single or more than two processor systems. Illustratively, one processor A executes the functions of the N-module  on the node, while the other processor B executes the functions of the D-module .","The memory  illustratively comprises storage locations that are addressable by the processors and adapters for storing programmable instructions and data structures. The processor and adapters may, in turn, comprise processing elements and\/or logic circuitry configured to execute the programmable instructions and manipulate the data structures. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable media, may be used for storing and executing program instructions pertaining to the invention described herein.","The storage operating system , portions of which is typically resident in memory and executed by the processing elements, functionally organizes the node  by, alia, invoking storage operations in support of the storage service implemented by the node. An example of operating system  is the DATA ONTAP\u00ae (Registered trademark of NetApp, Inc.) operating system available from NetApp, Inc. that implements a Write Anywhere File Layout (WAFL\u00ae (Registered trademark of NetApp, Inc.)) file system. However, it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such, where the term \u201cONTAP\u201d is employed, it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.","The network adapter  comprises a plurality of ports adapted to couple the node  to one or more clients  over point-to-point links, wide area networks, virtual private networks implemented over a public network (Internet) or a shared local area network. The network adapter  thus may comprise the mechanical, electrical and signaling circuitry needed to connect the node to the network. Illustratively, the computer network  may be embodied as an Ethernet network or a Fibre Channel (FC) network. Each client  may communicate with the node over network  by exchanging discrete frames or packets of data according to pre-defined protocols, such as TCP\/IP.","The storage adapter  cooperates with the storage operating system  executing on the node  to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape, optical, PVC, magnetic tape, bubble memory, electronic random access memory, micro-electro mechanical and any other similar media adapted to store information, including data and parity information. However, as illustratively described herein, the information is preferably stored on the disks  of array . The storage adapter  comprises a plurality of ports having input\/output (I\/O) interface circuitry that couples to the disks over an I\/O interconnect arrangement, such as a conventional high-performance, FC link topology.","Storage of information on each array  is preferably implemented as one or more storage \u201cvolumes\u201d that comprise a collection of physical storage disks  cooperating to define an overall logical arrangement of volume block number (vbn) space on the volume(s). Each logical volume is generally, although not necessarily, associated with its own file system. The disks within a logical volume\/file system are typically organized as one or more groups, wherein each group may be operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID). Most RAID implementations, such as a RAID-4 level implementation, enhance the reliability\/integrity of data storage through the redundant writing of data \u201cstripes\u201d across a given number of physical disks in the RAID group, and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID-4 level implementation, although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.","Operating System:",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 3A","b":["206","102","206","104","106","302","114"]},"Operating system  may also include a protocol layer  and an associated network access layer , to allow node  to communicate over a network with other systems, such as clients . Protocol layer  may implement one or more of various higher-level network protocols, such as NFS, CIFS, Hypertext Transfer Protocol (HTTP), TCP\/IP and others, as described below.","Network access layer  may include one or more drivers, which implement one or more lower-level protocols to communicate over the network, such as Ethernet. Interactions between clients  and mass storage devices  (e.g. disks, etc.) are illustrated schematically as a path, which illustrates the flow of data through operating system .","The operating system  may also include a storage access layer  and an associated storage driver layer  to allow D-module  to communicate with a storage device. The storage access layer  may implement a higher-level disk storage protocol, such as RAID (redundant array of inexpensive disks), while the storage driver layer  may implement a lower-level storage device access protocol, such as FC or SCSI. In one embodiment, the storage access layer  may implement the RAID protocol, such as RAID-4 or RAID-DPT\u2122 (RAID double parity for data protection provided by NetApp Inc. the assignee of the present disclosure).",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 3B","FIG. 3A","FIG. 3A"],"b":["206","325","312","308","304","314","316","315"]},"A file system protocol layer provides multi-protocol file access and, to that end, includes support for the Direct Access File System (DAFS) protocol , the NFS protocol , the CIFS protocol  and the HTTP protocol .","A virtual interface (\u201cVI\u201d) layer  implements the VI architecture to provide direct access transport (DAT) capabilities, such as RDMA, as required by the DAFS protocol . An iSCSI driver layer  provides block protocol access over the TCP\/IP network protocol layers, while a FC driver layer  receives and transmits block access requests and responses to and from the node. The FC and iSCSI drivers provide FC-specific and iSCSI-specific access control to the blocks and, thus, manage exports of luns to either iSCSI or FCP or, alternatively, to both iSCSI and FCP when accessing the blocks on the node .","In addition, the storage operating system includes a series of processor executable layers organized to form a storage server  that provides data paths for accessing information stored on the disks  of the node . To that end, the storage server  includes a file system module  in cooperating relation with a volume stripped module (VSM) , a RAID system module  and a disk driver system module .","The VSM  illustratively implements a SVS. The VSM cooperates with the file system  to enable storage server  to service a volume of the SVS. In one embodiment, VSM  may also implement the SVS related process steps described above with respect to .","The RAID system  manages the storage and retrieval of information to and from the volumes\/disks in accordance with I\/O operations, while the disk driver system  implements a disk access protocol such as, e.g., the SCSI protocol. The file system  implements a virtualization system of the storage operating system  through the interaction with one or more virtualization modules illustratively embodied as, e.g., a virtual disk (vdisk) module (not shown) and a SCSI target module . The SCSI target module  is generally disposed between the FC and iSCSI drivers ,  and the file system  to provide a translation layer of the virtualization system between the block (lun) space and the file system space, where luns are represented as blocks.","The file system  is illustratively a message-based system that provides logical volume management capabilities for use in access to the information stored on the storage devices, such as disks. That is, in addition to providing file system semantics, the file system  provides functions normally associated with a volume manager. These functions include (i) aggregation of the disks, (ii) aggregation of storage bandwidth of the disks, and (iii) reliability guarantees, such as mirroring and\/or parity (RAID).","The file system  illustratively may implement the write-anywhere file system having an on-disk format representation that is block-based using, e.g., 4 kilobyte (KB) blocks and using index nodes (\u201cmodes\u201d) to identify data containers and data container attributes (such as creation time, access permissions, size and block location and OpLock). The file system uses data containers to store meta-data describing the layout of its file system; these meta-data data containers include, among others, an mode data container. A data container handle, i.e., an identifier that includes an mode number (inum), may be used to retrieve an mode from disk.","Broadly stated, all modes of the write-anywhere file system are organized into the mode data container. A file system (fs) info block specifies the layout of information in the file system and includes an mode of a data container that includes all other modes of the file system. Each logical volume (file system) has an fsinfo block that is preferably stored at a fixed location within, e.g., a RAID group. The mode of the mode data container may directly reference (point to) data blocks of the mode data container or may reference indirect blocks of the mode data container that, in turn, reference data blocks of the mode data container. Within each data block of the mode data container are embedded inodes, each of which may reference indirect blocks that, in turn, reference data blocks of a data container.","Operationally, a request from the client  is forwarded as a packet over the computer network  and onto the node  where it is received at the network adapter . A network driver processes the packet and, if appropriate, passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write-anywhere file system . Here, the file system generates operations to load (retrieve) the requested data from disk  if it is not resident \u201cin core\u201d, i.e., in memory .","If the information is not in memory, the file system  indexes into the mode data container using the mode number (inum) to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system ; the logical vbn is mapped to a disk identifier and disk block number (disk, dbn) and sent to an appropriate driver (e.g., SCSI) of the disk driver system . The disk driver accesses the dbn from the specified disk  and loads the requested data block(s) in memory for processing by the node. Upon completion of the request, the node (and operating system) returns a reply to the client .","It should be noted that the software \u201cpath\u201d through the operating system layers described above needed to perform data storage access for a client request received at node  may alternatively be implemented in hardware. That is, in an alternate embodiment of the disclosure, the storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array (FPGA) or an ASIC. This type of hardware implementation increases the performance of the file service provided by node  in response to a file system request issued by client .","As used herein, the term \u201cstorage operating system\u201d generally refers to the computer-executable code operable on a computer to perform a storage function that manages data access and may, in the case of a node , implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel, an application program operating over a general-purpose operating system, such as UNIX\u00ae or Windows XP\u00ae, or as a general-purpose operating system with configurable functionality, which is configured for storage applications as described herein.","In addition, it will be understood to those skilled in the art that the invention described herein may apply to any type of special-purpose (e.g., file server, filer or storage serving appliance) or general-purpose computer, including a standalone computer or portion thereof, embodied as or including a storage system. Moreover, the teachings of this disclosure can be adapted to a variety of storage system architectures including, but not limited to, a network-attached storage environment, a storage area network and a disk assembly directly-attached to a client or host computer. The term \u201cstorage system\u201d should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system, the teachings of the present invention may be utilized with any suitable file system, including a write in place file system.","CF Protocol","In the illustrative embodiment, the storage server  is embodied as D-Module  to service one or more volumes of array . In addition, the multi-protocol engine  is embodied as N-Module  to (i) perform protocol termination with respect to a client issuing incoming data access request packets over the network , as well as (ii) redirect those data access requests to any storage server  of the cluster . Moreover, the N-Module  and D-Module  cooperate to provide a highly-scalable, distributed storage system architecture of the cluster . To that end, each module includes a cluster fabric (CF) interface module adapted to implement intra-cluster communication among the modules, including D-Module-to-D-Module communication for data container striping operations described herein.","The protocol layers, e.g., the NFS\/CIFS layers and the iSCSI\/FC layers, of the N-Module  function as protocol servers that translate file-based and block based data access requests from clients into CF protocol messages used for communication with the D-Module . That is, the N-Module servers convert the incoming data access requests into file system primitive operations (commands) that are embedded within CF messages by the CF interface module  for transmission to the D-Modules  of the cluster . Notably, the CF interface modules  cooperate to provide a single file system image across all D-Modules  in the cluster . Thus, any network port of an N-Module that receives a client request can access any data container within the single file system image located on any D-Module  of the cluster.","Further to the illustrative embodiment, the N-Module  and D-Module  are implemented as separately-scheduled processes of storage operating system; however, in an alternate embodiment, the modules may be implemented as pieces of code within a single operating system process. Communication between an N-Module and D-Module is thus illustratively effected through the use of message passing between the modules although, in the case of remote communication between an N-Module and D-Module of different nodes, such message passing occurs over the cluster switching fabric . A known message-passing mechanism provided by the storage operating system to transfer information between modules (processes) is the Inter Process Communication (IPC) mechanism. The protocol used with the IPC mechanism is illustratively a generic file and\/or block-based \u201cagnostic\u201d CF protocol that comprises a collection of methods\/functions constituting a CF application programming interface (API). Examples of such an agnostic protocol are the SpinFS and SpinNP protocols available from Network Appliance, Inc. The SpinFS protocol is described in U.S. Patent Application Publication No. US 2002\/0116593.","The CF interface module  implements the CF protocol for communicating file system commands among the modules of cluster . Communication is illustratively effected by the D-Module exposing the CF API to which an N-Module (or another D-Module) issues calls. To that end, the CF interface module  is organized as a CF encoder and CF decoder. The CF encoder of, e.g., CF interface on N-Module  encapsulates a CF message as (i) a local procedure call (LPC) when communicating a file system command to a D-Module  residing on the same node  or (ii) a remote procedure call (RPC) when communicating the command to a D-Module residing on a remote node of the cluster . In either case, the CF decoder of CF interface on D-Module  de-encapsulates the CF message and processes the file system command.",{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 4","b":["400","400","150","100","400","402","404","406","408","410","100","410","400","104","106","408","406"]},"Data Container Attribute Handle:  shows of a format of data container attribute handle  (may also be referred to as \u201cHandle \u201d) that may be used to access a data container e.g. a file. Handle  may include various fields that describe the location and data container characteristics. For example, Handle  may include a Member Volume Identifier field , an inode number field , a unique identifier field , a striped flag field , OpLock information  and other fields .","The Member Volume ID field  identifies the SVS volume within which the data container resides. The inode number field  contains an inode number of an inode (within an inode file) pertaining to the data container. The unique identifier field  may used to identify the DCA block .","The OpLock information  may include an OpLock identifier that identifies an OpLock that may be granted to a client . It is noteworthy that OpLock information  may be derived from other sources, for example, information related to client  that identifies a lock owner. Field  may be a reserved field to store any other information.","File System Organization","In the illustrative embodiment, a data container is represented in the write-anywhere file system as an inode data structure adapted for storage on the disks .  is a schematic block diagram of an inode , which preferably includes a meta-data section  and a data section . OpLock information  may be stored within meta-data section . The use of this information is described below in detail.","The information stored in the meta-data section  of each inode  describes the data container (e.g., a file) and, as such, includes the type (e.g., regular, directory, vdisk)  of data container, its size , time stamps (e.g., access and\/or modification time)  and ownership, i.e., user identifier (UID ) and group ID (GID ), of the data container. The meta-data section  also includes a generation number , and a meta-data invalidation flag field , the latter indicating meta-data whether meta-data in the inode is usable. The contents of the data section  of each inode may be interpreted differently depending upon the type of data container (inode) defined within the type field . For example, the data section  of a directory inode may include meta-data controlled by the file system, whereas the data section of a regular inode contains file system data. In this latter case, the data section  includes a representation of the data associated with the data container.","When an on-disk inode (or block) is loaded from disk  into memory , its corresponding in-core structure embeds the on-disk structure. For example, the dotted line surrounding the inode  indicates the in-core representation of the on-disk inode structure. The in-core structure is a block of memory that stores the on-disk structure plus additional information needed to manage data in the memory (but not on disk). The additional information may include, e.g., a \u201cdirty\u201d bit . After data in the inode (or block) is updated\/modified as instructed by, e.g., a write operation, the modified data is marked \u201cdirty\u201d using the dirty bit  so that the inode (block) can be subsequently \u201cflushed\u201d (stored) to disk.",{"@attributes":{"id":"p-0114","num":"0113"},"figref":"FIG. 6B","b":["624","624","626","638","636","626","500","503"]},"Each set of striping rules  illustratively includes a stripe width field , a stripe algorithm ID field , an ordered list of volumes field  and, in alternate embodiments, additional fields . The striping rules  contain information for identifying the organization of a SVS. For example, the stripe algorithm ID field  identifies a striping algorithm used with the SVS. In the illustrative embodiment, multiple striping algorithms could be used with a SVS; accordingly, stripe algorithm ID is needed to identify which particular algorithm is utilized. Each striping algorithm, in turn, specifies the manner in which file content is apportioned as stripes across the plurality of volumes of the SVS.","The stripe width field  specifies the size\/width of each stripe. The ordered list of volumes field  contains the IDs of the volumes comprising the SVS. In an illustrative embodiment, the ordered list of volumes that may specify the function and implementation of the various volumes and striping rules of the SVS. For example, the ordering of volumes in the list may denote the manner of implementing a particular data placement pattern, e.g., round-robin.","To locate a D-Module  and its associated volume of a SVS in order to service a data access request to a file, a function uses the SVS ID , an offset within the file, the inode number for the file and a set of striping rules . For example, assume a data access request directed to a file is issued by a client  and received at the N-Module  of a node , where it is parsed through the multi-protocol engine  to the appropriate protocol server of N-Module .","To determine the location of a D-Module  to which to transmit a CF message , the N-Module  may first retrieve a SVS entry  to acquire the striping rules  (and list of volumes ) associated with the SVS. The N-Module  then identifies the appropriate volume (and D-Module) to which to direct an operation. The protocol server of N-Module  then transmits the CF message  to the D-Module .","Distributed Environment for Storing Oplocks:",{"@attributes":{"id":"p-0120","num":"0119"},"figref":"FIG. 6C","b":"640"},"Structure  shows a plurality of storage volumes ,  and  managed by one or more nodes . The storage volumes store meta-data with OpLock information for a plurality of data containers. For example, storage volume  stores meta-data  for a data container  (shown as DC) with OpLock information for DC. Storage volume  stores meta-data  for data container DC with OpLock information. Storage volume  stores meta-data  for DCn with OpLock information.","In one embodiment, structure  is different from conventional systems where OpLock information for data containers is stored at a single volume. The distributed structure is advantageous because it reduces bottlenecks for granting and maintaining OpLocks.","System:  illustrates an example of a system  for implementing the process steps described above with respect to . As an example, system  shows a first node A that manages a first storage volume  and a second node B that interfaces with client application  and also manages the second storage volume . However, the adaptive embodiments may be implemented with more or fewer nodes, for example, both the storage volumes may be managed by a single node. Nodes A and B are similar to node , described above with respect to .","Storage volume   may store certain cached OpLock  and resident OpLocks . Storage volume   may also store certain resident OpLocks  and cached OpLocks . A resident OpLock is \u201cowned\u201d by the storage volume where it resides. For example, Storage volume   owns resident locks .","When a cached OpLock at storage volume   needs to be recalled, an OpLock recall message  is sent to the entity that manages storage volume  (in this example, node B). Message  is similar to recall message  that is described above with respect to . Message  identifies the OpLock that needs to be recalled and also includes a request for node B to not grant any other OpLock with respect to the affected storage volume.","Recall OpLock message (shown as ) is then sent to client application . Client application  then performs any pending operations (for example, write operation ) that may be affected by the OpLock recall due to message .","After the operation is performed, an acknowledgement  is sent to node B indicating that the OpLock recall in request  has been successful. The cached OpLock identified in message  is then invalidated (). It is noteworthy that all cached copies of the OpLock identified in message  are invalidated by node B.","In one embodiment, where data containers from a first storage volume have to be moved to another storage volume or if the first storage volume becomes temporarily unavailable due to maintenance, failover or any other reason, then any right (for example, an OpLock) is revoked in a systematic manner such that clients are given an opportunity to complete any pending I\/O operation, before revoking the right. In the SVS environment, after an OpLock is revoked, all cached copies are invalidated to prevent metadata coherency problems when the original OpLock is cleared.","While the present disclosure is described above with respect to what is currently considered its preferred embodiments, it is to be understood that the disclosure is not limited to that described above. To the contrary, the disclosure is intended to cover various modifications and equivalent arrangements within the spirit and scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing features and other features will now be described with reference to the drawings of the various embodiments. In the drawings, the same components have the same reference numerals. The illustrated embodiments are intended to illustrate, but not to limit the present disclosure. The drawings include the following Figures:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2","FIG. 1C"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
