---
title: API backward compatibility checking
abstract: A system and method for automatically determining whether a newer version of an application programming interface (API) is backwards compatible with an older version is disclosed. The method includes comparing the two versions of the API to determine a set of atomic differences between the two versions and applying a set of backwards compatibility rules to the set of atomic differences. For each atomic difference, applying the rules includes analyzing the atomic difference to determine any applicable backwards compatibility rules and evaluating each applicable rule for the atomic difference to determine whether the atomic difference represents a violation. The method also includes storing an indication of any backwards compatibility violations from the evaluation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08539475&OS=08539475&RS=08539475
owner: Oracle America, Inc.
number: 08539475
owner_city: Redwood City
owner_country: US
publication_date: 20090929
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["Software applications, components of applications, software platforms, and\/or other software entities are often configured to expose an application programming interfaces (API) that may enable other entities (e.g., other programs, components, scripts, etc.) to interact with the API-exposing entity. An API may essentially outline the vocabulary and\/or calling conventions that others should employ in order to use the software services offered by the software entity. For example, an API may expose various functions provided by a software platform that an application may invoke. If a software entity attempts to invoke a function not exposed by the API, an error may occur, such as a compilation or runtime error.","In practice, a software entity's API often evolves with subsequent versions. For example, subsequent versions of a software platform may provide more and\/or better functionality through a modified API. However, if the new API does not provide, for example, the same methods as the old API, then some software applications and\/or components that were configured to interface with the old API may malfunction when the newer version is introduced. Therefore, when releasing a new version of an API, it may be desirable to determine whether the new version is backwards compatible with an older version.","A system and method for automatically determining whether a new version of an application programming interface (API) is backwards compatible with an earlier version of the API is disclosed. The method includes comparing the two versions of the API to determine a set of atomic differences between the two versions and applying a set of backwards compatibility rules to the set of atomic differences. For each atomic difference, applying the rules includes analyzing the atomic difference to determine any applicable backwards compatibility rules and evaluating each applicable rule for the atomic difference to determine whether the atomic difference represents a violation. The method also includes storing an indication of any backwards compatibility violations from the evaluation.","In some embodiments, said applying includes grouping two or more of the set of atomic differences as a modification to a single, common member of the first and second versions of the API. It may then be determined whether the modification violates any of the set of backwards compatibility rules. In some embodiments, the modification violates a backwards compatibility rule if it matches one or more modification templates of the backwards compatibility rules.","In various embodiments, the particular backwards compatibility rules may be selected dependent on the programming language and\/or platform in which the API is implemented. Each backwards compatibility rule may include a modification template, such that a modification matching the template is determined to violate the backwards compatibility rule. In some embodiments, modification templates may include a subject, condition for violation, and\/or exceptions to the rule. In some embodiments, each rule may also be associated with a severity (e.g., warning, critical) and\/or a scope (e.g., source code, binary compatibility problems).","In some embodiments, the method may further include indicating whether any of the modifications violates one or more of the plurality of rules. For example, a backwards compatibility report may be generated, which may include information such as that indicating which rules are violated, the severity and\/or scope of the violation, which modifications caused the violations, etc.","Each of the plurality of rules may be associated with a handler that may be used to determine whether each modification violates the rule. In various embodiments, the modifications may each be handled by every handler sequentially and\/or in parallel.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description hereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the invention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Any headings used herein are for organizational purposes only and are not meant to limit the scope of the description or the claims. As used herein, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to) rather than the mandatory sense (i.e. meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","APIs often evolve with subsequent versions. However, to avoid software malfunctions, it may be desirable for a new API to be backwards compatible with an older version. A new version of an API may be backwards compatible with an older version if an application configured to use the older API can use the newer version of the API without malfunctioning. For example, a new API may be backwards compatible with an older version if the newer version fully supports all of the functions of the older version. In some instances, a software developer of a new API may wish to determine whether the new API is backwards compatible with an older version of the API.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 1","FIG. 1"]},"According to the illustrated embodiment, the method of  may begin by receiving an old and new API, as in . Each API may include one or more API members. The term API member may refer to any entity exposed by the API, such as classes, methods\/functions, variables, etc.). Various members may be exposed as public members of the API while others may have more restricted access (e.g., package scope).","In some embodiments, the APIs received in  may be in various forms. For example, in some embodiments, one or both APIs may be received as a representation of a computer program that implements the respective API. In various embodiments, a computer program that implements an API may be represented as machine code (e.g., binary), assembly code, and\/or in any other high or low-level programming language. In various embodiments, binary representations may take the form of native binary and\/or that of interpreted binary, such as Java\u2122 byte-code.","In some embodiments, rather than receiving an API representation as an implemented computer program that implements the respective API, receiving step  may include receiving an interface description without a full implementation. For example, receiving an API as in  may include receiving a description of API members (e.g., classes, method\/function signatures, class member variables, etc.) without necessarily receiving a full program implementation of the API. For example, receiving step  may include receiving an XML or free text description of one or more APIs.","In embodiments, each API member may be described with a signature. A member's signature may include such things as the member name, one or more access modifiers, parameter types, return types, containing class, and\/or any other modifiers. For example, an example signature for a main method in a Java program (e.g., \u201cpublic static void main(string[ ] args)\u201d) may include a name (\u201cmain\u201d), an access modifier (\u201cpublic\u201d), a return type (\u201cvoid\u201d), parameter type (\u201cstring[ ]\u201d), and a class modifier (\u201cstatic\u201d). In some embodiments, the signature may further identify the object type wherein the member is defined.","In some embodiments, receiving an old and new API in  may comprise receiving the signatures of the members of the APIs. For example, these may be provided in a plain text file, XML document, or other description. In other embodiments, one or more of the APIs received in  may be received as program implementations (e.g., as binary programs).","According to the illustrated embodiment, the APIs received in  may be scanned to extract API member signatures, as in . In some embodiments, the step of extracting API member signatures, as in , may be performed in a manner dependent on the format in which each API is received in . For example, if an API is received as a textual representation (e.g., XML, unformatted text, etc.) of the API members' signatures, then a scanner component may read the textual representation and build an in-memory model of the API. Similarly, in instances where an API is received in  as a source code program representation, then extracting the API member signatures in  may include parsing the source code to extract textual representations of each signature. Various techniques known in the art may be applied to perform this parsing. A particular technique may be applied depend on the programming language in which the source code representation is coded. In embodiments wherein an API is received as a binary representation of a program that implements the API, step  may include extracting API member signatures from the binary representation using binary parsing techniques.","In some embodiments, the output of step  for each API may be an in-memory representation of the API. However, in some embodiments, the in-memory representation may be serialized (e.g., in a file). Such techniques may enable the system to be more flexible and modular. For example, if an API received in  is in the form of a binary program representation, various third party tools may be used in  to convert the API signatures to a serialized representation. In one such example, if an API is received in  in the form of Java\u2122 byte-code, the SigTest tool from Sun Microsystems may be used to analyze the program representation and to extract a golden signature file from it. The golden signature file may comprise a textual representation of the API, including the signatures for each of the API members. In some such embodiments, extracting API member signatures from a binary representation may include scanning the binary representation using an API scanner and creating an in-memory representation of the API as a reference model. In some embodiments, the reference model may subsequently be converted to a golden signature file using a model-writing component.","According to the illustrated embodiment, the API descriptions (either in-memory or in file) extracted in  from the API representations received in , may be analyzed to determine a set of atomic differences between the old and new API, as in . As used herein, the term atomic difference may refer to any signature that exists in one API but does not exist in the other. In various embodiments, a signature of a first API may be considered an atomic difference with a second API if the signature does not exactly match a corresponding member of the second API. For example, one atomic difference between an old and new API may be that the new API contains a specific function or variable that is not in the old API. In some embodiments, even if the same member name appears in both APIs, one or more atomic differences may be generated if the members are described using different modifiers, if the parameters are changed, and\/or if any other part of the signature is different.","In some examples, a single modification between the old and new API may cause multiple atomic differences to be detected. For example, if a member variable named \u201cvar\u201d exists in the older API with a public access modifier (e.g., public var) and appears in the new API with a different access modifier (e.g., protected var), then in some embodiments, two atomic differences may be detected. A first atomic difference may be that the old API contains a public variable named \u201cvar\u201d that is absent from the new API and another atomic difference may be that the new API contains a protected variable named \u201cvar\u201d that is not in the old API.","In some embodiments, tools such as SigTest from Sun Microsystems may be used to determine a set of atomic differences between the two APIs. According to one embodiment, SigTest may be usable to perform methods -. In such an embodiment, the old and new APIs may be received in the form of byte-code representations of programs that implement the respective APIs. In some embodiments, the SigTest tool may then scan the byte-code to determine signatures for the members of each API and save the members in two golden signature files, each corresponding to a respective API. The SigTest tool may be further configured to analyze the two golden signature files to determine a set of atomic differences between the two APIs, as in . In other embodiments, a golden signature file for one API may be compared to a binary form (e.g., class, jar files) of the other API. In still other embodiments, the tool may compare a binary form of one API to a binary form of the other API. A temporary golden signature file may be generated for one API and compared with the other API.","Once the atomic differences between the old and new APIs have been determined, as in , the method of  may comprise grouping atomic differences according to the respective API member to which each refers, as in . For instance, in the example above, the two atomic differences (i.e., public var in the old API and protected var in the new API) both refer to the same API member (i.e., var). Therefore, they may be grouped in . In some instances, a group may comprise only a single atomic difference (e.g., when an API member not in the old API is introduced into the new API).","In various embodiments, different heuristics may be used to determine which atomic differences correspond to the analogous members of the respective APIs. For example, in one embodiment, differences may be matched by the API member name and\/or to the type of member to which they refer (e.g., method vs. variable). In various embodiments, arbitrarily complex heuristics may be used.","According to the illustrated embodiment, after the atomic differences have been grouped, as in , the method may include determining one or more modifications to the old API represented by each group, as in . While atomic differences may identify signatures that are present in one API and not in another, modifications may represent semantic changes made to the older API in order to arrive at the newer API. As illustrated above, this may include modifications to members of the old API (including deletion) and\/or additions to the new API.","In some instances, a group of atomic differences may be indicative of multiple modifications. For example, if the old API is the only one to contain the method \u201cpublic double myMethod( )\u201d while the new API is the only one to contain the method \u201cprotected int myMethod( )\u201d, then these two atomic differences may be grouped in  since they may be in reference to the same API member method myMethod( ). In , it may be further determined that this group is indicative of two modifications: (1) access modifier of myMethod( ) was changed from public to protected and (2) return type of myMethod( ) changed from double to int. In some embodiments, the two atomic differences may not be grouped at all, depending on the grouping heuristics employed in .","According to the illustrated embodiment, once the modifications have been determined, the method may comprise determining, for each modification, whether it violates one or more of a plurality of backwards compatibility rules, as in . In some embodiments, step  may include comparing each modification against the same set of backwards compatibility rules. In other embodiments, each modification may be classified according to some criteria (e.g., type of API members to which each is applied) and the modifications in each classification may be compared against a respective set of compatibility rules corresponding to the classification.","As shown in the illustrated embodiment, any violations of backwards compatibility rules may be reported, as in . According to various embodiments, reporting rule violations, as in , may include creating a compatibility report, displaying the compatibility report in a user interface, printing the compatibility report, and\/or saving the compatibility report to a file.","In various embodiments, the compatibility report may contain different information. For example, in one embodiment, the compatibility report may contain information identifying one or more of the modifications that violate at least one compatibility criterion. A compatibility report may further identify one or more of: the compatibility rule violated by each of the modifications, the severity of the violation, the scope of the compatibility issue (as described below), information usable to locate each modification, and\/or suggestions for possible fixes.","As described above, the method of  may include, at , determining for each modification whether it violates one or more of a plurality of backwards compatibility rules. Various embodiments may utilize different sets of compatibility rules, which may take various forms.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["200","210","220","230"]},"In such embodiments, modification template  may include information usable to determine whether a given modification matches (i.e., violates) backwards compatibility rule . In some embodiments, a modification template (such as ) may comprise a subject (such as ), one or more conditions (such as ), and zero or more exceptions (such as ). In some embodiments, subject  may correspond to a type of modification. For example, one subject may be \u201cadding or removing API members\u201d, \u201cmodifying member visibility\u201d, \u201cmodifying constants\u201d, \u201cchanging modifiers\u201d, etc.","In other embodiments, subject  may refer to particular API members. For example, in such embodiments, an example subject may be \u201call classes\u201d, \u201call interfaces\u201d, \u201call instance variables\u201d, \u201call types\u201d, \u201call API members\u201d, etc.","According to the illustrated embodiment, modification template  may further comprise conditions , which may identify circumstances in which changes to the subject may breaks backwards compatibility. For instance, in the example above regarding changing the visibility of member var from public to protected, the subject may correspond to \u201cinstance variables\u201d while the condition may correspond to \u201cnarrowing visibility from public to non-public\u201d.","In alternate embodiments, wherein subjects are condition types, the subject may correspond to \u201cmodifying member visibility\u201d while the condition corresponds to \u201cnarrowing from public to non-public\u201d. For the purposes of this disclosure, embodiments wherein subjects indicate API member types will be discussed henceforth. However, this is for purposes of clarity and is not intended to be limiting.","According to the illustrated embodiment, modification template  of backwards compatibility rule  may optionally comprise any number of exceptions . Exceptions  may define exceptions to the rule such that if a given modification matches one or more of conditions  and also one or more of exceptions , then the given modification would not match modification template  and therefore not be a violation of backwards compatibility according to rule .","To illustrate an example of an exception, suppose that backwards compatibility rule  is configured to detect modifications that narrow an API member's visibility in a manner that breaks backwards compatibility. In one such example, subject  may be \u201cany API member\u201d while condition  may be \u201cnarrowing visibility from protected to private\u201d. This modification template would match any modification that narrows an API member's visibility from protected to private. However, it may be that not all such modifications cause a backwards compatibility problem. For example, narrowing the visibility of a class that has no public constructor from protected to private may not cause a backwards compatibility issue. Therefore, exceptions  may indicate this exception by indicating that the rule does not apply to classes that do not have public constructors. In this case, exceptions  may also include further exceptions, such as for narrowing protected visibility of a member (e.g., variable, method) of a final class, of an enumerated type, or of another circumstance that would not break backwards compatibility.","According to the illustrated embodiment, backwards compatibility rule  may further include severity indication , which may be used to indicate a level of severity for violating the backwards compatibility rule. In different embodiments, the severity of violating different backwards compatibility rules may be different. For example, in some instances, violating a backwards compatibility rule may cause systems configured to rely on the older API to malfunction while violating other compatibility rules may not necessarily cause a malfunction. In some implementations, severity indication  may be configured to indicate one of at least two levels of severity: a critical level indicating that a modification violating the rule does cause a backwards compatibility problem and a warning level indicating that a modification violating the rule may cause a backwards compatibility problem. In various embodiments, different severity indication values may be possible.","As in the illustrated embodiment, backwards compatibility rule  may further comprise scope indication . In some embodiments, scope indication  may be used to indicate whether a modification matching the rule would cause a backwards compatibility problem for applications during compilation time (source code scope) or during runtime (binary code scope), or both.","A backwards compatibility problem at the source code scope may cause a problem that is detectable statically by analyzing the source code of an application that is configured to use the older API. That is, if the new API has a backwards compatibility problem at the source code scope, an application written to use the old API may not compile when the old API is replaced with the new API.","A backwards compatibility problem at the binary scope may cause a problem that is detectable only at runtime. For example, a program that is configured to utilize the old API may still compile with the new API, even if the new API has compatibility problems at the binary scope. However, the compatibility issues may cause the program to malfunction at runtime, such as by throwing a runtime exception.","Thus, each backwards compatibility rule may specify a level of severity and a scope for the problems caused by a modification violating that rule.","In various embodiments, the set of backwards compatibility rules, including subjects, conditions, exceptions, severity indication, and\/or scope may be dependent on the programming language and\/or the platform that implements the API and\/or that implements a given program configured to utilize the API. For example, the backwards compatibility rules below may be used for determining backwards compatibility for APIs written in the Java\u2122 programming language:\n\n","In some embodiments, the rule set above may be used to determine if a new version of a given Java\u2122 API is compatible with an older version. In some embodiments, such as that illustrated in , the rules above may be combined with the SigTest tool of Sun Microsystems for determining backwards compatibility of two versions of an API.",{"@attributes":{"id":"p-0050","num":"0204"},"figref":"FIG. 3","b":["300","305"]},"Once the two API implementations have been received (as in  and ), the method may comprise using the known SigTest tool to determine a set of atomic differences between the received first and second versions of the API, as in . As described earlier, the SigTest tool may produce a golden signature file for each of the received API implementations, which may contain various signatures for every member of the respective API, including variables, methods, classes, etc. In other embodiments, a golden signature file for one API may be compared to a binary form (e.g., class, jar files) of the other API. In still other embodiments, the tool may compare a binary form of one API to a binary form of the other API. A temporary golden signature file may be generated for one API and compared with the other API. In the illustrated embodiment, the atomic differences of  may comprise indications of each interface element that does not appear exactly in both of the received API implementations.","According to the illustrated embodiment, the method may then involve grouping the atomic differences into groups of one or more according to the respective API member to which the differences refer, as in . For example, a method signature that appears in the first version of the API but not in the second may correspond to the same method as a second method signature that appears in the second version of the API but not in the first. In such a case, the two signatures may be grouped in .","In , the illustrated method comprises examining each group and determining one or more modifications to the old API represented by each group. For example, in the case above where two method signatures were grouped as referring to the same method, determining one or more modifications to the first API may, in various cases, include such determinations as whether the method's visibility was changed, whether its scope was changed from static to non-static, and\/or various other modifications.","According to the illustrated embodiment, in , each modification determined in  may be matched against a plurality of backwards compatibility rules, such as those listed above, to determine if the modification matches one or more of the rules. In some embodiments, the method may include reporting any or all such matches as backwards compatibility violations, as in . According to various embodiments, reporting backwards compatibility violations, as in , may include creating a compatibility report, displaying the compatibility report in a user interface, printing the compatibility report, and\/or saving the compatibility report to a file. In various embodiments, the file may be in plain text, XML, or in any other format and may contain different information, as outlined above with respect to element  of .",{"@attributes":{"id":"p-0055","num":"0209"},"figref":["FIG. 4","FIG. 4","FIG. 3"],"b":"325"},"According to the illustrated embodiment of , each rule (e.g., -) may be represented and\/or embodied by a respective handler (e.g., -). In some embodiments, rules -may each include a modification template, severity indication, and\/or scope indication, such as in the data structure of . In some embodiments, such as those configured to determine the backwards compatibility between two implementations of a given Java\u2122 API, the n rules may correspond to the rules enumerated above.","Each handler -may be configured to determine whether a given modification matches the respective rule represented by that handler. In various embodiments, handlers  may process the determined modifications in different orders and\/or patterns. For example, in some embodiments, handlers  may be arranged in a chain of responsibility pattern, such as that illustrated in . That is, given a set of modifications to the API (such as ), each modification may be compared successively by each handler -to a corresponding rule -. Each time a handler matches a modification of  to a rule , the handler may note the match as a backwards compatibility violation in .","Numerous variations are possible. For example, in some embodiments, each modification may be processed by every handler, regardless of the result from each handler (e.g., violation or non-violation). In other embodiments, a modification that matches a rule of a given handler may not be processed by a subsequent handler. In such embodiments, the modification templates of rules may be interrelated with the order of the handlers.","In other embodiments, the handlers may be configured to process the modifications in parallel. For example, handler may be configured to process a first modification of  while handler processes a different modification of . Later, each handler may process the other modification. In such embodiments, the processing task may be faster due to the parallel processing.","In some embodiments, the handlers may process the determined modifications (as in the illustrated embodiment of ) while in other embodiments each handler may operate on the atomic differences (e.g., output of ) and\/or on groups of atomic differences (e.g., output of ).","In some embodiments, all of the modifications may be processed before a backwards compatibility report is generated, as in . A backwards compatibility report may be generated by examining backwards compatibility violations , which result from the processing of modifications  by handlers .",{"@attributes":{"id":"p-0062","num":"0216"},"figref":"FIG. 5","b":["500","510","510","510"]},"Backwards compatibility test module  may further comprise atomic difference grouping module , which may be configured to group the atomic differences between the two received APIs according to subject. Test module  may further include modification determining module , which may be configured to determine one or more modifications made between the old and new APIs to produce the atomic differences.","Backwards compatibility test module  may further comprise a plurality of backwards compatibility rules  and corresponding handlers . In some embodiments, there may be a one-to-one and onto correspondence between backwards compatibility rules  and handlers . In some embodiments, backwards compatibility test module  may further comprise a report generator , which may be capable of generating a backwards compatibility report for two given APIs, based on backwards compatibility rules .",{"@attributes":{"id":"p-0065","num":"0219"},"figref":"FIG. 6","b":"600"},"The API backwards compatibility checking components and methods described herein may be provided as a computer program product, or software, that may include a computer-readable storage medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to various embodiments. A computer-readable storage medium may include any mechanism for storing information in a form (e.g., software, processing application) readable by a machine (e.g., a computer). The computer-readable storage medium may include, but is not limited to, magnetic storage medium (e.g., floppy diskette); optical storage medium (e.g., CD-ROM); magneto-optical storage medium; read only memory (ROM); random access memory (RAM); erasable programmable memory (e.g., EPROM and EEPROM); flash memory; electrical, or other types of medium suitable for storing program instructions. In addition, program instructions may be communicated using optical, acoustical or other form of propagated signal (e.g., carrier waves, infrared signals, digital signals, etc.)","A computer system  may include one or more processors , each of which may include multiple cores, any of which may be single or multi-threaded. The computer system  may also include one or more persistent storage devices  (e.g. optical storage, magnetic storage, hard drive, tape drive, solid state memory, etc), which may persistently store data such as rules and\/or API implementations.","Computer system  may further comprise any number of I\/O devices, such as . For example, I\/O devices  may include one or more monitors, keyboards, speakers, etc.","According to the illustrated embodiment, computer system  may include one or more memories  (e.g., one or more of cache, SRAM, DRAM, RDRAM, EDO RAM, DDR  RAM, SDRAM, Rambus RAM, EEPROM, etc.). The one or more processors , the storage device(s) , I\/O devices , and the system memory  may be coupled to an interconnect . Various embodiments may include fewer or additional components not illustrated in  (e.g., video cards, audio cards, additional network interfaces, peripheral devices, a network interface such as an ATM interface, an Ethernet interface, a Frame Relay interface, etc.)","One or more of the system memories  may contain program instructions . Program instructions  may be encoded in platform native binary, any interpreted language such as Java\u2122 byte-code, or in any other language such as C\/C++, Java\u2122, etc or in any combination thereof. Program instructions  may include program instructions executable to implement two or more APIs  that may be tested against one another for backwards compatibility. In other embodiments, one or more APIs may be provided in forms other than as one of implementations  (e.g., as a golden signature file).","Program instructions  may further comprise a backwards compatibility test module , which may be configured to analyze API implementations  for backwards compatibility issues with respect to another of API implementations . In some embodiments, backwards compatibility test module  may correspond to backwards compatibility test module  of .","In some embodiments, program instructions  may further comprise one or more operating systems  for executing software on computer system . Program instructions  may further comprise one or more compilers, which may be used to parse, interpret, and\/or compile source code representing various API implementations.","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. For example, various techniques and rule sets may be used to determine compatibility checking dependent on the given language and\/or platform on which the candidate APIs are implemented. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
