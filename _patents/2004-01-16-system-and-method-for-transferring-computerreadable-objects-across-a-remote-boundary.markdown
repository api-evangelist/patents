---
title: System and method for transferring computer-readable objects across a remote boundary
abstract: A system and method for securely transferring computer-readable objects across a remote boundary is provided. The method decomposes any type of object into a hierarchy of sub-components based on a list of known object types. Each sub-component either corresponds to a known object type or an unknown object type. The unknown object types may be decomposed further into known object types at another level in the hierarchy. The known objects in the hierarchy are serialized into a package that is transmitted to a remote entity. The remote entity reconstructs the hierarchy. For any of the known object types, the remote entity instantiates an object of the known object type and populates the object with information transmitted in the package. The decomposition may be limited by specifying a level for the hierarchy, specifying a number that limits the known objects that are serialized, or specifying the properties within the object to serialize.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07770181&OS=07770181&RS=07770181
owner: Microsoft Corporation
number: 07770181
owner_city: Redmond
owner_country: US
publication_date: 20040116
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Exemplary Computing Environment","Exemplary Administrative Tool Framework","Exemplary Metadata Processor","Exemplary Error & Event Processor","Exemplary Session Manager","Exemplary Pipeline Processor and Loader","Exemplary Operation"],"p":["Subject matter disclosed herein relates to remote computing systems, and in particular to methods for transferring computer-readable objects during remote communications.","Today, during software development, developers utilize a programming concept called object-oriented programming. In object-oriented programming, computer-readable objects (objects) are defined. The objects have properties and methods. The properties store data that pertains to the object. The methods perform functionality associated with the object and typically, provide interfaces to the properties defined in the object. Even though programming with objects provides great versatility, using objects across remote boundaries, such as between different computers, presents some challenges.","One challenge is determining the mechanism for transferring the objects between the two computers. In certain environments, the executable code (methods) for an object, along with its properties, are transferred to a requesting computer from a server computer. However, this solution may pose a security risk to the requesting computer if the executable code that is transferred performs a malicious action, such as deleting files. Thus, other solutions have been developed to minimize this potential risk.","One current solution is a technology called Web Services Technology. Using this technology, the object is converted into XML (extended mark-up language), which is transmitted to the requesting computer. Upon receiving the XML, the requesting computer converts the XML back into the object. The requesting computer may than access the object's properties and invoke the object's methods. Using this technology, the requesting computer is responsible for knowing and trusting the server from which the object is received. In addition, for any object that wishes to communicate with the requesting computer, the software developer, who developed the object, must implement a special interface to handle the communication. The special interface provides a mechanism for serializing and de-serializing the object in order for the object to be transferred.","Even though this Web Service solution provides a robust environment for transferring objects across remote boundaries, the technology is restrictive and burdensome. In some environments, such as in system administration environments, forcing software developers to implement a special interface for objects that system administration tasks wish to monitor, is not a viable solution. For example, requiring the developers to implement these special interfaces is not a trivial matter, and requires the developers to divert their attention away from their primary objective\u2014implementing the object for their own particular application. Thus, many developers do not implement the special interfaces for their objects, and thus, these objects are not accessible.","Therefore, there is a need for a method of transferring objects across a remote boundary that is secure, not restrictive, and not burdensome to software developers.","The invention is directed to mechanisms and techniques for remote communication of objects. Briefly stated, a system and method for securely transferring computer-readable objects across a remote boundary is provided. The method decomposes any type of object into a hierarchy of sub-components based on a list of known object types. Each sub-component either corresponds to a known object type or an unknown object type. The unknown object types may be decomposed further into known object types at another level in the hierarchy. The known objects in the hierarchy are serialized into a package that is transmitted to a remote entity. The remote entity reconstructs the hierarchy. For any of the known object types, the remote entity instantiates an object of the known object type and populates the object with information transmitted in the package. The decomposition may be limited by specifying a level for the hierarchy, specifying a number that limits the known objects that are serialized, or specifying the properties within the object to serialize.","Briefly stated, the present system and method for transferring objects across a remote boundary provides a secure method for transferring objects. In addition, the present system and method does not place any artificial requirements on objects. Therefore, software developers do not incur any burden for supporting remote operations using their objects. Thus, unlike existing systems, any object on any computer or in another process on the same computer may be transferred across the remote boundary to a requesting process. In addition, the present system and method for transferring objects does not require both computers to execute the same version of software. Rather, the method incorporates a protocol negotiation process that not only provides a mechanism for supporting communication between two different versions, but also minimizes the amount of data transferred over the remote boundary.","The following detailed description is divided into several sections. In general, the present system and method is described within the context of an exemplary administrative tool environment. However, after reading the following description, those skilled in the art will appreciate that the present method may be implemented in other exemplary environments, which are also included within the scope of the appended claims.","A first section describes an illustrative computing environment in which an exemplary administrative tool environment may operate. A second section describes an exemplary framework for the administrative tool environment. Subsequent sections describe individual components of the exemplary framework and the operation of these components. For example, the section on \u201cExemplary Remote Processing of a Cmdlet\u201d, in conjunction with , describes an exemplary system and method for transferring objects across a remote boundary.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 1","FIG. 1"],"b":["100","102","104","104","104","105","106","107","106","120","105","200","120","108"]},"Computing device  may have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. These devices are well know in the art and need not be discussed at length here.","Computing device  may also contain communication connections  that allow the device to communicate with other computing devices , such as over a network. Communication connections  are one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2","b":["200","200","202","204","206","208","206","202","204","208"]},"Host Components","The host components  include one or more host programs (e.g., host programs -) that expose automation features for an associated application to users or to other programs. Each host program - may expose these automation features in its own particular style, such as via a command line, a graphical user interface (GUI), a voice recognition interface, application programming interface (API), a scripting language, a web service, and the like. However, each of the host programs - expose the one or more automation features through a mechanism provided by the administrative tool framework.","In this example, the mechanism uses cmdlets to surface the administrative tool capabilities to a user of the associated host program -. In addition, the mechanism uses a set of interfaces made available by the host to embed the administrative tool environment within the application associated with the corresponding host program -. Throughout the following discussion, the term \u201ccmdlet\u201d is used to refer to commands that are used within the exemplary administrative tool environment.","Cmdlets correspond to commands in traditional administrative environments. However, cmdlets are quite different than these traditional commands. For example, cmdlets are typically smaller in size than their counterpart commands because the cmdlets can utilize common functions provided by the administrative tool framework, such as parsing, data validation, error reporting, and the like. Because such common functions can be implemented once and tested once, the use of cmdlets throughout the administrative tool framework allows the incremental development and test costs associated with application-specific functions to be quite low compared to traditional environments.","In addition, in contrast to traditional environments, cmdlets do not need to be stand-alone executable programs. Rather, cmdlets may run in the same processes within the administrative tool framework. This allows cmdlets to exchange \u201clive\u201d objects between each other. This ability to exchange \u201clive\u201d objects allows the cmdlets to directly invoke methods on these objects.","In overview, each host program - manages the interactions between the user and the other components within the administrative tool framework. These interactions may include prompts for parameters, reports of errors, and the like. Typically, each host program - may provide its own set of specific host cmdlets (e.g., host cmdlets ). For example, if the host program is an email program, the host program may provide host cmdlets that interact with mailboxes and messages. Even though  illustrates host programs -, one skilled in the art will appreciate that host components  may include other host programs associated with existing or newly created applications. These other host programs will also embed the functionality provided by the administrative tool environment within their associated application.","In the examples illustrated in , a host program may be a management console (i.e., host program ) that provides a simple, consistent, administration user interface for users to create, save, and open administrative tools that manage the hardware, software, and network components of the computing device. To accomplish these functions, host program  provides a set of services for building management GUIs on top of the administrative tool framework. The GUI interactions may also be exposed as user-visible scripts that help teach the users the scripting capabilities provided by the administrative tool environment.","In another example, the host program may be a command line interactive shell (i.e., host program ). The command line interactive shell may allow shell metadata  to be input on the command line to affect processing of the command line.","In still another example, the host program may be a web service (i.e., host program ) that uses industry standard specifications for distributed computing and interoperability across platforms, programming languages, and applications. In another example, illustrated in , the host program may provide a remote interface for communicating with a remote computer.","In addition to these examples, third parties may add their own host components by creating \u201cthird party\u201d or \u201cprovider\u201d interfaces and provider cmdlets that are used with their host program or other host programs. The provider interface exposes an application or infrastructure so that the application or infrastructure can be manipulated by the administrative tool framework. The provider cmdlets provide automation for navigation, diagnostics, configuration, lifecycle, operations, and the like. The provider cmdlets exhibit polymorphic cmdlet behavior on a completely heterogeneous set of data stores. The administrative tool environment operates on the provider cmdlets with the same priority as other cmdlet classes. The provider cmdlet is created using the same mechanisms as the other cmdlets. The provider cmdlets expose specific functionality of an application or an infrastructure to the administrative tool framework. Thus, through the use of cmdlets, product developers need only create one host component that will then allow their product to operate with many administrative tools. For example, with the exemplary administrative tool environment, system level graphical user interface help menus may be integrated and ported to existing applications.","Host-Specific Components","The host-specific components  include a collection of services that computing systems (e.g., computing device  in ) use to isolate the administrative tool framework from the specifics of the platform on which the framework is running. Thus, there is a set of host-specific components for each type of platform. The host-specific components allow the users to use the same administrative tools on different operating systems.","Turning briefly to , the host-specific components  may include an intellisense\/metadata access component , a help cmdlet component , a configuration\/registration component , a cmdlet setup component , and an output interface component  Components - communicate with a database store manager  associated with a database store . The parser  and script engine  communicate with the intellisense\/metadata access component . The core engine  communicates with the help cmdlet component , the configuration\/registration component , the cmdlet setup component , and the output interface component . The output interface component  includes interfaces provided by the host to out cmdlets. These out cmdlets can then call the host's output object to perform the rendering. Host-specific components  may also include a logging\/auditing component , which the core engine  uses to communicate with host specific (i.e., platform specific) services that provide logging and auditing capabilities.","In one exemplary administrative tool framework, the intellisense\/metadata access component  provides auto-completion of commands, parameters, and parameter values. The help cmdlet component  provides a customized help system based on a host user interface.","Handler Components","Referring back to , the handler components  includes legacy utilities , management cmdlets , non-management cmdlets , remoting cmdlets , and a web service interface . The management cmdlets  (also referred to as platform cmdlets) include cmdlets that query or manipulate the configuration information associated with the computing device. Because management cmdlets  manipulate system type information, they are dependant upon a particular platform. However, each platform typically has management cmdlets  that provide similar actions as management cmdlets  on other platforms. For example, each platform supports management cmdlets  that get and set system administrative attributes (e.g., get\/process, set\/IPAddress). The host-independent components  communicate with the management cmdlets via cmdlet objects generated within the host-independent components .","The non-management cmdlets  (sometimes referred to as base cmdlets) include cmdlets that group, sort, filter, and perform other processing on objects provided by the management cmdlets . The non-management cmdlets  may also include cmdlets for formatting and outputting data associated with the pipelined objects. The non-management cmdlets  may be the same on each platform and provide a set of utilities that interact with host-independent components  via cmdlet objects. The interactions between the non-management cmdlets  and the host-independent components  allow reflection on objects and allow processing on the reflected objects independent of their (object) type. Thus, these utilities allow developers to write non-management cmdlets once and then apply these non-management cmdlets across all classes of objects supported on a computing system. In the past, developers had to first comprehend the format of the data that was to be processed and then write the application to process only that data. As a consequence, traditional applications could only process data of a very limited scope.","The legacy utilities  include existing executables, such as win32 executables that run under cmd.exe. Each legacy utility  communicates with the administrative tool framework using text streams (i.e., stdin and stdout), which are a type of object within the object framework. Because the legacy utilities  utilize text streams, reflection-based operations provided by the administrative tool framework are not available. The legacy utilities  execute in a different process than the administrative tool framework. Although not shown, other cmdlets may also operate out of process.","The remoting cmdlets , in combination with the web service interface , provide remoting mechanisms to access interactive and programmatic administrative tool environments on other computing devices over a communication media, such as internet or intranet (e.g., internet\/intranet  shown in ). In one exemplary administrative tool framework, the remoting mechanisms support federated services that depend on infrastructure that spans multiple independent control domains. The remoting mechanism allows scripts to execute on remote computing devices. The scripts may be run on a single or on multiple remote systems. The results of the scripts may be processed as each individual script completes or the results may be aggregated and processed en-masse after all the scripts on the various computing devices have completed.","For example, web service  shown as one of the host components  may be a remote agent. The remote agent handles the submission of remote command requests to the parser and administrative tool framework on the target system. The remoting cmdlets serve as the remote client to provide access to the remote agent. The remote agent and the remoting cmdlets communicate via a parsed stream. This parsed stream may be protected at the protocol layer, or additional cmdlets may be used to encrypt and then decrypt the parsed stream. Exemplary components for processing remote cmdlets and transferring objects between remote processes is illustrated in  and described below in the section entitled \u201cExemplary Remote Processing of a Cmdlet\u201d.","Host-Independent Components","The host-independent components  include a parser , a script engine  and a core engine . The host-independent components  provide mechanisms and services to group multiple cmdlets, coordinate the operation of the cmdlets, and coordinate the interaction of other resources, sessions, and jobs with the cmdlets.","Exemplary Parser","The parser  provides mechanisms for receiving input requests from various host programs and mapping the input requests to uniform cmdlet objects that are used throughout the administrative tool framework, such as within the core engine . In addition, the parser  may perform data processing based on the input received. The parser  of the present administrative tool framework provides the capability to easily expose different languages or syntax to users for the same capabilities. For example, because the parser  is responsible for interpreting the input requests, a change to the code within the parser  that affects the expected input syntax will essentially affect each user of the administrative tool framework. Therefore, system administrators may provide different parsers on different computing devices that support different syntax. However, each user operating with the same parser will experience a consistent syntax for each cmdlet. In contrast, in traditional environments, each command implemented its own syntax. Thus, with thousands of commands, each environment supported several different syntax, usually many of which were inconsistent with each other.","Exemplary Script Engine","The script engine  provides mechanisms and services to tie multiple cmdlets together using a script. A script is an aggregation of command lines that share session state under strict rules of inheritance. The multiple command lines within the script may be executed either synchronously or asynchronously, based on the syntax provided in the input request. The script engine  has the ability to process control structures, such as loops and conditional clauses and to process variables within the script. The script engine also manages session state and gives cmdlets access to session data based on a policy (not shown).","Exemplary Core Engine","The core engine  is responsible for processing cmdlets identified by the parser . Turning briefly to , an exemplary core engine  within the administrative tool framework  is illustrated. The exemplary core engine  includes a pipeline processor , a loader , a metadata processor , an error & event handler , a session manager , and an extended type manager .","The metadata processor  is configured to access and store metadata within a metadata store, such as database store  shown in . The metadata may be supplied via the command line, within a cmdlet class definition, and the like. Different components within the administrative tool framework  may request the metadata when performing their processing. For example, parser  may request metadata to validate parameters supplied on the command line.","The error & event processor  provides an error object to store information about each occurrence of an error during processing of a command line. For additional information about one particular error and event processor which is particularly suited for the present administrative tool framework, refer to U.S. patent application Ser. No. 10\/413,054, entitled \u201cSystem and Method for Persisting Error Information in a Command Line Environment\u201d, which is owned by the same assignee as the present invention, and is incorporated here by reference.","The session manager  supplies session and state information to other components within the administrative tool framework . The state information managed by the session manager may be accessed by any cmdlet, host, or core engine via programming interfaces. These programming interfaces allow for the creation, modification, and deletion of state information.","The loader  is configured to load each cmdlet in memory in order for the pipeline processor  to execute the cmdlet. The pipeline processor  includes a cmdlet processor  and a cmdlet manager . The cmdlet processor  dispatches individual cmdlets. If the cmdlet requires execution on a remote, or a set of remote machines, the cmdlet processor  coordinates the execution with the remoting cmdlet  shown in . The cmdlet manager  handles the execution of aggregations of cmdlets. The cmdlet manager , the cmdlet processor , and the script engine  () communicate with each other in order to perform the processing on the input received from the host program -. The communication may be recursive in nature. For example, if the host program provides a script, the script may invoke the cmdlet manager  to execute a cmdlet, which itself may be a script. The script may then be executed by the script engine .","Exemplary Extended Type Manager","As mentioned above, the administrative tool framework provides a set of utilities that allows reflection on objects and allows processing on the reflected objects independent of their (object) type. The administrative tool framework  interacts with the component framework on the computing system (component framework  in ) to perform this reflection. As one skilled in the art will appreciate, reflection provides the ability to query an object and to obtain a type for the object, and then reflect on various objects and properties associated with that type of object to obtain other objects and\/or a desired value.","Even though reflection provides the administrative tool framework  a considerable amount of information on objects, traditionally reflection focuses on the type of object. For example, when a database datatable is reflected upon, the information that is returned is that the datatable has two properties: a column property and a row property. These two properties do not provide sufficient detail regarding the \u201cobjects\u201d within the datatable. Similar problems arise when reflection is used on extensible markup language (XML) and other objects.","In contrast, extended type manager  focuses on the usage of the type rather than the type of object. Thus, with this as its focus, the extended type manager determines whether the object can be used to obtain the required information. Continuing with the above datatable example, knowing that the datatable has a column property and a row property is not particularly interesting. However, by focusing on the usage, the extended type manager associates each row with an \u201cobject\u201d and associates each column with a \u201cproperty\u201d of that \u201cobject\u201d. Thus, the extended type manager  provides a mechanism to create \u201cobjects\u201d from any type of precisely parse-able input. In so doing, the extended type manager  supplements the reflection capabilities provided by the component-based framework  and extends \u201creflection\u201d to any type of precisely parse-able input.","In overview, the extended type manager is configured to access precisely parse-able input (not shown) and to correlate the precisely parse-able input with a requested data type. The extended type manager  then provides the requested information to the requesting component, such as the pipeline processor  or parser . In the following discussion, precisely parse-able input is defined as input in which properties and values may be discerned. Some exemplary precisely parse-able input include Windows Management Instrumentation (WMI) input, ActiveX Data Objects (ADO) input, eXtensible Markup Language (XML) input, and object input, such as .NET objects. Other precisely parse-able input may include third party data formats.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 5","b":["502","1","2","1","2","502","1","2","1","2","520","508","510","1","2","1","2","520","520","502"]},"In both the tightly bound systems and the reflection systems, new data types can not be easily incorporated within the operating environment. For example, in a tightly bound system, once the operating environment is delivered, the operating environment can not incorporate new data types because it would have to be rebuilt in order to support them. Likewise, in reflection systems, the metadata for each object class is fixed. Thus, incorporating new data types is not usually done.","However, with the present extended type manager new data types can be incorporated into the operating system. With the extended type manager , generic code  may reflect on a requested object to obtain extended data types (e.g., object A\u2032) provided by various external sources, such as a third party objects (e.g., object A\u2032 and B), a semantic web , an ontology service , and the like. As shown, the third party object may extend an existing object (e.g., object A\u2032) or may create an entirely new object (e.g., object B).","Each of these external sources may register their unique structure within a type metadata  and may provide code . When an object is queried, the extended type manager reviews the type metadata  to determine whether the object has been registered. If the object is not registered within the type metadata , reflection is performed. Otherwise, extended reflection is performed. The code  returns the additional properties and methods associated with the type being reflected upon. For example, if the input type is XML, the code  may include a description file that describes the manner in which the XML is used to create the objects from the XML document. Thus, the type metadata  describes how the extended type manager  should query various types of precisely parse-able input (e.g., third party objects A\u2032 and B, semantic web ) to obtain the desired properties for creating an object for that specific input type and the code  provides the instructions to obtain these desired properties. As a result, the extended type manager  provides a layer of indirection that allows \u201creflection\u201d on all types of objects. An exemplary implementation for this layer of indirection is described in greater detail below in conjunction with remote processing. In this implementation, a precisely parse-able input (e.g., a serialized object) is used to obtain the desired properties for creating an object for a specific input type (e.g., a property bag). The property bag is then further de-composed to create objects of one or more base types. As will be described, the extended type manager enables one embodiment for transferring objects between remote processes and allows any object of any type to be transferred between the processes.","In addition to providing extended types, the extend type manager  provides additional query mechanisms, such as a property path mechanism, a key mechanism, a compare mechanism, a conversion mechanism, a globber mechanism, a property set mechanism, a relationship mechanism, and the like. Various techniques may be used to implement the semantics for the extended type manager. Three techniques are described below. However, those skilled in the art will appreciate that variations of these techniques may be used.","In one technique, a series of classes having static methods (e.g., getproperty( )) may be provided. An object is input into the static method (e.g., getproperty(object)), and the static method returns a set of results. In another technique, the operating environment envelopes the object with an adapter. Thus, no input is supplied. Each instance of the adapter has a getproperty method that acts upon the enveloped object and returns the properties for the enveloped object. The following is pseudo code illustrating this technique:",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class Adaptor"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003Object X;"]},{"entry":[{},"\u2003\u2003getProperties( );"]},{"entry":[{},"}."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In still another technique, an adaptor class subclasses the object. Traditionally, subclassing occurred before compilation. However, with certain operating environments, subclassing may occur dynamically. For these types of environments, the following is pseudo code illustrating this technique:",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class Adaptor : A"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003getProperties( )"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003return data;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Thus, as illustrated in , the extended type manager allows developers to create a new data type, register the data type, and allow other applications and cmdlets to use the new data type. In contrast, in prior administrative environments, each data type had to be known at compile time so that a property or method associated with an object instantiated from that data type could be directly accessed. Therefore, adding new data types that were supported by the administrative environment was seldom done in the past.","Referring back to , in overview, the administrative tool framework  does not rely on the shell for coordinating the execution of commands input by users, but rather, splits the functionality into processing portions (e.g., host-independent components ) and user interaction portions (e.g., via host cmdlets). In addition, the present administrative tool environment greatly simplifies the programming of administrative tools because the code required for parsing and data validation is no longer included within each command, but is rather provided by components (e.g., parser ) within the administrative tool framework. The exemplary processing performed within the administrative tool framework is described below.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 6","FIGS. 8-11"],"b":"13"},"Exemplary Data Structures for Cmdlet Objects",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 6","FIG. 2"]},"The provider cmdlet  (hereinafter, referred to as cmdlet ) is a public class deriving from a cmdlet class . Cmdlet  includes a cmdlet class name specified in place of \u201c<command name>\u201d. A software developer specifies a cmdletDeclaration  that associates a verb\/noun pair , such as \u201cget\/process\u201d, \u201cget\/db\u201d, \u201cformat\/table\u201d, and the like, with the cmdlet . The verb\/noun pair  is registered within the administrative tool environment. The verb or the noun may be implicit. The parser looks in the cmdlet registry to identify the cmdlet  when a command string having the name (e.g., get\/db) is supplied as input on a command line or in a script.","The cmdlet  is associated with a grammar mechanism that defines a grammar for expected input parameters to the cmdlet. The grammar mechanism may be directly or indirectly associated with the cmdlet. For example, cmdlet  illustrates a direct grammar association. In cmdlet , one or more public parameters (e.g., Name  and State ) are declared. Each public parameter  and  may be associated with one or more types of attributes, such as input attribute  and . The input attributes  and  specify the manner in which public parameters  and , respectively, are populated. For example, the public parameter may be populated from an object emitted by another cmdlet in a pipeline of commands, from the command line, and the like. If the public parameters are populated from other objects, cmdlet  includes a first method  (e.g., StartProcessing) and a second method  (e.g., processRecord). The core engine uses the first and second methods  and  to direct the processing of the cmdlet . For example, the first method  may be executed once and may perform set-up functions. The code within the second method  may be executed for each object (e.g., record) that needs to be processed by the cmdlet . The cmdlet  may also include a third method (not shown) that cleans up after the cmdlet . Alternatively, the grammar mechanism may be indirectly associated with the cmdlet by using a description of the public parameters defined in an external source, such as an XML document. The description of the parameters in this external source would then drive the parsing of the input objects to the cmdlet.","Thus, as shown in , code within the second method  is typically quite brief and does not contain functionality required in traditional administrative tool environments, such as parsing code, data validation code, and the like. Thus, system administrators can develop complex administrative tasks without learning a complex programming language.","The data structure  may also include a private member  that is not recognized as an input parameter. The private member  may be used for storing data that is generated within the cmdlet.","Exemplary process flows within the administrative tool environment are now described.","Exemplary Remote Processing of a Cmdlet",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 7","FIG. 7"],"b":["700","710","720","720","720","700","720"]},"The administrator  and remote server  may be computing devices, such as computing device  illustrated in . The administrator  is used by a system administrator or the like to maintain the remote server . In other words, the administrator  runs commands and performs tasks that may query the status or state of the remote server  and\/or make changes to the remote server . The administrator  includes an execution environment, which may include several components of the administrative tool framework  shown in . In particular, administrator  includes a remote interface  and a list of base types . In one embodiment, the list of base types  comprises a table having two columns: a first column for listing a type of object and a second column for referencing a specific serializer associated with the type. While other components within the administrative tool framework  may also be utilized to perform remote processing of cmdlets, the following discussion focuses on the interaction between the administrator  and the remote server  in order to process a remote cmdlet, such as \u201cRcmd machine:RemoteServer Get\/DB\u201d, and describes the operation of the other components, as needed, within this context. In addition, the following example illustrates remote processing of one cmdlet. However, the remote aspects work equally as well if there is a pipeline of cmdlets.","Remote server  includes a remote agent . The remote agent  is a component that responds to remote requests to execute one or more cmdlets. In addition, remote agent  is configured to take the results of the execution of the one or more cmdlets and create a return package  that is returned to the requesting entity (e.g., administrator ). In one implementation, the package takes the form of a serialized object that includes the results of execution, as well as meta information such as the date and time of invocation, identifying information about the particular remote system from which the results originated, and information about the requesting entity. This and perhaps other information is bound up into the return package  and transmitted back to the requesting entity (e.g., administrator ).","It is important to note, that the requesting entity may be one process  executing on a computing system and the remote server may be another process operating on the same computing system. In this configuration, the communication interface  includes system level application programming interfaces (API) for communicating between two processes, which are well known to those skilled in the art. In other embodiments, the communication interface  includes an internet or intranet network.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 8","b":["800","806","806","720","720"]},"For specifying the location, in one embodiment, a parameter specified along with the cmdlet identifies which location to execute the cmdlet. For example, the parameter \u201c-node\u201d along with a relevant node name may indicate execution of the cmdlet on a remote server associated with the node name. The parameter \u201c-workerprocess\u201d may indicate execution of the cmdlet in another process of the requesting entity. The parameter \u201c-appdomain\u201d may indicate execution of the cmdlet within another application domain of the same process. If execution is to occur within the same application domain or within another application domain within the same process, processing continues at block . Otherwise processing continues at block . While the processing of blocks - is not essential to the understanding of remote processing, understanding this processing will aid in understanding the concerns that were overcome in order to support remote processing of cmdlets.","At block , a file associated with the cmdlet is identified. The identification of the cmdlet and its associated file may be thru registration. As described above in conjunction with , the file contains the code for executing the cmdlet and also contains the properties and methods associated with the cmdlet class.","At block , the file is loaded into the process for the current application domain. As mentioned above, this blind loading of an executable file into the process on the requesting entity poses a security risk if the file is being loaded from some unknown, untrusted, remote server. As will be described in conjunction with blocks -, this security risk is overcome by utilizing the present method for transferring objects between remote boundaries.","At block , the cmdlet is executed. Execution includes instantiating the cmdlet class to create a cmdlet object. Populating the properties specified in the cmdlet object in the manner specified in the cmdlet class. Creating objects as defined in the code of the cmdlet class. If the incoming objects (such as objects from a previous cmdlet in a pipelined command) do not match the type specified in the current cmdlet class, the extended type manager may coerce the type as needed. Processing continues at block .","At block , the process may manipulate the created objects by accessing any of the properties and by invoking any of the methods. These created objects are referred to as \u201clive\u201d or \u201craw\u201d objects because the object's methods are available and can be invoked.","As one can imagine, the processing described in blocks - is less than ideal when the cmdlet is located on a remote computer. If the remote file was loaded into the local process for execution, there is a chance that the remote file could execute malicious code, which may compromise the security of the requesting entity. In addition, in an administrative tool environment, the requesting entity (e.g., administrator) is generally interested in obtaining administrative information regarding the remote computer. Thus, the objects populated by the cmdlet must contain status or other information pertinent about the remote server and not the requesting entity (e.g., administrator).","As explained in the background section, in a traditional web service environment, the client is responsible for knowing and trusting the remote server to whom it wishes to communicate. However, as explained above, this greatly restricts to whom the client may communicate because only objects that support a specific interface may communicate with the requesting entity. The present method for communicating objects between a requesting entity (e.g., administrator) and a remote server does not impose these limitations and is now described. For convenience, blocks which perform processing on the remote entity (e.g., remote server or separate process) are illustrated with a \u201cdotted\u201d background.","Returning to decision block , if the cmdlet is to be run in another process or on a remote server, processing continues at block . At block , the client establishes communication with a remote agent associated with the remote entity. The remote agent then performs blocks -, which performs the functioning described above for blocks -, but instead performs them with respect to the remote entity. However, once the cmdlet is executed and has obtained its associated objects, processing continues at block .","At block , the objects are serialized in a manner such that the security of the requesting entity (e.g., administrator) is not compromised. The serialization process creates a return package, such as return package  illustrated in . In overview, serializing the objects serializes information in a manner that can not be harmful to the requesting entity. An overview of the serialization process is illustrated in  and a more detailed description of the serialization process is described below in conjunction with . Processing continues at block .","At block , the serialized objects are transmitted to the client computer. The transmission of the serialized objects may be performed using convention methods known for network communication or may use known inter-process communication if the requesting entity and the remote server are on the same computer. Processing continues at block .","At block , the serialized objects are received at the requesting entity. The serialized object type is a type registered in the extended type manager. Thus, upon receipt, the extended type manager recognizes the serialized object type. Processing continues at block .","At block , the serialized object is de-serialized into sub-component objects. Briefly, the de-serialization process decomposes the serialized object into known base types. For any property that is not a base type, the de-serialization keeps the property as a property bag. An overview of the de-serialization process is illustrated in  and a more detailed description of the de-serialization process is described below in conjunction with . Processing continues at block .","At block , the de-serialized objects that were one of the base types may be manipulated as \u201craw\u201d objects, meaning that the methods and properties associated with the object are available. De-serialized objects that are not one of the base types may not be manipulated as \u201craw\u201d objects. These objects are referred to as \u201cdeserialized\u201d objects, which mean that the objects contain information about certain properties for the object, but their methods are not available.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":["FIG. 9","FIG. 8","FIG. 7","FIG. 13","FIG. 10"],"b":["900","902","904","904","902","712","722","712","722","906","906"]},"Upon receiving the request package, the requesting entity retrieves the serialized object  and performs a de-serialization process . In general, the de-serialization process  reconstructs the hierarchical tree . Because the hierarchical tree  is one of the object types recognized by the extended type manager, the extended type manager de-composes the hierarchical tree  into base objects and\/or property bag objects . The base objects are \u201clive\u201d (i.e., \u201craw\u201d) objects that have functionality (e.g., methods). The property bag objects  (i.e., \u201cde-serialized\u201d objects) provide relevant data, but do not include methods. Thus, as this overview illustrates, the object  originally created on the remote entity has been transferred to the requesting entity as a plurality of \u201craw\u201d base objects and other \u201cde-serialized\u201d objects without compromising the security of the requesting entity or requiring any special interface for the object . This de-serialization process  is described in more detail in conjunction with .",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 10","b":["900","900","900","900","900","900"]},{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003SQLInfo"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public int EmployeeNumber"]},{"entry":[{},"\u2003[Attribute(\u201cIdentification\u201d)]"]},{"entry":[{},"\u2003public string Name;"]},{"entry":[{},"\u2003public residence Address;"]},{"entry":[{},"\u2003public int SSN;"]},{"entry":[{},"\u2003public DateTime BirthDate;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 12","FIG. 9"],"b":["900","8"]},"Process  begins at block , where an object created by a remote cmdlet has been created. At block , a protocol negotiation process is performed in order to identify the level at which the requesting entity and the remote entity may communicate. Briefly, described in detail later in conjunction with , the level at which the entities communicate determines the amount of information that is transmitted to the requesting entity in order to transfer the object. As will be explained, the protocol negotiation process allows both the requesting entity and the remote entity to upgrade their system independent of each other while still allowing them to communicate with each other using different versions. In practice, this allows a requesting entity, which is operating with a version of base types that is several years newer than the version on the remote entity, the ability to still communicate with the remote entity. The converse is also true. Therefore, systems that have been shipped many years ago can be managed by newer administrator computers. The output of the negotiation process is a negotiated list that identifies each of the negotiated base types. Once the level of communication is determined, processing continues at block .","At block , a property bag is created for holding information about the object. In one embodiment, the property bag may be implemented as a hash table. The property bag is a core data type supported by the administrative tool environment. Processing continues at block .","At block , the type of object is identified by reflecting on the object. Once the type is identified, processing continues at decision block . At decision block , a determination is made whether the negotiated base types include the identified type of object. This determination may be implemented as a look-up within the negotiated list. For this implementation, the negotiated list would identify each of the negotiated base types. If the object is identified as one of the negotiated base types, processing continues at block .","At block , an entry is created in the property bag for the identified object. An exemplary implementation of a property bag will now be described.","Turning briefly to , a graphical depiction of a portion of an exemplary hierarchical tree (e.g., property bag tree) is illustrated. The portion depicts two levels within the hierarchical tree: the first level having property bag ; a second level having sub-property bag . Each property bag  and  includes a name field , a value field , and a type field . In addition, each property bag  and  may include an IsType field , a WasType field , and a TreatAs field . Property bag  includes entries - and sub-property bag  includes entries -.","Returning to , as mentioned above for block , an entry for the object is created in property bag  (e.g., entry ). Each field for the entry is then updated with information relating to the object. For example, the name for the object (e.g., \u201cEmployeeName\u201d) is entered in the name field . A value (e.g., 28731) for the property is entered in the value field . The type of the object (e.g., \u201cInt\u201d) is entered in the type field . In one embodiment, the name field may be a key for the hash table. Processing continues at block .","At block , the object is serialized. Direct serialization may occur via mechanisms provided by the underlying component framework, or by code that is specified for the base type, or the like. The serialization process for the object depends on its base type. Each base type has its own special serialization process. In one embodiment, the special serialization process is identified within the negotiated list. For this embodiment, the negotiated list includes a reference to a special serialization process for each of the negotiated base types in the list. In one embodiment, direct serialization converts the object into XML. However, direct serialization may convert the object into formats other than XML without departing from the appended claims. The result of the special serialization process is stored within the serialized object.","Returning to decision block , if it is determined that the object is not identified as one of the negotiated base types, processing continues at block . At block , a property bag type is entered in the type field . This property bag type then references a sub-property bag (e.g., sub-property bag ) created in block .","At block , a sub-property bag (e.g., sub-property bag ) is created. Thus, by creating additional levels of sub-property bags, a property bag tree is formed. The sub-property bag has the same fields as defined for the property bag. This sub-property bag may also have an entry for one or more sub-property bags creating another level in the hierarchical tree of property bags. Processing continues at block .","At block , the recursive nature of the serialization process is graphically depicted. The serialization process focuses on serializing each desired property within the object. Typically, the desired properties are properties that are designated as public. However, in some cases, hidden properties and other properties may be desired properties, and, are also serialized. Blocks - may be performed in various orders and in some cases one or more of the blocks (e.g., block ) may be optionally performed. Each of the blocks - is now further described.","At block , a type for the desired property is identified. This again occurs via reflection as explained above in reference to block .","At block , an entry into the current property bag (e.g., a sub-property bag) is added for the property.","At block , the fields in the entry associated with the desired property are set. The fields are set as explained above for block , but are set in the sub-property bag, rather than the property-bag. For example, the fields for entry  in sub-property bag , shown in , are updated with information associated with the property (object).","At block , if the desired property is one of the negotiated base types, the property is directly serialized as described above for block .","At block , if the desired property is not one of the negotiated base types, blocks  and  are performed in a recursive fashion.","Due to this recursive process, the hierarchical tree of property bags may become difficult to manage. Thus, it may be desirable to limit the serialization process . Embodiments for limiting the serialization process are represented within block , and may optionally be performed. There are several embodiments for culling the hierarchical tree. In one embodiment, a policy may be set that specifies a predetermined depth of the hierarchical tree. For example, if the predetermined depth is set at two, the recursive nature of the serialization process stops after creating one or more sub-property bags referenced from the property bag. The serialization process  does not proceed any further with decomposing the objects within the sub-property bags. Thus, these sub-property bags are serialized as a property bag and are included within the serialized object.","In another embodiment, prior to serialization, the remote agent runs the object through a \u201cpick\u201d process that strips out the properties that were not specified. An exemplary syntax is as follows: >Rcmd machine:RemoteServer Get\/DB | Pick Name, Birthdate. Then, during serialization, the specified properties (e.g., Name and Birthdate) become the desired properties and are serialized as described above. The pick process may be another cmdlet that is available on every system. One disadvantage of explicitly specifying the properties with the pick process is that the pick list must be specified each time and that the desired properties must be known in order to pick them.","In still another embodiment, block  may use a property set mechanism. The property set mechanism allows a name to be defined for a set of properties. An administrator may then specify the property set name, along with the cmdlet, in order to obtain the desired set of properties. The property set may be defined in various ways. In one way, a predetermined parameter, such as \u201c?\u201d, may be entered as an input parameter for a cmdlet. The operating environment upon recognizing the predefined parameter may list all the properties of the object. The list may be a GUI that allows an administrator to check (e.g., \u201cclick on\u201d) the desired properties and name the property set. The property set information is then stored in the extended metadata. For example, a property set may be named \u201cperformance\u201d. Each object would then identify which of its properties should be included in this performance property set. Therefore, the administrator does not need to know the name of the properties, but rather only needs to know the name of the desired property set. A property set named \u201cdefault\u201d may be defined that specifies the desired properties to serialize for an object. The administrator could then specify the default property when serialization is necessary.","Another way of limiting the property bag hierarchical tree is by only supporting certain types and forcing types derived from the certain types to conform to that type. In one implementation, the object hierarchy is \u201cwalked down\u201d by reflecting on each object to identify its parent. For certain objects, if it derived from a base type, the object will be forced to be its parent type. For example, a hash table object is an Idictionary object, which is an IEnumberable object, which derives from a base object. The serialization process may treat the hash table object as an IEnumberable object. In this way, the serialization process completely supports objects at certain levels within the object hierarchy, but forces objects of other types within the object hierarchy to conform to the chosen type. In practice, even though the original object type is not transferred, once the information is obtained at the receiving computer, the receiving computer can perform processing on it (such as creating a key) to obtain the original object, if needed.","Once the serialization process  is completed, the serialized object, along with other information, is combined to form the request package that is transmitted to the requesting entity.","The property bag and sub-property bags may have additional fields that are set during the serialization process, such as the IsType filed 1208, the WasType field , or the TreatAs field . These types are used during the de-serialization process . The IsType field  identifies a type for the object. However, when the object is serialized, the IsType field  for the object becomes \u201cNULL\u201d. The WasType field  identifies the type the property was before changing. From this information, the de-serialization process  can identify where the object originated, but can not know how many properties the object currently has. For example, if a property set or pick process was used when serializing the object, only specific properties were serialized, not all. The TreatAs field  identifies a type and guarantees that the properties associated with that type are available. For example, using the property set example above, one could define a new object type as \u201cSQLInfoPersonal\u201d. This new type guarantees that specified properties associated with the object are available, such as home address, home phone number, and the like. If sufficient properties are specified to include all the properties needed to qualify as a TreatAs, the serialization process  will enter the correct type under the TreatAs field .",{"@attributes":{"id":"p-0120","num":"0119"},"figref":["FIG. 11","FIG. 8"],"b":["1102","1104"]},"At block , a property bag object is created that will be populated with information contained within the transmitted data.","At block , a type property for the property bag object is set. The type property informs the extended type manager so that the extended type manager can handle the property bag as needed.","At block , each element identified within the transmitted data and associated with the property bag is processed. At block , an entry within the property bag is created. At block , the fields within the property bag are populated. Processing continues at decision block .","At decision block , a determination is made whether another property bag is defined within the transmitted data. If there is another property bag defined within the transmitted data, processing loops back through blocks - until the transmitted data does not contain any more property bags.","However, once there is no more property bags, processing continue at blocks -. Once the hierarchical tree of property bags has been created, each property bag is reviewed for further processing.","At block , if the type property for the property bag is one of the base types, the de-serialization process instantiates an object of the identified type (block ) and populates the properties of the object (block ).","At block , if the TreatAs attribute for the property bag specifies a type, an object of the specified type is instantiated (block ) and properties of the object are populated (). The type specified in the TreatAs attribute is one of the base types.","At block , for each remaining property bag that is not of a base type, each object identified within the property bag is instantiated (block ) and populated (block ).","Thus, as one can see, if the original object created at the remote computer is a base type, the transmitted data includes minimal information. This corresponds with a hierarchical tree with only one level. The transmitted data would include the name\/value pairs for the properties but would not contain any executable code. However, once the requesting computer received the transmitted data and recognized the type, an object of that type would be instantiated and would have the methods and functionality provided by the original object. In this manner, malicious code is not transmitted to and executed by the requesting computer. Instead, non-harmful information about the object is transmitted to the requesting computer.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":["FIG. 13","FIG. 9"]},"The protocol negotiation process  begins at block . At block , a client version number is received. The client version number identifies the most recent version of the list of base types that the client (e.g., requesting computer) may use. Processing continues at decision block .","At decision block , the client version number is compared with the remote version number to determine whether the remote version number is more recent. The remote version number identifies the most recent version of the list of base types that the remote server may use. If the remote version number is more recent, processing continues at block .","At block , the list of base types associated with the client version number is used for the serialization process. Thus, the client version becomes the negotiated list that is used during the serialization process.","On the other hand, if the remote version number is not as recent as the client version, processing continues at block . At block , the most recent list of base types available on the remote computer is used for the serialization process. Thus, the remote version becomes the negotiated list that is used during the serialization process.","In another embodiment of the negotiation process, the requesting computer may send the base types that it supports to the remote computer. The remote computer may then walk through the table and decide which types are supported by accepting or rejecting items in the table. The types that are accepted then form the negotiated list.","In another embodiment of the negotiation process, the requesting computer may send a set of references. The set of references may specify a file name. Thus, any type of object within the specified file name would be supported and be one of the negotiated base types.","Although details of specific implementations and embodiments are described above, such details are intended to satisfy statutory disclosure obligations rather than to limit the scope of the following claims. Thus, the system and method described above is defined by the claims is not limited to the specific features described above. Rather, the present system and method is claimed in any of its forms or modifications that fall within the proper scope of the appended claims, appropriately interpreted in accordance with the doctrine of equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 5","FIG. 2"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 7","FIG. 2"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 10","FIG. 8"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 11","FIG. 8"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 12","FIG. 10"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 13","FIG. 10"]}]},"DETDESC":[{},{}]}
