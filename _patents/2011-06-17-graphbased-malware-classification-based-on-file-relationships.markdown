---
title: Graph-based malware classification based on file relationships
abstract: A reliable automated malware classification approach with substantially low false positive rates is provided. Graph-based local and/or global file relationships are used to improve malware classification along with a feature selection algorithm. File relationships such as containing, creating, copying, downloading, modifying, etc. are used to assign malware probabilities and simultaneously reduce the false positive and false negative rates on executable files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08799190&OS=08799190&RS=08799190
owner: Microsoft Corporation
number: 08799190
owner_city: Redmond
owner_country: US
publication_date: 20110617
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Malware is a significant problem with effort being devoted towards automatic detection. Single instance files associated with malware have typically two sources: polymorphic and metamorphic malware which installs a unique instance of the attack on each new computer, and legitimate software which creates a unique file for each installation. It is impractical for human analysts to investigate each new file detected in the wild. Since malware authors rely on automation to avoid detection, commercial anti-malware companies need to rely on automation to detect new malware.","Machine learning and data mining technologies provide tools to improve automated malware detection. Typical approaches focus on classifying individual files in isolation and can be categorized as static analysis of binaries and dynamic analysis of program execution. Conventional algorithms range from computationally efficient methods to more complex static analysis algorithms that can be expensive in terms of processing time and processor power consumption. Further methods include using a file's reputation in relationship to the machines which report the file to improve classification. Attackers typically use automation to create new variants of malware which can by-pass anti-virus products. To combat this threat, some automated systems classify unknown files as malware. Some automated malware classification systems attempt to assign a probability that a file belongs to a specific family of malware. However, false positive rates may be unacceptably high for completely automated classification systems.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to exclusively identify key features or essential features of the claimed subject matter, nor is it intended as an aid in determining the scope of the claimed subject matter.","Embodiments are directed to a reliable automated malware classification approach with substantially low false positive rates. According to some embodiments, graph-based local and\/or global file relationships may be used to improve malware classification along with a feature selection algorithm. File relationships such as containing, creating, copying, downloading, modifying, etc. may be used to assign malware probabilities and simultaneously reduce the false positive and false negative rates on executable files.","These and other features and advantages will be apparent from a reading of the following detailed description and a review of the associated drawings. It is to be understood that both the foregoing general description and the following detailed description are explanatory and do not restrict aspects as claimed.","As briefly described above, automated malware classification may be enhanced with substantially low false positive rates using graph-based local and\/or global file relationships and a feature selection algorithm. File relationships such as containing, creating, copying, downloading, modifying, etc. may be used to assign malware probabilities and simultaneously reduce the false positive and false negative rates on executable files. While embodiments are discussed herein focusing on malware classification, the described principles may also be applied to any hierarchical representation of information that has dependency relations between entities. For example, a web page containing scripts and\/or i-frames, or an application (an executable) having (or depending on) multiple components may present suitable environments for the described algorithms. In the following detailed description, references are made to the accompanying drawings that form a part hereof, and in which are shown by way of illustrations specific embodiments or examples. These aspects may be combined, other aspects may be utilized, and structural changes may be made without departing from the spirit or scope of the present disclosure. The following detailed description is therefore not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims and their equivalents.","In the following detailed description, references are made to the accompanying drawings that form a part hereof, and in which are shown by way of illustrations specific embodiments or examples. These aspects may be combined, other aspects may be utilized, and structural changes may be made without departing from the spirit or scope of the present disclosure. The following detailed description is therefore not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims and their equivalents.","While the embodiments will be described in the general context of program modules that execute in conjunction with an application program that runs on an operating system on a computing device, those skilled in the art will recognize that aspects may also be implemented in combination with other program modules.","Generally, program modules include routines, programs, components, data structures, and other types of structures that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that embodiments may be practiced with other computer system configurations, including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and comparable computing devices. Embodiments may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","Embodiments may be implemented as a computer-implemented process (method), a computing system, or as an article of manufacture, such as a computer program product or computer readable media. The computer program product may be a computer storage medium readable by a computer system and encoding a computer program that comprises instructions for causing a computer or computing system to perform example process(es). The computer-readable storage medium is a non-transitory computer-readable memory device. The computer-readable storage medium can for example be implemented via one or more of a volatile computer memory, a non-volatile memory, a hard drive, a flash drive, a floppy disk, or a compact disk, and comparable media.","Throughout this specification, the term \u201cplatform\u201d may be a combination of software and hardware components for providing malware classification services. Examples of platforms include, but are not limited to, a hosted service executed over a plurality of servers, an application executed on a single computing device, and comparable systems. The term \u201cserver\u201d generally refers to a computing device executing one or more software programs typically in a networked environment. However, a server may also be implemented as a virtual server (software programs) executed on one or more computing devices viewed as a server on the network. More detail on these technologies and example operations is provided below.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","108","102","104","106","112","114","110","108","108","108","108"]},"Some of the received files may be associated with malware such as spyware, adware, ransomware, and similar ones that perform actions without the knowledge of a user and generally against the wishes of the user. Embodiments are directed to improving automated malware classification employing local graph of file relationships and\/or global graph of file relationships. The approaches simultaneously reduce false positive and false negative rates on executable files. File relationships such as containing, creating, dropping (copying), downloading, modifying, etc. or other files are propagated along a graph structure representing the files and their connections.","Prior to analyzing and updating graph-based malware classifications, a baseline malware classification probability may be assigned to one or more files in a system according to embodiments. The baseline malware classification may first compute a probability that a file belongs to one or more malware families. Because the number of malware changes constantly, new malware families are added to malware databases all the time. To address this constant change, a predefined number of malware families may be identified. If any of the files are determined to belong to malware families not contained in the list of predefined malware families, those files may be assigned to a generic malware family. Similarly, benign files may be assigned to a single class representing all benign files or to other classes representing individual benign programs (e.g. word processing programs, viewing programs, etc.).","For the baseline family-based malware classification system, system state variables, unpacked strings, Application Programming Interface (API) system call trigrams, and API system call plus an individual parameter value may be used as potential features to be ranked. A feature selection algorithm may attempt to choose a predefined number of best features per malware family benign program class and another number of best features for the generic malware and benign families. A ranked list of potential features for each family may be computed and the top K (a predefined threshold) best features selected for the family. These top K features are a mixture of different types of features depending on how well they discriminate the one family from all other malware and benign file classes (other malware families, generic malware family, benign program class and generic benign family).","To create the dataset to train the classifier, raw data may be converted from log files produced by an instrumented version of an anti-malware engine which runs an unknown file sample in a virtual machine into a feature vector, for example. Constructing a dataset from all of the raw data can result in millions of potential features and using all of the potential features may cause overfitting due to training a complex machine learning algorithm with an insufficient number of training examples. If the model is overly complex, the results when the system is deployed to production may differ significantly from those observed, when the system is trained and tested on a small labeled dataset. Thus, the number of features for the system may be selected to be the total number of samples divided by a sufficiently large number (e.g. 8-10).","For an example scenario considering the unpacked string feature, the training set may include a single example (e.g. file) containing the unpacked string \u201cXYZ\u201d, and the file may be associated with a malware family Rbot. A classification algorithm may then learn to predict that all files containing string \u201cXYZ\u201d are likely to be belong to the Rbot family. To choose the best subset of features from the large number of potential features, a feature selection algorithm based on 2\u00d72 contingency tables may be employed. A 2\u00d72 contingency table may be constructed for each potential feature for each class under consideration. The contingency table for the potential string feature \u201cXYZ\u201d has four elements: A, B, C, and D. A is the number of files which are not determined to be Rbot and do not include the string \u201cXYZ\u201d, while D is the number of files of type Rbot which do include the string \u201cXYZ\u201d. B and C are the number of files determined (not determined) to be of type Rbot which do not (do) include string \u201cXYZ\u201d, respectively. It should be noted that only two of the counts, C and D, need to be computed. Typically, a very small number of reports are likely to have a specific string. Thus, to estimate D and C, the number of files containing the string \u201cXYZ\u201d corresponding to Rbot and non-Rbot files, respectively, may be counted. A and B may be determined noting the A=NNR\u2212C and B=NR\u2212D, where NR and NNR are the numbers of Rbot and non-Rbot files, respectively. After the contingency table has been computed for each potential feature f, a score R(f) can be evaluated according to:\n\n()=Log \u0393(1)+Log \u0393(1)+Log \u0393(1)+Log \u0393(1)+Log \u0393(4)\u2212(Log \u0393(2)+Log \u0393(2)+Log \u0393(2)+Log \u0393(2)+Log \u0393(4)),\u2003\u2003[1]\n\nwhere Log \u0393(x) is the log of the Gamma function (\u0393) of quantity x.\n","The set of potential features can be ranked according to the scores for each class, and the top features selected, which best discriminate between each class (malware family, generic malware, benign program family, and generic benign). Alternative feature selection algorithms based on other metrics such as mutual information may also be employed.","Once the features for the baseline malware classification system are determined, one or more labeled datasets may be constructed based on logs extracted from an instrumented virtual machine. The logs for each individual file may be processed and any features corresponding to those selected by the feature selection system may be used to construct a training vector whose label is determined to be one of the predefined number of classes, the generic malware class, a specific benign program or the generic benign class. Then, the system may be trained using the labeled dataset employing multi-class logistic regression. Multi-class logistic regression computes N linear binary classifiers, where N is the total number of classes and a binary classifier is a simple linear hyperplane, which divides the high dimensional feature space into two sections. Other classifiers may also be used such as na\u00efve Bayes, support vector machine, neural network, boosted decision tree, other boosted algorithms, ensemble classifiers, hierarchical classifiers and\/or the like.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2","b":"200"},"In the example configuration of diagram , a file  being assessed may be at computing device . File  may have close (e.g. one hop or a few hops) relationships based on containment, copying, downloading, creation, or modification with other files  and  residing at the same computing device. In some scenarios, computing device  may be connected over network  to a data store  and\/or server , and utilize files that physically reside at data store  (e.g. files ) or server  (e.g. files ) such as a backend server. Thus, depending on hardware and software configurations, file relationships may be among files stored at the same computing device or on different computing devices.","The top portion of  illustrates an example for container classification using file relationships according to some embodiments. The bottom portion of  illustrates an example of improved file classification using file relationships. According to some example implementations, a container may be composed of three different types of files: files labeled as malware or some family of malware, files labeled as benign (or belonging to some known benign application), and unknown or unlabeled files.","Diagram  illustrates example files labeled as unknown (\u201cU\u201d) and benign (\u201cB\u201d). In the group of files  belonging to the same container, a probability that one or more files is malicious is first computed. The baseline file probability is not required to be computed for each file in the container. For malware files, which are known (i.e. labeled) to be malware, the file can be assigned a probability of being malware equal to 1.0. Alternatively, the file can be evaluated using a malware classifier. If any file in the container is labeled as malware, then the entire container may be labeled as malware and given a container probability  of 1.0 and also labeled as malware.","A file being labeled benign (or clean) may help provide some indication that the container is benign. Such a file can either be assigned a probability of 0.0 that it is malicious or evaluated using a malware classifier in order to assign the probability. Unknown files in the container may also be evaluated and assigned a probability of maliciousness. Then, a classifier may be executed on all of the unknown and benign files to compute a probability that the container is malicious. In the example of diagram , the estimated container probability (0.97) is higher than the individual malicious file probabilities (e.g. 0.92, 0.90, etc.). The probabilities shown in  are example values for illustration purposes only.","Diagram  illustrates an improved file classification method according to some embodiments. According to the example scenario, an unknown file  may be first assigned a probability of 0.7 that it is malicious by a classifier. In addition, the same file may be contained in five other containers , two which are labeled as malicious, two which are unknown, and one is labeled as benign. Unlike the container classifier, being included in a container labeled as malicious does not indicate that each file is malicious in a container according to embodiments. However, being included in a malicious container increases the likelihood that the unknown file is malicious. Similarly, being included in a benign container increases the likelihood that an unknown file is benign. The improved file classification (P_IMPROVED) is achieved based on the baseline malware probability (P_ORIGINAL) combined with the probabilities of the malware of each container which includes the file.","According to some embodiments employing local file relationships approach, malware probabilities are affected by files or containers, which are located in close proximity in the graph. For example, in diagram  and , the container and file probabilities are only affected by files and containers, respectively, located one hop away. In alternate local methods, file and container probabilities may be affected by files and containers in a small neighborhood such as two or three hops away. The distance between files may be predefined or adjusted by a user in determining the \u201clocality\u201d.","As discussed above, embodiments are directed to employing one or more local graph of file relationships and\/or global graph of file relationships in classification (for malware or other purposes). The first step in the local, graph-based malware classification is to propagate information from files to containers (archives). Doing so enables assignment of a score for each archive, which can later be used to refine the probability of the file. To train the classifier, labels for each container in the training set may be obtained first. To do so, the label \u201cMalware\u201d may be assigned to containers, which were either previously determined as malware by an analyst, contain one or more files labeled as malware by an analyst, or at least one file in the container is determined to be malware automatically (e.g. detected by an anti-virus engine). Similarly, benign archives may be defined as those previously determined as benign by an analyst or containing no files that were labeled as malware by an analyst or other automated system.","A number of methods may be used to assign a score to a container file indicating that it is malicious such as the above discussed biased logistic regression. Other methods for assigning a malicious score to a container include the maximum probability method, union bound method, logistic regression without a bias term, and comparable ones. For the maximum probability method, the maximum malware probability of all contained files may be assigned as the container probability. By way of example in , the malware probability for the container  would be assigned a value of 0.92 since this corresponds to the maximum malware probability of the individual files. For the union bound method, probabilities of being benign may be multiplied for all contained files.\n\n=\u03c0=\u03c0 (1\u2212).\u2003\u2003[2]\n\nAgain in , the probability that the container is benign is P=(1\u22120.9)*(1\u22120.76)*(1\u22120.0)*(1\u22120.84)*(1\u22120.92)*(1\u22120.64)=0.000002654208. The probability that this container is malicious using the union bound method is P=1\u2212P=0.999997345792. For the logistic regression method without a bias term, how to combine the probabilities may be learned in order to optimize how well the learned combination agrees with actual labels. In some embodiments, the most prevalent relationship in the database, containment, may be used. In other words, immediate neighbors of an executable which are the archives containing it may be employed. A cascaded two-step approach may be used, first using the baseline probabilities of the files to compute the probabilities of the container and then using the probabilities of the container labels to further improve file probabilities.\n","In a system according to embodiments, a malware analyst does not have to look at the whole graph to get a rough idea about the suspiciousness of a file; the local neighborhood provides most of the information. Furthermore, in order for a container to be suspicious it suffices that one of its contained files is malware. Conversely, a container may be considered as having a low level of suspiciousness only when all the contained files are not suspicious. Thus, a \u201ccontainer classifier\u201d for assigning a level of suspiciousness to each container may be employed. Since the determinations are binary (\u201cmalware container\u201d or \u201cbenign container\u201d), a logistic regression classifier may be employed with an additional offset motivated by the above observation:",{"@attributes":{"id":"p-0042","num":"0041"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"log","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mfrac":{"mrow":[{"msub":{"mi":["p","container"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["y","i"]},"mo":"=","mrow":{"mn":"1","mo":"|","mrow":{"mi":"N","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}}}},{"msub":{"mi":["p","container"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["y","i"]},"mo":"=","mrow":{"mn":"0","mo":"|","mrow":{"mi":"N","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}}}}]},"msup":{"mi":["v","T"]},"mrow":{"mi":"\u03a8","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"N","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}}},{"mi":"log","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mfrac":{"msub":{"mi":"p","mrow":{"mi":"b","mo":",","mrow":{"mi":["ma","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}},"mrow":{"mn":"1","mo":"-","msub":{"mi":"p","mrow":{"mi":"b","mo":",","mrow":{"mi":["m","ax"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}}}}],"mo":"+"}},{"mrow":{"mo":["[","]"],"mn":"3"}}]}}}},"br":{},"sub":["b,max ","container","i"]},"The above model is biasing its prediction of the suspiciousness of file i based on the most malicious file among i's neighbors, based on a container being malicious if at least one of the contained files is malicious. The assumption may be further adjusted by a linear combination of features computed from the neighborhood of i. The features may come from a simple histogram of the probabilities assigned to the container's contained files by the baseline malware classifier. More specifically, the interval [0; 1] may be split to 20 equally sized bins and create a histogram of the probabilities of the contained files. Then, the value of features \u03a82j and \u03a82j+1 are the fraction of contained files that fall in the j-th bin and the logarithm of the number of contained files (plus one) that fall in the j-th bin respectively. The features may be chosen to capture both absolute and relative numbers that may affect the decision. To limit manipulation from adversaries, the absolute numbers may be transformed by a logarithm so that large manipulations of the raw numbers cause only moderate manipulations of the features (as shown in expression [3]).","It should be noted that the form of the biasing term is not chosen arbitrarily. The baseline malware classifier itself may be based on logistic regression and the form of the bias may be the inverse of the logistic link function. Hence, the biasing term may be",{"@attributes":{"id":"p-0045","num":"0044"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msubsup":{"mi":["w","b","T"]},"mo":"\u2062","msub":{"mi":"\u03a6","mrow":{"mi":["m","ax"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}}},"br":{},"sub":["b ","max "],"sup":["T","T"]},"The vector, v, which represents the optimal way of combining the features to correct the prior assumption captured by the maximum probability of the file's neighbors, is estimated using the principle of maximum likelihood. For that, just a set of containers are needed, some determined as \u201cmalware\u201d and some determined as \u201cbenign\u201d, together with their neighbors. The neighbors may be used to compute the features and the maximum probability for each container. Then, a search may be performed for the v that maximizes the likelihood function. This optimization can be carried out exactly and efficiently because the (negative logarithm of the) likelihood is a convex function. This approach may be computed extremely fast to make a prediction for a new container. The system only needs to look at the contained files, retrieve their probabilities from the database (if a file has not been seen before its probability may be obtained from the baseline malware classifier), compute a predefined number of (e.g., 40) features from a simple histogram (e.g., 20 bins and two features from each bin), and take a linear combination with the learned vector v. Additional features may include the log of the number of files (or the number of files) in the container and a feature which multiplies the log of the number of files (or the number of files) in the container and the log(p\/(1\u2212P)). The last feature is used to learn the interaction between the number of features and the maximum file probability in the container.","An algorithm according to some embodiments does not classify the containers themselves, but improves upon a system that classifies executable files individually. In this sense, the probabilities obtained from a container classifier are just auxiliary information that summarizes the neighborhood of a file (how suspicious are the containers in which this file is found). Therefore, a second step may be introduced where information is aggregated across the containers, in which a given file participates. The final \u201crelationship-based\u201d classifier computes the same types of features and introduces a biasing term. The assumption reflected in the biasing term is that the baseline classifier is doing well most of the time and the neighborhood information is only used to learn a correction. The log odds of file i being malware (y=1) may be modeled as:",{"@attributes":{"id":"p-0048","num":"0047"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mrow":[{"mi":"log","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mfrac":{"mrow":[{"msub":{"mi":["p","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["y","i"]},"mo":"=","mrow":{"mn":"1","mo":"|","mrow":{"mi":"N","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}}}},{"msub":{"mi":["p","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["y","i"]},"mo":"=","mrow":{"mn":"0","mo":"|","mrow":{"mi":"N","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}}}}]}},{"mrow":[{"msup":{"mi":["u","T"]},"mo":"\u2062","mrow":{"mi":"\u03a8","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"N","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}}},{"mi":"log","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mfrac":{"mrow":[{"msub":{"mi":["p","b"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["y","i"]},"mo":"=","mrow":{"mn":"1","mo":"|","msub":{"mi":["x","i"]}}}}},{"msub":{"mi":["p","b"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["y","i"]},"mo":"=","mrow":{"mn":"0","mo":"|","msub":{"mi":["x","i"]}}}}}]}}],"mo":"+"}],"mo":"="},"mo":","}},{"mrow":{"mo":["[","]"],"mn":"4"}}]}}}},"br":{},"sub":["r ","b "]},"According to some embodiments, an example algorithm for improving file probabilities for the local graph method may be as follows:",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Let C be the set of labeled containers"]},{"entry":[{},"Let S= {\u03a8(N(i)); p; y) | i \u2208 C}, where"]},{"entry":[{},"\u2003\u2003N(i) is the set of executables in a container i,"]},{"entry":[{},"\u2003\u2003\u03a8( ) is computed from p(y= 1 | x),"]},{"entry":[{},"\u2003\u2003p= maxp(y= 1 | x)."]},{"entry":[{},"Find the vector v* that maximizes"]},{"entry":[{},"L(v) = \u03a0g(t(v))(1\u2212 g(t(v))), where"]},{"entry":[{},"\u2003\u2003t(v) = v\u03a8(N(i)) + log(p\/(1\u2212p))."]},{"entry":[{},"For each container i"]},{"entry":[{},"\u2003\u2003p(y= 1| x) = g(v*\u03a8(N(i)) + log(p\/(1\u2212p))."]},{"entry":[{},"Let F be the set of labeled files."]},{"entry":[{},"Let S= {\u03a8(N(i)); p(y= 1| x), y| i \u2208 F}, where"]},{"entry":[{},"\u2003\u2003N(i) is the set of containers containing i and"]},{"entry":[{},"\u2003\u2003\u03a8( ) is computed from p(y= 1 | x)."]},{"entry":[{},"Find the vector u* that maximizes"]},{"entry":[{},"L(v) = \u03a0g(r(u))(1\u2212 g(r(u))), where"]},{"entry":[{},"\u2003\u2003r(u) = u\u03a8(N(i)) + log(p(y=1|x) \/ (1\u2212 p(y=1|x)))."]},{"entry":[{},"For each file i"]},{"entry":[{},"\u2003\u2003p(y= 1) = g(u*\u03a8(N(i)) + log(p(y=1|x) \/ (1\u2212 p(y=1|x)))."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In the example algorithm, pis the probability according to the relationship based classifier, pis the probability according to the baseline classifier, \u03a8 is a vector of features computed from the neighborhood of the file and u is a vector of parameters for adjusting so that the features are optimally combined according to the maximum likelihood principle. The logistic link function g may be defined as",{"@attributes":{"id":"p-0052","num":"0051"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mfrac":{"msup":{"mi":["e","t"]},"mrow":{"mn":"1","mo":"+","msup":{"mi":["e","t"]}}},"mo":"."}],"mo":"="}}},"br":{}},"In the local graph-based approach, only local file relationships are employed to improve a file's overall classification score. In other words, the computations are performed based on nodes, which are at one-hop (or a few hops) away from the node under consideration. In the global graph-based approach, each individual node (file) may be affected by all other nodes in the graph. An algorithm based on a conditional random field may be employed in this approach.","For the random field formulation model, all files may be modeled as vertices (potentially millions of files) with K types of edges (relationships) among files (contains, downloads, creates, modifies, etc.). Features of files, x, may be labeled by analysts with labels y. Each relationship type may have a different strength \u03c3. Strongly related files have similar probabilities. In the random field model, the inference problem becomes: given \u03b8 and \u03c3, M(i) being the set of neighbors of i according to the relationship of type k, \u03c3being the standard deviations for relationships of type k, and \u03b8 being a vector of weights that together with the features xcan explain zand (hence) y, and \u03c3being the standard deviations for the difference between zand \u03b8x, find\n\n{circumflex over ()}=argmax\u03c0 ().\u2003\u2003[5]\n","With zdefined as the latent log-odds of i-th file, the probability may be defined as:",{"@attributes":{"id":"p-0056","num":"0055"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["y","i"]},"mo":"=","mrow":{"mn":"1","mo":"|","msub":{"mi":["z","i"]}}}}},{"mfrac":{"mn":"1","mrow":{"mn":"1","mo":"+","msup":{"mi":"\u2147","mrow":{"mo":"-","msub":{"mi":["z","i"]}}}}},"mo":"."}],"mo":"="}},{"mrow":{"mo":["[","]"],"mn":"6"}}]}}}},"br":{}},{"@attributes":{"id":"p-0057","num":"0056"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mover":{"mi":"z","mo":"^"},"mo":"=","mrow":{"mi":"argmax","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"n"},"mo":"\u2062","mrow":{"mo":"(","mrow":{"mrow":[{"mrow":{"mo":"-","mfrac":{"mn":"1","mrow":{"mn":"2","mo":"\u2062","msubsup":{"mi":"\u03c3","mn":["0","2"]}}}},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["z","i"]},"mo":"-","mrow":{"msup":{"mi":["\u03b8","T"]},"mo":"\u2062","msub":{"mi":["x","i"]}}}},"mn":"2"}},{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"K"},"mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mrow":{"mi":"j","mo":"\u2208","msub":{"mi":["M","k"]}}},"mo":"\u2062","mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mo":"-","mfrac":{"mn":"1","mrow":{"mn":"2","mo":"\u2062","msubsup":{"mi":"\u03c3","mn":["0","2"]}}}},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["z","i"]},{"mi":["z","j"]}],"mo":"-"}},"mn":"2"}}},"mo":"."}}}],"mo":"+"}}}}}},{"mrow":{"mo":["[","]"],"mn":"7"}}]}}}}},"[8] may be rewritten in more compact form as:",{"@attributes":{"id":"p-0059","num":"0058"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mover":{"mi":"z","mo":"^"},"mo":"=","mrow":{"mi":"argmax","mo":["-","+"],"mrow":[{"mfrac":{"mn":"1","mrow":{"mn":"2","mo":"\u2062","msubsup":{"mi":"\u03c3","mn":["0","2"]}}},"mo":"\u2062","msup":{"mrow":{"mo":["\uf605","\uf606"],"mrow":{"msub":{"mi":["Z","i"]},"mo":"-","mrow":{"mi":["X","\u03b8"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}},"mn":"2"}},{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"K"},"mo":"\u2062","mrow":{"mfrac":{"mn":"1","mrow":{"mn":"2","mo":"\u2062","msubsup":{"mi":["\u03c3","k"],"mn":"2"}}},"mo":"\u2062","msup":{"mrow":{"mo":["\uf605","\uf606"],"mrow":{"msub":{"mi":["A","k"]},"mo":"\u2062","mi":"z"}},"mn":"2"}}}]}},"mo":","}},{"mrow":{"mo":["[","]"],"mn":"8"}}]}}}},"br":{},"sub":"k "},{"@attributes":{"id":"p-0060","num":"0059"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mrow":[{"mrow":{"mo":["(",")"],"mrow":{"mi":"I","mo":"+","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"nK"},"mo":"\u2062","mrow":{"msub":[{"mi":["a","k"]},{"mi":["L","k"]}],"mo":"\u2062"}}}},"mo":"\u2062","mi":"z"},{"mi":["X","\u03b8"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}],"mo":"="},"mo":","}},{"mrow":{"mo":["[","]"],"mn":"9"}}]}}}},"br":{},"sup":"T","sub":["k","k ","k ","k "]},{"@attributes":{"id":"p-0061","num":"0060"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["a","k"]},"mo":"=","mrow":{"mfrac":{"msubsup":[{"mi":"\u03c3","mn":["0","2"]},{"mi":["\u03c3","k"],"mn":"2"}]},"mo":"."}}}},"br":{}},"For systems with files exceeding 10,000, sparse and conjugate matrices may be used for gradient. One example is symmetric positive definite (SPD), another example is diagonally dominant. In most systems, the first few iterations may contribute most to the computation. The global malware identifier may be further improved by using a preconditioner or parallelization and performing inference in groups of files (e.g. one million files).","The principles discussed above in conjunction with malware classification apply to any hierarchical representation of information that has dependency relations between entities. Thus, embodiments are not limited to malware classification. Furthermore, the methods described herein may be used to build up reputation data (or correlate\/enhance reputation data).",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 4","b":"400"},"Unlike the local approaches, each file or container in the graph may affect every other file or container to a degree. Each file or container is represented in the graph with a node labeled as malicious (\u201cM\u201d) (), benign (\u201cB\u201d) (), or unknown (\u201cU\u201d) (). Each file or container may be assigned a probability that it is malicious indicated by the square labeled P (). The baseline file probability P () is not required to be computed for each file in the graph. An improved file probability can be estimated (inferred) based on the baseline probability P () plus the graph relationships. Alternatively, the probability that the file is malicious can be estimated based solely on the graph relationships and the malware probabilities, either baseline or improved, of other files in the global graph. As described above, malicious files or containers labeled by analysts or other automated systems such as an anti-virus product as malware can be assigned a probability of 1.0. Similarly, each file or container labeled as benign by analysts or inclusion in a whitelist of software that is known to be legitimate may be assigned a probability of 0.0. Alternatively, the files labeled as malicious and benign can be assigned a probability or score (as discussed previously) from the classifier. The unknown files and containers may each be assigned a probability that they are malicious by a baseline file classifier. In the global malware classification approach, the underlying malware probabilities may be inferred from the global model. That is, an improved estimate of the underlying probability that the file is malicious may be inferred based on the underlying probability. The global model parameters may first be learned to allow the malware probabilities to be inferred from the model. The parameters may be learned using various methods such as solving a set of linear equations, linear programming (LP) based approximation, belief propagation, message passing, graph cut algorithms, and similar approaches.","The example systems and scenarios in  are shown with specific components, exchanges, and configurations. Embodiments are not limited to systems according to these example configurations. Graph-based classification based on file relationships may be implemented in configurations employing fewer or additional components in applications and user interfaces.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 5","b":["514","516","513","512","511","510"]},"As discussed above, a reliable automated malware classification approach with substantially low false positive rates may utilize graph-based local and\/or global file relationships to improve malware classification along with a feature selection algorithm. File relationships such as containing, creating, copying, downloading, modifying, etc. may be used to assign malware probabilities and simultaneously reduce the false positive and false negative rates on executable files. The server(s) may retrieve or store relevant data from\/to data store(s)  directly or through database server .","Network(s)  may comprise any topology of servers, clients, Internet service providers, and communication media. A system according to embodiments may have a static or dynamic topology. Network(s)  may include secure networks such as an enterprise network, an unsecure network such as a wireless open network, or the Internet. Network(s)  may also coordinate communication over other networks such as Public Switched Telephone Network (PSTN) or cellular networks. Furthermore, network(s)  may include short range wireless networks such as Bluetooth or similar ones. Network(s)  provide communication between the nodes described herein. By way of example, and not limitation, network(s)  may include wireless media such as acoustic, RF, infrared and other wireless media.","Many other configurations of computing devices, applications, data sources, and data distribution systems may be employed to provide improved malware classification using graph-based file relationships. Furthermore, the networked environments discussed in  are for illustration purposes only. Embodiments are not limited to the example applications, modules, or processes.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 6","FIG. 6"],"b":["600","600","602","604","600","604","604","605","604","606","622","624"]},"In addition to detecting potential malware files, malware detection application  may also provide other services such as file clean up, analysis, and comparable ones. Classification module  may be an integrated part of malware detection application  or a separate application and enhance categorization of files using local and\/or global file relationships. As discussed earlier, embodiments are not limited to malware classification. The tasks performed by classification module  may also be used to perform classification in any hierarchical representation of information that has dependency relations between entities. This basic configuration is illustrated in  by those components within dashed line .","Computing device  may have additional features or functionality. For example, the computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer readable storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. Computer readable storage media is a non-transitory computer readable memory device. System memory , removable storage  and non-removable storage  are all examples of computer readable storage media. Computer readable storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer readable storage media may be part of computing device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, and comparable input devices. Output device(s)  such as a display, speakers, printer, and other types of output devices may also be included. These devices are well known in the art and need not be discussed at length here.","Computing device  may also contain communication connections  that allow the device to communicate with other devices , such as over a wireless network in a distributed computing environment, a satellite link, a cellular link, and comparable mechanisms. Other devices  may include computer device(s) that execute communication applications, storage servers, and comparable devices. Communication connection(s)  is one example of communication media. Communication media can include therein computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media.","Example embodiments also include methods. These methods can be implemented in any number of ways, including the structures described in this document. One such way is by machine operations, of devices of the type described in this document.","Another optional way is for one or more of the individual operations of the methods to be performed in conjunction with one or more human operators performing some. These human operators need not be co-located with each other, but each can be only with a machine that performs a portion of the program.","The methods described in  through  discuss files and containers. However, individual files can also create or drop new files, which is analogous to the notion of file containment. It should be noted that in each example below, a containment relationship can also represent relationships where a file creates or drops additional files or containers.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 7"},"Process  may be employed for improving individual file probabilities when receiving an unknown container () based on the local approach. At operation , each file in the container may be extracted from the container file and the relationships determined. The relationships may be determined by analyzing whether each file is a container, creates new files, or drops (copies) new files. Assuming the container only includes files (i.e. each file in the container does not further drop or create any new files), the existing graph structure  may be updated based on the new container and files at operation . For example, if one or more files are contained in other containers, then these new file relationships may be added to the existing graph. Similarly, if the container is included in other containers, then these relationships may also be used to update the existing graph.","At operation , the baseline file probability of each individual file in the container may be computed for files, which have not been previously estimated. Based on these individual file probabilities, the container probability may be updated at operation . Next, the probabilities of all individual files in the container may be improved based on the baseline file probabilities and the probabilities of all containers which include the file at operation . Optionally, the container probabilities may be further improved based on the improved file probabilities and so on.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 8"},"Process  may be employed for improving individual file probabilities when receiving an unknown file  based on the local approach. At operation , the unknown file is evaluated to determine if it creates or drops any unknown files (i.e. file relationships). This may be followed by operation , where the baseline file probability of each individual unknown file and the created or dropped files may be computed. The existing graph structure  may be updated based on the new unknown files and the created or dropped files at operation . For example, if one or more files are contained in other containers or are created or dropped by other files, then these new file relationships may be added to the existing graph. Similarly, if an unknown file is included in other containers, then these relationships may also be used to update the existing graph. Based on these individual, baseline file probabilities, the unknown file probability may be updated (improved) at optional operation . At operation , the probabilities of all individual files created or dropped by the unknown file may be updated based on the baseline file probabilities. Optionally, the probabilities of the unknown files  may be further improved based on the improved probabilities of the dropped and created files  and so on.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 9"},"Process  may be employed for improving the individual file and container probabilities when receiving an unknown container  based on the global approach. Each file in the container may be extracted from the container file at operation , followed by further processing of each file in the container to determine if it is a container, creates new files, or drops new files. The existing graph structure  may be updated based on the new file and container relationships at operation . For example, if one or more files are contained in other containers, then these new file relationships may be added to the existing graph. Similarly, if the container is included in other containers, then these relationships may also be used to update the existing graph. If one of the files drops additional files, then these relationships may be added to the existing graph.","At operation , the baseline file probability of each individual file in the container which has not been previously estimated may be computed. Based on these individual file probabilities, the container probability may be updated at optional operation . Alternatively, the global model may be used to infer the container probability at operation . At operation , the improved file probability may be inferred using each file's baseline probability and the global graph model parameters (not shown). As mentioned above, the probability of the container may be inferred or the baseline probability of the container may be improved based on the baseline file probabilities and global graph model parameters (not shown) at . Optionally, the global model parameters may be updated based on the inferred file or container probabilities at operation . Updating may include learning the parameters using various methods such as solving a set of linear equations, linear programming (LP) based approximation, belief propagation, message passing, graph cut algorithms, and similar approaches. The process of inferring the probabilities and updating global model coefficients may continue in an iterative manner until the performance change from iteration to iteration is less than a predefined tolerance as indicated by the loop between operations  and .",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 10"},"Process  may be employed for improving the individual file and container probabilities when receiving an unknown file  based on the global method similar to that described in . The unknown file  may be processed at operation . If the unknown file creates any files or drops any new files, these relationships may be noted. Each file created or dropped by the unknown file may be further processed to determine if it is a container, it creates new files, or it drops new files. The existing graph structure  may be updated based on all new file relationships at operation . For example, if the unknown file  drops or creates additional files, these relationships are added to the existing graph. If one of the dropped or created files drops additional files, then these relationships may be added to the existing graph. In another example, if one or more dropped or created files are containers, then these new file relationships induced by the container may be added to the existing graph. Similarly, if the unknown file is included in other containers, then these relationships may also be used to update the existing graph.","At operation , the baseline file probability of each individual file which has not been previously estimated may be computed. The improved file probability of all new files may be inferred at operation  using each file's baseline probability and the global graph model parameters (not shown). Optionally, the global model parameters may be updated at operation  based on the inferred file probabilities and the current global model parameters. Updating may include learning the parameters using various methods such as solving a set of linear equations, linear programming (LP) based approximation, belief propagation, message passing, graph cut algorithms, and similar approaches. The process of inferring the probabilities and updating global model coefficients may continue in an iterative manner until the performance change from iteration to iteration is less than a predefined tolerance as indicated by the loop between operations  and .",{"@attributes":{"id":"p-0089","num":"0088"},"figref":["FIG. 11","FIG. 9","FIG. 10"]},"Process  describes a periodic update approach for global model parameters. One or more (i.e. a batch) newly received files and containers may be labeled by analysts or other automated methods such as being detected by an anti-malware scanner at operation . Benign files and containers may be automatically labeled by trusted software developers submitting legitimate software to a backend service. The new labeled files and containers may then be processed to extract file relationships induced by these items at operation .","The existing relationship graph  may be updated to include these new relationships at operation . The global model parameters may be retrained using the updated graph relationships at operation . At this point the model learning process can halt and be applied to inference described in  and . Optionally, the model learning process may continue in an interactive process by inferring the file and container probabilities at operation  followed by additional rounds of learning and inference until the training performance decreases to a predefined tolerance as indicated by the loop between operation  and decision operation .","Some embodiments may be implemented in a computing device that includes a communication module, a memory, and a processor, where the processor executes a method as described above or comparable ones in conjunction with instructions stored in the memory. Other embodiments may be implemented as a computer readable storage medium with instructions stored thereon for executing a method as described above or similar ones.","The operations included in processes  through  are for illustration purposes. Graph-based classification based on file relationships may be implemented by similar processes with fewer or additional steps, as well as in different order of operations using the principles described herein.","The above specification, examples and data provide a complete description of the manufacture and use of the composition of the embodiments. Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims and embodiments."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
