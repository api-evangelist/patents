---
title: System and method for isolating applications from each other
abstract: The present disclosure relates to a system and method for isolating applications from each other. In one arrangement, the system and method pertain to intercepting application instructions, determining if an application instruction calls for an illegal action, and preventing the illegal action from occurring if the application instruction calls for the illegal action. In some arrangements, the system and method further pertain to determining if the application instruction contains an indirect memory reference and, if so, modifying the application instruction to enable the application instruction to determine itself whether an illegal operation is to be performed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07051340&OS=07051340&RS=07051340
owner: Hewlett-Packard Development Company, L.P.
number: 07051340
owner_city: Houston
owner_country: US
publication_date: 20020419
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application claims the benefit of the filing date of U.S. Provisional Patent Application No. 60\/334,266, filed Nov. 29, 2001, which is hereby incorporated by reference into the present disclosure.","This disclosure generally relates to dynamic transformation of executing binary code. More particularly, the disclosure relates to a system and method for isolating applications from each other in multiprogrammed environments using dynamic code checking.","In multiprogrammed environments, multiple persons may share a given computer system and even use the system at the same time. For example, such an arrangement is common in large time-sharing systems. Generally speaking, multiprogrammed environments create the impression that the user has sole control over the system.","In order to permit multiple users to access a single computer system, the various users (and their applications) are assigned various separate resources within the system. For instance, various memory addresses are assigned to one user application and various other memory addresses are assigned to another to avoid overlap. This is known in the art as sandboxing. Such separation is used to avoid interference between applications that can cause undesired effects to occur.","Interference can be intentional or unintentional. An example of intentional interference is using a first application on a multiprogrammed system to copy data from another application on the system to access confidential information. An example of unintentional interference is accidental sharing of a virus of one application with another executing on the multiprogrammed system. Clearly, such interference is undesirable whether it is intentional or unintentional.","Substantially all multiprogrammed systems rely upon software and\/or hardware solutions that prevent applications from accessing memory addresses that are out of the permissible range. The software solutions typically at least statically review the instructions of a particular application when it is loaded to determine whether any of the instructions contain a direct memory reference to an out-of-range memory address. Although such an examination can be completed with relative ease, it is difficult for software solutions to identify less conspicuous references. For example, the address of an indirect memory reference may not be determinable until the moment immediately prior to execution of a given instruction. Although software solutions can be written to check each instruction just prior to execution to determine whether the memory address is out-of-range, this normally involves a great deal of overhead in that the application typically must be interrupted and a second application may need to be swapped into memory.","Although the overhead associated with checking each instruction prior to execution is not a concern with hardware designed for this purpose, it is very difficult to build a hardware solution that is capable of checking for every potential interference problem that may arise. Moreover, the time and cost associated with developing hardware solutions for each available computer system is prohibitive.","From the foregoing, it can be appreciated that it would be desirable to have a system and method for isolating applications from each other that avoids one or more of the drawbacks identified above.","The present disclosure relates to a system and method for isolating applications from each other. In one arrangement, the system and method pertain to intercepting application instructions, determining if an application instruction calls for an illegal action, and preventing the illegal action from occurring if the application instruction calls for the illegal action.","In some arrangements, the system and method further pertain to determining if the application instruction contains an indirect memory reference if the application instruction is not determined to call for an illegal action and, if so, modifying the application instruction to enable the application instruction to determine itself whether an illegal operation is to be performed.","Disclosed is a system and method for isolating applications executing on a multiprogrammed system from each other so as to avoid interference between the applications. Generally speaking, the disclosed system and method can be used to gain control over execution of an application such that, where necessary, the application code can be manipulated such that illegal operations can be prevented before they occur without significant overhead. As is discussed below, this can be accomplished by dynamically modifying the application code with a dynamic execution layer interface such that the application can self-check during execution. With such a mode of operation, potentially illegal operations can be detected without having to interrupt execution.","To facilitate description of the inventive system and method, example systems are discussed with reference to the figures. Although these systems are described in detail, it will be appreciated that they are provided for purposes of illustration only and that various modifications are feasible without departing from the inventive concept. Other example systems are described in U.S. patent application Ser. No. 09\/924,260, filed Aug. 8, 2001, entitled \u201cDynamic Execution Layer Interface for Explicitly or Transparently Executing Application or System Binaries,\u201d which is hereby incorporated by reference into the present disclosure. After the description of the example systems, an example of operation of the systems is provided to explain the manners in which application isolation can be facilitated.","Referring now to , illustrated is an example dynamic execution layer interface (DELI)  that, as identified above, can be used to facilitate application isolation. Generally speaking, the DELI  comprises a generic software layer written in a high or low level language that resides between applications, including or not including an operating system (O\/S), and hardware to untie application binary code from the hardware. Through this arrangement, the DELI  can provide dynamic computer program code transformation, caching, and linking services which can be used in a wide variety of different applications. As is discussed in greater detail below, the DELI  can provide its services while operating in a transparent mode, a nontransparent mode, or combinations of the two. In the transparent mode, the DELI  automatically takes control of an executing application in a manner in which the executing application is unaware that it is not executing directly on computer hardware. In the nontransparent mode, the DELI  exports its services through an application programming interface (API) to the application to allow the application to control how the DELI  reacts to certain system events.","In , the DELI  is shown residing between at least one application  and computer hardware . Depending upon the particular arrangement, the application  can comprise one or more user applications that are unaware of the DELI's presence and\/or a client that is aware of the DELI  and which is configured to utilize the DELI's services. More generally, however, the application  comprises any type of program code containing instructions to be executed by a computer processor. Where an O\/S is used, the DELI  may reside either above or below the O\/S (not indicated) depending upon the nature of the services that are provided. For example, when the DELI  operates above the O\/S, it can only control execution of applications. If the DELI  operates below the O\/S, however, the DELI has access to an instruction stream which can include a mix of system and user code both from the O\/S and applications. The hardware  can comprise various different computer system components but typically at least comprises a computer processor.","The DELI  can include four main components including a core , an application programming interface (API) , a transparent mode layer , and a system control and configuration layer . Generally speaking, the core  exports two main services to both the API  and the transparent mode layer . The first of these services pertains to the caching and linking of native code fragments or code fragments which correspond to the instruction set of the hardware . The second pertains to executing previously cached code fragments. The API , where provided, exports functions to the application  that provide access to the caching and linking services of the core  in the nontransparent mode of operation. The transparent mode layer  enables the core  to gain control transparently over code execution in the transparent mode of operation as well as fetch code fragments to be cached. Finally, the system control and configuration layer  enables configuration of the DELI  by providing policies for operation of the core  including, for example, policies for the caching, linking, and optimizing of code. These policies can, for example, be provided to the layer  from the application  via the API . The system control and configuration layer  also controls whether the transparent mode of the DELI  is enabled, thus determining whether the core  receives input from the API , the transparent mode layer , or both.","As is further indicated in , the system  can include a bypass path  that can be used by the application  to bypass the DELI  so that the application can execute directly on the hardware , where desired. It is noted that such operation can be possible in that the DELI  is an optional execution layer which may or may not be utilized.","As is shown in , the core  comprises a core controller , a cache manager , a fragment manager , and an optimization manager . The core controller  functions as a dispatcher that assigns tasks to the other components of the core  that are responsible for completing the tasks. The cache manager  comprises a mechanism (e.g., set of algorithms) that controls the caching of the code fragments within one or more code caches  (e.g., caches  through n) according to the policies specified by the system control and configuration layer  as well as the fragment manager  and the optimization manager . The one or more code caches  of the core  can, for instance, be located in specialized memory devices of the hardware , or can be created in the main local memory of the hardware. Where the code cache(s)  is\/are mapped in specialized memory devices, greatly increased performance can be obtained due to reduced instruction cache refill overhead, increased memory bandwidth, etc. The fragment manager  specifies the arrangement of the code fragments within the code cache(s)  and the type of transformation that is imposed upon the fragments. Finally the optimization manager  contains the set of optimizations that can be applied to the code fragments to optimize their execution.","As noted above, the API , where provided, exports functions to the application  that provide access to DELI services. More specifically, the API  exports caching and linking services of the core  to the application , which typically comprises a client that is aware of the DELI's presence. These services exported by the API  enable the application  to control the operation of the DELI  in the nontransparent mode by (i) explicitly emitting code fragments to the core  for caching and\/or by (ii) instructing the DELI  to execute specific code fragments out of its code cache(s) . In addition, the API  also can export functions that initialize and discontinue operation of the DELI . For instance, the API  can initiate transparent operation of the DELI  and further indicate when the DELI is to cease such operation. The API  also, as mentioned above, facilitates configuration of the DELI  by delivering policies specified by the application  to the core  (e.g., to the fragment manager  and\/or the optimization manager ).","With further reference to , the transparent mode layer  typically includes an injector  which is used to gain control over a running application  transparently. When the DELI  operates in a completely transparent mode (i.e., where the application is unaware of the DELI's presence) the injector  is used to inject the DELI into the application  before the application begins execution so that the application can be run under DELI control. In such circumstances, the DELI  avoids modifying the application's  executable image to avoid impeding exception handling. Control can be gained by the injector  in several different ways, each of which loads the application binaries without changing the virtual address at which the binaries are loaded. By way of example, the O\/S kernel loader can be modified such that the DELI  (e.g., compiled as a shared library) is automatically loaded by the kernel loader when it loads the application's executable image. Alternatively, a user level loader can be used to leverage the kernel loader without modifying it to load the application  in memory in suspended mode and later inject instructions into the application (e.g., on the application stack) that will load the DELI  shared library later when the application is resumed.","In another alternative, ptrace can be used to attach the DELI  to the application . As is known in the art, ptrace is a mechanism often used by debuggers that allows one process to control another. The DELI  can be configured as a separate process that attaches to the application  via ptrace, and runs the application until the point where the execution start-up code at the top of the application's binary image (e.g., crt0) is about to call the application's entry point. Execution of the application  can then be suspended, and the DELI  can be used to fetch the application instructions and execute them on its behalf.","In yet another alternative, the application's text segment can be expanded in a separate copy of the executable file. In particular, the application's binary image can be copied to a temporary location, the application's text segment extended by adding a DELI text segment at the end, and the start symbol (i.e., the entry point that is called by crt0) changed to the DELI entry point. The resulting executable file can then be executed using exec. The original application's text segment is still loaded at the same virtual address that it would normally have, but the DELI  will gain control before the actual application  starts.","In another example, the DELI  can gain control over the application  using a special version of crt0. As is known in the art, the crt0 code is responsible for picking-up the command line arguments, setting up the initial stack and data segment, and then making a call to the value of the start symbol (usually the main( ) function of the application ). Prior to calling the application  entry point, crt0 maps the dynamic link loader did, which then loads any dynamically linked libraries (DLLs) referenced by the application . A custom version of crt0 can be used to additionally map the DELI code (itself compiled as a DLL), and call the DELI's entry point instead of the one defined by the start symbol.","Irrespective of the manner in which control is obtained over the application , an instruction fetch controller  can then be used to extract (i.e., fetch) copies of fragments (e.g., traces) of the application binary code, pass them to the DELI core  for caching, and direct the core  to execute the appropriate cached copies out of its code cache(s) . Use of the transparent mode layer  in facilitating such operation is described below in relation to .","It is to be noted that, although the DELI  has been shown and described herein as including the API , persons having ordinary skill in the art will appreciate from this disclosure taken as a whole that the API may be omitted altogether depending upon the mode of operation that is desired. For instance, where the DELI  is to only operate in a completely transparent mode, the API  may not be necessary.","As noted above, the system control and configuration layer  enables configuration of the DELI  by providing policies for the caching and linking of code. Although the DELI  is not limited to any particular type of policy or policy content, the policies typically determine how the DELI will behave. For instance, the layer  may provide policies as to how fragments of code are extracted from the application , how fragments are created from the original code, how multiple code fragments can be linked together to form larger code fragments, etc. The layer's policies can be static or dynamic. In the former case, the policies can be hardcoded into the DELI , fixing the configuration at build time. In the latter case, the policies can be dynamically provided by the application  through function calls in the API . Implementation of the policies controls the manner in which the DELI  reacts to specific system and\/or hardware events (e.g., exceptions and interrupts). In addition to the policies noted above, the system control and configuration layer  can specify the size of the code cache(s) , whether a log file is created, whether code fragments should be optimized, etc.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["106","106","108","110","200","124","106","124","104"]},"The core controller  processes these requests and dispatches them to the appropriate core module. A request  to emit a code fragment with a given identifier can then be passed to the fragment manager . The fragment manager  transforms the code fragment according to its fragment formation policy , possibly instruments the code fragment according to its instrumentation policy , and links the code fragment together with previously cached fragments according to its fragment linking policy . For example, the fragment manager  may link multiple code fragments in the cache(s) , so that execution jumps to another code fragment at the end of executing a code fragment, thereby increasing the length of execution from the cache(s). To accomplish this, the fragment manager  issues fragment allocation instructions  to the cache manager . The fragment manager  then sends a request to the cache manager  to allocate the processed code fragment in the code cache(s) .","The cache manager  controls the allocation of the code fragments and typically is equipped with its own cache policies  for managing the cache space. However, the fragment manager  may also issue specific fragment deallocation instructions  to the cache manager . For example, the fragment manager  may decide to integrate the current fragment with a previously allocated fragment, in which case the previous fragment may need to be deallocated. In some arrangements, the cache manager  and fragment manager  can manage the code cache(s)  and code fragments in the manner shown and described in U.S. Pat. No. 6,237,065, issued May 22, 2001, entitled \u201cA Preemptive Replacement Strategy for a Caching Dynamic Translator Based on Changes in the Translation Rate,\u201d which is hereby incorporated by reference into the present disclosure. Alternatively, management of the code cache(s)  and code fragments may be performed in the manner shown and described in U.S. patent application Ser. No. 09\/755,389, filed Jan. 5, 2001, entitled \u201cA Partitioned Code Cache Organization to Exploit Program Locality,\u201d which is also hereby incorporated by reference into the present disclosure.","Prior to passing a fragment to the cache manager , the fragment manager  may pass () the fragment to the optimization manager  to improve the quality of the code fragment according to its optimization policies . In some arrangements, the optimization manager  may optimize code fragments in the manner shown and described in U.S. patent application Ser. No. 09\/755,381, filed Jan. 5, 2001, entitled \u201cA Fast Runtime Scheme for Removing Dead Code Across Linked Fragments,\u201d which is hereby incorporated by reference into the present disclosure. Alternatively, the optimization manager  may optimize code fragments in the manner shown and described in U.S. patent application Ser. No. 09\/755,774, filed Jan. 5, 2001, entitled \u201cA Memory Disambiguation Scheme for Partially Redundant Load Removal,\u201d which is also hereby incorporated by reference into the present disclosure. Notably, the optimization manager  may also optimize code fragments using classical compiler optimization techniques, such as elimination of redundant computations, elimination of redundant memory accesses, inlining functions to remove procedure call\/return overhead, etc.","As mentioned above, the fragment manager  transforms the code fragment according to its fragment formation policy . The transformations performed by the fragment manager  can include code relocation by, for instance, changing memory address references by modifying relative addresses, branch addresses, etc. The layout of code fragments may also be modified, changing the physical layout of the code without changing its functionality (i.e., semantics). These transformations are performed by the fragment manager  on fragments received through the API  and from the instruction fetch controller .","To perform code instrumentation, the fragment manager  gathers data according to the instrumentation policy  for code profiling, such as data on the frequency of execution of code fragments, the frequency with which a memory address is accessed, etc. Program counters can be used to collect these statistics in order to facilitate fragment formation or deallocation. These policies are configured by the system control and configuration layer , which receives policy instructions sent either through the API  or established at DELI build time. The policies may comprise options for different ways to create, instrument, optimize, and link fragments, or the policies may simply be hardcoded algorithms in the DELI  for performing these tasks.","The second type of request accepted by the DELI core  is a request  to execute a fragment identified by a given identifier (e.g., tag). In such a case, the core controller  issues a lookup request  to the fragment manager , which returns a corresponding code cache address  if the fragment is currently resident and active in the cache(s) . By way of example, the fragment manager  can maintain a lookup table of resident and active code fragments in which a tag can be used to identify the location of a code fragment. Alternatively, the fragment manager  or cache manager  can use any other suitable technique for tracking whether code fragments are resident and active. If the fragment is not currently resident and active in the cache(s) , the fragment manager  returns an error code to the core controller , which returns () the fragment tag back to the initial requester as a cache miss address. If, on the other hand, the fragment is currently resident and active, the core controller  then patches () the initial request to the cache manager  along with its cache address. The cache manager , in turn, transfers control to the addressed code fragment in its code cache(s) , thus executing the addressed code fragment. Execution then remains focused in the code cache(s)  until a cache miss occurs, i.e., until a copy for the next application address to be executed is not currently resident in the cache(s). This condition can be detected, for instance, by an attempt of the code being executed to escape from the code chache(s) . A cache miss is reported () from the cache manager  to the core controller  and, in turn, back () to the initial requester.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3","b":["300","100","300","300","302","304","306","308","310","312","314"]},"The processing device  can include any custom made or commercially available processor, a central processing unit (CPU) or an auxiliary processor among several processors associated with the computer system , a semiconductor based microprocessor (in the form of a microchip), a macroprocessor, one or more application-specific integrated circuits (ASICs), a plurality of suitably configured digital logic gates, and other well known electrical configurations comprising discrete elements both individually and in various combinations to coordinate the overall operation of the computing system.","The memory  can include any one of a combination of volatile memory elements (e.g., random access memory (RAM, such as DRAM, SRAM, etc.)) and nonvolatile memory elements (e.g., ROM, hard drive, tape, CDROM, etc.). The memory  typically comprises an O\/S , one or more applications  (e.g., user application and\/or client), and the DELI , which has already been described in detail. Persons having ordinary skill in the art will appreciate that the memory  can, and typically will, comprise other components which have been omitted for purposes of brevity.","The one or more user interface devices  comprise those components with which the user can interact with the computing system . For example, where the computing system  comprises a personal computer (PC), these components can comprise a keyboard and mouse. Where the computing system  comprises a handheld device (e.g., PDA, mobile telephone), these components can comprise function keys or buttons, a touch-sensitive screen, a stylus, etc. The display  can comprise a computer monitor or plasma screen for a PC or a liquid crystal display (LCD) for a handheld device.","With further reference to , the one or more I\/O devices  are adapted to facilitate connection of the computing system  to another system and\/or device and may therefore include one or more serial, parallel, small computer system interface (SCSI), universal serial bus (USB), IEEE 1394 (e.g., Firewire\u2122), and\/or personal area network (PAN) components. The network interface devices  comprise the various components used to transmit and\/or receive data over a network. By way of example, the network interface devices  include a device that can communicate both inputs and outputs, for instance, a modulator\/demodulator (e.g., modem), wireless (e.g., radio frequency (RF)) transceiver, a telephonic interface, a bridge, a router, network card, etc.","Various software and\/or firmware has been described herein. It is to be understood that this software and\/or firmware can be stored on any computer-readable medium for use by or in connection with any computer-related system or method. In the context of this document, a computer-readable medium denotes an electronic, magnetic, optical, or other physical device or means that can contain or store a computer program for use by or in connection with a computer-related system or method. These programs can be embodied in any computer-readable medium for use by or in connection with an instruction execution system, apparatus, or device, such as a computer-based system, processor-containing system, or other system that can fetch the instructions from the instruction execution system, apparatus, or device and execute the instructions. In the context of this document, a \u201ccomputer-readable medium\u201d can be any means that can store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device.","The computer-readable medium can be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium. More specific examples (a nonexhaustive list) of the computer-readable medium include an electrical connection having one or more wires, a portable computer diskette, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM, EEPROM, or Flash memory), an optical fiber, and a portable compact disc read-only memory (CDROM). Note that the computer-readable medium can even be paper or another suitable medium upon which a program is printed, as the program can be electronically captured, via for instance optical scanning of the paper or other medium, then compiled, interpreted or otherwise processed in a suitable manner if necessary, and then stored in a computer memory.","The general nature of the DELI  having been described above, an example of operation of the DELI will now be discussed. As identified above, the DELI  operates in two general operating modes, i.e., a transparent mode and a nontransparent mode, as well as combinations thereof.  illustrates operation in the transparent mode. In describing this mode of operation, a flow diagram is provided. It is to be understood that any process steps or blocks in flow diagrams of this disclosure represent modules, segments, or portions of code that include one or more executable instructions for implementing specific logical functions or steps in the process. It will be appreciated that, although particular example process steps are described, alternative implementations are feasible. Moreover, steps may be executed out of order from that shown or discussed, including substantially concurrently or in reverse order, depending on the functionality involved.","Generally speaking, irrespective of whether the DELI  has gained control over the execution of the application  transparently or nontransparently, the application does not execute directly on the hardware . Rather, application code executes through the DELI , for instance, in the form of code fragments that may be maintained in the code cache(s) .  illustrates a simple example of the DELI  operating in a completely transparent mode in which the application  is unaware of the DELI's presence. Beginning with block , the DELI  is first initiated. When operating in the transparent mode, this initiation can result from initiation of the application . Upon its initiation, the DELI  is injected into the application  with the injector  of the transparent mode layer , as indicated in block , such that the DELI gains control over the application and its execution. As noted above, there are various different methods in which this control can be gained.","Once the DELI  has control over the application , the DELI can be used to provide any one of several different services such as those noted above. For instance, the DELI  can facilitate hardware and\/or software emulation, dynamic translation and optimization, transparent remote code execution, remapping of computer system functionality for virtualized hardware environments program, code decompression, code decryption, etc. These different services each involve the caching and the linking of program code fragments within the code cache(s) . By caching certain fragments of code copied from the application binaries and transforming them in some manner, the desired services can be provided by later executing the transformed code from the code cache(s) .","Before caching code, the DELI  must determine which particular fragments of code to cache. In that, when operating in the completely transparent mode, the application  is unaware of the DELI , the DELI does not receive guidance from the application as to which code fragments to cache. Although the caching of code can be dictated through the policies created at the DELI build time, more typically, the DELI  will, at least in part, make these determinations on its own. The DELI  can do this by monitoring the execution of application code, as indicated in block . In so doing, the DELI  can collect information as to, for instance, which code fragments are most useful to the application  by, for example, determining which fragments are most frequently used.","As the various code fragments are executed by the application  under the control of the DELI , the DELI \u201csees\u201d each piece of code that is executed. Through the monitoring process, the DELI  can, therefore, determine which code fragments are used most frequently. The DELI  can then make the determination of which pieces of code are \u201chot,\u201d i.e., most important to application execution with reference to the policies that are provided by the system control and configuration layer . As noted above, this determination can be made using program counters that track execution instances. Persons having ordinary skill in the art will appreciate that various other methods can be used to make the determination of which pieces of code are hot. Examples of the manner in which this determination can be made are described in U.S. patent application Ser. No. 09\/186,945, filed Nov. 5, 1998, entitled \u201cMethod for Selecting Active Code Traces for Translation in a Caching Dynamic Translator,\u201d and U.S. patent application Ser. No. 09\/312,296, filed May 14, 1999, entitled \u201cLow Overhead Speculative Selection of Hot Traces in a Caching Dynamic Translator,\u201d both of which are hereby incorporated by reference into the present disclosure.","With further reference to , as each code fragment is executed, the DELI  can determine whether an associated code fragment has previously been cached, as indicated in decision element . If so, the DELI  jumps to the code cache(s)  that contains the cached (and potentially transformed) code and this code is executed by the hardware  in lieu of the original application code, as indicated in block . The determination of whether the code has been cached can be made with reference to, as noted above, identifiers (e.g., tags) that identify the association between native application code and analogues that have been cached within the code cache(s) . Execution of the cached code then continues, including the execution of linked fragments of code that reside in the code cache(s) , until such time when a reference to code that has not been cached (i.e., a cache miss) is encountered. With reference to decision element , if a reference to uncached code is encountered, the DELI  jumps back to the application code and the execution of that code is resumed, as indicated in block . At this time, the DELI  can resume monitoring of this execution (block ).","Returning to decision element , if the DELI  determines that an associated code fragment does not reside in the code cache(s) , flow continues to decision element  at which it is determined whether the code fragment is hot with reference to a predetermined policy. If the code is not hot, flow returns to block  at which monitoring of the application code execution continues. If, on the other hand, the code is hot, the code fragment is copied, as indicated in block , by fetching the fragment using the instruction fetch controller  of the transparent mode layer . It is noted that, if desired, each piece of code can be copied prior to determining whether the code is hot in decision element . Such a change does not, however, affect the overall operation of the system  or the results that can be achieved.","At this point, the code fragment can be transformed in some manner, as indicated in block . In addition, code fragments within the cache(s)  can be linked according to the policies that have been established for code linking. The nature of the code transformation depends upon the type of services that the DELI  is to provide. For example, where the DELI  is to merely optimize the application execution, this transformation can comprise rearranging and\/or reconfiguring the code for better performance. Irrespective of the nature of the transformation provided, the code structure is modified in a way without modifying the underlying semantics. Once the code fragment has been transformed, the transformed code can be cached within the code cache(s) , as indicated in block , and executed within the DELI  with flow continuing to block  described above.","Although, in the above example, code is cached when it is considered hot, other criteria may be used to determine which pieces of code to cache. Indeed, in some arrangements, each piece of code (or at least an associated version of the code) may be cached so that substantially all execution ultimately occurs within the code cache(s) .","As noted above, the DELI  may also operate in a nontransparent mode. Generally speaking, when operating in the nontransparent mode, the DELI  may operate, for example, as a DLL or a statically linked module which exports functions in the API  that the application  can access. In the simplest case, the application (client) controls every aspect of DELI operation through the API . In such a case, the DELI  can be utilized to cache, link, and optimize code according to explicit instructions provided by the client via the API . Alternatively, in a hybrid arrangement, the client may call upon the DELI  to provide its services in a transparent manner. In such a case, the client invokes operation of the DELI , as well as provides instructions as to when the DELI is to halt its operation. In either case, the client is aware of the DELI  and is configured to utilize the DELI's services. In that, in the isolation scenario, the application  normally is not aware of the DELI's presence, the nontransparent mode of operation is not described in detail. Persons having ordinary skill in the art will appreciate, however, that such isolation could be provided in a nontransparent manner where the application software is written to facilitate such isolation.","As described above, existing software and hardware solutions designed to prevent illegal application operation in multiprogrammed environments have various drawbacks that render their implementation unattractive. These problems can be avoided, however, when the DELI  is used in that the DELI controls very small portions of code, such as code fragments and even individual instructions, at run time. For instance, the DELI  can modify suspect application instructions so that they are capable of checking themselves immediately prior to execution to ensure that an out-of-range memory address will not be accessed or another illegal action cannot be accomplished. Once the code has been modified and cached, the legality of the instruction can be determined during execution without the need to interrupt execution of the application.","Beginning with block , the DELI  is initiated and, as indicated in block , injected into the application  before it starts so as to gain control over its execution. With this control, the DELI  can intercept the various application instructions that are to be executed, as indicated in block . As in the mode of operation described in relation to , the DELI  monitors the execution of code so it can be determined which code fragments to cache. Accordingly, as described above, the DELI  can first determine whether an associated code fragment has previously been cached, as indicated in decision element . If so, the DELI  jumps to the code cache(s)  that contains the code and this code is executed by the hardware  in lieu of the original application code, as indicated in block . Again, execution of the cached code continues until a reference to code that has not been cached is encountered (), e.g., a cache miss occurs, at which time the DELI  jumps back to the application code and block .","With reference back to decision element , if no associated code fragment resides in the code cache(s) , flow continues to block  at which a code fragment (one or more application instructions) is copied, for instance to one or more instruction buffers. Next, with reference to decision element , the DELI  determines whether the copied instruction(s) are legal. By way of example, this determination can comprise determining whether the instruction(s) identify an out-of-range memory address that was not known before the application code was bound. If the instruction(s) is\/are legal, flow continues down to decision element  described below. If, on the other hand, one or more of the instructions is illegal, flow continues to block  at which the desired action is prevented. This can, for instance, comprise shutting down the application or permitting the application to continue but disallowing it to complete the illegal action.","At this point, flow continues to decision element  at which the DELI  inspects the application instruction(s) to determine whether one or more instructions contain an indirect memory reference. As discussed above, the address to be referenced by an instruction cannot be determined until just prior to execution of the instruction where the reference is indirect. Due to the overhead associated with interrupting execution of an application to determine whether or not the instruction actually references an out-of-range address, it is impractical to inspect an instruction each time it is used. To avoid this overhead, the DELI  can modify the instruction so that it can determine itself whether an out-of-range address is to be accessed, or whether another illegal operation is to be performed. Accordingly, where one or more instructions are determined to contain an indirect memory reference at decision element , flow continues to block  at which the DELI  modifies the code fragment to enable self-checking. The modification can comprise adding one or more additional instructions to the original instructions that are configured to check the memory address to be accessed just prior to execution of the original instructions. Such a modification can be made inline within the fragment such that no interruption of execution is necessary and, therefore, little overhead is incurred. Once the fragment is modified in this manner, its associated function can determine whether execution of the fragment could result in an illegal action. If so, the action is again prevented.","Irrespective of whether an indirect reference was identified, flow continues to block  at which the code fragment is cached within one or more code caches . As mentioned above, such operation may result in substantially all code ultimately being stored and executed within the code cache(s) . In such a case, substantially all of the original application instructions and the modified instructions may eventually be resident within the code cache(s) . Although both modified and unmodified code fragments have been described as being cached, it is to be appreciated that, if desired, only the modified code fragments could be cached. In such a scenario, the fragment would be tagged such that the next time the original application instruction(s) arise, execution will jump to the code cache(s)  for execution of the modified (i.e., self-checking) code fragment.","Operating in the manner described above in relation to , substantially all illegal references can be detected and avoided without having to interrupt execution or expend the time and cost associated with creating a hardware solution. While particular embodiments of the invention have been disclosed in detail in the foregoing description and drawings for purposes of example, it will be understood by those skilled in the art that variations and modifications thereof can be made without departing from the scope of the invention. For instance, although the DELI has been described above with reference to  as primarily isolating code, it is to be noted that various other services can simultaneously be provided by the DELI. For instance, this isolation can be provided while simultaneously providing instruction optimization, etc. The present disclosure is intended to include such hybrid operation."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention can be better understood with reference to the following drawings.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 5","FIG. 1"]}]},"DETDESC":[{},{}]}
