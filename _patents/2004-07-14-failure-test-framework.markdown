---
title: Failure test framework
abstract: A framework by which arbitrary routines may be executed in reaction to specific events for analysis and testing, while avoiding the need to manipulate the actual code being monitored. A method for performing functional failure testing of a software-based system comprises monitoring execution of target software for occurrence of a specified event, in response to detecting occurrence of the specified event, performing an action to cause or simulate a failure of the target software or of software or hardware that operatively interacts with the target software, and monitoring the target software for a response to the performed action.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07877733&OS=07877733&RS=07877733
owner: Oracle International Corporation
number: 07877733
owner_city: Redwood Shores
owner_country: US
publication_date: 20040714
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","The present invention relates to a software failure test framework by which arbitrary routines may be executed in reaction to specific events for analysis and testing.","2. Background of the Prior Art","Software quality control is a necessary task in order to provide software that properly performs its designed functions. One important aspect of software quality control is functional testing. Functional testing exercises the operation of the software under relatively realistic operating conditions. In order to provide a thorough and realistic test, the software must be tested not only under normal operating conditions, but also under conditions in which errors occur.","Previously, in order to emulate particular runtime situations for functional testing, for example, as in the case of third-party failure, it was necessary to implement intrusive techniques such as creating special test builds of the software being tested, in which these error simulations are introduced into the software itself. This technique is not only threatening to the software development process, it is generally not sufficiently effective at recreating an accurate simulation. For example, where interaction with distributed and third party software is needed, but the source code for such software is not available, error simulations of such software may not be sufficiently accurate for testing purposes.","Another approach is to mock out certain aspects of the system. However, this takes away any potentially unexpected behavior of the actual, practical system involved and also relies on the accuracy of third-party systems implementations of specifications, both of which may not be sufficient in critical real life solutions. A need arises for a technique by which arbitrary routines may be executed in reaction to specific events for analysis and testing, while avoiding the need to manipulate the actual code being monitored. This would provide the capability to accurately model failure scenarios, while avoiding the need for special test builds of the software under test. Such a technique would be useful in many scenarios, such as transactional processing failure and recovery and security.","The present invention provides a framework by which arbitrary routines may be executed in reaction to specific events for analysis and testing, while avoiding the need to manipulate the actual code being monitored. In one embodiment, the present invention uses the Java Debugging Interfaces to monitor java processes for specific events such as method entry, line number, all of the methods of a class or package, all exceptions, etc. Upon occurrence of such an event, a reaction is executed in order to introduce a failure, analyze the current state of the software or participating resources, manipulate parameters, etc. Examples of such reactions in the framework respectively include the communication loss or shutdown of application servers, databases, messaging systems, etc. while engaged in transactional processing, the analysis of recovery states all along the life-cycle of such failure, the manipulation and forwarding of responses as in the case of security information, response codes, and so on.","In one embodiment of the present invention, a method for performing functional failure testing of a software-based system comprises monitoring execution of target software for occurrence of a specified event, in response to detecting occurrence of the specified event, performing an action to cause or simulate a failure of the target software or of software or hardware that operatively interacts with the target software, and monitoring the target software for a response to the performed action. The method may further comprise defining the specified event based on a particular action to be taken by the target software under test that would indicates that a particular failure action should be initiated and defining instructions specifying the action to be taken by the framework in response to detecting the specified event. The method may further comprise attaching to the target software and starting execution of the target software. The target software may comprise at least one Java process. The target software may comprise at least one Java process and at least one native process. The target software may comprise at least one Java process and the method may further comprise starting execution of a Java virtual machine with debugging capability, attaching to the Java process, and starting execution of the Java process. The monitoring step may comprise monitoring execution of the Java process using the debugging capability. The method may further comprise detecting occurrence of the specified event with the debugging capability and transmitting a notification that the specified event was detected. The method may further comprise in response to receiving the notification that the specified event was detected, starting execution of the action and attaching the action to the Java process.","The present invention provides a framework by which arbitrary routines may be executed in reaction to specific events for analysis and testing, while avoiding the need to manipulate the actual code being monitored. In one embodiment, the present invention uses the Java Debugging Interfaces to monitor java processes for specific events such as method entry, line number, all of the methods of a class or package, all exceptions, etc. Upon occurrence of such an event, a reaction is executed in order to introduce a failure, analyze the current state of the software or participating resources, manipulate parameters, etc. Examples of such reactions in the framework respectively include the communication loss or shutdown of application servers, databases, messaging systems, etc. while engaged in transactional processing, the analysis of recovery states all along the life-cycle of such failure, the manipulation and forwarding of responses as in the case of security information, response codes, and so on.","While, for simplicity and clarity of description, the present invention is described in terms of the JAVA\u00ae programming language and programming system, one of skill in the art would recognize that the present invention is equally applicable to implementation using any programming language and programming system. The present invention contemplates the use of any programming language and programming system.","An exemplary block diagram of the components involved in the operation of the present invention is shown in . These components include failure creator , failure framework , Java process , native process , and client . Failure creator  configures the failure framework  by setting values via the built-in application programming interface (API) of failure framework  or by supplying failure framework  with a custom failure object that defines the events to listen for and the failure actions to perform when these events are detected. Client  initiates the routine that will trigger the event in the Java Process that the Failure Framework is listening for. This event that the Framework is listening for is the one the failure creator  has specified. It is likely the case that the failure creator  and client  will be initiated from the same source, as the failure must be set up before the client initiates the routine that will in turn trigger the event set. Java Process  is an example of target software that is analyzed and\/or manipulated by the Failure Framework. This also includes any processes dependent upon the primary. These are started before the routine is initiated by the client. Native Process  is an example of a process that may be called by Java process , for example, via a bridging mechanism such as JNI. This allows framework  to listen for execution points in non-Java libraries. This simply illustrates an additional function of the framework and is not a necessary component.","Failure creator  has a one to one-or-more relationship  with failure framework , failure framework  has a one to one-or-more relationship  with Java process , client  has a one to one-or-more relationship  with Java process , and Java process  has a one to zero-or-more relationship  via JNI calls with native process .","It is likely the case that the Failure Creator and Client will be initiated from the same source as the failure must be set up before the client initiates the routine that will in turn trigger the event set. The targets for analysis and\/or manipulation and dependents thereof are obviously started before this routine is initiated. The Java process may call into a native process via a mechanism such JNI thereby allowing the framework to listen for execution points in non-Java libraries, however, this simply illustrates an additional function of the framework and is not a necessary component.","A simple use case of this functionality involves testing the runtime behavior in a transaction processing system such as those described in the Distributed Transaction Protocol and XA specifications produced by the Open Group. Implementations of these specifications provide a coordinator that manages multiple persisted resources such as databases, messaging systems, and mainframes within a global scope or transaction such that the principle criteria of atomicity, consistency, isolation, and durability (known as ACID properties) are insured. Though these aspects are related for this example we will focus on the atomicity guarantee that a transaction is a discrete unit of work and that all constituent operations must either succeed or fail. These operations may include queuing messages, updating databases, and displaying the results of a transaction on a screen.","A typical example is the transfer of money from one bank account to another. In this transaction the transfer amount must both be subtracted from the original account and added to the destination account in order to satisfy the atomicity requirement. If there is a failure in either account during this process the amount must remain in the original account only. In other words, any work conducted prior to the failure must be rolled back to the original state.","This example also illustrates the components involved in a Transaction Processor (TP) system, namely the Application Program, such as the web application, bank teller console, etc. that is issuing the command to transfer, the databases containing the bank accounts, which are the participants or Resource Managers (RMs), and the Transaction Processor which coordinates the RMs.","An exemplary sequence diagram illustrating the interaction of the objects shown in , is shown in . The example shown in  assumes that the target has been started. (the dotted line is used to represent a JDWP callback from the target Java Process for an event the Failure Framework is listening for).  is best viewed in conjunction with , which is an exemplary flow diagram of a process  of operation of the framework of the present invention is shown in . This example is illustrated in the context of failure testing a Transaction Processor system using the Java programming system, but is equally applicable to failure testing of any type of software\/programming or software\/hardware system.","Process  begins with step , in which the failure framework  is initialized with the failure event that the framework is to listen for. This is done by transmission of initFailure object  from failure creator  to failure framework . The initFailure object  includes a failure event specification, which defines a particular action taken by the target software under test that indicates that a particular failure action should be initiated. In addition, initFailure object  includes an instruction set specifying the failure actions to be taken by the framework in response to the event. The instruction set can be of arbitrary complexity\u2014that is, it can be as simple or complex as required. In this example a method entry event on the commit method of the Transaction class (the commit method is the point in the transaction routine where the TP will tell all participating resource managers to persist work conducted) is set along with a failure reaction of to shutdown the TP\/VM. The equivalent lines of code could be as simple as the following:\n\n","In step , the Java virtual machine (VM) where the TP runs is started with Java Debug Wire Protocol (JDWP) properties such as the following:\n\n","The Java Debug Wire Protocol (JDWP) is the protocol used for communication between a debugger and the Java virtual machine (VM) which it debugs. Thus, vm.attach  attaches failure framework  to Java process . In the case of other programming systems, the underlying processes necessary to support execution of the failure test framework and the software being tested are started.","In step , the software under test, such as Java process , is started. For example, the bank transfer is initiated. Execution of the software under test proceeds. For example, Java process  may perform a native object call  to native process . In step , the failure event is detected in the software under test, such as Java process  or native process . An eventReached notification  is transmitted from Java Process  to failure framework . This indicates that a particular failure action should be initiated. In step , the custom failure action defined by the instruction set is then started and attaches to the target\/TP by use of eventreached object . In step , the expected result is asserted and the actual response of the target operation is monitored. In this example we should see that no funds were transferred as the TP crashed before it could call commit on any of the account databases involved.","This is a simple example and, automation benefits aside, could potentially be recreated manually. There are much more complex architectures and failure scenarios to consider however. An example of this is if in the previous example the TP was able to issue a successful commit on the first account's database, but the second database crashed before receiving its commit message from the TP. There are a number of different protocols defined for recovery scenarios, however, all rely on some form of log to remember the last stable state and use an algorithm that adheres to the given protocol to recover by rolling back or committing as appropriate to maintain an ACID outcome. Further failure issues may occur during the recovery process itself. In a similar way, compensation activities can occur in complex business process transactions where for example a travel agency must book plane reservations that coincide with hotel reservations (should one hotel become available, another two might fit the same timeframe, etc.). As mentioned the scenarios are further complicated by the underlying architecture which, particularly in the case of webservice transactions, e.g., may span multiple TPs, protocols, business entities, etc. as in the example shown in . In this diagram the transaction is actually initiated by an outside system, specifically an Enterprise Resource Provider  (ERP) such as SAP\u00ae or PEOPLESOFT\u00ae. The transaction context inflow \u201cinfects\u201d the transaction processor  (TP) with an existing transaction (distinguishing it from a transaction created by the TP) and effectively enlists TP  as a special type of participating resource often referred to a sub or interposed coordinator. The called TP  in turn requires services and resources in other entities (where entities may refer to other companies) including but not limited to other transaction processors (such as TP , TP ) that again may require the resources (such as a MAINFRAME , DATABASE , MESSAGING SYSTEM , etc.) and so on.","In a similar way, compensation activities can occur in complex business process transactions such as the one illustrated in . The failure framework of the present invention can test this and also simulate various responses from interaction points in workflows such as the payment authorization shown in . In this diagram a failure creator can situate a failure framework at one or more of the connection points of the activity in order to control what the outcome or decision of the process is or cause a failure outright. As an example, the framework could be positioned at the appropriate location of the Authorize Payment node to induce or intercept and dispatch a \u2018failed\u2019 or \u2018succeeded\u2019 message or fail at any point of the this node's processing. The result of Cancel Order, Reorder Goods, or failure reaction can then be determined and analyzed.","Beyond failures due to crashes, lost messages, etc. there is a potential for malicious and corrupted messages in any number of scenarios as well. Byzantine general formulas have long been a study in distributed processing. The framework can simulate such situations by intercepting calls and forwarding or replying with bogus information. It is easy to see the adverse effects of a TP system subject to such misleading messages if no consensus algorithm is in place to account for them. Another scenario involves security concerns such as the interception of private information, stolen identities, etc. The framework can also be set to carry this out with minimal effort.","An exemplary block diagram of a computer system , in which the present invention may be implemented, is shown in . System  is typically a programmed general-purpose computer system, such as a personal computer, workstation, server system, and minicomputer or mainframe computer. System  includes one or more processors (CPUs) A-N, input\/output circuitry , network adapter , and memory . CPUs A-N execute program instructions in order to carry out the functions of the present invention. Typically, CPUs A-N are one or more microprocessors, such as an INTEL PENTIUM\u00ae processor.  illustrates an embodiment in which System  is implemented as a single multi-processor computer system, in which multiple processors A-N share system resources, such as memory , input\/output circuitry , and network adapter . However, the present invention also contemplates embodiments in which System  is implemented as a plurality of networked computer systems, which may be single-processor computer systems, multi-processor computer systems, or a mix thereof.","Input\/output circuitry  provides the capability to input data to, or output data from, database\/System . For example, input\/output circuitry may include input devices, such as keyboards, mice, touchpads, trackballs, scanners, etc., output devices, such as video adapters, monitors, printers, etc., and input\/output devices, such as, modems, etc. Network adapter  interfaces database\/System  with Internet\/intranet . Internet\/intranet  may include one or more standard local area network (LAN) or wide area network (WAN), such as Ethernet, Token Ring, the Internet, or a private or proprietary LAN\/WAN.","Memory  stores program instructions that are executed by, and data that are used and processed by, CPU  to perform the functions of system . Memory  may include electronic memory devices, such as random-access memory (RAM), read-only memory (ROM), programmable read-only memory (PROM), electrically erasable programmable read-only memory (EEPROM), flash memory, etc., and electro-mechanical memory, such as magnetic disk drives, tape drives, optical disk drives, etc., which may use an integrated drive electronics (IDE) interface, or a variation or enhancement thereof, such as enhanced IDE (EIDE) or ultra direct memory access (UDMA), or a small computer system interface (SCSI) based interface, or a variation or enhancement thereof, such as fast-SCSI, wide-SCSI, fast and wide-SCSI, etc, or a fiber channel-arbitrated loop (FC-AL) interface.","The contents of memory  vary depending upon the function that system  is programmed to perform. However, one of skill in the art would recognize that these functions, along with the memory contents related to those functions, may be included on one system, or may be distributed among a plurality of systems, based on well-known engineering considerations. The present invention contemplates any and all such arrangements.","In the example shown in , memory  includes target software , failure test framework , and operating system . Target software  includes software object, routines, modules, systems, etc., that are undergoing functional failure testing. Failure test framework is software that implements the objects and processes of the present invention to perform functional failure testing of target software . Failure test framework  includes failure test routines , failure event definitions , and custom failure definitions . Failure test routines implement the functionality of the failure test framework of the present invention. Failure test event definitions  specify events that are to be monitored in order to initiate failure actions. Custom failure definitions  specify actions to be taken upon detection of a failure test event in order to create or simulate failures for the target software . Operating system  provides overall system functionality.","As shown in , the present invention contemplates implementation on a system or systems that provide multi-processor, multi-tasking, multi-process, and\/or multi-thread computing, as well as implementation on systems that provide only single processor, single thread computing. Multi-processor computing involves performing computing using more than one processor. Multi-tasking computing involves performing computing using more than one operating system task. A task is an operating system concept that refers to the combination of a program being executed and bookkeeping information used by the operating system. Whenever a program is executed, the operating system creates a new task for it. The task is like an envelope for the program in that it identifies the program with a task number and attaches other bookkeeping information to it. Many operating systems, including UNIX\u00ae, OS\/2\u00ae, and WINDOWS\u00ae, are capable of running many tasks at the same time and are called multitasking operating systems. Multi-tasking is the ability of an operating system to execute more than one executable at the same time. Each executable is running in its own address space, meaning that the executables have no way to share any of their memory. This has advantages, because it is impossible for any program to damage the execution of any of the other programs running on the system. However, the programs have no way to exchange any information except through the operating system (or by reading files stored on the file system). Multi-process computing is similar to multi-tasking computing, as the terms task and process are often used interchangeably, although some operating systems make a distinction between the two.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media such as floppy disc, a hard disk drive, RAM, and CD-ROM's, as well as transmission-type media, such as digital and analog communications links.","Although specific embodiments of the present invention have been described, it will be understood by those of skill in the art that there are other embodiments that are equivalent to the described embodiments. Accordingly, it is to be understood that the invention is not to be limited by the specific illustrated embodiments, but only by the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The details of the present invention, both as to its structure and operation, can best be understood by referring to the accompanying drawings, in which like reference numbers and designations refer to like elements.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
