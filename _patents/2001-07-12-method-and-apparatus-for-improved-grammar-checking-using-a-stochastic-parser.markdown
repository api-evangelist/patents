---
title: Method and apparatus for improved grammar checking using a stochastic parser
abstract: A method and grammar checking system are provided that generate a stochastic score, or a statistical goodness measure, for each of an input string of text and one or more alternative strings of text. An alternative generator generates the alternative strings of text, and a ranking parser produces parse trees and corresponding statistical goodness measures for each of the strings. The string of text having the highest goodness measure is selected for recommendation to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07003444&OS=07003444&RS=07003444
owner: Microsoft Corporation
number: 07003444
owner_city: Redmond
owner_country: US
publication_date: 20010712
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["Cross reference is made to U.S. patent application Ser. No. 09\/620,745, entitled, \u201cRANKING PARSER FOR A NATURAL LANGUAGE PROCESSING SYSTEM\u201d, filed Jul. 20, 2000.","The present invention relates to natural language processing. In particular, the present invention relates to grammar checker processing of natural language text.","A computer program that checks a user's grammar for correctness is called a grammar checker. Upon finding a mistake, a grammar checker usually flags the error to the user and suggests a correction. Users find grammar checkers to be very helpful. However the usefulness is dependent on the quality of the corrections the grammar checker suggests. The higher the accuracy, the happier the user.","In various grammar checkers, there are some mistakes that are difficult to evaluate using just heuristics. One such mistake is agreement between subject and verb. For example, the subject and verb in \u201cHe very quickly, after turning out the lights, eat the pistachios\u201d do not agree. In this example, the subject and the verb are separated by a long distance, and so larger structures need to be considered. In the example \u201cI insist that he go\u201d, if one just looks at \u2018he go\u2019 it would seem that there is disagreement. However, because it is an argument clause to \u2018insist\u2019 there is no disagreement. In this case again one needs to consider larger scale structures. In many cases the correct larger scale structures to use are parts of the complete parse tree for the sentence.","There are other types of hard mistakes, such as writing \u2018their\u2019 where \u2018there\u2019 is meant. Again, for this type of mistake the best way to know if a mistake has been made is often to look at the parse tree for the entire sentence. Another hard type of mistake is either not forming possessives correctly, or using a possessive where a plural was meant.","There are various heuristics grammar checkers can use to identify such mistakes. Most of these involve some form of template matching. For example one might construct a template that says if \u2018their\u2019 is followed by \u2018is\u2019, then change it to \u2018there\u2019. Some grammar checkers have used probabilistic techniques using as evidence the words within a certain distance of the search site. Some use Hidden Markov Model techniques to identify errors. Some techniques use a parser to help identify mistakes. In all of these methods there are two distinct processes going on. The first process is the search for constructions that might be in error. The second process is the evaluation of the choices to see if an error was actually made. Both of these processes are error prone.","Although these techniques for grammar checking natural language text have proven useful, there is an ongoing need to further improve the quality of the corrections suggested by the grammar checker. In particular, there is an ongoing need to improve the evaluation processes of grammar checkers.","Overview of Natural Language Processing","An overview of natural language processing (NLP) and related concepts is provided to aid in the understanding of the concepts of the invention. A NLP system is typically a computer-implemented software system, which intelligently derives meaning and context from an input string of natural language text. \u201cNatural languages\u201d are the imprecise languages that are spoken by humans (e.g., English, French, Japanese). Without specialized assistance, computers cannot distinguish linguistic characteristics of natural language text. A NLP system assists the computer in distinguishing how words are used in different contexts and in applying rules to construct intelligible language.","NLP Parser","The core of a NLP system is its parser. Generally, a parser breaks an utterance (such as a phrase or sentence) down into its component parts with an explanation of the form, function, and syntactical relationship of each part. The NLP parser takes a phrase and builds for the computer a representation of the syntax of the phrase that the computer can understand. A parser may produce multiple different representations for a given phrase. The representation makes explicit the role each word plays and the relationships between the words. As used herein, an utterance is equivalent to a phrase. A phase is a sequence of words intended to have meaning. In addition, a sentence is understood to be one or more phrases. In addition, references herein to a human speaker include a writer and speech includes writing.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1","b":["20","20","28","26","30","34","20","22","24"]},"The grammar rules interpreter  interprets the codified grammar rules. The tokenizer  identifies the words in the textual string , looks them up in a dictionary, makes records for the parts of speech (POS) of a word, and passes these to the searcher. The searcher  in cooperation with the grammar rules interpreter generates multiple grammatically correct parses of the textual string. The searcher sends its results to the parse ranker .","The parse ranker  mathematically measures the \u201cgoodness\u201d of each parse and ranks them. \u201cGoodness\u201d is a measure of the likelihood that such a parse represents the intended meaning of the human speaker (or writer). The ranked output of the parser ranker is the output of the ranker. This output is one or more of parses  ranked from most to least goodness.","Linguistic Concepts of NLP","Linguists group words of a language into classes, which show similar syntactic behavior, and often a typical semantic type. These word classes are otherwise called \u201csyntactic\u201d or \u201cgrammatical categories\u201d, but more commonly still by the traditional names \u201cpart of speech\u201d (POS). For example, common POS categories for English include noun, verb, adjective, preposition, and adverb.","Generally, words are organized into phrases, which are groupings of words that are clumped as a unit. Syntax is the study of the regularities and constraints of word order and phrase structure. Among the major phrase types are noun phrases, verb phrases, prepositional phrases, and adjective phrases.","The headword is the key word in a phrase. This is because it determines the syntactic character of a phrase. In a noun phrase, the headword is the noun. In a verb phrase, it is the main verb. For example, in the noun phrase \u201cred book\u201d, the headword is \u201cbook.\u201d Similarly, for the verb phrase \u201cgoing to the big store\u201d, the headword is \u201cgoing.\u201d A modifying headword is the headword of a sub-phrase within a phrase where the sub-phrase modifies the main headword of the main phrase. Assume a phrase (P) has a headword (hwP) and a modifying sub-phrase (M) within the P that modifies hwP. The modifying headword (hwM) is the headword of this modify phrase (M).","Syntactic features are distinctive properties of a word relating to how the word is used syntactically. For example, the syntactic features of a noun include whether it is singular (e.g. cat) or plural (e.g. cats) and whether it is countable (e.g. five forks) or uncountable (e.g. air). The syntactic feature of a verb includes whether or not it takes an object, for example.","Computational Linguistics","In computational linguistics, the regularities of a natural language's word order and grammar are often captured by a set of rules called \u201ctransitions\u201d or \u201crewrite rules.\u201d The rewrite rules are a computer representation of rules of grammar. These transitions are used to parse a phrase. A rewrite rule has the notation form: \u201csymbolA\u2192symbolB symbolC . . . \u201d. This indicates that symbol (symbolA) on the left side of the rule may be rewritten as one or more symbols (symbolB, symbolC, etc.) on the right side of the rule.","For example, symbolA may be \u201cs\u201d to indicate the \u201cstart\u201d of the sentence analysis. SymbolB may be \u201cnp\u201d for noun phrase and symbolc may be \u201cvp\u201d for verb phrase. The \u201cnp\u201d and \u201cvp\u201d symbols may be further broken down until the actual words in the sentence are represented by symbolB, symbolC, etc. For convenience, transitions can be named so that the entire rule need not be recited each time a particular transition is referenced.","The nature of the rewrite rules is that a certain syntactic category (e.g, noun, np, vp, pp) can be rewritten as one or more other syntactic categories or words. The possibilities for rewriting depend solely on the category, and not on any surrounding context, so such phrase structure grammars are commonly referred to as context-free grammars (CFG).",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2","b":["50","50","52","52","54","54"],"i":["a","c ","a","g"]},"The tree  includes a set of terminal nodes \u2013. These nodes are at the end of each branch of the tree and cannot be further expanded. For example, \u201clike\u201d cannot be expanded any further because it is the word itself. The tree  also includes a set of non-terminal nodes \u2013. These nodes are internal and may be further expanded. Each non-terminal node has immediate children, which form a branch (i.e., \u201clocal tree\u201d). Each branch corresponds to the application of a transition. For example, \u201cnp\u201d can be further expanded into a \u201cnoun\u201d by application of the \u201cnp_noun\u201d transition.","Each non-terminal node in the parse tree is created via the application of some rewrite rule. For example, in , the root node was created by the \u201cs\u2192np vp\u201d rule. The \u201cVP\u201d node by the \u201cs\u2192verb np\u201d rule. The tree  has a non-terminal node designated as the starting node and it is labeled \u201cs.\u201d In general, the order of the children in each branch generates the word order of the sentence, and the tree has a single root node (in  it is node ), which is the start of the parse tree.","A non-terminal node has a type that is called its \u201csegtype.\u201d In , each non-terminal node is labeled with its segtype. A node's segtype identifies the rule that was used to create the node (working up from the terminal nodes). For example, the segtype of node in  is \u201cnp\u201d because the rule \u201cnp\u2192noun\u201d was used to create the node.","In given grammar, a segtype can be many different values including, for example: NOUN, NP (noun phrase), VERB, VP (verb phrase), ADJ (adjective), ADJP (adjective phrase), ADV (adverb), PREP (preposition), PP (prepositional phrase), INFCL (infinitive clauses), PRPRT (present participial clause) PTPRT (past participial clause), RELCL (relative clauses), and AVPVP (a verb phrase that has a verb phrase as its head).","In this document, a functional notation is used to refer to the information associated with a node. For example, if a variable \u201cn\u201d represents a node in the tree, then \u201chw(n)\u201d is the headword of node \u201cn.\u201d The following functions are used through out this document:\n\n","A parse tree can be annotated with information computed during the parsing process. A common form of this is the lexicalized parse tree where each node is annotated with its headword. One can annotate a parse tree with additional linguistic information (e.g. syntactic features).  shows an example of such a lexicalized parse tree .  is a parse tree of one or many parses of the sentence, \u201cswat flies like ants.\u201d Terminal nodes , which are the words of the sentence, are not annotated. Non-terminal nodes are annotated. For example, node has a segtype of \u201cnoun\u201d and is annotated with \u201chw=ants\u201d. This means that its headword is \u201cants.\u201d The parse tree  in  is also annotated with the names of the transitions between nodes. For example, the transition name \u201cvp_verbvp\u201d is listed between node and node ","A probabilistic context free grammar (PCFG) is a context free grammar where every transition is assigned a probability from zero to one. PCFGs have commonly been used to define a parser's \u201cgoodness\u201d function. \u201cGoodness\u201d is a calculated measurement of the likelihood that a parse represents the intended meaning of the human speaker. In a PCFG, trees containing transitions that are more probable are preferred over trees that contain less probable transitions.","Since the probability of a transition occurring cannot be mathematically derived, the standard approach is to estimate the probabilities based upon a training corpus. A training corpus is a body of sentences and phrases that are intended to represent \u201ctypical\u201d human speech in a natural language. The speech may be intended to be \u201ctypical\u201d for general applications, specific applications, and\/or customized applications. This \u201ctraining corpus\u201d may also be called \u201ctraining data.\u201d","An augmented phrase structured grammar (APSG) is a CFG that gives multiple names to each rule, thereby limiting the application of each \u201cnamed\u201d rule. Thus, for each given rewrite rule there are more than one name and the name limits its use to specific and narrower situations. For example, the structure \u201cVP\u2192NP VP\u201d may have these limiting labels: \u201cSubjPQuant\u201d and \u201cVPwNPl.\u201d SubjPQuant specifies subject post-quantifiers on a verb phrase. For example, in \u201call found useful . . . \u201d, \u201call\u201d is a subject post-quantifier, In \u201cwe all found useful the guidelines\u201d is [NP all][VP found useful the guidelines]. VPwNPl specifies a subject to a verb phrase. For example, in \u201cJohn hit the ball\u201d [NP John] [VP hit the ball] where John is the subject.","Given the ambiguity that exists in natural languages, many sentences have multiple syntactic interpretations. The different syntactic interpretations generally have different semantic interpretations. In other words, a sentence has more than one grammatically valid structure (\u201csyntactic interpretation\u201d) and as a result, may have more than one reasonable meaning (\u201csemantic interpretation\u201d). A classic example of this is the sentence, \u201ctime flies like an arrow.\u201d There are seven valid syntactic parse trees.",{"@attributes":{"id":"p-0032","num":"0036"},"figref":["FIGS. 4","FIG. 4","FIG. 4"],"i":["a ","b ","a","b"],"b":["4","70","74","80","84"]},"A conventional approach used in NLP systems to determine which of multiple grammatically correct parses is the \u201ccorrect\u201d one is the use of a \u201cgoodness\u201d function to calculate a \u201cgoodness measure\u201d of each valid parse. Existing parsers differ in the extent to which they rely on a goodness function, but most parsers utilize one. A number of different goodness measures have been used in natural language systems to rank parse trees. For example goodness measures based upon probabilities determined by how frequently given parse tree occurred in a training corpus (a \u201cstraw man\u201d approach) have been used. Other goodness measures use a collection of mostly unrelated statistical calculations based upon parts of speech, syntactic features, word probabilities, and selected heuristic rules. Still other goodness measures are based upon syntactic bigram approaches, transition probability approaches (TPA), or other methods.","A method and grammar checking system are provided that generate a stochastic score, or a statistical goodness measure, for each of an input string of text and one or more alternative strings of text. An alternative generator generates the alternative strings of text, and a ranking parser produces parse trees and corresponding statistical goodness measures for each of the strings. The string of text having the highest goodness measure is selected for recommendation to a user.",{"@attributes":{"id":"p-0050","num":"0054"},"figref":"FIG. 5","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general-purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer .","Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, FR, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies.","A user may enter commands and information into the computer  through input devices such as a keyboard , a microphone , and a pointing device , such as a mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a hand-held device, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.",{"@attributes":{"id":"p-0062","num":"0066"},"figref":"FIG. 6","b":["200","200","202","204","206","208","210"]},"Memory  is implemented as non-volatile electronic memory such as random access memory (RAM) with a battery back-up module (not shown) such that information stored in memory  is not lost when the general power to mobile device  is shut down. A portion of memory  is preferably allocated as addressable memory for program execution, while another portion of memory  is preferably used for storage, such as to simulate storage on a disk drive.","Memory  includes an operating system , application programs  as well as an object store . During operation, operating system  is preferably executed by processor  from memory . Operating system , in one preferred embodiment, is a WINDOWS\u00ae CE brand operating system commercially available from Microsoft Corporation. Operating system  is preferably designed for mobile devices, and implements database features that can be utilized by applications  through a set of exposed application programming interfaces and methods. The objects in object store  are maintained by applications  and operating system , at least partially in response to calls to the exposed application programming interfaces and methods.","Communication interface  represents numerous devices and technologies that allow mobile device  to send and receive information. The devices include wired and wireless modems, satellite receivers and broadcast tuners to name a few. Mobile device  can also be directly connected to a computer to exchange data therewith. In such cases, communication interface  can be an infrared transceiver or a serial or parallel communication connection, all of which are capable of transmitting streaming information.","Input\/output components  include a variety of input devices such as a touch-sensitive screen, buttons, rollers, and a microphone as well as a variety of output devices including an audio generator, a vibrating device, and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition, other input\/output devices may be attached to or found with mobile device  within the scope of the present invention.","The present invention is based in part upon the realization that the accuracy of grammar checking can be improved by using a parser that assigns a stochastic measure to the parse trees it produces. Evaluation of alternative sentences or text strings is enhanced, thereby greatly improving the likelihood that any alternative sentences suggested to the user are correct. Generally, before suggesting an alternative to a sentence, the parser is run twice. The parser is first run to produce a parse for the original sentence, and then it is run a second time to produce a parse with a suggested correction. The stochastic measures of the two parses are compared and the one with the higher measure is picked as the correct sentence. In this way, suggested corrections can be double checked by the parser before being shown to the user. Further details of a grammar checking system and method employing these concepts are shown in  and are described as follows.",{"@attributes":{"id":"p-0068","num":"0072"},"figref":"FIG. 7","b":["300","310","320","310","325","330","335","340","320","345","350","300","110","200"]},"The input to system  is the original string  of text or a representation thereof. Alternative generator  receives the original input string and uses a set of grammar rules to look for what might be grammar mistakes in the string. If alternative generator  finds any potential mistakes, it generates one or more alternative versions  of the string (alternative versions \u201calt a\u201d, \u201calt b\u201d and \u201calt c\u201d are shown) and passes these alternative string versions, corresponding to possible grammatical corrections of the original string, to memory or storage . It also passes on the original string . The suggested correction alternatives , along with the original string, are collectively referred to herein as \u201cAlternatives\u201d .","Storage , which can correspond to designated memory within a computer, is used to keep track of Alternatives  (including corrected versions  and the original text string ). Storage  also stores the stochastic score associated with each of Alternatives , although at this stage it has not yet been computed. This is discussed below with reference to stochastic ranking parser .","Given Alternatives  stored in storage , parceler  calls the stochastic parser  to calculate the stochastic score for each of the strings in Alternatives . In some embodiments, parcels the Alternatives  in storage  to the stochastic ranking parser  one at a time. Parse tree producer or producing functions  generate a parse tree  for each of the text strings in Alternatives . The parse tree  for each separate text string in Alternatives  is passed to stochastic score assignor , which uses any of a variety of stochastic parse score or goodness measure generating techniques to generate a separate stochastic score  for each string (corresponding to a parse tree ) in Alternatives . After stochastic score assignment by parser  (discussed below in greater detail), grammar checker  then stores the stochastic score produced for each Alternative such that it is correlated with the Alternative in storage .","Picker  picks the Alternative from Alternatives  with the greatest stochastic score as the correct string. If the grammar checker  ends up with the original string as the most likely correct string based upon stochastic scores, then there is no grammar mistake to report to the user. If a different Alternative is picked, then the grammar checker alerts the user to this fact through some form of user interface. For example, the user can be notified of the fact that a different sentence or text string is being suggested through a graphical user interface (GUI) displayed on a monitor, liquid crystal display (LCD) or other display device.","Those skilled in the art will recognize that various other embodiments of the system  and corresponding algorithm are possible. For example, instead of storing all of the Alternatives  and then looping through the parser, one could have the alternative generator produce the Alternatives one at a time, call the parser to compute the stochastic score, and then store the results together at the same time. Another variation is to construct a lattice as input to the parser instead of calling the parser one string at a time. These and other embodiments are considered within the scope of the invention as set forth in the claims appended hereto.",{"@attributes":{"id":"p-0074","num":"0078"},"figref":["FIG. 8","FIG. 8"],"b":["300","805","365","810"]},"In block , the strings in Alternatives are enumerated and a determination as to whether there is a string to be analyzed is made at block . If a string exists which still needs to have a stochastic score or goodness measure assigned, then at block  a stochastic score is generated for the string by calling ranking parser  as described previously. As shown at block , the stochastic scores are stored along with the corresponding strings. Once there are no further strings to analyze, at block  the string having the highest stochastic score is determined and that string is selected for recommendation to the user.","The following description sets forth a specific embodiment of the ranking parser  used in an exemplary embodiment of the invention. This embodiment utilizes a particularly beneficial stochastic score or goodness measure generating method. However, the present invention can be used with any stochastic parser ranking method.","The exemplary parser  employs a goodness function to rank the possible grammatically correct parses of an utterance. The goodness function of the exemplary parser is highly accurate in representing the intended meaning of a speaker. It also has reasonable training data requirements. With this exemplary parser, the goodness measure of a particular parse is the probability of taking each transition (\u201ctransition probability\u201d) within the parse tree of that parse. Each transition probability within the tree is conditioned on highly predicative linguistic phenomena. Such phenomena include headwords, \u201cphrase levels\u201d, and \u201csyntactic history\u201d. Herein, the term \u201clinguistic features\u201d is used to generically describe transitions, headwords (including modifying headwords), phrase levels, and syntactic history.\n\nStatistical Goodness Measure The statistical goodness measure (SGM) of the exemplary parser uses a generative grammar approach. In a generative grammar approach, each sentence has a top-down derivation consisting of a sequence of rule applications (i.e., transitions). The probability of the parse tree is the product of the probabilities of all the nodes. The probability for a given node is the probability that from the node one would take a specific transition, given the syntactive features. The SGM of the exemplary parser may be calculated using either of the following equivalent formulas: \n\n\nOR . . . \n\n\nwhere\n\n","The exemplary parser defines phrase levels and labels them. Previous conventional approaches clustered transitions by segtype. For example, transitions focused on noun phrases, transitions focused verb phrases, etc. However, within each such grouping, the rules can be further subdivided into multiple levels. These levels are called \u201cphrase levels\u201d herein. These phrase levels are highly predicative of whether a transition will occur.","A null transition is utilized for each phrase level to account for no change from one level to the next. The null transition enables a node to move to the next level without being altered. The null transition is assigned probabilities just like other transitions.","The exemplary parser defines each node's syntactic history. Using the exemplary parser, phenomena that are predicative but appear elsewhere in the tree (other than simply a node's immediate decedents or ancestors) are included in the probability calculation.","The probabilities of the exemplary parser are conditioned on transition name, headword, phrase level, and syntactic history. Since the probabilities are conditioned on the transition name in the exemplary parser instead of just the structure of the rule (e.g. VP\u2192NP VP), the parser may give the same structure different probabilities. In other words, there may be two transitions with the same structure that have different probabilities because their transition names are different. The probabilities of the SGM of the exemplary parser are computed top down. This allows for an efficient and elegant method for computing the goodness function.","A training corpus of approximately 30,000 sentences can be used to initially calculate the conditioned probabilities of factors such as transition name, headword, syntactic bigrams, phrase level, and syntactic history. The sentences in this training corpus have been annotated with ideal parse trees and the annotations contain all the linguistic phenomena on which the parser conditions.","The probabilities computation method has two phases: training and run-time. During the training phase, the system examines the training corpus, and pre-computes the probabilities (which may be represented as a \u201ccount\u201d) required at run-time. At run-time, the goodness function is quickly computed using these pre-computed probabilities (which may be \u201ccounts\u201d).","Conditioning on Headwords","Consider parse trees  and  shown in . Assume the two parse trees are identical except for the transition that created the top-most VP (verb phrase). In Tree  of , the verb phrase was created using the rule:\n\nVPwNPr: VP\u2192VP NP\n\nVPwNPr is used to add an object to a verb. For example, \u201cJohn hit the ball\u201d or \u201cThey elected the pope.\u201d In Tree  of , the verb phrase was created using the rule:\n\nVPwAVPr: VP\u2192VP AVP\n\nVPwAVPr is used when an adverbial phrase modifies a verb. For example, \u201cHe jumped high\u201d or \u201cI ran slowly.\u201d\n","To determine which tree was most probable using the conventional Transition Probability Approach (TPA), the number of occurrences of VPwNPr and VPwAVPr in the corpus is counted. If VPwNPr occurred most often, the conventional TPA's goodness function would rank Tree  of highest.","This may be correct, but often it will be wrong since it will choose Tree  of regardless of the linguistic context in which the rules appear. For example, assume that the headword was \u201csmiled\u201d Parse trees  and  shown in illustrate the same parses shown in trees  and  in , but the headword \u201csmiled\u201d is noted. English-speaking humans know that Tree  of is highly unlikely. \u201cSmiled\u201d is intransitive and cannot take a direct object. In other words, \u201cShe smiled the ball\u201d is incorrect because someone cannot \u201csmile\u201d a \u201cball.\u201d Although, it is correct to say, \u201cShe smiled the most\u201d because the \u201cmost\u201d is not an object of \u201csmiled.\u201d Although \u201cthe most\u201d can act as a noun phrase in other contexts, it is an adverb in this case.","If the headword is included into the probability calculations, the goodness function is more likely to pick the correct parse. In particular, instead of just counting up all occurrences of VPwNPr and VPwAVPr in the corpus, a count is made of how often these rules appear with the headword \u201csmiled.\u201d In doing so, it likely to be discovered that there are no instances of VPwNPrl occurring with the headword \u201csmiled.\u201d Thus, the goodness function would calculate the probability of Tree  to be zero.","Phrase Level","Phrases (e.g., noun phrases or verb phrases) have a natural structure. The job of the grammar (i.e., grammar rules) is to build this structure. Because of the rules of the language and because of conventions used by the grammarian, there are constraints on how the phrasal structure can be built. This translates into constraints on the order in which the rules can be applied. In other words, some rules must run before other rules. The SGM of the exemplary parser implements phrase levels to make this set of constraints explicit. Since phrase levels are predicative of what transition can occur at each node in a parse tree, incorporating them into the goodness function makes the goodness function more accurate.","To define the phrase levels for a given segtype, rules that create the given segtype are grouped into levels. All the rules at a given level modify the segtype in the same way (e.g., add modifiers to the left). The levels are numbered from one to N. Each level contains a null transition that allows a node to move to the next level without having an effect on the phrase being built.","The analysis grammar build a phrase up by first producing an HW\u03c6 from a word. This is the head word of the phrase. It then enforces an order of levels by attaching modifiers of the headword in increasing phrase level order. For example, consider simple noun phrases in English. When building the parse tree for a noun phrase, the determiner (e.g., \u201cthe\u201d) is attached after the adjectives describing the noun. For example, \u201cthe red book\u201d is correct, but \u201cred the book\u201d is not correct. Therefore, a rule that adds a determiner to a noun phrase must come after the rule(s) that add adjectives. Again, \u201cafter\u201d is relevant to creation of a parse tree and the ordering of the application of the grammar rules. The term does not relate to the order of standard writing or reading.","For more complex noun phrases, the grammarian building a set of rules has some options. For example, consider the phrase: \u201cThe red toy with the loud siren.\u201d In one set of grammar rules, the structure may be like this:\n\n","All prepositional phrases (e.g. \u201cwith the loud siren\u201d) are attached to noun first; adjectives are attached next, and finally the determiner (\u201cthe\u201d) is added last. Once a determiner is attached to a noun phrase, it is not possible to add additional adjectives or prepositional phrases. Another set of grammar rules might structure it this way:\n\n","However, as long as a grammar clearly defines the structure of noun phrases, there exist constraints on the order of the rules. In the exemplary parser's SGM, this ordering is made explicit by adding phrase level information to the rules and conditioning our probabilities on these phrase levels.","As another example, consider the grammar shown in  that builds verb phrases. This grammar supports verbs, noun phrases, and adjective phrases, but it has been simplified and does not support a range of other valid linguistic phenomena like adverbs, infinitive clauses, prepositional phrases, and conjunctions. This grammar can parse simple verb phrases like those shown in the description column of  and complex phrases like:","\u201cMore surprising, we have all found useful the guidelines which were published last year\u201d",{"@attributes":{"id":"p-0095","num":"0109"},"figref":["FIG. 11","FIG. 12"],"i":"a ","b":["600","1","1"]},"As shown in the table of , on the right-hand side of each rule, each constituent is associated with a particular phrase level that is required for that constituent. Specifically, the number in parenthesis indicates the phrase level of the constituent (e.g., \u201cVP()\u201d).","On the left-hand side of the rule, the phrase level of the resulting node is specified. For example, consider the null transition:\n\nVP()\u2192VP()\n","This null transition can be applied to a VP at phrase level three and create a VP at phrase level four.","\u201cPL_Max\u201d in a phrase level indicator means the highest phrase level that occurs for a given segtype. For example, for the grammar above VP (PL_Max) would be the same as VP(). As another example:\n\nVPwNPl: VP()\u2192NP(PL_Max) VP()\n\nThis means that the rule can be applied to an NP that is at the highest NP level and to a VP that is at level three. The result of running the rule is to create a VP at level four.\n","Sometimes the phrase level of a constituent of the same segtype is the resulting node and may be either at the phrase level of the resulting node of less than then phrase level of the resulting node. For example:\n\nPerfect: VP ()\u2192VP() VP(,)\n\n","To see an example of null transitions, consider the phrase:\n\n","Notice that this phrase differs from the similar phrase used above in that \u201c . . . we have all found useful . . . \u201d has been simplified to be \u201c . . . we found useful . . . \u201d","The rule VpwNul at transition null requires the second constituent to have PL. Because the constituent has PL we construct a null transition first.",{"@attributes":{"id":"p-0104","num":"0122"},"figref":["FIG. 11","FIG. 11"],"i":["b ","b"],"b":["610","612","2","3"]},"The phrase levels and null transitions of the exemplary parser models the grammar of the English natural language. For example, consider the noun \u201cnut.\u201d You would never see a sentence such as \u2018I want nut.\u2019 or \u2018Nut is on the table.\u2019 The word \u201cnut\u201d wants a determiner such as \u201ca\u201d or \u201cthe\u201d. The phrase levels and null transitions force the exemplary parser to explicitly consider the absence of modifiers, as well as their presence.","Syntactic History","A node's syntactic history is the relevant grammatical environment that a node finds itself in. It may include the history of transitions that occur above the node. For example, is the node below a NREL, PRPRT, PTPRT, RELCL, or AVPVP? It may include whether the node is in a passive or an active construction. It may include information that appears elsewhere in the tree. For example, whether the headword of a sibling node is singular or plural. The specifics of what it relevant is dependent upon the specifics of the grammar (i.e., rewrite rules or transitions) being used.","For example,  shows two parse trees,  and , for the same verb phrase. Both trees are parsing a verb phrase having the mono-transitive headword (hw=\u201chit\u201d) and the verb phrase is known to be passive (sh=passive). In tree , the verb has a direct object as represented by NP at . In tree , the verb does not take a direct object.","In English, a mono-transitive verb inside a passive construction does not take a direct object. In contrast, when in the active form, the mono-transitive verb \u201chit\u201d takes a direct object. For example, \u201cI hit the ball\u201d in the active form has a direct object \u201cball\u201d to the verb \u201chit\u201d, but \u201cthe ball was hit\u201d in the passive form has no direct object to \u201chit.\u201d English-speaking humans know that tree  will never occur. In other words, there is a zero probability of a mono-transitive verb (like \u201chit\u201d) taking a direct object when the sentence is passive.","In the exemplary parser, the transition probabilities are conditioned on syntactic history as well as headwords. Using a training corpus, the exemplary parser counts up how often VPwNPr occurs in a passive construction with a mono-transitive verb and finds that it never occurs. Thus, the probability of Tree  would be calculated to be zero.","Syntactic history can be propagated down many levels of the tree. Take, for example, the sample sentence, \u201cGraceland, I love to visit.\u201d The thing (\u201cGraceland\u201d) that \u201cI\u201d love to visit is stated before it is revealed the \u201cI\u201d loves to visit anything.  shows an annotated parse tree  of a parse of this sample sentence. As can be seen in , the \u201ctopicalization\u201d feature is propagated past the verb \u201clike\u201d to the verb \u201cvisit.\u201dA complete discussion of syntactic phenomena which can be incorporated into syntactic history is not provided here, but the concepts of syntactic phenomena are well known by linguists.","SGM of the Exemplary Parser","The SGM (statistical goodness measure) of the exemplary parser uses a generative grammar approach-each sentence has a top-down derivation consisting of a sequence of rule applications (transitions). The probability of a parse tree is the product of the probabilities of all the nodes within that tree.","Generally, the probability of a node is defined as a conditional probability:\n\nProb(node)=Prob(what_is_unknown|what_is_known)\u2003\u2003Formula 1\n\nAssume that each node is visited in a depth-first tree walk. What is known is the information associated with the node and\/or with any node previously encountered in the tree walk. For example, the properties of the node, it is headword, phrase level, syntactic history, and segtype. What is unknown is what occurs below the node (i.e., the transition taken and the properties of its children).  shows a portion of a parse tree  and visually illustrates what is known and unknown at a node . What is known is above line  because it has already been processed. Below line  is what is unknown because it has not been processed.\n","With reference to the parse tree  of , the conditional probability of exemplary parser is: \n\n\nwhere nranges over all nodes in the tree and the transition named by trn(n) is of the form X\u2192Y Z or of the form X\u2192Y.\n","To simplify Formula 2, it is noted that not all the parameters are independent. In particular, trn(n) and pl(n) imply pl(n) and pl(n). In other words, the name of the transition and the phrase level at node X implies the phrase levels of nodes Y and Z. Therefore, pl(n) and pl(n) may be removed from the left-hand side of the formula: \n\n","Similarly, Formula 3 may be simplified because trn(n), hw(n), and sh(n) imply sh(n) and sh(n). In other words, the name of the transition, the headword, and the syntactic history at node X implies the syntactic history of nodes Y and Z. Therefore, sh(n) and sh(n) may be removed from the from the left-hand side of the formula: \n\n","Formula 4 may be further simplified. Tracking both hw(n) and hw(n) is not particularly valuable because one of them is the same as hw(n) The one that is not the same is the modifying headword. The notation modhw(n) to refer to this modifying headword. This yields: \n\n","Formula 5 may be simplified still further by applying the chain rule (as understood by those skilled in the art of statistics), yields this: \n\n","Since trn(n) implies pl(n) and segtype(n), the Formula 6 can further simplify this to be: \n\n","Finally, since it has been found that sh(n) is not very predicative of what the modifying headword will be, Formula 7 can be approximated by removing sh(n) from that part of Formula 7: \n\n","Notice that Formula 8 above is Formula B recited near the beginning of this detailed description.","PredParamRule Probability and SynBigram Probability","As described above, the probability of a parse tree is the products of the probabilities of each node. The probability of each node is the product of two probabilities. Thus, the SGM probability formula for a single node in a tree may be rewritten like this:\n\nProb(trn(n)|hw(n), pl(n), sh(n), segtype(n)) Prob(modhw(n)|trn(n), hw(n))\u2003\u2003Formula 9 (SGM probability at a given node X)\n\nwhere X ranges over all the nodes in the parse tree.\n\nThis represents the statistical goodness measure (SGM) of the exemplary parser. This may be divided into to two parts. For convenience, the first probability will be called the predictive-parameter-and-rule probability or simply \u201cPredParamRule Probability\u201d and the second probability will be called the \u201cSynBigram Probability\u201d.\n\nThe PredParamRule Probability is:\n\nProb(trn(n)|hw(n), pl(n), sh(n), segtype(n))\u2003\u2003Formula 10 (PredParamRule Probability)\n","Unlike the Simple Content Dependent Approach (described above in the background section), the PredParamRule Probability of the exemplary parser conditions upon headword, segtype, phrase level, and syntactic history. Since these are highly predicative of the contextually correct parse, this PredParamRule Probability is a significantly more accurate goodness function than conventional techniques.","The SynBigram Probability is:\n\nProb(modhw(n)|trn(n), hw(n))\u2003\u2003Formula 11 (SynBigram Probability)\n\nThe SynBigram Probability computes the probability of a syntactic bigram. Syntactic bigrams are two-word collocation. The probability a measure of the \u201cstrength\u201d of the likelihood of a pair of words appearing together in a syntactic relationship. For example, the object of the verb \u201cdrink\u201d is more likely to be \u201ccoffee\u201d or \u201cwater\u201d than \u201chouse\u201d.\n","As described above in the background section, this is a conventional technique to calculate a goodness measure. However, with existing conventional syntactic bigram approaches, it is used alone to calculate the goodness function and it requires a huge training corpus. The exemplary parser overcomes the limitations of conventional syntactic bigram approaches by further conditioning the goodness measure on independent probability characteristics. In particular, those characteristics are represented by the PredParamRule Probability formula (Formula 10).","As a review, the following is a known about calculating conditional probabilities by counting appearances in a training corpus: \n\n","Therefore, the PredParamRule Probability and the SynBigram Probability can be calculated by counting the appearances of relevant events in the training corpus. The probabilities of a given training corpus that are determined by the PredParamRule Probability and the SynBigram Probability may be generally called \u201clanguage-usage probabilities\u201d for that given training corpus.","Thus, the PredParamRule Probability formula (Formula 10) may be calculated as follows: \n\n\nMoreover, the SynBigram Probability formula (Formula 11) may be calculated as follows: \n\n\nTwo Phases of SGM Calculation\n","Typically, a parser of an NLP system (such as the exemplary parser) is designed to quickly calculate the goodness measure for many parse trees of parses of a phrase. To accomplish this, the exemplary parser is implemented in two phases: \u201ctraining\u201d and \u201crun-time.\u201d","During the training phase, the exemplary parser pre-calculates the counts that are needed to compute the PredParamRule Probability and the SynBigram Probability at run-time. Although this process tends to be time-consuming, processor-intensive, and resource-intensive, it only need be once for a given training corpus.","The result of the training phase is a set of counts for headword, phrase level, syntactic history, and segtype. If the training corpus approximates the natural language usage of a given purpose (general, specific, or customized), then the counts also approximate the natural language usage for the same purpose.","At run-time, these pre-calculated counts are used to quickly determine the probability of the parse tree. Each phrase is parsed into multiple parse trees. Each parse tree is given a SGM based upon the pre-calculated counts.","Alternatively, the training and run-time phase may be performed nearly concurrently. The training phase may be performed on a training corpus (or some subset of such corpus) just before the run-time phase is performed. Those who are skilled in the art will understand that time and space trade-offs may be made to accommodate the given situation. Regardless, the training phase (or some portion thereof) is performed, at least momentarily, before the run-time phase. This is because the training phase provides the foundation for the run-time phase to base its SGM calculations.","Although the present invention has been described with reference to particular embodiments, workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention. For example, references to a string of text being stored or acted upon should be understood to include various representations, such as parse trees, of the string of text."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0035","num":"0039"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0036","num":"0040"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0037","num":"0041"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0038","num":"0042"},"figref":"FIGS. 4","i":["a ","b "],"b":"4"},{"@attributes":{"id":"p-0039","num":"0043"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0040","num":"0044"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0041","num":"0045"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0042","num":"0046"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0043","num":"0047"},"figref":"FIGS. 9","i":["a ","b "],"b":"9"},{"@attributes":{"id":"p-0044","num":"0048"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0045","num":"0049"},"figref":"FIGS. 11","i":["a ","b "],"b":"11"},{"@attributes":{"id":"p-0046","num":"0050"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0047","num":"0051"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0048","num":"0052"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0049","num":"0053"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
