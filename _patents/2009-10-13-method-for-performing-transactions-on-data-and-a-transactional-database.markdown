---
title: Method for performing transactions on data and a transactional database
abstract: The present invention provides a method for performing transactions on data entities in a database and a transactional database. The database comprises an ordered set of data stores with at least one static data store, wherein said static data store uses an index structure based on a non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices. The method allows to generate a modifiable data store when the performed transaction comprises an insert, update or delete operation, to execute operations of the transaction on the ordered set being present at the time when the transaction has been started and, if present, on the modifiable data store and to convert data stores to a new static data store, The insert, update or delete operation are executed on the modifiable data store which is the only data store modifiable for the transaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09026538&OS=09026538&RS=09026538
owner: Open Text S.A.
number: 09026538
owner_city: Luxembourg
owner_country: LU
publication_date: 20091013
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND ART","SUMMARY OF INVENTION","DESCRIPTION OF EMBODIMENTS"],"p":["The invention generally relates to database technology. In particular, the invention relates to a method for performing transactions on a database, and a database. More particular, the invention relates to a method for performing transactions on a database providing support for natural language text attributes and a database providing sufficient support for natural language text and transactional capabilities on natural language text.","Persistence stores (databases) as generally known in the art have been specifically designed for specific application domains. For example, relational databases (RDBs) started off being optimized for on-line transactional processing (OLTP) applications, and on-line analytical processing (OLAP) engines were optimized for decision support systems (DSS). To some degree RDBs have evolved to also support DSS applications, but specialized engines still dominate in that domain.","Relational databases (RDBMSs) are the dominant form of commercial databases available today. The key advantage of RDBMSs is a declarative query language that provides flexibility in expressing unanticipated access paths. Although the commercial RDBs have attempted to become \u201cuniversal databases\u201d usable with each application domain, they have been developed and were optimized for OLTP type applications that have very simple and restrictive data modelling needs and a particular pattern of updates and accesses that are not necessarily applicable to other application domains.","Thus, RDBMS used with OLTP systems do neither provide adequate support for rich flexible data models nor for full text and natural language.","Furthermore, XML databases are known in the art which are based on the concepts of the extensible markup language (XML) used to for document markup. Certain enhancements introduced in XML have been proposed in the art to use XML as a general model for a serialized representation of arbitrary data structures for communication or storage purposes. It has been observed that a means to query data modelled in XML and directly producing XML within a query could reduce some of the issues with the relational models (e.g., the rigid structures for both application modelling and the result structures). A big difference with the XML databases is the use of a similar declarative query specification, even though there is still a primary hierarchical access view.","XML\/RDF (resource description framework) databases (e.g., graph databases) are typically implemented on top of relational databases. Support for natural language is thus missing. Therefore, a performance penalty is the result.","The last relevant category of database systems are those built around a graph data model. As is the case with the XML databases these are relatively immature systems in many areas compared with relational systems. However, they have the advantage of not being restricted by the need to support the large legacy of those commercial systems.","Further models include full text systems and specific OLAP systems. However, the full text systems neither support rich flexible data models nor transactions and the OLAP systems neither support full text\/natural language specific things nor transactions and also no flexible data models which would imply at least the possibility to delete\/change entities.","Transactional persistence stores such as described above rely heavily on a single logical disk based updatable data structures for their value and index storage. All reads during query evaluation primarily access this store. Throughout the transactions any changes made to the global store are seen by the transaction. They work either by writing directly in place to the updatable structures during the transaction and maintaining information to roll back these changes in the event of transaction failure, or by keeping structures for the effect of changes in a transaction in parallel to the global state of the database system. After or when the transaction is committed the changes are made to the updatable structures. In the latter case the union of the disk based structure and the changes are seen by the transaction reads.","Database systems as known in the art usually have three primary disk based storage structures such as persistent transaction logs that are required for recovering from system failure, value stores that contain the current state of the system, and indices that support accelerated evaluation of certain queries. There is, particularly, a broad range of structures that have been developed for the values stores and the indices. In the following, the significant options for value stores and indices such as known in the art will be exemplified.","In general, value stores maintain the state information about the entities and relationships stored in the persistence system. There are two primary forms known in the art for maintaining this state: a row oriented approach or a column oriented approach.","Known relational databases systems have a data model of a set of relations that are highly regular structures. Typically, such systems store each of these tables in rows major order with each row residing in single physical disk pages. In the event that a projection or query evaluation operation only needs to access the elements contained in a single row that row can then be accessed with a single logical Input\/Output (IO) operation. Much of the effort in developing such systems has concentrated on attempting to allow many of these accesses to get their information from main memory buffers, avoiding the need for corresponding physical IOs. However, each entity that does not fit within a page will often require additional access during evaluation or projection. This is often the case with enterprise content management (ECM) data in which the entity types do not map well to a simple relational schema, and there are large textual fields that cause even single entities to overflow the space available in single disk pages.","With row oriented stores where full table scans are required during query evaluation (e.g., if there is a predicate on a table for which there is no corresponding index) much IO may be spent on retrieving data that is not required to perform the evaluation. This is generally sequential IO which has a significant performance advantage over random IO. The advantage is large enough that even in the event that an index does exist to support a particular predicate, the table scan may still be more efficient than the use of the index if that would lead to large numbers of random row accesses. This is particularly the case when there is more than one predicate on the same table, one with an index and one without. The information retrieved may also potentially pollute the memory buffers used by the system to avoid other IOs. Much prior art has been developed in the areas of query optimizers and buffer management to mitigate these problems, but there are still situations in which these problems surface.","Another area that has been explored for reducing the intrinsic IO costs noted above involves using various row oriented compression mechanism. The effectiveness of these approaches is constrained by the need to randomly access individual rows. This generally limits the approaches to the use of simple stochastic models yielding compression rates on the order of 2 or 3 to 1.","A further issue with row oriented approaches when dealing with flexible schema structures is that they can result in very sparse relations, with many cells containing NULL values to indicate that the corresponding entry is not set. Again, there has been much work on addressing the costs of such NULLs in the context of row oriented stores, however the cost can still be significant.","Column oriented value stores are often used in OLAP type systems that want to perform aggregation operations on individual fields. For entities with large numbers of attributes the IO requirements for such aggregations can be significantly reduced relative to retrieving all rows in a row oriented value store and pulling out the needed field. However, a column orientation can be very expensive, relative to a row oriented store, for non-memory resident data sets to do projection of large numbers of attributes. To counteract this there are often more compression options available than for row oriented stores.","Another problem that arises with column based stores is the need to update each column for each attribute that is involved in any update. The batch based update mechanism employed by many of the systems that use column oriented value stores gets around these problems but eliminates the ability to perform online transactional updates. For applications, that have flexible schemas, or schemas with many entities with large numbers of attributes, but generally project a relatively small subset of those fields, a materialized view row orientation (that can be seen as a hybrid of row and column orientation) can yield the best performance.","Most specialized text search engines concentrate on their index structures rather than their system state. However, one common projection requirement for text engines is a presentation of what are known as dynamic summaries. The dominant mechanisms for producing such summaries involve the retrieval of the entire document content from some stored form and either a scan of the document looking for some sentences (or passages) that are most relevant to the query, or using location information produced by the indexing system to select some character sequences that contain the text that is most relevant. The latter approach requires the indexing system to identify such sequences which is often not available when document level statistical relevance ranking approaches are employed. For their metadata these text engines employ a general row or column based approach.","Indices are redundant representations of the information in the value stores that support accelerated performance of certain operations, typically selection or filtering but indices have also been specified to accelerate operations such as joins and grouping and aggregation. Filtering indices are basically mappings from one or more keys to the set of entities that match that key in some fashion. Join indices identify pairs of entities that satisfy some join condition. Projection and bit mapped indices are often used to support grouping and aggregation operations.","There are a few important characteristics to be considered for filtering indices. The characteristics are: Does the index cover the entity set with respect to its keys, is the key set disjoint or overlapping, and is the index augmented or a multi-levelled? These characteristics will be described next in more detail.","With respect to the coverage of the entity set, a non-covering index would probably be a lot smaller than a corresponding covering index.","For a disjoint key set query predicates that correspond to multiple keys (e.g., a range predicate over an index in which each key corresponds to a unique value) will need to perform the union of the portions of the index corresponding to each involved key. In overlapping indices query predicate may be constrained by some logical combination of keys. For example a date range index could have keys for individual days, weeks, months and years. The entries for a particular week would be the union of the entries for the days in that week, but the evaluator can avoid the cost of doing the union at query time by using the appropriate week key. Such indices are redundant and so incur both a space and maintenance cost, but for certain predicates this may be worth the expenditure.","Augmented or multi-level indices in which the keys identify the entities that satisfy some predicate, and some form of auxiliary information or auxiliary index supports the identification of subsets of those entities that satisfy some finer grained predicate. For example, some index could identify that some word xyz occurred in one of the attributes of an entity. If such predicates were common this could be a useful index. However, there may also be predicates that are looking for xyz only within attribute A. If this were also common, but less so than the attribute agnostic predicate one could augment the index entries with the identification of the attribute(s) of the entity in which the word occurred, or provide subset indices for particular attributes that provided the same information.","The most common filtering index structure in standard databases is the known BTree which has many variants. The BTree supports log time random updates, although the base of the log with respect to page access (and correspondingly logical IO accesses) is generally very high, and a relatively small main memory \u201ccache\u201d of at least the top levels of the tree can limit average numbers of IOs per random access request to 1 or even lower. However, committing information to the persistence store will require physical writes of all affected pages (usually 1). In some systems such physical updates are postponed to a batch type process, while an in-memory structure maintains the information on the changes since the last batch run. The row\/entity references associated with each key can be either logical or physical addresses of the location of the row. Logical addresses provide an additional degree of freedom in re-arranging the referenced entities. BTrees efficiently support both equality and to some degree range predicates. The latter generally requires some re-ordering of the addresses, if there are other predicates for which there are indices or if the corresponding rows need to be retrieved, to avoid disk thrashing.","Among the common variants\/implementations of BTrees is a compressed version that takes advantage of the ordering to avoid fully representing the values that repeat between consecutive rows. This can significantly decrease the space needed for an index relative to a na\u00efve representation and provide corresponding increases in the hit rate for a given amount of main memory available to cache the index pages. A variant that is sometimes used with indices over entities with small numbers of fields (e.g., 2-4) is to use the compressed BTree index as the value representation for the extent\/table. Recent results have used dictionaries to map the keys in the index tuples into integers identifying elements in some dictionary. This mechanism can further reduce the space costs of the index, with a trade-off of some potential additional cost in maintaining and using the dictionaries.","Other filtering index types are generally optimized for specific data types and the common predicates on such types where these are poorly supported by BTree indices. For example, geographic region types and predicates for overlap and containment are supported by options such as KDTrees.","Inverted indices are primarily used to support fine grained predicates on potentially large textual values. In full text engines such indices also maintain auxiliary information needed to support a fuzzy evaluation of the \u201crelevance\u201d of an entity to a query and some form of phrase or proximity checking. These indices generally produce large numbers of index points for each entity. Although the contents of such indices are similar to the compressed BTree indices with appropriate fields, the large numbers of index points associated with each entity mean that the update costs of individual BTree index entries is generally too expensive. These systems generally then use batch update mechanisms and do not support traditional database concurrency control. In an inverted index the set of entity references associated with a particular key are referred to as the postings list for that key.","With respect to transaction management as known in the art there is a logical view of the isolation between process and the mechanisms used to implement this isolation. According to the prior art, the isolation possibilities are partitioned into four levels: serializable, repeatable read, read committed, and read uncommitted. The implementation mechanisms are generally divided into pessimistic and optimistic concurrency control. The potential concurrency supported generally increases as one descends the isolation levels at the cost of introducing inconsistencies in the database. Pessimistic implementations generally use some form of locking and updates are applied directly to a single updatable store. All transactions read from this single store, and isolation is generally achieved by some appropriate form of locking. Optimistic mechanisms have each transaction maintain some form of lookaside copies of some of the database state, including at least the changes made in that transaction. On commit these changes are checked against conflicts with changes made by other transactions that have been committed. If the check indicates no conflicts the corresponding changes are made to the updatable on-disk data structures that store the current database state. If there is any conflict the transaction is forced to rollback, although that is cheap since it merely involves dumping the lookaside. The costs associated with the lookaside and the conflict resolution depend on the isolation level. In those applications which have a low probability of conflict the optimistic mechanism can be much more efficient than the pessimistic one, although the reverse can be true when there is a high probability of conflict.","It is a first object of the present invention to provide a method allowing to perform transactions on a database and a transactional database, to store large amounts of data irrespective of their type and to execute operations of said transactions with high performance and low costs also in the case of large amounts of data.","It is a second object of the present invention to store the data in the database in a compact form and to provide a flexible data model allowing to vary stored data on a data entity basis.","Further objects of the present invention are to provide a method allowing to perform the transaction on a database providing support for natural language text, perform the transaction one multiple data stores ensuring the consistency of data, and further reduce the semantic gap between data and queries.","The first object is achieved according to an embodiment of the present invention by a method for performing transactions on data entities in a database. Each transaction comprises one or more query, projection, insert, update, and\/or delete operations. The database comprises an ordered set of data stores with at least one static data store for storing data entities and performing queries on said data entities. The static data store uses an index structure which is based on a non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices. Each of said data entities comprises a unique identifier and a plurality of fields each containing a single or multi valued value. The method comprises for a transaction the steps of: determining the current ordered set of data stores when said transaction is started, storing information of said current ordered set of data stores as transactional state for said transaction. When said transaction comprises an insert, update or delete operation, the method further comprises generating a modifiable data store and adding said modifiable data store as newest data store to said transactional state for said transaction, wherein said modifiable data store is adapted to store data entities and to perform queries on said stored data entities, executing said one or more operations of said transaction on the data entities in the data stores of which information has been stored in said transactional state. When said transaction is committed and if said modifiable data store has been generated for said transaction, the method further comprises adding said modifiable data store as newest data store to said ordered set of data stores. When one of said one or more operations of said transaction is a query operation with a query, said step of executing comprises performing said query against each of said data stores of which information has been stored in said transactional state, wherein said query returns ordered identifiers of data entities for each of said data stores that match with said query, masking for each of said data stores those of said returned ordered identifiers for which a data entity with the same identifier already exists in a newer data store, uniting said masked identifiers and returning said united identifiers. When one of said one or more operations of said transaction is an insert operation for inserting a new data entity, said step of executing further comprises writing said new data entity in said modifiable data store, wherein a new unique identifier is used as identifier for said new data entity. The method further comprises converting one or more selected data stores of said ordered set of data stores to a new static data store, wherein said converting step further comprises: reading all data entities from said one or more selected data stores, masking for each of said one or more selected data store said read data entities for which a data entity with the same identifier already exists in a newer data store of said ordered set of data stores, merging said masked data entities, building a new index structure using the identifiers of said merged data entities for said new static data store, wherein said new index structure is based on said non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices, writing said merged data entities into said new static data store, adding said new static data store to said ordered set of data stores and deleting said one or more selected data stores from said ordered set of data stores.","Thus, the present invention provides a database (persistence store) that supports update and query mechanisms against a flexible data model, particularly an entity\/relationship (ER) model, by supporting data entities having a plurality of fields each containing a single or multi-valued value.","The present invention also achieves to reduce the semantic gap between applications operating on the database by transactions and the database (persistence store data model) and query views by the steps of performing the transaction. Such a reduction simplifies the process of developing applications that rely on scalable and transactional persistence stores. The present invention thus efficiently supports transactions with a read consistent isolation level and provides ACID properties in the context of transactions that often contain data that produce large numbers of random value or index update points by the provision of the transactional state and the modifiable data store.","The invention furthermore provides an efficient concurrency control mechanism that exploits the transactional characteristics of the applications by the transactional state and the modifiable data store. In detail, commit time costs (i.e., time needed to commit a transaction) are minimized by creating a new modifiable data store as read only store and maintaining the global state of the database as an ordered set of data stores which may be memory resident or disk resident. The read only nature of these data stores achieves to minimize their space and access costs.","The method according to the present invention also allows to store data in the database in a compact form using said non-updatable index structure wherein said non-updatable index structure facilitates that query operations are performed in a suitable short period, even when the data amount stored in said database become large, and allows to update the data stored in said static data store using said compact form in a manner complying with known transactional criteria. Furthermore, the method provides a new isolation level for transactions wherein the data to be seen by the transaction is read consistent which means that the state of data actual at the time when a transaction is started is remained constant for said transaction until the transaction changes the state of data.","According to an embodiment of the present invention, when one of said one or more operations of said transaction is a projection operation for reading at least one field of an existing data entity of which the identifier is one of the identifiers returned by said query operation, said step of executing may further comprise reading said single or multi valued value in said at least one field of said existing data entity, returning said single or multi valued value.","Therefore, the method facilitates to return by masking only the newest instance of queried data entity fields from the database, irrespective whether and how often the data entity field has been changed. That is, the internal storage of data entities in static or modifiable data stores are efficiently hidden from the querying user or application such that the user or the application only see, at each time, the newest (present) instance of the queried data entity field which has been committed prior to the transaction started by the user or the application. Thus, the method provides data consistency for the query results.","According to an embodiment of the present invention, when one of said one or more operations is an update operation for updating at least one field of an existing data entity of which the identifier is one of the identifiers returned by said query operation, said step of executing may further comprise executing said projection operation for reading at least those fields of said existing data entity not to be updated, writing a new data entity corresponding to said existing data entity in said modifiable data store, which comprises the fields of said existing data entity not to be updated, said at least one updated field and said identifier of said existing data entity as identifier of said new data entity.","Thus, the method allows to update existing data entities without the need to change instances of said data entities being stored in prior static or modifiable data stores, rather storing updated data entities in the modifiable data store generated for the transaction whereby the update operation can be executed with low costs.","According to an embodiment of the present invention, when one of said one or more operations is a delete operation for deleting at least one field of an existing data entity of which the identifier is one of the identifiers returned by said query operation, said step of executing may further comprise executing a projection operation for reading at least those fields of said existing data entity not to be deleted, writing a new data entity corresponding to said existing data entity in said modifiable data store, which comprises the fields of said existing data entity not to be deleted, and said identifier of said existing data entity as identifier of said new data entity.","The method facilitates the deletion of several fields of existing data entities without changing the non-updatable index structure or the storage of the existing data entities in prior static or modifiable data stores and thereby the deletion operation can be performed in shorter time compared to that according to the above mentioned prior art systems.","According to an embodiment of the present invention, when one of said one or more operations is a delete operation for deleting an existing data entity of which the identifier is one of the identifiers returned by query operation, said step of executing may further comprise writing a new data entity corresponding to said existing data entity in said modifiable data store, which comprises a marker and said identifier of said existing data entity as identifier of said new data entity, wherein said marker indicates that said corresponding existing data entity is deleted.","By writing said data entity to be deleted into said modifiable data store, the delete operation can be executed with low costs due to not changing the index structure or the read-only data stores of the transactional state.","According to an embodiment of the present invention, the method may further comprise deleting said one or more selected data stores which have been deleted from said ordered set of data stores.","The method facilitates to efficiently use resources of a computer system, on which the method is executed, whereby, for example, disc space of a hard drive incorporated in said computer system may be freed by deleting unused data stores.","According to an embodiment of the present invention, each of said static data stores may further comprises at least one mask containing identifiers of data entities to be used in said masking step of said query operation and said converting step, wherein those returned identifiers are masked for which the same identifier exists in said at least one mask of said newer data store, and said converting step further comprises: generating said at least one mask containing at least those identifiers of the merged data entities which do not occur in data stores older than said one or more selected data stores.","The method allows to further speed up the query operations according to the embodiments herein defined since the pre-generated mask can be used to mask the identifiers instead of to perform separate query in each of the data stores.","According to an embodiment of the present invention, said database may support natural language text and at least one of said plurality of fields of said data entities comprises a natural language text value containing a plurality of words.","The meritorious effects of the method according to the present invention additionally emerges when the data stored in the database is of natural language text such as complete content of written documents or the documents itself along with additional information such as meta information since such data can be handled irrespective of their specific type with the same performance as compared to, for instance, single value integer data entities. The semantic gap is further reduced by including the support for natural language full text values and both crisp and fuzzy query mechanisms.","According to an embodiment of the present invention, said database may further comprise a dictionary including a mapping from words to wordindices and said new index structure is built on a field of said data entities, wherein said field comprises said natural language text value, and said step of building the new index structure further comprises: mapping a word of said natural language text value to a corresponding wordindex using said mapping of said dictionary, mapping a pair comprising said wordindex and an identifier of a merged data entity to an integer of said ordered set of integers, if said new static data store contains said data entity and said field containing said word or a form of said word.","The method allows to store data in said compact form since only said wordindices need to be stored in the data stores instead of complete words or word combinations. Thus, the capacity of storage media comprising the data stores can be utilized efficiently.","According to an embodiment of the present invention, said new index structure may further comprise blocks of consecutive integer entries of said ordered set of integers and a search tree, wherein each of said blocks contains a predefined number of chunks each having a predefined number of integer entries, and said step of building said new index structure further comprises: partitioning said ordered set of integers into blocks comprising a number of N\u00d7M integer entries, wherein N is said predefined number of chunks and M is said predefined number of integer entries, partitioning each of said blocks into chunks of said predefined number of integer entries, computing deltas of consecutive integer entries in each of said chunks, determining the maximum of said deltas and computing an entry-size from said maximum, wherein said entry-size is the size needed to write said maximum in an entry, consecutively writing said deltas in entries having said entry-size, storing the offset of each of said chunks and its starting value in the header of the corresponding block, building said search tree having a node for each of said blocks, wherein said node consists of a value of the first integer entry in said block and a pointer to the position where said block starts.","The index structure based on a non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices allows to store the data in the static data store and indices thereto in a compact form and facilitates that search operations for indices in said index structure can be executed with good performance and low costs.","According to an embodiment of the present invention, said step of converting may further comprise storing each of said identifiers of said data entities stored in said new static data store and an unique subset identifier provided in said new static data store which is mapped to said identifier in a store subset provided in said new static data store, storing a field name for each of said fields of said data entities stored in said new static data store and an offset associated with each field name in a field map provided in said new static data store, and storing said single or multi valued value of each of said fields of said data entities stored in said new static data store which are designated by the same field name in a field store provided in said new static data store, wherein said offset defines the position of said field store in said new static data store.","The method according to the above embodiment achieves additional compact storage of data in said static data store since the identifiers stored in association with the fields of the data entities can be kept small even in the case when the number of data entities stored in the database and thus, the unique identifier provided in the database for each data entity is large.","According to an embodiment of the present invention, each of said data stores may be adapted to store relations between data entities, wherein a relation comprises an unique identifier and a plurality of fields each including one or more identifiers of said data entities which are included in said relation.","Since the relations between data entities are handled by the method in the same way as data entities only consisting of values, the same meritorious effects as described with respect to compact storage of said data entities and the ability to perform transactions according to the present invention are also present with respect to the relation. Thus, the capabilities of the database, on which the transactions according to the above method are performed, are advanced towards a compact and flexible entity-relations-database.","According to an embodiment of the present invention, said query operation may support full text query and\/or said query operation provides crisp and fuzzy query evaluation.","Especially with respect to natural language text data wherein different forms of words may occur, results of query operations comparing given words to be queried with stored words are improved since also those forms of stored word are found as results of the query operations which are not identical but similar to the given words. The semantic gap is further reduced by including the support for both crisp and fuzzy query predicates.","According to an embodiment of the present invention, said database may further comprise a query language, wherein each query operation uses said query language to define queries based on navigational expressions along relations, Boolean predicates, crisp and natural language text predicates, and combinations thereof.","It is advantageous to provide a query language within a database and used to perform transactions on the database wherein the form and structure of said operations are predefined and formalized since operations of transaction being defined using the query language can be easily evaluated and performed.","According to an embodiment of the present invention, when one of said one or more operations of said transaction is an insert, update or delete operation, said step of executing may further comprise: storing said insert, update or delete operation in a transactional log provided in said database, wherein said transaction log corresponds to said modifiable data store on which said insert, update or delete operation is executed.","The method provides a mechanism which allows to re-execute, in a case of loss or damage of the modifiable data store on which operations have been performed, those of the operations which have been performed prior to the loss or damage. Thus, the method improves the durability of the data stored in the database.","According to another embodiment of the present invention, a database is provided which comprises an ordered set of data stores with at least one read-only static data store adapted to store data entities and to perform queries on said data entities, wherein said static data store uses an index structure which is based on a non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices, wherein each of said data entities comprises an unique identifier and a plurality of fields each including a single or multi valued value, means for controlling transaction, wherein each transaction comprises one or more query, projection, insert, update, and\/or delete operations, and means for converting one or more selected data stores of said ordered set of data stores to a new static data store. The means for controlling transaction is adapted to perform for a transaction the steps of determining the current ordered set of data stores when said transaction is started, storing information of said current ordered set of data stores as transactional state for said transaction, when said transaction comprises an insert, update or delete operation, generating a modifiable data store and adding said modifiable data store as newest data store to said transactional state for said transaction, wherein said modifiable data store is adapted to store data entities and to perform queries on said stored data entities, executing said one or more operations of said transaction on the data entities in the data stores of which information has been stored in said transactional state, when said transaction is committed and if said modifiable data store has been generated for said transaction, adding said modifiable data store as newest data store to said ordered set of data stores. When one of said one or more operations of said transaction is a query operation with a query, said means for controlling transaction is further adapted to perform said step of executing by performing said query against each of said data stores of which information has been stored in said transactional state, wherein said query returns ordered identifiers of data entities for each of said data stores that match with said query, masking for each of said data stores those of said returned ordered identifiers for which a data entity with the same identifier already exists in a newer data store, uniting said masked identifiers and returning said united identifiers. When one of said one or more operations of said transaction is an insert operation for inserting a new data entity, said means for controlling transaction is further adapted to perform said step of executing by writing said new data entity in said modifiable data store, wherein a new unique identifier is used as identifier for said new data entity. The means for converting one or more selected data stores of said ordered set of data stores to a new static data store, wherein said means for converting is adapted to perform the steps of: reading all data entities from said one or more selected data stores, masking for each of said one or more selected data store said read data entities for which a data entity with the same identifier already exists in a newer data store of said ordered set of data stores, merging said masked data entities, building a new index structure using the identifiers of said merged data entities for said new static data store, wherein said new index structure is based on said non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices, writing said merged data entities into said new static data store, adding said new static data store to said ordered set of data stores and deleting said one or more selected data stores from said ordered set of data stores.","The database according to this embodiment allows to store data in a compact form using said non-updatable index structure wherein said non-updatable index structure facilitates that query operations are performed in a suitable short period, even when the data amount stored in said database become large, and allows to update the data stored in said static data store using said compact form in a manner complying with known transactional criteria.","The means for controlling transaction and the means for converting of the above embodiment may further be adapted to perform the steps according to the above described embodiments of the method.","Further embodiments of the present invention provides a computer program which, when executed on a computer, adapts said computer to perform the methods according to embodiments of the present invention, and a storage medium, on which said computer program is stored so that it is readable by a computer.","Thus, the method according to the present invention can be executed on a suitably equipped computer system, such as a server computer connected to a client computer via a network connection, or any other computer or data processing system suitable for running a database system.","Reference will now be made in detail to embodiments consistent with the present invention as illustrated in the accompanying drawings. Whenever possible, the same reference numerals will be used throughout the drawings and the following description to refer to the same or like parts.","The following definitions will be used throughout the description of the embodiments:\n\n","Furthermore, transactions according to the following embodiments may comprise one or more query, projection, insert, update, and\/or delete operations, and treated in a coherent and reliable way independent of other transactions. The transactions according to the embodiments hereinafter described comply with the known principles of transactions, namely in that the transactions are atomic, consistent, isolated and durable (ACID). That is, transactions according to the following description provide an \u201call-or-nothing\u201d proposition, i.e., each operation is either completed (also referred to as finalized or committed) in its entirety or had no effect whatsoever. Furthermore, transactions are isolated from other transactions, results are in conformity to existing constraints provided in the database, and successfully committed transactions are written to durable storage.","The database according to the embodiments described hereinafter comprises an ordered set of data stores with at least one static data store. The data stores may preferably be ordered in a timely manner. The time stamp of a data store may be defined in the case of a modifiable data store, by the time when the transaction which has generated that modifiable data store has been started, or in the case of a static data store, by the time of the earliest one of data stores which have been selected to be converted to that static data store. The ordered set of data stores may be provided as a global state within the database which may preferably comprise references to the data stores and further information on the data stores, such as time information or information with respect to their accessibility.","The at least one static data store is adapted to store data entities and to perform queries on said data entities and may be stored as a persistent data store on a hard disk of a computer system. The static data store uses an index structure which is based on a non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices which will be described below in more detail.","The data entities stored in the static data store may comprise a unique identifier and a plurality of fields each containing a single or multi valued value. The unique identifier may be provided globally in the database to identify a data entity within a database, irrespective of the number of data stores, biunique and may be an unsigned integer of a globally provided ordered set of unsigned integers in the database. Each of the plurality of fields may refer to a specific type of values or to multiple different types of values such as integer typed values or full text typed values. That is, each of the single or multi valued values stored in a field refer to the specific type.","The queries are preferably at least elementary similar to constructs known in the art such as the SELECT-operation in SQL. However, the queries may be formulated in any other query language which is preferably provided in the database such as described below in more detail. The queries may be defined based on navigational expressions along relations, Boolean predicates, crisp and natural language text predicates, and combinations thereof using the query language.","An embodiment of the present invention will now be described with reference to  which shows a flowchart of the steps performed in a transaction.","A new transaction S may be initiated by a user or an application. The initialization of the transaction may comprise further steps (not shown) such as establishing a connection between the user or the application and the computer system which provides a database management system including the database according to the present embodiment, authorizing the user or the application and checking the permissions of the user or the application to perform operations on the database.","If the transaction has been successfully initiated in step S, the current ordered set of data stores (also referred to as global state) is determined and the information obtained from the current ordered set of data stores is stored as transactional state of the transaction S. The transactional state may comprise references to the data stores being present in the current ordered set of data stores at the time when the transaction has been started, similar to the global state. Thus, the transaction is enabled to perform operations on the data stores being present in the transactional state only. Thereby, isolation of transactions is achieved since the transactions can be performed independent from other transactions. Accordingly, the modifiable store generated by the transaction is not present in the ordered set of data stores while the transaction is executed, and therefore not visible and not accessible for other transactions, thereby ensuring consistency of the transactions.","As mentioned above, the transaction may comprise one or more query, projection, insert, update, and\/or delete operations. In one preferred embodiment, when it is determined that the operation to be executed next is an insert, update or delete operation S, the following steps are performed before this operation will be executed.","If it is determined that the insert, update or delete operation to be executed next S is the first of such operations to be executed in the present transaction, and that a modifiable data store has not been generated for the present transaction S, the modifiable data store is newly generated S for the transaction. Furthermore, the information on the generated modifiable data store may be added to the transactional state of the transaction indicating that the modifiable data store is the newest data store. To determine if a modifiable data store has been generated for the transaction, the transactional state may be searched for such a modifiable data store, for example, based on a comparison of the generation time of the modifiable data stores within the transactional state and the time when the transaction has been started. When it is determined that the generation time of a modifiable data store within the transactional state and the time at which the transaction has been started are equal, then a modifiable data store has already been generated for the transaction. However, any other suitable method for determining if the modifiable data store has already been generated for the transaction may be applicable.","In a further embodiment of the present invention, the modifiable data store may be generated before the first operation of the transaction is executed irrespective of whether it is an insert, update, delete, query or projection operation. That is, the modifiable data store may be generated before, in parallel or after step S as shown in  is performed.","The generated modifiable data store is adapted to store data entities and to perform queries on the stored data entities both as described above. The modifiable data store may preferable be kept in memory during the transaction for which the modifiable data store has been generated, such that the operations executed on the modifiable data store can be performed with suitable performance without the need for accessing other storage media such as a hard disk. However, the modifiable data store to may be kept in another embodiment on any other writable storage media such as a hard disk when the computer system on which the database is configured does not provide sufficient memory for keeping the modifiable data store as an in-memory data store during the transaction. It will be acknowledged by the person skilled in the art that, if the modifiable data is store is kept on a hard drive instead of the memory, the performance to execute operations on the modifiable data store is significantly reduced.","Furthermore, the modifiable data store may be structured using a row-oriented data structure, a column-based data structure such as those known from RDBs or any other suitable data structure. If the modifiable data store uses a column-based data structure, each of the fields contained in a data entity will be stored in a specific column of the data structure. For example, if a first data entity comprises field values for surname and name of persons and a second entity comprises field values for name and birth date of persons wherein both data entities are to be stored in the same modifiable data store, the modifiable data store at least comprises three columns for each of the respective fields, namely a surname, name and birth data columns. However, the row-oriented data structure is preferably used in the modifiable data store. According to the row-oriented data structure, the fields of each data entities will be stored consecutively, irrespective of their particular type. With respect to the above example, the surname and the name field of the above first data entity, and the name and the birth date field of the above second data entity will each be store consecutively so that the data entities may have the form \u201csurname, name\u201d and \u201cname, birth data\u201d when using a separation by comma.","After the modifiable data store has been successfully generated in step S, the insert, update or delete operation may be executed on the modifiable data store since the modifiable data store generated for the transaction is the only data store in the transactional state which is writable by the transaction. Specifically, the static data stores are read-only per se since the index structure based on a non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices does not allow easy manipulation of data entities without rebuilding the index structure or performing complex operations on this index structure. The above read-only characteristics of the static data store will be described below in connection with OUIS. Modifiable data stores in the transactional state which have been generated by preceding transactions are marked as read-only for further transaction when the preceding transactions are committed.","If it is determined in step S that the operation to be executed next is not an insert, update or delete operation, rather a query or projection operation, that operation is executed in step S on the data entities of those data stores of which information has been stored in the transactional state. In particular, the query or projection operation may be executed against each one of the data stores or at least one particular data store in the transactional state. The at least one particular data store may be explicitly specified by the operation.","As shown in , steps S to S will be repeated when it is determined in step S that further operations are to be executed within the transaction. Otherwise, if no further operations are to be executed within the transaction and if the transaction is to be committed, it is determined in step S whether a modifiable data store has been generated for the transaction or not. If so, the modifiable data store generated for the transaction is added as newest data store to the ordered set of data stores S provided in the database. The added modifiable data store is furthermore marked as read-only data store for further transactions started after the transaction has been committed. Thus, the ordered set of data stores thereafter comprises all static and modifiable data stores which are present and readable in the database for the further transactions. If the transaction is cancelled without committing the same, the modifiable data store generated for the transaction may be deleted and must not be added to the ordered set of data store within the database. Thus, the transactions performed according to the present embodiment comply with the principles of the atomicity and durability according to ACID as described above.","A detailed description of the execution of the above operations will be provided hereinafter. It is thereby assumed that operations are executed on a data entities level basis. That is, if a particular data entity identified by a specific identifier is present in more than one data stores of the transactional state, for example, due to an update or delete operation performed on that particular data entity, each of the more than one data stores comprises that particular data entity in a complete, but updated or partly deleted form. Thus, since the data stores of the transactional state are ordered, the particular data entity of the newest one of these data stores in which the particular data entity is present can be regarded as being the current and newest instance of the particular data entity.","The query operation defined according to an embodiment of the present invention comprises a query which is to be executed against the data entities in the data stores of the database. The query may be defined by using a query language as will be described below. The query operation is preferably executed by performing the query against each of the data stores of which information has been stored in the transactional state, but may also be performed against selected ones of these data stores.","It will be assumed in the present embodiment that a query is performed against each of the data stores.","Before the query is executed, the query definition according to the used query language may be evaluated by a query evaluator provided in the database so that it can be ensured that the query definition is consistent with the query language definitions. The evaluated query may then be transmitted to each of the data stores which perform the transmitted query independent from each other. The query against one data store may be performed as known in the art and therefore, corresponding descriptions will be omitted here.","Each of the queries returns unique identifiers of data entities which have a match with the query. If no data entities having a match with the query are found in a data store, the query may return information such as the well-known \u201cNULL\u201d value, indicating that no matching data entity has been found. If, unique identifiers are returned by the query, the identifiers are preferably ordered.","For example, if the query is defined to search for \u201cname=Meier\u201d, the query returns the identifier of each data entity which comprises a field \u201cname\u201d and wherein at least one value of the field is equal or similar to \u201cMeier\u201d.","As will be easily recognized by the skilled person, since one data entity can be present in more than one data store due to update or delete operations executed in preceding transactions committed before the present transaction has been started, the identifiers returned by the queries from different data stores may be comprise identical identifiers. These identifiers generally refer to the same data entities which have been updated or partly deleted before.","To achieve consistency of the identifiers such that the returned identifiers only refer to the newest instance of each of the data entities, in particular to that data store in which this newest instance is stored, a step of masking for each of the data stores those of the returned ordered identifiers for which a data entity with the same identifier already exists in a newer data store. The masking step may be performed by using the returned identifiers of a data store as mask to mask the returned identifiers of each preceding data store in the ordered set of data stores of the transactional state, beginning with the newest data store.","For example, if a query is performed against an ordered set of data store comprising data stores A, B, and C wherein data store B is newer than data store A, and data store C is newer than data store B, and the identifiers , , and , the identifiers , , and , and the identifiers , and  are returned from A, B, and C, respectively, the masking step is performed as follows.","At first, the mask is formed using the identifiers of the newest data store, namely data store C to mask the returned identifiers of each preceding data store, namely data stores A and B. Thus, since the returned identifiers of data store B also comprises the identifier  and  and the returned identifiers of data store A also comprises the identifier , the aforementioned identifiers are masked so that the masked returned identifiers of A are  and , and that of B is . Then, the masked returned identifiers of the instantaneous preceding data store of data store C, namely B, are used as mask for masking each of the preceding data stores of B. Thus, since the masked returned identifiers of A and the mask of B both contain identifier , this identifier is masked and the masked returned identifiers of data store A now contain identifier  only.","In a further step of uniting, the masked identifiers for each of the data stores remaining after the masking step may be united, for example, by using an OR gating which results in a list of unique identifiers referring to data entities stored in data stores that have a match with the performed query. The list of the identifiers after the masking and the uniting step is returned as a result of the query. With respect to the above described example, the returned identifiers comprises , , , , and  wherein the identifier  relates to data store A, the identifier  to data store B, and all other to data store C only.","The above described masking and uniting step may also be performed by applying an AND grating on the returned identifiers from the queries against each of the data stores. Furthermore, each of the returned identifiers may contain information to which of the data stores it refers.","The insert operation will be described next in more detail. The insert operation is adapted to insert a new data entity to the database. As described above, the insert operation may be defined using constructs of a query language such as the SQL statement INSERT. Accordingly, the insert operation may define fields and values for each of the fields to be written in the database.","Since only the modifiable data store of the transaction is writable for operations of the transaction, the insert operation writes a new data entity to this modifiable data store wherein a new unique identifier is used as the identifier of the new data entity and the fields and values as defined in the operation are written accordingly. The new unique identifier may be the next unused identifier of the ordered set of unique identifiers as provided in the database.","The projection operation may be executed according to another embodiment as follows. First of all, the projection operation may read at least one field of an existing data entity of which the identifier is one of the identifiers returned by an above described query operation executed prior to the projection operation. That means, a query operation has to be executed prior to the projection operation, and identifiers returned by the query operation will be used by the projection operation for further processing. By the way, projections in the context of the present application mean materialization of values. That is, the values of at least one field are read and returned by the projection operation.","The projection operation may read the single or multi valued value, or a part of the multi valued value stored in the at least one field of the existing data entity designated by one of the returned identifiers. Since each of the returned identifiers is masked as described above and thus refers to the newest instance of the existing data entity stored in a particular one of the data stores, the projection operation reads only the at least one field of the newest instance of the existing data entity in the particular data store. Furthermore, the projection operation returns the at least one value of that newest instance.","According to the above embodiment, the projection operation may be defined by using a query language such as the SELECT statement of SQL. In particular, the definition of the projection operation may at least contain the fields or particular values of a multi valued value field to be read. In another embodiment, the projection operation may include steps of a query operation as described above so that the separate query operation executed prior to the projection operation to provide identifiers may be omitted. In this case, the projection operation needs to define the query.","The update operation for updating at least one field of an existing data entity according to a further embodiment of the present invention may be executed as follows.","The identifier of the existing data entity may be one of the identifiers returned by a query operation executed before the update operation. At first, a projection operation as described above is executed to read at least those fields of the existing data entity which will not be updated by the update operation. Then, the update operation creates a new data entity in the modifiable data store for the transaction. The new data entity comprising the fields of the existing data entity read by the projection operation, the at least one updated field and the identifier of the existing data entity is written into the modifiable data store of the transaction.","According to one embodiment, the update operation may further include steps of a query operation so that a separate query operation executed prior to the update operation can be omitted, and\/or steps of a projection operation so that the fields of the existing data entity not to be updated can be read without executing a separate projection operation.","Furthermore according to another embodiment, the projection operation may read all fields of the existing data entity and update those fields to be updated before writing to the new data entity.","The definition of the update operation may be made by using constructs of a query language such as the UPDATE statement known from SQL. However, the update operation may be defined using any other query language.","Furthermore, the delete operation according to one embodiment of the present invention may be performed as follows. The delete operation may thereby be performed on an existing data entity of which the identifier is one of the identifiers returned by a query operation executed prior to the delete operation.","If at least one field of the existing data should be deleted, a projection operation is executed to read at least those fields of the existing data entity which will not be deleted by the delete operation. Then, a new data entity is created in the modifiable data store generated for the transaction. This new data entity comprises the fields of the existing data entity read by the projection operation and the identifier of the existing data entity as the identifier of the new data entity. In another embodiment, the new data entity may further comprise a marker for each of the fields which have been deleted by the delete operation wherein the marker indicates that the respective field has been deleted.","Additionally or alternatively, if an existing data entity should be completely deleted, a new data entity may be written to the modifiable data store including a marker and the identifier of the existing data entity as identifier of the new data entity. The marker indicates that the existing data entity to which the new data entity corresponds is deleted.","In another embodiment, the delete operation may be defined using a query language wherein the definition may be similar to that of the DELETE statement known from SQL. Furthermore, the delete operation may include steps of a query operation to perform a query as described above, and\/or steps of a projection operation to read fields of the existing data entity not to be deleted by the delete operation. Thus, a query operation executed prior to the delete operation and a projection operation separately executed may be omitted.","The method according to the preferred embodiment of the present invention further comprises a step of converting one or more selected data stores of the ordered set of data stores (global state) to a new static data store.","The step of converting may be executed independently from any committed or currently performed transaction in an automatic manner or due to a command issued by a management application or a user. As will be described below, the step of converting may be executed when the number of data stores in the ordered set of data stores exceeds a predefined value or when it is estimated that the complexity for converting one or more data stores to be selected exceeds a predefined condition.","The step of converting will now be described with reference to .","The converting step is executed S when one of the above situations occurs. Then, data stores of the ordered set of data stores may be selected S. The selected data stores may comprise one or more modifiable data stores, two or more static data stores, or at least one modifiable data store and at least one static data store. The selection algorithm used by the converting step may take into consideration the number of data entities stored within each of the data stores in the ordered set of data stores, and selects data stores-until the total number of the selected data stores exceeds a predefined maximum. The selection algorithm may preferably select consecutively ordered data stores or modifiable data stores of the global state since at least the latter one preferably converted to static data stores first owing to the advantages provided by the index structure of these data stores.","In step S, all data entities are read from the selected data stores, for example, by querying all identifiers of the data entities stored in each of the data stores and then reading all fields for each of the queried identifiers. The above step S may also be performed by separate execution of query and projection operations as described above.","A step of masking S is performed on the data entities read by the step S in each of the selected data stores for which it is determined in step S that a data entity with the same identifier exists in a newer data store of the selected data stores or, preferably, the ordered set of data stores. The step of masking S is executed similar to the masking step of the query operation as described above. That is, for example, if a selected data store A comprises data entities with identifiers , , and , and another selected data store B which is newer than A comprises data entities with identifiers , , and , the resulting data entities after the masking step comprises the data entities with identifiers , , and  of B, and data entity with identifier  of A. If data store B is not a selected data store, but present in the global state, then the resulting data entities only comprise data entity with identifier  of A.","After masking the data entities, the remaining masked data entities of the selected data stores are merged to a set of data entities S. The merging step S may be done by applying an OR grating to the masked data entities of each selected data store.","As described above, the static data stores comprise an index structure based in a non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices which is to be generated for a new static data store. Therefore, such a new index structure is built in step S using the identifiers of the merged data entities. After building the new index structure which will be described in more detail below, the merged data entities are written into a new static data store S. Finally, the new static data store is added to the ordered set of data stores.","To maintain the ordered set of data stores, the position of the new static data store in the ordered set of data stores may be the position of one of the selected data stores and is preferably the position of the newest one of the selected data stores. However, the new data store may be set on any other position in the ordered set of data stores so that the order of the data stores with respect to the data stores not being selected can be maintained.","Furthermore, according to another embodiment of the method, a step for deleting one or more of those data stores which have been deleted from the global state of the database is performed. However, the step of deletion needs to determine if any transaction is currently performed which includes at least one of these data stores to be deleted in its transactional state. This may be the case, when the transaction has been started before the converting step, and is sill performed when the deleting step is started. If so, the respective data store may not be deleted from the database.","It has been mentioned, that operations and steps as described above are executed on a data entities level basis. However, these operations and steps may optionally be executed on a field level basis. That is, a new data entity written by an update or delete operation in the modifiable data store for the transaction does necessarily not contain the complete, but updated or partly deleted existing data entity to which the new data entity correspond. According to the embodiment, only those fields are written as new data entity which have been updated or deleted by an update or delete operation.","It will be apparent to the person skilled in the art that the above described operations and steps need to be adapted so as to be executable on a field level basis.","By way of example, the adaptation of the update and delete operation will be described. At first, the projection operation of the update and delete operation can be omitted since only the updated or deleted fields are written in the new data entity and the fields of the existing data entities need therefore not to be read. When an update operation for updating at least one field of an existing data entity is to be performed, a new data entity is written in the modifiable data store for the transaction which comprises the at least one updated field and the identifier of the existing data entity as identifier of the new data entity. Additionally, when an delete operation for deleting at least one field of an existing data entity is to be performed, a new data entity is written in the modifiable data store comprising a marker for each of the at least one deleted fields and the identifier of the existing data entities as identifier of the new data entity. In both aforementioned operations, the identifier of the existing data entity may be provided by a query operation executed prior to the respective operation or by steps of a query operation included in both operations.","Performing the operations and steps on the field level basis will advantageously lead to the effects of increased performance in update and delete operations, and further reduction in the size of the modifiable data stores, thereby providing increased compactness of the database.","However, as will be recognized by the person skilled in the art, the query operation and the converting step, especially in view of the masking and the uniting steps, need to be adapted for the field level basis additionally. The adaptation of query operation will now be exemplified.","By way of example, the necessary adaptation of the query operation may relate to dividing the query of the query operation in separate atomic queries wherein one atomic query is formed for each of the fields to be queried. These atomic queries may be executed on each of the data stores on which the query operation is to be executed. The results of each atomic query may comprise identifiers of data entities which have a match with the atomic query. The resulting identifiers may then be masked as described above. Additionally, it is to be determined if the data entities having the same identifier exist in newer data stores, irrespective of whether the identifier of the data entity in the newer data store has been returned by the same atomic query. If so, it is assumed that the data entity with this identifier has been updated or partly deleted in the respective field against which the atomic query has been performed and it can therefore be assumed that the newest instance of the data entity is present in the newer data store. The resulting identifiers remaining after such masking may then be united and returned as described above.","In a further embodiment of the present invention, the above described converting step as shown in  may further generate at least one mask containing identifiers for the new static data store. For example, the identifiers of the merged data entities which do not occur in data stores older than the selected data stores may at least be used for the mask. The mask may then be used in the masking step of the query operation and the converting step so that those of returned identifiers can be masked for which same identifiers exist in at least one mask of a newer data store.",{"@attributes":{"id":"p-0149","num":"0152"},"figref":"FIG. 3","b":["300","300","310","330","301"]},"The client side component  exposes a query language and the client side application programming interface (API) . The client side component  is also aware of the meta data model  that is specified by the application  and sends its request via a wire protocol  to the server .","On the server side  the evaluator  is responsible for the mapping of queries into accessor trees. The evaluator  is responsible for execution of projections, queries, updates, inserts and deletes in the context of transactions. In particular, the evaluator  comprises a transaction control  for controlling the transaction initiated to the server . Furthermore, the evaluator  comprises a query evaluator  having means for node filtering , relationship processing , value join processing  and fuzzy query evaluation  which are adapted to interpret the query as to identify the processing to be made during the execution of the query.","The transactional store management  handles transactions and concurrency issues and is responsible for store maintenance . This includes the global node store  that memorizes the global state of the system  as a sequence of stores. The sequence of stores reflects the sequential order of operations that constitute the current state of the system . Besides that multiple transactional node stores  can exist (one for each running transaction). These reflect the transactional state as the order of stores as seen by an individual transaction. The transactional store management  may also comprises a transaction log management  which is adapted to store and manage logging information of the operations which have been executed in the transaction. Thus, disaster recovery information for restoring the database or particular data stores after a system failure may be provided by the transaction log management .","The stores and indices layer  is responsible for the internal representation of the data and provides the basic access mechanisms. The main store types are the static node store (SNS) which is a read only structure and the in-memory node store . The lifecycle of any chunk of data starts in an IMS  and will eventually end up in SNS . Parts of the data can exist in multiple versions in SNS  and IMS  stores. Furthermore, global static dictionaries  may be provided which will be described below in more detail.","The persisted state layer  reflects the global state of the system  on a disk. It consists of a persisted configuration structure  that reflects the sequence of Static Node Stores  and log files  that constitute the current system state.","In the following, data structures and algorithms which may be used in connection with the described embodiments will be described in detail.","The ordered unsigned integer set (OUIS) is a basic data structure (also referred to as an index structure) for ordered sets of integers, in particular ordered sets of unsigned arbitrary sized integer values. The OUIS may be used as the central data structure for the static node stores (SNS) and\/or as most common data structure of the embodiments described herein. The indices may heavily depend on this data structure. It is to be noted that the below described data structure is optimized in many ways for the needs of databases such as those according to embodiments of the present invention.","As described above, the static data stores use an index structure which is based on a non-updatable representation of an ordered set of integers according to the principle of compressed inverted indices. In one embodiment of the present invention, the index structure of the static data stores comprises blocks of consecutive integer entries of the ordered set of integers and a search tree. Each of the blocks contains a number of chunks each having a number of integer entries. The number of chunks as well as the number of integer entries is preferably predefined. The number of chunks and the number of integer entries may be set to any value which is suitable for the particular configuration of the database. In the following example, it will be assumed that the number of chunks N is set to 16 and the number of integer entries M is set to 64.","In this example, a new index structure will be generated for a static data store comprising 4096 data entities (i.e., 4096 unique identifiers) during the above describe converting step by performing the following steps. The ordered set of 4096 integers may at first be partitioned (i.e., divided) into 4 blocks per 1024 integers. The number of integers in each of the blocks may be calculated by multiplying the number of chunks N with the number of the integer entries M (i.e., N\u00d7M). These blocks may further be partitioned into the number of chunks N.","In a further step, deltas between any two consecutive integer entries in each of the chunks are computed. That is, for example, if a chunk comprises the integer entries 60, 245 and 8821 consecutively, the deltas will be computed to 185 between 60 and 245, and 8576 between 245 and 8821. The computed deltas may then be used to determine the maximum of the deltas which in the above example is 8576. The so determined maximum delta defines the size of the entry which is needed to write the maximum delta in terms of memory space. When assuming that each entry is stored using bitwise fashion having binary values 0 and 1 as usually used in computer systems, then each entry needs at least 14 Bit to store the maximum delta of 8576. This may be determined by considering that 2 to the power of 13 is only 8192 (i.e., 13 Bit), thus smaller than 8576 which means that 13 Bit are not enough to store an entry having a number of 8576. Therefore, the next possibly power is considered as needed size of the entry which is 2 to the power of 14 (i.e., 14 Bit) and with 16384 greater than 8576. However, any fashion other than bitwise fashion may be used to store the maximum entry. The deltas may then be stored in entries of the chunk having the size as determined above, consecutively.","In a further step, the chunks may then be stored consecutively in the block to which the chunks refer, and an offset for each of the chunks and its starting value in the block may be determined and stored in a header of the block.","The blocks generated as mentioned above are stored in a consecutively ordered fashion. In a last step, the search tree is built using the blocks so that the search tree comprises a node for each of the blocks. Each node in the search tree may consist of a value of the first integer entry in the block to which the node refers and a pointer to a position in the index structure where the block starts. The search tree may be built as known in the art and thus its description will be omitted here.","An example of the OUIS will now be described with reference to . The OUIS is a three level structure ,  and  as shown in . This ensures that for any set the bulk of the information is stored in the lowest two levels  and , and that those levels are as compact as possible while providing reasonably efficient random access by index. As will be easily recognized, there is a trade-off here between compacting individual entries using variable length representations and adding the addressing information to allow those entries to be quickly accessed.","Levels 2  and 3  are folded into a sequential structure . The top level  of the OUIS contains one entry for every 128 elements in the set. The level 1  structure is based on a compact search tree to represent these elements in a form that exploits deep memory hierarchies. The main issues with this structure are supporting a sequential generation model for sets that are too large to fit in memory without requiring significant buffering, and supporting efficient random and sequential access within the structure in the context of deep memory hierarchies, support for arbitrary length integers and the addition of the addressing information to locate the chunk for each element at this level. Standard mechanisms for the sequential generation of cache oblivious binary search trees are applied here, augmented by the addition of the required level 2  chunk address information. Blocks in this structure are written as they are filled during the sequential writing of the data.","The OUIS partitions the set into chunks of 128 entries and provides a top level search tree over every 128-th value that also indicates the locations of each corresponding 128 entry (level 2 ) chunk. Each 128 entry chunk is represented as a 15 entry header and 16 corresponding level 3  chunks specifying the values lying between corresponding header (or top level and header) entries. The header entries also include an indication of the offset within the large chunk at which the corresponding low level chunk starts. In both the header and the low level chunk the values are relative to the corresponding entry at the next higher level and are represented with constant size entries that support random access.","The representation of each chunk may be bit aligned, built upon a corresponding structure that supports arrays of fixed size entries of any size in bits, starting at any bit location. For example, the value v[i] of entry i in the set may be determined as follows:\n\nfor %128=01128]\n\nfor %8=0 and %128 !=011282128% 128\/8]\n\notherwise:\n\n1128212883% 128%128\/8%1024\/8]\n\nwhere v1[j] is the value in the top level  structure corresponding to index j=i\/128, v2[j][k] is the k-th value entry in the j-th level 2  chunk, and v3[i][j][k] is the k entry in the level 3  chunk i,j. The value v2[j][k] at level 2  may be determined by the range of the level 2  chunk R[j] determined by the values of level 1  and the error e2[j][k] that is stored in the level 2  chunk. The value may be calculated in the following way:\n\n2162\n\nThis results in a more compact representation. The maximum number of bits needed for the error is stored in the header of the level 2  chunk. The level 3  chunks may be byte aligned and fixed size.\n","An example will be given next to illustrate how space costs are minimized in the OUIS. In this example, it will be assumed that the lowest level  chunk contains the values X+20, X+35, X+60, X+90, X+100, X+105, X+107 where the next value in the header is X+120. This lowest level  chunk will then use 7 bits (ceiling(log2(120))) for each entry. The space needed for X does not impact the chunk space and the cost to represent this sequence is 7*7=49 bits. There are Comb(120,7) such values (i.e., a selection of 7 values from a range of 120 possible values). Assuming each is equally likely the number of such values is 120!\/(7!*113!). One possible representation of this set would be relative to an enumeration of all such combinations. The space needed to specify such an index would be about 35 bits, but it will be expensive to compute the value for the i-th entry. As the range expands the overhead of the representation relative to this optimal is reduced.",{"@attributes":{"id":"p-0167","num":"0170"},"figref":"FIG. 6"},"The addressing information in the level 2  chunk header, used to locate a 7 entry level 3  chunk associated with a specific header entry, may further be minimized by using a prediction mechanism. The prediction may assume that the values in the level 2  chunk are uniformly distributed over the level 3  chunks. Individual header entries then specify the error relative to this prediction using an encoding that is optimized to minimize the expression of these errors.","For illustration purposes, it will be assumed that the range of values in the level 2  chunk is R as determined by the values in the level 1  structure, thus the space consumed in the header for each entry value will be ceiling(log2(R)). Each level 3  chunk is then assumed to span a range of R\/16 with each entry in those chunks then consuming S=ceiling(log2(R\/16)) bits. The i-th low level chunk is assumed to start at bit i*S from the end of the header and that is the default alignment for the low level chunks.","The OUIS may further provide a second addressing option which is also shown in  that provides efficient representations when the distribution within the 128 entry chunk varies significantly from the uniform assumption. In this event each level 3  chunk is encoded with the minimal space determined by its range and each header entry has additional information that encodes the offset from i*S at which the representation of that chunk starts. The big chunk header identifies the range of these offsets, and the individual header entries have additional information that encodes the offset for each entry. This may only be used when the cost of the location encoding is less than the alignment overheads, which only occurs for very skewed distributions.","The generation of the 128 entry chunks of an OUIS requires a buffering of 128 values. This will usually fit in the first level cache of present computer systems and all computations to decide on the structure to use and the encoding of each entry into an output bit stream are very efficient.","According to an embodiment of the present invention, the method may further provide a specific mechanism (hereinafter referred to as GapAccessor) to perform the intersection, union and difference of various data entity sets (identified as sets of corresponding internal IDs that are 64 bit unsigned integers), as well as the selection of subsets of some ordered set as identified by an ordered set of indices within that set. The specific mechanism may support automated optimization of the evaluation of a tree of such operations in conjunction with appropriate indices.","The leaf sets in the tree may be specified via crisp or fuzzy predicates on the attributes of a data entity. In some cases these predicates will be supported by:","(a) Inverted indices whose keys support the identification of the exact set of entities that satisfy the predicate. For example, a predicate \u201ctype=person\u201d will generally have inverted indices whose keys are precisely the set of all values of the attribute \u201ctype\u201d that occur for any data entity. Recall that the range of the inverted indices is logically the set of internal IDs of entities.\n\n(b) Inverted indices whose keys may be combined to identify the set of entities that match the current predicate. For example, a date field could have an index whose keys correspond to individual days. The set of entities that correspond to a predicate for a specific week will be the union of the sets that correspond to each of the 7 days within that week.\n\n(c) A combination of inverted indices and related subset indices for which the keys of the full index identify some superset of the matching set and the subset indices identify some subset of those sets that correspond to finer grained predicates. For example, an index for a data field whose keys correspond to particular calendar weeks. Individual days within each week may be identified as subsets of the set for the week in which they occur.\n\n(d) Finer grained inverted indices whose range is not just the set of internal IDs, but may include additional information that can be used to support evaluation of predicates that look into more detail about particular values and\/or provide information related to computations of a fuzzy score for a matching entity. For example, a predicate on a full text field may be looking for values that have two specific words within close proximity of one another. One type of inverted index that supports such predicates will have keys corresponding to the words and a range that identifies both the entity ID and a position within the value at which the word occurs. These positions can be used to evaluate the proximity condition.\n\n(e) No indices for the predicate so that evaluation requires tests that examine the value of entities to determine if they match the predicate.\n","An exemplary embodiment of the GapAccessor will now be described in more detail.","The GapAccessors may use the following functions: next to go to the next entity in the OUIS, goToValue which allows to jump to an given entity ID wherein the accessor returns an indication as to whether the entity with the specified ID is in the OUIS computed by the accessor, getIndex to get the index in the set of the current position as modified by the above operations, getValue to get the ID at the current position within the set, and is Done to identify that the OUIS does not contain anymore elements.","The GapAccessor for the inverted index structure as described above may implement the goToValue function in a manner that is at worst logarithmic in cost, but provides a special optimization to be faster in the case that the ID being requested is close to the current ID. This uses an up\/down binary search that relies on roughly constant time access by index to the ordered set of entity IDs. Thus, if the set is positioned at index i which has entity ID e and gets a goToValue call with argument g it does:","1. check to see if g is less than e if so reset i to zero,","2. look for the smallest range that could contain g by starting at i+c (c=1) and then move if the value at i is less than g and double c until the value at i+c is greater than g or the end of the set is reached, and","3. do a binary search for g within the index range determined in 2.","In the situation in which almost all entries in some range of the index are visited, the up portion of the search will terminate very quickly with a small range to search. If g is far away, the cost will be at worst two times as expensive as a binary search in the range of the set remaining.","Intersection propagates skipping calls to its inputs in a manner that ensures that the cost for a full evaluation is determined by the most restrictive set and by the overlap of the sets.","As an example, the sets A={1, 2, . . . , 9, 11} and B={10, 11, . . . , 30} will be assumed to be intersected. The intersection will start with the two input accessor pointing to the values A:1 and B:10. A will be told to goToValue(10) and will go to the value 11 as efficiently as possible. It will indicate that this is not a match. The intersection accessor will then get the value 11 from A and tell B to goToValue(11). B will find  efficiently and report a match. The caller will then do a goToValue(11+1=12) on the intersection accessor. The intersection will propagate this to A and B. A will return that it is done and the intersection will then indicate that a match was not found and that it is done. In total then there were two calls to the intersection accessor in this example.","Similar automatic optimizations occur for difference and subset operations. Union operations will still need to visit all elements in each set, however, something like A intersect (B union C) where A is small will still be controlled by the size of A with skipping propagated to both B and C.","The intrinsic optimization of the skipping mechanism of the GapAccessors as described above, in conjunction with appropriate indices that will be accessed in monotonically increasing, but potentially non-sequential order, avoids the need for much of the optimization analysis done in many of the known persistence stores.","According to a further embodiment of the present invention, the database may provide support for natural language text. Such natural language text values are assumed to contain the bulk of the information in the application to be supported by the database. In particular, at least one of the plurality of fields of the data entities stored in any of the data stores may comprise a value of the type natural language. Furthermore, the query language and thus each of the operation, especially the query operation, may in a further embodiment support natural language text. Particularly, the query operation may in this embodiment support full text queries.","A key component of providing the capabilities to support queries is a strong built-in natural language capability. A key component in providing this is a compact high speed dictionary for looking up words in the supported languages. Another is a means to map these words, or sequences of words, into some base form (or equivalence class) to be used as the default search key for that sequence and some remainder information that expresses the variations the actual form takes in the text.","For example, in the sentence \u201cThe mailman was bitten by the dog.\u201d the word sequence \u201cwas bitten\u201d together forms the past perfect conjugation of the verb \u201cto bite\u201d. Further analysis of the sentence could reveal that this occurrence could be considered to be an example of an \u201cattack\u201d. The present embodiment may provide means to have this sentence characterized as a SVO (i.e., subject, verb, object) triple consisting of (dog\/the,attack\/bite\/pastperfect\/passive,mailman\/the\/Cap), and potentially even a further analysis that could identify which dog and which mailman if those were in fact entities known to the database. Furthermore, the present embodiment may provide the data structures to express this information, and efficiently exploit it at query time when the analysis capabilities are provided. High speed tokenization of Unicode text, high speed and compact language specific dictionaries, and high speed but simple dictionary based stemming capabilities may additionally be supported by the present embodiment.","The present embodiment may therefore use a trivial tokenization algorithm that is actually merged with an encoding to translate each token in the text into a pair of unsigned 64 bit values (U8s). One element of the pair encodes the case and accent insensitive form of the word, for languages that support those notions and where such information is regarded as irrelevant for default search purposes. The second encodes the actual case and accent information so that the database can still provide case and\/or accent sensitive searching if desired. The purpose of this encoding is to provide a form that can be rapidly looked up in per language static dictionaries. As the encoding of some natural language words, or other tokens in the text, may not fit into a single U8 subsequent stages in the processing of the tokenized form are responsible for handling sequences of U8 that have been created due to the size limitations of the encoding output.","For example, for text that uses the Latin alphabet the encoding for the base uses 5 bits per character to allow for the 26 base letters, and special ones such as the German sharp S. Thus, 12 characters can be encoded into a single U8. The encoding of the case and accent information for these languages is lossless to ensure that if this form were used for storage, rather than just indexing, the exact input could be reconstructed. This can be complicated to some degree by the redundancy in Unicode that allows many accents characters to have as many as 3 different Unicode encodings.","As noted above, the present embodiment may further comprise a per language static dictionary. These dictionaries are fairly small. According to one embodiment, the dictionaries may be in-memory structures. These dictionaries take as inputs the words in the encoded U8s produced by the tokenization. The handling for non-word tokens, and word tokens whose encoding does not fit into a single U8, are discussed below.","The distribution of the occurrences of the words in a natural language may generally follow a distribution according to Zipfs law (i.e. the relative frequency of the i-th most frequent item is roughly 1\/i times the frequency of the most frequent). For example, in normal English text this leads to a distribution in which the 100 most frequent words account for about 50% of all word occurrences (these are basically function words such as articles and prepositions), the most frequent 10000 account for about 95%, and there is a long tail of other \u201cwords\u201d (often misspelling or domain specific words). When assuming that a dictionary such as The Oxford English dictionary contains approximately 120000 words, this characteristic may be exploited by the present embodiment to build a 3 level structure:","1. a 128 array of U8s,","2. a 16384 array of U8s, and","3. an array of U8s large enough to contain all of the words.","The dictionary may be built by adding words in descending frequency order. All dictionary words are tokenized as noted above. For example, each U8 produced may be hashed into a number in the range [0,16384]. The top 7 bits of this hash are then extracted. If the entry in array 1 at this index is empty the current value is added there. If not the full value of the hash is used as an index into array 2. If that entry is empty the value is added there. If not the entry is added to array 3. After all entries have been added array 3 is sorted so that simple binary searches can be applied to it. One option that could be done is to reduce the space consumed by array 3 by using the OUIS structure, but as the total space is relatively small compared to the usual main memories this is not deemed necessary in general.","It is to be noted that in the above described embodiment most of the highest frequency elements will be in array 1, and the next higher in array 2. Array 1 may therefore be small enough to fit easily into the level 1 (L1) cache (requiring only a few CPU cycles to access) on most systems. Array 2 similarly will fit into most level 2 (L2) caches that required something on the order of 10 cycles to access. Binary search is only needed for the array 3, and this will only generally be needed for 3% of all words. Thus, this dictionary provides on average very high speed translation of a stream of input words into dictionary indices with the property that the smallest indices correspond on average to the highest frequency words.","For words whose encoding does not fit into a single U8 (e.g., in the English dictionary there are fewer than 12000 such words), each U8 chunk is added to the base dictionary, where the encodings are augmented to indicate that these are parts of a multiple entry word. The indices of these entries in the base dictionary are then concatenated to form new U8s, and that set is sorted and stored in a simple U8 array. Again binary search can be applied to lookup such sequences in this array. Indices in this array are then added to the last index in the base array to allow the database to quickly identify which dictionary to use for a given word.","Furthermore, non-word tokens, or word tokens that do not occur in the static dictionary for the language are split into chunks with flags added to identify whether they are the first chunk, a middle chunk or a final chunk. The size of these chunks may be selected to ensure that they can be used directly as keys in the index structures described below. As there may be some word tokens that are not in the static dictionary, but still are very frequent within a particular deployment of the present invention, an embodiment may exploit the general high frequency phrase handling mechanism, described below, to ensure that these can still be looked up efficiently.","In the event that an input word is in the static word dictionary the database according to the present embodiment may use the index produced by the dictionary to lookup in a corresponding array the index of the stemmed form of that word and an index that identifies the category of the variant of that stemmed form (e.g. the past participle of a verb). On building these structures, the database may ensure that the stems for all words exist in the base word dictionary so that the indices into the base dictionary are used to represent the stem.","The stemming dictionary according to an embodiment may perform some context sensitive processing for a word. This processing may include checking to see if the previous word is one of the standard auxiliary verbs associated with the various verb conjugations.","With respect to the above, the database according to one embodiment may comprise a dictionary including a mapping from words to wordindices. That is, if the dictionary is, for example, an English text dictionary and comprises the words \u201cdatabase\u201d and \u201ccomputer\u201d mapped to wordindices 10 and 123, respectively, each of the above words found in a natural language text value may be mapped to the respective wordindex.","If such a dictionary is present in the database, a new index structure of the new static data store to be built during the conversion of selected data stores may preferably be based on a field of the data entities comprising natural language text values.","In this case the step of building the new index structure may further comprise the following steps. At first, if a word of the natural language text value is equal or at least similar to a word of the dictionary, the word of the natural language text value is mapped to the wordindex of the dictionary. Using the above example, if the natural language text value comprises the word \u201ccomputer\u201d, this word is mapped to wordindex10. Then, a pair comprising the wordindex and an identifier of a data entity of a merged data entity is mapped to an integer of the ordered set of integers, if the new static data store contains the data entity and the field containing the word or a form of the word.","The components as shown in  will now be described in more detail.","A client application  may use an API and a query language  both provided by an embodiment to perform its transactional operations with one or more backend server  instances. The operations include transactional ones such as starting, committing and aborting along with a sync operation that ensures that subsequent query operations within the transaction will see the updates made during the transaction.","The query language  may support the definition of sets or forests of entities using a regular path expression style. The language  may further provide means to express both crisp and fuzzy full predicates. There exist specific predicates that are aware of natural language and have knowledge about language specifics like stemming. The API  provides means within the language and with parameterization mechanisms to control the manner in which fuzzy predicates can be combined. The API  provides the means to specify the attributes to be projected for each set. There may be according to another embodiment no means to specify computed projection values over multiple entities as is done in relational projections within the known SQL statement SELECT. However, much of the need for such functionality may be emulated by exploiting the flexible data model  to compute such values at update time as new named attributes assigned to the entities.","The data model  will now be described in more detail.","It is assumed that relationships provided in the embodiments described herein may have attributes and be n-ary, and entity or relationship attributes can potentially be multi-valued and of heterogeneous type.","The flexible data model  which can be seen as a less restrictive version of Chen's original Entity-Relationship proposal may be provided according to an embodiment. Chen identified a logical partition between entities and relationships, and sets of entities of the same type, but all entities of the same type had the same attributes (a carryover from the rigidity of the relational model) and no mechanism is provided to deal with any form of entity type relationship such as inheritance. The above flexible data model  consists of a set of entities and a set of relationships between those entities. Both entities and relationships can have arbitrary sets of attributes associated with them. Relationships are named tuples of roles where individual entities occur in those roles. For many applications the most common relationships would be unattributed binary ones. However, the data model  allows more than two entities to be related by a relationship and allows those relationships to have attributes which can influence the behaviour of the database.","As will be recognized by the skilled person, the above describes the high level data model of entities and relationships which is provided in the database according to the above embodiments. In a database dealing with large textual data that can include such entities as emails, word processing documents and HTML or XML documents, the embodiments of the present invention also have a notion of attributed tree structured textual values. A full text value can contain sections that occur at multiple levels, sections can contain sections (at lower levels) or paragraphs that can be of either body or heading type, and paragraphs contains sentences that are sequences of words or non-word tokens. Sequences of words or non-word tokens can be highlighted. This structure is exploited to refine its match probabilities for fuzzy predicates as will be discussed below. In that discussion these various levels (sections, paragraphs, sentences) are referred to as segments.","Following, the query language  provided in embodiments of the present invention will be discussed in further details.","In text dominated applications, for which the embodiments of the present invention are intended, the majority of the data consists of various representations of natural language information, such as word processing documents, emails, blogs, wikis, instant messaging text and audio files of spoken discourse. In such a domain the support for both crisp and fuzzy predicates is critical.","For example, consider two distinct natural language passages that contain the two sentences: \u201cThe Doberman attacked the mailman.\u201d and \u201cThe mailman was bitten by the dog.\u201d. A user who issued the query \u201cdog attacks\u201d would probably consider both passages to be \u201crelevant\u201d.","Further, that predicate may be part of a more complex query such as \u201cinsurance claims from summer of 2006 concerning dog attacks handled by someone reporting directly or indirectly to John Doe\u201d. Such a query has crisp components: the type of entity is an insurance claim, the identity of the individual who handled the claim as expressed by a recursive relationship (although this may also be fuzzy to some degree as one may consider people closer to John Doe in the reporting chain to be more relevant); as well as fuzzy components: the \u201cdog attacks\u201d noted above and \u201csummer of 2006\u201d (which would almost definitely include June through August of 2006, but how many other months should be considered, and should the relevance of the match decrease as one gets nearer to spring or fall).","Further embodiments may specify a query model that supports a range of crisp to fuzzy query capabilities over the data model specified above in contrast to the concepts known in the art. The fundamental model is one of traversing relationships and filtering or assigning match scores for sets of entities. This may be handled by a model of regular filter path expressions and fuzzy and natural language predicates as primary components.","Regular filter path expressions may combine filters and paths in a form similar to regular expressions. They may be composed of simple path expressions, filters and symbols that specify a bound or unbound number of repetitions of a sub expression similar to regular expressions as described hereinafter.","Basic filter expressions may be Boolean combinations of the simple built-in predicates (that include a rich set of full text tests), specific to a particular primitive data type, that test a specified attribute (or set of attributes), of a particular entity. Filters may be indicated with brackets in the query language and have forms like:","[name=\u2018Mary\u2019]","[name=\u2018Mary\u2019 and age<18]","Filters can also be applied to the attributes of relationships. For example, the \u201cHandledBy\u201d relationship would likely have a date attribute indicating when the claim was processed, and the \u201cReportsTo\u201d relationship likely would have a date interval attribute that would indicate the period when that reporting relationship was valid. The \u201csummer of 2006\u201d condition would then be applied as a filter on that date.","Path expressions can be seen as edges from entities via an incoming role of a relationship and from there via an outgoing role to entities. For binary relationships the name of the relationship may be used as short form to navigate along the in role to the relationship and then via out role to the entities. Simple path expressions may also be applied to sets. The result of such an application will be the set of all entities that are reached from the input set along the path. Path expressions may be combined.","Assuming a domain of persons and edges that stand for kinship. For example, the query [firstname=\u2018Mary\u2019 and lastname=\u2018Stuart\u2019]\/child would result in the set of all children of persons with first name \u2018Mary\u2019 and last name \u2018Stuart\u2019. The navigation along the child relationship is indicated with a \u2018\/\u2019.","The traversal may be specified to occur some minimum or maximum (potentially unlimited) number of times for transitive relationships. For example [firstname=\u2018Mary\u2019 and lastname=\u2018Stuart\u2019]\/child+ is a query that returns all descendants of \u2018Mary Stuart\u2019 while [firstname=\u2018Mary\u2019 and lastname=\u2018Stuart\u2019]\/child* results in all descendants and \u2018Mary Stuart\u2019 herself. \u2018*\u2019 indicates an arbitrary positive number of traversals while \u2018+\u2019 indicates one or more traversals along the edge.","As a more complex example typical for applications that process documents the query \u201ceverything that is authored by somebody of whom \u2018John Doe\u2019 is direct or indirect boss\u201d might then be expressed in the query language as [Name=\u2018John Doe\u2019]\/bossOf+\/authorOf.","The type of the elements in the result set might depend on the type of the relation authorOf. If authorOf relates to documents and mails are a sub set of documents then the query can be easily restricted to only return mails by [Name=\u2018John Doe\u2019]\/bossOf+\/authorOf[Type=Mail].","Basic fuzzy predicates that specify how scores should be computed to determine the probability that a given condition matches a particular attribute or set of attributes. This can weight matches in different attributes more or less strongly than others. For example, a match of the condition \u201cdog attacks\u201d in a title field could be specified to carry more weight than a match in a document body.","For full text fuzzy predicates the described embodiment may either use traditional full value statistical score calculations or segment level calculations that exploit the internal structure (an attributed tree of sections, paragraphs, sentences) detected for such values. Further, the embodiments may support a representation of sentence information so as to allow that the sequences \u201cDoberman attacked\u201d and \u201cwas bitten by the dog\u201d are potentially both treated as matches for the phrase \u201cdog attacks\u201d.","In the query language  the weighting may be specified with a weight modifier. For example, the query [mailBody contains\/weight=10 \u2018dog attacks postman\u2019 OR\/weight=1 \u2018Christmas\u2019] will rank dog attacks to postmen high with a bias for Christmas. Mails with dog attacks that have no match for Christmas will have lower score than mails that refer to Christmas events without any occurrence of something similar to dog attack.","The evaluator  of the server  will now be described in more detail.","In the event that some new sets have been defined since the last value retrieval the API implementation collects all of the query specification that have been defined since that point and makes a request to server components as shown in  to obtain initial chunks produced by each such definition. These chunks are cached in the client , and as long as value requests can be satisfied from the cache no further communication to the server  is required. Such communications will only be performed if the chunks in the cache are exhausted or new sets are specified and values from iterators on those sets are requested.","The evaluator  is responsible for processing each user request. It has a transaction control component  that is responsible to do all operations within the correct transaction context. The evaluator  may further contain a node filtering component  that is responsible for translating filter expressions from the query into trees of GapAccessors. The relationship processing component  of the evaluator  translates relational traversals and conditions into operator trees.","Node filtering is essentially the translation of filter predicates into trees of GapAccessors. A GapAccessor is an essential data structure that is optimized for access either sequential or with gaps.","As an example, assume a query of the form: [(firstname=\u2018John\u2019 or firstname=\u2018Olivia\u2019 or firstname=\u2018Mary Ellen\u2019) and lastname=\u2018Walton\u2019] will be translated into a tree of GapAccessors as shown in .","The above query will at first be translated in an AND GapAccessor  which takes the results of an OR GapAccessor  and a GapAccessor for [lastname=\u2018Walton\u2019]  as inputs. The OR GapAccessor takes the results of the GapAccessor for [firstname=\u2018John\u2019], the GapAccessor for [firstname=\u2018Olivia\u2019] and the GapAccessor for [firstname=\u2018Mary Ellen\u2019] respectively as inputs. The above query is executed beginning with GapAccessors ,  and . When the AND GapAccessor  has been executed the resulting identifiers satisfy the above query.","A GapAccessor for a predicate will be translated to either an index (either directly or to a projection index) or into a \u201cscan and test\u201d accessor.","A n-ary OR GapAccessor may be maintained by a heap data structure with the current position of the multi or accessor at the top of the heap. A goto next on the heap will advance the accessor of the top element and then rebalance the heap structure. The new element at the top will then be the next element for the iteration. Similar optimizations will exist for AND operators.","The two main operators are shown in  which are designated as reaches  and navigate . Both reaches  and navigate  may take a GapAccessor  as an input set and a linkage (not shown) as parameter. Furthermore, reaches  may take a GapAccessor  as a filter. Both GapAccessors  and  may be a tree of GapAccessors or a single basic GapAccessor. The recursive structure of linkage is explained below, in the simplest case a linkage is a binary relation. This corresponds to the tree inputSet.reaches(I, filterSet) as shown in  wherein the filter set of the \u2018reaches via Linkage I\u2019 operator and the output of the \u2018navigate via L\u2019 operator may be sorted according to one embodiment.","For example as shown in , a query  in a document related context could be the set of all mails satisfying some condition (input set)  whose author satisfies some condition (filter) .","The transaction store management  will now be described in further details.","Each new transaction starts with the set of data stores that reflect the current global state and a new in-memory data store that reflects the updates that occur within this transaction. As described above, the new in-memory data store may be generated at the beginning of the new transaction or when an update, insert or delete operation is to be executed next. Merges, and other transaction commits, occur without affecting this set for the in process transaction. The state view for this transaction is always then the ordered sequence of committed data stores that existed at the time the transaction was started and the updates that occur within the transaction. These updates are not visible to any other transaction until this transaction commits.","As shown in , at a specific time the transactional data stores  of the transactional store management  comprises a number of n data stores. A number of k of those n data stores are static node stores  and the rest of the data stores are still in-memory node stores . The index of these stores may reflect the order in which these data stores were committed.","According to one embodiment, one data store may reflect multiple transactions as results of some merge activity (this is described in detail below). The transaction keeps a structure that we call transactional node store (T\u00d7NS)  that memorizes the data stores that are part of the transaction. Any other transactions will not affect the global state of all nodes visible from queries in this transaction as all of the data stores are either read only such as static data stores SNS, . . . , SNS or already finalized IMSes  that are finalized when preceding transactions committed. The transaction may create a new in-memory node store IMS as shown in  where the changes of this transaction are reflected.","When a transaction is committed the information in the associated in-memory node store is written to the transaction log . This is written in a form that reflects the net effect on the system state of that transaction rather than as some sequence of updates. The committed state of the system is maintained as the union of a special \u201cconfiguration\u201d file that identifies the set of committed read only store files and the transaction log. The cost of a transaction commit (or prepare in the case of two-phase commit support for distributed transactions) is then an append of the in-memory transaction update information to the transaction log. In case of a system crash a recovery manager restores the state of the system from the on disk information of the configuration file, the SNSes and the log files.","The interface provides a means for a client to explicitly request a write lock on individual entities. While this is not an adequate control mechanism to support state based updates such as required for accounting type applications, the mechanism is expected to be sufficient. For use cases where this assumption turns out to be invalid a means to explicitly obtain and release entity level shared read locks may be added. An in-memory version of the committed store is maintained for new transactions. The state as a sequence of read-only stores eliminates a need to reflect the transaction modifications in a corresponding set of updatable page changes and thus leads to a system behaviour with significantly less disk page accesses for index and value updates compared to traditional systems (RDBMS).","Background processes that make the index and value representation more compact are the main mechanism of the store maintenance component . The background processes merge read only data stores, clean up data stores that are no longer needed by any transaction and prune the transaction log. Detailed description of each of these is provided below. A special configuration file may be maintained that identifies the current sequence of committed stores. This may be a small file that just lists the names and sizes of the files that contain these stores.","The state of individual entities can be updated within a transaction. The state visible to that transaction is the state that existed at the beginning of the transaction, modified by any changes that have occurred within the transaction. If an update of an existing entity occurs within a transaction the transaction update description maintains a specification of both the entity that was updated and the attribute(s) that were affected. Any query done within the transaction will see the state of the entity masked by the changes to individual attributes. At some point in the merge process (converting step) the entire reflected state of an entity, that is updated within a transaction, will be copied, from the older store that maintains that state, into the new merged store with the modifications made in the transaction applied.","The transactional store management  is responsible for the execution of queries, inserts and updates in the correct transactional context. For queries this means to build an accessor tree over the valid indices in the stores in the transactional context. This context is reflected by the set of static node stores  that correspond to the persisted state at the time the transaction started identified by the global node store  and the updates made within a transaction as reflected in the in-memory node store  specific to the transaction that is created when the transaction starts.","For each IMS  a corresponding log file guarantees that the effects of a transaction are not lost in the case of a system shutdown. A recovery manager  will then restart from the information in the persisted files which are the config file  that holds the information which data stores and log files are part of the current state and the so referenced SNS  and the log files  themselves.","The present embodiment may also provide a mask mechanism that masks old versions of a value so that the accessors only see valid values within the current transaction context. Essentially the mask mechanism is based on an accessor type that iterates only over up to date values of a field and masks out values that have been modified in data stores that were newer.","The mechanism as described here would soon result in a fragmented state with lots of stores. To avoid this fragmentation a store maintenance mechanism  which is described below is in place.","As long as there are appropriate index structures associated with the predicates in the query the GapAccessor interfaces provide a means to evaluate the query without a need for the optimization process required for typical relational systems. As the server  builds and maintains indices appropriate for typical predicates as described below this capability of the GapAccessors is generally satisfied.","Referring to , a sequence of transactions performed on the database according to the embodiments as described herein will now be described.","Each of the states , , and  of  shows its configuration of the storage management , the stores and indices , and the persisted state . At the beginning, the database comprises in state  a configuration file , a first static node store SNS and a transactional log file  both designated in the configuration file . Furthermore, state  comprises global node state  referring to the SNS and an in-memory node store  of a committed transaction.","When two transactions has been started (shown by transition ) from state , the database results in state  wherein additionally to the above described configuration in state  the following is present. For each of the transactions, a transactional store  named T\u00d7NSand T\u00d7NSis created. The transactional store T\u00d7NSrefers to each of the stores present in the global state , namely to static node store SNSand to in-memory node store IMS, at the time when the transaction has been started. Furthermore, a new in-memory node store IMS is created for the transaction and referred to in T\u00d7NS. The transactional store T\u00d7NS has the same configuration, but refers to IMS as the in-memory node store for the other transaction,","As one of the transaction is committed (shown by transition ), the database will be configured as shown with state . The transactional store T\u00d7NS of the transaction is deleted and the in-memory node store IMS of the transaction is added as newest data store to the global node store . Additionally, transaction information about the committed transaction is stored in the transactional log file .","Generally, it is shown that a new transaction creates a new IMS  that is part of the transactional node store  associated with a transactional context. This newly created IMS  will reflect all insertions and modifications that are done within the transaction context. This means that the sequence of stores can contain different versions of objects or even attribute values. With this concept the complete system can support transactional inserts and updates based on read only store structures (SNS). When transactions are committed these data stores are added to the global context of the global node store (GNS)  and thus a repeatable read isolation level is supported.","The recovery component as included in the store maintenance and recovery  of  will now be described with reference to .",{"@attributes":{"id":"p-0251","num":"0254"},"figref":"FIG. 12","b":["1210","1220"]},"The transaction stores named Transaction.1  and Transaction.2  are modifiable data stores (IMS) for transactions which are currently being performed by the database, thus being present in the main memory . These transaction stores  and  are writable only for the corresponding transaction for which the transaction store has been created. Furthermore, modifiable data stores (IMS) of previously committed transactions are also present in the main memory . These modifiable data stores, named MemStore.1  and MemStore.2 , are read-only stores. According to an embodiment, the modifiable data stores in the main memory will be stored on the disk  when a predefined threshold value set in the database is reached or when the modifiable data stores are merged with other modifiable data stores within the main memory . However, to prevent lost of data in case of any database failure, data of the modifiable data stores have also been stored in a transaction log file  on the disk  to ensure the possibility of disaster recovery. The disk  further comprises currently used static node stores (SNS) named DiskStore.1 , DiskStore.2 , and DiskStore.3  which may be the result of a previously performed merge operation, a current configuration file Config.1 , and a control file . The configuration file  comprises the ordered set of all static node stores and the name of the currently used transaction log file . The control file  points to the currently used configuration file . Thus, the content of the control file  needs only to be change to switch to a further\u2014newer\u2014configuration of the database. For instance, if the disk  comprises two additional static node stores DiskStore.4  and DiskStore.5  which may be new static node stores currently built by a merge operation and therefore, currently not active, and a new configuration file Config.2 , the configuration of the database may easily be switched to the new configuration file Config.2  after the merge operation has been successfully finished by pointing the control file  to the new configuration file .","As shown in , when a new data store is appended to the sequence or a merge process is completed a new configuration file is created that specifies the new sequence of data stores that specify the bulk of the system state. An additional small file may be used to simply name the current configuration file. This file may be modified in an atomic operation to ensure that it always identifies a valid configuration. The rest of the system state may be maintained in memory and reflected in persisted form in the transaction log. In the event of a failure and restart the transaction log information may be re-read to build the corresponding in-memory structures. The time taken to perform such restarts may preferably be proportional to the time to re-populate those memory structures from the form contained in the log. However, support for high update transaction rates (with fairly simple updates) may be primarily constrained by the cost of disk IOs related to transaction commits. The present embodiment may then support the specification of a configuration parameter to allow an administrator to trade-off restart time for transaction throughput rates. This may be done by changing the amount of memory used before a disk based store is created.","Next, the store maintenance of the store maintenance and recovery component  as shown in  will now be described. In general, the store maintenance has three main operations to make the stores more compact and so guarantees that queries will not suffer from too much fragmentation. These three main operations designated as merge of IMSes, conversion of IMSes into SNSes and merge of SNSes are illustrated in .","The store maintenance is provided to achieve the following aspects:","(1) to minimize the resource utilization require to maintain the indices. Thereby a logarithmic cost in terms of sequential reads and writes of compact representations of the data is achieved. The mechanism exploits the high sequential read and write speeds of, for example, magnetic disk devices that can be contrasted with the relatively expensive random access costs of those devices. It is to be noted that this may require very large files and a substantial disk space overhead.\n\n(2) to minimize the number of read only stores that reflect the state at any specific time and concentrate as much of the information as possible in as few stores as possible. As one key resource cost related to query processing for large data sets is the number of random disk accesses, and this will generally be related to the number of stores, minimizing this parameter is significant.\n\n(3) to support the projection of potentially large numbers of attributes of individual entities by ensuring that a representation of such attributes occupies some contiguous range in some store. This ensures that such information can be accessed in at worst a single disk IO.\n","The store maintenance according an embodiment may achieve the above aspects using background merge processing activities that combine pairs of current committed stores to produce new merged stores. Although merge policies that allow the combination of more than two stores at a time can reduce the overall maintenance costs they can significantly increase the average number of stores active at any time and so increase the average query costs.",{"@attributes":{"id":"p-0258","num":"0261"},"figref":"FIG. 13","b":["1310","1360","1310","361","361","373","362","1310","1315","1320","362","1325","1330","362","373","362","362","1335","362","362","362","1340","362","1345","362","361","373","361","361","1355","361","361"],"sub":["1 ","2 ","3 ","4 ","4 ","3 ","4 ","3 ","4 ","3,4 ","3,4 ","3,4 ","3",{"sub2":"\u2014"},"4 ","2 ","3",{"sub2":"\u2014"},"4 ","1 ","2",{"sub2":"\u2014"},"3",{"sub2":"\u2014"},"4 "]},"The store maintenance may further allow the configuration of different merge polices that can reduce the maintenance costs but will produce substantially higher average numbers of active stores.","As a default merge policy, the average number of active stores is to be minimized at the expense of some additional work for store maintenance.","This default merge policy may involve a form of binary merges. If it is assumed that consecutive committed stores are combined in a straightforward binary fashion the data involved in each commit will be involved in log2 merges. In this case after N stores have been added and merged there will be between 1 and log2 N stores. However, since the creating of disk based stores is avoided according to the described embodiments, and therefore disk based merges are required when the size of the committed store that have not been written to disk, other than in the transaction log, reaches some size that can be set by an user. Up to that point stores are only merged in memory to produce new in-memory read only stores. In general this process will also smooth out variations in the disk based merge activity due to corresponding variations in the amount of data committed in individual transactions. With this basic mechanism the number of disk based stores will be roughly log2 of the total amount of committed data over the space of the smallest disk based store.","Using a pure binary merge policy at any point there will be one store of each power of two multiple of the smallest disk based store size. The alternative employed according to an embodiment reduces the average to something closer to log4. The algorithm merges the new store at the next lower level into a single store at the next higher level 8 times, at which point that store becomes an input to the merges at the next higher level.","The following table illustrates a sequence of 8 store creations for the two policies. In the table the lists to the left of the semicolons indicate the number and sizes of the stores that exist at any point assuming that the merge activity from the previous row has completed before the next store of that size is generated.",{"@attributes":{"id":"p-0264","num":"0267"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},{},"merge","merge","merge"]},{"entry":[{},"N = 8 (as an example)","always","binary","4-way"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Average number of","1","1.625","2.25"]},{"entry":[{},"stores"]},{"entry":[{},"Number of merges","8","7","2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"Number of stores and merges dependant on the number N of insertions of stores of size 1. These numbers hold when N is a multiple of a n-th power of 2 otherwise the numbers for average number of stores and number of merges vary slightly.",{"@attributes":{"id":"p-0266","num":"0269"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"merge","merge","merge","Merge"]},{"entry":[{},"always","binary","4-way","n-way"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Average","1","\u00bd logN","\u00be logN","(n \u2212 1)\/(2 logn) * log"]},{"entry":["number of",{},{},{},"N"]},{"entry":"stores"},{"entry":["Maximal","1","logN","1.5 logN","(n \u2212 1)\/logn * logN"]},{"entry":"number of"},{"entry":"stores"},{"entry":["Minimal","1","1","1","1"]},{"entry":"number of"},{"entry":"stores"},{"entry":["Number of","N","N\/2 \u2212 1","\u2153 (N\/2 \u2212 1)","1\/n (N\/2 \u2212 1)"]},{"entry":"merges"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The following table shows the trade-off between a binary merge and a n-way merge between fragmentation and merge cost. E.g., a 128-way merge has a 110 fold fragmentation compared to binary merge but only about 1\/1000 of cost for ingestion.",{"@attributes":{"id":"p-0268","num":"0271"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]},{"entry":[{},{},{},{},"merge","merge","merge"]},{"entry":[{},"merge","merge","merge","16-","128-","1024-"]},{"entry":[{},"binary","4-way","8-way","way","way","way"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Fragmenta-","1","1.5","2.3","3.75","18.14","110.3"]},{"entry":"tion"},{"entry":"factor"},{"entry":"compared"},{"entry":"to binary"},{"entry":"merge"},{"entry":["Factor in","1","0.5","0.25","0.125","0.0078","0.00098"]},{"entry":"merge"},{"entry":"cost"},{"entry":"compared"},{"entry":"to binary"},{"entry":"merge"},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},"The above described embodiment may provide means for the user to configure the merge parallelism. This enables to optimize the performance of the system for the anticipated behaviour with respect to ratios of entity creations and updates relative to query rates.","The parameters for the policy described above give the closest trade-off between merge costs and store counts assuming only binary merging is performed. Increasing the number of stores involved in the sequential merges (e.g. to 16 or 32) will decrease the average number of stores existing at any time at a roughly proportional increase in the merge costs. Decreasing the number of stores or allowing for greater than binary merges decreases the merge cost at an increase in the average number of stores to be accessed during query processing.","The update masking will now be described in more detail. As mentioned above, a critical component to allow the use of read only structures is the ability to mask matches for entities that are represented in multiple stores due to updates so that only matches against the current value of that entity are seen. Further, the cost of this masking must not outweigh the benefits of the use of the read only structures. Thus, according to an embodiment means are provided to achieve the above that rely on generic GapAccessors over the sets of entity IDs that exist in each store. The cost is also reduced by keeping the number of stores low with the mechanism of the store maintenance that guarantees exponential pattern of store sizes. The fact that store sizes grow exponential with age means that many operations only need the bigger and older stores and do not suffer from fragmentation.","The committed state of the system is a temporal sequence of committed stores, the larger and older ones are disk resident, while the newer and smaller ones are memory resident. The view seen by a transaction is made up of the set of committed stores that existed when the transaction was started, along with an updatable store that reflects new entities that are created during the transaction or updates to existing entities.","When any attribute of an entity is updated or a new attribute is added the non-updated attributes will at some point be copied into a new store that will then contain all of the current state for that entity (and corresponding index structure's). Each store maintains an ordered long set that consists of the set of entity IDs for entities that exist in that store. The set that is visible from any store is then the set of all those that exist in that store but do not exist in any more recent store. The following specifies the GapAccessor that is created to identify the set of entities for all stores that match some predicate P.","For example, it is assumed that the database comprises a sequence S, . . . , Sof stores where Sdenotes the oldest store and Sthe newest. GA(S) is the GapAccessor over the ID set for store Sand is maintained within each store (with a structure S,IDs that contains the set of entity IDs whose entity representation exists in that store). For all entities that are modified (or deleted) in newer stores a mask operator is needed that allows to mask out the IDs that exist in newer stores efficiently. For this, a mask is used which is defined by the GapAccessor GA(S) which is the union of all newer IDs, i.e., GA(S)=unionGA(Sj).","The GapAccessor for the mask will now be used to restrict the result set that a predicate has some predicate P. Assume that the GapAccessor GA(S,P) produces the ordered set of all IDs in store Sthat satisfy predicate P. The set is polluted by entities that are modified (or deleted) in the meantime. To get the correct result we have to compute the difference between this set and the Mask for all entities modified in newer stores. i.e., GA(S,P)=GA(S,P)\u2212GA(S)=GA(S,P)\u2212unionGA(Sj).","In the description above it may seem that it would have a quadratic (in the number of stores) number of masking accessors as the j-th store will need to be masked by all stores greater than j, the (j+1)-th by all greater than j+1 and so on. The above described embodiment avoids this explosion by reusing the same GA(S) for all requirements for masks for S. This loses some of the potential efficiencies from almost sequential accesses for the same accessor (although the expected costs are still at worst logarithmic), but avoids the need for a quadratic number of accessors.","The performance of this masking procedure is also related to the exponential growth, and the base for that growth, in the store size from the newest to the oldest stores. As the maximum size of a store at level i is 8 times that at the next lower level the vast bulk of the data will be in the oldest 1-3 stores. The ID sets of the smaller stores will then constitute a small fraction of the total number of IDs.","An example of the above described update masking is shown in .",{"@attributes":{"id":"p-0279","num":"0282"},"figref":"FIG. 14","b":["1401","1402","1403","1404","1405","1402","1405","1402","1402","1403","1404","1403","1406"]},"In the following, embodiments of the database with respect to different configurations of the data stores, particularly the static node stores, will be described in more detail. The read only node stores (named static data stores, static node stores or SNS) are adapted to hold the bulk of the committed data.","A first embodiment of the static node store  will be described with reference to .","The static node store  comprises a store subset (also referred to as ordered ID subset)  for storing each of the identifiers of the data entities stored in this static data store  and a unique subset identifier provided in the static data store  which is mapped to the identifier. A field map  for storing a field name for each of the fields of the data entities stored in the static data store  and an offset associated with each field name is provided in the static field store . A field store  for storing the single or multi valued value of each of the data entity fields of the data entities stored in the static data store  which are designated by the same field name in a field store  provided in the static data store . The above offset defines the position of the field store  in the static data store .","The above described configuration of the static node store may be generated during the conversion of one or more selected data stores of the ordered set of data stores by the following steps.","Each of the identifiers of the data entities stored in the new static data store and a unique subset identifier provided in the new static data store which is mapped to the identifier in a store subset provided in the new static data store is stored. A field name for each of the fields of the data entities stored in the new static data store and an offset associated with each field name in a field map provided in the new static data store is also stored wherein the offset is calculated based on the position of the field store in the new static data store. Then, the single or multi valued value of each of the fields of the data entities stored in the new static data store which are designated by the same field name in a field store provided in the new static data store is stored.","The static node stores  may further comprise a row oriented projection store (not shown in ). The row oriented projection store may use the configuration as known in the art, especially in the field of relational systems. In the row oriented projection store, each individual value may be encoded as byte sequences. The structure of the row oriented projection store may be a simple concatenation of field ids and value representations, where the latter just use a simple encoding of the multiple heterogeneous values. The space consumed for such representations, or random access to individual field values, can be trivially optimized using standard dictionary approaches exploiting the read only nature of these stores.","With respect to the above description, each static node store maintains the ordered set of internal object IDs (64 bit unsigned integers) which have data in that store. It is used to obtain the masks required to support the migration of update values to new stores. Internal to an SNS the indices and value store represent their information with respect to indices in the OID array for the SNS, rather than replicating the potentially much larger actual OID values throughout. This level of indirection may add to the complexity of query evaluation and store maintenance, but makes up for this with reductions in the space consumed by the index structures, which for full text indices in particular can have very large numbers of references to each object. The OID array is then used to map those back to the internal IDs for operations that span multiple SNSes. This mapping overhead is avoided for many operations by allowing evaluations to occur within the store internal ID space reflected by the OID array indices. For example, an entity filtering expression such as \u201c(A or B) and (C or D)\u201d can be completely evaluated within each SNS on the basis of these OID array indices before mapping the results to the global OIDs needed for merging with results from other stores.","The SNS OID arrays  may according to one embodiment be implemented using the above described OUIS structure.","A further configuration example of the static node store  is shown in . The static node store  of  differs from the configuration of the static node store of  in that it further comprises a header  wherein information about the static node store  and the configuration thereof may be stored.","Furthermore, field store  may contain a set of column oriented value stores  also used as projection indices. Each field maintains the ordered set of the IDs of the objects in this store that have a value for the specified field in a field OID subset . It is used as a mask for field operations. The field OID subsets  may be implemented with the OUIS structure. The field stores  may also contain an OUIS  as an index per type.","Another embodiment of the field store  is shown in . According to this embodiment, the field store may comprise a base projection store, a dynamic n-gram dictionary, a projection store overflow, and a plurality of inverted indices per type .","The base projection store  may be a structure that holds the value entries for the field store. The base projection store  is optional because the field lookup can also be done in the row based value store as described above. The use of this structure can speed up evaluations where many values of a field need to be looked up (e.g. for predicates that are not supported by indices) because the layout in the storage hierarchy is more compact than a structure where the values of complete rows are folded. The base projection store  may better exploit storage, memory and cache hierarchies.","Following, the projection store overflow  and the dynamic n-gram dictionary  will be described in more detail.","The dynamic n-gram dictionary  may be provided according to one embodiment, preferably in conjunction with the per field projection store (base projection store ) and the projection store overflow  to support the following operations.","Standard projection requirements often involve only a small number of attributes associated with one entity. One of the most common operations in document management systems is browsing. The browsing operation requires at least the attributes: name, type, size, modification date and creator, while a typical entity has much more associated fields. For example, in a row based store where entities are randomly selected, full memory blocks of row based representations are fetched to obtain only the five attributes mentioned above from a single entity stored in that block. Such issues are one reason why typical RDB implementations spend much effort on page pining and related algorithms. Further, depending on the row value representation within the memory block the effort of extracting the desired values could be significant. The structures noted may also provide substantially better compression than a row based representation. It is the intention of the dynamic n-gram dictionary  to have much higher likelihood of having the required info in Random Access Memory (RAM) so that access to individual value is faster and decoding is quicker.","In aggregation operations (also known as groupby-operation) generally a small number of fields is scanned to collect statistical information. As the entries in the projection store  and its overflow  are encoded relative to the global static dictionary (not shown in ) provided in the database or each static node store for the type, and the dynamic n-gram dictionary , using the indices into each whose ordering reflects the natural ordering for the type, it is possible to perform operations such as aggregating for a histogram without reference to the dictionaries, based solely on the dictionary references used in the projection store, once any literals associated with the request have been looked up.","In the rare case that a user specifies a predicate on some field that does not have an inverted index provided, the projection index provides the potential for a cheap scan and test operation on the value of the field provided in the predicate. This may be done by providing rapid random access from a store level OID to the encoded value(s) set for that OID for this field.","The implementation of the dynamic n-gram dictionary  may use the same dictionary structure as the static dictionary, with the difference that what goes in may be the set of n-grams actually observed in this field, with their statistics used to improve the performance of the lookup as they will generally be in accordance with Zipfs law, just as the static dictionary entries are. According to an embodiment, the n-gram tokens may be encoded in some manner to limit the number of bits of each n-gram. In the case of \u201clatin alphabet\u201d natural language text, this means to simply encode each character in a 5 bit value and concatenate these. In this case n=5 or n=6 is chosen, along with a flag to indicate the position of the n-gram within the token, to limit the size of these values to <=32 bits. Then all keys used in the inverted indices or the projection index may be indices into either the global static dictionary for the type or the dynamic n-gram dictionary . Where pairs of high frequency n-grams occur together, as with pairs of high frequency words, phrase level inverted indices may be used to speed the processing of predicates who's literal is a phrase or exceeds the size of a single n-gram.","According to an embodiment, the projection store overflow  may be provided to deal with cases where the representation of the value that occurs for some OID for this field does not fit in the compact space allowed for each entry (i.e., the number of bits required to specify a dictionary reference). This may occur when the value is multi-valued or a multi-token (word or n-gram) full text value whose encoding takes more than one dictionary reference. In such cases the dictionary reference in the projection store  may be replaced with an offset into a block of encoded values. The number of blocks may be determined at store creation time to ensure that the number of bits available in a projection store entry is adequate to reference any value in the block. The values may be stored in the same order in the projection store overflow  as in the base projection store  and the projection store overflow  and may further provide an array of block base pointers whose size corresponds to the number of blocks.","The indices  of the field stores  will be described in more detail below.","The inverted index may comprise an index into the OID array to indicate that the OID at that location matches this predicate for this key, and a key provided as an unsigned integer produced as a dictionary index or as a chunking of some encoded value.","Multiplies the latter by the maximum index in the OID array (S) for a SNS to get the index entry. The entries associated with a key K will then have values in the range KS to (K+1)S. The set of all such values for a given index are stored in an OUIS. It is noted that the OUIS may automatically compress this structure as the space for keys that are repeated many times is factored out to the higher levels, and dense sequences of references are compressed in the low level chunks as well.","A variant referred to as a subset index may be used when predicates for a set of keys K\u2032 is to be supported such that a base index for a set of keys K of which the K\u2032 forms a partition of all occurrences can be provided. For example, if it is assumed that a date field and an index whose keys identify dates at a monthly granularity are provided, the set of all OIDs that match a particular month can be rapidly identified. If matches for a particular day are also to be quickly identified, an additional full index with references to the OID array, or a subset index may be used. The references for each day in each month are then indices into the range of the base index that corresponds to the month that includes that day. This range can often be much smaller than references to the entire OID array as the date field likely only occurs in a subset of all entities and the keys may identify many tens to hundreds of months. The references for the days in a particular month only need to be as large as the number of occurrences of that month. Further, the space for the monthly index will be significantly smaller than direct daily indices as on average each key will have about 30 times as many entries as the daily keys, so the OUIS compression will on average produce entries that are close to 5 bits smaller. However, processing the daily queries will involve the overhead of mapping through the monthly index each time. This cost may be offset to some degree by the potential reuse at a lower level in the memory hierarchy of the more compact monthly index. The subset index can have even more benefits for the more complex index variants needed to support various word containment predicates as described below. The key in all cases is to select base indices that most closely reflect the keys most commonly used in queries, and use subsets to enhance the performance of more rarely used, but still possible, key sets.","It is noted that the stores and corresponding indices may be continuously rewritten according to the above described embodiments. One way to exploit this is to monitor the predicates and key sets that are used in queries and select appropriate base and subset indices to optimize the performance of the anticipated query set and the maintenance of the index.","A base word containment index for the SNS may consist of word level addresses that are combined with a segment map structure that identifies the boundaries in these ranges between the various segments the system supports. As noted above these could be at the granularity of sentences, paragraphs, sections or full values. The addresses may be modified to sentence level, and possibly SVO identifiers. The default keys for the above embodiments may be the stem indices produced by the stemming dictionary, but also Wordnet synset like indices may be used.","The base index may further be combined with the segment maps to produce the segment level relevance ranking as well as the support for structured attributes needed for the attribute set requirement.","The remainder indices may be used to support word containment predicates that use modifiers to specify some variant of the word relative to the default provided by the base word index. For example, assume that a derivational morphology stem may be used as the base form for searches, but the query wants the surface form with the exception of the case and accent information. The remainder indices identify these variants as subsets of the postings associated with the base form. It is noted that these remainders are ordered and form a nested set of equivalence relations. Again with a default relation of derivational morphology stem the remaining relations are the inflectional morphology stem and the case and accent sensitivity. For example, in this case the surface form Indestructible would become destroy, +ible+in, none, Capitalized and the surface form destroying would be destroy, none, present participle, none.","According to one embodiment, the implementation may be analogous to the phrase index with multiple levels to handle the nested relations as described below.","A nested set of ordered tuple sets, encoded as U8s, may comprise the following fields key1, key2 and SS identifier in order.","The key1 may be a previous level key. At the top level this may correspond to a key in the base index. At each subsequent level this key may be the index of the structure identified to this point. For the above destroy example, the top-level key is the index of destroy in the dictionary that contains only base forms. The second level set key1 is the index in the top level of the entry for destroy and the derivational morphology variant identified by the key2 field in that entry.","The key2 may be an index into the dictionary of remainders that apply at this level. For example, at the top level this would be a dictionary of all of the derivational morphology variants that occur, or in the initial global dictionary for such variants.","The SS (subset) identifier may be an identifier of the subset indices described below which are partitioned by the sizes of the subset indices (i.e. the # of occurrences of the base key) to optimize the space required. This will be determined by the number of occurrences of the key1 word.","A set of subset indices that are ordered set of pairs, encoded as U8s, with the fields key pair index and subset index in order.","The key pair index may be the index of an element in the above pair set and the subset index may be the index in the order set of entries at the next higher level. For the top-level this will be the postings lists of the base form. For the other levels these will be the subsets identified by the enclosing key.","In a further embodiment, the person skilled in the art may provide means of a database system adapted to perform the method steps of the above described embodiments.","The above described embodiments may be implemented as components of a sample application such as a system that manages all emails, instant messages, blog posts and wiki posts in an organization, along with all the associated entities related to those entities such as the various types of email senders and recipients, including people, email lists, mail boxes, application based email enabled entities. The emails have attributes such as subject, body, and date and relationships to the other entities noted as senders and recipients as well as other entities such as attachments. The people may have multiple names that have potentially complex internal structures such as multiple middle names or hyphenated last names. Other applications (e.g. a records management system) may also attach other attributes to any of these entities to support their operations.","As described above, the method for performing transactions on a database and the transactional database according to the embodiments of the present invention have been described with reference to the exemplary drawings. However, the present invention is not limited to the embodiments and the drawings disclosed in this specification, and various changes and modifications can be made without departing from the scope of the present invention as defined by the accompanying claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["Further advantageous embodiments and aspects of the present invention are disclosed and will become more apparent by the accompanying drawings described in the following and illustrating an implementation and exemplary embodiments of the present invention and, together with the description and the appended claims, serve to explain the advantages and principles of the invention.","In the drawings,",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIGS. 4-6"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIGS. 8A and 8B"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
