---
title: Automatic incremental application dependency discovery through code instrumentation
abstract: Disclosed is a method allowing the automatic discovery of application component dependencies by tracing application calls to dependant resources. The call tracing is embedded dynamically in an application at runtime using Common Intermediate Language (“CIL”) code instrumentation at compile time or runtime. Such a method reads an instrumentation configuration file to determine an address extraction code portion that is to be instrumented to an application method code, locates the CIL method body for the application method that is to be instrumented, instruments the application method by inserting the address extraction code portion into the appropriate .NET Application or .NET library at either compile time or at run time, extracts the address of one or more external service providers from the designated .NET library methods responsible for communication during execution of the application method that was instrumented, publishes any newly discovered dependencies to a management system in the form of the discovery event, and causes the management system to build an application dependency map based on the resource address information obtained.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104794&OS=09104794&RS=09104794
owner: Microsoft Technology Licensing, LLC
number: 09104794
owner_city: Redmond
owner_country: US
publication_date: 20090715
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","DESCRIPTION OF THE BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This application is based upon and claims benefit of copending U.S. Provisional Patent Application Ser. No. 61\/134,900 entitled \u201cAutomatic Incremental Application Dependency Discovery Through MSIL Code Instrumentation\u201d, filed with the U.S. Patent and Trademark Office on Jul. 15, 2008 by the inventors herein, the specification of which is incorporated herein by reference.","This invention relates generally to application dependency discovery, and more particularly to incremental dependency discovery using application instrumentation.","In many organizations, operations teams are charged with management and support of applications without getting clear information about the application topology and infrastructure provided by the application development team. It makes application management, change control, and impact analysis tedious and sometimes impossible. In those scenarios, the application is like an unpredictable and unstructured black box for operations.","For effective change control and impact analysis, the operations team has to discover application dependencies and analyze how a change to one component may affect other dependent components. Today, the only way to discover dependencies is to get a blue print from the application development team that describes the application architecture. After that, the blue print needs to be updated every time a new version of the application is deployed. That process is labor intensive and error prone.","The difficulty in comprehending application dependencies becomes even more complex when dealing with distributed applications, which are typically characterized by components running on several different machines, written in different languages, and interacting in complex ways. For instance, modern Enterprise .NET applications have a distributed architecture and may consist of a number of components talking to each other via various communication protocols. In some cases, they also rely on external service providers. Communication with external service providers is typically performed using Web Services. If we consider a single application component, it may have a number of dependencies on internal service providers that correspond to other components of the distributed application and on external service providers that may be outside of the boundary of the distributed application. A misbehavior or a change in any of the service providers may affect the functionally or availability of the application component.","It would therefore be advantageous to provide techniques by which application dependencies existent in distributed applications could be discovered, regardless of the manner in which the distributed application was developed, and particularly regardless of whether the separate application components are developed in different languages, or run on multiple machines, or interact in complex ways.","In accordance with one particularly preferred embodiment, an exemplary method allows automatic discovery of application component dependencies by tracing application calls to dependant resources. The call tracing is embedded dynamically in an application at runtime using Common Intermediate Language (\u201cCIL\u201d) (formerly referred to as Microsoft Intermediate Language, or \u201cMSIL\u201d) code instrumentation at compile time or runtime. Such a method reads an instrumentation configuration file to determine methods that need to be instrumented, locates the CIL method body for the application method that is to be instrumented, instruments the application method by inserting an address extraction code portion into the appropriate .NET Application or .NET library at either compile time or at run time, extracts the address of one or more external service providers from the designated .NET library methods responsible for communication during execution of the application method that was instrumented, publishes any newly discovered dependencies to a management system in the form of the discovery event, and causes the management system to build an application dependency map based on the resource address information obtained.","The invention summarized above may be better understood by referring to the following description, which should be read in conjunction with the accompanying drawings in which like reference numbers are used for like parts. This description of an embodiment, set out below to enable one to practice an implementation of the invention, is not intended to limit the preferred embodiment, but to serve as a particular example thereof. Those skilled in the art should appreciate that they may readily use the conception and specific embodiments disclosed as a basis for modifying or designing other methods and systems for carrying out the same purposes of the present invention. Those skilled in the art should also realize that such equivalent assemblies do not depart from the spirit and scope of the invention in its broadest form.","Disclosed herein are methods by which dependencies existing among disparate .NET application components may be automatically discovered, regardless of the extent to which those components are separated in a distributed architecture, by using application instrumentation to trace application calls to dependent resources. As used herein, an application is \u201cinstrumented\u201d by inserting code that extracts the address of external service providers called by a particular application at compile time or runtime. This code insertion process is referred to as \u201cinstrumenting\u201d as it provides \u201cinstruments\u201d for monitoring distributed applications, and more particularly for determining dependencies among separate components of distributed applications, so as to allow an administrator to effectively manage change control and impact analysis.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["100","200","110","120","110","100","120","100","100","200","210","210","215","110","120"]},".NET applications that rely on communication libraries, such as those depicted in  at , typically reference compiled versions of those libraries. Such .NET libraries are compiled into an intermediate language called Common Intermediate Language, or \u201cCIL.\u201d CIL preserves the overall application structure. During the compilation process, application classes and methods in an application source code are converted into corresponding classes and methods in CIL code. During application execution, the Common Language Runtime (CLR) converts CIL code to machine code and executes the instructions in the code. Conversion of an application method to the machine code is done before the first execution of the method.","With regard to a first particularly preferred aspect of the invention, an instrumentation module  is in communication with .NET libraries  and .NET Application , such that instrumentation module  may instrument methods  that are responsible for connecting .NET application  to or communicating it with distributed service providers. As discussed in greater detail below, the instrumentation code that the instrumentation module  inserts into methods  comprises extraction code , which extracts the address  of an external service provider from particular parameters or member variables of library methods  that are responsible for the communication between .NET application  and such external service providers. After the external service provider address  is extracted from the respective library or application method , the instrumentation module  compares the extracted external service provider address  with a list of previously discovered dependencies, and determines whether the stated dependency has previously been discovered. After such analysis, the instrumentation module  publishes any extracted new dependency information to a management system  in the form of a discovery event . The management system subscribes on the discovery events  published by instrumentation module , collects them, and based on the external resource address information builds an application dependency map , which in turn may be used by a manager, administrator, programmer, or other user of the .NET application to evaluate and understand the dependency relationships between the .NET application and its various external, distributed components and services.","In order to instrument the code, instrumentation module  must have information about what methods are responsible for communication with external service providers and need to be instrumented, how to instrument those methods, and how to extract external service provider address  from instrumented method parameters and member variables. This information can be hardcoded in the instrumentation module  or placed in one configuration file or several configuration files. Placing this information in the configuration files allows adjusting the instrumentation without changing the instrumentation module  itself.","The list of methods to instrument is defined by the list of communication protocols for which the dependency discovery needs to be supported. For each supported communication protocol, the instrumentation configuration contains a list of methods from .NET application  or a communication library  that are responsible for connecting to or executing requests for an external service provider. The list of methods is identified manually by analyzing source code or CIL code for .NET application  or a communication library  and selecting the methods that connect to or execute a request for an external service provider. In order to connect to or to execute a request for an external service provider, a method that is responsible for communications must have an address of that external service provider. For instance, in the case of database providers , the address is typically presented in the form of a connection string. Further, in the case of application-to-application communications, address information is typically presented in a form of a Uniform Resource Identifier (URI). The address is typically accessible thought parameters or member variables of a method responsible for the communication. For each communication method, the instrumentation configuration contains an extraction rule definition that contains information on how to access the external service provider address from the instrumented method parameters or member variables. The address information can be stored in one of multiple member variables or parameters. If a member variable is an object, the address information may be stored in one of the member variables or properties of this object. Address information may be represented by a complete member variable or parameter value, or by a part of the value. The extraction rule definition contains information about what parameters or member variables contain address information and how to extract the address from the values of those parameters or member variables. The extraction rule definition defines extraction code  that will be used for reading the address. The extraction code  can access member variable or parameters values directly or through using .NET reflection. The direct access requires a compile time dependency on a communication library, or a .NET application that contains an instrumented method. .NET reflection is a mechanism that allows reading values based on their names without compile time dependency. If extraction code  reads values directly, then unique extraction code needs to be created for each instrumented method. If extraction code  uses .NET reflection to read values, then common extraction code can be used for instrumenting different methods. The common extraction code relies on a declarative definition in the instrumentation configuration to identify names of member variables or parameters that need to be read to extract the address. A declarative approach for extraction code offers more flexibility and allows expanding the list of supported communication protocols without creating custom extraction code for each new protocol. The drawback of using declarative methods, however, is relatively slow performance. Reading a value using .NET reflection is significantly slower than reading a value directly. As a result, direct access extraction rules will typically offer better performance. Because extraction occurs during application execution, performance is an important feature, thus providing a potential preference for the use of direct access extraction rules.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 1"],"b":["300","500","300","300","300","210","215","300","310"]},"Next, at step , and based on the method name, instrumentation module  locates the particular CIL method body for the application method  that needs to be instrumented. At step , instrumentation module  inserts the extraction code  in the method body to extract information about application dependencies. In accordance with a particularly preferred embodiment of the invention, step  and step  may be carried out either at compile time or at run time. The decision to do the instrumentation at compile or runtime is based on the usage scenarios. Compile time instrumentation allows instrumentation to be carried out only once during the compile time, but after that instrumentation is fixed. Runtime time instrumentation requires executing instrumentation during each application load. Runtime time instrumentation is more flexible but requires access to the application runtime environment and creates extra overhead during the application load process. If the instrumentation is to be carried out at compile time, the instrumentation module  reads metadata for an assembly file for the .NET application  or communication library  that contains a method being instrumented. The metadata contains a list of classes and methods defined in the assembly combined with information about method body location within the assembly. The instrumentation module  looks up the method body address based on the method name from the list of methods in the assembly metadata and retrieves the method body Alternatively, if the instrumentation is to be carried out at run time, instrumentation module  subscribes on Just in Time (JIT) compilation callbacks of the .NET profiling API. The JIT compilation callback passes function ID to the instrumentation module . The function ID uniquely identifies a function within an application or library. Based on the function ID received from the JIT callbacks, the instrumentation module  calls the profiling API and retrieves the method body for the method  being instrumented. The instrumentation module  modifies the method body by adding the extraction code  to the method body. The extraction code  can be inserted directly into the method body or the extraction code  can be kept as a separate extraction method, in which case a call to the extraction method is inserted into the method body.","After adding the extraction code  to the method , at step  instrumentation module  modifies method body for method  by adding additional analysis code  for analyzing the extracted data. The analysis code  contains logic to compare the address value extracted by the extraction code  with a list of addresses for previously discovered dependencies. After the particular method or methods  have been instrumented with both the extraction code  and the analysis code , at step , and when the instrumented .NET application executes, the extraction code  extracts the address of one or more external service providers from library methods  that have been instrumented as discussed above.","After the address information has been extracted, at step  the analysis code  compares the extracted address information with a list of previously discovered dependencies to determine whether a dependency already exists. If a dependency already exists in the list of discovered dependencies, the newly obtained address information is discarded. If, however, a dependency does not already exist in the list of previously discovered dependencies, then the newly obtained address information is added to the list of discovered dependencies at step .","In addition to adding the newly obtained address information to the list of discovered dependencies, instrumentation module  at step  also publishes any such newly discovered dependencies to management system  in the form of a discovery event , which contains information about the distributed application component and information about the detected dependency. The discover event  may be published, by way of non-limiting example, via WMI, SNMP, or any other eventing mechanisms as will be apparent to those of ordinary skill in the art. The format of the discovery event is based upon the particular eventing mechanism used. Management system  preferably subscribes on the discovery events , collects them, and at step  builds an application dependency map . To build the application dependency map, the management system  reads information about the distributed application component and discovered dependency component for the discovery event, and checks if those components already exist in the dependency map. If either components or one of them does not exist in the dependency map, the management system  adds the corresponding component or components to the list of components in the dependency map. Next, the management system  verifies if a dependency between the distributed application component and the discovered dependency component already exists in the dependency map. If the relation does not exist, the management system  adds the dependency to the map.","Instrumentation module  and the method depicted in  may be implemented on a computer system, an exemplary embodiment of which is shown in . A computing device  may include at least one processor  and system memory . System memory may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.), or some combination of the two. System memory  may include an operating system , one or more program modules , and program data . Operating system  may include a component-based framework that supports components, objects, inheritance, polymorphism, and reflection, and may provide an object-oriented component-based application programming interface (API), such as that of the .NET\u2122 Framework manufactured by Microsoft Corporation, Redmond, Wash. Computing device  may also include additional removable data storage devices  and non-removable data storage devices , such as, by way of non-limiting example, magnetic disks, optical disks, or tape. Such computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. Each of system memory , removable storage , and non-removable storage  may include RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be accessed by computing device . Computing device  may also include one or more input devices , such as a keyboard, mouse, pen, voice input device, touch input device, etc., one or more output devices , such as a display, printer, speakers, etc., and such other devices as may be particularly suited to a specific application as will be evident to those of ordinary skill in the art. Moreover, computing device  may also include a communications manager  allowing communication between computing device  and other, external computing devices , such as over a computer network. Communications manager  may be implemented through computer readable instructions, data structures, program modules, or other data in a modulated data signal (i.e., a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal), such as a carrier wave or other transport mechanism, and includes any information delivery media, and may include wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media.","Having now fully set forth the preferred embodiments and certain modifications of the concept underlying the present invention, various other embodiments as well as certain variations and modifications of the embodiments herein shown and described will obviously occur to those skilled in the art upon becoming familiar with said underlying concept. It should be understood, therefore, that the invention may be practiced otherwise than as specifically set forth herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":["The above and other features, aspects, and advantages of the present invention are considered in more detail, in relation to the following description of embodiments thereof shown in the accompanying drawings, in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 3","FIG. 1","FIG. 2"]}]},"DETDESC":[{},{}]}
