---
title: Column redundancy for digital multilevel nonvolatile memory
abstract: A digital multilevel bit memory array system comprises regular memory arrays and redundant memory arrays. A regular y-driver corresponds to each memory array to read or write contents to a multilevel bit memory cell and compare the read cell content to reference voltage levels to determine the data stored in the corresponding memory cell. Likewise, similar functions are performed by the redundant y-driver circuit for the redundant memory array. During the verification of the contents of the memory cell, if the read voltage is outside a certain margin requirement for a level of the reference voltage, a signal is generated in real time so that data from the bad y-driver is not output and data from the redundant y-driver corresponding to the redundant memory array is read out. The memory array system may also include a fractional multilevel redundancy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06992937&OS=06992937&RS=06992937
owner: Silicon Storage Technology, Inc.
number: 06992937
owner_city: Sunnyvale
owner_country: US
publication_date: 20030728
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates to a memory having column redundancy, and more particularly a digital multilevel nonvolatile memory having column or segmented column redundancy.","Memory devices frequently use redundant columns for replacing columns of memory cells that are defective in order to improve manufacturing yield. The selection of the redundant columns is typically done in a test mode at the manufacturing facility. The memory cells are tested and if a column or portion of column is defective, a fuse is set to disable selection of the defective column and enable the redundant column.","In one aspect of the invention, a memory comprises a first memory array that includes a plurality of memory cells arranged in columns and a redundant memory array that includes a plurality of redundant memory cells. Each of a plurality of y-drivers is coupled to a corresponding column of memory cells to read contents of selected memory cells in the column. A validation circuit tests a voltage level of stored data in the memory cells. Each of a plurality of redundant y-drivers is coupled to a corresponding column of redundant memory cells to read contents of redundant memory cells in the column. A comparison circuit generates a selection signal to enable the redundant memory array and a disable signal to disable a portion of the first memory array in the event of a failure of the testing of the voltage level. The memory may include fractional multilevel redundancy.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 1","FIG. 1A","FIGS. 1 and 1A"],"b":["100","100","100"]},"For the purpose of illustration, a gigabit nonvolatile multilevel memory system is described. In one embodiment, the memory array includes a source side injection flash technology, which uses lower power in hot electron programming, and efficient injector based Fowler-Nordheim tunneling erasure. The programming may be done by applying a high voltage on the source of the memory cell, a bias voltage on the control gate of the memory cell, and a bias current on the drain of the memory cell. The programming in effect places electrons on the floating gate of memory cell. The erase is done by applying a high voltage on the control gate of the memory cell and a low voltage on the source and\/or drain of the memory cell. The erase in effect removes electrons from the floating gate of memory cell. The verify (sensing or reading) is done by placing the memory cell in a voltage mode sensing, e.g., a bias voltage on the source, a bias voltage on the gate, a bias current coupled from the drain (bitline) to a low bias voltage such as ground, and the voltage on the drain is the readout cell voltage VCELL. The bias current may be independent of the data stored in the memory cell. In another embodiment, the verify (sensing or reading) is done by placing the memory cell in a current mode sensing, e.g., a low voltage on the source, a bias voltage on the gate, a load (resistor or transistor) coupled to the drain (bitline) from a high voltage supply, and the voltage on the load is the readout voltage. In one embodiment, the array architecture and operating methods may be the ones disclosed in U.S. Pat. No. 6,282,145, entitled \u201cArray Architecture and Operating Methods for Digital Multilevel Nonvolatile Memory Integrated Circuit System\u201d by Tran et al., the subject matter of which is incorporated herein by reference.","The digital multilevel bit memory array system  includes a plurality of regular memory arrays , a plurality of redundant memory arrays (MFLASHRED) , a spare array (MFLASHSPARE) , and a reference array (MFLASHREF) . The system  includes a total of, for example for one giga bits, 256 million nonvolatile memory cells for a 4-bit digital multilevel memory cell technology or 128 million nonvolatile memory cells for a 8-bit digital multilevel memory cell technology. An N-bit digital multilevel cell is defined as a memory cell capable of storing 2levels.","In one embodiment, the memory array system  stores one gigabits of digital data with 4-bit multilevel cells, and the regular memory arrays  are equivalently organized as 8,192 columns and 32,768 rows. Addresses A<:> are used to select a row, and addresses A<:> are used to select two columns for one byte. A page is defined as a group of 512 bytes corresponding to 1,024 columns or cells on a selected row. A page is selected by the A<:> address. A row is defined here as including 8 pages. A byte within a selected page is selected by the address A<:>. Further, for each page of 512 regular data bytes, there are 16 spare bytes that are selected by the address A<:>, which are enabled by other control signals to access the spare array and not the regular array as is normally the case. Other organizations are possible such as a page including 1024 bytes or a row including 16 or 32 pages.","The reference array (MFLASHREF)  is used for a reference system of reference voltage levels to verify the contents of the regular memory array .","The redundancy array (MFLASHRED)  is used to increase production yield by replacing bad portions of the regular memory array . The use of page mode operation (described in more detail below) and serial style address input improve the memory system described herein for media type data storage applications. Such memory applications typically use separate controller chips to manage the data storage in many ways similar to the chips used for rotating media data storage but with better system mechanical robustness and lower power consumption. The controller chip can typically work around defects that are page oriented. For instance, if an entire row of memory is defective, the controller chip can store the addresses of the 8 bad sequential pages that make up that bad row and prevent them from ever being used. The bad addresses are \u201cmapped out\u201d of the usable address space. One bad row out of 32,768 total rows represents a small amount of memory loss that is easily worked around. The bad page addresses can be supplied to the controller; as a separate data file during system manufacture, determined by interrogating the memory chip during system power up, or determined on the fly by system behavior in the field. Random single cell defects can be repaired in the same way at the system hierarchy by mapping out bad bytes, pages or rows. However, column related defects have much greater impact and are harder to work around. For instance, one bad column spans all 32768 rows and would map out 32768 bad bytes out of (8\u00d7512\u00d732768) total bytes or 1\/4096th of the memory. That is 8 times worse than a row defect in terms of memory loss and uses complicated (slower) algorithmic address generation instead of simple look-up tables for the controller to handle the address mapping. Thus, on memory chip column redundancy is very desirable. The redundancy array  accomplishes the desired column redundancy as described below. For the purpose of illustration, the redundancy array  includes 4 subarrays, but other numbers of subarrays may be used.","The spare array (MFLASHSPARE)  can be used for extra data overhead storage such as for error correction and\/or memory management (e.g., status of a selected block of memory being erased or programmed, number of erase and program cycles used by a selected block, or number of bad bits in a selected block). In another embodiment, the digital multilevel bit memory array system  does not include the spare array .","The digital multilevel bit memory array system  further includes a plurality of y-driver circuits , a plurality of redundant y-driver circuits (RYDRV) , a spare y-driver circuit (SYDRV) , and a reference y-driver (REFYDRV) circuit .","The y-driver circuit (YDRV)  controls bit lines (also known as columns, not shown in ) during write, read, and erase operations. Each y-driver (YDRV)  controls one bitline at a time. A y-driver circuit  (shown in ) comprises a pair of y-drivers (YDRV)  that are used to control a pair of columns. Time multiplexing may be used so that each y-driver  controls multiple bit lines during each write, read, and erase operation. The y-driver circuits (YDRV)  are used for parallel multilevel page writing and reading to speed up the data rate during write to and read from the regular memory array . In one embodiment, for a 512-byte page with 4-bit multilevel cells, there are a total of 1024 y-drivers  or a total of 512 y-drivers . A y-driver  is used for one byte of data; hence within a page, byte addressing is referred to interchangeably as y-driver addressing.","The reference y-driver circuit (REFYDRV)  is used for the reference array (MFLASHREF) . In one embodiment, for a 4-bit multilevel cell, there are a total of 15 or 16 reference y-drivers . The function of the reference y-driver  is similar to that of the y-driver circuit  with many functions possibly not used such as those associated with data latches (described in more detail below in conjunction with ).","The redundant y-driver circuit (RYDRV)  is used for the redundant array (MFLASHRED) . The function of redundant y-driver circuit (RYDRV)  is similar to that of the y-driver circuit (YRDRV) . In one embodiment, for redundancy described herein, there are a total of eight redundant y-drivers  to fix up to eight \u201cbad\u201d columns (4 bytes) at a time during write, read, and erase operation. The reason is as follows. Due to page mode operation, all y-drivers including all the redundant y-drivers  operate at the same time on a selected page (unless time multiplexing is used), and because there are eight redundant y-drivers, only eight possible redundant columns can be used at a time (per selected page). Because two columns are used to access one byte, this is equivalent to fixing up to 4 bad bytes per page. Because an address match operation using the byte and page addresses is true (described in detail below) for the redundancy to operate, up to 4 bad bytes per page can be repaired. Thus, the most redundancy that is applied per page is up to 8 columns or 4 bytes, whichever limitation occurs first. If, for example, defects are random single cell type and are located on separate bytes, then 4 bytes per page are the more likely occurring redundancy limitation. In that case, only 4 single cell defects on the same page are fixed unless other defective cells happen to be on one of the other 4 columns in the same 4 bytes. Note that although only 4 defective cells were fixed, 8 redundant columns replace 8 columns per page in the combined arrays  and . Because row addresses are not used in the address matching operation, if a certain byte in a selected page on a selected row is bad, the system  considers that same byte and page address as bad for all other rows as well. The amount of random single cell type defects repairable for the entire chip is thus limited to 4\u00d78=32 defects in this example. If some randomly defective cells are located on the same column or on columns addressed by the same byte, the total number repairable increases. More than 8 columns may be fixed at a time by increasing the number of redundant y-drivers at expense of more circuits for additional redundant y-drivers, additional redundant array (coupled to additional redundant y-drivers) and additional fuses associated with additional redundant columns). The trade-off is additional area versus increased yield due to additional redundancy. The redundancy is described in more detail below in conjunction with , , and .","The spare y-driver circuit (SYDRV)  includes a plurality of single spare y-drivers (SYDRV)  used for the spare array (MFLASHSPARE) . The function of the spare y-driver circuit (SYDRV)  is similar to the function of the y-driver circuit (YDRV) . In one embodiment, for a 512-byte page with 4-bit multilevel cells with 16 spare bytes, there are a total of 32 spare y-drivers .","The digital multilevel bit memory array system  further includes a plurality of page select (PSEL) circuits , a redundant page select circuit , a spare page select circuit , a reference page select circuit , a plurality of block decoders (BLKDEC) , a multilevel memory precision spare decoder (MLMSDEC) , a byte select circuit (BYTESEL) , a plurality of redundant byte select circuits , a spare byte select circuit , and a reference byte select circuit , and as shown in , also includes a page address decoder (PGDEC) , a byte address predecoder (BYTEPREDEC) , an address pre-decoding circuit (XPDECPRS) , and an address pre-decoding circuit (XPDEC) . The digital multilevel bit memory array system  further includes a redundant driver circuit  () that comprises the redundant y-driver circuits  and redundant compare-OR selection circuits . The redundant y-driver circuit  comprises the redundant y-driver circuit , the redundant page select circuit  and the redundant byte select circuit . The redundant driver circuit  is described below in conjunction with .","The page select circuit (PSEL)  selects one bit line  (see ) out of multiple bitlines  (see ) for each single y-driver (YDRV) . In one embodiment, the number of multiple bitlines  connected to a single y-driver (YDRV)  is equal to the number of pages. The corresponding select circuits for the reference array , the redundant memory array , and the spare memory array  are the reference page select circuit , the redundant page select circuit , and the spare page select circuit , respectively.","The byte select circuit (BYTESEL)  enables one byte data in or one byte data out of a pair of the y-driver circuits (YDRV)  at a time, which is described below in conjunction with . The corresponding byte select circuits for the reference array , the redundant memory array , and the spare memory array  are the reference byte select circuit , the redundant byte select circuit , and the spare byte select circuit , respectively.","The block decoder (BLKDEC)  selects a row or a block of rows in the arrays  and  based on the signals from the row page address counter  (described below) and provides precise multilevel bias values over temperature, process, and power supply used for consistent multilevel memory operation for the regular memory array  and the redundant memory array . The multilevel memory precision spare decoder (MLMSDEC)  selects a spare row or block of spare rows in the spare array  and provides precise multilevel bias values over temperature, process corners, and power supply used for consistent multilevel memory operation for the spare array . The intersection of a row and column selects a cell in the memory array. The intersection of a row and two columns selects a byte in the memory array.","The digital multilevel bit memory array system  further comprises a compare-OR logic (COMPORLOG) circuit  that outputs a compare-OR (COMPOR)  signal and an inverted compare-OR (COMPBOR)  signal. The y-driver circuit  generates a compare-OR (COMPOR) signal - (also see ) or an inverted compare-OR (COMPBOR) signal - (also see ) to set a margin of the upper and lower ends of a memory cell operating voltage range. A margin defines the desired difference in voltage or current between a memory cell output and a reference value. During a read, a write or an erase operation, all the y-drivers operate simultaneously and independently of one another in page mode operation. The compare-OR (COMPOR)  and the inverted compare-OR (COMPBOR)  signals indicate to the system whether all the y-drivers have successfully accomplished the read, write or erase operation. The redundant y-driver circuit , the spare y-driver circuit , and the reference y-driver  generate a compare-OR (COMPOR) signal -, -, and -, respectively, or an inverted compare-OR (COMPBOR) signal -, -, and -, respectively, in a manner similar to the y-driver circuit . (It should be noted that the circuit of  corresponds to the y-driver circuit , but functions similar to the y-driver circuits , , and . The signals  and  are shown without dash number in .) The compare-OR logic circuit  generates the compare-OR signal  in response to the compare-OR (COMPOR) signals -, -, -, and -. The compare-OR logic circuit  generates the inverted compare-OR (COMPBOR) signal  in response to the inverted compare-OR (COMPBOR) signals -, -, -, and -.","An input\/output bus  is coupled to the y-driver circuits , ,  and  to provide data in and data out of the corresponding arrays , ,  and . The input\/output bus  is coupled to the input data (IN)  and the output data (DOUT) , which are described below in conjunction with .","The address pre-decoding circuit (XPDECPRS)  decodes addresses. In one embodiment, the addresses are A<:> to select a block of memory array with one block comprising 16 rows. The outputs of the address pre-decoding circuit (XPDECPRS)  are coupled to the block decoder (BLKDEC)  and the spare decoder (MLMSDEC) . The address pre-decoding circuit (XPDEC)  decodes addresses. In one embodiment, the addresses are addresses A<:> to select one row out of sixteen within a selected block. The outputs of address pre-decoding circuit  also couple to the block decoder (BLKDEC)  and the spare decoder (MLMSDEC) .","The page address decoder (PGDEC)  decodes page addresses, such as A<:>, to select a page, e.g., P<:>, and provides its outputs to the page select circuits , , , and . The byte address predecoder (BYTEPREDEC)  decodes byte addresses, such as A<:>, and provides its outputs to the byte select circuit (BYTESEL)  to select a byte. The byte predecoder  also decodes spare byte address, such as A<:> and AEXT, and provides its outputs to the spare byte select circuit  to select a spare byte. A spare byte address control signal AEXT is used together with A<:> to decode addresses for the spare array  instead of the regular array . A redundancy controller  provides control signals to the redundant byte select  to select a redundant byte as described below in conjunction with .","The digital multilevel bit memory array system  further includes a row page address counter (ROWPACNTR) , a byte address counter (BYTEACNTR) , and a spare byte address counter (SPAREBYTEACNTR) . The row page address counter (ROWPACNTR)  provides addresses, such as A<:>, to the page decoder (PGDEC) . The byte address counter (BYTECNTR)  provides byte addresses (e.g., A<:>) to the byte pre-decoder . The byte spare address counter (SPAREBYTECNTR)  also provides spare byte addresses, such as AEXT, to the byte pre-decoder . The row page address counter  also provides addresses, such as A<:>, to the address pre-decoding circuit  and the address pre-decoding circuit  for row address selection. The inputs of the address counters , , and  are coupled to the output of the input interface logic circuit (INPUTLOGIC) .","The digital multilevel bit memory array system  further includes an input interface logic circuit (INPUTLOGIC) , an algorithm controller (ALGOCNTRL) , a voltage and current bias generator (V&IREF) , a precision oscillator (OSC) , a voltage algorithm controller (VALGGEN) , a test logic circuit (TESTLOGIC) , a fuse circuit (FUSECKT) , a reference control circuit (REFCNTRL) , a redundancy controller (REDCNTRL) , voltage supply and regulator (VSUPREG) , and an input buffer .","The input interface logic circuit (INPUTLOGIC)  provides an external interface to external systems, such as an external system microcontroller. Typical external interface for memory operations are read, write, erase, status read, identification (ID) read, ready busy status, reset, and other general purpose tasks. A serial interface can be used for the input interface to reduce pin counts for a high-density chip due to a large number of addresses. Control signals (not shown) couple the input interface logic circuit (INPUTLOGIC)  to the external system microcontroller. The input interface logic circuit (INPUTLOGIC)  includes a status register that indicates the status of the memory chip operation such as pass or fail in program or erase, ready or busy, write protected or unprotected, cell margin good or bad, restore or no restore, and the like.","The algorithm controller (ALGOCNTRL)  is used to handshake the input commands from the input logic circuit (INPUTLOGIC)  and to execute the multilevel erase, programming and sensing algorithms used for multilevel nonvolatile operation. The algorithm controller (ALGOCNTRL)  is also used to algorithmically control the precise bias and timing conditions used for multilevel precision programming. The (COMPOR)  and (COMPBOR)  signals generated from the (COMPORLOG) circuit  are coupled as inputs to the algorithm controller (ALGOCNTRL) .","The test logic circuit (TESTLOGIC)  tests various electrical features of the digital circuits, analog circuits, memory circuits, high voltage circuits, and memory array. The inputs of the test logic circuit (TESTLOGIC)  are coupled from the outputs of the input interface logic circuit (INPUTLOGIC) . The test logic circuit (TESTLOGIC)  also provides timing speed-up in production testing such as in faster write\/read and mass modes. The test logic circuit (TESTLOGIC)  also provides screening tests associated with memory technology such as various disturb and reliability tests. The test logic circuit (TESTLOGIC)  also allows an off-chip memory tester to directly take over the control of various on-chip logic and circuit bias circuits to provide various external voltages and currents and external timing. This feature permits, for example, screening with external voltage and external timing or permits accelerated production testing with fast external timing.","The fuse circuit (FUSECKT)  is a set of nonvolatile memory cells configured at the external system hierarchy, at the tester, at the user, or on chip on-the-fly to achieve various settings. These settings can include precision bias values, precision on-chip oscillator frequency, programmable logic features such as write-lockout feature for portions of an array, redundancy fuses, multilevel erase, program and read algorithm parameters, or chip performance parameters such as write or read speed and accuracy.","The reference control circuit (REFCNTRL)  is used to provide precision reference levels for precision voltage values used for multilevel programming and sensing. The redundancy controller (REDCNTRL)  provides redundancy control logic and is described below in conjunction with .","The voltage algorithm controller (VALGGEN)  provides various specifically shaped voltage signals of amplitude and duration used for multilevel nonvolatile operation and to provide precise voltage values with tight tolerance, used for precision multilevel programming, erasing, and sensing. A bandgap voltage generator (BGAP)  provides a precise voltage value over process, temperature, and supply for multilevel programming and sensing.","The voltage and current bias generator (V&IREF)  is a programmable bias generator. The bias values are programmable by the settings of control signals from the fuse circuit (FUSECKT)  and also by various metal options. The oscillator (OSC)  is used to provide accurate timing for multilevel programming and sensing.","The input buffer  provides buffers for input\/output with the memory array system . The input buffer  buffers an input\/output line  coupled to an external circuit or system and the input\/output bus , which couples to the arrays , , , and  through the y-drivers , , , and , respectively. As noted above, the input\/output bus  is coupled to the output data  and the input data  of the y-driver (see , , and ). In one embodiment, the input buffer  includes TTL input buffers or CMOS input buffers. In one embodiment, the input buffer  includes an output buffer with slew rate control or an output buffer with value feedback control.","The voltage supply and regulator (VSUPREG)  provides regulated voltage values above or below the external power supply used for erase, program, read, and production tests. In one embodiment, the voltage supply and regulator (VSUPREG)  includes a charge pump.","An overview of the system operation with redundancy is described. The system  is capable of parallel operation, e.g., the system  operates on multiple bytes, hence cells, at the same times for data in loading, erase, program, and read. In some parallel operations, a page of bytes are operated on simultaneously using addresses A<:> to select one page out of eight pages in a selected row in a page mode operation. The system is also capable of byte operation using single byte data in loading, program, and read. In this case, byte addressing is used, e.g., addresses A<:>, to select a byte out of  bytes in a selected page. The system  is also capable of row or block (sector) operation such as in multiple page erase. In this case row or block addressing is used, e.g., addresses A<:> to select a row or A<:> to select a block of 16 rows. The system  communicates with an external controller typically with a byte by byte (serial) protocol. Further details of the system operation using redundancy are described below.","An erase operation may be done to erase all selected multilevel cells by removing the charge on selected memory cells according to the operating requirements of the non-volatile memory technology used. The erase operation begins with an erase command coupled to the input logic . After the erase command is validated by the input logic , addresses, such as A<:> for row erase or A<:> for block erase, appearing on the input\/output bus  are then latched in the address counter . An internal erase-then-verify operation is then executed by the algorithm controller  to remove the charge on the memory cells in the selected row. The verification operation with a compare-OR and\/or inverted compare-OR is done to monitor if all or any cells fail the erase operation or operate with an insufficient margin. The compare-OR and inverted compare-OR function are monitored separately for the regular arrays , the reference array , the spare array , and the redundant arrays . Appropriate flags are set by the algorithm controller  to indicate the result of the erase operation. The handling of redundancy in erasing and verification (including the compare-OR and\/or inverted compare-OR function, which will be sometimes referred to simply as the compare-OR function) is described in more detail below. The erase operation is described in more detail below in conjunction with .","A data load operation may be used to load in the multiple bytes of data to be programmed into the memory cells, e.g., 512 bytes in a page. Loading of data in begins with a data load command through the input logic . After the command is validated by the input logic , addresses, e.g., A<:> (for byte) and A<:> (for page) and A<:> (for row), and data appear on the input\/output bus . Addresses are then latched by the address counters ,  and  and decoded by the byte pre-decoder , page decoder , and address pre-decoders  and . The input logic  then outputs various control signals to select the data latches located inside the y-drivers ,  to latch in the data. The selection of appropriate data latches is done by decoding the addresses, e.g., A<:>, by the byte pre-decoder  and the byte select circuits  and . As described below in conjunction with the redundancy controller  in  and with the flow operation in , the data in may be multiplexed into the redundant y-drivers  by the redundancy controller  if an address match operation is true by enabling the redundant byte select circuit . The redundancy controller  executes an address match operation to compare a currently used address coupled on the input\/output bus  to a \u201cbad\u201d stored fuse address that is stored in a redundant address fuse set in the fuse circuit (FUSECKT) . A redundant address fuse set represents a set of multiple fuses used to store a byte\/page address corresponding to a bad column or pair of bad columns within the same byte. For example, as shown in , fuse addresses (FS<: >)  comprise FS<:> corresponding to addresses (A<:>) , FS<> corresponding to address extension enable (AEXTEN) , which enables redundancy repair of the spare array as described below in more detail in conjunction with , FS<> corresponding to fuse state (FSEN) , which is a fuse state enable to enable the fuse set. Henceforth, a bad byte\/page address is referred to interchangeably as a column address or simply as a redundant column when in fact actually two columns associated with the bad byte\/page address are being discussed. The data load operation is described in more detail below in conjunction with .","A read operation may be done to read out in parallel the data (digital bits), e.g., 512 bytes within a page, stored in the multilevel cells. The read operation begins with a read command coupled to the input logic . After the read command is validated by the input logic , addresses, such as A<:> (for byte) and A<:> (for page) and A<:> (for row), appearing on the input\/output bus  are then latched by the address counters such as circuits ,  and\/or . An internal binary search sensing operation, operating on the selected page, is then executed by the algorithm controller  to decode the digital data bits stored in the multilevel cells in the selected page and latch them in data latches in the y-drivers , , and . A restore operation with compare-OR and\/or inverted compare-OR function is executed by the algorithm controller  to ensure the selected cells are still within a certain operating range. The compare-OR function refers to the OR-ing function results of comparing the memory cell output to the desired states of multiple cells in parallel. The compare-OR and inverted compare-OR function are monitored separately for the regular arrays , the reference array , the spare array , and the redundant arrays . Appropriate flags are set by the algorithm controller  to indicate the result of the restore operation. The handling of redundancy in a restore function (especially the compare-OR and\/or inverted compare-OR function) is described below. A data out operation may then be initiated to shift out serially the latched data. The redundancy controller  executes an address match operation to compare a currently used column address coupled on the input\/output buffer  to a \u201cbad\u201d stored fuse address. A byte of data from a redundant column is multiplexed out instead of from a regular column if an address match comparison is true. The redundancy controller  controls the multiplexing of the data. The read operation is described in more detail in conjunction with .","A program operation may be done to store in parallel the data in (digital bits) into the multilevel cells by placing an appropriate charge on selected multilevel cells depending on the operating requirements of the non-volatile memory technology used. The program operation begins with a program command coupled to the input logic . The program command is typically done after the data in loading that loaded data in a page, e.g., 512 bytes in a page. After the program command is validated by the input logic , an internal incremental verify then program operation is executed by the algorithm controller  to accurately place desired charges on the selected memory cells in the selected page. The verification operation with the compare-OR and\/or inverted compare-OR is done to monitor if all or any cell fail the program operation or operate with an insufficient margin. The compare-OR and inverted compare-OR function are monitored separately for the regular arrays , the reference array , the spare array , and the redundant arrays . Appropriate flags are set by the algorithm controller  to indicate the result of the program operation. The handling of redundancy in programming and verification (including the compare-OR and\/or inverted compare-OR function) is described below. The program operation is described in more detail below in conjunction with .",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 2","FIG. 8","FIG. 6"],"b":["148","112","101","104","104","101","12","624"]},"The redundant driver circuit  comprises a plurality of redundant y-driver circuits  and a plurality of redundant compare-OR selection circuits , which couple the compare-OR function of redundant y-drivers to the system compare-OR logic (the compare-OR logic circuit  ()). The redundant y-driver circuit  comprises the redundant y-driver , the redundant page select circuit , and the redundant byte select circuit  (shown in ). The compare-OR selection circuits  are enabled by redundant page y-driver enable signals - through - from the redundancy controller . As shown, there are four redundant y-driver circuits , which are selected by redundant y-driver enable signals - through - from the redundancy controller .","The redundant y-driver enable signals - through - are used to select the redundant y-driver  and the redundant page y-driver enable signals - through - are used to select the redundant compare-OR for the following reason. Recall, the column addressing architecture described in this embodiment allows access by page or byte. Because the smallest addressing granularity for column access is by byte, column replacement for redundancy is also done by byte. Single column access, although providing better memory utilization, comes at the price of additional decoding and control logic, which complicates the design. Thus, each redundant y-driver  operates on two columns with the same byte address (two columns to access one selected byte for a 4-bit multilevel cell at a time) because each circuit  includes a pair of y-drivers  (further description below in conjunction with ). Column address comparison is used to detect whether the selected column is bad. The column address comparison results in the redundant y-driver enable signals - through - being forced active or inactive depending on address matching as described below in conjunction with . However, unlike the byte and page address comparison used to generate redundant y-driver enable signals - through -, only the page addresses are used in the address comparison to generate the redundant page y-driver enable signals - through -. This is because the compare-OR functions of all the y-drivers  are monitored at the same time (in page mode). The compare-OR functions to monitor the result of memory cell verification versus a desired reference value such as in erase, program, or read (as described in more detail below in conjunction with ). Page address comparison causes the redundant page y-driver enable signals - through - to be forced active or inactive depending on page address matching as described below in conjunction with . Page address and not byte comparison is used because all y-drivers operate by page mode operation, (e.g., page addressing is used for all the y-drivers including the redundant y-drivers simultaneously). For clarity, other signal lines of  are not numbered but are described below in conjunction with .","Although there are a total of eight y-driver arrangements comprising , , and  as shown in , other numbers of y-drivers may be used, such as one, three or seven. For example, an odd number of y-drivers is used for nibble instead of byte operation, because one byte (8 digital bits) corresponds to two 4-bit multilevel cells and one nibble (4 digital bits) corresponds to one 4-bit multilevel cell.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 3","FIGS. 1 and 2"],"b":["300","300","202","208","300"]},"The y-driver circuit  comprises a pair of y-driver circuits  (same as redundant y-driver circuit ), a pair of page select circuits  (same as redundant page select circuit ), and a byte select circuit  (same as redundant byte select circuit ). Only one instead of two byte select circuits  is shown because in this embodiment, it is shared between the two y-drivers . The byte select circuit  enables one byte of data in or one byte of data out of a pair of y-driver circuits  at a time. In this embodiment, the byte select circuit  is embedded in the y-driver circuit . In another embodiment, the byte select circuit  is separate from the y-driver circuit .","The y-driver circuit  is described for columns of memory cells in the array, but the memory arrays may be arranged in other configurations. In one embodiment, the memory array  may be arranged in segments with columns of memory cells, and the defective portions of the column segments are replaced by portions of the redundant memory array . In another embodiment, the memory array  may be arranged in row or column segments, and the defective segments are replaced by portions of the redundant memory array .","The byte select circuit  comprises selection logic including a NAND gate, NOR gates and inverters for generating an inverted read clock (RDCLKB) , a load data clock (LDDATACLK) , and a byte select (BYTESEL) signal  in response to a load data (LDDATAB) signal , a read (READB) signal , a byte select (BYTESELCLKH) clock , a first pre-decoded byte decoding signal (UI) , and a second pre-decoded byte decoding signal (TI) . The signals , , and  are provided from the algorithm controller . The byte decoding signals  and  are provided from the byte pre-decoder .","The page select circuits  provide data from the regular memory array  via a plurality of bit lines  to a bit line  for application to the corresponding y-driver circuit . The selection of the bit line  is controlled by the select signals  from the corresponding page decoder . An inhibit voltage line (VINH)  supplied from the voltage supply and regulator (VSUPREG)  provides an inhibit voltage to the unselected bit lines . The bit lines  are provided from the regular memory array  through the page select circuit . As noted above, the y-driver circuit  of  is similar to the spare y-driver , the redundant y-driver  and the reference y-driver circuit . For the y-driver circuits , , and , the bit lines  pass from the respective redundant memory array , spare memory array , and reference memory array  through the respective redundant page select circuit , the spare page select circuit  and the reference page select circuit .","The input data  and the output data  are responsive to the clock signals (LDDATACLK)  and (RDCLKB)  from the byte select circuit (BYTESEL) , the redundant byte select circuit , the spare byte select circuit , and the reference byte select circuit  to the y-driver circuit , the redundant y-driver (RYDRV) circuit , the spare y-driver (SYDRV) circuit , and the reference y-driver circuit , respectively.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 4","b":"110"},"The y-driver circuit  comprises a plurality of data latches - through -, a reference voltage decoder (ydryvrefdec) , a comparator , a NAND gate , an AND gate , a NOR gate , a latch , a PMOS transistor , a y-driver redundancy data latch (ydrvredlat) , an inverter , and a plurality of NMOS transistors \u2013 and \u2013. The description thereof similarly applies to the redundant y-driver circuit , the spare y-driver circuit , and the reference y-driver circuit .","The input buffer  () couples input\/output data on the input\/output line  to the input\/output bus , which is coupled to the input data  and the output data  in the y-driver circuit . The plurality of data latches - through - latch data from the input data (IN) - through -, respectively, during data loading in response to the load data clock (LDDATACLK) . The data latches - through - also latch data previously stored in a memory cell during a read operation in response to read bit data (RDBIT through RDBIT) - through -. The read bit data control signal (RDBIT through RDBIT) - through - are provided from the algorithm controller  to decode respective least significant digital bit (B) through most significant digital bit (B) stored in the memory cell. The plurality of data latches - through - generate the output data (DOUT) - through -, respectively, in response to the data stored in the memory arrays  and the inverted read clock (RDCLKB) . The data latches  hold the data during the data input step of a page programming cycle or hold the data during a latch during a page read cycle. For the purpose of illustration, four data latches  are shown for an embodiment in which 4 bits are stored per memory cell. Other numbers of bits may be stored per memory cell. A reset latch (RSTYLAT) signal  supplied from the algorithm controller  resets the data latches .","The plurality of data latches - through - generate output data (B) - through -, respectively, which are applied to the reference voltage decoder , and also generate the output data - through -, respectively. During a page program cycle, the data  represent previously loaded in data. During a page read cycle, the data  represent the data read out of the cell.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 5A","b":"402"},"The data latch  comprises a plurality of inverters ,  and , an AND gate , a plurality of OR gates ,  and , and a plurality of transfer gates ,  and . The NOR gates  and , the AND gate , and the transfer gate  are coupled in a latch arrangement. The reset latch (RSTYLAT) signal  is applied to the NOR gate  to reset the latch. The input data (IN)  is applied via the transfer gate  to the other input of the NOR gate . The load data clock (LDDATACLK)  is applied to the transfer gates  and  and inverted by the inverter  for application to the transfer gates  and  for clocking the input data . A comparator latched output (COMLATQ) signal  described below is applied to a first input of the AND gate  for enabling or disabling the latch. The read bit (RDBIT) signal  is applied to the other input of the AND gate  for enabling the latch and applied to the NOR gate  for reading the contents of the latch, which is coupled from the output of NOR gate  to the other input of NOR gate . The output of the NOR gate  provides the output data (B)  and through the inverter  provides the inverted output data signal, which is transferred via the transfer gate  as the output data (DOUT) . The transfer gate  is enabled by the inverted read clock (RDCLKB)  and the inversion thereof by the inverter .","Refer again to . In response to the data of the output data (B) , the reference voltage decoder  couples a voltage based on one of the voltages applied to the corresponding voltage reference line (VR(-))  as an reference voltage output  applied to a reference voltage input of the comparator .",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 5B","b":"404"},"The reference voltage decoder  comprises a plurality of transfer gate circuits - through - and a plurality of selection logic circuits - through -. The transfer gate circuits - through - are coupled in series. The selection logic circuits - through - provide enable signals to the respective transfer gate circuits - through - in response to the output data - through - (e.g., BBBB) from the data latches - through -, respectively. The transfer gates - through - provide the selected voltage reference on the voltage reference lines  as the reference voltage output .","Refer again to . A bit line  from the page select circuit  (see ) is coupled to a cell voltage VCELL input of the comparator . The comparator  provides a comparator output signal (COMPOUT)  to indicate whether the cell voltage VCELL on the bit line  is above or below the reference voltage  for application to a D input of the latch . The comparator  has a differential structure with an autozero function to zero out an offset.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 5C","b":"405"},"The comparator  generates the comparator output signal (COMPOUT)  in response to the comparison of the cell voltage VCELL on the bit line  and the reference voltage . Auto zero control signals (AUTOZ)  and (AUTOZB)  automatically zero the comparator offset. Evaluation control signals (EVAL)  and (EVALB)  enable the comparator  to evaluate the inputs of the bit line  and the reference voltage . Release control signals (RELES)  and (RELESB)  release the comparator . A strobe signal (STRB)  latches the output of the comparator . The control signals  through  and  are generated by the algorithm controller (ALGOCNTRL) . A comparator bias (VBYCOMP) signal  generated by the voltage algorithm controller (VALGGEN)  biases the comparator .","Refer again to . The latch  generates a comparator latch (COMPLATQ) signal  and an inverted comparator latch (COMLATQB) signal  that indicates a result of comparing the voltage on the bit line  and the reference voltage of the reference voltage output . Under the control of the algorithm controller (ALGOCNTRL) , an enable comparator latch (ENLATCOMP) signal  functions as a strobe signal to enable the latch  during a certain time to latch the output of the comparator .",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 5D","b":"410"},"The latch  comprises inverters  and , a NAND gate , and transfer gates  and . The comparator output (COMPOUT) signal  is applied via the transfer gate  to a first input of the NAND gate . The reset comparator latch (RBYLATCOMP) signal  is applied to a second input of the AND gate . The output of the NAND gate  is coupled to the inverter , and also generates the inverted comparator latch output (COMLATQB) signal . The output of the inverter  is coupled via the transfer gate  to the first input of the NAND gate , and also provides the comparator latched output (COMLATQ) signal . The transfer gates  and  are controlled by the enable comparator latch (ENLATCOMP) signal , which functions as a clock, and is inverted by the inverter .","Refer again to . When the enable comparator latch (ENLATCOMP) signal  is at logic high, the latch  outputs the logic level of the comparator output (COMPOUT) signal  applied on the D input as the comparator latch output (COMLATQ) signal . When the enable comparator latch (ENLATCOMP) signal  goes to logic low, the latch  latches the logic level of the comparator output (COMPOUT) signal  on the comparator latch output (COMLATQ) signal .","The reset comparator latch (RBYLATCOMP) signal  applied to a reset RB input of the latch  resets the latch  at suitable times under the control of the algorithm controller (ALGOCNTRL) . When the reset comparator latch (RBYLATCOMP) signal  is logic low, the latch  is reset, whereby the comparator latch output (COMLATQ)  is at logic low and the inverted comparator latch output (COMLATQB)  is at logic high.","The comparator latch output (COMLATQ) signal  from the Q output of the latch  is applied to the gate of the NMOS transistor , an input of the AND gate , and the data latches . The inverted comparator latch output (COMLATQB)  from the QB output of the latch  is applied to the gate of the NMOS transistor .","A read (READB) signal  supplied from the algorithm controller  is applied to another input of the AND gate . The read (READB) signal  is at a logic high during a page programming cycle, and is at a logic low during a page read cycle. The output of the AND gate  is applied to a first input of the NOR gate .","A no-compare-OR (NOCOMPORB) signal  from the y-driver redundancy latch  is coupled to the inverter . The inverter  inverts the no-compare-OR (NOCOMPORB) signal  and applies the inverted signal to the second input of the NOR gate . The output of the NOR gate  is applied to the gates of the PMOS transistor  and the NMOS transistor .","The PMOS transistor  sets the memory cell coupled thereto on the bit line (BLIN)  into a program or program inhibit mode. The drain-source terminals of the PMOS transistor  are coupled between an inhibit voltage (VINH) signal  and the bit line (BLIN) . When enabled, the PMOS transistor  pulls the bit line  to the inhibit voltage (VINH) .","The NMOS transistors ,  and  form a current bias circuit to apply a constant current load on the bit line (BLIN) . The NMOS transistors ,  and  are coupled in a cascode arrangement between the bit line  and ground, and include gates coupled to a first y-driver bias voltage (VBIYDRVCAS)  and a second y-driver bias voltage (VBIYDRV) , respectively, and supplied from the voltage algorithm controller (VALGGEN) .","The compare-OR (COMPOR) signal  is controlled by the NMOS transistors  and . The drain-source terminals of the NMOS transistors  and  are coupled in series between the compare-OR (COMPOR) signal  and ground. The gate of the NMOS transistor  is coupled to the comparator latched output (COMLATQ)  of the latch . The no-compare-OR (NOCOMPORB) signal  is applied to the gate of the NMOS transistor .","The inverted compare-OR (COMPBOR) signal  is controlled by the NMOS transistors  and . The drain-source terminals of the NMOS transistors  and  are coupled in series between the inverted compare-OR (COMPBOR) signal  and ground. The gate of the NMOS transistor  is coupled to the inverted comparator latched output (COMLATQB)  of the latch . The no-compare-OR (NOCOMPORB) signal  is applied to the gate of the NMOS transistor .","The no-compare-OR (NOCOMPORB) signal  enables or disables the compare-OR (COMPOR) signal  and the inverted compare-OR (COMPBOR) signal . When the compare-OR (COMPOR) signal  and the inverted compare-OR (COMPBOR) signal  are enabled during the compare-OR function, the latch  sets the states of these signals responsive to the comparator output signal (COMPOUT)  from the comparator . During the compare-OR function, the compare-OR (COMPOR) signal  and the inverted compare-OR (COMPBOR) signal  are first both pulled up to logic high (one) by the compare-OR logic (COMPORLOG) circuit . Then, if the comparator output signal (COMPOUT)  is logic high, the comparator latched output (COMLATQ)  of the latch  is high and the transistor  pulls the compare-OR (COMPOR) signal  to ground (zero). Also, if the comparator output signal (COMPOUT)  is logic high, the inverted comparator latched output (COMLATQB)  of the latch  is low, and the transistor  is off allowing the inverted compare-OR (COMPBOR) signal  to remain high (one). The comparator output signal (COMPOUT)  is a logic high when the cell voltage VCELL is less than the reference voltage output . However, if the comparator output signal (COMPOUT)  is logic low, the comparator latched output (COMLATQ)  of the latch  is low, and the transistor  is off allowing the compare-OR (COMPOR) signal  to remain high (one). Also, if the comparator output signal (COMPOUT)  is logic low, the inverted comparator latched output (COMLATQB)  of the latch  is high and the transistor  pulls the inverted compare-OR (COMPBOR) signal  to ground (zero). The comparator output signal (COMPOUT)  is a logic low when the cell voltage VCELL is higher than the reference voltage output . If any of the compare-OR (COMPOR) signals  are low from any of the enabled y-drivers , , or , the compare-OR logic (COMPORLOG) circuit  forces the compare-OR (COMPOR) signal  to a logic low (zero). If all of the compare-OR (COMPOR) signals  are high from all of the enabled y-drivers , , or , the compare-OR logic (COMPORLOG) circuit  forces the compare-OR (COMPOR) signal  to a logic high (one). If any of the inverted compare-OR (COMPBOR) signals  are low from any of the enabled y-drivers , , or , the compare-OR logic (COMPORLOG) circuit  forces inverted compare-OR (COMPBOR) signal  to a logic low (zero). If all of the inverted compare-OR (COMPBOR) signals  are high from all of the enabled y-drivers , , or , the compare-OR logic (COMPORLOG) circuit  forces the inverted compare-OR (COMPBOR) signal  to a logic high (one).","The NAND gate  generates an enable data signal (ENDATAFB)  in response to data select (B through B) signals  and the enable data (ENDATAF) signal  supplied from the algorithm controller . The enable data signal (ENDATAFB)  is an input data pattern indicator that is used for example to achieve a desired operation, such as program inhibit and is coupled to the redundancy latch .",{"@attributes":{"id":"p-0110","num":"0109"},"figref":["FIG. 5E","FIG. 1"],"b":["416","416","416","416","502","504","506","508","335","160","506","508","502","504","502","334","186","342","140","506","508","449","504","451"]},"Refer again to . The NMOS transistors , ,  and  provide monitoring of the bit line (BLIN) . The drain-source terminals of the NMOS transistors  and  are connected in series between the bit line  and a bit line monitor (BLMON) signal . The bitline monitor (BLMON) signal  is coupled to the test logic circuit (TESTLOGIC)  to provide direct information from the bitline  during any operation. This is used, for example, to monitor the effects of disturb conditions on a memory cell on the bitline . A first bit line monitor enable (MONITORBL) signal  supplied from the test logic circuit (TESTLOGIC)  is applied to the gate of the NMOS transistor . A byte select (BYTESEL) signal  is applied to the gate of the NMOS transistor . When the NMOS transistors  and  are enabled, the bit line monitor signal  is coupled to the bit line . The drain-source terminals of the NMOS transistors  and  are coupled in series between a power supply line and a drain of the NMOS transistor . The gate of the NMOS transistor  is coupled to the bit line . The gate of the NMOS transistor  is coupled to a second bit line monitor enable (MONITORBL) signal  supplied from the test logic circuit (TESTLOGIC) . When the NMOS transistors  and  are enabled, the bit line monitor signal  is coupled to the power supply when the bit line  is at a sufficient voltage to enable the NMOS transistor . The NMOS transistors  and  provide buffered monitoring of the bit line .",{"@attributes":{"id":"p-0112","num":"0111"},"figref":"FIG. 6","b":"186"},"The redundancy controller  enables the column redundancy of the redundant memory array  and the correspondent redundant y-drivers . The redundancy controller  comprises a plurality of redundancy decoders (reddesfsx) , , , , a redundancy address sequencer (redaddseq) , a NOR gate , NAND gates  and  and inverters , , and .","The redundancy controller  generates a column redundancy fuse enable (FSENCOLRED) signal  as an indicator that the column redundancy is to be used so that the memory array system  can take action to optimize system performance. The column redundancy fuse enable signal , if indicative of an inactive state (low level signal), is applied to the input logic  and the address counters ,  and  to disable permanently during any operation the multiplexing of data into the redundant y-drivers  during data loading, or the multiplexing of data from the redundant y-drivers  during data out reading. The column redundancy fuse enable signal  indicating an inactive state also signals to the input logic  and the compare-OR logic circuit  to not activate permanently during any operation the compare-OR function of the redundant y-drivers . This action eliminates any speed penalty due to any circuit path being activated due to redundancy.","The redundancy controller  also generates the redundant page y-driver enable (ENYDRVRPx) signals - through - to enable corresponding redundant compare-OR function, and redundant y-driver enable (ENYDRVR) signals - through - to enable corresponding redundant y-drivers  (see ). The redundancy controller  also generates a redundancy address (REDADDTRUE) signal , indicating a column is bad, to serve as a true or false flag to indicate to the controllers  and  to issue appropriate control signals coupled to the y-drivers , ,  and  to take appropriate actions during operation (see description below for ).","The redundancy controller  also generates the reset no-compare-OR latch (RSTNOCMPORL) signal  to reset the redundancy latch  (see description with ), an end redundant address sequencing (ENDREDADDSEQB) signal  to signal the end of the action of the redundancy address sequencer , an enable byte decoder redundancy reset (ENBTDECREDRST) signal  to enable appropriately the byte pre-decoder  and byte address counters  or , and an enable redundant oscillator (ENREDOSC) signal  to enable an oscillator (not shown) used to keep track of the internal timing for redundancy operation.","The redundancy decoders , , ,  are used for redundant byte and page enabling. The redundancy decoders , , , and  compare incoming page, e.g., A<:>, and byte addresses, e.g., A<:> , to stored fuse addresses (FS<xxx>)  to generate address matching for page address (redundant page y-driver enable - through -) and byte\/page address (redundant column (y-driver) enable - through -).","The redundancy decoders , , ,  generate the redundant page y-driver enable (ENYDRVPx) signals , the redundant y-driver enable (ENYDRVR) signals , and fuse enable OR (FSENORXB) signals , which are applied to corresponding inputs of the NAND gate . One input of the NAND gate  is coupled to the output of the NAND gate , and another input of the NAND gate  is coupled to the output of the inverter , which inverts a disable column redundancy (DISCOLRED) signal . The inverter  generates the column redundancy fuse enable (FSENCOLRED) signal  from the output of the NAND gate . The redundant y-driver enable (ENYDRVR) signals  are applied to the inputs of the NOR gate . The inverter  generates the redundancy address (REDADDTRUE) signal  from the output of the NOR gate . The redundancy decoders , , ,  receive an address signal  (e.g., A<:>), an address extension enable (AEXTEN) signal , a y-driver fuse enable (FENYDRVR) signal , a y-driver fuse enable all (FENYDRVRPALL) signal , and a fuse (FS<x:y>) state signal - through -. The row page address counter  and the byte address counters  and  provide the address signal  and the address extension enable signal  to the redundancy decoders , , , . The address extension enable (AEXTEN) signal  combines the address extension signal (AEXT)  provided from the spare byte address counter  and an extension enable control command (not shown) from the input logic . Unless the extension array or spare array  is enabled by an extension enable command through the input logic , the extension array is not accessible, e.g., the (AEXTEN) signal  is inactive. The test logic circuit  provides the disable column redundancy signal , the y-driver fuse enable signal  and the y-driver fuse enable all signal  to the redundancy decoders  through  for testing functions. The fuse circuit  comprising a plurality of fuse circuits, described below in conjunction with , provides the fuse state signals - through -.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 7","FIG. 7"],"b":["601","602","603","604","601","602","603","604","601","1","701","0","701","7","1","702","1","703","704","705","706"]},"The fuse redundancy decoders - through - generate a corresponding fuse state enable (FSEN) signal - through -, which are applied to a respective input of the NOR gate . The inverters  and  are coupled in series to buffer the output of the NOR gate  and generate the fuse enable OR signal . The fuse redundancy decoders - through - also generate a corresponding redundant column (RCx) signal - through - and a corresponding redundant page (RPx) signal - through -, which are applied to the redundant column decoder (rcydec)  and the redundant page decoder (rpydec) , respectively. The address signals (A<:>) , the address extension enable (AEXTEN) signal , and fuse state signals  are applied to the fuse redundancy decoders . The fuse state signals  correspond to the fuse state signals  (see ).",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 8","b":"701"},"The fuse redundancy decoder  is used to compare address  and  to a stored fuse state , which corresponds to a fuse state signal . There are eight redundancy decoders , as shown in , used with a pair of redundant y-drivers  as shown in . The fuse redundancy decoder  comprises a plurality of redundancy comparators (redcomp) - through -, a redundancy decoder (reddec) , and a plurality of inverters ,  and .","Each redundancy comparator (redcomp) - through - generates a fuse state output (FSOx) signal - through -, respectively, which is applied to a corresponding input of the redundancy decoder (reddec) , in response to an address (A<x>) signal - (A<>) through - (A<>), respectively, and a fuse state (FS<x>) signal - through -, respectively. The redundancy comparator - generates a fuse state output (FS) -, in response to the address extension enable (AEXTEN) signal  and a fuse state signal -. The inverters  and  generate a fuse extension (FSEXTEN) signal  in response to the fuse state signal -. The inverter  generates the fuse state enable (FSEN) signal  in response to a fuse state FS() -. The signals - through -, , and  are input to the redundancy decoder . The fuse state signals  and  comprise the fuse state signals - through -, which are provided from fuse circuits  described below in conjunction with  (each of signals - through - corresponds to a FS signal  in ).","The redundancy decoder  generates the redundant column (RC) signal  to indicate a byte and page address matching and the redundant page (RP) signal  to indicate a page address matching in response to the fuse state output (FSO) , the fuse extension (FSEXTEN) signal , and the fuse state enable signal (FSEN) . The redundant column (RC) signal  and redundant page (RP) signal  couple to the redundant column decoder (rcydec)  and redundant page decoder (rpydec) , which in turn generate redundant y-driver enable signals  and redundant page y-driver enable signals  to enable the redundant byte select  and the redundant compare-OR selection circuits , respectively, in the redundant y-driver  as shown in , , and .",{"@attributes":{"id":"p-0125","num":"0124"},"figref":"FIG. 9A","b":"801"},"The redundancy comparator (redcomp)  is a one bit digital comparator that outputs a \u201c1\u201d if two inputs are the same (\u201c11\u201d or \u201c00\u201d) and outputs a \u201c0\u201d if two inputs are different (\u201c01\u201d or \u201c10\u201d). The redundancy comparator  is used for address match comparison as described previously, and comprises a plurality of inverters ,  and , and a plurality of transfer gates  and . The inverter  applies an inverted signal of the address signal  to the transfer gate . The inverter  applies an address signal corresponding to the address signal  to the transfer gate . The fuse state signal  and an inverted fuse state signal from the inverter  control the transfer gates  and  to couple the address signal  or the inverted address signal , respectively, to the fuse state outputs .",{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 9B","b":["9100","9100","182"]},"The fuse cell element  comprises a latch , an isolation circuit , a precharge circuit , a margin circuit , an isolation transfer gate , and memory cells - and -. The input signals numbered 9xyz entering , except output signal , are provided by a fuse control circuit inside the fuse circuit . The signal  corresponds to the fuse state signal FS  (),  (), and  (). To better comprehend the invention, the description of  may be read after the description of  and return to this section last.","In one embodiment, the latch  and the memory cells - and - are in a constant current differential sensing arrangement, in which an input pair of a differential comparator is replaced by a fuse pair (e.g., the memory cells - and -). The difference in the floating gate voltage of the fuse pair (the memory cells - and -) generates the input differential voltage. Accordingly, the comparator output is an accurate indication of the fuse pair output. Well-known advantages of a true differential comparator, such as constant bias current, noise insensitivity to power supply fluctuation, and common mode rejection, are thus preserved in this fuse sensing arrangement. Constant bias current is advantageous in terms of power layout distribution (such as metal width) and low power consumption. Furthermore, the fuse pair may include a cross-coupled fuse pair to average out the effects of electrical differences between the fuse pair due to processing and physical location, such as bottom and top fuse locations, on a memory device, which improves yield and reliability.","The sensing scheme has two phases. The first phase is active (with bias current and voltage) sensing by the differential comparator to amplify a floating gate voltage differential in the input fuse pair. The second phase is constant current latching amplification by enabling a current controlled cross coupled built-in latch (e.g., latch ) to then completely open up the output voltage to full rail and isolate the fuse cells from the latch  by shutting off the pass gate (e.g., the isolation circuit ) from fuse cells to the latch . The built-in latch refers to the latching PMOS transistors (e.g., PMOS transistors  and  described below) as part of the differential comparator. The constant current latching amplification refers to the latch amplification at a fixed bias current.","The sensing scheme can alternately allow the fuse cells (memory cells ) to be in an on-condition, namely fuse cells in operating condition (voltages on control gate and bit line), by not isolating the fuse cells from the latch  (e.g., by not shutting off the pass gates of the isolation circuit  from the fuse cells, memory cells , to the latch ).","In one embodiment, the sensing scheme can also use one logic signal edge triggered from a power-on-reset (POR) signal (not shown) to control the sensing. In this embodiment, as the power-on-reset (POR) signal transitions from high to low, as the supply voltage VCC transitions from low to high, the built-in latch  and the differential comparator are on. When the voltage VCC is turning on and as the power-on-reset (POR) signal transitions from high to low at the VCC trip point, the built-in latch  then opens up the output to full rail. The fuse cells (memory cells ) can then operate (voltages on the control gate and bit line). Alternatively, the sensing scheme may use a logic signal triggered from an on-chip or off-chip control logic circuit (not shown) to control the sensing.","In one embodiment, the first and second memory cells -, - are programmable non-volatile fuse elements. In one embodiment, the memory cells -, - are source side hot electron injection flash memory. In one embodiment, the memory cells -, - are split gate memory cells. A fuse control gate voltage (VCGFSL)  is applied to the memory cell - to control the control gate (CG) thereof. A fuse control gate voltage (VCGFSR)  is applied to the memory cell - to control the control gate (CG) thereof.","The latch  detects the contents stored in the memory cells -, - and latches the read contents allowing the memory cells -, - to be electrically disconnected from the latch  by the isolation circuit . The latch  comprises p-channel metal oxide semiconductor field effect transistors (PMOS transistors) ,  and n-channel metal oxide semiconductor field effect transistors (NMOS transistors) , , . The drain-source terminals of the PMOS transistors ,  are coupled between a power supply line  and a first latch input - and a second latch input -, respectively. The drain-source terminals of the NMOS transistors ,  are coupled between the first and second latch inputs - and -, respectively, and a common node . The gates of the PMOS transistor  and the NMOS transistor  are coupled together and to the second latch input -. The gates of the PMOS transistor  and the NMOS transistor  are coupled together and to the first latch input -. The NMOS transistor  includes drain-source terminals coupled between the common node  and ground, and includes a gate coupled to a latch signal . The NMOS transistor  controls the current of the latch  during sensing, and functions as a logic switch during latching.","The isolation circuit  isolates the memory cells -, - during standby and isolates the latch  from a write circuit (not shown) during write. In one embodiment, the isolation circuit  comprises NMOS transistors  and  including drain-source terminals coupled between the respective first and second latch inputs -, - and a bit line (BL) terminal of the respective first and second memory cells -, -, and including a gate coupled to a read delay (READDLY) signal . The read delay signal  is set at a time after the memory cells  are read sufficient for the latch  to latch the read content of the memory cells . The read delay signal  also is set during standby and during writes to the memory cells .","The precharge circuit  precharges the voltage applied to the latch  and the latch inputs  before reading the memory cells . In one embodiment, the precharge circuit  comprises a PMOS transistor  and an NMOS transistor  coupled together as a transfer gate between the gates of the PMOS transistors , . The gates of the NMOS transistor  and the PMOS transistor  are controlled by a precharge signal  and an inverted precharge signal (PRECHARGEB) , respectively. During precharge, the PMOS transistor  and the NMOS transistor  equalize the voltage on the first and second latch inputs - and -.","The margin circuit  provides a current to the latch  sufficient to ensure that a definite margin voltage exists between the pair of memory cells -, -. In one embodiment, the margin circuit  comprises NMOS transistors , , , . The drain-source terminals of the NMOS transistors ,  are coupled together in series, and the series connected NMOS transistors ,  are coupled in parallel between the bit line (BL) terminal and a common line (CL) terminal of the memory cell -. The gates of the NMOS transistors ,  are coupled to receive a first fuse control gate margin control (VCGFSML) signal  and a first fuse floating gate margin control (VFGFSML) signal , respectively. The drain-source terminals of the NMOS transistors ,  are coupled together in series, and the series connected NMOS transistors ,  are coupled in parallel between the bit (BL) terminal and the common line (CL) terminal of the memory cell -. The gates of the NMOS transistors ,  are coupled to receive a second fuse control gate margin control (VCGFSMR) signal  and a second fuse floating gate margin control (VFGFSMR) signal , respectively.","The fuse cell element  also has a mass margining feature to ensure a definite margin voltage exists between the fuse pair (memory cells -, -). Mass margining refers to all fuses (in a predefined portion of the memory, such as all in a bank or page or device) being exercised at the same time, resulting in shortened test time. The NMOS transistors ,  and the NMOS transistors ,  function as dummy transistors which are a pair of series connected transistors that are connected in parallel with the respective memory cells -, -. One dummy transistor simulates a control gate transistor of a memory cell . The other dummy transistor simulates a floating gate transistor of the memory cell . By comparing a reference voltage on the dummy pair of NMOS transistors ,  and the control gate voltage  of the memory cell -, and likewise by comparing a reference voltage on the dummy pair of NMOS transistors ,  and the control gate voltage  of the memory cell -, the state of the pair of memory cells -, - is known. Hence, a definite voltage is observed which is related to the margin of the memory cell fuse pair. This definite voltage is called the voltage of the memory cell to more easily explain the fuse cell element and its operation.","In an alternate embodiment, mass margining applies a current offset from the supply voltage VCC on the power supply line  or from a ground line to the bit line of one of the memory cells - and - during sensing. A MOS transistor (not shown) includes drain-source terminals coupled between the power supply line  or the ground line and the bit line of one of the memory cells - and -, and includes a gate biased at a certain voltage.","The fuse apparatus can also allow multilevel fuse sensing by setting an appropriate reference voltage on one fuse control gate and comparing it against a reference value on the other fuse control gate (or against a reference value on the dummy transistor gate of the other side) of the differential comparator.","In one multilevel fuse sensing embodiment, one of the fuse control gate voltages  or  of one of the memory cells -, - is set to an appropriate reference voltage, and compared against a reference value on the control gate of the other of the memory cells -, -. In another embodiment, the comparison is against a reference value on the gate on one of the NMOS transistors , , ,  corresponding to the control gate of the other of the memory cells -, -.","The fuse may be programmed using a constant current mass fuse programming, in which all the bias currents to all fuses are provided at the same time for programming to save time.","As an illustrative example, setting the fuse control gate voltage (VCGFSL)  and the fuse control gate voltage (VCGFSR)  equal to each other and equal to approximately 1.5 volts, a difference in the floating gate voltages causes the latch  to flip according to the difference. In one embodiment, the floating gate difference is obtained by erasing one of the memory cells -, - and programming the other to store one binary state of the fuse element or reversing the program and erase state of the memory cell pair to store the opposite fuse state. In one embodiment, the fuse margin is tested to ensure the fuse memory cells  have sufficient margin voltage difference to prevent the floating gates from losing the information, and thus preventing the latch  from flipping incorrectly.","In one embodiment, the fuse margin test is performed to verify that an erased memory cell  has a certain difference margin voltage. For the sake of illustration in this margin test, the memory cell - is erased. The fuse control gate voltage (VCGFSR)  is set to 0 volts to turn off the memory cell -. The fuse control gate voltage (VCGFSL)  is set to the operating voltage, e.g., 1.5 volts. The first fuse control gate margin control (VCGFSML) signal  applied to the NMOS transistor  and the first fuse floating gate margin control (VFGFSML) signal  applied to the NMOS transistor  are set to zero. The second fuse control gate margin control (VCGFSMR) signal  applied to the NMOS transistor  is set to the operating voltage, e.g., 1.5 volts. In order to observe the voltage of the memory cell -, the second fuse floating gate margin control (VFGFSMR) signal  is varied until the voltage on the second latch input - switches from high to low. At this event, the voltage of the first memory cell - equals the voltage applied to the NMOS transistor , i.e., the second fuse floating gate margin control (VFGFSMR) signal .","In order to test that the voltage of the memory cell - is greater than the margin voltage for more reliable operation, the second fuse floating gate margin control (VFGFSMR) signal  is set equal to a predetermined first voltage margin, and the voltage of the memory cell - is greater than the desired voltage margin if the voltage on the latch input at - is still high.","In one embodiment, the fuse margin test is performed to verify that a programmed memory cell  has a certain difference margin voltage. For the sake of illustration in this margin test, the memory cell - is programmed. The fuse control gate voltage (VCGFSR)  is set to 0 volts to turn off the memory cell -. The fuse control gate voltage (VCGFSL) , the second fuse control gate margin control (VCGFSMR) signal  applied to the NMOS transistor , and the first fuse control gate margin control (VCGFSML) signal  applied to the NMOS transistor  are set to the operating voltage, e.g., 1.5 volts. In order to observe the voltage of the memory cell -, the second fuse floating gate margin control (VFGFSMR) signal  is set to a value which simulates a predetermined weakly erased but still acceptably reliable memory cell. The first fuse floating gate margin control (VFGFSML) signal  applied to the NMOS transistor  is varied until the voltage on the second latch input - switches from low to high. At this event, the voltage of the first memory cell - equals the voltage applied to the NMOS transistor , i.e., the first fuse floating gate margin control (VFGFSML) signal .","In order to test that the voltage of the memory cell - is greater than the margin voltage desired for more reliable operation, the first fuse floating gate margin control (VFGFSML) signal  is set equal to a predetermined first voltage margin, and the voltage of the memory cell - is greater than the voltage margin if the voltage on the second latch input - is still low.","In another embodiment, the fuse margin test is again performed to verify that a programmed memory cell  has a certain difference margin voltage. For illustration, the memory cell - is again programmed. The fuse control gate voltage (VCGFSR)  is set to 0 volts to turn off the memory cell -. The first fuse control gate margin control (VCGFSML) signal  applied to the NMOS transistor  and the first fuse floating gate margin control (VFGFSML) signal  applied to the NMOS transistor  are set to zero. The fuse control gate voltage (VCGFSL)  and the second fuse control gate margin control (VCGFSMR) signal  applied to the NMOS transistor  are set to the operating voltage, e.g., 1.5 volts. In order to observe the voltage of the memory cell -, the second fuse floating gate margin control (VFGFSMR) signal  is set to a value which simulates a predetermined weakly erased but still acceptably reliable memory cell. If the voltage on the first latch input - is high, then the voltage of the first memory cell - is less than the first margin voltage. The fuse control gate voltage (VCGFSL)  is set to a higher voltage, e.g., 3.5 volts. If the voltage on the first latch input - is high, then the voltage of the first memory cell - is less than the second margin voltage. The voltage margin equals the difference between the two tested voltages multiplied by a control gate coupling ratio. In this example, the margin voltage is 0.4 volts (equals a coupling ratio of 0.2 times the difference between the 3.5 volts and the 1.5 volts). Thus the voltage of the first memory cell - has at least a margin voltage equal to 0.4 volts.","The margin of the entire fuse element  is a function of the margins for both memory cells - and -. Thus, similar procedures are performed to test the margin of the complementary memory cell. The present invention allows both memory cell margins to be tested independently, such as the testing described above. In another embodiment, the fuse margin is tested by the differential swing in the voltages applied to the control gate. The fuse control gate voltage (VCGFSL)  applied to the first memory cell - and the fuse control gate voltage (VCGFSR)  applied to the second memory cell - are swung in opposite directions by a voltage VM and the state of the latch (e.g., the voltage on the first latch input - and the second latch input -) are tested. The margin voltage equals a fixed coupling ratio times the voltage VM.","The fuse cell element  further comprises a read bias current circuit , a programming inhibit circuit , an inverter , and a fuse forcing circuit . The read bias current circuit  provides bias current for reading of the memory cells . In one embodiment, the read bias current circuit  comprises an NMOS transistor . The NMOS transistor  includes drain-source terminals coupled between the common line (CL) input terminals of the memory cells -, - and a fuse common line terminal voltage (VCLFS) signal , and includes a gate coupled to a read bias voltage (VRBIAS) .","The programming inhibit circuit  inhibits the programming of the memory cells -, -. In one embodiment, the programming inhibit circuit  comprises PMOS transistors ,  and NMOS transistors , , , , .","The NMOS transistor  provides bias current for programming the memory cells. Specifically, the NMOS transistor  includes drain-source terminals coupled between the common node formed of the source terminals of the NMOS transistors ,  and ground, and includes a gate coupled to receive a fuse bias voltage (VBFS) .","The drain-source terminals of the PMOS transistor  and the NMOS transistor  are series coupled between the power supply line  and the drain terminal of the NMOS transistor . The gates of the PMOS transistor  and the NMOS transistor  are coupled together and to a fuse bit line signal (BITLNFS) .","The NMOS transistor  isolates the memory cell - from the read circuit during read. The NMOS transistor  includes drain-source terminals coupled between the bit line (BL) terminal of the memory cell - and the common node formed of the PMOS transistor  and the NMOS transistor , and includes the gate coupled to receive a bit line enabled (BLEN) signal .","The drain-source terminals of the PMOS transistor  and the NMOS transistor  are series coupled between the power supply line  and the drain terminal of the NMOS transistor . The gates of the PMOS transistor  and the NMOS transistor  are coupled together and to an inverted fuse bit line signal (BITLNFSB) .","The NMOS transistor  isolates the memory cell - from the read circuit during read. The NMOS transistor  includes drain-source terminals coupled between the bit line (BL) terminal of the memory cell - and the common node formed of the PMOS transistor  and the NMOS transistor , and includes a gate coupled to receive the bit line enabled (BLEN) signal .","The isolation transfer gate  isolates the sensing circuit (the latch ) from the external circuits. In one embodiment, the isolation transfer gate  comprises a PMOS transistor  and NMOS transistor  coupled together as a transfer gate between the second latch input - and the input of the inverter . The gates of the PMOS transistor  and the NMOS transistor  are controlled by complimentary enable output signals (ENOUT, ENOUTB)  and , respectively. The inverter  provides an output (FBIT) signal  indicative of the contents of the memory cells .","The fuse forcing circuit  forces memory cells -, - to selected storage states. In one embodiment, the fuse forcing circuit  comprises a PMOS transistor  and an NMOS transistor . The NMOS transistor  and the PMOS transistor  are coupled together as a transfer gate between the common node of the isolation transfer gate  and the input of the inverter  and selectively to either ground or the fuse bit line signal (BITLNFSB) terminal . The gates of the NMOS transistor  and the PMOS transistor  are coupled to a fuse forcing (FORCEFS) signal  and an inverted fuse forcing (FORCEFSB) signal , respectively, to enable the fuse force circuit .","The fuse cell element  may be used for multi-level voltage storage of multiple bits per cell. The voltages applied to the memory cells -, - are controlled by applying the multiple bits to a digital-to-analog converter (not shown) for applying an analog voltage to the memory cells . Likewise, memory cells  may be read by converting the voltage therefrom into multiple bits by an analog-to-digital converter (not shown). The multi-level fuse cells may be used in circuits having a plurality of fuse cell elements .",{"@attributes":{"id":"p-0160","num":"0159"},"figref":"FIG. 9C","b":["9112","1","9112","2","9100"]},"In this embodiment, the columns of flash transistors are arranged such that two memory cells, top and bottom are used for each fuse cell - and -, respectively. The two cells average out top and bottom process non-uniformity. Other averaging combinations may be used such as 3, 4 or 5. A dummy row  is disposed on the top and on the bottom and a dummy bit line  is disposed on the right and on the left. A dummy source line  immediately on the top and bottom is left floating. This floating avoids leakage on the bit lines. Dummy source lines  on the uppermost top and lowermost bottom are grounded. The dummy word lines  are connected to ground. It should be noted that except where the memory cells are used, there is no bit line contact to other dummy memory cells.",{"@attributes":{"id":"p-0162","num":"0161"},"figref":"FIG. 10","b":["1","802"]},"The redundancy decoder (reddec)  comprises a plurality of NAND gates , , , , ,  and inverters , , , , . The NAND gate  and the inverter  generate an AND signal  of the fuse states output FSO<:> - through - and apply the AND signal  to a first input of the NAND gate . The NAND gate  generates a NAND signal from the applied fuse states output FSO<:> - through - and applies the NAND signal to a first input of the NAND gate . The inverter  inverts the fuse extension (FSEXTEN) signal  and applies the inverted signal to a second input of the NAND gate . The output of the NAND gate  is applied to a second input of the NAND gate . The inverter  and the NAND gate  provide the fuse state output FSO<> - to a third input of the NAND gate . The NAND gate  and the inverter  generate the redundant page (RP) signal , which also is applied to a fourth input of the NAND gate , as an AND of the fuse states output FSO<:> - through - and the fuse state enable (FSEN) signal . The inverter  provides the redundant column (RC) signal  in response to the output of the NAND gate .","Refer again to . The redundant column decoder (rcydec)  generates the y-driver enable (RCYDRVR) signal  in response to the redundant column (RCx) signals , the y-driver fuse enable all (FENYDRVRPALL) signal , and the y-driver fuse enable signal  applied thereto.",{"@attributes":{"id":"p-0165","num":"0164"},"figref":"FIG. 11","b":["1","702"]},"The redundant column decoder (rcydec)  comprises NOR gates  and , NAND gates , , and inverters , , and . The NOR gate  generates a NOR of the redundancy column (RC) signals - through -. The NOR gate  generates a NOR of the redundancy column (RC) signals - through -. The outputs of the NOR gates  and  are coupled to corresponding inputs of the NAND gate . The NAND gate  is enabled by the complement of the y-driver fuse enable all (FENYDRVRPALL) signal  from the inverter . The NAND gate  and the inverter  form an AND gate to generate the y-driver enable signal (ENYDRV) signal  from the output of the NAND gate  when enabled by the complement of the y-driver fuse enable signal  from the inverter .","Refer again to . The redundant page decoder (rpydecl)  generates the page y-driver enable (rpydrvr) signal  in response to the redundant page (RPx) signals , the y-driver fuse enable all (FENYDRVPALL) signal  and the y-driver fuse enable signal  applied thereto.",{"@attributes":{"id":"p-0168","num":"0167"},"figref":"FIG. 12","b":"703"},"The redundant page (rpydecl) decoder  comprises NOR gates  and , NAND gates  and , and inverters ,  and , which are arranged in a similar manner as the NOR gates  and , NAND gates  and , and inverters , , and , respectively.","It may be useful to summarize some of the embodiments of this invention that have been previously discussed before describing more details of the redundancy controller (REDCNTRL) . As described above, to load, program, and read data, the multilevel memory system  operates on a page of  regular plus 16 extension data bytes at the same time. Each selected row of memory includes 8 pages of data. A circuit block including a y-driver and a page select circuit independently operate on a single selected column coupled to a memory cell capable of storing 4 bits of multilevel data. Each page select can multiplex 1 of 8 columns (or pages) in the array to its associated y-driver. A byte select circuit coupled to a pair of y-drivers can enable a byte of data to be loaded in or read out of the y-drivers. Selecting a particular byte on a selected page on a selected row addresses a particular byte of data in the memory. Thus, on a selected page, addressing a particular byte is the same as addressing a particular pair of y-drivers. Due to page mode operation, column redundancy in this system replaces a bad y-driver  and its associated column with a good redundant y-driver  and its associated column. The redundancy controller (REDCNTRL)  controls the replacement by matching the selected byte and page address (column address) to the bad column addresses previously stored in the fuse circuit (FUSECKT) . Thus, the redundancy controller (REDCNTRL)  disables a byte select circuit  or  and enables a redundant byte select circuit  coupled to a pair of redundant y-drivers . A byte of data is thus rerouted from the bad column pair to a good redundant column pair. With 8 redundant y-drivers , up to 4 bytes can be redirected for each one of the 8 pages.","Refer again to . During load in or read out of byte data to or from the latches  in the y-drivers , the redundancy controller  identifies whether the selected column address is bad. The redundancy controller  employs the redundancy address decoders  through  to detect the bad address by comparing the addresses A<:>  and AEXTEN  with the fuse (addresses) state signals FS  that correspond to previously stored bad addresses in the fuse circuit (FUSECKT) . If a bad address is found (address comparison is true), the redundant y-driver enable signal  then disables the appropriate address decoding circuitry, such as the byte-predecoder , the byte address counters  and , coupled to the selected y-drivers  through the inverted read clock (RDCLKB) , the load data clock (LDDATACLK) , and the byte select (BYTESEL) signals . This prevents reading out the data from or loading in the data into the selected y-drivers . The redundancy controller  instead directly enables the data from or into the redundant y-drivers , as shown in . The signal  from the redundancy controller  is coupled to signal  of the redundant byte select circuit  (represented by the byte select circuit  of ) to select the associated redundant y-drivers . In another embodiment, the signals - through - enable or disable the appropriate decoding circuitry (not shown) at the input\/output buffers  instead of the y-drivers. In this approach the speed of reading out or loading in the data from the redundant y-drivers  is faster due to eliminating delay paths associated with the serial operations of address decoding, bad address matching, y-driver enabling, and I\/O. In this alternate embodiment, the regular and redundant y-drivers are all enabled while, in parallel, the bad address matching is performed and the good for bad data replacement is done in the input\/output buffers .","For enabling the compare-OR (COMPOR) or inverted compare-OR (COMPBOR) function, the redundancy address sequencer  detects the address as follows. (The compare-OR function is described in more detail above.) One usage of the compare-OR function is to indicate the operating voltage range of the memory cells. For the system  shown in , a page mode operation is done at the system hierarchy in which the memory operation is done on multiple cells, or a page, at the same time to speed up the write-read data rate. For example, in one embodiment, a page has 1024 cells, and 1024 y-drivers are used. The compare-OR function is done for all 1024 y-drivers at the same time. If a bad column exists, the corresponding \u201cbad\u201d y-driver  is disabled from participating in the compare-OR function. In one embodiment, the disabling is done by cycling through the addresses of all 1024 y-drivers (actually cycling thru 512 byte addresses on the selected page corresponding to all 512 y-driver pairs) while comparing those addresses individually with the stored bad addresses. If a match is found, the matched y-driver  is disabled. This embodiment uses 512 timing cycles. In another preferred embodiment, the stored bad address from the fuse is used and then superimposed (multiplexed directly to the address decoder input) on the address decoder for the 1024 y-drivers  to directly disable the compare-OR function in the bad y-driver . This embodiment uses a number of timing cycles equal to the number of fuse addresses. For example, column redundancy is implemented with 32 sets of fuses replacing possibly 32 bad bytes and therefore uses only 32 cycles. The 32 bad bytes are replaced using the 4 redundant y-driver circuits  that are each capable of accessing 8 pages as described above in conjunction with . The second embodiment is faster than cycling through the 512 address cycles. In one embodiment of cycling through all the y-driver addresses, the regular byte address counter  and the byte predecoder are part of the redundancy address sequencer , and are used to provide decoding for all y-drivers.","For all embodiments, the fuse address for column redundancy is enabled for each column fuse by a dedicated enable fuse signal  (). For example, in , , and , there is one  output from each one of the eight decoders  from each one of the 4 decoders -. So there are 8\u00d74=32 separate  signals in the system. Each one of the 32 signals  corresponds to and enables one of the 32 redundancy bytes. When the fuse enable signal  is low, the redundant column signal  and the redundant page signal  () are also low, e.g., disabled.","In another embodiment, the redundancy address sequencer  cycles through only the fuse addresses that have been enabled for column redundancy. This approach has an even shorter time usage associated with the redundancy address sequencer . Here the fuse enable signal  is used to control the redundancy address sequencer  to cycle through only enabled fuse addresses by using additional control logic (not shown). For example, if one fuse address set is used to fix one bad column (pair), then only one cycle is used. The fuse address for column redundancy is enabled for each column fuse by a dedicated enable fuse signal  (). When the fuse enable signal  is low, the output signals, the redundant column signal  and the redundant page signal  () are low, e.g., disabled. If no column redundancy is used, the redundancy controller  is not activated due to all the fuse enable signals  being low. Thus the fuse enable column redundancy (FSENCOLRED) signal , which couples through the logic circuit , disables the redundancy address sequencer , and hence no additional time is wasted. Although this embodiment improves performance, it uses more control logic (which is not shown).","In one embodiment, the redundant address sequencer  shown in  cycles through all the fuse addresses, e.g., 32 times for 32 fuse address sets, to directly access the y-driver latch  to disable the compare-OR function in the bad y-driver as described above and described below in more detail. The redundancy address sequencer  generates the reset no-compare-OR (RSTNOCMPORL) signal , an enable redundant oscillator (ENREDOSC) , address (AI) signals , inverted address (AIB) signals , an address extension (AEXTI) signal , and the enable byte decoder redundancy reset (ENBTDECREDRST) signal . The enable redundant oscillator (ENREDOSC)  enables a redundant oscillator (not shown) to provide timing for the redundant address sequencer . The signals , ,  and  cycle through all the fuse addresses, and couple to the byte pre-decoder  to directly access the y-driver latch  in the \u201cbad\u201d y-drivers. The reset no-compare-OR signal  is used to reset the y-driver redundancy latches  in the accessed bad y-driver pairs during each of the 32 cycles if the bad address matches one of the addresses on the selected page. The redundancy address sequencer  receives the address signals  provided from the address counters , , and , a redundant oscillator clock (REDOSCLK)  provided from the redundant oscillator (not shown), an address extension (AEXT) signal  provided from the spare byte address counter , and the fuse state signals FS  that correspond to previously stored bad addresses from the fuse circuit (FUSECKT) . The input logic  provides a begin redundant address sequencing signal (BEGREDADDSEQ)  to initiate the redundancy address sequencer .",{"@attributes":{"id":"p-0176","num":"0175"},"figref":"FIG. 13","b":"605"},"The redundancy address sequencer  comprises a first redundant fuse address multiplexer (redfsaddmx) , a redundant regular address multiplexer (redregaddmx) , a redundant page comparator (redpgcomp) , a redundant fuse address counter (redfsaddctr) , a oneshot circuit (OSFNLD) , a plurality of delay circuits ,  and , a plurality of NAND gates , ,  through , a plurality of NOR gates  and , a plurality of D flip-flops  through , and a plurality of inverters \u2013 and \u2013.","The NAND gate  and the inverter  generate a fuse counter clock (FSCTRCLK)  as the logic AND of the Q output from the D flip-flop  and a fuse oscillator output signal . The D flip-flop  provides an enable fuse counter (ENFSCTR) signal  in response to the fuse oscillator output signal  applied to the clock input of the D flip-flop  and to the enable redundant oscillator (ENREDOSC) signal  applied to the reset and Q inputs of the D flip-flop . The inverter  generates the fuse oscillator output signal  in response to the redundant oscillator clock (REDOSCLK) . The redundant fuse address counter  generates fuse counter (FSCTR) signals .","The first redundant fuse address multiplexer  receives the fuse state signals FS , the fuse counter signals , and the enable fuse counter (ENFSCTR) signal , and generates a multiplexed fuse enable (FSENX) signal  and multiplexed fuse states (FSX) . The first redundant fuse address multiplexer (redfsaddmx)  is used to multiplex out one fuse address set (each fuse address set corresponds to a stored bad address), out of 32 fuse address sets () at a time during each of the 32 timing cycles. The one multiplexed out fuse address set is multiplexed fuse address set FSX . The multiplexed fuse enable (FSENX) signal  indicates whether the associated multiplexed fuse address set FSX  is being used for redundancy. The multiplexed fuse address set FSX  and the multiplexed fuse enable (FSENX) signal  are used to access the bad y-driver latch  to disable the compare-OR functions under the control of the redundant fuse address counter (redfsaddctr)  which cycles through all 32 fuse addresses.","The redundant regular address multiplexer (redregaddmx)  is used to enable to its outputs  and , either the regular byte\/page address A<:>  if redundancy is not used or the multiplexed fuse address set FSX  if redundancy is invoked (by the ENFSMUX signal  described below). The redundant regular address multiplexer  also provides buffering for its outputs, address signals  and , that couple to the inputs of the byte address predecoder  which accesses the y-drivers. Thus, if redundancy is invoked, the multiplexer  forces the byte address predecoder  to select the bad y-driver address stored in the multiplexed fuse address set FSX  during each of the 32 cycles.","The redundant page comparator (redpgcomp)  provides a logic signal, redundant page (RPAGE) , which couples to logic circuits generating the reset no-compare-OR signal (RSTNOCMPORL)  and to the enable byte decoder redundancy reset (ENBTDECREDRST) signal . As described above, the enable byte decoder redundancy reset signal  enables the byte pre-decoder  and byte address counters  or . The enable byte decoder redundancy reset signal  is used in the operation of the spare array .","The redundant page (RPAGE)  is invoked when the selected page address A<:>  matches a stored fuse (bad) page address FS<:>  (page address matching) and the multiplexed fuse enable (FSENX) signal  indicates the associated multiplexed fuse address set FSX  is being used for redundancy (fuse enabling). This prevents resetting the redundant latch  on a good y-driver based on a default state in the multiplexed fuse address set FSX  sent out by the redundant regular address multiplexer  in some instances. The redundant latch  is reset by a true state of the signal reset no-compare-OR (RSTNOCMPORL) .","As described below, the redundant address sequencer  also generates the end redundant address sequencing (ENDREDADOSEQB) signal  to signal the end of the action of the redundant address sequencer . The NAND gate  and the inverter  form an AND signal  from the begin redundant address sequencing signal  and the end redundant address sequencing signal , and apply the AND signal  to the reset and Q inputs of the D flip-flop . The delay circuit  delays the begin redundant address sequencing signal  for clocking the D flip-flop . The NAND  and the inverter  generate the enable redundant oscillator (ENREDOSC) signal  as the AND of the output of the D flip-flop  and the end redundant address sequencing signal . The enable redundant oscillator signal  is applied to a first input of the redundant fuse address counter .",{"@attributes":{"id":"p-0184","num":"0183"},"figref":"FIG. 14","b":"1304"},"The redundant fuse address counter (redfsaddctr)  comprises a plurality of D flip-flops - through -. The fuse counter clock (FSCTRCLK) signal  is applied to the clock input of the D flip-flop -. The Qbar output of each flip-flop  is coupled to the D input of the same flip-flop . The Q output of the flip-flops - through - is coupled to the clock input of the next flip-flop  (except the flip-flop -) and is provided as the fuse counter (FSCTR(x)) signals - through -, respectively, in response to the enable redundant oscillator (ENREDOSC) signal  coupled to the reset input of the flip-flops - through -.",{"@attributes":{"id":"p-0186","num":"0185"},"figref":"FIG. 15","b":"1301"},"The first redundant fuse multiplexer  comprises a plurality of second redundant fuse multiplexers - through -, an inverter logic circuit , an inverter , a redundant fuse bus pull (REDFSXBUSPULL) circuit , and a plurality of AND gates - through -. The inverter logic circuit  generates fuse counter signals , which include the buffered fuse counter signals  and inverted counterparts of the fuse counter signals , and provides the fuse counter signals  to the second redundant fuse multiplexers . The fuse state signals  are also applied to the second redundant fuse multiplexers . For clarity, individual ones of the fuse counter signals , the fuse state signals  are not individually numbered in . The second redundant fuse multiplexer  is enabled by the enable fuse counter signal . The second redundant fuse multiplexers  generate internal fuse state (FSXI<:>) signals  and internal fuse enable (FSENXI) signal . The AND gates - through - generate the buffered multiplexed fuse state signals FSX  in response to the internal fuse state signals FSXI  and the enable fuse counter signal . The AND gate - generates the buffered multiplexed fuse enable signal FSENX  in response to the internal fuse enable signal FSENXI  and the enable fuse counter signal .",{"@attributes":{"id":"p-0188","num":"0187"},"figref":"FIG. 16","b":"1501"},"The second redundant fuse address multiplexer  comprises a plurality of third redundant fuse address multiplexers - through -, which generate the internal fuse state signals  and the internal fuse enable signal  in response to the fuse state signals  and the fuse counter signals  (which is a buffered fuse counter signal ). For clarity, the fuse state signals  and the fuse counter signals  are not labeled individually by bit number in . The third redundant fuse address multiplexer  is enabled by the enable fuse counter (ENFSCTR) signal .",{"@attributes":{"id":"p-0190","num":"0189"},"figref":"FIG. 17","b":"1601"},"The third redundant fuse address multiplexer  comprises a plurality of transfer gates - through -, a plurality of NAND gates  and , and a plurality of inverters , ,  and . The transfer gates - through - provide the internal fuse state signal  in response to the applied fuse state signal  when enabled by an enable fuse multiplexer (ENFSMX) signal  from the inverter  and enabled by an inverted enable fuse multiplex (ENFSMXB) signal  from the inverter . The NAND gate  and the inverters  and  are coupled in series. The inverted and non-inverted signals  of the fuse counter signals  from the inverter circuit  () are applied to the corresponding inputs of the NAND gate . The NAND gate  is enabled by a AND gate formed of the NAND gate  and the inverter , which is enabled by the fuse counter (CTR) signal  and the enable fuse counter (ENFSCTR) signal . The fuse state enable FS() signal is applied to the inverter , which has an output applied to the transfer gate - for providing the internal fuse enable (FSENXI) .","Refer again to . The internal fuse state signals  and the internal fuse enable signals  are coupled to the redundant fuse bus pull-up (REDFSXBUSPULL) circuit  to pull up or down these signals. The enable fuse counter (ENFSCTR) signal  forms an enable pull-up signal. The inverter  generates an enable pull-down signal  in response to the enable fuse counter signal .",{"@attributes":{"id":"p-0193","num":"0192"},"figref":"FIG. 18","b":"1504"},"The redundant fuse bus pull (REDFSXBUSPULL) circuit  comprises a plurality of redundant fuse pull-up (REDFSXPULLUP) circuits - through - and a redundant fuse pull-down (REDFSXPULLDWN) circuit . The redundant fuse pull-up circuits  pull up the internal fuse state signals  in response to the enable fuse counter signal .",{"@attributes":{"id":"p-0195","num":"0194"},"figref":"FIG. 19","b":"1801"},"The redundant fuse pull-up circuit (REDFSXPULLUP)  comprises a PMOS transistor . The drain-source terminals of the PMOS transistor  couple the internal fuse state (FSXIx) signal  applied to the drain terminal to the supply voltage applied to the source terminal in response to the enable fuse counter signal  applied to the gate of the PMOS transistor .","Refer again to . The redundant fuse pull-down circuit  pulls down the internal fuse enable signal  in response to the enable pull-down signal .",{"@attributes":{"id":"p-0198","num":"0197"},"figref":"FIG. 20","b":"1802"},"The redundant fuse pull-down circuit (REDFSXPULLDWN)  comprises an NMOS transistor . The drain-source terminals of the NMOS transistor  couple the internal fuse enable (FSENXI) signal  applied to the drain terminal to ground in response to the enable pull-down (ENPULLDWN) signal  applied to the gate of the NMOS transistor .","Refer again to . The first redundant fuse address multiplexer  provides the multiplexed fuse state  to the redundant regular address multiplexer . The D flip-flop  generates an enable fuse multiplexer signal , which is applied to the redundant regular address multiplexer , in response to the enabled redundancy oscillator signal . The enable fuse multiplexer signal  is invoked by the begin redundant address sequencing signal , which is initiated by the input interface logic circuit . The D flip-flop  is clocked by the redundant oscillator clock , which has been inverted by the inverters  and . The address signals  and the address extension (AEXT) signal  are applied to the redundant regular address multiplexer .",{"@attributes":{"id":"p-0201","num":"0200"},"figref":"FIG. 21","b":"1302"},"The redundant register address multiplexer , together with the redundant page comparator , are used to reset the latch  in the defective y-driver circuit . The multiplexer  enables the multiplexed fuse states  to the address signals (AEXTI) , AI<:> , and AIB<:> , which couple to the byte pre-decoder , which then couples to the y-drivers , ,  through the byte select circuits , , and . The redundant register address multiplexer (redregaddmx)  comprises a plurality of redundant fuse address multiplexers (redfsaddmx)  and , a plurality of inverter chains - through -, and an inverter . The multiplexed fuse states  and the enable fuse multiplexer signal  are applied to the redundant fuse address multiplexer . The address signals , the address extension signal  and the inverted enable fuse multiplexer signal  from the inverter  are applied to the redundant fuse address multiplexer . The redundant fuse address multiplexers  and  are similar to the redundant fuse multiplexer  described above in conjunction with . Depending on the enable fuse multiplexer signal , the redundant fuse address multiplexers  and  provide either the multiplexed fuse state signals  or the regular address signals ,  to the inverter chain  via an AFS(:) bus . Each inverter chain  comprises a series of inverters to generate the address signal  and the inverted address signal . The inverter chain - generates the address extension signal .","Refer again to . The redundant page comparator  generates a redundant page (RPAGE) signal  in response to the multiplexed fuse enable signal , the begin redundancy address sequencing signal , the address signal , and the fuse state signals . The address signal  and the fuse state signal  correspond to the bits that select a page. This is due to page mode operation of the system  which uses page address matching for redundancy as described above.",{"@attributes":{"id":"p-0204","num":"0203"},"figref":"FIG. 22","b":"1303"},"The redundant page comparator  comprises a plurality of redundant comparators - through -, a NAND gate , and an inverter . The redundancy comparators  may be, for example, circuits similar to the redundancy comparator  described above in conjunction with . The address signal  and the fuse state signal  are applied to the redundancy comparators . Each redundancy comparator - through - generates a corresponding input of the NAND gate . The multiplexed fuse enable signal  and the begin redundancy address sequencing signal  are applied to corresponding inputs of the NAND gate . The inverter  and the NAND gate  generate the redundancy page signal  as the logic AND of the signals from the redundancy comparators - through -, the multiplexed fuse enable signal  and the begin redundancy address sequencing signal .","Refer again to . The redundant page signal  is applied to an input of the NAND gate . The end redundancy address sequencing signal  and the enable fuse multiplexer signal  are applied to corresponding inputs of the NAND gate . The output of NAND gate  is applied to corresponding input of the NAND gate . The enable fuse multiplexer signal  is applied to another input of the NAND gate . The output of the NAND gate  and the double inversion by the serially connected inverters  and  generate an enable byte decode redundancy reset (ENBTDECREDRST) signal .","The reset no-compare-OR (RSTNOCMPORL) signal  is generated from the redundant oscillator clock , the enable redundancy oscillator signal , the enable fuse multiplexer signal , and the redundant page signal . The redundant oscillator clock  is applied through the inverter  and the NAND gate  to the NOR gate , which is enabled by the inverter  in response to the enable redundancy oscillator signal . The output of the NOR gate  is applied to an input of the AND gate formed of the NAND gate  and the inverter  and delayed through the inverter  and the delay circuits  and  for application of another input of the NAND gate . The output of the inverter  is applied to the first input of the AND gate formed of the NAND gate  and the inverters ,  and , which generates the reset no-compare-OR (RSTNOCMPORL) signal . The enable fuse multiplexer signal , the fuse oscillator output signal , and the redundant page signal  are applied to corresponding inputs of the NAND gate . The reset no-compare-OR (RSTNOCMPORL) signal  couples to the y-driver redundancy latch  (see ).","The fuse counter signals  from the redundant fuse address counter  are applied to the respective inverters , , , ,  and . The output of the inverters  through  are applied to the NAND gate , and the outputs of the inverters , the fuse counter clock (FSCTRCLK) , and the fuse counter signal - are applied to inputs of the NAND gate . The output of the inverter  or the output of the NAND gate  are selectively applied to an input of the OR gate formed of the NOR gate  and the inverter . The output of the NAND gate  or ground are selectively applied to another input of the NOR gate , based on a desired decoding count. The selected fuse state from the inverter  is applied to an input of the AND gate formed of the NAND gate  and the inverter . The AND gate  is disabled by the enable redundant oscillator signal  from the inverter . The enable signal from the inverter  is applied to the oneshot circuit  that provides the output to the inverter  which generates the end redundancy address sequencing signal , which also is applied to another input of the AND gate .","In one embodiment, each fuse address - through - () corresponds to an address of a segmented column. In another embodiment, the number of fuse sets (as indicated by the fuse state signal  of ) is less than the number of the redundancy columns, for example, less than 32 fuse sets even though there are 32 redundancy columns. In one embodiment, this is done by sharing some fuse sets for a certain number of redundancy columns to save area due to a reduced number of fuse sets.","For the description of , communication between the memory system  with an external controller is via a serial byte by byte protocol, for example, signal transmission is by 8 digital data bits at a time.",{"@attributes":{"id":"p-0211","num":"0210"},"figref":"FIG. 23","b":["100","2302","0","26","0","528"]},"In response to a command sequence applied by the external controller via the input\/output line  to the memory array system , the data loading is initiated (block ). In one embodiment for the input command for data load, a chip load enable (CLE) is set to one (CLE=1), a write enable (WE\/) signal is pulsing, and the input\/output signal  is set to data load command code 80H (IO(:)=80H) to begin the data loading sequence.","The data in the data latches  (e.g., BBBB) of the regular y-driver circuits  and  and the data latches  of the redundant y-drivers  are reset to a predetermined value in response to the data load command (block ). The predetermined value corresponds to a default input data to be stored in the regular memory array. In one embodiment, the predetermined value is fixed, for example, \u20181111\u2019 (\u201cF\u201d), for reasons described below. In another embodiment, a configuration (fuse) bit initialization is executed to load in data from fuse non-volatile memory cells to the volatile latches  located in the fuse circuit  at this step. For either of these embodiments, the predetermined value of the data latch  reset controls the compare-OR function as follows. The redundant latches  of the y-driver circuits , , and  are reset to disable the compare-OR (COMPOR) signal  and the inverted compare-OR (COMPBOR) signal  by the enable data signal (ENDATAFB) . The enable data signal (ENDATAFB) , generated from NAND gate  as shown in , is enabled when the data pattern BBBB is \u201cF\u201d in the data latches  and the enable data signal  is high. Thus, the compare-OR functions can be disabled when the predetermined value in the data latches  (e.g., BBBB) is reset to \u201cF\u201d. This allows partial programming of a page, as described below.","The addresses are then supplied by the external controller to provide addresses to the memory array system  (block ). In one embodiment, the address latch enable (ALE) signal is set to one (ALE=1), the write enable (WE\/) signal is pulsing, the addresses A<:> are coupled on the input\/output line . The addresses are latched by address counters , , and  to provide addresses to the memory array system .","The loading of input data is then initiated to the memory array system  (block ). In one embodiment, the chip load enable signal is set to zero (CLE=0) and the address latch enable signal is set to zero (ALE=0) (block ). The write enable (WE\/) signal is pulsing, and the data is read in through the input\/output bus  (IO<:>=DATA IN) to the input data  to the latches  (blocks  through ). The input data  to be stored is loaded into the latches  in the y-driver  or .","In one embodiment, data that is not specifically loading into the latches (unloaded data) in the y-drivers stays at the predetermined default value, e.g., \u20181111\u2019 (\u201cF\u201d), for reasons described below.","In one embodiment, a redundancy address comparison is done in real time, e.g., the comparison is done as the data is loading into the latches . The bad y-drivers  and  are disabled from loading in data. In one embodiment, the bad y-drivers  and  are disabled by disabling the byte address predecoder  in response to a match between an incoming address  and the fuse address  as provided by the redundancy controller . Hence, data in the bad y-drivers  and  remains reset (e.g., stays at \u201cF\u201d). The data (e.g., \u201cF\u201d) disconnects the compare-OR function from the bad y-drivers  and  (as done by the signal  coupled to the redundant latch  in ). Hence, the bad y-drivers are disabled from the compare-OR function. A predetermined data value (e.g., \u20181111\u2019 or \u201cF\u201d) is designated to indicate that no memory cell programming is to be performed by that y-driver. Similarly, if the data input  is \u20181111\u2019, no programming is to happen and no compare-OR function is performed (as done by the signal  coupled to the redundant latch  and in turn coupled to the inverter  and the NOR gate  to the PMOS transistor  to inhibit the bitline  as shown in ). Another example is to use the data \u201cF\u201d to allow partial page programming where only a subset of bytes within a page are loaded in and are programmed at a time while the other previously programmed or still erased bytes on the same page are not changed (data stays at \u201cF\u201d). At the end of data loading, the data (e.g., \u201cF\u201d) is decoded by the NAND gate  (enabled by the (ENDATAF) signal ) to disconnect the compare-OR function. If a redundancy address match occurs, the redundant y-driver circuit (RYDRV)  is enabled to load in data and to connect to the compare-OR function.","If the write enable signal is pulsing (block ), the redundancy address (REDADDTRUE) signal  is evaluated. The redundancy address (REDADDTRUE) signal  from the redundancy controller  serves as a flag coupled to the controllers  and  to issue appropriate control signals for the memory array system  to execute appropriate actions as described below. If the redundancy address signal  indicates a bad y-driver  or  (REDADDTRUE=1) (block ), the data stored in the bad y-driver circuit (YDRVR)  or  remains unchanged (e.g., B(:)=\u2018F\u2019) to disable the compare-OR function (block -). The data stored in a pair of the redundant y-driver circuits (RYDRV)  in the redundant y-driver circuit  is set equal to the input data  (e.g., 2\u00d7B(:)=IO(:)) (block -). The pair of redundancy data latches  of the redundant y-driver circuits (RYDRV)  stays in a set condition to enable the compare-OR function (block -). On the other hand, if the write enable signal is pulsing (block ) and if the redundancy address signal  does not equal one (REDADDTRUE=0) (block ), the redundancy data latches  of the good y-drivers (YDRVR)  or  remains set to enable the compare-OR function (block -) and the data stored in data latches  of a pair of the regular y-driver circuits (YDRVR)  or  is set equal to the input data  (e.g., 2\u00d7B(:)=(IO(:)) (block -). The loading of the y-driver circuit  or  continues until the number N of bytes written is greater than a selected number (e.g., ) (block ). When the input command is a start programming command (e.g. \u201810H\u2019) (block ), the programming is started (block ).","In another embodiment, the input data is loaded in the redundant y-drivers  as well as in the bad regular y-drivers  or . In this embodiment, disabling the data loading for the bad regular y-drivers  or  need not be done and thus less circuitry is used. Furthermore, the predetermined data \u201cF\u201d is not used to disable the compare-OR function, but instead uses another mechanism, such as the redundancy address sequencer , to disable the compare-OR function.","On the other hand, if the write enable signal is not pulsing (block ), until the input command is a start programming command (e.g. \u201810H\u2019) (block ), the programming does not start, and if the input command is a start programming command (e.g., \u201810H\u2019)(block ), the programming is started (step ).",{"@attributes":{"id":"p-0221","num":"0220"},"figref":"FIG. 24","b":["100","2402","9102","182","605","2403","605","416","110","114"]},"The cells are verified (block ). In one embodiment, the values in the data latches  determine the reference value of one of 16 references for verification. Other numbers of reference values may be determined. As described above, the margin defines a desired difference in voltage recurrent between memory cell output and reference value. In one embodiment, the data latches  (e.g., B\u2013B) select one of the reference voltages VR(-)  (from the y-driver reference decoder ) offset with a margin voltage, vmargin (e.g. 30 mV generated by a circuit which is not shown, and used in a system with 100 mV separation between adjacent reference voltages VR(-)), for each y-driver. If for any y-driver, the voltage of the cell (VCELL) coupled to each y-driver is less than the selected reference voltage  offset with the margin, e.g., VCELL<(VR(-)-vmargin), then the inverted compare-OR signal  is set to one (COMPBOR=1) to indicate the cell has been correctly programmed with the desired margin (e.g., VCELL<(VR(-)\u221230 mV) and the voltage on the bit line  is set to equal to the voltage on the voltage inhibit signal  (BL=VINH) to prevent further programming. To better understand the principle of margin in this embodiment, it is useful to know that the voltage VCELL is decreasing after each programming pulse. When the inverted compare-OR signal  from each of the enabled y-drivers is equal to one, then the compare-OR logic (COMPORLOG) circuit  sets inverted compare-OR signal  equal to one to indicate the programming has been completed correctly for all y-drivers in the memory array system .","If the inverted compare-OR signal  is not set to one (e.g., COMPBOR\u22601) (block ), a program pulse is applied to the memory array system  (block ). Only those selected cells coupled to bit-lines coupled to y-drivers whose inverted compare-OR signal  is not set to one (e.g., COMPBOR\u22601) receive the programming pulse. Bit-lines coupled to y-drivers whose inverted compare-OR signal  is set to one (e.g., COMPBOR=1) remain coupled to the voltage inhibit signal  (BL=VINH) to prevent further programming. In one embodiment, the common line voltage (VCL) applied to the source of the memory cells, the select gate voltage (VSG) applied to the gate of the selected memory cells and the bit line current (IBL) applied to the drains (also called bitlines) of the memory cells are set at programming values, and the verification counter is incremented (N=N+1). If the verification counter is less than an end of count value (N<NEND)(block ), the system  returns back to verification (block ), described above.","On the other hand, if the verification counter equals an end of count value (N=NEND) (block ) or if the inverted compare-OR signal  is set (e.g., COMPBOR=1) (block ), the margin is verified on all cells (block ). In one embodiment, the verify is done to check that the voltage VCELL of the cells has not been programmed so low that it is too close to the adjacent state below the desired program state. In one embodiment, the data latches  (e.g., B\u2013B) select one of the reference voltages VR(-)  (from the y-driver reference decoder ) offset with a verify margin voltage, vvmargin (e.g. 70 mV generated by a circuit which is not shown), for each cell (y-driver). If for any cell (y-driver), the voltage of the cell VCELL is less than the selected reference voltage  offset with the verify margin, e.g., VCELL<=(VR(-)\u2212vvmargin), the compare-OR signal  is set to zero (COMPOR=0), which is indicative that the cell voltage is over-programmed below the desired reference value, e.g., VCELL<(VR(-)\u221270 mV). When the compare-OR signal  from any of the y-drivers is equal to zero, then the compare-OR logic (COMPORLOG) circuit  sets compare-OR signal  equal to zero to indicate the verify has been completed incorrectly for some y-drivers in memory array system .","If the compare-OR signal  is not equal to zero (e.g., COMPOR=1) (block ), the programming and verification is completed correctly, and a program status bit (SRO) and an inverted ready busy signal (R\/B\/) are set (block ). In one embodiment, the program status bit is set equal to zero (e.g. SR=0) and the inverted ready busy signal is set to one (e.g., R\/B\/=1).","On the other hand, if the compare-OR signal  is equal to zero (block ), the programming and verification is completed with error and the program status bit and inverted ready busy signal are set (block ). In one embodiment, the program status bit is set to one (e.g. SR=1 to indicate an error in program) and the inverted ready busy signal is set to one (e.g., R\/B\/=1). In an alternate embodiment, separate system status flags can be used to discriminate between two separate error conditions as follows. One status flag can be set to indicate the compare-OR signal  is equal to zero and the system failed to verify correctly (e.g. over-programming has occurred). Another status flag can be set to indicate the inverted compare-OR signal  is still equal to zero after the verification counter equals an end of count value (N=NEND) and the system failed to program correctly (e.g. insufficient programming has occurred).",{"@attributes":{"id":"p-0227","num":"0226"},"figref":"FIG. 25","b":["100","2502"]},"An erase pulse is applied to the selected block (block ). In one embodiment, the erase pulse has an erase voltage value (VE) and an erase time duration (TE) applied to the selected block.","The compare-OR function of the bad y-drivers  is disabled by a run redundancy address reset \u201cREDADDRESET\u201d sequencer step (block ). In one embodiment, as detailed above, the redundancy address sequencer  resets redundancy data latch  in the defective y-drivers  to disable the compare-OR function. In one embodiment, the redundancy address sequencer  sets the redundancy data latch  in the redundant y-drivers  to enable the compare-OR function.","The margin is verified in all cells in the page (block ). In one embodiment, the value \u201cF\u201d stored in the data latches  determines the reference voltage (VR) . The erase margin is verified. In one embodiment, if all cells in a page have the voltage of the cell greater than the reference voltage  (VCELL>VR), the margin is sufficient and the compare-OR (COMPOR) signal  is set (e.g., COMPOR=1). If any cell in a page has the voltage of the cell less than the reference voltage  (VCELL<VR), the erase margin is insufficient and the compare-OR (COMPOR) signal  is not set (e.g., COMPOR=0). In one embodiment, the reference voltage is offset higher by a fixed bias value, e.g., 30 millivolts. In another embodiment, the reference voltage is offset by a ratio to a reference voltage, e.g., 5% of the reference voltage (VR) .","If the compare-OR signal  is not set (e.g., COMPOR\u22601) (step ), which indicates some erased cells are verified unsuccessfully, the erase is completed and the status bit and the inverted busy signal are set (step ). In one embodiment, the erase status bit is set to one (e.g. SR=1 to indicate an error in erase) and the inverted ready busy signal is set to one (e.g., R\/B\/=1).","On the other hand, if the compare-OR signal  is set (e.g., COMPOR=1) (block ), the page number counter is incremented (PAGENO=PAGENO+1) (block ). Next, the page number is compared to a predetermined page number which corresponds to the number of pages in the block plus one (e.g., PAGENO=33) (block ), and if there is not a match, the system  continues the run redundancy address reset \u201cREDADDRESET\u201d sequencer step (block ). On the other hand, if there is a match, the erase is completed, and the status bit and the inverted ready busy signal are set (block ). In one embodiment, the status bit is set to zero (e.g. SR=0 to indicate successful erase) and the inverted ready busy signal is set to one (e.g., R\/B\/=1).","In one embodiment, the system  may repeat for more than one pass through the flow. In another embodiment, the system  may repeat a flow with variable erase time or variable erase value or both until all cells are verified or until a boundary condition is reached, e.g., maximum erase voltage VE or maximum erase time TE.",{"@attributes":{"id":"p-0234","num":"0233"},"figref":"FIG. 26","b":["100","2602","402","3","2","1","0","9102","182","2602"]},"The compare-OR function of the bad y-drivers  or  is disabled and enabled for redundant y-drivers  as needed by a run redundancy address reset \u201cREDADDRESET\u201d sequencer step (block ). In one embodiment, the redundancy address sequencer  resets the redundancy data latch  in the defective y-driver  or  to disable the compare-OR function.","The information, herein described as voltage, stored in the memory cell is then converted to digital bits with an implementation shown herein with 4 bits per cell (block ). In one embodiment described herein, a binary search is performed to find the digital bit one bit at a time. In another embodiment, a multibit binary search may be performed to find more than one digital bit at a time such as 1.5 or 3 bits. In one embodiment, the third read bit - is associated with a data latch - is set to a predetermined logic state (e.g., RDBIT=1). The output data - is forced to a low state (B=0). The data latches  are set for selecting a predetermined reference voltage VR(-)  (e.g., BBB to select VR). A comparison is made between the selected reference voltage VR(-)  and the memory cell output VCELL on the bitline  (). The data latch - is latched by the read bit - (B) signal from the algorithm controller  based upon the result of the comparison indicated by the comparator latch output signal . The second read bit - associated with the data latch - is set equal to a certain logic state (e.g., RDBIT2=1). The output data - is forced equal to a low state (e.g., B=0). The data latches are set for selecting another reference voltage VR(-)  based on the previous search (e.g., BBB with B latched from a previous search). The comparison is made between the selected reference voltage  and the memory cell output VCELL on the bitline , and the data latch - is then latched with B with the result from the comparison indicated on the comparison latch signal . Similar forcing of the first data bit - (e.g., RDBIT=1) and the zero data bit - (e.g., RDBIT=1) is performed resulting in the data latches - and - latched with B and B.","In one embodiment, a margin read verification can be performed. In a first mode, RESTORE, the cell output VCELL is checked if it inadvertently increases too close to a reference value above it (VR(-)) . Thus, the RESTORE margin read verification mode checks a \u201clook-up\u201d cell read margin condition and generates a flag called (RESTORE) as described below. In this case, the voltage of the cell is compared to a selected reference voltage (VRN)  less than a predetermined read margin voltage, vrmargin (e.g., 10 millivolts generated by a circuit which is not shown) (block ). In one embodiment, the data latch  selects the reference voltage VR(-)  (e.g., BBBB to select VR(-)). If any cell voltage VCELL is greater than the reference voltage VR(-)  minus a predetermined read margin voltage, e.g., VCELL>(VR(-)-vrmargin), the look-up margin of the cell is considered bad, and the inverted compare-OR signal  is set equal to zero (COMPBOR=0). In this embodiment vrmargin (block )<vmargin (block ) to allow some acceptable amount of inadvertent VCELL drift.","The inverted compare-OR signal  is analyzed (block ). If the inverted compare-OR signal  is equal to zero (COMPBOR=0), the state of the cell is determined to be a bad look-up cell and (RESTORE) is set equal to 1 or true (RESTORE=1) (block ). Otherwise, if the inverted compare-OR signal  is not equal to zero (COMPBOR\u22600), the state is determined to be a good look-up cell and (RESTORE) is set equal to 0 or false (RESTORE=0) (block ). If a cell is considered a bad lookup cell, a corrective operation may be then performed, for example by rewriting the cell and redoing the margin read verification.","In a second mode (RESTORE, serving as a flag for a look-down cell condition) of the margin read verification, the cell output VCELL is checked if it inadvertently goes down too close to a reference voltage below it (VR(-)\u22121). In this case, the voltage of the cell VCELL is compared to a selected reference voltage  (VR(-)\u22121) plus a predetermined read margin voltage, vrmargin (e.g., 10 millivolts generated by a circuit which is not shown) (block ). In one embodiment, the data latches  (e.g., the BBBB) select a reference voltage (VR(-)\u22121) . If any cell voltage VCELL is less than the selected reference voltage VR(-)-1 318 plus a predetermined read margin voltage, e.g., VCELL<((VR(-)\u22121)+vrmargin), the look-down read margin of the cell is considered bad and the compare-OR signal  is set equal to zero (COMPOR=0). The compare-OR signal  is analyzed (block ). If the compare-OR signal  is equal to zero (COMPOR=0), the state of the cell is determined to be a bad look-down cell, and RESTORE is set equal to 1 or true (RESTORE=1) (block ). Otherwise, if the compare-OR signal  is not equal to zero (COMPOR\u22600), the state is determined to be a good look-down cell, and RESTORE is set equal to 0 or false (RESTORE=0) (block ). If a cell is considered a bad lookdown cell, a corrective operation may be taken, for example, by rewriting the cell and redoing the margin read verification.","A byte read sequence is then initiated for reading any number of desired bytes of data (block ). In one embodiment, the inverted ready busy signal is set to one (R\/B\/=1). The chip enable signal is evaluated (block ). If the chip enable is set (CE\/=1), the reading is done (block ). The user may, after a fixed time out after R\/B\/=1, read the system status to check the flag for the read margin (RESTORE, RESTORE) flags.","On the other hand, if the chip enable signal is not set (CE\/=0), shifting out of bytes (data out) can then begin (block ). For each byte read, the real time redundancy address comparison, as provided by the redundancy decoders  through , disconnects the data output from the bad y-drivers  or  and connects the data output from the redundant y-drivers , as done by disabling the byte select circuits  or  and enabling the byte select circuit  respectively, with the redundancy address comparison occurring in real time as the byte is shifted out. In one embodiment, the read enable is analyzed (block ). If the read enable (RE\/) signal is not pulsing, the chip enable is analyzed (block ). If the chip enable (CE\/) is not set (CE\/\u22601), the process continues of analyzing the read enable (block ). On the other hand, if the chip enable signal is set (CE\/=1) (block ), the read verification is completed (block ). In another embodiment, instead of multiplexing the data out from a bad and redundant y-driver, the data out is multiplexed at an input\/output circuit or I\/O buffer.","On the other hand, if the read enable is pulsing (block ), the redundancy address signal  is analyzed (block ). If the redundancy address signal  equals 1 (REDADDTRUE=1), the input output data bus  is coupled to the redundancy y-driver  (block ). On the other hand, if the redundancy address signal  is not set (REDADDTRUE\u22601), the input output data bus  is coupled to the regular y-drivers  or  (block ). Also in this case, the redundancy data latch  of the good y-driver  or  is reset to enable the compare-OR function (block ). If the number of bytes being read is complete (number of bytes=NEND) (block ), the verification is done (block ). Otherwise, if the number of bytes read is not complete (block ), the process returns to determining if the read enable is pulsing (block ).","As described above, the column redundancy functions by replacing a regular column with a redundant column. A fractional multilevel redundancy functions by replacing a regular column by combining a part of a regular column with a part of a redundant column or by combining a part of a redundant column with a part of another redundant column. As an illustrative example, the description relates to a 4-bit memory cell (BBBB). Also in this example, the bad regular column has a defect that causes the least significant bits to fail, for example, B and B. The fractional multilevel redundancy detects this partial bad regular column and enables a redundant column to be used. The most significant bits B and B of the bad regular column are used. The redundant column is used to provide bits B and B to replace the defective regular bad column bits. Accordingly, the bad and redundant columns are only 2 bits instead of 4 bits per cell.","In this disclosure, there is shown and described only the preferred embodiments of the invention, but, as aforementioned, it is to be understood that the invention is capable of use in various other combinations and environments, is capable of changes or modifications within the scope of the inventive concept as expressed herein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIG. 1A","FIG. 1"]},{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 5A","FIG. 4"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 5B","FIG. 4"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 5C","FIG. 4"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 5D","FIG. 4"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 5E","FIG. 4"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 6","FIG. 1A"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 9A","FIG. 8"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 9C","FIG. 9B"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 10","FIG. 8"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 11","FIG. 7"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 12","FIG. 7"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 13","FIG. 6"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 14","FIG. 13"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 15","FIG. 13"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 16","FIG. 15"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 18","FIG. 15"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 19","FIG. 18"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 20","FIG. 18"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 21","FIG. 13"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 22","FIG. 13"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 23","FIG. 1"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 24","FIG. 1"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 25","FIG. 1"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 26","FIG. 1"]}]},"DETDESC":[{},{}]}
