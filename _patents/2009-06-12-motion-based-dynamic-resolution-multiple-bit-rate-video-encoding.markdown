---
title: Motion based dynamic resolution multiple bit rate video encoding
abstract: A video encoding system encodes video streams for multiple bit rate video streaming using an approach that permits the encoded resolution to vary based, at least in part, on motion complexity. The video encoding system dynamically decides an encoding resolution for segments of the multiple bit rate video streams that varies with video complexity so as to achieve a better visual experience for multiple bit rate streaming. Motion complexity may be considered separately, or along with spatial complexity, in making the resolution decision.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08270473&OS=08270473&RS=08270473
owner: Microsoft Corporation
number: 08270473
owner_city: Redmond
owner_country: US
publication_date: 20090612
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["With the increasing popularity of playing streaming audio and video over networks such as the Internet, there is a need for optimizing the data transferred from a server to a client such that the client's experience is maximized even if network conditions during playback are inconsistent. Optimizing the client's experience involves choosing a quality level for encoding the audio and video portions of the video playback such that the video can be transferred and reconstructed uninterrupted while preserving the quality of the video content.","The quality level is generally dictated by the bit rate specified for the encoded audio or video portions of the input stream. A higher bit rate generally indicates that a larger amount of information about the original audio or video is encoded and retained, and therefore a more accurate reproduction of the original input audio or video will be presented during video playback. Conversely, a lower bit rate indicates that less information about the original input audio or video is encoded and retained, and thus a less accurate reproduction of the original audio or video will be presented during video playback.","Generally, the bit rate is specified for encoding each of the audio and video based on several factors. The first factor is the network condition between the server and the client. A network connection that can transfer a high amount of data indicates that a higher bit rate can be specified for the input video that is subsequently transferred over the network connection. The second factor is the desired start-up latency. Start-up latency is the delay that a video playback tool experiences when first starting up due to the large amount of data that has to be received, processed, and buffered. The third factor is the tolerance to glitching. Glitching is when video playback has to stop because data is missing. In most cases any amount of start-up latency or glitching is intolerable, and it is therefore desirable to optimize the bit rate specified such that the start-up latency and the glitching are minimized or eliminated.","Currently available commercial streaming media systems rely on multi bit rate (MBR) coding to perform coding rate control. In MBR coding, source video content is encoded into alternative bit streams at different coding rates and typically stored in the same media file at the server. This then allows the content to be streamed in segments or chunks at varying levels of quality corresponding to different coding rates according to the changing network conditions, typically using bit stream switching between segments.","The currently available multi bit rate video streaming systems use a constant bit rate approach to encoding each alternative video stream. However, a typical video will generally include scenes having a wide variety of visual complexity. However, the constant bit rate approach can not efficiently encode video segments with different quality. The constant bit rate approach unnecessarily spends too many bits for encoding low complexity video segments, and conversely the high complexity scenes are allocated too few bits. Consequently, the constant bit rate approach to encoding the alternative streams results in video quality for Internet streaming that is undesirable and inconsistent.","The currently available multi bit rate video streaming systems also have a further requirement for the final display resolution to be fixed. By maintaining a fixed display resolution, the video streams at the multiple bit rates can all be decoded and scaled to this same final display resolution in order to achieve a glitch free video presentation. With the fixed display resolution, the various alternative video streams can have a wide range of bit rates from a few megabits per second to a few kilobits per second. One problem is to match an appropriate video resolution to each video stream bit rate. The currently available multi bit rate video streaming systems use a pre-defined encoding resolution, which again may not be well suited to the varying complexity (e.g., detail or\/or motion) of the video scenes.","The following Detailed Description concerns techniques (implemented via methods, devices and systems) for motion based dynamic resolution multiple bit rate video encoding, which are intended to make better use of the available bits with each bit rate so as to achieve generally higher quality video.","According to one technique described herein, the motion based dynamic resolution multiple bit rate video encoder dynamically varies the video resolution of the encoded video. The video encoder considers motion complexity of the video content (e.g., on a per group of pictures (GOP) basis) in the resolution resize decision. A higher resolution is selected for video content with less (slower) motion and a lower resolution is selected for video content with more (faster) motion. Motion complexity is determined by analyzing motion vectors (e.g., motion vector magnitude) during video encoding.","According to another technique described herein, the motion based dynamic resolution multiple bit rate video encoder dynamically varies the video resolution of the encoded video based on motion complexity and texture complexity. The multiple bit rate video encoder selects a higher video resolution for groups of pictures that have less texture complexity and less motion complexity, whereas a lower resolution is assigned for groups of pictures that have higher texture complexity and higher motion complexity. This dynamic resolution approach allows the multiple bit rate video encoder to achieve a generally better video quality for a given bit rate.","For each bit rate, the video encoder dynamically decides the resolution based on the video content of a scene (which may comprise one or more groups of pictures) in order to achieve better visual quality.","This Summary is provided to introduce a selection of concepts in a simplified form that is further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Additional features and advantages of the invention will be made apparent from the following detailed description of embodiments that proceeds with reference to the accompanying drawings.","The following detailed description concerns various techniques and systems for video encoding using motion based dynamic resolution to produce video streams at multiple bit rates for streaming. Although the techniques are described in the context of their application to a multiple bit rate streaming application, the techniques can be applied more broadly to other video encoding applications.","The various techniques and tools described herein may be used independently. Some of the techniques and tools may be used in combination. Various techniques are described below with reference to flowcharts of processing acts. The various processing acts shown in the flowcharts may be consolidated into fewer acts or separated into more acts. For the sake of simplicity, the relation of acts shown in a particular flowchart to acts described elsewhere is often not shown. In many cases, the acts in a flowchart can be reordered.","I. Multi Bit Rate Video Streaming",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["100","100","110","120","130","100","110","120"]},"In one specific example implementation, the server  is a standard HTTP server without any specialized streaming capability other than the ability to serve files. Because the server  does not support any specialized bit rate selection capability, the client  must perform all bit rate selection activities. In this implementation, the client  performs all bit rate selection activities. For example, the client  can perform rate control using the index information obtained from the server  (e.g., alone or in combination with other information, such as client buffer information, network bandwidth, etc.). However, in other implementations, some or all of the rate-control functions can occur at the server.","In general, the indexed file for multi bit rate streaming can be used by standard HTTP servers to serve multimedia content at multiple bit rates with bit rate selection (rate control) being performed client-side (e.g., exclusively client-side). Clients can perform rate control by first obtaining index information from the server describing the various bit rates available for streaming segments of a program. Based on the index information, and possibly other information (e.g., network bandwidth, buffer information, etc.), the client can decide which bit rate streaming segments to download from the server to provide a desired user experience (e.g., the best user experience possible based on the available bit rates and current network conditions).","Other types of computing devices (e.g., other than traditional HTTP servers) can provide files using the indexed file. For example, a computing device (e.g., a personal computer, server computer, or special-purpose streaming media server) can use the indexed file layout to serve multimedia content using various file serving protocols (e.g., File Transfer Protocol (FTP), Hypertext Transfer Protocol (HTTP), Real Time Streaming Protocol (RTSP), MMS (Microsoft Media Services), etc.).","In order to support bit rate switching, programs are divided into temporal chunks called streaming segments (self-contained units). The server stores each streaming segment at one or more bit rates (e.g., each streaming segment\u2014bit rate combination is a separate streaming segment encoding). Each streaming segment includes one or more available bit rate encodings for a specific track (e.g., a specific audio track, such as an English audio track, or a specific video track) of a program. Clients then determine which bit rate, from the available bit rates (e.g., from the available streaming segment encodings), to download for each streaming segment. For example, a client may obtain a first streaming segment, for a video track, encoded at 250 Kb\/sec (kilo-bits per second) (from one or more available streaming segment encodings for the first streaming segment), a second streaming segment, for the video track, encoded at 500 Kb\/sec (from one or more available streaming segment encodings for the second streaming segment), and a third streaming segment, for the video track, encoded at 1 Mb\/sec (mega-bit per second) (from one or more available streaming segment encodings for the third streaming segment). In the illustrated streaming system , each streaming segment contained in the indexed file is encoded by a video encoder at a variable bit rate (VBR) and variable resolution, as described below.","II. Video Encoder Overview",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["200","200","210","220","230","240"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2","b":["200","100","200","210","230"]},"The video encoder  processes video pictures. The term \u201cpicture\u201d generally refers to source, coded, or reconstructed image data. For progressive video, a picture is a progressive video frame. For interlaced video, a picture may refer to an interlaced video frame, the top field of the frame, or the bottom field of the frame, depending on context.","The video encoder  compresses inter-coded, predicted pictures of the input video and intra-coded pictures of the input video. For the sake of presentation,  shows a path for intra-coded frames through the encoder  and a path for inter-coded predicted frames. Many of the components of the video encoder  are used for compressing both intra-coded content and inter-coded, predicted content. The exact operations performed by those components can vary depending on the type of information being compressed.","In general, within the video encoder , an inter-coded, predicted frame (as a picture) is represented in terms of prediction from previously reconstructed content (as one or more other pictures, which are typically referred to as reference pictures or anchors). For example, content at a given time is encoded as a progressive P-frame or B-frame, interlaced P-field or B-field, or interlaced P-frame or B-frame. Within the video encoder , a prediction residual is the difference between predicted information and corresponding intra-coded frames.","The input video  content on the inter-path is encoded as a predicted picture based on motion information. If certain conditions are met, the video encoder  uses the pre-calculated motion information from input  (as illustrated by selection switch ), which can be in the form of a set or sequence of motion vector for macroblocks or other sets of samples of the inter-path video picture with respect to one or more reference pictures. In general, the choice to use the pre-calculated motion information can be based on: first, the availability of pre-calculated motion information; and second, which and whether encoding parameters were changed from the previous calculation of the motion information and the parameters used for the current encoding of the video content. In one example, the video encoder will choose not to use the previously calculated motion information from input  if the motion information was calculated for encoding the video content with a different video resolution than that which the video encoder is current encoding.","However, the video encoder  can instead choose (again illustrated by selection switch ) to perform new motion estimation for the inter-path video content  with motion estimator . The motion estimator  estimates motion of macroblocks or other sets of samples of the video picture with respect to one or more reference pictures, which represent reconstructions of previously encoded video content frames. The picture store  buffers this reconstructed video content  as a reference picture or pictures. When multiple reference pictures are used, the multiple reference pictures can be from different temporal directions or the same temporal direction. The motion estimator  outputs motion information  such as motion vector information.","The motion compensator  applies motion vectors to certain reconstructed video content  (stored as reference picture(s)) when forming a motion-compensated current picture . The difference (if any) between a block of the motion-compensated picture  and corresponding block of the original inter-path video picture is the prediction residual  for the block. During later reconstruction of the inter-path video frame (e.g., at a video decoder), reconstructed prediction residuals are added to the motion compensated residual video  to obtain reconstructed content closer to the original inter-path video . In lossy compression, however, some information is still lost from the original inter-path video. Alternatively, a motion estimator and motion compensator apply another type of motion estimation\/compensation.","A frequency transformer  converts spatial domain video information into frequency domain (i.e., spectral, transform) data. For block-based video content, the frequency transformer  applies a DCT, variant of DCT, or other forward block transform to blocks of the samples or prediction residual data, producing blocks of frequency transform coefficients. The frequency transformer  may apply an 8\u00d78, 8\u00d74, 4\u00d78, 4\u00d74 or other size frequency transform.","A quantizer  then quantizes the blocks of transform coefficients. The quantizer  applies non-uniform, scalar quantization to the spectral data with a step size that varies spatially on a picture-by-picture basis, macroblock-by-macroblock basis or other basis. Additionally, in some cases the quantizer varies quantization across color channels of the inter-layer residual video picture. The quantizer  can also apply another type of quantization, for example, a uniform or adaptive quantization for at least some spectral data coefficients, or directly quantizes spatial domain data in an encoder system that does not use frequency transformations.","When reconstructed video content is needed for subsequent motion estimation\/compensation of an inter-path video picture, an inverse quantizer  performs inverse quantization on the quantized spectral data coefficients. An inverse frequency transformer  performs an inverse frequency transform, producing blocks of reconstructed prediction residuals (for predicted inter-path residual video content) or samples (for intra-path residual video content). If the residual video content  was motion-compensation predicted, the reconstructed prediction residuals are added to the motion-compensated predictors  to form the reconstructed residual video. The picture store  buffers the reconstructed residual video for use in subsequent motion-compensated prediction.","The entropy coder  compresses the output of the quantizer  as well as certain side information (e.g., quantization parameter values) Typical entropy coding techniques include arithmetic coding, differential coding, Huffman coding, run length coding, LZ coding, dictionary coding, and combinations of the above. The entropy coder  typically uses different coding techniques for different kinds of information, and can choose from among multiple code tables within a particular coding technique.","When the video encoder  performs intra-compression of the intra-path video content, the encoder intra-compresses it as an intra-coded picture, without motion compensation. The video  is provided directly to the frequency transformer , quantizer , and entropy coder  and output as encoded video. A reconstructed version of the intra-coded video can be buffered for use in subsequent motion compensation of other inter-path video.","A controller  receives inputs from various modules such as the motion estimator , frequency transformer , quantizer , inverse quantizer , and entropy coder . The controller  evaluates intermediate results during encoding, for example, setting quantization step sizes and performing rate-distortion analysis. The controller  works with other modules to set and change coding parameters during encoding. When the controller  evaluates different coding parameter choices, the controller  may iteratively perform certain stages to evaluate different parameter settings, or the controller  may jointly evaluate different coding parameters. The tree of coding parameter decisions to be evaluated, and the timing of corresponding encoding, depends on implementation. In some embodiments, the controller  also receives input from an encoding session wizard interface, other encoder application interface, or other source to designate video to be encoded using specific rules.","III. Variable Bit Rate Encoding of MBR Streams","For the multiple bit rate video streaming system  (), a multiple bit rate video encoding system separately encodes the input video as a set of compressed video streams with successively decreasing overall bit rates. Although described herein as encoding separate individual MBR video streams, an alternative implementation of the MBR video streaming system and encoding system can encode one or more of the MBR video streams as a compressed bitstream having multiple separable coding layers. The multiple bit rate video encoding system includes an MBR encoding engine (not shown) that drives the video encoder  () to encode the input video with varying encoding parameters according to a multiple bit rate encoding process (as shown in ) that implements a variable bit rate and motion based dynamic resolution approach described in this and the following section. The MBR encoding engine can provide a user interface or console for receiving user input to configure parameters for the MBR video stream encoding (or alternatively an application programming interface to receive such input from a caller application), such as the number of streams, and other parameters mentioned below.","In contrast to other currently available multiple bit rate video streaming systems (which use a constant bit rate approach to encoding the multiple video streams), the MBR encoding system for the multiple bit rate video stream system  aims at providing a constant or consistent quality for each video stream. For the top MBR video stream (generally having highest overall bit rate), the video encoder  encodes the video stream with a varying bit rate constrained to fall under a specified peak bit rate while satisfying a specified average bit rate. For the bottom MBR stream (generally having the lowest bit rate of the set), the video encoder uses a constant chunk rate approach. In the context of the multiple bit rate video streaming system, the term chunk refers to a group of pictures (GOP) into which the video stream are segmented, and define the level of granularity at which the video streaming system may switch playing individual segments between video streams. The constant chunk rate approach enables the video streaming system to guarantee predictability of streaming, in that when the lowest bit rate or quality video stream is streamed, the client will receive the chunk amount of pictures at the constant rate so as to maintain minimum quality continuous playing of the video.","In between the lowest and highest overall bit rate streams, the video encoder encodes one or more intermediate video streams also using variable bit rates of coding within the constraints of a peak bit rate and average bit rate that aim to maintain a constant video quality. The peak and average bit rate constraints of the intermediate video streams can be specified to decrease progressively in a proportional, logarithmic or other decreasing manner. For example, the average bit rate of the intermediate stream can decrease proportionally to be \u00be, \u00bd, and \u00bc that of the average bit rate constraint of the highest bit rate video stream. In this way, the video streaming system  is able to provide an instant start and swift video switching from a guaranteed low constant chunk rate up to a highest quality variable rate bit stream. The peak and average bit rates, as well as the constant chunk rate are encoding parameters that can be configured by the user. These parameters can be configured explicitly by the user, or calculated by the MBR encoding system engine based on more generalized parameters input by the user. For example, the MBR encoding engine can have an automatic mode where the user (or a caller application) simply specifies the minimal and maximal target bit rates and a number of video streams or layers. The engine in this automatic mode then calculates all the intermediate bit rate constraints (peak and average) in a uniform, logarithmic or other distribution space.","With reference now to , the MBR encoding system encodes the set of MBR video streams with a process  that uses a two pass encoding approach. This process includes an analysis pass and an encoding pass. The goal of the analysis pass is to find the scene complexity of the video content (spatial and\/or motion complexity) based on the encoding configurations as well as the input video source material itself. Once this information is extracted in the analysis pass, the following encoding pass then generates the set of MBR video streams.","The MBR encoding process  begins with an initialization step . In this step, the MBR encoding process determines the parameters for the encoding from user input, including number of MBR video streams, peak and average bit rate constraints for the streams, and the constant chunk rate of the lowest quality MBR video stream, motion search range parameters, and segment parameters, among others.","The analysis pass of the MBR encoding process  includes actions -. In the analysis pass, the MBR encoding engine analyzes the input source video frame by frame. The analysis includes a number of different tasks including scene change detection, segmenting a video sequence between scene change boundaries into group of picture segments, and video frame complexity measurements (e.g., spatial and\/or motion complexity). Based on the scene change detection, the MBR encoding engine marks boundaries at which scene changes occur during the video. Between marked boundaries of a video sequence (sequence mark-in and sequence mark-out positions), the MBR encoding process  further determines a total number of group of pictures segments in which to divide the video sequence within user-specified constraints (such as a specified average GOP length and maximum allowed GOP length within a scene) and sets boundaries of each group of pictures. Once the GOP boundaries are defined, the total numbers of frames within each GOP is calculated by the MBR encoding engine. The MBR encoding engine calculates a set of three texture measurements per frame of each group of pictures, which are used in the variable resolution encoding described in the next section. The three texture measurements include a frame global texture, frame horizontal texture and frame vertical texture measurement. The MBR encoding engine also calculates the median value of the magnitude of the motion vectors per frame of each group of pictures, which are used in the variable resolution encoding described in the next section. In a specific implementation, the magnitude of a motion vector is the sum of the absolute values of the x and y component of the motion vector. Also, in the specific implementation, the median value is calculated for each predicted (e.g., P and\/or B) frame in the GOP.","The MBR engine writes these analysis pass results (the scene and GOP boundaries, the texture measurements, and the motion vector measurements) into a log file, as indicated at action . In a specific implementation, the MBR engine calculates an average median motion vector value per GOP (from the median motion vector magnitude values of the frames of the GOP), and stores the average median motion vector value in the log file.","For the encoding pass (actions -), the MBR engine applies the results of the analysis pass to encode the MBR video streams using the video encoder  (). The MBR engine causes the video encoder  to encode each segment (action ) for all the MBR streams (action ). For each segment of an MBR video stream, the MBR encoding engine controls the encoding parameters of the video encoder  in an attempt to hit user specified targets for an average bit rate. If the source video content is too complex to be encoded at the targeted bit rate, the MBR encoding engine starts to increase the quantization step size in order to achieve a better visual quality. The top or best quality video stream is encoded subject to a maximal peak bit rate constraint meeting the user specified MBR encoding parameters. For the bottom or lowest quality video stream, the MBR engine controls the video encoder to produce an encoding of the video stream to meet the constant chunk rate constraint, which helps guarantee client side predictability for playing the streamed video. In intermediate video streams, the MBR engine causes the video encoder to encode the source video with encoding parameters to produce the video stream a variable bit rate falling within maximal peak and average bit rate constraints for the respective intermediate stream.","As a result of the encoding pass, the MBR engine then outputs compressed video bit streams for the set of MBR streams that are produced using the video encoder, as well as a log file. With the variable bit rate approach of this MBR encoding process , the MBR engine produces a set of MBR video streams that decreases evenly from a top to bottom quality stream for each GOP. With this set of MBR video streams, the MBR system  () can deliver a desired constant or consistent visual quality for the video sequence according to the available connection bandwidth.","IV. Variable Resolution Encoding of MBR Streams","The MBR encoding engine also applies a technique that dynamically varies resolution of encoding for each of the MBR video streams. For each video stream ranging from the top to bottom of the MBR video streams, the MBR encoding engine dynamically decides the resolution for encoding each video GOP to produce a better visual quality. For each video stream, the MBR encoding engine assigns a higher resolution to a low spatial complexity GOP (or segment), while a more spatially complex GOP (or segment) is assigned a lower resolution of encoding. In addition to, or instead of, spatial complexity, motion complexity can be considered when dynamically varying resolution. Specifically, resolution can be lowered for a GOP (or segment) with significant motion.","Encoding video content with fast motion scenes can be challenging for video encoders. For example, in some situations the motion estimation routine cannot track fast motion scenes because of limits and\/or heuristics in deciding the motion search range. If the motion search range is too small (or exits early), the motion estimation routine may generate inaccurate motion vectors. The inaccurate motion vectors, in turn, generate large error signals. In order to meet the target bit rate, the encoder may compensate for the large error signals by increasing the quantization parameter. The end result is a frame with high blockiness. On the other hand, if the motion search range is too large, the motion estimation routine can consume a high percentage of the encoding time. This leads to long encodes with little gain (because the fast motion scene usually flies by on the screen in a blur). In addition, inaccurate motion vectors can lead to incoherent motion of objects. The macroblocks belonging to the object may be assigned motion vectors that are not coherent. This results in a frame with blocks of the same object moving in seemingly random directions.","The MBR encoding engine can take advantage of motion complexity in video content to tune the rate control mechanism. This approach allows the MBR encoding engine to resize resolution in scenes with motion. For example, motion complexity of video content can be determined by computing the median value of the magnitude of the motion vectors in video pictures (e.g., in predicted pictures, such as P and\/or B pictures). The median can then be averaged over the pictures (e.g., frames) in a segment or GOP (e.g., averaged over all the P frames in a GOP). The average median is a function of the amount of motion in the segment or GOP where a higher average median implies faster perceived motion in the segment or GOP.","Accuracy of motion compensation is, in part, dependent on the motion search range, where a larger search range gives a more accurate set of motion vectors. In a specific implementation of the MBR encoding engine using the SMPTE 421-M video codec, an adaptive motion search range is used. The adaptive motion search range changes on a frame-by-frame basis, adapting from 0 to 3 depending on the amount of motion in the content. Alternatively, the motion search range can be set to a fixed value (e.g., a user-settable option). In a specific implementation of the encoding engine using the SMPTE 421-M codec, a motion search range of 2 or larger has been found, empirically, to result in motion vectors capable of indicating whether encoded video content contains significant motion (e.g., sufficient to determine a range of motion present in video content from little or no motion to fast motion).","For video content with significant motion, reducing the resolution can provide a number of encoding efficiencies\/improvements. For example, a reduced resolution reduces the motion search range, increasing the chance that the motion estimation routine will find an accurate motion vector, and a reduced resolution results in increased encoding speed. In addition, more accurate motion vectors produce smaller error signals, which lead to a smaller quantization parameter and less blockiness in the encoded video stream. Finally, more accurate motion vectors allow spatially adjacent blocks belonging to the same object to move in a coherent fashion.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 8","b":["800","800","1","3","1","2","3"]},"At , the three GOPs are encoded without dynamic resolution (i.e., they are all encoded at the same resolution).","At , the three GOPs are encoded at the three different bit rates using, at least in part, motion based dynamic resolution. As can be seen at , the slow motion GOP (GOP ) is encoded at one resolution for all three bit rates (alternatively, in some encoding situations, the lower bit rate encodings could be at a reduced resolution). The median motion GOP (GOP ) for bit rate  is encoded at the same resolution as bit rate  for GOP , while bit rate  and bit rate  is encoded at lower (reduced) resolution. Similarly, the high motion GOP (GOP ) for bit rate  is encoded at the same resolution (as bit rate  for GOP  and ), while bit rates  and  are encoded at even lower (more reduced) resolution. In the visual representation , the relative resolution of each GOP encoding is reflected by the size of the corresponding box.","Depending on the particular encoding situation and\/or the particular video content, more or less resolution resizing may be performed than is depicted in the visual representation .","In an example implementation, the MBR encoding engine applies the decision to dynamically resize resolution of each GOP at scene boundaries of the video. This avoids introducing any undesirable visual effects that resizing video resolution in the middle of a video scene might produce. For example, in a scene featuring a \u201ctalking head,\u201d varying the video resolution mid-scene could introduce a noticeable popping or pulsing as the detail edges and features in the scene sharpen or soften along with the resolution change. Accordingly, the MBR encoding engine performs the below described process for the GOP or GOPs of a scene (e.g., for the first GOP after a scene change boundary identified in the analysis phase described above).","In one example implementation of the dynamic resolution encoding, the MBR encoding engine uses a three-point sampling approach to make the dynamic resolution decision. Each sampling point represents the result (in terms of actual encoded bit rate or size) from encoding the GOP using three different pairs of video resolution and quantization step sizes. With these three sampling point results, the MBR engine establishes a model of the relation between resolution, quantization step size and coded size, which relation is illustrated graphically in . From this dynamically extracted model for the video sequence, the MBR encoding engine can then decide a resolution for each targeted bit rate of the MBR video streams. In alternative implementations, the MBR encoding engine can use more sampling points to establish the model. However, the three sampling point approach is found to be sufficient to establish the model while remaining most practical for purposes of encoding speed.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 5","b":["500","500","510","200"]},"In the illustrated model, the MBR video encoding engine performs the encoding for an initial sample resolution and quantization step size parameter pair (R, Q), as well as at one fourth of the initial sample resolution (i.e., (R\/4, Q)) and at twice the initial sample quantization step size (i.e., (R, Q*2)). Alternatively, other parameter pairs for the sample points can be used, such as at half resolution, four times the quantization step size, etc. The MBR video encoding engine observes the encoded bit sizes (S, S, and S) that result from encoding the GOP of the video stream with the three resolution and quantization step size parameter pairs.","In a next action , the MBR engine establishes two linear models: one for the relation between quantization step size and encoded size (labeled GraphQS in the diagram of ), and one for the relation between resolution and encoded size (GraphRS). The relation between quantization step size and encoded size is determined by the encoded sizes that result from the two sample points where the quantization step size is varied while the resolution is held constant, while conversely the relation between resolution and encoded size is determined from the two sample points which vary the resolution while quantization step size remains constant.","At action , the MBR engine uses the relation of encoded size to quantization step size to find the quantization step size that yields the encoded size corresponding to the desired bit rate. This is the modeled result quantization step size (labeled Q\u2032) at the full sampling resolution R that should yield the target bit rate for the GOP of the video stream.","The MBR engine then compares the modeled result quantization step size to an empirically determined threshold (determined from experiments measuring video texture over a wide range of video content). If the modeled result quantization step size is smaller than the threshold, then the MBR engine decides to use the full sample resolution and modeled result quantization step size, i.e., (R, Q\u2032) at action .","More specifically, the MBR engine determines the appropriate quantization step threshold based on the per frame texture measurements made during the analysis phase (discussed above) for the input video content. The MBR engine calculates the texture measurements for the GOP by averaging the frame texture measurements for all frames in the GOP. This produces GOP global texture, GOP horizontal texture and GOP vertical texture measurements. Of these, the GOP global texture measurement determines the quantization step size threshold that controls when to resize video resolution. From experimental results over a broad range of video content (including sports, television, movies, etc.), it has been determined that a quantization step size threshold of Qequal to 12 (for video encoding with the SMPTE 421M standard) is suitable for video with a typical GOP global texture measurement. In other words, if the modeled result quantization step size Q\u2032 is over 12, then the MBR encoder should resize to a lower video resolution in order to encode at a lower Q. However, in an example implementation, the MBR encoder can further vary the quantization step size threshold for resizing depending on the overall global texture measurement for the video. The MBR encoder has established a linear relationship between global texture and the quantization step size threshold for resizing. For video having a low overall global texture, a lower quantization step size threshold is expected. This allows the MBR encoder to be more aggressive in resizing down the video resolution of video content having a lot of smooth regions (for which resizing to a lower resolution would tend not to produce artifacts). Whereas, for video with high global texture, the MBR encoder expects a higher quantization step size threshold for resizing. Such higher threshold makes the MBR encoder more careful in resizing down video resolution of frames that have a lot of detail, so as to avoid smoothing of detailed regions of those frames. In alternative implementations, the quantization step size threshold can be established at other quantization step sizes, such as for use with other video encoding standard, or to achieve a desired degree of aggressiveness\/caution in resizing the video resolution.","On the other hand at action , if the modeled result (the modeled result quantization step size Qp\u2032 determined at  above) is larger than the threshold defined by the video texture, the MBR engine instead uses the relation between encoded size and resolution (GraphRS) to find a modeled result resolution (R\u2032) that yields the encoded size corresponding to the target bit rate of the video stream. In a specific implementation, the result of action  is a texture scale factor determined from GraphRS. An example texture scale factor is 0.8 (where 1.0 is full resolution R), indicating a reduction in resolution to 0.8*R.","In addition, at  if the modeled result is larger than the threshold defined by the video texture (action  above), then motion complexity is also considered in the resolution resize calculation. Generally, for video content with high motion (which is typically blurry), the resolution can be reduced further without significantly affecting quality. In a specific implementation, the motion complexity calculation is performed as depicted in .",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 6","FIG. 3"],"b":"610"},"At , if the average median motion vector value is greater than the motion threshold, then a motion resize scale value is determined. In a specific implementation, the motion resize scale value is determined using a motion resize scale mapping function. An example motion resize scale map  is depicted in . In , the x-axis of the scale map  represents the normalized (from 0 to 1) average median motion vector value (linearly normalized based on video resolution and the motion search range), and the y-axis represents the motion resize scale value (normalized from 0 to 1). The motion resize scale mapping function depicted in  is a two-piece linear function. From a normalized average median motion vector value of 0 to a threshold value N, the video segment, or GOP, is considered to have no significant motion (or, not enough motion to warrant a reduction in resolution). For a normalized average median motion vector value from the threshold value N and up (to a value of 1.0), a motion resize scale value is applied, indicating a resize in resolution. For example, using the scale map , an average median motion vector value of approximately 0.9 indicates a motion resize scale value of approximately 0.6. Instead of a piecewise linear motion resize scale mapping function, other functions could be used (e.g., a piecewise linear function with more segments, a non-linear function, or different functions for different types of video content).","In a specific implementation, the scale map is a linear function with five segments, with the first segment being the no-motion segment from a normalized average median motion vector value of 0 to a threshold value N. In the specific implementation, the five-piece linear function is obtained by determining an optimal resize of a set of representative video clips. For example, the clips are viewed at different resolutions for blockiness versus smoothing (or blurring). In the specific implementation, slightly blurred pictures are preferred over blocky pictures. The optimal resolution is then chosen such that there is little or no blockiness at varying motion clips.","At , the final resize scale value is calculated by adjusting the texture scale factor (resulting from action  above) by the motion resize scale value. In a specific implementation, the texture scale factor is multiplied by the motion resize scale factor to determine the final resize scale value. For example, if the texture scale factor is 0.8, and the motion resize scale value is 0.6 (e.g., determined from the motion resize scale map , where the normalized average median MV value was 0.9), then the final resize scale value would be: 0.8*0.6=0.48 (about half the pixel area as the original resolution).","On the other hand at , if the average median MV value is not greater than the motion threshold, then a motion resize scale value is not applied, and the texture scale factor is applied without compensation for motion complexity.","Alternatively, the final resize scale value can be calculated in other ways. For example, the final resize scale value can be calculated by taking the minimum of the texture scale factor and the motion resize scale value.","In some encoding situations, it may be desirable to prevent over-scaling the resolution. In a specific implementation, a floor value is used to limit the amount of scaling performed by the motion complexity calculation. For example, the motion resize scale value can be limited, or the resized pixel resolution can be limited. The floor value can be applied independently to the texture scale factor and\/or the motion resize scale value. In addition, a minimum final resized resolution can also be applied (e.g., a minimum resized resolution of 64 pixels, horizontally and\/or vertically).","Returning to , The MBR engine can decide to resize the resolution uniformly (i.e., the same horizontal and vertical resolution scaling), or non-uniformly. In a specific implementation, the GOP average horizontal and vertical texture measurements are used to control how much to resize the video resolution in each direction. The MBR engine calculates a ratio of the GOP horizontal and vertical texture measurements. Once it is determined to resize the resolution (actions  and ), and MBR engine has calculated the final resize scale value, the MBR engine then determines how to distribute the resize amount in the vertical and horizontal directions based on the ratio of GOP horizontal and vertical texture measurement. In particular, if there is a large discrepancy or delta between horizontal and vertical texture measurements (i.e., the ratio is non-unity), the MBR engine distributes the resizing to apply more resizing in the lower detail direction than is applied to the higher detail direction. For example, when the ratio is two, then the MBR engine would resize in the vertical direction twice as much as the horizontal direction. Otherwise, if the delta between the horizontal and vertical texture measurements for the GOP is low (the ratio is near unity), then the MBR engine resizes the resolution equally between the directions.","The MBR engine at action  then uses the relations between quantization step size and encoded size (GraphQS) and between resolution and encoded size (Graph RS) as well as the target bit rate of the respective video stream to establish a relation (GraphQR shown at top left of ) between resolution and quantization step size for the particular target bit rate.","At action , the MBR engine then uses the relation (GraphQR) established in action  to find a modeled result of the quantization step size (Q\u2032) for the modeled result resolution R\u2032 decided at action . The MBR engine then decides to encode this GOP of this video stream at the modeled result quantization step size and resolution (R\u2032, Q\u2032).","In a specific implementation, the final resize scale value is used to adjust the final resize scale value of lower layers. Specifically, the final resize scale value calculated for the top layer (the highest bit rate stream). Then, when the final resize scale value is calculated for the next lower layer (the next lower bit rate stream), it is multiplied by the final resize scale value of the top layer, and so on. For example, if a top layer GOP final resize scale value is 0.9, and a next lower layer GOP final resize scale value is 0.8, then the next lower layer GOP final resize scale value would be adjusted to: 0.9*0.8=0.72. The 0.72 value would then be used as a multiplier for the next lower layer, and so on until the lowest layer is calculated. In some implementations, the texture scale value is calculated for each layer, while the motion scale value is only calculated once and is used for all layers.","Alternatively, the final resize scale value can be calculated independently for each layer.","By use of this dynamic resolution approach, the MBR encoding system is able to assign a larger encoding resolution to less complex video and\/or lower motion segments (or GOPs), which maintains more visual detail. On the other hand, more complex and\/or higher motion video segments (or GOPs) are assigned a smaller resolution that reduces visual artifacts. This approach has been found to provide a better visual experience for multiple bit rate streaming.","V. Representative Computing Environment",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 9","b":["900","900"]},"With reference to , the computing environment  includes at least one central processing unit  and memory . For the multi core motion information precalculation discussed above, the computer includes a multi core CPU having plural CPU cores. In , this most basic configuration  is included within a dashed line. The central processing unit  executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power and as such, multiple processors can be running simultaneously. The memory  may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory  stores software  that can, for example, implement the technologies described herein. A computing environment may have additional features. For example, the computing environment  includes storage , one or more input devices , one or more output devices , and one or more communication connections . An interconnection mechanism (not shown) such as a bus, a controller, or a network, interconnects the components of the computing environment . Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment , and coordinates activities of the components of the computing environment .","The storage  may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment . The storage  stores instructions for the software , which can implement technologies described herein.","The input device(s)  may be a touch input device, such as a keyboard, keypad, mouse, pen, or trackball, a voice input device, a scanning device, or another device, that provides input to the computing environment . For audio, the input device(s)  may be a sound card or similar device that accepts audio input in analog or digital form, or a CD-ROM reader that provides audio samples to the computing environment . The output device(s)  may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment .","The communication connection(s)  enable communication over a communication medium (e.g., a connecting network) to another computing entity. The communication medium conveys information such as computer-executable instructions, compressed graphics information, or other data in a modulated data signal.","Computer-readable media are any available media that can be accessed within a computing environment . By way of example, and not limitation, with the computing environment , computer-readable media include memory  and\/or storage . As should be readily understood, the term computer-readable storage media includes the media for data storage such as memory  and storage , and not transmission media such as modulated data signals.","Any of the methods described herein can be performed via one or more computer-readable media (e.g., storage or other tangible media) comprising (e.g., having or storing) computer-executable instructions for performing (e.g., causing a computing device, audio and\/or video processing device, or computer to perform) such methods. Operation can be fully automatic, semi-automatic, or involve manual intervention.","Having described and illustrated the principles of our innovations in the detailed description and accompanying drawings, it will be recognized that the various embodiments can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computing environment, unless indicated otherwise. Various types of general purpose or specialized computing environments may be used with or perform operations in accordance with the teachings described herein. Elements of embodiments shown in software may be implemented in hardware and vice versa.","In view of the many possible embodiments to which the principles of our invention may be applied, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3","FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
