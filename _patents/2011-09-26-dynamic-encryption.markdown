---
title: Dynamic encryption
abstract: Systems and methods for encrypting a media file for streaming and/or downloading over a network are disclosed. These systems and methods may be part of a larger media servicing network that can be used to, among other things, process uploaded media content, provide it for streaming, and collect metric information regarding the streaming. The disclosed systems and methods provide for receiving requests for a media file or a chunk of a media file and responding to these requests by encrypting the requested chunks dynamically and providing the chunks to the requesting entity. These systems and methods, which can be utilized with a dynamic chunk generation and dynamic index file generation, enable a high degree of flexibility in streaming chunked media files and preclude the need to encrypt the chunks prior to streaming. The systems and methods may also be applied to encrypting files for continuous streaming protocols as well as for progressive download.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08625789&OS=08625789&RS=08625789
owner: Unicorn Media, Inc.
number: 08625789
owner_city: Tempe
owner_country: US
publication_date: 20110926
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This disclosure relates in general to cloud-based computer processing and, but not by way of limitation, to encrypting media for streaming.","The delivery of media over networks such as the Internet can be accomplished in many ways, including progressive downloading or streaming. Streaming is often preferred to progressive downloading because it offers additional features such as content protection and the ability to seek to undownloaded parts of a media file. The process of preparing a media file for streaming typically involves \u201cchunking\u201d the file, or dividing media files up into smaller segments for delivery. Information including where chunks may be accessed can be stored in an index file, or manifest. This index file can be delivered to a client, such as a media player application, for use in streaming.","The processes of chunking and indexing files for streaming present challenges to a media file delivery service provider or content provider desiring to host media files for streaming. For example, a significant amount of preprocessing is required to prepare media for streaming. Media content may be encoded into several different files to accommodate several different sub-streams. Each of these files typically are chunked, stored, and indexed before the media content is available for streaming. Where encryption is required, the chunks are additionally encrypted before they are stored. Such preprocessing leaves little flexibility for changing encryption keys.","Systems and methods for encrypting a media file for streaming over a network are disclosed. These systems and methods may be part of a larger media servicing network that can be used to, among other things, process uploaded media content, provide it for streaming, and collect metric information regarding the streaming. The disclosed systems and methods provide for receiving requests for a media file or a chunk of a media file and responding to these requests by encrypting the requested chunks dynamically and providing the chunks to the requesting entity. These systems and methods, which can be utilized with a dynamic chunk generation and dynamic index file generation, enable a high degree of flexibility in streaming chunked media files and preclude the need to encrypt the chunks prior to streaming.","An example method for providing a plurality of encrypted segments of a media file over a data network, according to the disclosure, includes receiving a request for a first segment of the media file and retrieving the first segment of the media file. The first segment of the media file can comprise media content for playback over a period of time. The method further includes determining a first encryption key and creating an encrypted first segment of the media file by encrypting the first segment of the media file using the first encryption key. The encrypting the first segment of the media file can occur after receiving the request for the first segment of the media file. The method further includes providing the encrypted first segment of the media file, receiving a request for a second segment of the media file, and retrieving the second segment of the media file. The second segment of the media file can comprise media content for playback over a period of time. The method also includes determining a second encryption key and creating an encrypted second segment of the media file by encrypting the second segment of the media file using the second encryption key. The encrypting the second segment of the media file can occur after receiving the request for the second segment of the media file. Finally, the method includes providing the encrypted second segment of the media file.","The example method for providing the plurality of encrypted segments of the media file over the data network also can include one or more of the following features. The second encryption key can be different than the first encryption key. The requests for the first and second segments of the media file can be received from a Media File Delivery Service Provider (MFDSP), which can be a media file delivery service provider, media streaming services provider, cloud data services provider, or other media file delivery services provider. The encrypted first and second segments of the media file can be provided to the MFDSP. The receiving the requests for the first and second segments of the media file and the providing the encrypted first and second segments of the media file can occur during playback of the media file by a device communicatively linked to the data network. The determining the first encryption key can comprise generating the first encryption key. The generating the first encryption key can comprise using an algorithm received over a communication link.","The example method for providing the plurality of encrypted segments of the media file over the data network also can include one or more of the following additional features. Providing a first decryption key for decrypting the encrypted first segment of the media file. Determining the first encryption key can comprise requesting, over a communication link, the first encryption key, and receiving, over the communication link, the first encryption key. Determining the second encryption key can comprise requesting, over the communication link, the second encryption key, and receiving, over the communication link, the second encryption key. Determining the first encryption key comprises retrieving the first encryption key from data storage.","An example a non-volatile computer-readable storage medium, according to the description, can have instructions embedded thereon, which, when executed by a processor, cause the processor to perform the method for providing the plurality of encrypted segments of the media file over the data network described above.","An example a server for communicating, via a network, a media file having a plurality of segments, according to the description, can include a network interface, a memory configured to store one or more of the plurality of segments, and a processor communicatively coupled with the memory and the network interface and configured to cause the server to receive, using the network interface, a request for a first segment of the media file and retrieve the first segment of the media file from the memory. The first segment of the media file can comprise media content for playback over a period of time. The processor also can be configured to cause the server to determine a first encryption key, and create an encrypted first segment of the media file by encrypting the first segment of the media file using the first encryption key. The encrypting the first segment of the media file can occur after receiving the request for the first segment of the media file. The processor also can be configured to cause the server to provide, using the network interface, the encrypted first segment of the media file, receive, using the network interface, a request for a second segment of the media file, and retrieve the second segment of the media file from the memory. The second segment of the media file can comprise media content for playback over a period of time. The processor also can be configured to cause the server to determine a second encryption key and create an encrypted second segment of the media file by encrypting the second segment of the media file using the second encryption key. The encrypting the second segment of the media file can occur after receiving the request for the second segment of the media file. Finally, the processor can be configured to cause the server to provide, using the network interface, the encrypted second segment of the media file.","The example server for communicating, via the network, the media file having the plurality of segments, can include one or more of the following features. The processor can be configured to cause the server to receive the requests for the first and second segments of the media file from a Media File Delivery Service Provider (MFDSP). The processor can be configured to cause the server to provide the encrypted first and second segments of the media file are to the MFDSP. The processor can be configured to cause the server to receive the requests for the first and second segments of the media file and provide the encrypted first and second segments of the media file during playback of the media file by a device communicatively linked to the network. Determining the first encryption key can comprise generating the first encryption key.","The example server for communicating, via the network, the media file having the plurality of segments, also can include one or more of the following additional features. The processor can be configured to cause the server to receive an algorithm via the network interface, and use the algorithm to generate the first encryption key. The processor can be configured to cause the server to determine the first encryption key by requesting, using the network interface, the first encryption key, and receiving, using the network interface, the first encryption key. The processor can be configured to cause the server to determine the second encryption key by requesting, using the network interface, the second encryption key, and receiving, using the network interface, the second encryption key. The processor can be configured to cause the server to determine the first encryption key by retrieving the first encryption key from the memory.","An example system for securely communicating, with a network, a media file, according to the disclosure, can include a data storage configured to store the media file, and a processing server communicatively coupled with the data storage. The processing server can be configured to receive a request for a first segment of the media file, retrieve at least a portion of the media file from the data storage, and generate the first segment of the media file. The first segment of the media file can comprise media content for playback over a period of time. The processing server also can be configured to determine a first encryption key and create an encrypted first segment of the media file by encrypting the first segment of the media file using the first encryption key. The encrypting the first segment of the media file can occur after the request for the first segment of the media file is received. Additionally, the processing server can be configured to provide the encrypted first segment of the media file, receive a request for a second segment of the media file, and generate the second segment of the media file. The second segment of the media file can comprise media content for playback over a period of time. The processing server further can be configured to determine a second encryption key and create an encrypted second segment of the media file by encrypting the second segment of the media file using the second encryption key. The encrypting the second segment of the media file can occur after receiving the request for the second segment of the media file. Finally, the processing server can be configured to provide the encrypted second segment of the media file.","The example system for securely communicating, with the network, the media file can include one or more of the following features. A media caching server configured to send the requests for the first and second segments of the media file, via the network, to the processing server, receive the encrypted first and second segments of the media file, via the network, from the processing server, and store the encrypted first and second segments of the media file in a memory. The media caching server can be further configured to provide the encrypted first and second segments of the media file to a device communicatively coupled with the media caching server. The media caching server can be configured such that the media caching server will not send the requests for a segment of the media file via the network to the processing server if the media caching server has the segment of the media file stored in the memory.","In the appended figures, similar components and\/or features may have the same reference label. Further, various components of the same type may be distinguished by following the reference label by a dash and a second label that distinguishes among the similar components. If only the first reference label is used in the specification, the description is applicable to any one of the similar components having the same first reference label irrespective of the second reference label.","The ensuing description provides preferred exemplary embodiment(s) only, and is not intended to limit the scope, applicability or configuration of the disclosure. Rather, the ensuing description of the preferred exemplary embodiment(s) will provide those skilled in the art with an enabling description for implementing a preferred exemplary embodiment. It is understood that various changes may be made in the function and arrangement of elements without departing from the spirit and scope as set forth in the appended claims.","The increased availability of media content over data communications networks such as the Internet has mirrored the increased bandwidth for these networks. Because media has recently taken a more prominent role in data communications, the distribution of media and the data associated with such distribution has become increasingly important, particularly to media content providers. Media streaming has become a widely-used method of media distribution, but the preprocessing associated with streaming can be burdensome. Certain protocols, including forms of Hypertext Transfer Protocol (HTTP) streaming, require chunking and storing the chunked media files, and generating a corresponding index file(s) (also known as a \u201cmanifest\u201d file). In a traditional approach, this can involve a large amount of preprocessing.","Preprocessing media for streaming traditionally involves chunking media files, storing the chunks, then creating corresponding index files to indicate where chunks may be located to download for streaming. Streaming protocols often provide for frequently updating an index file for instances where the corresponding media is frequently updated, such as during live streaming. Thus, an index file does not need to contain all chunks for a requested media file. In addition, because media files are frequently stored in a format that requires little additional processing to chunk, the chunks can be created in real time, during the streaming of a media file. The systems and methods disclosed in U.S. patent application Ser. No. 12\/976,883, entitled \u201cDYNAMIC CHINKING FOR MEDIA STREAMING,\u201d and U.S. patent application Ser. No. 12\/976,890, entitled \u201cDYNAMIC INDEXING FOR AD INSERTION IN MEDIA STREAMING,\u201d which are incorporated herein by reference, take advantage of these features to enable dynamic index file creation and dynamic media file chunking.","In instances where a media provider desires secure streaming, preprocessing traditionally involves encrypting chunks of a media file as well. Such preprocessing can result in a large amount of stored encrypted chunks that can prove burdensome to manage. For example, if a content provider of a media file desires to update or change the encryption key(s) used to encrypt the stored encrypted chunks corresponding to the media file, each chunk would either need to be decrypted and re-encrypted or replaced altogether with a new chunk, encrypted with the new encryption key.","In contrast, the techniques provided herein enable dynamic encryption that can allow a system to encrypt chunks of a media file in real time, as the chunks are requested by a client streaming the media file. Such functionality can provide flexibility to a content provider to provide the encryption key(s) used to encrypt a media file at any time, including while media file is streaming to a client. In other embodiments, another entity, such as the content distributor, can provide the encryption key(s). This dynamic encryption can be utilized in a variety of systems, including those that preprocess and store chunks of a media file, as well as those that can dynamically create the chunks. Moreover, techniques described herein are not limited to encrypting chunks of a media file, but also can be utilized to encrypt whole files as well as non-media files and\/or chunks of non-media files. Furthermore, the techniques described herein may also return a media file that has been dynamically stitched together from many chunks, which, to a client, can appear like a contagious file for continuous streaming protocols (Real Time Messaging Protocol (RTMP), Real Time Streaming Protocol (RTSP), etc.) as well as for progressive download.","The index file(s) utilized to access chunks of a media file (or whole files, in some embodiments) can vary in content and format, depending on protocols utilized by a media player application configured to play the streamed media file. For example, different index files can include information corresponding to a different number of chunks and\/or chunks of media having differing playback parameters (e.g., bit rate, resolution, frame rate, etc.). Despite the differences in format and content, the techniques described herein can be utilized to enable any number of clients, having different index file requirements, to utilize a single Uniform Resource Locator URL (URL), or other indicator, to retrieve the index file corresponding to a particular media file in a format suitable for that client. As a result, a media content provider can provide a single URL for each media file, regardless of the type of client and\/or platform requesting the media file.","Furthermore, when a client uses the URL to request a media file, an index file generator receiving the request can determine whether advertisements are to be played during the playback of the media file, and enable a content provider to select the advertisements to be played. Moreover, the content provider further can provide the index file generator with one or more beaconing URLs to insert into an index file, which can serve as beacons to indicate to the content provider that certain content, such as advertisements, is being and\/or has been played. A content provider can find the beaconing information to be vital in determining the value of the media.","The beaconing information may be used for various purposes. For example, it may be used to determine the state of a client (e.g., paused, skipping certain content, playing back certain content, etc.), which can be used in behavioral advertisement targeting and enforcement of session advertisement behavior, adjusting advertisement content and playback based on the behavior of a user. The state of a client also may be used to support individual encryption keys in an encryption scheme and allow the index file generator to return secure URLs (e.g., time expiring or Internet Protocol (IP) allowed) for chunks to support functions such as payment services.","While the above embodiments may be implemented in a variety of different systems, some particular embodiments may be implemented as part of a media service system.  is a block diagram illustrating a media servicing system , according to some embodiments of the present invention. The system may deliver media content to the end user device  through a network such as the Internet . The end user device  can be one of any number of devices configured to receive media over the Internet , such as a mobile phone, tablet computer, personal computer, portable media device, etc. A media file provided by a content provider  can be processed and indexed by cloud-hosted integrated multi-node pipelining system (CHIMPS) , and further stored a media file delivery services provider (MFDSP) . Additionally or alternatively, the CHIMPS  may also be adapted to store the media file.","The media servicing system further enables a content provider  or other entity to gather information regarding user behavior during media playback. For example, a content provider  can be provided with data indicating that end users tend to stop watching a video at a certain point in playback, or that users tended to follow links associated with certain advertisements displayed during playback. With this data, a content provider  can adjust factors such as media content, advertisement placement and content, etc., to increase revenue associated with the media content and provide the end user device  with a more desirable playback experience.","End user device  can request a media file to stream with a client program executed by the end user device . The client program can be, for example, a media player, browser, or other application adapted to request and\/or play media files. In response to a request for a media file, the CHIMPS  can utilize any number of application centers  and\/or kernel application center(s)  to provide the client program with a data object concerning the requested media file. The data object can include information about the media file, including where the media file can be located, such as within the MFDSP  or within the CHIMPS  itself. Location information may be provided by a URL or other indicator. During playback of the media file, the CHIMPS  can collect data regarding the playback through beaconing provided by a client program executed by the end user device  and\/or indexing service from within the CHIMPS and\/or MFDSP. The CHIMPS  can subsequently provide the data and\/or any analytics information derived from the data to the content provider . Additionally, as discussed below, the content provider  can provide additional beaconing URLs to an index file generator with which the content provider can determine whether particular content has been viewed.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2A","b":["111","1","110","1","111","1","112","120","140","112","111","1","112","110","1","270","112","111","1"]},"Components within the kernel application center - can communicate through network  such as a local area network (LAN) and can include one or more origin servers  and a storage array  with which data objects and\/or media files may be stored and distributed. The storage array  may also be utilized by services running on processing server(s)  and\/or transcoding server(s)  that may require temporary or long-term storage. Kernel server  can utilize processing server(s) , transcoding server(s)  to provide various functional capabilities to the CHIMPS .","For example, as described in more detail below, the CHIMPS - can provide transcoding service for media files provided by a content provider  for syndication. Such a service can allow a content provider  to upload a media file to an application center , after which the application center  would notify the kernel server  that the media file has been uploaded. The kernel server can then notify services running on the processing server(s)  of the upload. These services can utilize transcoding server(s) to transcode the media file, which can then be moved to a MFDSP and\/or stored locally by storage array  and origin server(s) . Services running on the processing server(s)  can also update the associated data object stored by the storage array  and origin server(s) .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 2B","FIG. 2A"],"b":["111","2","112","111","2","112","111","2","111","2","260","112","110","112","110"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":["112","112","330","310","360","330","310","360","320","130","370","310","111","112","340","350","350","310","111"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 4"],"b":["400","110"]},"Media can be ingested into the CHIMPS  when a content provider  uploads a media file to ingestion server(s)  in an application center  by utilizing a client . The client  can be a stand-alone application or browser based, for example, and can communicate with ingest server(s)  through an application programming interface (API) configured for the ingestion of media files.","Ingest server(s)  can communicate with devices in the kernel application center  executing programs such as kernel server  and file replication service . The kernel server  can be configured organize the workflow among services such as transcoding  file system manager , and other services  (e.g., analytics, dynamic API, etc.) Upon a particular event, for example, the kernel server can be configured to notify the relevant services of the event, causing the services to process tasks associated with the event.","The file replication service , under direction of the kernel server , can coordinate the movement of the media files between services. For example, retrieving the uploaded media file from the ingest server(s)  and storing it on the file archive , or retrieving transcoded media files from transcoding server(s)  and storing them in the media file origin.","The data object updater  keeps the data object origin  up to date in response to any changes in the system. When, for example, a file is uploaded, transcoded, and stored in media file origin , the location and other metadata concerning the transcoded media files need to be created or updated in the data object origin  to ensure an end user device that accesses the object in the data object origin  has the correct information regarding the related media file. Because the data object updater  receives updates from the kernel server  (which is notified when a transcoded media file is stored in the media file origin , the system ensures the data objects in the data object origin are constantly up to date.","The upload of a media file to the ingest server(s) , as described above, can provide an example of how the kernel server  may coordinate workflow. For instance, in response to the upload, the ingest server(s)  can notify the kernel server  that a media file has been uploaded. The kernel server  informs the file replication service  of the uploaded media file, and the file replication service  moves the uploaded media file into the file archive  and notifies the kernel server  of the move. In response, the kernel server  notifies the file replication service , the file system manager , and the transcoding master  of the move. The file replication service  then will know it can delete the uploaded media file from the ingest server(s) , the file system manager  will update the file system accordingly, and the transcoding master  will notify transcoding service(s)  of different transcoding tasks to be performed. The transcoding service(s)  can then retrieve the uploaded media file from the file archive  to create transcoded media files. The transcoding service(s)  notify the kernel server  once transcoding is complete, and the kernel server  relays this information to the file replication service . The file replication service  then takes the transcoded media files from the transcoding services  and moves them to the media file origin . Once the file replication service  notifies the kernel server  of the move, the kernel server , in turn, notifies the file replication service  and the data object updater . The data object updater  which updates the data object origin  accordingly, and the file replication service  deletes the transcoded media files from the transcoding services .","The modular nature of the system enables all tasks associated with an event to be completed quickly. As illustrated in the example above, workflow relating to a particular event, such as a media file upload, can be spread among the various services simultaneously. Moreover, because the system's modularity enables it to be scaled to accommodate differing hardware capacities, and because the system can be configured to dynamically allocate hardware to different services according to the needs of the system, the speed of completing tasks relating to a particular event can further be increased. For example, a server of the CHIMPS  can be configured to dynamically switch its purpose based on external conditions such as load and overall system performance, providing functions such as transcode, upload, metrics collection, application web service, and more, on an as-needed basis.","Embodiments of such systems may include other systems that manage various requests from end users. For example, a system for providing an appropriate index file to any of a variety of clients utilizing a single URL. Referring to , an embodiment of such a system  is shown. Media may be streamed to end user device  though a client . As mentioned above, the client  can be stand-alone media player, a plug-in, a browser, or other application, which can be executed on a personal computer or other electronic device.","An index file (i.e. manifest file) generator  can be a program instantiated for media streaming to a particular client . The index file generator  can be executed on a server or other computing device within an application center  of the CHIMPS . Index files generated by the index file generator can include a wide variety of information such as starting, ending, and or run times for media chunks and locations for media chunks. This information can be embedded in a single string of data, such as a URL or other type of URI. If media includes various sub-streams (e.g., streams with alternative bitrates, captions, alternative languages, etc.) the index file can include data for chunks corresponding to each of the alternative sub-streams, as well as information regarding the bitrate and\/or other unique information for each stream. Alternatively or in addition, index files indicating alternative sub-streams may be separate from index files indicating one or more media chunks for streaming.","It should be understood that the index file can further comprise a wide variety of formats, which can depend on a particular streaming protocol utilized by the client . HTTP streaming may, for example, require index files to comprise one or more of M3U, M3U8, XML, and XML-based formats. Of course, other formats can be used in accordance with relevant streaming protocols.","The index file generator  can determine the relevant streaming protocol from information included in a request sent from the client  to stream a media file. For example, a client  can utilize a URL, obtained from a content provider  or other entity to stream a particular media file, to request the media file from the index file generator . In addition to the URL, the request can included information regarding the identification of the client  (or \u201cclient ID\u201d; e.g., a user agent identification in a request header) that the index file generator  can use to determine the proper format and content of an index file for the client .","A proper format and content of an index file can be determined in numerous ways. For example, the index file generator  itself may recognize the type of client from the client ID and determine a proper index file type accordingly. The index file generator , therefore, may include information regarding common client IDs and\/or special use cases for which particular index file types are used. This information can be updated periodically, and\/or as index file types are determined for different client IDs.","Alternatively, the index file generator  can access a client information database(s)  to determine the proper index file type. Such a database(s) can be located within the CHIMPS  (shown) and\/or external to the CHIMPS  (not shown), depending on desired functionality. One example of an external client information database(s)  is the Wireless Universal Resource FiLe (WURFL), a device description repository maintained by ScientiaMobile, Inc. The proper index file type can be determined by identifying a index file type known to work for a particular client ID or matching a client ID to an index file type based on a profile of capabilities associated with the client ID.","If a proper index file type cannot be determined, the index file generator  can provide an index file of a default index file type. The default index file type can include information for streaming the requested media file using a basic media stream compatible with virtually any media client. For example, parameters associated with a basic video stream could include a resolution of 160\u00d7120, a 3GP (Third Generation Partnership Project file format) multimedia container format, and\/or a streaming bit rate of 100 kilobits per second (kbps).","The index file generator  further can utilize a file information database  in the creation of an index file. The file information database  can provide information regarding the requested media file (e.g., length, genre, author, etc.) as well as information regarding whether any advertisements are to be shown during the playback of the requested media file. If advertisements are to be shown during the playback of the requested media file, the database further can provide points at which advertisements are to be played during playback of the media file by the client.","An advertisement server , which can be maintained by a content provider , can provide the index file generator  with additional information regarding advertisements to be shown during the playback of the requested media file. For example, the index file generator  can determine, using information from the file information database , that three video advertisements are to be shown at certain points during the playback of a particular video file. The index file generator  then can request information from the advertisement server  regarding which advertisements to show. (This can be in the form of three different requests, or a single request, depending on the desired functionality of the system.) Moreover, the index file generator  can use the forwarded IP address and forwarded user agent of the client to identify the client, thereby allowing the content provider  to provide customized advertisements for the client. The advertisement server  can specify the advertisements to show (if an advertisements have been previously uploaded to the CHIMPS, and the index file generator can receive metadata regarding the advertisements from the file information database . Alternatively, the advertisements may be uploaded to and chunked by the CHIMPS  after the index file generator  requests the information from the advertisement server  regarding which advertisements to show In this latter case, metadata regarding the advertisements would also be extracted and used in the creating of the index file. Regardless of when the advertisements are uploaded to the CHIMPS , the advertisement server  enables a content provider  to traffic new advertisements into the playback of a media file shortly before the index file is generated, which can occur shortly before or even during the playback of a media file.","In addition to providing information regarding advertisement content, the advertisement server  can designate certain URLs in the index file for beaconing. These beaconing URLs can be similar to normal URLs of an index file, but with additional information attached, designating it as a providing a \u201cbeacon\u201d to report back to the content provider . The content provider can use these beacons to determine, among other things, if a particular advertisement is played. For example, a beaconing URL can be a redirect URL included in a request for a first chunk of an advertisement. The request, which initially is directed to an API server of the CHIMPS , is interpreted as a beacon by the API server and added to a list of items for which the API server requests of the advertisement server  (or other system of the content provider ). The beacon itself can be, for example, a getRequestURL( ) or similar request that the advertisement server  can use to determine that a particular URL was made. The API server can use the forwarded IP address and forwarded user agent of the client to help ensure that the content provider  can correctly determine that a beacon corresponds with a request from a particular client . The API server also can redirect the client to a particular media file delivery service provider (MFDSP) (or other system hosting the requested chunk) to receive the requested chunk. In alternative embodiments, the content provider  can provide additional beaconing URLs that can be used to provide beaconing information regarding the playback of the media file itself. Through the use of such beaconing URLs, the content provider  to is able to provide its own beaconing data in addition or as an alternative to any beaconing data gathered by the CHIMPS .","The index file generator  then uses the information regarding the client ID, the requested media file, the advertisement(s) to be shown during playback of the media file, and the points of the media file at which the advertisement(s) are to be played, to create an index file of the right index file type to return to the client . As indicated above, the index file can include, among other things, a number of URLs indicating the location of each chunk of the media file to be played by the client , as well as chunks of the advertisement(s). The chunks of the advertisement(s) are included in an manner such that they are shown at a point(s) during the playback of the media file corresponding to the points designated by the file information database . Additionally, the index file can include one or more beaconing URLs which, when used, can be indicative of the playback of an advertisement as discussed above.","The URLs provided by an index file additionally can direct a client  to additional index files. For example, under certain adaptive bit rate streaming protocols, a first index file typically can include a number of URLs to additional index files, where each additional index file corresponds to a particular bit rate for streaming. The client  then can choose a bit rate based on one or more factors such as connection speed, device type, etc. Other streaming rates (bytes, etc.) may be used additionally or alternatively.","To this end, the index file generator  can be configured to create an index file that provides the client  with a particular set of bit rates adapted to the client's circumstances. The client's circumstances not only can include the type of end user device  (also referred to herein as \u201cdevice type\u201d) on which the client is running, but also the type of network to which the device is connected, among other things. These circumstances may be determined from a request header provided by the client along with a URL, and\/or they may be determined utilizing other data obtained from and\/or regarding the client . (The index file generator , for example, can determine that the Autonomous System (AS) number of a particular client's IP address is associated with a provider of a mobile wireless network.) Because the set of bit rates provided in the index file provides a customized selection for the client , the resulting playback can be optimized to provide the best user experience.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Bit Rates for Certain Device\/Network Types"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Device\/Network Type"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Smart Phone\/",{},"Tablet\/",{}]},{"entry":[{},"Mobile","Smart Phone\/","Mobile","Tablet\/"]},{"entry":[{},"Wireless","Wired","Wireless","Wireless"]},{"entry":[{},"Network","Network","Network","Network"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Stream-","1200",{},{},"X","X"]},{"entry":["ing","800",{},{},"(X)","X"]},{"entry":["Bit","600","X","(X)","X","(X)"]},{"entry":["Rate","400","(X)","X",{},"X"]},{"entry":["(kbps)","200","X","X",{},"X"]},{"entry":[{},"100","X","X",{},"X"]},{"entry":[{},"64","X","X","X","X"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"Table 1, provided merely as an example, illustrates the different sets of streaming bit rates an index file can make available to a client, based on the device type and the network type. Not only can the index file include a selection of available bitrates, indicated by \u201cX\u201d, but the index file further can designate an initial bit rate, indicated by \u201c(X)\u201d, for the client . The client can then choose to steam the media file using the initial bit rate designated by the index file, or it may choose to stream the media file using one of the other bit rates provided in the index file. Alternatively, if the client  does not utilize an adaptive bit rate protocol, the index file generator can provide an index file of a single bit rate, where the single bit rate can be determined based on device type, network type, etc.","For example, an index file for a smart phone connected to a mobile wireless network (e.g., a wireless carrier for mobile phones and other wireless devices) can provide URLs for streaming a requested media file at 600, 400, 200, 100, and 64 kbps, where 400 kbps is designated as the initial rate at which the client can begin streaming the media file. However, if a smart phone is connected with a wired network (e.g., a cable or DSL internet connection), including a wireless local area network (LAN) connected to the internet through a wired network, the index file may provide the same set of URLs for streaming the requested media file, but designate a higher initial bit rate at which the client can begin streaming the media file. On the other hand, because a tablet computer may have a monitor capable of displaying higher-quality resolutions associated with a higher bit rate, the index file can provide a tablet computer with different sets of bit rates and different starting bit rate designations, including higher bit rates, that are not included in an index file provided to a client  running on a smart phone.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 6A","FIG. 5"],"b":["600","1","510","530","600","1","610"]},"At block , the device type and\/or network type is determined. As discussed above, the request can include a header with client ID information. The client ID information can be indicative of a particular device type, including the type of physical device, as well as the type of operating system and\/or client the physical device is running Determining the device type can include using one or more databases and\/or resorting to a default device type if a particular device type is not identified. As discussed above, the network type can be determined, for example, from the AS number of the client's IP address, which can be associated with a particular network provider (e.g., wireless mobile network provider, wired network provider, etc.).","At block , metadata regarding the requested media file is retrieved. The metadata, which can be stored on one or more databases in the CHIMPS , for example, can include information regarding the media file such as length, title, author, etc. Additionally, at block , advertisement support can be determined. Information regarding advertisement support, which also can be stored on one or more databases, can include whether advertisements can be included in the playback of a media file, and if so, at what points during the playback of the media file.","At block , if the media file includes advertisement support, the advertisement(s) to include in the playback of the media file are determined. As discussed previously, determining the advertisement(s) to include can comprise communicating with a content provider  (or other entity), who can indicate the advertisement(s) to include. The advertisement(s) (which can be files with a video and\/or audio) may be uploaded beforehand to a MFDSP , server, or other delivery system, or they may be uploaded by the content provider  (or other entity) after the request for the media file is received. The advertisement(s) further may be chunked beforehand, dynamically chunked once requested, comprise complete file(s), or may be already included as part of a permutation of a media file.","At block  metadata regarding the advertisement(s) is retrieved. Similar to the metadata for the media file, the metadata for the advertisement(s) can include length, title, etc., which can be used in creating the index file. At block , the index file is created using the metadata of the media file and advertisement(s) as well as information regarding the device type, which can impact the format and\/or content of the index file. Finally, at block , the index file is returned.","The method - can be executed with every time a media file is requested. Even though a single URL can correspond with a single media file, the content of the index file returned at block  may be different. Depending on the type of client (e.g., client ID) and\/or type of network and the advertisements to be included in the playback, among other things, the index file can vary to conform to different formats, include different available streaming bit rates, include information regarding different advertisements, and more. Thus, despite the fact that a content provider  can provide a single URL to correspond to a particular media file, the streaming experience can be tailored to a particular client .",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 6B","FIG. 6A"],"b":["600","2","510","600","1","600","2","620","635"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 6C","FIGS. 6A-6B"],"b":["600","3","510","600","1","600","2","600","3","637","642","510","600","3","642","625"]},"Dynamic generation of chunks and\/or entire media files may or may not involve transcoding. The media file can be stored in a format where transcoding may not be needed, thereby reducing the processing requirements for creating chunks of media during streaming. For example, media files may be stored such as H.264 or MPEG-4 video format and\/or AAC, HE-AAC, or MP3 audio format. According to some streaming protocols, such as some forms of HTTP streaming, chunks of media in these formats would not need transcoding before being wrapped in an MPEG-2 transport stream container format. Instead, such a conversion essentially would require the addition of metadata to create the streaming format from the format of the stored media file. In other words, generating a deliverable chunk of media may only require identifying the stored media file, extracting the relevant segment of the media from the media file, and adding certain metadata in accordance with a container format. This process requires little processing power and can be easily performed on the fly during streaming. More details regarding this process can be found in U.S. patent application Ser. No. 13\/092,299, entitled \u201cTRANSCODELESS ON-THE-FLY AD INSERTION,\u201d which is incorporated herein in its entirety. Once the deliverable chunk of media is generated, it can be encrypted according to the techniques described herein.","Where an index file is used, the client can stream the requested media file by using the URLs designated in the index file to download the chunks from a content delivery service. , shows an embodiment of a system - for delivering content, including media files, which can be chunked and\/or encrypted. The client  and index file generator  are also illustrated for reference.","In this system -, chunks of media can be generated during media streaming by a dynamic segmentor, which of a dynamic permutation layer (DPL)  providing an HTTP service. The DPL , as well as the media file origin  can be located within a kernel application center  of the CHIMPS  on, for example, a media file origin server. The system - can be configured such that the kernel application center  provides dynamically-created chunks of media to a MFDSP  for delivery to client . The MFDSP  can store the chunks locally in, for example, a media file cache , thereby forgoing the need to dynamically create a chunk again if the same chunk is requested in the future.","After a chunk is dynamically created, if encryption is desired, the DPL  also can encrypt the chunk using an encryption key. The encryption key can be, for example, a private key of an asymmetric encryption scheme. Because the overhead of encrypting a chunk of a media file is relatively small, the DPL  can encrypt the chunks in real time, as the client  is streaming the media file (i.e., as the chunks are being requested). Such a scheme can be implemented in numerous ways.","In one embodiment, the DPL  can request a private key through an Application Programming Interface (API) server  of the content provider . The API server  can return the requested encryption key to the DPL  via a secure communication link , which can be encrypted and\/or otherwise secured to help ensure the security of the encryption key is not compromised. The DPL  can then use the encryption key to encrypt one or more chunks of a media file, returning the encrypted chunk(s) to the MFDSP  for delivery to the client . The client can obtain the corresponding decryption key (e.g., public key) from the content provider , the CHIMPS , or other source.","The functionality provided by this system - enables the content provider  to control encryption of chunks of media. Depending on the desired encryption scheme, the DPL  can request a new encryption key\u2014which is provided by the API server \u2014for each chunk of a media file. Additionally or alternatively, the DPL  can request a new encryption key less frequently, such as with each media file and\/or group of media files. Moreover, changing an encryption key may be time based, such that the DPL  requests a new encryption key every minute, hour, day, etc. In addition, or as an alternative, the API server  may provide a new encryption key to the DPL  without a request from the DPL .","In another embodiment, the DPL  can generate an encryption key. In this embodiment, the DPL  can utilize an algorithm provided by the API server  via the secure communication link . The API server  and DPL  can run the algorithm in synchronization to generate identical encryption\/decryption keys, such that the encryption key does not need to be communicated between the API server  and the DPL . Moreover, the API server  can provide an algorithm in each response to the DPL's requests, thereby allowing the DPL  to generate the encryption key without the need to store an algorithm or otherwise have access to the algorithm beforehand. Alternatively, the DPL  can store a variety of algorithms for encryption key generation, and the API server  could indicate an algorithm to use in response to an algorithm request from the DPL . Such functionality can give the allow content provider  control of encryption keys and\/or encryption key generation.","Alternatively, the DPL  can simply generate the encryption key (which can be generated for each chunk, media file, etc., or may be time based, as discussed above). In this case, the DPL  can provide the encryption key to the API server , or retain the encryption key without sharing it, depending on the desired functionality.","In sum, the system - for indexing and encrypting dynamically-created chunks of a media file can, after receiving a request for an index file from a client , dynamically generate an index file with an index file generator . The index file can, among other things, indicate where a next chunk of a media file may be located. A client can then request the chunk from the location indicated by the index file, which can comprise a media file cache  in a MFDSP . If the chunk is not found in the media file cache , or if the chunk is encrypted with an outdated encryption key, the cache miss can redirect the request to a DPL , which can dynamically generate the requested chunk by accessing the corresponding media file in the media file origin . The DPL  determines an encryption key (e.g., by generating the encryption key, receiving it from the API server, etc.) and creates an encrypted chunk by encrypting the requested chunk with the encryption key. The encrypted chunk then can be provided to the MFDSP  for storage in the media file cache  and delivery to the client . If the same chunk is requested at a later point in time (and the chunk is not encrypted with an outdated encryption key) the MFDSP  can deliver the chunk from the media file cache , thereby forgoing the need to redirect the request to the DPL  to regenerate the chunk.","The determination of whether an encrypted chunk in the media file cache  of the MFDSP  has an outdated encryption key can be made in a variety of ways. For example, the DPL , upon receiving and\/or generating the encryption key, can notify the MFDSP  of the update so that the MFDSP  can delete and\/or overwrite any affected files. Alternatively, the DPL  can inform the index file generator  of an update in the encryption key. The index file generator  can adjust index files accordingly, indicating, for example, an encryption key version number in a URL of the index file. If the MFDSP  cannot match the URL to any cashed location in the media file cache , it will request an updated chunk from the DPL . Other techniques for indicating expired encryption keys, and other methods of encryption (e.g., RSA, symmetric key, etc.) also are contemplated.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 7B","b":["700","2","700","2","770","112","110","770","510","770","110","110"]},{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 8","b":["800","510","811","811","840","730","130","855","510","840","855","730","840"]},"The embodiment  shown in  is provided as an example and is not limiting. As with other illustrations provided herein, the embodiment  can be altered in numerous ways without departing from the spirit and scope of this disclosure. For example, the media chunks may be stored at a location and\/or system remote from the media server . Moreover, encrypted chunks may be cached by one or more caching server(s) that may be communicatively linked between the client  and the chunk encrypter . Other such variations are contemplated.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 9A","b":["900","1","740","840","900","1","910","150","770","510","140","915"]},"At block , an encryption key is requested from a content provider , and at block  the encryption key is received from the content provider . Because this exchange involves an encryption key, it can be done over a secure communication link, as discussed above. Moreover, the request for the encryption key from the content provider may be sent prior to, or in conjunction with, the retrieval of the requested chunk. Such timing may increase efficiency by reducing the overall time it takes to execute the method - of . Although the term \u201ccontent provider\u201d is used in the method - and in other figures provided herein, other entities can be used as an encryption key source. After the encryption key is received, the requested chunk is encrypted at block  and returned at block .",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 9B","FIG. 9A"],"b":["900","2","900","1","910","900","2","130","917","918","922","900","2","130","130"]},{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 9C","FIG. 9B","FIGS. 9A and 9B"],"b":["900","3","900","2","923","130","924","900","1","900","2","130","130"]},{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIGS. 9A-9C","b":"700"},{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 10","b":["1005","150","1010","150","150"]},"Blocks  and  help determine whether the MFDSP  can return the encrypted chunk corresponding to the requested chunk without a call to the DPL . At block , the MFDSP  determines whether the requested chunk is in cache. If not, the process moves to block , where the MFDSP  requests the chunk from the DPL .","Otherwise, if the chunk is cached at the MFDSP , the process moves to block  where the MFDSP  determines whether the encryption of the chunk is current. As discussed above, such a determination can be made in several ways. For example, an encryption version can be embedded in the URL, the MFDSP  can be notified by the DPL  of a change in the encryption key, etc. If the encryption is current, the MFDSP  can simply return the encrypted chunk, at block . Otherwise, the MFDSP  requests the chunk from the DPL  at block .","At block , the DPL  receives the request for the chunk, and at block  retrieves the chunk. As discussed previously, certain embodiments can allow for the chunk to be created dynamically by the DPL . Otherwise, the DPL  (or other system configured to encrypt chunks) can retrieve the chunk from storage. Before the chunk is encrypted, the encryption key must be obtained. Thus, at block , the DPL  requests the encryption key.","At block , the API server (which can be hosted by the content provider of the media file corresponding to the chunk, or other entity) receives the DPL's request for an encryption key. The API server then generates or otherwise obtains the encryption key, at block . The encryption key can be, for example, stored in memory and used for multiple requests, rotated on a time and\/or file basis, etc. Alternatively, a new key can be generated for each request received by the DPL . In any case, the encryption key is returned to the DPL  at block .","The DPL  receives the encryption key from the API server at block . With the encryption key, the DPL  encrypts the chunk, at block . The encrypted chunk is then returned to the MFDSP  at block .","At block , the MFDSP  receives the encrypted chunk from the DPL . The MFDSP  then can cache the encrypted chunk at block , thereby enabling the MFDSP  to provide it to clients who request the chunk in the future (provided, of course, that the encryption is current at the time of the future client requests). At block , the MFDSP  returns the encrypted chunk to the client, which is received at block . The client  can decrypt the encrypted chunk by utilizing a corresponding decryption key, which, in asymmetric encryption, can be provided by the API server  (or another system of the content provider) in a variety of ways.","It should be noted that the methods, systems, and devices discussed above are intended merely to be examples. It must be stressed that various embodiments may omit, substitute, or add various procedures or components as appropriate. For instance, it should be appreciated that, in alternative embodiments, the methods may be performed in an order different from that described, and that various steps may be added, omitted, or combined. Also, features described with respect to certain embodiments may be combined in various other embodiments. Different aspects and elements of the embodiments may be combined in a similar manner. Also, it should be emphasized that technology evolves and, thus, many of the elements are examples and should not be interpreted to limit the scope of the invention.","Specific details are given in the description to provide a thorough understanding of the embodiments. However, it will be understood by one of ordinary skill in the art that the embodiments may be practiced without these specific details. For example, well-known circuits, processes, algorithms, structures, and techniques have been shown without unnecessary detail in order to avoid obscuring the embodiments. This description provides example embodiments only, and is not intended to limit the scope, applicability, or configuration of the invention. Rather, the preceding description of the embodiments will provide those skilled in the art with an enabling description for implementing embodiments of the invention. Various changes may be made in the function and arrangement of elements without departing from the spirit and scope of the invention.","Also, it is noted that the embodiments may be described as a process which is depicted as a flow diagram or block diagram. Although each may describe the operations as a sequential process, many of the operations can be performed in parallel or concurrently. In addition, the order of the operations may be rearranged. A process may have additional steps not included in the figure. Furthermore, embodiments of the methods may be implemented by hardware, software, firmware, middleware, microcode, hardware description languages, or any combination thereof. When implemented in software, firmware, middleware, or microcode, the program code or code segments to perform the necessary tasks may be stored in a non-volatile computer-readable medium such as a storage medium. Processors may perform the necessary tasks.","Having described several embodiments, it will be recognized by those of skill in the art that various modifications, alternative constructions, and equivalents may be used without departing from the spirit of the invention. For example, the above elements may merely be a component of a larger system, wherein other rules may take precedence over or otherwise modify the application of the invention. Also, a number of steps may be undertaken before, during, or after the above elements are considered. Accordingly, the above description should not be taken as limiting the scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present disclosure is described in conjunction with the appended figures:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6A","b":"510"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6B","b":"510"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6C","b":"510"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 9C"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
