---
title: Multi-level buffer pool extensions
abstract: A buffer manager that manages blocks of memory amongst multiple levels of buffer pools. For instance, there may be a first level buffer pool for blocks in first level memory, and a second level buffer pool for blocks in second level memory. The first level buffer pool evicts blocks to the second level buffer pool if the blocks are not used above a first threshold level. The second level buffer pool evicts blocks to a yet lower level if they have not used above a second threshold level. The first level memory may be dynamic random access memory, whereas the second level memory may be storage class memory, such as a solid state disk. By using such a storage class memory, the working block set of the buffer manager may be increased without resorting to lower efficiency random block access from yet lower level memory such as disk.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09235531&OS=09235531&RS=09235531
owner: Microsoft Technology Licensing, LLC
number: 09235531
owner_city: Redmond
owner_country: US
publication_date: 20111128
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit under 35 U.S.C. 119 to U.S. provisional patent application Ser. No. 61\/497,420 filed Jun. 15, 2011, which provisional patent application is incorporated herein by reference in its entirety. This application is a continuation-in-part of U.S. patent application Ser. No. 12\/717,139 filed Mar. 4, 2010, which is also incorporated herein by reference in its entirety.","Applications often use volatile memory to operate efficiently. During operation, data is read from mechanical disk into memory and potentially also written back to mechanical disk in discretely sized components called \u201cpages\u201d. A buffer pool is memory used to cache blocks of memory (such as pages) as the blocks are being read from mechanical disk, or being modified in memory. The buffer pool improves performance by allowing data to be accessed from memory instead of from mechanical disk. As an example only, databases often use buffer pools in order to manage and index pages in memory.","As a system operates, the system will randomly access a working set of pages. Over time, as the system operates, that working page set will change, which often also leads to a change in size of the working page set. If the working page set is larger than the available buffer pool in the random access memory (RAM), then the system performs more random access operations from mechanical disk.","A mechanical disk is structured with a mechanical rotational magnetic media in which a disk head sweeps a magnetic platter to read and access data. Sequential read\/writes are more efficient because they do not involve a mechanical sweep of the disk head, but merely involves the electronic transmission delay from the disk head and controller circuitry to memory. Thus, mechanical disk operations are much more efficiently used for sequential operations, while random access operations to mechanical disk can significantly reduce system performance. Thus, as the working page set becomes larger than the buffer pool, system performance degrades.","At least one embodiment described herein relates to an environment that includes a buffer manager that manages blocks of memory amongst multiple levels of buffer pools. For instance, there may be a first level buffer pool for blocks in first level memory, and a second level buffer pool for blocks in second level memory. The first level buffer pool evicts blocks to the second level buffer pool if the blocks are not used above a first threshold level. The second level buffer pool evicts blocks to a yet lower level if they have not used above a second threshold level.","In one embodiment, the first level memory is dynamic random access memory, whereas the second level memory is storage class memory, which includes, but is not limited to, a solid state disk. By using such a storage class memory, the working block set of the buffer manager may be increased without resorting to block access from yet lower level memory (such as disk), which may involve lower efficiency random access operations.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","In accordance with embodiments described herein, a buffer manager that manages blocks of memory amongst multiple levels of buffer pools is described. For instance, there may be a first level buffer pool for blocks in first level memory, and a second level buffer pool for blocks in second level memory. The first level buffer pool evicts blocks to the second level buffer pool if the blocks are not used above a first threshold level. The second level buffer pool evicts blocks to a yet lower level if they have not used above a second threshold level. In the case of more than two levels in the buffer pool, this lower level may be yet another level in the buffer pool.","In one specific example of a two level buffer pool, the first level memory may be dynamic random access memory, whereas the second level memory may be storage class memory, such as a solid state disk. By using such a storage class memory, the working block set of the buffer manager may be increased without resorting to lower efficiency random block access from yet lower level memory such as disk. First, some introductory discussion regarding computing systems will be described with respect to . Then, the embodiments of the buffer pool extensions and their operation will be described with respect to .","Computing systems are now increasingly taking a wide variety of forms. Computing systems may, for example, be handheld devices, appliances, laptop computers, desktop computers, mainframes, distributed computing systems, or even devices that have not conventionally been considered a computing system. In this description and in the claims, the term \u201ccomputing system\u201d is defined broadly as including any device or system (or combination thereof) that includes at least one physical and tangible processor, and a physical and tangible memory capable of having thereon computer-executable instructions that may be executed by the processor. The memory may take any form and may depend on the nature and form of the computing system. A computing system may be distributed over a network environment and may include multiple constituent computing systems.","As illustrated in , in its most basic configuration, a computing system  typically includes at least one processing unit  and memory . The memory  may be physical system memory, which may be volatile, non-volatile, or some combination of the two. The term \u201cmemory\u201d may also be used herein to refer to non-volatile mass storage such as physical storage media. If the computing system is distributed, the processing, memory and\/or storage capability may be distributed as well. As used herein, the term \u201cmodule\u201d or \u201ccomponent\u201d can refer to software objects or routines that execute on the computing system. The different components, modules, engines, and services described herein may be implemented as objects or processes that execute on the computing system (e.g., as separate threads).","In the description that follows, embodiments are described with reference to acts that are performed by one or more computing systems. If such acts are implemented in software, one or more processors of the associated computing system that performs the act direct the operation of the computing system in response to having executed computer-executable instructions. An example of such an operation involves the manipulation of data. The computer-executable instructions (and the manipulated data) may be stored in the memory  of the computing system . Computing system  may also contain communication channels  that allow the computing system  to communicate with other message processors over, for example, network .","Embodiments described herein may comprise or utilize a special purpose or general-purpose computer including computer hardware, such as, for example, one or more processors and system memory, as discussed in greater detail below. Embodiments described herein also include physical and other computer-readable media for carrying or storing computer-executable instructions and\/or data structures. Such computer-readable media can be any available media that can be accessed by a general purpose or special purpose computer system. Computer-readable media that store computer-executable instructions are physical storage media. Computer-readable media that carry computer-executable instructions are transmission media. Thus, by way of example, and not limitation, embodiments of the invention can comprise at least two distinctly different kinds of computer-readable media: computer storage media and transmission media.","Computer storage media includes RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store desired program code means in the form of computer-executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. For instance, such media may include Solid State Disks (SSDs) or Storage Class Memory (SCM), discussed further below in detail. In this description and in the claims, a \u201ccomputer program product\u201d includes one or more computer storage media having computer-executable instructions thereon that, when executed by the one or more processors of the computing system, perform the function of the computer program product.","A \u201cnetwork\u201d is defined as one or more data links that enable the transport of electronic data between computer systems and\/or modules and\/or other electronic devices. When information is transferred or provided over a network or another communications connection (either hardwired, wireless, or a combination of hardwired or wireless) to a computer, the computer properly views the connection as a transmission medium. Transmissions media can include a network and\/or data links which can be used to carry desired program code means in the form of computer-executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. Combinations of the above should also be included within the scope of computer-readable media.","Further, upon reaching various computer system components, program code means in the form of computer-executable instructions or data structures can be transferred automatically from transmission media to computer storage media (or vice versa). For example, computer-executable instructions or data structures received over a network or data link can be buffered in RAM within a network interface module (e.g., a \u201cNIC\u201d), and then eventually transferred to computer system RAM and\/or to less volatile computer storage media at a computer system. Thus, it should be understood that computer storage media can be included in computer system components that also (or even primarily) utilize transmission media.","Computer-executable instructions comprise, for example, instructions and data which, when executed at a processor, cause a general purpose computer, special purpose computer, or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be, for example, binaries, intermediate format instructions such as assembly language, or even source code. Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the described features or acts described above. Rather, the described features and acts are disclosed as example forms of implementing the claims.","Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations, including, personal computers, desktop computers, laptop computers, message processors, hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, mobile telephones, PDAs, pagers, routers, switches, and the like. The invention may also be practiced in distributed system environments where local and remote computer systems, which are linked (either by hardwired data links, wireless data links, or by a combination of hardwired and wireless data links) through a network, both perform tasks. In a distributed system environment, program modules may be located in both local and remote memory storage devices.","In accordance with embodiments described herein, the buffer pool size is augmented by using multiple memory levels of memory hierarchy. The lower the level of memory hierarchy, the faster the average access speeds. For instance, first level memory will have a faster average access speed than the second level memory. In accordance with one embodiment described herein with respect to , the buffer pool is extended to use a second level memory. However, the principles described herein may be extended to buffer pools having more than two memory levels also. In the embodiment described with respect to , the first level memory may be, for example, dynamic random access memory, and the second level memory may be, for example, Storage Class Memory (SCM), although the principles described herein are not limited to such examples. The second level memory may be persistent memory, although it may also be volatile memory, without departing from the principles described herein.","The term \u201cSCM\u201d is known in the art, and this description incorporates the known definition of the term. An SCM has the following properties.","1. The memory is solid state;","2. The memory is randomly accessible;","3. The memory has lower latency than mechanical disk;","4. The memory has random I\/O throughput greater than mechanical disk.","An SCM may also optionally have the characteristic that it is non-volatile, although not required.","A Solid State Disk (SSD) is distinct from a mechanical disk as SSDs are solid state devices. The SSD additionally has the following properties which may also be included in some, but perhaps not all, of other types of SCMs that may be used with the principles described herein:","1. High granularity random access.","2. Larger capacities than DRAM (capacity is in the order of that magnetic disk).","3. Higher transistor densities than DRAM (more store per unit of area and volume).","4. Lower power consumption and dissipation than spinning media and DRAM.","5. Typically no Direct Memory Access between the SSD and disk. Instead, the data has to flow through DRAM to get to disk.","Other types of SCMs include Phase Change Memory (PCM), Ferrous Oxide, and Memristor, which potentially have lower latencies and better access granularities than SSD. However, the principles described herein are not even limited to currently existing SCM technology, and may be extended to apply to SCM technology developed in the future or to any second level memory other than SCM also. Regardless, some embodiments described herein take advantage of these SCMs properties. Although SSDs are occasionally discussed herein as an example of SCMs, such examples should not be construed, by any means whatsoever, as limiting the principles of the present invention to a single type of SCM. As the term is used herein, an SCM may encompass one or more Storage Class Memory devices. The SCM may be located locally, or perhaps even remotely in which case the storage is accessed over a network link. Stated more generally, any storage with any connection can be used at level N (where N is an integer) if its random access latency and\/or bandwidth are better than that at level N+1.","In accordance with the principles described herein, a buffer pool manager allocates blocks of memory (hereinafter simply called \u201cblocks\u201d) to at least two levels of memory depending on the pattern with which the block is accessed. As previously mentioned, an example of a block is a \u201cpage\u201d, although the principles described herein are not limited to that. A \u201cpage\u201d is a block unit of memory stored in the buffer pool cache, and represents the unit of memory that is transferred in and out of the cache. For instance, more frequently accessed blocks may be allocated to the first level memory, whereas blocks that are accessed with lesser frequency are allocated to the second level memory, and blocks that have even lower frequency of access are perhaps not allocated within the buffer pool at all.","As used herein, \u201chot blocks\u201d, \u201cwarm blocks\u201d and \u201ccold blocks\u201d are terms used to describe blocks in terms of how frequently the blocks are accessed by the system, with higher temperature references implying more frequent access. Thus, hot blocks are accessed by the system more frequently than warm blocks, and warm blocks are accessed by the system more frequently than cold blocks. As operational needs change, the frequency of access for a given block may also change. Thus, a hot block may later become warm or cold, a warm block may later become hot or cold and a cold block may later become warm or hot. The principles described herein are not limited to the manner in which blocks are determined to be hot, warm, or cold, nor to the threshold between hot and warm, or between warm and cold. In some embodiments, the next-to-last access time may be used to determine the temperature, rather than the frequency. However, the principles described herein are not limited to the conversion process or mechanism from an access pattern to temperature.","A \u201cworking block set\u201d of the system is a set of blocks that are more frequently accessed in order to perform current operations of the system. In one example, the memory levels in the buffer pool are efficient at performing random access operations, whereas a memory or storage (such as a disk) outside the buffer pool (also referred to hereinafter as \u201cexternal storage\u201d) is not as efficient at performing random access operations.","In accordance with at least some embodiments described herein, if the size of the buffer pool grows (by extending the buffer pool to use second level memory) to encompass most of the working block set of the system, hot blocks are written less frequently to the external storage by diverting these writes to the second level memory. As an example, such a second level memory may be non-volatile SCM. In the prior technology, such hot blocks may have been written to external storage perhaps due to memory pressure since the working block set becomes significantly larger than the maximum buffer pool size. The principles described herein take advantage of the faster random I\/O performance of a second level memory (such as SCM) as compared to external storage (such as disk) to dramatically improve I\/O latency and throughput.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":["200","230","240","240","250","240","250","240","240","250","240","241","242"]},"The application need not know the details of the buffer pool management operation. Rather, I\/O requests are issued by the buffer pool manager  as those requests are provided to the buffer pool manager. The principles described herein are not limited to the application that makes such requests, but applications that require a larger working block set may be particularly benefited by the principles described herein. For instance, database applications such as relational database applications often have large working block sets.","The buffer manager  is an I\/O broker, and is a component that issues I\/O requests to the disk and other storage media to fetch blocks from and store blocks to the external storage and buffer pool. For instance, there may be additional layers that expose read\/write APIs for an application (such as a database) given the file and block identifiers. For read requests, the buffer pool manager  checks if the page is already in the buffer pool . If the block is not in the buffer pool , the buffer pool manager  pulls the block from external storage , puts the block in the cache, and responds to the read request. The data files  represent data on external storage  that may be read from and written to (i.e., paged into and out of in the case of pages) the external storage .","For write I\/O requests, if the block is not cached in the buffer pool , the buffer pool manager  writes the block to the external storage , or queues the write to the external storage  until multiple writes can be accumulated for a sequential write operation. If the block is located in the buffer pool , then the buffer pool manager  updates the block in the buffer pool , and then either writes the update to the external storage , or queues the update to be written with other blocks in a sequential write operation.","In one embodiment, the first level buffer pool  is a resource shared by multiple applications for their cached blocks. In some embodiments, there is one first level buffer pool  instance per application instance. For example, in the case of SQL Server, there may be one buffer pool  instance per SQL Server instance. Alternatively, there may perhaps even be one buffer pool  instance per database. However, in the description that follows, the buffer pool instances are described as being on a per service instance basis, though the broader principles are not limited to such an embodiment.","In some cases, the processors of the computing system may have multiple Non-Uniform Memory Access (NUMA) nodes. In that case, the first level buffer pool  may be partitioned on each NUMA node. The buffer pool manager  has a lazy-writer (not shown) associated with each NUMA node. Lazy writer threads maintain a small number of available buffers for its buffer pool consumers to prevent the consumers from constantly stalling while waiting for the buffer. Because the first level buffer pool  is a monolithic per-instance component in this embodiment, the first level buffer pool  can afford to partition its significantly sized data structures per-CPU or per-NUMA node. This eliminates the need for explicit synchronization on buffer pool data structures. CPU's, their caches, and memory may be partitioned into solid state nodes. Proximity of memory to a memory node determines the latency of access. The closer the node, the faster the access; the farther the node, the slower the access.","In some embodiments, the buffer pool manager  no longer performs its own memory management. Instead, the buffer pool manager  relies on a memory manager (not shown) that allocates and frees buffer descriptors (BUF structures\u2014described below) and memory blocks. The memory manager is NUMA-aware and allows the buffer pool manager  to abstract NUMA node affinity and memory management orthogonally.","The maximum and minimum size of the buffer pool  may be determined at configuration time. This occurs perhaps during startup or during some configuration of the application. This determines the maximum number of blocks that can be cached in the buffer pool at any time in the running instance.","As a working block set grows, shrinks, or moves, blocks may have to be evicted to make room for newer database pages in the buffer pool cache. Every buffer descriptor contains information about the last two times a block was referenced and some status information, including whether or not a block has been dirtied by an update.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":["301","302","303"]},"The BUF_L2BPOOL bit indicates that the copy of the page frame has been written to an L2 page file, which is the contiguous extent of storage in the second level buffer pool (SCM in this example). The L2 page file is statically sized and created when the use of the second level buffer pool  is enabled. Changes to the L2 page file configuration are allowed when the second level buffer pool  is disabled. For solid state disks, since the storage stack is traversed, this is represented as a file system file, or potentially a raw disk volume. In other embodiments of this invention this may be a contiguous memory segment bypassing the storage stack. This memory segment may be backed by local storage or remote storage across a communications link.","The BUF_L2DIRTY bit indicates that the copy of the page frame on the L2 page file is stale relative to the copy of the page frame in the first level buffer pool  (e.g., DRAM). An update has occurred to the page in the first level buffer pool  after the last time the page was written to the second level buffer pool .","The Last Timestamp  represents the last time the corresponding page was accessed. The Next to Last Reference  Timestamp represents the next previous time that the corresponding page was accessed. In one embodiment, the temperature of the corresponding page may be ascertained by comparing the NTLR timestamp with the current time with a lesser time difference implying a higher temperature page.","In the described implementation, setting the BUF_L2BPOOL bit is a condition for BUF_L2DIRTY being set. A page frame in the L2 page file cannot be dirty with respect to the page in the first level buffer pool  unless it has first been written into the L2 page file. None of the changes described above affect either the size or alignment of the BUF structure.","In one example, the reference information is used to implement the page replacement policy for the cache data pages using an LRU-2 algorithm. However, that is not required as the principles described herein may be used for any block or page replacement algorithm. However, in specific examples described herein, LRU-2 will be mentioned more commonly.","All pages in the buffer pool  are periodically scanned from start to end. During the scan, the value is assigned to each buffer based on its usage history. When this value is below the low threshold, the pages are considered cold and evicted from the cache. Clean (non-dirty) pages are evicted by un-hashing the descriptor from a buffer pool hash table and freeing the memory for the buffer descriptor and its page frame with the memory manager. Otherwise a write is scheduled to write the page to external storage strictly conforming to write-ahead logging (WAL) rules for dirty evicted pages. After the write is completed, the page is no longer dirty, it is un-hashed, and both its buffer descriptor and page frame are freed.","In some embodiments, individual worker threads primarily perform the work of scanning the buffer pool, writing dirty pages, and populating the buffer free list after they have scheduled an asynchronous read and before the read is completed. Once the read is initiated, the worker thread determines if the memory manager has no pages available to satisfy requests for new pages entering the cache. If there are no pages available, the worker thread calls a routine to replenish the buffer pool cache with free pages. The worker thread then scans a further set of BUF descriptor structures and checks their next-to-last-reference (NTLR) timestamps to determine which buffers can be freed up. The next BUF descriptor entries may be determined by, for example, a buffer clock hand. If a write has to be performed for a dirty buffer in that scan window, the write is scheduled. After the scan the buffer clock hand is advanced to the next set of BUF descriptor structures.","Each instance of server (e.g., each SQL Server instance) also has specialized threads called \u201clazy writers\u201d. There is a lazy writer associated with each NUMA node. The function of the lazy writer threads is to lazily write-behind dirty blocks to external storage  regardless of whether those blocks are hot, warm, or cold. In some embodiments, the lazy write only writes out cold pages and once the lazy-write is completed the page gets evicted.","The buffer pool manager  maintains a small number of available buffers for its buffer pool consumers to prevent them from constantly stalling waiting for the buffer. A lazy writer thread scans that part of the buffer pool associated with its node. The lazy writer sleeps for a specific interval of time, or until under node memory pressure it is woken up by another worker thread on the node. When the lazy writer wakes up, it checks if there are enough free buffers\u2014that is, if the number of available buffers is above a certain threshold which is a function of the buffer pool size. If there are not enough free buffers, like the worker threads, the lazy writer scans the buffer pool to repopulate the free list for that node. Buffers added to the free list are also written back to database pages on disk, following the WAL rules, if they are dirty.","Application-Based Virtual Blocks","This section introduces the notion of application-based virtual blocks. Specifically, in one example, the application-based virtual block is described in the context of a SQL Server instance, but the principles described herein may be more broadly applied in to any relational database server, or any application for that matter.","In this case, the buffer pool is divided into two, the first level buffer pool (referred to herein as \u201cL1\u201d) that corresponds to the DRAM as an example, and a second level buffer pool (referred to herein as \u201cL2\u201d) that corresponds to the backing store . As the primary L1 buffer pool exhausts its available DRAM, the buffer pool writes pages out to the L2 buffer pool freeing up page frames for reuse. When a buffer without a page frame is referenced, the buffer pool manager allocates the page frame and faults the page from its L2 cache to its L1 cache.  illustrates the position of the L2 buffer pool  backed by a storage class memory relative to the L1 buffer pool  in DRAM. Note that there is an interface abstracting paging I\/O between the L1 buffer pool  and the L2 buffer pool .","As  shows, economics forces the DRAM  configured for a database workload to be typically much smaller than the working set  of that workload. Also because most database applications operate on small portions of the database at a time, the working set  is typically smaller than the database , which is one example of a client application. When a workload progresses from initialization to steady-state, its working set grows gradually at a rate depending on the computation time and the available bandwidth populating memory from disk. During the ramp-up phase database pages are mostly read, either randomly or sequentially, from spinning media. There reaches a point where the working set does not fit in memory and the database cache is forced to evict pages from memory as explained below.","Random access to pages in memory leads to evictions of pages to random block addresses on disk. Although conventional solutions coalesce pages into large blocks during eviction from memory to disk, most writes by the worker threads and the lazy writer are small random I\/Os typically between 8 KB and 32 KB. Similarly for a random workload, whenever there is a buffer pool cache miss, the buffer pool manager faults database pages by reading randomly from spinning media. This implies that as a working set grows, shrinks, or moves (remains the same size but changes) the performance of any random workload is capped by the random I\/O throughput of the underlying disk subsystem. Today, the average random IOPS rating for a commercial grade 7200 rpm SATA drive is 80 while that of a 15 Krpm FC or SAS drive is 110-120 Krpm. Driving up the IOPS on spinning media to meet peak workloads usually involves over-provisioning the I\/O subsystem with 10's to 100's of spindles, increasing up-front capital expenditure and significantly reducing the Mean Time To Failure (MTTF) of any disk in the I\/O subsystem.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 4","b":["411","401","402","421","422","431","432"]},"One way of eliminating the performance barrier of small random I\/O's to disk (or other storage that is less efficient at small random access I\/Os) is increasing the system DRAM. However, the configured DRAM on a server is limited by economics and bus bandwidth in the memory subsystem. SSDs are an example of an SCM that is a source of cheap and efficient random IOPS. Although today the price\/capacity of SSD block storage is not as competitive as disk, their price\/random IOPS is superior, especially for small random reads. Where possible, the design offloads random IOPS from mechanical disk to SSD. SSDs behave analogously to EEPROMs but furnish orders of magnitude more and provide cheaper capacity with low latency and non-volatile random access mass storage. However, the principles described herein may use any type of SCM that creates a memory hierarchy between DRAM and a higher latency non-volatile storage source. For example, disks may be replaced by SSD's when the economics of doing so is right. Faster SSD's or some other type of SCM such as PCM or memristors may become the intermediate backing store for caching pages. In general the invention applies to and takes advantage of any memory hierarchy, as described in the summary to improve performance.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 5","b":["501","402","201","501","401","501","511","431","432","432"]},"Buffer pool faults from and to mechanical disk (or other storage device that replaces the disk as a storage device) are reduced to a trickle because most of the demand paging and eviction shifts to the 2-levels of memory, DRAM and SCM, that now constitute the buffer pools L1 and L2. With the larger combined buffer pool size, pages move between the buffer pool and mechanical disk more because the working set itself moves, grows, or shrinks. These I\/O workloads are less eruptive and voluminous, smoothing and alleviating the IOPS demand on mechanical disk during normal processing, when the working set is much larger than the available DRAM. The SCM does most of the random I\/O heavy lifting to move pages in and out of DRAM. This leads to much improved system performance as SCM has much faster random IOPS speeds, and since the cost of such operations is reduced.","A SATA, SAS, or PCI\/e connection to the host replaces or augments the mechanical disk drive. Using an SCM as a tier in the disk storage hierarchy is not mutually exclusive to buffer pool extensions, but complementary.","A specific example implementation will now be described in some detail. That said, this is just a very specific example. The principles described herein are to be applied to any extension of the DRAM buffer pool using SCMs to offload at least some random access operations that would otherwise be performed with higher latency storage device(s). The details of just one specific embodiment will now be described with the caution that this is just one of an infinite variety of implementations that may fall within the larger and broader scope of the more generalized principles described and claimed herein.","The buffer pool extension described in this document may extend off of existing data structures. For instance, in one embodiment that is about to be described in further detail, the main changes are to the BUF data structure, the size of the BUF array, the introduction of a page frame pool per NUMA node, and a L2 page file on the SCM. The following sections outline these changes.","In one embodiment, the buffer pool manager creates as many descriptors as there are pages in the page file, creating a one to one correspondence mapping such that every descriptor matches one page slot in the page file. This allows for a simple allocation scheme which reserves an L2 page slot for every BUF structure allocated from the BUF array. The offset of a page frame in the L2 page file is a simple calculation that translates the ordinal BUF descriptor number to an 8K-aligned offset in the L2 page file.  illustrates the relationships among page frames, the BUF array, and the L2 page file in the specific embodiment described. However, recall the previous statements about how the broader principles of the present invention are not limited to this specific embodiment.","Consider a situation where there is memory pressure as the working set of the database workload grows to exhaust the buffer pool cache. Colder pages may have to be evicted from L2 buffer pool. If these pages are clean pages, then their BUFs and page frames are simply freed for reuse. Dirty pages committed to the L2 page pool (BUF_L2POOL=1, BUF_L2DIRTY=0) have to be written to database pages on disk. In this specific embodiment, there are no Direct Memory Access (DMA) transfers from the L2 page file to disk, so the buffer manager first reads the page from the L2 page file then writes it out to disk. Before doing so, the buffer manager first allocates a page frame to map the page from the L2 buffer pool and use that page frame for DMA to disk. But the buffer pool manager is under memory pressure and allocating the page frame increases the demand for memory. The increased demand for memory forces more evictions which potentially increases the demand for page frames\u2014a vicious cycle resulting eventually in an out-of-memory state.","In one implementation of the buffer pool extension described herein, this problem is solved by reserving small pools of page frames per NUMA node. The number of page frames reserved is a function of the maximum numbers of outstanding I\/Os for the buffer pool manager and the maximum contiguous I\/O size to disk (or other storage device that has lower latency than the SCM used as the backing store). When a dirty page needs to be evicted from the L2 buffer pool, it is allocated from the page frame pool on the NUMA node corresponding to that of BUF structure associated with the page.","The buffer manager exposes the augmented buffer pool  as a pool of block slots on a segmented portion of the second level buffer pool  exclusively owned by a client making I\/O requests to the buffer pool manager . In particular, when the select level buffer pool  is NAND-flash SSD, the augmented memory corresponds to an exclusively owned page file on the SSD.","The latency differential places the SCM somewhere between DRAM and disk in the memory hierarchy with access times to SCM in the order of microseconds as opposed to 10's of nanoseconds and milliseconds to DRAM and the disk storage subsystem, respectively. Preferably, the SCM is separated from the CPU solely by the memory controller hub and is directly attached to the I\/O controller hub via PCI\/e or another standard interface. This has the following advantages:\n\n","Hence, the design favors a hardware configuration where the SCM lies closer to the CPU, where aggregate bandwidth is in GB\/s as opposed being an integrated component on the disk storage stack with aggregate bandwidths in the order of 10 s or 100 s of MB\/s.","Typically, the buffer pool manager  evicts blocks out of the buffer pool  eagerly under memory pressure, or lazily when the block is no longer part of the active working set. The two-level buffer pool hierarchy allows a two level eviction mechanism as illustrated in . Both levels of eviction may use the existing LRU-2 page replacement policy, although another replacement policy may suffice. However, as previously mentioned, the principles of  may be extended to buffer pool hierarchies with more than two levels also.","With first level eviction (i.e., L1 eviction), the buffer pool manager  moves the most recent version of any page, both clean and dirty, from the L1 buffer pool  to the L2 buffer pool . That is, the buffer pool manager un-maps or copies evicted pages in DRAM to the SCM page pool. In the SSD case, this translates to page writes to the SSD page file. After the mapping, the page in virtual memory may or may not be freed but the corresponding BUF structure remains hashed with a corresponding reference to the offset of the page on SSD. On demand, pages may be migrated back from the L2 to the L1 pool by mapping, or reading, them from the SCM page pool to virtual memory.",{"@attributes":{"id":"p-0078","num":"0081"},"figref":"FIG. 7","b":["701","711","702","725","712","703","724","703","702","713","703","704"]},"In this description, the first phase (arrow ) is referred to as the preparation phase and the second stage (arrow ) is referred to as the commitment phase. Under enough memory pressure, the buffer manager may combine the first and second stages to relinquish virtual memory associated with the page immediately. In practice both the preparation phase and commitment phase are combined but the design separates them into two distinct phases. The separation shows that if there is not too much memory pressure, it is possible to save a read back from the L2 cache if the page is quickly re-referenced after the 1st-level eviction. On demand, the buffer manager may reallocate a page frame and un-map the page from the L2 pool to the L1 pool. The commitment phase of the L1 eviction may occur repeatedly (referring the circular flow between states  and  created by arrows  and ) until the buffer pool manager evicts the page completely from the pool (reference transitions  or ), depending on both virtual memory pressure and demand for the page.","L2 eviction removes the page completely from the buffer pool. The buffer pool manager  writes pages that are dirty with respect to external storage  back to external storage , and invalidates the page by clearing the BUF_L2BPOOL and BUF_L2DIRTY before unhashing the BUF structure and discarding it. L2 evictions free resources from cold pages and give them to warm pages. Downstream access to the page implies reading the page back from external storage. The buffer manager must be aggressive about freeing unneeded pages to moderate memory pressure and avoid unnecessary L2 evictions. As indicated by , L2 eviction is possible during allocation or at any of the two phases of L1 eviction.","The 2-level caching hierarchy divides database pages into three categories: (1) hot pages cached in the L1 buffer pool in DRAM, (2) warm pages cached in an L2 buffer pool paging file, (3) and cold database pages that are targeted for 2nd-level eviction to disk. The temperature is a measure of the time interval between the penultimate timestamp (the next-to-last-recently-used or NTLR value) of when the page was last referenced and the current time. The hotter the page, the smaller the interval between uses, or the higher the frequency of use. The colder the page, the larger the interval or the less recently used.  illustrates this segmentation of page temperatures.","The parameterized upper and lower thresholds may be defined statically and may be changed dynamically (e.g., using special trace flags, T-SQL DDL commands, or a public application programming interface). These thresholds may not change frequently and a few predefined ranges may be set depending on the workload. These thresholds are percentiles of page temperatures across all buffer pool pages. For example, a threshold interval of (10, 75) specifies a lower threshold of 10 and an upper threshold of 75. This means that all pages in the buffer pool with temperatures below that of the 10th percentile are considered cold, those with temperatures strictly above the 75th percentile are hot, and all other pages in between are considered warm.","A method calculates the temperatures corresponding to the threshold percentiles by randomly sampling the NTLR values of a statistically large number of pages in the buffer pool (the sample size is currently statically set to 500), sorting them in descending order, and selecting the temperatures at the 30th and 5th percentile to calculate the high and low threshold values, respectively. This method may grow the number of clean pages in the buffer pool. It does so by evicting warm pages out to the L2 buffer pool cache (i.e. pages between the L2 and L1 cutoff) if they are not clean relative to that cache. The method also evicts cold pages (i.e. pages older than the L1 cutoff) from the buffer pool completely. The method is called whenever the clock hand walking the BUF array (using the next method described herein) wraps the BUF array. Its parameters may include the current buffer partition, and an indicator of whether or not a steal is attempted by an allocation routine.","Another method uses the upper threshold temperature to determine which pages qualify for 1st-level eviction and the lower threshold to determine pages targeted for 2nd-level eviction. The method maintains the cursor mentioned in the method just previously described.","In one embodiment, one mechanism for consolidating random IOPS to be internal to the buffer pool, is to cache only clean pages in the L2 buffer pool. In this case, when completely evicting a clean page from the augmented buffer pool, the buffer manager does not need to write clean pages out to disk or force the log for the database. A workload generates random I\/Os only when pages populate the buffer pool from disk and dirty pages are written back to disk eagerly under memory pressure, via for example the lazy writers. Writing only clean pages to the L2 pool biases the IOPS offload scheme toward read-only workloads. As the proportion of updates increase in the workload, the benefits of IOPS offload may be significant but much less resolute.","In the embodiment in which only clean pages are evicted to the L2 buffer pool, when a warm page that is also \u201cdisk-dirty\u201d is to be evicted from the L1 buffer pool to the L2 buffer pull, that page is cleaned by writing the page to the disk, if possible, under a sequential write with other pages. In this description, a page is \u201cdisk dirty\u201d (or simply \u201cd-dirty\u201d) if the copy of the page in virtual memory has more recent updates than the logical image of the page in the database. Similarly, a page is L2 \u201cpool dirty\u201d (or \u201cp-dirty\u201d) if the copy of the page in virtual memory has more recent updates than the most current image in the L2 buffer pool. Thus, in a dual write operation, the warm page is written to the L2 buffer pool, as well as to the disk, in parallel. This would ensure that the warm page is made clean in conjunction with its being written to the L2 buffer pool (if the page qualifies as \u201cwarm\u201d and could be written to the L2 cache), under the assumption that both branches of the dual write operation are successful; that is, assuming that the page was successfully written to the disk as well as to the L2 buffer pool.","In the case where the page was not successfully written to the disk, but was successfully written to the L2 buffer pool, the page in the L2 buffer pool is invalidated (e.g., using the BUF_L2BPOOL bit in the BUF structure) to satisfy the criteria that only clean pages are to be written to the L2 buffer pool. In the case where the page was successfully written to the disk, but was not successfully written to the L2 buffer pool, the system does not validate that the page was written to the L2 buffer pool (e.g., using the BUF_L2BPOOL bit in the BUF structure), but the page is marked as clean (or not d-dirty).","A page is clean when it is equivalent to its database image on disk. When a page is updated in memory (in the L1 buffer pool), the page in the L1 buffer pool becomes dirty relative to its image on disk, and also the page is dirty relative to its image in the L2 buffer pool (if the page is present in the L2 buffer pool). There is a dirty status bit representing whether the page is disk dirty in the BUF descriptor. Accordingly, that bit would be set in this case. Furthermore, the BUF_L2DIRTY bit in the BUF descriptor represents whether the page is dirty with respect to its image in the L2 buffer pool (see ), and thus that bit would also be set. When caching clean pages in the buffer pool, the manager maintains the invariant that no dirty pages are written to the L2 buffer pool. For clean pages already in the L2 buffer pool, setting the BUF_L2DIRTY status bit invalidates clean pages in the L2 buffer pool when the clean pages become dirty.","Lazy writes write dirty pages to disk. When these writes are completed successfully, the corresponding pages in memory are made clean again and are potential candidates for L2 buffer pool caching. The parallel dual write optimization allows the dirty candidate pages to be written to disk and the L2 buffer pool in parallel. The following outlines the algorithm:","1. Any dirty page being written to disk is selected for parallel writes if either of the two following criteria are satisfied:\n\n","For all parallel dual write operations, the manager acquires a single I\/O latch, incrementing the outstanding I\/O count to two for the subsequent parallel write. Then, the asynchronous I\/O's are submitted in parallel to both the disk I\/O subsystem and the L2 buffer pool. On completion of each asynchronous write, the outstanding I\/O count is decremented. If the write to disk completes successfully, the BUF_DIRTY status bit is reset to indicate the page is clean. Otherwise, the bit remains unchanged and the write I\/O error is captured. The outstanding I\/O count would decrement to zero upon the last completed write, allowing the manager to determine whether all writes were successful. If all writes were successful, the BUF_L2BPOOL status bit is set and the BUF_L2DIRTY status bit is reset to indicate a clean page in the buffer pool. If at least one of the writes was unsuccessful, then both BUF_L2BPOOL and BUF_L2DIRTY status bits remain unchanged and the appropriate write error is captured. Any write or I\/O failures on the L2 buffer pool media disables the L2 buffer pool caching and the dual write operation. The I\/O latch is then released.","Notice that one exclusive I\/O latch is taken for all I\/O's both to disk and the L2 buffer pool. This latch guarantees the stability of the page until completion of all I\/O's. In addition, the atomicity guaranteed by the latch ensures only clean pages are written to the L2 buffer pool cache. If either the write to disk or the write to the L2 buffer pool fails, the BUF_L2BPOOL and BUF_L2DIRTY status bits are never updated to ensure any page still dirty in memory is not valid to the L2 buffer pool\u2014maintaining the clean page L2 buffer pool invariant.","In the worst case, any failures to write a page out to disk results in a superfluous write to the L2 buffer pool. However, since write failures are very rare, this does not represent a significant problem. Finally, since the writes are submitted in parallel, the exclusive I\/O latch is held for the duration of the slower of the two writes and not the aggregate of the two consecutive writes. This means the I\/O latch is not held longer than that of any other I\/O during forward progress and should have no significant impact on performance. Although this parallel dual write operation has been described with respect to parallel writes to disk and the L2 buffer pool, the principles may also apply to an extended buffer pool in which there are three or more levels in the buffer pool (e.g., for an L3 buffer pool up to an LM buffer pool where M is an integer equal to or greater than 3). In that case, there may be a parallel write operation in which a parallel write is made to the disk, and to the extended buffer pools using a single I\/O latch as described above.","In a broader embodiment, the dirty pages may also be cached to the L2 buffer pool. These pages may contain updates that have not made it to disk or may be stale relative to a page in memory. For that reason, we introduce orthogonal notions of a page in the L1 pool being dirty with respect to the on disk database or relative to its most current image in the L2 pool.","To be clear, pages are dirty on disk or in the L2 pool relative to the page image in the L1 pool. There is no notion of dirtiness between pages in the on-disk database and the L2 pool. The following set of invariants specifies rules to determine the dirty states of a page during the two phases of L1 eviction and L2 eviction:","DI1. A newly allocated page is neither d-dirty nor p-dirty.","DI2. A page can become d-dirty, when there is an update to the page, at any point in time after allocation.","DI3. A page is never p-dirty on completion of a L1 eviction commitment phase. This means that the buffer manager has either to perform a L2 eviction or update the image of the page in the L2 pool. Without this invariant, the buffer manager will relinquish the virtual memory for a page and all updates to the L1 pool image are lost to the L2 pool. In this case, the updates were either completely lost or written to the on-disk database. This leads to the synchronization invariant below.","DI4. A page becomes p-dirty only if updated after the preparation phase of the L1 eviction.","DI5. A p-dirty page is always d-dirty but the converse is not necessarily true. This invariant ensures that the buffer manager either updates or invalidates any d-dirty page in the L2 buffer pool before it makes the on-disk image of the page clean. As a corollary, a d-dirty page in the L2 pool is always at least as recent as a p-dirty page on disk.","DI6. A page is neither d-dirty nor p-dirty on completion of a L2 eviction. This is the default invariant since a page cannot be clean or dirty if it is not in the buffer pool.","The current dirty page on existing BUF array elements captures the dirty state of a page. Augmenting the BUF array elements with one bit captures of the L2-dirty state of a page (reference  and the corresponding description above).","Moving Pages Between SCM and RAM","When moving pages between the L1 and L2 pools, the buffer manager may use an interface that abstracts out the nuances and idiosyncrasies of both the underlying media and their I\/O characteristics. The un-map operation moves page frames from DRAM in the L1 pool to the L2 pool while the map operation moves pages from the L2 pool to page frames in the L1 pool. This section describes the mechanisms for realizing map and un-map operations for one specific type of SCM: NAND-flash SSDs. Other types of SCM, segmented shared, or network memory may have completely different implementations but honor the following contract:","MAP1. Pages are un-mapped and mapped atomically across the interface boundary.","MAP2. Un-map and map operations support boxcars of pages across the interface boundary with scatter and gather functionality for noncontiguous virtual memory page address segments.","MAP3. Semantics of un-map and map operations assume non-buffered DMA to and from the underlying SCM media.","MAP4. Both the un-map and map support both synchronous and asynchronous completion semantics.","SCMs have latencies closer approximating DRAM than disk and at first glance MAP2, MAP3 and MAP4 may appear unnecessary. MAP2 allows full exploitation of the underlying bus bandwidth for large bulk transfer of large groups of pages across the interface. The non-buffered DMA of MAP3 eliminates the injection of memory copy latency. Finally, MAP4 addresses a widening gap in the latency between on-core memory and memory at low tiers of the memory hierarchy. Furthermore, we do not want constraints on the latency of issuing un-map and map operations to limit the size of boxcars in MAP2.","Background L2 Indexing and Write to Disk","In the embodiment in which d-dirty pages are permitted in the L2 buffer pool, there may be a background indexer that sorts the d-dirty pages in the L2 buffer sequentially according to the disk address. These d-dirty pages are to be written to disk in order to clean up the L2 buffer pool. However, since sequential writes are much more efficient to write to disk than random access writes, the d-dirty pages should be written sequentially to disk if such sequences can be found. Clean pages may be sorted as well (according to the sequence) with the d-dirty pages.","The L2 buffer pool is then examined to find one or more sets of sequential contiguous dirty pages. These sequences may then be written to the disk more efficiently since 1) the sequences may be more easily found as they are already ordered sequentially in the L2 buffer pool, and 2) since the writes are all sequential writes. In one embodiment, in order to reduce the number of required sequential writes, the sequential write may include some clean pages as well. For instance, suppose that there is one sequence of 100 d-dirty pages, and another sequence of 100 d-dirty pages, with both sequences separated by a single clean page. Instead of performing two sequential writes of 100 d-dirty pages each, the system may instead perform a single write of 201 pages (200 of which being d-dirty, and 1 of which being clean). For disk write operations (or write operations to other media that favor sequential writes over random access writes), this may be a much more efficient way of writing 200 d-dirty pages, even though there was 1 clean page in the write that technically did not need to be written.","Most of the NUMA logic remains the same in the buffer pool manager. This is made even simpler by the NUMA-aware memory manager making allocations and freeing from appropriate NUMA nodes transparent. However, after the commitment phase of a 1st-level eviction the BUF for a page loses its page frame. Whenever a page is faulted from the L2 to the L1 buffer pool cache the page frame may be allocated on the same node on which the BUF structure was allocated. The buffer pool manager typically references a page's BUF structure before accessing its page frame. So, a NUMA node mismatch between a BUF and its page frame results in significant performance degradation on a running system with millions of pages.  illustrates the challenge.",{"@attributes":{"id":"p-0114","num":"0119"},"figref":"FIG. 10"},"Accordingly, the principles described herein enable the operations on large working block sets while reducing random access operations to external storage. The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is, therefore, indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order to describe the manner in which the above-recited and other advantages and features can be obtained, a more particular description of various embodiments will be rendered by reference to the appended drawings. Understanding that these drawings depict only sample embodiments and are not therefore to be considered to be limiting of the scope of the invention, the embodiments will be described and explained with additional specificity and detail through the use of the accompanying drawings in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 10","FIG. 9"]}]},"DETDESC":[{},{}]}
