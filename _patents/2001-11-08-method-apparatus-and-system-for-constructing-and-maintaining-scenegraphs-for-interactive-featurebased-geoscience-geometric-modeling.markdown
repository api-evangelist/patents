---
title: Method, apparatus and system for constructing and maintaining scenegraphs for interactive feature-based geoscience geometric modeling
abstract: A method, computer system or computer program is provided for interactively constructing, editing, rendering and manipulating geoscience models, including aggregating the functionality of a geometry system and a graphics system, enforcing consistency between the geometry system and the graphics system, and interfacing the geometry system and the graphics system to an application through an integration layer. State machines are also provided that enable updating of only those graphics objects whose geometry or topology have been changed and that are specified as visible by the user, thus increasing performance. A scenegraph construction technique is also provided to reduce memory requirements and further enhance performance. A material property framework is provided, among other things, to communicate changes in the geometry or topology to aggregate objects which then determine which graphics objects are affected by the changes and which graphics objects are to be updated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06980935&OS=06980935&RS=06980935
owner: Schlumberger Technology Corp.
number: 06980935
owner_city: Houston
owner_country: US
publication_date: 20011108
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE RELATED ART","SUMMARY OF THE INVENTION","OPERATION OF THE PRESENT INVENTION","DETAILED DESCRIPTION OF THE INVENTION","FRAMEWORK OF THE PRESENT INVENTION","ABSTRACT BASE CLASSES","OPERATION OF THE PRESENT INVENTION","EXAMPLE: Attach PSP Property","OTHER METHOD DESCRIPTIONS"],"p":["This application is a conversion of Provisional U.S. Application Ser. No. 60\/308,915 that was filed on Jul. 31, 2001 from which priority is claimed under 35 U.S.C. 120.","This invention relates in general to computer graphics imaging and geometric modeling, and more particularly, the present invention relates to interactively constructing, editing, rendering and manipulating geoscience models.","Geologists, geophysicists and petroleum engineers use models, including computerized models, of the earth's shell to plan exploration and production of hydrocarbons and, to a lesser extent, other minerals. As hydrocarbons become more and more scarce, the accuracy of the computerized models becomes increasingly important to limiting the cost of locating and producing hydrocarbons and the associated cost of hydrocarbon products, such as gasoline and heating oil.","Interpretation of geophysical and geological data stored in a computerized model relies on the ability of the model to be displayed in such a way that the information contained in the model can be discerned and edited.","The Interactive Geometric Modeling library (IGM) (see U.S. Pat. No. 6,191,787 to Lu, et al.) integrates a geometry engine and a graphics engine. This integration provides a high level interface that supports interactive feature-based 3D geoscience geometric model building, rendering and editing.","A scenegraph is a representation of a scene by a graphics engine. Efficient scenegraph construction and maintenance directly affect the performance of an interactive system. This patent application describes several new techniques for constructing and maintaining a scenegraph, which greatly enhances performance of and adds new functionality to the IGM.","The geometry engine that the IGM uses is the Geometry Query Interface (GQI) (see U.S. Pat. No. 6,128,577 to Assa, et al.). The GQI is a layer built on top of a geometry kernel called \u201cShapes\u201d from XOX, Inc. The graphics engine is called Open Inventor. The IGM integrates the two engines to enable interactive feature-based geometric modeling.","The GQI builds geometric models via Irregular Space Partitioning using Boolean operations. The resulting model is a boundary representation (b-rep) model. The GQI provides feature-based modeling for geoscience applications, where features are entities of interest to an end user concerning group geometric and topological elements in a model.","Several factors have to be considered for constructing and maintaining scenegraphs for building geoscience models. The process and the generated geoscience geometric models are different from those in traditional CAD industry. Some of these differences that relate to this invention are listed below. These differences affect the manner of constructing and maintaining the scenegraph for rendering.","First, models are built via irregular space partitioning where input features are split into pieces, while CAD industry typically uses Constructive Solid Geometry where input features are combined via Boolean operations. Secondly, the material properties in a geoscience geometric model are typically space changing and are attached at the feature level, while in CAD industry each element in a model typically has a constant material property. Third, a crack is normal in a geoscience model, while a crack may be a defect in a CAD model.","Similar to the needs of users in the CAD industry, a geoscience user wants to be able to interact with and maintain the identities of input features and to assign and interact with new features.","For geoscience applications, the following two types of views are typically required. The first type is surface view that renders surface cells or features in the model. The second type is volume view that renders the volume cells or features in the model. A surface cell has its own identity. It also serves as a boundary cell for two volumes that share it. A user may also want combinations of the two types. Consequently, there is more than one graphical representation for the same geometric model.","Finally, software related to geoscience applications typically consume considerable computer resources, oftentimes requiring powerful workstations that are not easily moved. However, it would be desirable to have the capability mentioned above at field locations. There is, therefor, a need in the art to increase the efficiency of geoscience software to the point that it can be installed on normal mobile computing devices, such as laptop computers.","In accordance with the present invention, the disadvantages and problems associated with the prior art are solved by reducing memory requirements through a new scenegraph construction method, as well as a providing a finite state machine that handles the consistency between graphics objects (whether set visible or invisible and valid or invalid) and their corresponding geometry objects, thereby enabling the selective or partial updating of only those graphics objects whose geometries or topologies have been changed and that are set as visible by the user, further enhancing performance.","The present invention includes a method for interactively editing a model comprising a first surface method being implemented on a programmable computer having a processor, a storage system and at least one input and at least one output device. The model is preferably stored in media that is readable by the programmable computer or can be stored on other media such as tape, hard disk, CD-ROM, etc. A database that is operative with the storage system and the processor stores a model of the various objects that can be viewed on one or more scenegraphs.","In the simplest embodiment of the method of the present invention, the data representing a first surface feature in the database is loaded into random access memory or system memory of the computer system of the present invention. An aggregate feature is created for the first surface feature. After creating the aggregate feature, a first graphics object is created from the aggregate feature. Then the first graphics object is added to the application scenegraph. Thereafter, a geometry object for the aggregate feature is created and then the first surface feature is edited in the model. After editing the surface feature, the graphics for the model are updated selectively so that only those graphics objects whose geometry objects have been changed and that are not set as viewable by the user are not updated\u2014thus conserving time and resources. Selective updating is an important feature of the present invention and distinguishes it from prior art systems that update all objects, regardless of whether or not those objects are visible and\/or have changed. The present invention only updates those graphics in the model that are displayed to the user. For instance, if the graphics object in question is set as invisible to the user, then they are not immediately updated. Once the updating step is completed, the first graphic object is removed from the application scenegraph.","The present invention also provides an interface and an IGM that is operative with the interface as well as a GQI that is operative with the IGM. The interface is used for selecting an operation to perform on a second surface feature and that interface is also developed to inform the IGM of the selection that the user has made. Once that has happened the IGM can invoke the operation with the GQI. And then thereafter, at least one callback from the GQI is performed to inform the IGM during the execution of the operation so that the updating of the graphics object of the model can be done to refresh the output device.","It is preferred that the editing be accomplished by irregular space partitioning and that the updating of the graphics object includes the creation of graphics objects or, if the performing of the callback causes a change of state for the aggregate feature, the aggregate feature change of state is recorded in a consistency finite state machine of the present invention. The consistency finite state machine manages consistency between geometry and graphics. The consistency finite state machine facilitates the selective (partial) update of the graphics presented to the user.","The method in the present invention also includes a callback method that includes the invalidation of graphics objects for the aggregate feature. The callback method can also perform validation of the geometry of the aggregate feature so that a distinction between invalid graphics and valid geometry can be made.","The callback method of the present invention includes providing a set of objects that facilitates the callback, namely a first geometry modeler feature object. Also included in the method is a changed geometry object that is contained in a geometry model or feature object. There is also a first meta-property attribute object that is associated with the changed geometry object. In addition, a first meta-property object that is associated with a meta-property attribute object is provided. The first meta-property object has a number of properties associated with it, mainly a point set preservation property, a point set preservation property policy object, a cell back pointer property object, an aggregate back pointer property policy object, a geometry cell object that is associated with the back cell pointer object, an aggregate cell object associated with the geometry cell object and a display cell graphics object associated with the aggregate cell object. Further, a second meta-property object that is associated with the geometry modeler feature object is included as well as a second meta-property object that is associated with second meta-property attribute object. The second meta-property object has a number of the same objects and features as the first meta-property object. Namely, the second meta-property object has a point set preservation property object, a point set preservation property policy object, a feature back pointer property object, a second aggregate back pointer property policy object, a geometry feature object associated with the feature back pointer property object, an aggregate feature object associated with a geometry feature object and a display feature object that is associated with the aggregate feature object.","Callbacks are performed in a series of sub-steps. For instance, if the callback is for a volume object then the edit is performed for the volume feature, otherwise the edit is for the surface feature. In the case of updating graphics, preferably the update is performed for only those cells that have changed geometrically. Alternatively, the update in the graphics can include only those features that have changed topologically. However, another embodiment of the present invention includes the updating of graphics for those features that have changed either topologically or geometrically. Finally, the update can take place for those features that have changed both topologically and geometrically.","The creation of graphics for the aggregate feature of the model is performed in a series of sub-steps. Generally, the relevant surface features from the model are obtained and for each of the relevant surfaces, if the surface feature has a graphics object then the graphics object is updated. Otherwise, the graphics object is first created and then either the updated graphics object or the created graphics object is added to the surface scenegraph root node.","The present invention can be described as a method for interactively editing a model that is implemented on a computer comprising a processor, a data storage system, at least one input device and at least one output device, including, but not limited to, a computer monitor, storage device, or print-out. The model is preferably stored on a computer-readable media. The model itself has at least a first surface, although many surfaces are typically modeled.","The method begins by loading data of the first surface feature from a database that is stored in the data storage system. Next, an aggregate feature is created for the first surface feature. This enables the creation of a first graphics object from the aggregate feature. Thereafter, the first graphic object is added to the application scenegraph. Next, a geometry object is created for the aggregate feature. The first surface feature in the model is then edited as desired. Once editing is complete (e.g., the user opts out of edit-mode, or a requisite period of time elapses) the graphics for the model are selectively updated. The selective update relieves the various devices from recalculating and displaying all updates and changes. Instead, only those updates that affect what the user experiences are updated. Finally, the first graphics object of the first surface feature is removed from the application scenegraph.","Editing and Updating","The process of editing itself is composed of several steps. First, one must provide an interface. Next, an IGM that is operative with the interface must also be provided. A GQI is provided that is operative with the IGM to enable geometric modeling. This enables the user, through the interface, to select an operation to perform on a second surface feature. The interface is designed to inform the IGM of the user's selection. The operation itself is invoked with the GQI. During the editing process, it is necessary to perform at least one callback from the GQI to the IGM during execution of the operation. The callback is used to update the graphics object of the model to refresh the output device. Editing can be accomplished via irregular space partitioning, although other techniques of editing are possible with the present invention. Once the editing is complete, the updating of the graphics can commence, typically by creating the graphics object. The present invention has a special feature wherein the step of updating includes updating graphics only those cells that have changed geometrically and\/or topologically. The updating step may also include the referencing of a visibility finite state machine. The visibility finite state machine aids in the managing of the graphics object's updating operations, and the graphics object's visibility update operations. Use of the visibility finite state machine enables the updating of only those graphics objects that are designated as visible (to the user). The visibility finite state machine can be used to designate a graphics object as visible, and also to check on the validity of the graphics object. If the graphics object is valid, then the graphics object can be added to the scenegraph. Otherwise, the graphics object can be updated and then added to the scenegraph.","The process of updating can encompass several steps. For example, updating may include checking the state of each feature in the scenegraph. Generally, if the graphics of the feature is valid or if the feature's geometry is invalid, then the feature's graphics object is not updated. However, if the feature's geometry is valid and the graphics are invalid, then the graphics object of the feature is updated.","Another form of updating can include checking the state of each cell in the scenegraph. In this scenario, if the graphics for the cell are valid or if the geometry of the cell is invalid, then the graphics object of the cell is not updated. If the geometry for the cell is valid and the graphics of the cell is invalid, then graphics object of the cell is updated.","The method of the present invention may also encompass those situations where a second surface feature is not contained within the model, although the second feature can, of course, be contained within the model.","Creating Graphics","The method of the present invention also involves the creation of graphics for various entities, such as an aggregate feature. Typically, this process involves obtaining all relevant surface features in the model. For each of the relevant surface features, if that surface feature has a graphics object, then that graphics object is updated. Otherwise, a graphics object for the surface feature is created. Afterward, the graphics object for the surface feature is added to a surface scenegraph root node.","In addition to the steps outlined in the preceding paragraph, other steps may optionally be accomplished, for example, the aggregate objects of all two-dimensional cells for the surface feature may be obtained. Next, the aggregate objects of each of the cells can be prompted to obtain at least one valid graphics object and to add that graphics object to a sub-scenegraph of the surface feature. Once that is completed, the graphics object of the surface feature can be validated.","Still more steps may be taken for the method outlined immediately above. For example, the step of obtaining valid graphics object for a cell can include a check to determine if the graphics object for the cell does not exist. If the graphics object doesn't exist, then the graphics object for the cell is created and validated. If the graphics object for the cell does exist but is not valid, then the graphics object for the cell is updated and validated.","Alternatively, the method of the present invention for creating graphics may also include creating graphics for at least one volume cell from the model. This alternative method includes obtaining at least one relevant active volume cell in the model. Once obtained, a check can be made to ensure that the graphics objects of all of the two-dimensional cells of each volume cell have been created. Then, for each of the two-dimensional cells, aggregates can be obtained. A new aggregate can be created if the two-dimensional cell aggregate does not exist. Then each two-dimensional cell is checked to ensure that it has valid graphics. Thereafter, a graphics object can be created for each of the volume cells. Then, for each volume cell, the graphics content, preferably without color material, of each two-dimensional cells of the volume cell is added to the sub-scenegraph of the graphics object of the volume cell. Finally, the graphics object is added for each of the volume cells to the volume scenegraph root node. An instantiation of a graphics content, preferably without color material, that graphically represents a two-dimensional cell is shared by at least one scenegraph containing a graphics object of a surface feature that has the two-dimensional cell as a child, as well as at least one of the scenegraphs that contains graphics objects of either one volume cell or two volume cells that have the two-dimensional cell as part of their boundaries.","Callbacks","The present invention makes extensive use of callback within the object framework. For instance, a callback can cause a change of state for the aggregate feature. Preferably, the aggregate features is a consistency finite state machine, so that the callback is facilitated efficiently. It is also preferable that the consistency finite state machine manage the consistency between the geometry and the graphics. Callbacks are also useful for invalidating the graphics object for the aggregate feature and for validating the geometry of the aggregate feature. For example, if the callback is for a volume object, then a specific callback is used for the volume feature. Otherwise, an edit callback for a surface feature is performed.","Callbacks according to the present invention can come in a variety of configurations and circumstances. For example, edit callbacks for a volume feature include registering the meta-property split callback class method with the geometry modeler interface. The geometry modeler interface is intended to be invoked when a volume split event occurs. Thereafter, a first meta-property attribute is attached to at least one volume object that is contained by the volume feature. Then a callback is received from the geometry modeler interface that specifies a first volume object, a second volume affected by a change to the first volume object and the first meta-property attribute. A pointer value is then obtained from the first meta-property attribute which then allows the de-referencing of the pointer value to locate a first meta-property object. A split callback is invoked in the first meta-property object with the first meta-property attribute, the first volume object and the second volume object. This last step itself encompasses obtaining a first point set preservation property instance and a first point set preservation policy instance from the property instance, as well as initiating a first split callback to the point set preservation policy instance with the point set preservation property instance, the first volume object and the second volume object. This last sub-step itself includes obtaining at least one containing feature for the first volume object and initiating a feature add child update on the geometry modeler interface with the containing feature and the second volume object. Then, a cell back pointer property instance is obtained so that an aggregate back pointer property policy instance can be obtained from the cell back pointer property instance whereupon a second split callback is initiated to the aggregate back pointer property policy instance with the cell back pointer property instance. The latter callback itself includes obtaining a volume geometry cell object from the cell back pointer property instance and initiating a cell split call to the volume geometry cell object. The latter sub-step may encompass initiating a call to the volume cell aggregate patron of the volume geometry cell object to invalidate the graphics of the first volume.","Performing a feature add child callback for a volume feature includes registering the meta-property add child callback class method with the geometry modeler interface that is to be invoked when a feature add child event occurs. This can include attaching a second meta-property attribute instance to the volume feature; and receiving, from the geometry modeler interface, the add child callback specifying the volume feature, a volume object and the second meta-property attribute. Next, a pointer value from the second meta-property attribute is obtained and then the pointer value is de-referenced to locate a second meta-property object. The add child callback is invoked in the second meta-property object. The latter step includes obtaining a second point set preservation property instance; obtaining a second point set preservation property policy instance from the second point set preservation property instance; and initiating the add child callback method of the second point set policy object with the volume feature and the volume geometry object. That latter sub-step itself includes attaching the point set preservation property to the volume cell; obtaining a feature back pointer property instance; and obtaining a second aggregate back pointer property policy instance from the feature back pointer property instance; and initiating the add child callback method of the second aggregate back pointer property policy instance with the volume feature, the volume geometry object and the volume feature back pointer property. The latter sub-step itself includes initiating an add child notify method call to the volume feature geometry object identified by the feature back pointer property instance. That latter sub-step itself includes initiating a call to the volume feature aggregate patron of the volume feature object in order to validate the geometry of the volume feature object; and initiating a call to the volume feature aggregate patron of the volume feature object in order to invalidate the graphics of the volume feature object.","Yet another aspect of the method of the present invention involves performing an edit callback for a surface feature. This aspect of the method includes registering the meta-property split callback class method with the geometry modeler interface to be invoked when a surface split event occurs; attaching a first meta-property attribute to at least one surface object contained by the surface feature; receiving from the geometry modeler interface a callback specifying a first surface object, a second surface affected by a change to the first surface and the first meta-property attribute; obtaining a pointer value from the first meta-property attribute and de-referencing the pointer value to locate a first meta-property object; invoking a split callback in the first meta-property object with the first surface object, the second surface object and the first meta-property attribute. The latter step itself includes obtaining a first point set preservation property instance; obtaining a first point set preservation policy instance from the property instance; and initiating a first split callback to the point set preservation policy instance with the point set preservation property instance, the first surface object and the second surface object. The latter sub-step itself includes obtaining at least one containing feature for the first surface object; and initiating a feature add child update on the geometry modeler interface with the containing feature and the second surface object; obtaining a cell back pointer property instance; obtaining an aggregate back pointer property policy instance from the cell back pointer property instance; and initiating a second split callback to the aggregate back pointer property policy instance with the cell back pointer property instance. The latter sub-step itself includes obtaining a surface geometry cell object from the cell back pointer property instance; and initiating a cell split call to the surface geometry cell object. This latter sub-step includes initiating a call to the surface cell aggregate patron of the surface geometry cell object to invalidate the graphics of the first surface.","The step of performing a feature add callback (mentioned in the preceding paragraph) itself includes registering the meta-property add child callback class method with the geometry modeler interface that is to be invoked when a feature add child event occurs; attaching a second meta-property attribute instance to the surface feature; receiving from the geometry modeler interface the add child callback specifying the surface feature, a surface object and the second meta-property attribute; obtaining a pointer value from the second meta-property attribute and de-referencing the pointer value to locate a second meta-property object; and invoking the add child callback in the second meta-property object. This latter sub-step itself includes obtaining a second point set preservation property instance; obtaining a second point set preservation property policy instance from the second point set preservation property instance; and initiating the add child callback method of the second point set policy object with the surface feature and the surface geometry object. This latter sub-step itself includes attaching the point set preservation property to the surface cell; obtaining a feature back pointer property instance; obtaining a second aggregate back pointer property policy instance from the feature back pointer property instance; and initiating the add child callback method of the second aggregate back pointer property policy instance with the surface feature, the surface geometry object and the surface feature back pointer property. This latter sub-step itself includes initiating an add child notify call to the surface feature geometry object identified by the feature back pointer property instance. This latter sub-step itself includes initiating a call to the surface feature aggregate patron of the surface feature object to validate the geometry of the surface feature object; and initiating a call to the surface feature aggregate patron of the surface feature object to invalidate the graphics of the surface feature object.","Callbacks can have a number of effects on various objects of the present invention. For instance, performing the callback may cause a change of state for a cell. The change of state of the cell can be recorded in a consistency finite state machine.","Another aspect of the method of the present invention is the performing of an edit callback for a volume feature. That aspect of the method of the present invention includes registering the meta-property merge callback class method with the geometry modeler interface to be invoked when a volume merge event occurs; attaching a first meta-property attribute to at least one volume object contained by the volume feature; receiving from the geometry modeler interface a callback specifying a first volume object, a second volume object, a surface object which formerly bounded the first and second volume objects and which has been removed from the model, and a meta-property attribute; obtaining a pointer value from the geometry model attribute and de-referencing the pointer value to locate a first meta-property object; and invoking a merge callback in the first meta-property object. The latter sub-step itself includes obtaining a first point set preservation property instance; obtaining a first point set preservation policy instance from the property instance; and initiating a first merge callback to the point set preservation policy instance with the point set preservation property instance, the first volume object, the second volume object, and the surface object. That latter sub-step itself includes obtaining at least one containing feature for the first volume object; and initiating a feature remove child update on the geometry modeler interface with the containing feature and the second volume object; obtaining a cell back pointer property instance; obtaining an aggregate back pointer property policy instance from the cell back pointer property instance; and initiating a second merge callback to the aggregate back pointer property policy instance with the cell back pointer property instance, the first volume object, the second volume object, and the surface object. The latter sub-step itself includes obtaining a volume geometry cell object from the cell back pointer property instance, and initiating a cell merge call to the volume geometry cell object. That latter sub-step itself includes initiating a call to the volume cell aggregate patron of the volume geometry cell object to invalidate the graphics of the first volume.","The method for performing an edit callback on a volume feature itself optionally has a removal of the child edit callback. That sub-method includes registering the meta-property remove child callback class method with the geometry modeler interface to be invoked when a feature remove child event occurs; attaching a second meta-property attribute instance to the volume feature; receiving from the geometry modeler interface the remove child callback specifying the volume feature, a volume object and the second meta-property attribute; obtaining a pointer value from the second meta-property attribute and de-referencing the pointer value to locate a second meta-property object; and invoking the remove child callback in the second meta-property object. The latter sub-step includes obtaining a second point set preservation property instance; obtaining a second point set preservation property policy instance from the second point set preservation property instance; initiating the remove child callback method of the second point set policy object with the volume feature and the volume geometry object. The latter sub-step includes removing the point set preservation property from the volume cell; obtaining a feature back pointer property instance; obtaining a second aggregate back pointer property policy instance from the feature back pointer property instance; and initiating the remove child callback method of the second aggregate back pointer property policy instance with the volume feature, the volume geometry object and the volume feature back pointer property. The latter sub-step includes initiating a remove child notify call to the volume feature geometry object identified by the feature back pointer property instance. That latter sub-step includes initiating a call to the volume feature aggregate patron of the volume feature object to validate the geometry of the volume feature object; and initiating a call to the volume feature aggregate patron of the volume feature object to invalidate the graphics of the volume feature object.","Performing an edit callback on a surface volume is similar to the same method for the volume feature (described above). Specifically, the step of performing an edit callback for a surface feature includes registering the meta-property merge callback class method with the geometry modeler interface to be invoked when a surface merge event occurs; attaching a first meta-property attribute to at least one surface object contained by the surface feature; receiving from the geometry modeler interface a callback specifying a first surface object, a second surface object, and a curve object which formerly bounded the first and second surfaces and which has been removed from the model and a meta-property attribute; obtaining a pointer value from the geometry model attribute and de-referencing the pointer value to locate a first meta-property object; and invoking a merge callback in the first meta-property object. The latter sub-step includes obtaining a first point set preservation property instance; obtaining a first point set preservation policy instance from the property instance; and initiating a first merge callback to the point set preservation policy instance with the point set preservation property instance, the first surface object, the second surface object, and the curve object. The latter sub-step includes obtaining at least one containing feature for the first surface object; and initiating a feature remove child update on the geometry modeler interface with the containing feature and the second surface object; obtaining a cell back pointer property instance; obtaining an aggregate back pointer property policy instance from the cell back pointer property instance; and initiating a second merge callback to the aggregate back pointer property policy instance with the cell back pointer property instance, the first surface object, the second surface object, and the curve object. The latter sub-step includes obtaining a surface geometry cell object from the cell back pointer property instance; and initiating a cell merge call to the surface geometry cell object. The latter sub-step itself includes initiating a call to the surface cell aggregate patron of the surface geometry cell object to invalidate the graphics of the first surface.","Finally, the step of performing a feature remove callback for a surface feature includes registering the meta-property remove child callback class method with the geometry modeler interface to be invoked when a feature remove child event occurs; attaching a second meta-property attribute instance to the surface feature; receiving from the geometry modeler interface the remove child callback specifying the surface feature, a surface object and the second meta-property attribute; obtaining a pointer value from the second meta-property attribute and de-referencing the pointer value to locate a second meta-property object; and invoking the remove child callback in the second meta-property object with the second meta-property attribute, the surface feature and the surface geometry object. The latter sub-step includes obtaining a second point set preservation property instance; obtaining a second point set preservation property policy instance from the second point set preservation property instance; and initiating the remove child callback method of the second point set policy object with the surface feature and the surface geometry object. The latter sub-step itself includes removing the point set preservation property from the surface cell; obtaining a feature back pointer property instance; obtaining a second aggregate back pointer property policy instance from the feature back pointer property instance; and initiating the remove child callback method of the second aggregate back pointer property policy instance with the surface feature, the surface geometry object and the surface feature back pointer property. The latter sub-step includes initiating an remove child notify call to the surface feature geometry object identified by the feature back pointer property instance. The latter sub-step includes initiating a call to the surface feature aggregate patron of the surface feature object to validate the geometry of the surface feature object; and initiating a call to the surface feature aggregate patron of the surface feature object to invalidate the graphics of the surface feature object.","A callback can be performed in a number of ways. Generally, however, the callback is accomplished with a set of one or more objects. Generally, that set of objects includes a first geometry modeler feature object; a changed geometry object that is contained in the geometry modeler feature object; a first meta-property attribute object that is operatively associated with the changed geometry object; a first meta-property object that is associated with the first meta-property attribute; a second meta-property attribute object that is associated with the geometry modeler feature object; and a second meta-property object associated with the second meta-property attribute object.","The first meta-property object itself has a set of objects, such as a point set preservation property object; a point set preservation property policy object; a cell back pointer property object; an aggregate back pointer property policy object; a geometry cell object associated with the cell back pointer object; an aggregate cell object associated with the geometry cell object; and a display cell graphics object associated with the aggregate cell object.","The second meta-property attribute object itself has a set of objects, includes a second point set preservation property object; a second point set preservation property policy object; a feature back pointer property object; a second aggregate back pointer property policy object; a geometry feature object associated with the feature back pointer property object; an aggregate feature object associated with the geometry feature object; and a display feature graphics object associated with the aggregate feature object.","Geometric model building and editing are largely an interactive process that requires adequate graphics support. Given the complexity of interactive computer graphics, it is desirable to write applications using high-level development tools such as OPEN INVENTOR, an object oriented graphics library.","Schlumberger Ltd.'s GEOFRAME product, an application for performing geoscience modeling, includes a geometry modeling component, called the GEOMETRY QUERY INTERFACE (\u201cGQI\u201d), which provides an application programming interface (\u201cAPI\u201d) to build and edit solid 3D geometry models. Solid 3D geometry models contain the relationships between the various geometry elements contained in the model. A portion of The GQI's geometry modeling functionality is provided by a commercial geometry engine, XOX Corporation's SHAPES package.","A graphics system displays graphic information in such a way so that complicated relationships, such as those contained in the geometry model, can be visualized. The SHAPES package includes a graphics system based on OpenGL. For performance reasons, however, it is important to separate graphics interaction and geometry processing. Further, virtually all earth science applications require visualization or interactive graphics but not all of them require geometric modeling. Therefor, it simplifies development to use one generally suitable graphics system for writing applications and to add a geometry engine only where required.","When designing an application including both a graphics and a geometry system, the design issues are not only how to render and visually interact with the geometry model, but also how to make the geometry engine and the graphics engine work together smoothly. In the case of OPEN INVENTOR and GQI\/SHAPES, both engines are self-contained and manage their own objects and operations on those objects. The two engines use different internal representations for equivalent objects to describe their geometry, topological relationships, and physical properties. This leads to inconsistencies when the same object is operated on by both engines. Integration of the two engines entails the addition of some mechanism to keep track of and reconcile those inconsistencies.","One such design, an interactive geometric modeling library (\u201cIGM\u201d) , integrates a high-level graphics system (\u201cgraphics system\u201d)  and a high-level geometric modeling package (\u201cgeometry system\u201d) , providing an application  with a consistent view of both sub-systems, as shown in . The IGM provides an architecture that integrates a graphics system and a geometry system to enable interactive construction, editing, and visualization of geoscience models.","Earth science applications have specific geometry modeling requirements in addition to those met by conventional CAD packages. Subsurface structures form typically \u201clayer cakes\u201d  where \u201chorizons\u201d, such as horizon , , , horizon , , and horizons  and , separate layers, such as segmented layer , , segmented layer , , segmented layer , , and layers  and , as shown in . Layer cakes are often broken up into \u201cfault blocks\u201d, such as fault blocks , , , , , , that are bounded by \u201cfaults\u201d, such as faults  and . In terms of geometric modeling, this means that the geometry engine used must support the representation and computation of non-manifold geometries, that is, geometries having mixed dimensions (i.e., 3D fault blocks and 2D faults).","Horizons form the boundaries of layers; faults separate and offset blocks of layers. Logically, layers and horizons are considered single objects even if they are split up and spatially separated as, for example, the horizon , , separating layer , from layer , ","A region of interest  may be sub-divided by inserting surfaces , to produce layer cake , as shown in . At first, the sub-division appears only on the screen. Once the application is satisfied with the location of the surfaces, it \u201ccommits\u201d , computing intersections, and establishing connection relationships between all objects in the assembly to produce layer cake  and the layers are rendered on the screen to provide screen view .","Building geometric models of subsurface structures, or earth models, is largely an iterative process in which models are refined as new subsurface data become available. In , the lower surface is deformed to produce horizon , changing the geometry of the layer  above it to a wedge or \u201cpinchout\u201d. Again, after the application is satisfied, it commits , causing the change to be reflected in the geometry model  and on the screen . In particular, the IGM merges two layers  and , to produce layer , removing horizon  in the process. To accommodate such changes, adequate support for model editing is as important as facilities to build models from scratch.","Earth models can be large and may contain several tens to hundreds of surfaces, each represented by several ten-thousands to hundred-thousands of triangles, in the case of a tessellated surface. The IGM must perform well on large data sets. While it may be acceptable, or even required, for some applications to run as batch processes, it must be possible to interactively work with an earth model. This includes viewing a model as well as editing its objects and their attributes.","Different applications have to be able to share the earth model. This means that persistent storage must include all shapes, topological relationships, and attributes which make up a model.","Most commercial geometric modeling systems use boundary representations and architecturally separate the representations of shape, topology, and attributes such as material properties. Some systems are able to represent non-manifold geometries, for example, 3D objects with embedded surfaces or 2D objects with embedded curves. In such objects, boundaries are shared between adjacent components, for example, fault  is shared by fault blocks , , and , as shown in .","Traditional computer aided design (\u201cCAD\u201d) applications build complex 3D geometries by combining primitive 3D building blocks such as blocks and cylinders. This is referred to as constructive solid geometry (CSG) modeling. For example, as shown in , subvolumes are subtracted from an initial shape . Further subvolumes are subtracted producing the final shape . CSG modeling is unsuitable for building earth models where the shapes of 3D objects such as geologic layers have to be inferred from the 2D objects that bound them such as horizons and fault planes.","Irregular space partition (\u201cISP\u201d) provides the capability to build earth models because it operates as a sequence of sub-divides and inserts, as shown in . Region of interest  is sub-divided by surfaces and to produce layer cake . A subvolume , representing a salt dome, is inserted into layer cake  and the shape of the boundaries between the objects is edited to produce the final model .","ISP models can, in addition, represent smoothly varying material property fields which may contain internal discontinuities that occur along distinct boundaries. The location of the discontinuity boundaries make up the shape and structure of the model. The shape of discontinuity boundaries is explicitly represented. These boundaries may lie anywhere in an infinite space, have any shape, and intersect one another to partition space into sets of distinct sub-regions.","An ISP model is built by defining a \u201cregion of interest\u201d and subdividing it with lower-dimensional objects, for example, a subsurface region subdivided into layers by stratigraphic boundaries. In addition to subdividing a region, other regions can be embedded into them. The GQI's implementation of ISP modeling supports the notion of features which makes it possible to treat collections of regions as uniform objects.","Geometry engines provide a variety of representations for shapes, including analytical and parametric curve and surface representations. In earth science, triangle meshes are widely used for surface representation.","Topological relationships in a model are represented as a graph in which nodes are topological entities such as vertices, curves, faces, and volumes, and in which edges are connectivity relationships. This is called a boundary representation, or \u201cb-rep\u201d. Both CSG and ISP modeling can generate b-reps.","For example, shows an object  comprised of two adjacent rectangles ,  with a shared boundary . An exploded version of object , shown in , demonstrates that it comprises two faces , , seven edges , , , , , , and , and six vertices , , , ,  and . The topological relationships between these geometric elements, illustrated in , comprises circles  and , representing face  and , respectively. Face  is connected to and bounded by four edges , , , and , represented by circles , ,  and , respectively. The \u201cbounded by\u201d relationship is represented by arcs , , , and . Face  is connected to and bounded by four edges , , , and , represented by circles , ,  and , respectively. The \u201cbounded by\u201d relationship is represented by arcs , , , and .","Attributes are typically associated with topological entities. For example, the rectangles' color attribute  and  may be associated with their corresponding faces  and , respectively.","Geometric modeling systems support a comprehensive set of geometric operations. These include curve\/curve, surface\/surface and surface\/curve intersections as well as boolean operations such as the union, subtraction, and intersection of solid objects. Boolean operations on solids are also called (topological) classification. Support for non-manifold objects implies that some classifications, namely the Subdivide operation, produce composite rather than \u201cmonolithic\u201d objects. Consider, for example, the subdivision of the region of interest  by two surfaces and in . In addition to surfaces and , the resulting model contains three layers , , and  that replace the original block.","Many geometric computations run in \u201cinteractive time\u201d, that is, they are completed in less than a few seconds. Boolean operations involving meshes composed of on the order of half a million triangles, however, may take in the order of minutes.","Transformation of a single object is very fast; transforming the same object, if it forms a piece of a larger assembly, may take considerably more time due to the required re-classification.","GQI\/SHAPES implements a geometry modeling system that supports representation and computation of non-manifold objects. GQI\/SHAPES provides a C-language API with encapsulated abstract data types. Extensibility is given through the SHAPES attribute mechanism that allows applications to register callbacks with attributes. The callbacks that are triggered as classification algorithms change the states of their associated objects. GQI\/SHAPES defines a proprietary file format for persistent storage.","High-level 3D graphics systems are libraries that encapsulate shape and attribute representations, rendering methods, and interaction methods. Commercial products include OPEN INVENTOR, IRIS PERFORMER, HOOPS, RENDERWARE, COSMO 3D and others. The model uses OPEN INVENTOR, an extensible, object-oriented 3D graphics library. Applications use OPEN INVENTOR calls to create 3D objects and arrange them in a directed acyclic graph (DAG), the so-called scene graph.","For example, the two rectangles with a shared edge illustrated in may be represented by a scene graph, as shown in . (\u201cScene graph\u201d is also written herein as one word \u201cscenegraph\u201d.) The traversal order in the scene graph is top-to-bottom and left-to-right. A group node , is the beginning of the traversal. A next node  establishes a material property, namely a color (grey). Node  establishes the beginning coordinates of the image and node  establishes an \u201cIndexedFaceSet\u201d, or index of the vertices of the left-hand rectangle. Node  changes the value of the color material property to grey and node  establishes an \u201cIndexedFaceSet\u201d for the right-hand triangle. When this scene graph is traversed, the image shown in is displayed on the screen.","A specific set of classes, called actions, allow applications to create objects that traverse a scene graph and perform operations on its nodes. For example, there is a render action to display the objects in a scene graph, a search action to find objects in a scene graph, etc. The role of the scene graph is to define a traversal order. Actions are used wherever operations must maintain a state that is not stored in the objects but is a side-effect of the operations performed during traversal. For example, the scene graph in  contains one Coordinates node  whose coordinates are shared by two IndexedFaceSets. During traversal an array of \u201ccurrent coordinates\u201d is maintained. Each IndexedFaceSet represents one rectangle and contains the indices of its corner coordinates. Similar to coordinates, Material values remain active until overridden by a new Material node. Consequently, in , the first rectangle is drawn in a darker shade of gray than the second.","Another set of classes, called sensors, can be used to monitor nodes and sub-graphs of a scene graph. Applications can associate callbacks with sensors that are triggered each time the state of the \u201csensed\u201d object changes.","Open Inventor objects include implicit shapes such as boxes, spheres, and cylinders, as well as parametric shapes such as NURBS curves and surfaces, and triangle meshes. While it is possible to create and display shapes, there is no support for geometric computations other than coordinate transformations and ray-object intersections. These operations typically run fast and are dominated by rendering time if re-rendering is required. Interactive work is possible as long as achievable frame rates support it. For example, if a scene can be rendered in 0.1 seconds, an object can be moved around the scene at 10 frames per second.","There are a few important requirements which are met by the IGM's integration of a geometry and a graphics subsystem. First, the IGM provides a consistent, object-oriented interface for interactively constructing, rendering, editing and manipulating 3D objects. Second, the IGM is light-weight in terms of overhead. Each sub-system by itself is complex and integration minimizes additional overhead and does not degrade performance. Third, the interface is customizable and extensible.","In addition, there are three major issues described in the above overviews of the geometry and graphics systems which are addressed by the IGM. They are a mismatch in the representations of geometric objects in either system, a mismatch in the representation of object attributes, and a discrepancy in processing speed.","Object representations in the geometry system and in the graphics system do not match. While objects in the geometry system are connected explicitly through a topology graph, as shown in , graphics objects are merely ordered in a scene graph, as shown in .","Further, in earth models, many surfaces are shared as boundaries between adjacent objects and, consequently, serve two roles in the geometry system. First, they are objects in their own right, used to build an earth model by subdividing some region in space. Second, they are bounding surfaces of rock layers, and as such they are parts of layer objects. In the graphics system, when an earth model is rendered, it may be rendered as a set of surfaces or as a set of layers, or a mix of both. When rendering a set of layers, shared surfaces are rendered only once for good performance.","As a consequence, there is no one-to-one relationship between geometric objects and graphic objects. Rather, the graphic objects must be transient representations of geometric objects which potentially leads to data replication when two representations of object data must be maintained. Further, data replication requires data consistency control to guarantee that, as one representation of an object changes, its other representation is updated as well. Attributes in the geometry system are directly associated with objects or pieces of objects, such as color attributes  and  in . Attributes in the graphics system are not explicitly associated with geometric objects. Rather, they are \u201cautonomous\u201d objects in a scene graph, such as nodes  and  in , that affect the rendering state and thus, indirectly, control the appearance of rendered shapes.","The IGM supports interactive work with complex geometric models. It is possible to monitor the changes that users make to the graphics representation of objects, requiring users to \u201ccommit\u201d any changes to the geometric representation when desired. Consider the examples in . To subdivide a region of interest  with surfaces and , the surfaces must first be positioned correctly. This could be done interactively by manipulating the graphics representations of the surface geometries only. In this phase, the geometry model is not consistent with what is visible on the screen. Next, a classification is performed to incorporate the surfaces into the geometric model. After this process, which may take some time, the geometry model  and the rendering on the screen  are again consistent.","Both the graphics system and the geometry system may be extensible systems. The primary design choice in integrating the two systems is whether to view one system as the primary system and extend it by functionality found in the other, or to create an integration layer on top of both subsystems. The model uses the latter approach. With an integration layer integrating the graphics system and the geometry system, either subsystem can be replaced, if necessary, a clear separation exists between graphics and geometry operations, and it is possible to have a distributed implementation in which each subsystem runs on a different host.","The integration layer is implemented in C++. The next design choice is whether to use multiple inheritance or object aggregation. With multiple inheritance, the grandchildren inherit a child's parents without access to any of their other descendants. It was desired to model \u201ccousin\u201d-relationships where descendants in one hierarchy are associated with descendants in other hierarchies, and therefor, multiple inheritance is not appropriate.","Further, the preferred embodiment does not completely encapsulate the subsystems but rather exposes them to applications. This minimizes overhead, because it leaves objects accessible for operations that are specific to their respective subsystems, while allowing applications to manage only the objects defined in the integration layer. Data consistency control helps to avoid the consequential creation of inconsistencies between the subsystems.","The model uses \u201cobject aggregation\u201d in the design of the integration layer. An \u201cAggregateObject\u201d class  encapsulates the common aspects of a GeometryObject representation  and a GraphicsObject representation  of an object, as shown in . Lines  and  denote one-to-many relationships, represented by a line with an arrow on one end, with the \u201cone\u201d relationship being at the end with the arrow. For example, line  indicates that a single Application  manages a plurality of AggregateObjects, one of which is AggregateObject  (the others are not shown). Lines ,  indicate one-to-one relationships. In the example shown, AggregateObject  has one GraphicsObject , and one GeometryObject . The GraphicsObject class may include multiple graphic views  and  of the same GeometryObject.","The \u201cIgmAction\u201d class , shown on , encapsulates methods required either to traverse a topology graph and generate appropriate graphics representations or to traverse a scene graph removing obsolete GraphicsObjects or to generate a GeometryObject.","A GeometryObject class hierarchy provides C++ wrappers for geometric objects in the geometry subsystem, as shown in . At the top of the tree, the IgmObject  is the GeometryObject base class. The gmGeometry class  (the underscore in variable names shown in the Figures, such as the one between \u201cgm\u201d and \u201cGeometry\u201d in , is left out in the text portion of the specification) is a sub-class of the IgmObject, sub-classing being represented by a line with an arrow-head, such as line . The gmGeometry class has two sub-classes, gmFeature  for features and gmCell  for cells, with the sub-classing indicated by a line . The gmFeature class and the gmCell class store The GQI handles to features and cells, respectively. The gmFeature class has a number of sub-classes, including gmPlane  for a plane, gmBox  for a box, gmweb  for a web, gmISP  for an ISP, and others , with the sub-classing indicated by a line .","The GraphicsObject class hierarchy describes objects that can be rendered on the screen, as shown in . The GraphicsObject class is responsible for rendering GeometryObjects and handling graphical interactions. At the top of the GraphicsObject tree is an OPEN INVENTOR's SoWrapperKit , which provides a mechanism to build and manage scene sub-graphs. Typically, those subgraphs contain attribute and shape nodes. Thus, SoWrapperKits associate attributes and shapes, providing a simple way to handle the attribute representation mismatch between the graphics and geometry subsystems. An oiBaseKit  is a sub-class of the SoWrapperKit, as indicated by a line . The oiBasekit has a number of sub-classes including an oiFeature class , an oiCell class  and oinongmBasekit class , with the sub-classing being indicated by a line . The oiFeature class has a number of sub-classes, including an oiBox class , an oiweb class , an oiISP class , and other classes , the sub-classing being indicated by a line . Further, the oinongmBaseKit, which renders objects that are not part of the geometry model, has a number of sub-classes , the sub-classing being indicated by line .","Graphics objects, except those graphics objects that are not part of the geometry model, contain a scene graph representing the current rendering of their corresponding GeometryObjects, such as that shown in . For example, the GraphicsObject for an ISP model may contain a scene graph populated with GraphicsObjects representing its constituent features. Applications add GraphicsObjects to their own scene graph to render the desired portions of a geometry model. Usually, the application adds the GraphicsObject of a new unclassified object to the scene graph. After classification, the new object becomes part of a composite object and its \u201cstandalone\u201d representation is removed from the scene graph. The GraphicsObject for the ISP model is either added to the scene graph or is updated if it already had been added.","Changes made to the GraphicsObject through user interaction can be monitored by Open Inventor sensors. Sensors can trigger callbacks that notify an AggregateObject of the change. Users interact with GraphicsObject via an IGM interactor. The changes are graphical only until the user is satisfied, and the application notifies the AggregateObject to update the GraphicsObject and propagate the changes to the GeometryObject.","GraphicsObjects do not need to be as specialized as GeometryObjects although specialization is possible where required. In many cases, the generic GraphicsObject suffices to encapsulate the required functionality. Exceptions include objects for which a pure graphical representation exists that is not constructed from a GeometryObject, for example, surfaces built from extruded curves before they have been classified; and objects that require special interaction, such as web surfaces, which require special interactions to edit or deform.","The AggregateObject class hierarchy represents integrated objects, as shown in . At the top of the AggregateObject class tree is the IgmObject  which was also at the top of the GeometryObject class hierarchy (see ). An agBaseClass  is a sub-class of the IgmObject class , with the sub-classing being indicated by a line . The agBaseClass class has two sub-classes: a agGeometry class  and a nagBaseClass class , the sub-classing being indicated by a line . The agGeometry class has two sub-classes, an agFeature class  and an agcell class , the sub-classing being indicated by a line . The nagBaseClass , which represents objects that are not part of the geometry model, has a plurality of sub-classes , the sub-classing being indicated by a line . The agFeature class has a number of sub-classes, including a agPlane class , an agBox class , an agweb class , an agISP class  and other classes , the sub-classing being indicated by a line .","AggregateObject represents the integration of data and methods shared between GraphicsObject and GeometryObject. For example, the agPlane object together with its corresponding GraphicsObjects and GeometryObjects form a class hierarchy, as shown in . Most of the hierarchy is extracted from the class hierarchies illustrated in . The association between the aggregate class and the graphics class, represented by a line , and the association between the aggregate class and the geometry class, represented by line , have been added and represent the aggregation.","AggregateObjects can be constructed from object parameters, for example, a point and the normal of a plane. The AggregateObject class provides methods to construct its corresponding GraphicsObjects and GeometryObjects. Applications control when to create the subobjects.","Alternatively, AggregateObjects can be constructed from existing GraphicsObjects or from existing GeometryObjects. This allows applications to import objects from packages that provide only the equivalent of graphics representations (for example, other OPEN INVENTOR applications). More importantly, it allows applications to use GeometryObjects representations, complete with shape, topological, and attribute information, for persistent storage. Typically, AggregateObjects and GraphicsObjects are created on the fly when GeometryObjects are loaded from persistent storage.","The three class trees are similar but have some differences. For example, the three class trees are of different depths. All three classes support dynamic type checking.","The IGM defines a number of standard objects in addition to the generic GraphicsObjects, GeometryObjects, and AggregateObjects. For example, the GeometryObject class hierarchy contains many sub-classes because they encapsulate the different objects that can be modeled with the geometry system. The GraphicsObject hierarchy contains fewer objects because many GeometryObjects can be rendered using generic methods. For example, there is a specific GeometryObject for a plane,  in , but no specific GraphicsObject, as shown in . Other objects such as meshed surfaces and composite objects require support for interactive editing which is implemented in specialized GraphicsObjects. Composite objects may become fairly complex and are encapsulated in a special class that manages updates on a per-component basis.","Applications instantiate and manage AggregateObjects, as shown in . AggregateObjects also provide graphics and geometry operations through calls  to the AggregateObject which are then delegated to the appropriate subobjects, either the GraphicsObject , through delegation path  or to the GeometryObject  through delegation path , as shown in . Applications also have read-only access to GraphicsObjects and GeometryObjects through call paths  and , respectively, to perform operations that do not affect system consistency, as shown in . Through this exposure, the requirement of minimal overhead can be met because replication of GraphicsObject or GeometryObject methods in AggregateObject is minimized.","Special classes, illustrated in , whose root class is mpMap  (which is itself rooted in the Igmobject class  as shown by line ) implement the necessary data format translations and mappings from physical properties to renderable attributes. For example, an mpColorMap class , sub-classed from the mpMap class as shown by line , and mpCLutMap class , sub-classed from the mpColorMap class  as shown by line , provide color maps that can be indexed in a number of ways. An mpCLutDoubleMap class , sub-classed from the mpCLutMap class as shown by line , provides methods to map colors to ranges of double precision floating point numbers. There are other classes,  and , sub-classed from the mpMap and mpCLutMap classes, respectively.","GeometryObject uses the callback mechanism available through GQI\/Shapes attributes the same way GraphicsObject uses Open Inventor sensors: AggregateObject is notified of changes to the state of a geometry object.","The AggregateObject fulfills a number of tasks, two of which, consistency control and data conversion management, will be discussed in more detail. The tasks are:\n\n","The two subsystems being integrated by the IGM are not always consistent, that is, they sometimes have inconsistent representations of the same geological data. Often, the two subsystems are intentionally left inconsistent for the duration of an extended edit operation to improve performance.","There are a finite number of possible \u201cvalid\/invalid\u201d states for the two subobjects, and AggregateObject can be treated as a finite state machine with the two subobjects as state variables, as shown in . Subobjects can be either \u201cvalid\u201d or \u201cinvalid\u201d, depending on whether or not they represent the result of the last user interaction. AggregateObject monitors and manages the transition from one state to another, thus managing consistency and addressing the issue of processing speed discrepancies.","The state machine operates by changing states in response to a variety of events. Assume that both the GraphicsObject and the GeometryObject are valid, which means that the system is in state . The left half of a box representing a state, such as state , is shaded or unshaded if the GraphicsObject is valid or invalid, respectively. Similarly, the right half of the box is shaded or unshaded if the GeometryObject is valid or invalid, respectively. Both halves of the box representing state  are shaded, indicating that both the GraphicsObject and the GeometryObject are valid.","Now assume that the GraphicsObject changes. An example of such a change would be an application picking a graphics object and moving it without committing to the move. Such a change is represented by transition  to state , in which the GraphicsObject is valid but the GeometryObject is invalid. The system does not transition out of this state if the GraphicsObject is further changed, as indicated by transition .","If the change to the GraphicsObject is committed causing the change (such as classifying a moved surface) to be made in the GeometryObject, or if a GeometryObject is created, the system transitions  back to state , in which both the GraphicsObject and the GeometryObject are valid. If, instead, a parameter is changed, the system transitions  to state , in which both the GraphicsObject and the GeometryObject are invalid. Further setting of or changes to the parameters leave the system in state .","The system can leave state  under two circumstances. If the system creates a GraphicsObject, the system transitions  back to state , where the GraphicsObject is valid and the GeometryObject is invalid. If, instead, the system creates a GeometryObject, the system transitions  to state , where the GraphicsObject is invalid and the GeometryObject is valid. The system remains in state  for further changes in GeometryObject . If the GraphicsObject is updated or a GraphicsObject is created, the system transitions  to state . If, instead, a parameter is changed, the system transitions  from state  to state , where both the GeometryObject and the GraphicsObject are invalid.","Consider the example in  where the user positions new surfaces on the screen. The graphics representations of the surfaces are valid since they have the shape and position intended by the user. The geometric model is invalid because the objects overlap existing objects without establishing topological relationships between them. Thus, the system is in state . Once the user commits to the change, the system transitions  to state , changing the geometry and updating the graphics.","Methods that perform complex conversions between GeometryObject and GraphicsObject are implemented as their own classes and their base class is called IgmAction , as shown in . IgmAction includes ggAction (and its subclasses) that are used to generate graphics from geometry. A gmobject, with the help of an agobject or an oiobject, generates a geometry object (a gqi instance) from a graphics object. ggAction objects, which are derived from the igmObject class, can traverse a topology graph, performing desired operations and calling methods on individual objects as appropriate. ggAction is a component that handles the aspect of geometric object representation mismatch between the sub-systems. It is used by AggregateObject to support consistency management.","An example is an IgmAction that can create or update GraphicsObjects from GeometryObjects according to several different rendering modes, depending on which GraphicsObjects will contain different attributes and shapes to render. Rendering modes include:\n\n","The management of rendering modes illustrates that GraphicsObjects are visual representations of their corresponding GeometryObjects. As described above, there is no one-to-one relationship between the two object types. For example, which shapes are rendered by a GraphicsObject representing a volume depend on adjacent objects and the presence of clipping planes.","Not all objects to be displayed in a 3D view are necessarily objects forming, or intended to form, part of a geometry model. Examples include text, symbols, and glyphs. In addition, many applications work with data that have a geometric interpretation which is rendered but is not part of a geometry model. An example from earth science is a borehole trajectory that may be rendered for reference only. The IGM provides agBaseClass  () from which nagBaseClass  for such \u201cnon-geometry-model\u201d objects is derived. The equivalent GraphicsObject of nagBaseClass is oinongmBaseKit  ().","This approach allows applications to manage one generic type of objects regardless of whether they are to be used for the geometry model. For example, a SceneManager class can be written that keeps track of objects that are displayed or hidden in one or more application windows. In addition, sub-classes of nagBaseClass can encapsulate the bindings of GraphicObjects to entities stored in a database.","The present invention may be implemented in hardware or software, or a combination of both. However, preferably, the present invention is implemented in computer programs executing on programmable computers each comprising a processor, a data storage system (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. Program code is applied to input data to perform the functions described above and generate output information. The output information is applied to one or more output devices, in known fashion.","Each program is preferably implemented in a high level procedural or object oriented programming language (such as C++ or C) to communicate with a computer system. However, the programs can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or an interpreted language.","Each such computer program is preferably stored on a storage media or device (e.g., ROM or magnetic\/optical disk or diskette) readable by a general or special purpose programmable computer, for configuring and operating the computer when the storage media or device is read by the computer to perform the procedures described herein. The inventive system may also be considered to be implemented as a computer-readable storage medium, configured with a computer program, where the storage medium so configured causes a computer to operate in a specific and predefined manner to perform the functions described herein.","Attention is directed to  where a first volume  and a second volume  is separated by a surface cell . To the right of the volume cells  and  are a series of note interpretations indicated by a surface feature  which corresponds to surface cell . The surface feature node  contains nodes MP , MB  and face  that are the graphics content without color material. The volume cell  has a node representation of volume  having MP , MB  and face . Some of the second volume  having note representation that is headed off with a volume  node of . The MP , the MB  and face .",{"@attributes":{"id":"p-0138","num":"0144"},"figref":["FIG. 17","FIG. 16","FIG. 16","FIG. 17","FIG. 17","FIG. 17"],"b":["428","430","429","432","438","444","450","432","438","444","434","440","446","436","442","448"]},{"@attributes":{"id":"p-0139","num":"0145"},"figref":["FIG. 18","FIG. 18","FIG. 18","FIG. 18","FIG. 18","FIG. 18","FIG. 18","FIG. 18"],"i":["a ","a ","b","a","a","a ","b","a"],"b":["1","452","1","456","2","454","2","458","1","460","1","464","2","466","2","462","3","468","470","486","472","1","474","2","476","1","460","2","462","1","480","2","482","3","484","1","464","2","466","3","468","488","490","492","494","452","454","456","458","474","476","480","482","484","470","486"]},"The present invention replaces the low level GQI C-structure mechanisms of the other implementations with a new framework. To further improve performance, the core gmMP framework classes described above no longer have any dependencies on the IGM. The present invention is composed of a set of object instances that are implemented as software on, for instance, a digital computer. However, the present invention is amenable to being implemented completely in hardware, or some combination of hardware and software.",{"@attributes":{"id":"p-0141","num":"0147"},"figref":["FIG. 20","FIG. 20","FIG. 20","FIG. 20","FIG. 20"],"b":["2002","2004","2006","2008","2010","2012","2014","2014","2016","2026","2020","2016","2026","2016","2020","2018","2022","2018","2022","2024","2024","2016"]},{"@attributes":{"id":"p-0142","num":"0148"},"figref":["FIG. 21","FIG. 21","FIG. 21"],"b":["2022","2104","2150","2106","2150","2118","2106"],"sub":["\u2014","\u2014"]},"A gmMPConstant object  has an IsA relationship with the gmMP object . A gmUtilFtrBndPolicy object  has an IsA relationship with the gmMPGQIPolicy object , as illustrated in . Several other policy objects, including the gmSysPSPPolicy object , the gmSysRulesPolicy object , and the gmMPVolumePropertyPolicy object , all have IsA relationships with the gmMPPolicy object  as illustrated in . In addition, the gmSysPSPPolicy object  has a policy composition relationship with the gmSysPSPProperty object . Similarly, the gmSysRulesPolicy object  has a policy composition relationship with the gmSysRules object . The gmUtilFtrBnd object  is the last of the group and it, along with gmSysRules  and gmSysPSPProperty object , have an IsA relationship with the gmMPConstant object . The gmMPVolumePropertyPolicy object  also has a composition relationship with the gmMPConstant object , as illustrated in . Finally, the GQI Material Property Framework  also optionally includes a gmutilstatus object  and mvvt object  and a gmmpatoms object , all of which facilitate the interactions and relationships in the storing and the processing of information for the present invention.",{"@attributes":{"id":"p-0144","num":"0150"},"figref":["FIG. 22","FIG. 22","FIG. 22"],"b":["2022","2018","2018","2228","2230","2234","2232","2236","2230","2232","2236","2238","2240","2242","2120","2216","2218","2220","2216","2222","2224","2226","2216","2222","2224","2226","2104","2018","2204","2104","2022","2206","2208","2210","2212","2214"]},{"@attributes":{"id":"p-0145","num":"0151"},"figref":["FIG. 23","FIG. 23","FIG. 23"],"b":["2022","2018","2108","2234","2108","2022","2116","2228","2018","2116","2116","2216","2206"]},{"@attributes":{"id":"p-0146","num":"0152"},"figref":["FIG. 24","FIG. 24","FIG. 24","FIG. 24","FIG. 24"],"sub":["\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014"],"b":["2204","2018","2408","2406","2204","2402","2204","2412","2402","2410","2104","2412","2410","2414","2104","2106","2104","2416","2106"]},"Referring to , the material property framework classes may be grouped into four categories. The system classes (, , , , , , , , , , , , and  of ) support the operation of the GQI (e.g., point set preservation, feature boundary tracking). The IGM classes (, , and  of ) (e.g., feature back pointers) must be isolated from the system classes because they have dependencies on the IGM. The system classes are strictly limited to internal use and should not be derived from or instantiated by applications. The application support property classes (, , , , and  of ) implement the basic mechanisms required by applications (and system components) for attachment, invariant maintenance, and evaluation. They may be derived from and, in some cases, used directly by applications. It is preferable that the system classes also be derived from these application support classes. Finally, the fourth set of classes, the application classes (, , , , , , , , , , , , and  of ) are intended to be used by applications for the direct representation of material properties.","The gmMP class  of  define the basic behavior of the material property representation classes. It directly supports the following capabilities:\n\n","The gmMP base class  also provides the data structures used by the above methods to manage all instances of the derived classes and to support the necessary lookup capabilities.","The gmMPPolicy abstract base class  implements the following behaviors:\n\n","The gmMPTopologyTraversalState  of  implements several generators for different property propagation policies and behaves like an iterator to conduct the traversal while maintaining the state of a traversal. The generators that are supported include:\n\n","A Shapes attribute, designated \u201cmp XATTR\u201d  and  of  establishes the mapping between a Shapes entity gqiAttachmentSite  and the corresponding gqiMetaProperty instance . As can be seen from , the earlier C-structure based scheme has been replaced with direct reference to gmMP instances .","In the preferred embodiment of the present invention, the core no longer manages event handlers. In prior art practice, it was determined that the event handlers were not independent. Instead, the event handlers clustered into a few sets of related handlers. According to the present invention, the prior art event handlers are now represented by gmMPPolicy instances  (see ). Because the gmMPPolicy  has no persistent state (the traversal state must be multiply-instantiated, if re-entrant traversal were to be supported), a singleton pattern is used to minimize the number of event handler virtual function tables.","The evaluators for the present invention are implemented as virtual functions in the gmMP  (e.g., sub functions) and classes derived from gmMP . A pattern similar to the singleton gmMPPolicy  may be used to represent the evaluators for gmMP  derived classes as the number of evaluators grows. However, the gmMP  instances are shared by each attachment site to which a particular \u201cproperty instance\u201d is propagated.","The design of the objects of the present invention isolate the two behaviors mentioned above into two new pairs of classes:","Point Set Preservation",{"@attributes":{"id":"p-0156","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["gmSysPSPProperty  carries the attachment semantics for point set preservation (\u201cPSP\u201d). The top level attachment site for gmSysPSPProperty  is the model core itself. If more than one core exists, multiple PropertyDI's are generated and each core is considered to have a separate attachment. There is no other persistent state for this property.","gmSysPSPPolicy  of  implements the propagation policy and edit callbacks for PSP.\n\nRules\n","gmSysRules  of  carry the attachment semantics for \u201cCore\u201d and \u201cFeature\u201d attached rules sets. The state of these property instances consists of the actual rule attachments and their firing state. The state of rules (which framework rules are attached and the rule violations) are managed by evaluation operations on the gmSysRules property instances . Firing rule resolvers are distinct operations implemented only by the gmSysRules class .","gmSysRulePolicy  implements the propagation policy and edit callbacks for the rules, including firing the rule detectors.\n\nProperty DI and Attachment Semantics\n"]}}}},"The Property (Parameter) data item provides very specific user-visible semantics as illustrated in the following example. A property of specified PropertyCode, Name, Modifiers (and other attributes supporting Log Curve Naming convention) have been attached by a user (or an application acting on behalf of the user). These attributes permit user discrimination among multiple similar properties on a given site.","A gmMP data member  having a parameter called TopLevelSite stores the original site to which a top level attachment is made. If an attribute of a gmMP instance  (e.g., default, or value) is modified, one must create a copy of the gmMP instance  if the site associated with the modification is not the top level site.","The following policy is established for use of Property (Parameter) data item and attachment sites:\n\n",{"@attributes":{"id":"p-0160","num":"0189"},"figref":["FIG. 19","FIG. 19","FIG. 19"],"b":["1","496","2","500","3","502","4","498","1","4","504","1","2","506","2","3","510","4","3","508","4","1","512","2","1","516","514","3","1"]},"Callback Scheme",{"@attributes":{"id":"p-0161","num":"0190"},"figref":["FIG. 26","FIG. 26"]},"As illustrated in , there are three main sets of objects on the left and middle portions of . As mentioned above, the objects cover three general aspects: geometry, features, and cells. As a matter of notation convention an acronym for the general category appears before the specific aspect of the object. For example, \u201cag\u201d stands for aggregate; \u201cgm\u201d stands for geometric modeling; \u201coi\u201d stands for OPEN INVENTOR, a graphics engine; gqi stands for geometry query interface; and \u201cX\u201d stands for XOX\u2014Shapes, the geometry engine.","Referring to , first, there is the agBaseClass  (see ) that has an IsA relationship  with the agGeometry object  as illustrated in . The gmGeometry object  is in a hasA relationship  with the agGeometry object  and has another relationship  with the gqiGeometryt object .","An instance of the aggregate feature object agFeature and an aggregate cell object agCell are associated with the aggregate geometry object agGeometry  through IsA relationships  and , respectively, as illustrated in . An open inventor feature object instance oiFeature is operatively related to the agFeaturethrough association . Similarly, the open inventor cell object instance oiCell is operatively connected to agCell via association .","The geometric modeling object instances gm Feature and gm Cell are operatively connected to agFeature and agCell via associations  and , respectively. In addition, the gmFeatureobject  has a relationship  with the gmGeometry object . The gm Cellobject similarly has a relationship  with the gmGeometry object , as illustrated in .","An XFeatureobject  is provided with the present invention as illustrated in . The XFeatureobject  has a relationship  with the gmFeatureobject . The XFeatures object  has a relationship  with the xAttrFtr object  which, in turn, has a relationship  with the gqiFeatureobject . The gqiFeatureobject , in turn, has a relationship  with the XFeatureobject . The XCellobject  has a relationship  with the XFeatureobject  (and the XFeatureobject  has a relationship  with the XCellobject ) as illustrated in .","The XFeatureobject  has an association  with the gqiGeometryt object  as illustrated in . The XFeatureobject  also has a relationship  with the xAttrMP object  which, in turn, has a relationship  with a first gqiMetaPropertyinstance object  The first instance of the gqiMetaPropertyobject  is for features and can have a set of objects in association  with it, such as object  and one or more instances of the FtrRefobject  as illustrated in . The FtrRefobject  facilitates the callback functionality of the present invention through relationships  and  with the gm Featureobject  as illustrated in .","The cell objects have a parallel instance of the gqiMetaProperty object, namely gqiMetaPropertyobject . In this aspect of the present invention, XCellobject  has a relationship  with the xAttrMP object . The xAttrMP object , in turn, has a relationship  with the second instance of the gqiMetaPropertyobject  as illustrated in . As with the first instance of the gqiMetaProperty, the second gqiMetaPropertyobject  has an association  with various objects, such as object  and CellRefobject . The callback operations of the present invention (for cells) are facilitated by relationships  and  with the gmCellobject . As with the XFeatureobject , the XCellobject  has a relationship  with the gqiGeometryt object  as illustrated in . Finally, the XCellobject  shares relationship  and relationship  with the XFeatureobject  as illustrated in .","The present invention can be described as a method for interactively editing a model that is implemented on a computer comprising a processor, a data storage system, at least one input device and at least one output device, including, but not limited to, a computer monitor, storage device, or print-out. The model is preferably stored on a computer-readable media. The model itself has at least a first surface, although many surfaces are typically modeled.","A general indication of the capabilities and flexibility of the structure of the present invention will be evident from the following example.",{"@attributes":{"id":"p-0171","num":"0200"},"figref":["FIG. 25","FIG. 25","FIG. 25"],"b":["1","2501","2502","2520","2503","2504","1","2503"],"sub":["\u2014","\u2014"]},"From the gqiFeature object , a group add child method  is invoked to affect the XOX Shapes object  as illustrated in . The XOX Shapes object  then invokes a class group add child callback method , which has as its parameters IAF, H, and an IAF attribute, onto the gqimetaProperty object  as illustrated in . The gqiMetaProperty object  also invokes an attribute get pointer value method , which takes as a parameter a vAttr variable, onto a XOX handle object , the instantiation of which is labeled IAFattr. Thereafter, an add child callback method  is invoked by the gqiMetaProperty object  onto a gqiMetaProperty instance called IAFmeta  as illustrated in . The add child callback method  takes as its parameters IAF, H, and the IAF attribute. The IAFmeta instance of the gqiMetaProperty  invokes two methods. First, a get policy method  is invoked on the C1PSP instance of the gmSysPSPProperty object . Second, an add child callback method, having IAF, Hi, and the IAF attribute as parameters, is invoked on the gmSysPSPPolicy object  as illustrated in . Finally, an attach to method  is invoked by the gmSysPSPPolicy object  onto the C1PSP instance of the gmSysPSPProperty object .","A more generalized description of the methods of the present invention, in contrast to the specific example above, are illustrated in . The specific steps illustrated in those Figures are described in the accompanying description.","According to , the method begins generally at step . The method continues in step  by loading data about the first surface feature from a database that is stored in the data storage system into memory (random access memory or system or system memory) of a computer system. Next, in step , an aggregate feature is created for the first surface feature. This enables the creation of a first graphics object from the aggregate feature, step . Thereafter, the first graphic object is added to the application scenegraph, step . Next, in step , a geometry object is created for the aggregate feature. The first surface feature in the model is then edited as desired, step . Once editing is complete (e.g., the user opts out of edit-mode, or a requisite period of time elapses), the graphics for the model are selectively updated, step . The selective update relieves the various devices from recalculating and displaying all updates and changes. Instead, only those updates that affect what the user experiences are updated. Finally, the first graphics object of the first surface feature is removed from the application scenegraph, step .","Editing and Updating","The process of editing itself is composed of several steps. Referring to , first, one must provide an interface, step . Next, in step , an IGM that is operative with the interface must also be provided. It is helpful to include a GQI that is operative with the IGM. This enables the user, through the interface, to select an operation to perform on a second surface feature, step . The interface is designed to inform the IGM of the user's selection, step . The operation itself is invoked with the GQI, step . During the editing process, step , it is necessary to perform at least one callback from the GQI to the IGM during execution of the operation. The callback is used to update the graphics object of the model to refresh the output device. Editing can be accomplished via irregular space partitioning, although other techniques of editing are possible with the present invention. Once the editing is complete, the updating of the graphics can commence, typically by creating the graphics object, step .","As illustrated in , the present invention has a special feature wherein the step of updating  includes updating graphics only those cells that have changed according to a defined criteria such as geometrical and\/or topological, step . The updating step may also include the referencing of a visibility finite state machine, step . The visibility finite state machine aids in managing of the graphics object's updating operations and the graphics object's visibility updating operations. Use of the visibility finite state machine enables the updating of only those graphics objects that are designated as visible (to the user). The visibility finite state machine can be used to designate a graphics object as visible, and also to check on the validity of the graphics object. If the graphics object is valid, step , then the graphics object can be added to the scenegraph, step . Otherwise, the graphics object can be updated and then added to the scenegraph, step  as illustrated in ","The process of updating can encompass several steps. For example, updating may include checking the state of each feature in the scenegraph, as illustrated in steps \u2013 of . Generally, if the graphics of the feature are valid, step , then the feature's graphics object is not updated, step . However, if the feature's graphics are invalid, step , and the geometry is valid, step , then the graphics object of the feature is updated, step  as illustrated in ","Another form of updating can include checking the state of each cell in the scenegraph, as illustrated in . In this scenario, if the graphics for the cell are valid, step , then the graphics object of the cell is not updated, step . If the graphics of the cell are invalid, step , and the geometry for the cell is valid, step , then graphics object of the cell is updated, step .","The method of the present invention may also encompass those situations where a second surface feature is not contained within the model, although the second feature can, of course, be contained within the model.","Creating Graphics","The method of the present invention also involves the creation of graphics for various entities, such as an aggregate feature, as illustrated in . Typically, this process involves obtaining all relevant surface features in the model, step . Then, for each of the relevant surface features, if that surface feature has a graphics object, step , then that graphics object is updated, step . Otherwise, a graphics object for the surface feature is created, step . Afterward, the graphics object for the surface feature is added to a surface scenegraph root node, step , and the method of  ends generally at step .","In addition to the steps outlined in the preceding paragraph, other steps may optionally be accomplished, as illustrated in . For example, the aggregate objects of all two-dimensional cells for the surface feature may be obtained, step . Next, the aggregate objects of each of the cells can be prompted to obtain at least one valid graphics object and to add that graphics object to a sub-scenegraph of the surface feature, step . Once that is completed, the graphics object of the surface feature can be validated, step , and the method ends generally at step .","Still more steps may be taken for the method outlined immediately above, as illustrated in . For example, the step of obtaining valid graphics object for a cell can include a check to determine if the graphics object for the cell does not exist, step . If the graphics object doesn't exist, then the graphics object for the cell is created and validated, step . If the graphics object for the cell does exist but is not valid, then the graphics object for the cell is updated and validated, step .","Alternatively, the method of the present invention for creating graphics may also include creating graphics for at least one volume cell from the model, as illustrated in . This alternative method includes obtaining at least one relevant active volume cell in the model, step . Once obtained, a check can be made to ensure that the graphics objects of all of the two-dimensional cells of each volume cell have been created, step . Then, for each of the two-dimensional cells, aggregates can be obtained, step . A new aggregate can be created if the two-dimensional cell aggregate does not exist, step . Then each two-dimensional cell is checked to ensure that it has valid graphics, step . Thereafter, a graphics object can be created for each of the volume cells, step . Then, for each volume cell, the graphics content of each two-dimensional cells of the volume cell is added to the sub-scenegraph of the graphics object of the volume cell, step . Finally, the graphics object is added for each of the volume cells to the volume scenegraph root node, step . Additionally, an instantiation of a graphics content, without color material, that graphically represents a two-dimensional cell can be shared by at least one scenegraph containing a graphics object of a surface feature that has the two-dimensional cell as a child, as well as at least one of the scenegraphs that contains graphics objects of either one volume cell or two volume cells that have the two-dimensional cell as part of their boundaries.","Callbacks","The present invention makes extensive use of callback within the object framework. For instance, a callback can cause a change of state for the aggregate feature. Preferably, the aggregate features element is a consistency finite state machine, so that the callback is facilitated efficiently. It is also preferable that the consistency finite state machine manages the consistency between the geometry and the graphics. Callbacks are also useful for invalidating the graphics object for the aggregate feature and for validating the geometry of the aggregate feature. For example, if the callback is for a volume object, then a specific callback is used for the volume feature. Otherwise an edit callback for a surface feature is performed.","A callback can be performed in a number of ways. Generally, however, the callback is accomplished with a set of one or more objects. Generally, that set of objects includes a first geometry modeler feature object; a changed geometry object that is contained in the geometry modeler feature object; a first meta-property attribute object that is operatively associated with the changed geometry object; a first meta-property object that is associated with the first meta-property attribute; a second meta-property attribute object that is associated with the geometry modeler feature object; and a second meta-property object associated with the second meta-property attribute object.","The first meta-property object itself has a set of objects, such as a point set preservation property object; a point set preservation property policy object; a cell back pointer property object; an aggregate back pointer property policy object; a geometry cell object associated with the callback pointer object; an aggregate cell object associated with the geometry cell object; and a display cell graphics object associated with the aggregate cell object.","The second meta-property attribute object itself has a set of objects, includes a second point set preservation property object; a second point set preservation property policy object; a feature back pointer property object; a second aggregate back pointer property policy object; a geometry feature object associated with the feature back pointer property object; an aggregate feature object associated with the geometry feature object; and a display feature graphics object associated with the aggregate feature object.","Callbacks according to the present invention can come in a variety of configurations and circumstances. For example,  illustrates edit callbacks for a volume feature which includes registering the meta-property split callback class method with the geometry modeler interface, step . The geometry modeler interface is intended to be invoked when a volume split event occurs. Thereafter, in step , a first meta-property attribute is attached to at least one volume object that is contained by the volume feature. Then, in step , a callback is received from the geometry modeler interface that specifies a first volume object, a second volume affected by a change to the first volume object and the first meta-property attribute. A pointer value is then obtained from the first meta-property attribute which then allows the de-referencing of the pointer value to locate a first meta-property object, step . A split callback is invoked in the first meta-property object with the first meta-property attribute, the first volume object and the second volume object. This last step itself encompasses obtaining a first point set preservation property instance, step , and a first point set preservation policy instance from the property instance, step , as well as initiating a first split callback to the point set preservation policy instance with the point set preservation property instance, the first volume object and the second volume object. This last sub-step itself includes obtaining at least one containing feature for the first volume object, step , and initiating a feature add child update on the geometry modeler interface with the containing feature and the second volume object, step . Then, a cell back pointer property instance is obtained so that an aggregate back pointer property policy instance can be obtained from the cell back pointer property instance whereupon a second split callback is initiated to the aggregate back pointer property policy instance with the cell back pointer property instance. The latter callback itself includes obtaining a volume geometry cell object, step , from the cell back pointer property instance and initiating a cell split call to the volume geometry cell object. The latter sub-step may encompass initiating a call to the volume cell aggregate patron of the volume geometry cell object to invalidate the graphics of the first volume, step .",{"@attributes":{"id":"p-0189","num":"0218"},"figref":"FIG. 34","b":["3404","3406","3408","3410","3412","3414","3416","3418","3420","3422"]},"Yet another aspect of the method of the present invention involves performing an edit callback for a surface feature. This aspect of the method includes registering the meta-property split callback class method with the geometry modeler interface to be invoked when a surface split event occurs, step ; attaching a first meta-property attribute to at least one surface object contained by the surface feature, step ; receiving from the geometry modeler interface a callback specifying a first surface object, a second surface affected by a change to the first surface and the first meta-property attribute, step ; obtaining a pointer value from the first meta-property attribute and de-referencing the pointer value to locate a first meta-property object, step ; invoking a split callback in the first meta-property object with the first surface object, the second surface object and the first meta-property attribute, itself. The latter step includes obtaining a first point set preservation property instance, step ; obtaining a first point set preservation policy instance from the property instance, step ; and initiating a first split callback to the point set preservation policy instance with the point set preservation property instance, the first surface object and the second surface object. The latter sub-step itself includes obtaining at least one containing feature for the first surface object, step ; and initiating a feature add child update on the geometry modeler interface with the containing feature and the second surface object, step ; obtaining a cell back pointer property instance, step ; obtaining an aggregate back pointer property policy instance from the cell back pointer property instance, step ; and initiating a second split callback to the aggregate back pointer property policy instance with the cell back pointer property instance. The latter sub-step itself includes obtaining a surface geometry cell object from the cell back pointer property instance, step ; and initiating a cell split call to the surface geometry cell object. This latter sub-step includes initiating a call to the surface cell aggregate patron of the surface geometry cell object to invalidate the graphics of the first surface, step .",{"@attributes":{"id":"p-0191","num":"0220"},"figref":"FIG. 36","b":["3604","3606","3608","3610","3612","3614","3616","3618","3620","3622","3624"]},"Callbacks can have a number of effects on various objects of the present invention. For instance, performing the callback may cause a change of state for a cell. The change of state of the cell can be recorded in a consistency finite state machine.","Another aspect of the method of the present invention is the performing of an edit callback for a volume feature, as illustrated in . That aspect of the method of the present invention includes registering the meta-property merge callback class method with the geometry modeler interface to be invoked when a volume merge event occurs, step ; attaching a first meta-property attribute to at least one volume object contained by the volume feature, step ; receiving from the geometry modeler interface a callback specifying a first volume object, a second volume object, a surface object which formerly bounded the first and second volume objects and which has been removed from the model, and a meta-property attribute, step ; obtaining a pointer value from the geometry model attribute and de-referencing the pointer value to locate a first meta-property object, step ; and invoking a merge callback in the first meta-property object. The latter sub-step itself includes obtaining a first point set preservation property instance, step ; obtaining a first point set preservation policy instance from the property instance, step ; and initiating a first merge callback to the point set preservation policy instance with the point set preservation property instance, the first volume object, the second volume object, and the surface object. That latter sub-step itself includes obtaining at least one containing feature for the first volume object, step ; and initiating a feature remove child update on the geometry modeler interface with the containing feature and the second volume object, step ; a cell back pointer property instance is then obtained in step . Next, in step , an aggregate back pointer property policy instance is obtained from the cell back pointer property instance; and a second merge callback is initiated to the aggregate back pointer property policy instance with the cell back pointer property instance, the first volume object, the second volume object, and the surface object. The latter sub-step itself includes obtaining a volume geometry cell object from the cell back pointer property instance, step , and initiating a cell merge call to the volume geometry cell object. That latter sub-step itself includes initiating a call to the volume cell aggregate patron of the volume geometry cell object to invalidate the graphics of the first volume, step .",{"@attributes":{"id":"p-0194","num":"0223"},"figref":"FIG. 38","b":["3804","3806","3808","3810","3812","3814","3816","3818","3820","3822","3824"]},{"@attributes":{"id":"p-0195","num":"0224"},"figref":"FIG. 39","b":["3904","3906","3908","3910","3912","3914","3916","3918","3920","3922","3924"]},"Finally,  illustrates the step of performing a feature remove callback for a surface feature where a method includes registering the meta-property remove child callback class method with the geometry modeler interface to be invoked when a feature remove child event occurs, step ; attaching a second meta-property attribute instance to the surface feature, step ; receiving from the geometry modeler interface the remove child callback specifying the surface feature, a surface object and the second meta-property attribute, step ; obtaining a pointer value form the second meta-property attribute and de-referencing the pointer value to locate a second meta-property object, step ; and invoking the remove child callback in the second meta-property object with the second meta-property attribute, the surface feature and the surface geometry object. The latter sub-step includes obtaining a second point set preservation property instance, step ; obtaining a second point set preservation property policy instance from the second point set preservation property instance, step ; and initiating the remove child callback method of the second point set policy object with the surface feature and the surface geometry object. The latter sub-step itself includes removing the point set preservation property from the surface cell, step ; obtaining a feature back pointer property instance, step ; obtaining a second aggregate back pointer property policy instance from the feature back pointer property instance, step ; and initiating the remove child callback method of the second aggregate back pointer property policy instance with the surface feature, the surface geometry object and the surface feature back pointer property. The latter sub-step itself includes initiating an remove child notify call to the surface feature geometry object identified by the feature back pointer property instance. That latter sub-step itself includes initiating a call to the surface feature aggregate patron of the surface feature object to validate the geometry of the surface feature object, step ; and initiating a call to the surface feature aggregate patron of the surface feature object to invalidate the graphics of the surface feature object, step .","The present invention, therefor, is well adapted to carry out the objects and attain both the ends and the advantages mentioned, as well as other benefits inherent therein. While the present invention has been depicted, described, and is defined by reference to particular embodiments of the invention, such references do not imply a limitation on the invention, and no such limitation is to be inferred. The invention is capable of considerable modification, alternation, alteration, and equivalents in form and\/or function, as will occur to those of ordinary skill in the pertinent arts. The depicted and described embodiments of the invention are exemplary only, and are not exhaustive of the scope of the invention. Consequently, the invention is intended to be limited only by the spirit and scope of the appended claims, giving full cognizance to equivalents in all respects."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention and its advantages, reference is now made to the following description, taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 1 and 7"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIGS. 2","b":["5","5"],"i":["a ","b "]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIGS. 3","b":["4","4"],"i":["a ","b "]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 5","i":"c "},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIGS. 8\u201314"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIGS. 18","i":["a ","b "],"b":"18"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIGS. 27\u201340"}]},"DETDESC":[{},{}]}
