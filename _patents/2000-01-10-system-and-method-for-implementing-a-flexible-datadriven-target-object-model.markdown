---
title: System and method for implementing a flexible data-driven target object model
abstract: A method and system are disclosed for a flexible data-driven target object model which allows a client to gather and present information about objects on a target system independently of the target's operating system and processor architecture. The object descriptions are implemented using XML in order to provide architecture-generic descriptions of objects. The architecture-generic descriptions define the object data to be returned from the target and also defines its presentation to the user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07051015&OS=07051015&RS=07051015
owner: Wind River Systems, Inc.
number: 07051015
owner_city: Alameda
owner_country: US
publication_date: 20000110
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND INFORMATION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["An integrated development environment (\u201cIDE\u201d) is typically used to develop software in a \u201ctarget\u201d computer system. The IDE includes one or more \u201chost\u201d installations which may be connected to the target system in order to load the developed software into the target system and monitor its execution. A number of alternatives exist for connecting the target system to the host, but usually the connection is either an Ethernet or serial link.","In a development system, the host is typically equipped with large amounts of RAM and disk space, backup media, printers, and other peripherals. In contrast, the target system typically has limited resources (small amounts of RAM, no disk, no display, etc.), and perhaps some small amount of additional resources for testing and debugging. The target may include no more than a processor with on-chip RAM and a serial input\/output channel. The target's processor may be of various kinds including the PowerPC\u00ae processor manufactured by IBM Corp. or the Pentium\u00ae II manufactured by Intel Corp. The target may also include an operating system, such as VxWorks\u00ae from Wind River Systems, Inc., which may be used to control the allocation and usage of the target's resources.","The IDE may include a number of \u201ctools\u201d that allow a software developer to easily develop software for the target system and monitor the generation of the developed software on the target system. One such tool may be an \u201cobject browser\u201d which can be conveniently used to monitor the state of the target system while developed applications are executing. The object browser can be used to display information about \u201cobjects\u201d in the system, for example, information about objects of the operating system executing on the target. These objects may include tasks, semaphores, message-queues, memory-partitions, watchdogs, etc. Each object also has attributes which are the properties of the object. For example, a semaphore (an object) may have as attributes its name, identification number, and state (e.g., whether the semaphore is taken). The attributes of an object may be static (i.e., determining the object attribute does not require access to the target system) or dynamic (i.e., determining the object attribute does require access to the target system). The static attributes of the object may include, among others, a string describing the type of object (e.g., for the semaphore, the string may be \u201cSemaphore\u201d). The dynamic attributes may include, among others, the name of the object, the object's identification number, and the state of the object.","In a host-target development environment, in order for the host to gather information about the objects running on the target, the host generally has one or more files describing the target system's implementation of the object and this description file is specific to the implementation of the object by the operating system running on the target system. For example, the description files can list offsets to internal fields within each object's data structure, allowing the tools on the host to locate information concerning the object running on the target system. Information concerning the object is then retrieved from the target system using a standard communication protocol such as a Gopher program. The Gopher program describes a sequence of memory reads which results in a sequence of data to be returned to the calling host.","This scheme just described for gathering information is unwieldy in practice and not easily scalable. It is expensive to extend and maintain because introducing a new object requires updating many architecture specific files.","A method and system for retrieving and presenting data from a target system, the method includes retrieving object data from the target system for an object selected by a client, the retrieval performed by using one of the data retrieval programs corresponding to the target system. The method also includes providing the object data and a presentation format to the client, the object data and the presentation format are based upon one of the object description files corresponding to the object selected by the client.","According to the present invention, a flexible object model may be implemented, for example, in the IDE employing host and target systems. The flexible object model allows information about objects running on the target to be gathered independently of a target's architecture (i.e., the operating system running on the target and the processor architecture of the target). The flexible object model has the following benefits:\n\n","In one exemplary embodiment of the present invention, eXtensible Markup Language (\u201cXML\u201d) is used to describe the publicly accessible information of an object as well as the method by which that information can be accessed from the object and used in the IDE. XML is referred to as a \u201cmetalanguage\u201d, or a language for describing other languages. An XML file is made up of XML elements, each of which consists of a start tag (e.g., <title>), an end tag (e.g., <\/title>), and the information between the two tags (referred to as the content). Like Hypertext Markup Language (\u201cHTML\u201d), an XML document holds text annotated by tags. However, unlike HTML, XML allows an unlimited set of tags, each indicating not how something should look, but what something means. Rather than describing the order and fashion in which the data should be displayed, the tags in XML indicate what each item of data means. Detailed information on the XML standard is provided in: \u201cExtensible Markup Language (XML) 1.0\u201d, W3C Recommendation 10-Feb.-1998, REC-xml-19980210, http:\/\/www.w3.org\/TR\/REC-xml.","XML allows the host to carry architecture-generic descriptions of objects, each object having an XML file. This architecture-generic description would define the object data to be returned from the target and also define its presentation to the client. XML is thus suited for implementing the exemplary embodiment because it allows for architecture-generic descriptions of how to access and use data pertaining to objects.","The use of XML as the object description language would have the following benefits:\n\n","Referring to the figures in which like numerals indicate like elements,  is a block diagram illustrating an exemplary development environment  according to a first exemplary embodiment of the present invention. As shown, a host  is connected to a target  via, for example, a serial or Ethernet link.","The host  may comprise a computing environment having various well-known components and systems (for example, a processor, a memory system, a display, and user input devices such as a keyboard and mouse). The host  may include an operating system (e.g., Unix, Windows, Linux, etc.) which controls the execution of applications on the host .","The target  may comprise a second computing environment which, for example, is intended to operate apart from the host . The processor of the target , for example, may be an Intel Pentium\u00ae II processor or an IBM PowerPC\u00ae processor. The target  may include fewer resources than the host , thus making it advantageous to perform software development on the host  prior to implementation in the target . The target  may include an operating system  which controls the execution of applications and other objects running on the target . The operating system , along with user applications running on the target , uses various kernel objects (\u201cobjects\u201d) such as semaphores and tasks.","The host  includes a development system  to be used in developing software for the target . Included in the development system  is at least one client , which may be one of a number of known development tools (e.g., the object browser, debugger, etc.). During operation, the client  may require information about objects running on the target . In order to monitor the operations of objects on the target , an application programming interface (\u201cAPI\u201d)  is provided giving the client  access to an object interface (\u201cOI\u201d)  and which allows the client  to access information (e.g., attributes) about the objects running on the target . The API  thus allows development tools such as the object browser, debugger, command line shell, etc. to communicate with the OI .","The OI  is a program that allows the client  to obtain information about objects running on the target  independently of the target's architecture (which is described below) or its operating system. The OI  also includes an XML interpreter which is used to read XML files and provide access to their content and structure.","The development system  also includes a target interface (\u201cTI\u201d)  which is used by the OI  to access information about the objects running on the target . The TI  includes the Gopher standard protocol which is used to gather information about an object running on the target .","The development system  further includes an object database containing descriptions of objects for each known operating system and also data retrieval programs for various target processor architectures. In the first exemplary embodiment, the object database is an XML object database  and the object descriptions for each known operating system are implemented using XML. Also, in the first exemplary embodiment, Gopher programs, corresponding to recognized target processor architectures, are the data retrieval programs. However, in other embodiments, the object descriptions may be implemented using other languages and other programs may be used to retrieve data from the target . The XML object database  may be accessed by the OI  in order to process requests by the client  for information about an object running on the target .",{"@attributes":{"id":"p-0028","num":"0037"},"figref":"FIGS. 2","i":"a\u2013b ","b":["2","20","203","105","206","105","115","20","115","209","115","20","120","150","20","20","215","115","130","115"]},"In step , the client  \u201cenumerates\u201d all the objects supported by the OI . Enumerating the objects means to determine all the static attributes of the known objects, i.e., those attributes which do not require access to the target . The client  is provided enumeration information (i.e., information about the static attributes of the object) by the OI . The OI  obtains the enumeration information solely by using the XML object descriptions in the XML object database : there is one XML object description per object supported. No reference is made to the target  via the TI  for enumeration of the supported objects. The attributes of each object are defined in the XML object database  and may include, among others, the name of the object, the standard icon, the state, label, whether the object is displayable, how data displayed, etc.","In step , the client  requests further details about an object selected by the user. In step , the client  sends a reference to the object selected to the OI  via the API . In step , the OI  accesses the XML object database  to retrieve the XML object description corresponding to the selected object. The OI  also retrieves from the XML object database  the Gopher program corresponding to the processor of the target . A Gopher program may exist for each of the many possible target processor architectures if such a program is required\u2014an advantage of this embodiment of the present invention is that a Gopher program can be shared by different target processor architectures if they use the same memory layout for software objects.","In step , the OI  accesses the target  using a data retrieval method to collect data from the target . In one embodiment, the data retrieval method is passing the Gopher program from the OI  through the TI  to the target  in order for the OI  to gather data about the selected object. The returned data is referred to as a \u201cGopher tape.\u201d In step , the OI  decodes the data returned from the target  based on the XML object description retrieved from the XML object database . In step , the OI  sends the decoded data to the client  along with a presentation format. The presentation format is also based on the XML object description and instructs the client  on how to display the decoded data. The decoded data and the presentation format allow the client  to be data driven. The decoded data for the selected object is returned to the client  as a set of object attributes. In step , the client  uses the set of object attributes which was returned as a result of the original request. Such use of the object attributes can be, for example, in the case of the object browser, to display the object's attributes in a format suitable for a graphical user interface (\u201cGUI\u201d).","The previous embodiment shows how the OI  can be used to retrieve information about objects running on the target. In a second exemplary embodiment according to the present invention, the OI  can be used by a specific development tool\u2014an object browser\u2014to display information about objects running on a specific target. In this example, the processor of the target  is the PowerPC\u00ae processor, and the operating system  of the target  is VxWorks\u00ae. In other alternative embodiments, the OI  may be used by other development tools such as a debugger (e.g., the debugger would need to enumerate tasks in order to attach to one of them), and a command line shell (e.g., the shell may provide system information such as a snapshot of the tasks running on the target).","The following example illustrates the use of the exemplary OI  and the XML object database  by the object browser to obtain information (i.e., attributes) about objects running on the target. Referring again to  but now for the case where the client  is specifically the object browser, in step , the object browser is launched by, for example, the user. In step , the object browser instantiates the OI  in order to get object information from the target . In step , the OI  queries the target  via the TI  for information regarding the processor type and the operating system  of the target  and retrieves this information from the target .","In step , the OI  loads the XML object descriptions for VxWorks\u00ae from the XML object database . In step , the object browser enumerates all object types supported by the OI  using the XML object descriptions obtained from the XML object database . In step , the object browser requests further details on a particular object selected by the user of the object browser. In step , the object browser sends the object selected to the OI  via the API .","In step , the OI , based on the object selected, retrieves the corresponding XML object description from the XML object database . The OI  also retrieves from the XML object database  the Gopher program corresponding to the PowerPC\u00ae processor in order to retrieve the attributes of the selected object running on the target . In step , the OI  accesses the target  to retrieve the attributes of the selected object running on the target  using the Gopher program by sending the Gopher program through the TI  to the target .","In step , the OI  decodes the data returned from the target  based on the XML object description retrieved from the XML object database . In step , the OI  sends the decoded data (i.e., object attributes) to the object browser along with the presentation format. In step , the object browser displays the object attributes in the format as specified by the presentation format.",{"@attributes":{"id":"p-0037","num":"0046"},"figref":["FIG. 3","FIG. 3","FIG. 3","FIG. 3","FIG. 3"],"b":"20"},{"@attributes":{"id":"p-0038","num":"0047"},"figref":["FIGS. 4","FIG. 4"],"i":"a\u2013h ","b":"4"},"The third and fourth lines of  define the specifics of the object type. For example, the object is defined as a semaphore (objTypeName=\u201csem\u201d) and given a unique object number (objTypeNumber=\u201c1\u201d).","The \u201cobjTypeAttributes\u201d in  contain descriptions of those attributes which are static, i.e., those attributes which do not require target access. The \u201cobjAttributes\u201d contain descriptions of those attributes which do require target access. The \u201cobjGopher\u201d contains the Gopher programs used by the OI  for each target architecture along with a logical identifier to be attached to the returned value. This identifier is referenced in the \u201cobjAttribute\u201d to decode the returned data.",{"@attributes":{"id":"p-0041","num":"0050"},"figref":"FIG. 5","b":["135","15","135","135","135","115"]},{"@attributes":{"id":"p-0042","num":"0051"},"figref":["FIGS. 6","FIG. 2"],"i":"a\u2013b ","b":["6","20","218","20"]},"Referring to , in step , the OI  loads the user-defined XML object descriptions (the plug-ins) from the user-defined XML object database  for the specified target operating system. The plug-ins allow the user to add custom objects. The plug-ins also allow the OI  to support user defined custom objects. The plug-ins expand the number of objects that are supported by the OI . After the plug-ins are loaded in step , the OI  is now initialized.","In a fourth embodiment of the present invention, data extraction routines are used rather than the Gopher program to retrieve object data from the target .  is a block diagram illustrating the development environment  according to the fourth embodiment of the present invention.","Included in a data extraction development system  is an object description module  which contains descriptions of each of the objects running on the target . In order for the object descriptions to be architecture-generic, they are implemented using XML. The object description module  contains XML code for describing each of the object's public attributes. The object description module  also contains data extraction routines; each object description specifies a data extraction routine for that object. Different data extraction routines may exist for each target processor architecture supported by the data extraction development system  and the data extraction routines may be pre-compiled using the appropriate compiler.","The data extraction routine is downloaded to the target  via the TI  in order to assemble data about the selected object on the target  in the format described in the XML object description found in the object description module . In an alternative embodiment, the data extraction routine already resides on target  and therefore does not need to be downloaded. The data extraction routine assembles the data about the selected object on the target  into a data packet and places it in a target buffer.",{"@attributes":{"id":"p-0047","num":"0056"},"figref":"FIG. 8","b":["505","105","510","115","20","120","150","20","512","115","155","514","105","115"]},"In step , the client  selects an object for which to obtain information and this selection is sent to the OI  via the API . In the case of the object browser, the object whose public attributes are to be displayed is selected by a user. In step , the object description for the selected object is fetched from the object description module . In step , the data extraction routine corresponding to the processor architecture of the target  is fetched from the object description module .","In step , the compiled data extraction routine is sent to the target  via the TI . In step , the data extraction routine assembles the requested data for the selected object and places this data into a data packet and puts this data packet into a target buffer. In step , the OI  uses the object description, found earlier in the object description module , in order to interpret the retrieved data. The OI  formats the requested data by matching it with the object description found in the object description module . In step , the OI  sends the decoded data to the client . In the case that the client  is the object browser, the decoded data (the object information) can be displayed to the user.",{"@attributes":{"id":"p-0050","num":"0059"},"figref":["FIGS. 9","FIG. 9","FIG. 9"],"i":"a\u2013b ","b":"9"},"A <data> element defines the data assembled for use by the object browser. The <data> element includes the definition of the data items which will be assembled by the target  and downloaded to the host  in a data packet. The host  uses <dataItem> definitions in the <data> element to decode this data packet. For each <dataItem>, information is provided to allow the host  to extract the data from the data packet and to know how to display it in the object browser. A \u201ctype\u201d attribute specifies the number of bytes in the data item and how it should be interpreted. A \u201cidref\u201d attribute is an internal name for the dataItem. A \u201ctext\u201d attribute is the label to be used in the object browser for the dataItem. A \u201cformat\u201d attribute is a C-style format stating how the data should be displayed by the client. A \u201cdisplay\u201d attribute indicates whether the dataItem is displayed; if display is set to \u201calways\u201d then the dataItem is always displayed, if display is set to \u201coptional\u201d then the user can elect to display the dataItem, and if display is set to \u201cnever\u201d then the dataItem is never displayed.","In the preceding specification, the invention has been described with reference to specific exemplary embodiments thereof. It will, however, be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims that follow. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIGS. 2","i":"a\u2013b "},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 4","i":"a\u2013h "},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 6","i":"a\u2013b "},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 9","i":"a\u2013b "}]},"DETDESC":[{},{}]}
