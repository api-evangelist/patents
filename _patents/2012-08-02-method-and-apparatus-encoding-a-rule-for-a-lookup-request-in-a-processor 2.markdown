---
title: Method and apparatus encoding a rule for a lookup request in a processor
abstract: In one embodiment, a method includes encoding a key matching rule having at least one dimension by storing in a memory (i) a header of the key matching rule that has at least one header field, and (ii) at least one rule value field of the key matching rule corresponding to one of the dimensions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09596222&OS=09596222&RS=09596222
owner: Cavium, Inc.
number: 09596222
owner_city: San Jose
owner_country: US
publication_date: 20120802
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/514,344, filed on Aug. 2, 2011; U.S. Provisional Application No. 61\/514,382, filed on Aug. 2, 2011; U.S. Provisional Application No. 61\/514,379, filed on Aug. 2, 2011; U.S. Provisional Application No. 61\/514,400, filed on Aug. 2, 2011; U.S. Provisional Application No. 61\/514,406, filed on Aug. 2, 2011; U.S. Provisional Application No. 61\/514,407, filed on Aug. 2, 2011; U.S. Provisional Application No. 61\/514,438, filed on Aug. 2, 2011; U.S. Provisional Application No. 61\/514,447, filed on Aug. 2, 2011; U.S. Provisional Application No. 61\/514,450, filed on Aug. 2, 2011; U.S. Provisional Application No. 61\/514,459, filed on Aug. 2, 2011; and U.S. Provisional Application No. 61\/514,463, filed on Aug. 2, 2011. The entire teachings of the above applications are incorporated herein by reference.","The Open Systems Interconnection (OSI) Reference Model defines seven network protocol layers (L1-L7) used to communicate over a transmission medium. The upper layers (L4-L7) represent end-to-end communications and the lower layers (L1-L3) represent local communications.","Networking application aware systems can process, filter and switch a range of L3 to L7 network protocol layers, for example, L7 network protocol layers such as, HyperText Transfer Protocol (HTTP) and Simple Mail Transfer Protocol (SMTP), and L4 network protocol layers such as Transmission Control Protocol (TCP). In addition to processing the network protocol layers, the networking application aware systems can simultaneously secure these protocols with access and content based security through L4-L7 network protocol layers including Firewall, Virtual Private Network (VPN), Secure Sockets Layer (SSL), Intrusion Detection System (IDS), Internet Protocol Security (IPSec), Anti-Virus (AV) and Anti-Spam functionality at wire-speed.","Improving the efficiency and security of network operation in today's Internet world remains an ultimate goal for Internet users. Access control, traffic engineering, intrusion detection, and many other network services can be optimized by packet classification, which is discrimination of packets based on multiple fields of packet headers.","Internet routers can classify packets to implement a number of advanced internet services such as routing, rate limiting, access control in firewalls, virtual bandwidth allocation, policy-based routing, service differentiation, load balancing, traffic shaping, and traffic billing. To perform these services, the router classifies incoming packets into different flows and then performs appropriate actions depending on the classification.","A classifier, using a set of filters or rules, specifies the flows, or classes. For example, each rule in a firewall might specify a set of source and destination addresses and associate a corresponding deny or permit action with it. Alternatively, the rules might be based on several fields of a packet header including layers 2, 3, 4, and 5 of the OSI model, which contain addressing and protocol information.","On some types of proprietary hardware, an Access Control List (ACL) refers to rules that are applied to port numbers or network daemon names that are available on a host or layer 3 device, each with a list of hosts and\/or networks permitted to use a service. Both individual servers as well as routers can have network ACLs. ACLs can be configured to control both inbound and outbound traffic.","In one embodiment, a method includes encoding a key matching rule having at least one dimension by storing in a memory (i) a header of the key matching rule that has at least one header field, and (ii) at least one rule value field of the key matching rule corresponding to one of the dimensions.","In another embodiment, the method may store the header of the key matching rule by at least one of the following.","(a) Storing a length of the key matching rule.","(b) Storing a match type of the key matching rule corresponding to one of the dimensions.","(c) Storing an enable value corresponding to the one of the dimensions. The one of the dimensions is enabled if the enable value has a first value. The one of the dimensions is disabled if the enable value has a second value. Disabling matching of the one dimension masks the one dimension.","(d) Storing a rule validity value corresponding to the key matching rule. The key matching rule is enabled if the rule validity value has a first value. The key matching rule is disabled if the rule validity value has a second value.","(e) Storing a priority value corresponding to the key matching rule. The priority value indicates a priority of the key matching rule compared to a plurality of key matching rules.","In one embodiment, disabling matching of the one of the dimensions can further disable storage of the at least one rule value field of the key corresponding to the one of the dimensions.","In another embodiment, the match type field can include an indication of at least one of a prefix match, an exact match, a mask match, and a range match. The prefix match is configured to match a beginning of a field of a key to the one of the dimensions. The exact match is configured to exactly match a field of a key to the one of the dimensions. The mask match is configured to match bits of a field of a key corresponding to a mask to the one of the dimensions. The range match is configured to match a field of a key to a range of values indicated by the one of the dimensions. The match type can further include the indication of the prefix match. The match type field can further include a length to match the beginning of the field of the key.","In another embodiment, the method includes comprising aligning, by adding padding bits to the at least one header field and to the at least one rule value field in the memory. The added padding bits set the at least one header fields and the at least one rule value field to be a multiple of a particular bit length.","In another embodiment, the method can further include grouping a plurality of key matching rules in a chunk. The method can then further include aligning the plurality of key matching rules within the chunk by padding each of the plurality of key matching rules to be a multiple of a particular bit length.","In another embodiment, aligning the plurality of key matching rules within the chunk includes aligning any particular key matching rule to be less than the particular bit length after a successive particular bit length. Each of the key matching rules may include a corresponding priority. The method may order each of the plurality of key matching rules in the chunk according to the corresponding priority.","In another embodiment, one of the header fields may correspond with the one of the dimensions. The rule value field, according to the one of the header fields, may be configured to be compared against a key or a field of the key. If the one of the header fields indicates a prefix match, the rule value field may include a rule value and a bit length, and the rule value may be compared against the bit length of the key or the field of the key. If the one of the header fields indicates a mask match, the rule value field may include a rule value and a bit mask, and the rule value may be compared against the particular bits of a key or a field of the key indicated by the bit mask. If one of the header fields indicates a range match, the rule value field may include a minimum and a maximum, and a key or a field of the key may be determined to be within or out of a range indicated by the minimum and a maximum. If the one of the header fields indicates an exact match, the rule value field may include a rule value, and a key or a field of the key may be compared against the rule value.","In one embodiment, an apparatus includes a memory and a processor. The processor can be configured to encode a key matching rule having at least one dimension by storing in the memory (i) a header of the key matching rule having at least one header field, and (ii) at least one rule value field of the key matching rule corresponding to one of the dimensions.","A description of example embodiments follows.","The teachings of all patents, published applications and references cited herein are incorporated by reference in their entirety.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 1","b":["100","102","104","104","104","104","102","102","102","106","106","108"],"i":["a","h","a","h ","a","h","a","h ","b","e ","h","a","f","a","f ","a","e. "]},"The core routers -are configured to operate in the Internet core  or Internet backbone. The core routers -are configured to support multiple telecommunications interfaces of the Internet core  and are further configured to forward packets at a full speed of each of the multiple telecommunications protocols.","The edge routers -are placed at the edge of the Internet core . Edge routers -bridge access routers -outside the Internet core  and core routers -in the Internet core . Edge routers -can be configured to employ a bridging protocol to forward packets from access routers -to core routers -and vice versa.","The access routers -can be routers used by an end user, such as a home user or an office, to connect to one of the edge routers -, which in turn connects to the Internet core  by connecting to one of the core routers -. In this manner, the edge routers -can connect to any other edge router -via the edge routers -and the interconnected core routers -","The search processor described herein can reside in any of the core routers -, edge routers -, and access routers -. The search processor described herein, within each of these routers, is configured to analyze Internet protocol (IP) packets based on a set of rules and forward the IP packets along an appropriate network path.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 2A","b":["200","202","106","106","202","204","214","204","204","206","204","206","202","208","202","206","202","204","210"]},"Likewise, the second host processor  is an egress host processor. The second host processor  receives egress packets to send from the network . The second host processor  forwards a lookup request with a packet header (or field) from the egress packets  to the search processor  over a second Interlaken interface . The search processor  then processes the packet header using a plurality of rule processing engines employing a plurality of rules to determine a path to forward the packets on the network. The second host processor  forwards the processed egress packets  to another network element in the network.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 2B","b":["220","106","202","106","202","202","202","202","228","226","202","228","106","222","228","202","222","228","228","224","202"],"i":["a ","b","a","b ","a","b","a","b ","a","b ","a","b. "]},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 2C","b":["240","246","202","246","250","242","242","250","202","202","250","252","244","244","248"]},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 3A","b":["300","302","303","308","304","302","306","306"],"i":["a","h","a","h "]},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 3B","b":["320","202","302","306","303","303","308","328","304","303","306","322","324","326","202","324","306"],"i":["a","b ","a","b ","a","b","a","b","a","b","a","b ","a","b. "]},"As an example, a packet is received by the line card at the MAC layer . The MAC layer sends the packet to the forwarding table . Then, the packet and appropriate forwarding table information is stored in the local buffer memory . The processor card  then accesses its routing table  to determine where to forward the received packet. Based on the determination, the router selects an appropriate line card , stores the packet and forwarding information in the local buffer memory of the appropriate line card, and forwards the packet out to the network.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 3C","b":["340","302","302","303","342","342","303","304","308","342","342","342"],"i":["b","h","a","a ","a","h","a. "]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 3D","b":["360","302","302","303","342","342","342","342","342","342","344","326","202","342","342","346","344","202","344","328","303","342"],"i":["a ","b","h","a","b ","a ","b","h","a","b ","a","b","a","b","a","b","a ","a ","a","a ","b "]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 4A","b":["400","202","202","402","402","202","404","402","404","406","406","406","408","408","408","413"],"i":["a","b ","a","b ","a ","b","a","b ","a ","b","a","b "]},"The crossbar  is coupled with a first supercluster and a second supercluster . Within each supercluster -are a plurality of search blocks -. Each search block -, or search cluster, is configured to receive a key from a received packet, determine and load a set of rules to process the key, and output results of the search executed using those rules. The crossbar  and the superclusters -are part of a lookup cluster complex (LCC) .",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 4B","b":["420","408","424","440","414","410","424","422","422","424","428","430","432","426","424","434","414","414","410","436","440","442","442"],"i":["a","b","a ","b","a","b","a","b","a","b ","a","b ","a","b ","a","b","a ","b. "]},"The processor described herein loads one or more rules (e.g., matching rules) that match a packet. In general, a packet may be broken down into parts, such as a header, a payload, and a trailer. The header of the packet (or packet header) may be further broken down into fields, for example. So, the processor may further find one or more rules that match one or more parts (or fields) of the packet.","The processor can execute a \u201clookup request,\u201d which finds one or more rules matching a packet or parts of a packet. The lookup request first leads to finding one or more matching rules.","From the standpoint of the processor described herein, executing a lookup request begins with 1) receiving the lookup request from a host processor. The lookup request includes a packet header and group identifier (GID).","2) The GID indexes to an entry in a global definition\/description table (GDT). Each GDT entry includes (a) n number of table identifiers (TID), (b) a packet header index (PHIDX), and (c) key format table index (KFTIDX).","3) Each TID indexes an entry in a tree location table (TLT). Each TLT entry identifies which lookup engine or processor core looks for the one or more matching rules. In this way, each TID specifies both which lookup engine or processor core looks for the one or more matching rules and where the particular one or more matching rules are stored.","4) Each TID also indexes an entry in a tree access table (TAT). Each TAT entry provides the starting address (e.g., a root node) in memory of a collection of rules (or pointers to rules) called a table or tree of rules. The terms table of rules, tree of rules, table, or tree are used interchangeably throughout the application. In all, the TID identifies the TAT, which identifies the collection or set of rules in which to look for one or more matching rules.","5) The PHIDX of the GDT entry indexes an entry in a packet header table (PHT). Each entry in the PHT instructs the processor how to extract n number of keys from the packet header.","6) The KFTIDX of the GDT entry indexes an entry in a key format table (KFT). Each entry in the KFT provides instructions for extracting one or more fields (i.e., parts of the packet header) from each of the n number of keys extracted from the packet header.","7) The processor looks for subsets of the rules using each of the fields extracted from the packet together with each of the TIDs. Each subset contains rules that may possibly match each of the extracted fields.","8) The processor then compares each rule of each subset against an extracted field. The processor provides rules that mach in responses or lookup responses.","The above description of a lookup request and its enumerated stages are described to present concepts of lookup requests. These concepts may be implemented in numerous ways. For example, according to example embodiments of the present invention, these concepts may be implemented by a search processor.","As described above, the search processor processes a lookup request for a packet. In processing the lookup request, the processor can extract a header or field from the packet that is then applied to one or more rules. The header of field can be referred to as a key.","The search processor stores at least one tree of rules. In one embodiment, the tree of rules is a memory structure employed by the processor to narrow down a set of rules for a given key and a rule is a test of a value of a key. The tree has a root node, or a starting address. The search processor uses a tree walk engine (TWE) to traverse the tree for a particular key. The TWE eventually reaches a pointer to a memory address in the tree. The pointer can be either to a bucket of rules or a pointer to rules in memory directly.","A bucket of rules is a set of pointers to rules. If the pointer is to a bucket of rules, a bucket walk engine (BWE) determines, based on the key and the bucket, a pointer to rules in a memory, such as an on chip memory. A group of rules in memory is called a chunk. The chunk can be sequentially addressed rules or rules grouped in another manner. If the pointer is to rules in the memory directly, the pointer may point directly to the chunk.","Once the processor loads the chunk of rules from memory, it sends the key and the chunk of rules to a rule match engine (RME). The rule match engine determines whether the key matches rules within the chunk. Then, the RME and the search processor can respond to the lookup request with the selected rule and match result.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 5","b":["700","704","702","704","710","710","712","714","716","712","711","713","732","713","712","714","718","716","720","720","720"],"i":["a","d","a","b","a","b "]},{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 6","b":["500","410","410","508","504","514","520","508"],"i":["a","c"]},"The search cluster  receives a key  from the LUF  () at the TWE . The TWE  issues and receives a plurality of tree input\/output (I\/O) accesses  to the OCM . Based on the key , the TWE  walks the tree from a root node to a possible leaf node. If the TWE  does not find an appropriate leaf node, the TWE  issues a nomatch  (e.g., a no match). Then, if the TWE  finds an appropriate leaf node, the leaf node can indicate a pointer  to a bucket. The TWE  provides the pointer  to the bucket to the BWE . The BWE  accesses the OCM  by issuing bucket I\/O accesses  to the OCM . The bucket I\/O accesses  retrieve at least one pointer  to a chunk to the BWE . The BWE  provides the pointer  to the chunk to one of the plurality of RMEs -. The one of the chosen RMEs -also receives the key . Each of the plurality of RMEs -are configured to issue rule and\/or chunk I\/O accesses  to the OCM  using the pointer  to the chunk to download appropriate rules from the chunk in the OCM to analyze the key . The RMEs -then analyze the key using the rules accessed from the OCM  and issue a response or nomatch -corresponding to whether the key matched the rule or chunk indicated by the tree and bucket stored in the OCM .",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 7A","b":["730","712","732","734","734","712","734","736","738","738","714","718","718"]},{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 7B","b":["740","712","734","732","736","742","736","746","736","742","746","746","736"]},{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 8A","b":["600","602","604"]},"The search cluster of the search processor then determines whether the rule or bucket is in the tree () by searching for a non-null leaf node. If not, for instance, if the leaf node is nonexistent or null, the search cluster returns a nomatch (). If the leaf node stores a rule or bucket, then the search cluster determines whether the leaf node points to a rule or points to a bucket (). If the leaf node points directly to the rule, then search cluster loads the rule from an external memory (). Then the system provides the rule to the BPP (). The system provides the rule to the BPP by either (i) the BPP pulling the rule from the external memory using the pointer from the leaf node or (ii) a navigation unit within the search cluster sending a command to the external memory to forward the requested memory addresses to the BPP.","The BPP is a processor similar to the RME that is configured to process a chunk of rules and compare the rules to keys, however, the BPP is further configured to process rules from the external memory. Loading rules from an external memory (, , ) is an optional embodiment of the search processor and corresponding search clusters. The search processor can store all of the rules and\/or chunks of rules on an OCM. Therefore, the tree data structure may store pointers to buckets instead of pointers to rules directly. Even in an embodiment where rules and\/or chunks of rules are stored solely on the OCM, the leaf nodes can point directly to the rules and\/or chunks of rules in the OCM without the use of buckets.","If the leaf node points to a bucket (), then the search processor loads pointers stored in the bucket (). Then, the search processor loads the rules that are stored in the OCM where the pointers from the bucket are pointing (). Then, the system provides the rule(s) to RMEs ().",{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 8B","b":["800","802","806","808","810","812","814","816","808","810","812"]},{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 9","b":["900","520","520","902","904","906","520","520","520","914","912","520","916","520","520","908","520","520","910"]},{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 10","b":["1000","520","520","502","720","520","520","1002","520","1006","520","1008","1006","1010","1010"],"i":["a","n ","a","n "]},"The formatting block  receives chunks of rule  and the key . The formatting block, based on the chunks of rules , rule format info and the key , outputs formatted dimensions -to the DME block -. The format block  outputs as many formatted dimensions -as there are the DMEs in a particular clock cycle. For example, in an RME  that includes twelve DMEs, the format block  can issue twelve formatted dimensions -to each of the twelve DMEs -. However, the RME  can contain any number of DMEs. The DMEs -receive the formatted dimension -and the key . The DMEs process the key, comparing it to the formatted dimension -, and output a respective dimension result -. The post processing block  receives all of the dimension results -, and performs of Boolean \u2018and\u2019 of all of the dimension results -to output results . Therefore results  indicate whether the key  matches a particular rule across all of its dimensions.","In other words, in one embodiment, rules are stored within a chunk. A chunk is a collection of rules that are grouped together. The RME receives the chunk of rules one line of data per clock cycle (or beat). In one embodiment, the line of data can be 256-bits wide, however other embodiments the line of data can be any size.","Each line can contain at least one rule. For example a first line transmitting a chunk may contain three and a half rules, that is, three complete rules and one partial rule. The one partial rule is \u2018cut off\u2019 because the line of data is too short to store the complete fourth rule. Instead, the fourth rule is transmitted on a second line transmitting the chunk.","The second line may contain two and a half rules, that is, two complete rules, and one partial rules. The first rule of the second line of data is the remainder of the partial rule in the first line of data (i.e., the fourth rule). The second line of data contains two complete rules (i.e., the fifth and sixth rules of the chunk). In another embodiment, a line can include two partial rules, where the first partial rule is \u2018cut-off\u2019 at the beginning of the line, and the second partial rule is \u2018cut-off\u2019 at the end of the line. However, in this embodiment, the chunk contains six rules transmitted over two clock cycles, as described above.","The format block , or first stage, formats all dimensions of the received multiple rules and assign each rule to a DME on each clock cycle. In this embodiment, in first clock cycle the format block  processes three rules because it has received three complete rules (i.e., the first, second and third rule) where the format block  does not process the fourth rule because it hasn't been completely received yet. In the second clock cycle, the format block  processes three more rules (i.e., the fourth, fifth, and sixth rules) because all have been received completely at this point.","Every clock cycle, the DMEs -process the dimensions. Then, the post processing block  sorts the outputs of DMEs, and returns a final response on completion of whole chunk (in this embodiment, the six rules).",{"@attributes":{"id":"p-0115","num":"0114"},"figref":["FIG. 11","FIG. 10"],"b":["1100","520","520","1002","1110","1116","1002","1110","1116"]},"In relation to , the format block  includes a start block , a middle block , a tween block , and a finish block . The start block  has two pipeline stages, P and P. The middle block  has two pipeline stages, P, and P. The tween block  has one stage, P. The finish block  has two stages, P and P.","The format block  receives rule data  and rule formatting information at the start block . The start block  has three high-level functions. First, the start block  finds starts of the rules within the rule data . Second, the start block  identifies rules that do not require processing, such as a rule with a check rule violation or a rule with a valid bit being set to zero (or false). Third, the start block  precalculates terms for next stage (e.g., the middle block ) processing.","The middle block  has three high-level functions. First, the middle block  removes rules that do not need to be processed, as identified by the start block . The start block , as described above, identifies rules that do not require processing, such as a rule with a check rule violation or with a valid bit set to zero or false. Second, the middle block  extracts rule format from headers of the rule data . Third, the middle block  extracts at least one priority field from headers of the rule data . The priority field of each rule indicates the priority in which the rule is processed.","The tween block  has two high-level functions. First, the tween block  calculates rule header and positions. Second, the tween block  calculates rule dimension and positions.","The finish block  has two high-level functions. First, the finish block  calculates control for the multiple DMEs -of the DME group . Second the finish block  generates control rule and formatting information for the post processing block .","The start block  has two pipeline stages, P and P. The start block  introduces a large delay, through combinatorial logic, from its inputs. The stages of the start block  (i.e., P and P) are configured to enable stalling, or hold information from a stall issued by the middle block  or the finish block . The start block  also calculates header length information. The start block  also identifies rules that do not need to be processed, by (1) performing a check rules operation, and (2) checking the valid bits of the rules. The start block , in some embodiments, does not remove the rule, but rather identifies, flags, and\/or selects the rule to be removed later, for instance, by the middle block . The start block  then determines whether the start block  has processed more than a threshold of rules. The start block  identifies rules P and P in excess of the threshold for removal. The start block  also identifies rules for removal based on each rules validity bit.","The middle block  has two pipeline stages, P and P. Both stages are configured to stall and hold under a stall from the finish block . Stage P removes invalid rules identified by the start block . Therefore, only a rule that passes the check rules test and has its validity bit set (e.g., being true or one) are sent to the next stage of the middle block  (e.g., stage P).","Pipeline stage P of the middle block  extracts header formatting information in a header processing module . The header processing module  processes up to four headers per clock cycle, however, the actual number of headers processed is dependent on the number of dimensions within the rules. This limits the amount of formatting information the tween block  and finish block  process during each clock cycle.","In one embodiment, the header processing module  can process a certain number of headers based on the number of dimensions within each header. For example, in an embodiment where the RME  includes 12 DMEs -, the header processing module  can process four headers when each header includes 1-3 dimensions. This means that the header processing module  processes 4-12 maximum dimensions per cycle, which does not overload the twelve DMEs -","The header processing module  can process three header paths if each header includes 4-5 dimensions. This allows the RME  12 to 15 maximum dimensions per cycle, which occupies the DMEs -, however, with stall conditions, the DMEs -can process any surplus dimensions in a next clock cycle.","The header processing module  can process two header paths when the headers include 6-11 dimensions. This creates 12-22 maximum dimensions per cycle, which occupies the DMEs -, however, using stall conditions, any surplus dimensions can be processed in a next clock cycle.","Last, the header processing module  can process one header path when the header includes 12-16 dimensions. The RMEs  process 12-16 total dimensions per clock cycle, which occupies the DMEs -. Surplus dimensions can be processed in a next clock cycle.","The DME group  of the RME  can include any number of DMEs -. Adjusting the number of DMEs -can affect the numbers described above. Accordingly, the above numbers describe one example embodiment and other combinations of numbers of headers, dimensions, and DMEs can realize other embodiments.","Further, the header processing module  can process partial headers. A partial header is a header that straddles across two beats, or clock cycles, which requires processing during more than one cycle. The straddled header path is stored until the header processing module  downloads the complete header. Multi-beat headers are discussed in further detail in relation to .","In relation to , rule data may contain more headers than described in the embodiments described above. Upon a rule including more headers than in the embodiments described above, the RME  asserts a stall, via the middle block stall signal , so that the header processing module , and the RME  in general, can process the additional headers in the rule. The middle block stall signal  stalls stages P and P of the start block . Then the RME  processes the number of headers based on the number of headers and number of dimensions, as described above. Then, the RME  stores unprocessed data in the middle block  to be processed in next clock cycles.","The tween block  includes one pipeline stage, P. The tween block  stalls upon a finish stall stage data  signal from the finish block . The tween block  is configured to calculate rule header and position. The tween block  is further configured to calculate rule dimension and positions from dimension widths. The tween block  is further configured to calculate key positions from each dimension from rule formatting data.","The finish block  includes two pipeline stages P and P. The finish block  includes a FIFO memory structure configured to manage control. The FIFO structure can push and pop, or retire, a variable number of elements. Elements in the FIFO are positions of headers and dimensions.","The finish block  further calculates control for the DMEs -. The calculated controls are shift accounts, masks, or assembly controls (e.g., for dimension straddles). In an embodiment where the RME includes 12 DMEs -, the finish block  retires, or processes, up to 12 dimensions per beat or clock cycle (including dimension straddles), up to four rules starts per beat, parts of up to five rules per beat, when the finish block  is finishing processing a rule from the previous beat, and up to 256 bits of rule data per beat.","The finish block  pushes up to four rule end positions (e.g., header and dimension end positions) and field widths into a FIFO data structure in a rule formatting (RFT) block . The RFT block  also calculates control data for dimension data for the first 16 elements of the FIFO data structure the control data includes a retirement state for the up to four headers and 12 rule dimensions. The finish block  uses this control data to retire control and rule data. The formatting data from the RFT block  is retired when the corresponding complete rule is sent to the DME group , or when all header bits are retired. The RFT block  retires data by popping any dimension and\/or header it sends.","The finish block  retires rule data when it is sent to the DME group . When there are more rule bits than can be retired in one clock cycle (e.g., more than 12 dimensions and\/or more than four rules) the finish block  stalls by issuing a finish block stall signal . The finish block  processes as much of the rule data, (e.g., as many rule bits) as possible during the clock cycle and stores the remaining rule data to process in the next cycle.","Further, the RFT block  can cause the finish block  to issue a stall if it stores more than 32 elements stored in its FIFO, in one embodiment. The 32 element threshold allows the rule format stall to be independent of the number of elements popped in any cycle because it hides one cycle of the pop through a stall latency from the maximum allowed rule formatting pop count of the finish block .","The finish block  calculates control for each of the 12 DMEs -through the control information from the rule formatting block . The control information includes (1) shift counts to align rule and key data for the match, (2) a mask control to select a number of bits for each match, (3) and an assembly control for each of the assembly of dimensions that straddle beat boundaries.","The finish block  further calculates control for post processing of the matched results, (e.g., via post processing control data ). The post processing control data  includes information that allows the post processing block  to identify which dimension results correspond with each rule. Each rule is given a tag, which follows each dimension of that rule as it exists in the finish block .","The DME group  includes multiple DMEs -(e.g., 12 DMEs). Each DME -can perform a 128-bit match of one of four different types. The four match types are (1) a range match, (2) an exact match, (3) a prefix match, and (4) a mask match. The DMEs -can perform more than a 128-bit match of the four different types. For example, the DMEs -can perform any bit length match, in one embodiment.","A range match determines whether a given key is within a minimum value and maximum value as set in a given dimension. An exact match determines whether a given key exactly matches a value as set in a given dimension. A prefix match determines whether a given number of bits, as set in the dimensions, of a given value as set in the dimension matches first set of a given number of bits in a given key bits. For example, a prefix match can match a first eight bits of a key to an eight-bit value in the dimension. Therefore, the prefix dimension includes both a length and a value to check. A mask match determines whether a given set of bits in a key, as indicated in a bit mask in the dimension, matches a value as indicated in the mask dimension. Therefore the mask dimension includes both a bit mask and a value for the bit mask to be checked.","As described above, a range match and a mask match both employ two rule data operands (i.e., range requires a minimum value and a maximum value, and mask requires a bit mask and a value). An exact match employs one rule data operand, which is the exact match value that searches against the key. A prefix match employs one rule data operand plus a width or a zero kill shift for unused bits. Matching a dimension to a key employs at least one operand of key data.",{"@attributes":{"id":"p-0142","num":"0141"},"figref":"FIG. 12","b":["1200","1122","1122","1204","1206","1122","1206","1122","1204","1204","1122","902","1122","1206","1204"],"i":["a","c","a","c","a","c "]},"The single-beat header processing modules -output processed headers -. Further, the multi-beat header processing module  outputs a processed header and a processed multi-beat header , which combines the header information across the multiple beats. The processed headers -and processed multi-beat header  include header formatting information (e.g., beginning and ending of each dimension, etc.). Further, the processed headers  -are combined to become processed headers .",{"@attributes":{"id":"p-0144","num":"0143"},"figref":"FIG. 13","b":["1300","1108","520","1108","1316","1312","1128","1312","1304","1310","1128","1310","1304","1302","1314","1302","1120","1108","1120","1002"]},"The rule formatting block  can further issue a rule format stall  upon receiving more rule bits than can be retired in one beat (or clock cycle). Further, the control logic module  can issue a dimension stall  upon determining that the FIFO  stores greater than 32 elements. If either the rule formatting block  issues a rule format stall  or the control logic module issues a dimension stall , the finish block  issues a finish stage stall signal .",{"@attributes":{"id":"p-0146","num":"0145"},"figref":"FIG. 14A","b":["1400","1006","1006","1406","1408","1006","1422","1006","1006","1406","1408","1422"],"i":["a","b "]},"The match unit  includes a first compare unit , a second compare unit , a combination unit , and mask logic . The match unit  receives an aligned first dimension data , and aligned second dimension data , and an aligned key , and outputs a dimension match  indicating whether the key matches the particular rule.","The aligned first dimension data and aligned second dimension data correspond to the two possible pieces of data accompanying each dimension. For example, range matching uses the aligned first dimension data as a minimum, and the aligned second dimension data as a maximum. The first compare unit therefore performs a greater than (or greater than or equal to) operation, the second compare unit performs a less than (or less than or equal to) operation, and the combination unit  then performs a logical \u2018and\u2019 operation on the results of the first and second compare units -to reach the dimension match .","In a mask operation, the aligned first dimension data is the value of the dimension, and the aligned second dimension is the bit mask. The match unit  then performs an exclusive-or operation of the aligned first dimension data and the aligned key . Then, the match unit  performs a bit-wise \u2018and\u2019 of the aligned second dimension data (e.g., the mask, and the results of the exclusive or operation). Then the match unit  performs an \u2018or\u2019 operation of all of the bits of the \u2018and\u2019 operation. The mask logic  performs the above operations. The dimension match  is the result of the final \u2018or\u2019 of the mask logic .","For an exact or prefix match, the aligned first dimension data and the aligned second dimension data include the same formatted rule bits. Therefore, the exact or prefix match can take the same path through the match unit  as the range match.","For mask operations, the aligned first dimension data is masked on a nimble granularity. The aligned second dimension data is not masked because masking is not required. The aligned key  is masked on a bit granularity to support prefix operations.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":["FIG. 14B","FIG. 14A","FIG. 14B","FIG. 14A","FIG. 14B","FIG. 14A"],"b":["1450","1112","1112","1112","1402","1403","1452","1452","1406","1408","1403","1422","1422"],"i":["a","b "]},{"@attributes":{"id":"p-0153","num":"0152"},"figref":"FIG. 15","b":["1500","1116","1116","1120","1108","1106","1116","1110","1120","1502","1116","908","910"]},{"@attributes":{"id":"p-0154","num":"0153"},"figref":"FIG. 16","b":["1600","1602","1604","1606","1602"]},"If headers are present in the rule data (), then the format block determines whether there are more headers than a particular limit (). If there are not more headers than the predetermined limit, then the format block processes all headers in the rule data (). Then, the format block sends all rule data to the next stage of processing (). Then, the format block waits to receive new rule data ().","However, if the RME has received more headers than the predetermined limit (), the format block processes the number of headers up to the header limit (). Then, the format block stalls (). Then, the format block sends process data to the next stage (). The format block stores unprocessed data in its current stage (). Then, the format block determines whether the RME is storing more headers than the predetermined limit () and proceeds accordingly.",{"@attributes":{"id":"p-0157","num":"0156"},"figref":"FIG. 17","b":["1650","1602","1652","1654","1656","1658","1602"]},"On the other hand, if there are more than 12 dimensions or more than 4 headers in the rule data (), the format block stalls (). Then, the format block retires up to 12 dimensions of rule data and formatting (). Then, the format block sends the retired rule data to the DMEs (). Then, the format block retires up to 4 headers in the rule data and formatting (). Then, the format block determines again whether there are more than 12 dimensions or more than 4 headers in the rule data () and proceeds accordingly.",{"@attributes":{"id":"p-0159","num":"0158"},"figref":"FIG. 18","b":["1700","1700","1702","1704","1706","1708","1710","1712","1702","1704","1706","1708","1708","1710","1718","1722","1714","1726","1730","1722"]},{"@attributes":{"id":"p-0160","num":"0159"},"figref":"FIG. 19","b":["1800","1850","1840","1850","1802","1802","1802","1804","1806","1804","1808","1806","1808","1808","1808","1840","1810","1810","1808","202","1810","1808","1814"]},"The data plane  further receives headers  at a customer application layer . The headers  are received either in a packet header mode  or a direct key mode . In either packet header mode  or direct key mode , the customer application layer  generates the lookup request  to the data plane . The data plane  then looks up the headers in the search processor  by employing the binary rules file  already loaded into the processor to generate results . The results  are sent to the customer application layer  which are then outputted as results output .",{"@attributes":{"id":"p-0162","num":"0161"},"figref":"FIG. 20A","b":["2000","2004","2004","2002","2002","2004","2002"]},{"@attributes":{"id":"p-0163","num":"0162"},"figref":"FIG. 20B","b":["2005","2006","2008","2006","2010","2010","2006","2010","2010"],"i":["a ","b","a ","b. "]},"The mask rule type  includes a mask value and a bit mask . The mask value is the value to which the key is compared, and the bit mask is the set of bits of the key and the mask which the mask value is compared. A key value matches the mask rule type  if the masked bits of the key value match the masked bits of the mask value ",{"@attributes":{"id":"p-0165","num":"0164"},"figref":"FIG. 20C","b":["2020","2022","2024","2024","2022","2024"]},{"@attributes":{"id":"p-0166","num":"0165"},"figref":"FIG. 21A","b":["2100","2102","2102","2102","2104","2102","1006","2102","1006","1060","1006"]},{"@attributes":{"id":"p-0167","num":"0166"},"figref":"FIG. 21B","b":["2110","2114","2112","2114","2112","2114","2114"]},{"@attributes":{"id":"p-0168","num":"0167"},"figref":["FIG. 21C","FIG. 21B"],"b":["2120","2102","2102","2102","2126","2126","2124","2122"],"i":["a","n","a","n ","a","n "]},{"@attributes":{"id":"p-0169","num":"0168"},"figref":"FIG. 21D","b":["2130","2132","2132","2134","2102"]},{"@attributes":{"id":"p-0170","num":"0169"},"figref":"FIG. 21E","b":["2140","2004","2114","2004","2002","2114","2114"]},{"@attributes":{"id":"p-0171","num":"0170"},"figref":"FIG. 21F","b":["2150","2022","2022","2024","2114","2114"]},{"@attributes":{"id":"p-0172","num":"0171"},"figref":"FIG. 21G","b":["2160","2108","2106","2006","2162","2008","2006","2114","2162","2008","2006"]},{"@attributes":{"id":"p-0173","num":"0172"},"figref":"FIG. 21H","b":["2170","2134","2114","2172","2134","2102","2174","2114","2114"]},{"@attributes":{"id":"p-0174","num":"0173"},"figref":"FIG. 22","b":["2200","2204","2206","2208","2208","2208","2210","2102","2102","2200","2212","2204","2206","2208","2210"]},"The valid bit  is a flag that indicates whether the rule is valid or not. If the valid bit is set to one, then the rule is processed by the RME or BPP. If the valid bit is set to zero, then the rule is screened out and not processed. Setting the validity bit can be a more efficient method to enable and disable rules than deleting or inserting the rule.","Further, in one embodiment, when the dimension valid bit is set to zero, its corresponding dimension value is not stored. Therefore, the dimension, and therefore rule and chunk, occupy less space in memory and further increase efficiency.","The rule length is a 6-bit value that indicates the length of the rule, which is useful for rule processing. For example, the rule length  informs the RME or BPP when to stop processing the rule because the remaining bits of the rule are simply padding to fill out the rest of the rule length. Prefix lengths -indicate the length of a prefix field for a given dimension. The PL fields are used for prefix dimension types. The priority field indicates the priority of the rule, for instance, the priority of the rule within a chunk of rules. The dimensions -indicate the actual values of the rule  to be processed.",{"@attributes":{"id":"p-0178","num":"0177"},"figref":"FIG. 23","b":["2300","2302","2304","2204","2206","2302","2210","2304","2102","2204","2206","2302","2302","2302"],"i":["a","b"]},{"@attributes":{"id":"p-0179","num":"0178"},"figref":"FIG. 24A","b":["2400","2406","2402","2404","2114","2102"],"i":["a","b "]},{"@attributes":{"id":"p-0180","num":"0179"},"figref":"FIG. 24B","b":["2420","2402","2404","2102","2422","2102","2102","2102","2102","2102","2424","2102","2424","2102","2424","2102","2426"],"i":["a","ba ","b ","a ","b ","bb ","ca ","c ","c "]},{"@attributes":{"id":"p-0181","num":"0180"},"figref":"FIG. 25","b":["2500","720","2502","2502","2502","2502","2502","2506","720"],"i":["a","b","c","d ","x"]},"First, the rule zero is transferred during beat one . Then, during beat zero , upper rule one is transferred, however rule one does not finish during beat zero . Rule one continues being transferred as lower rule one in beat one . Then, chunk padding  is transmitted to align the rules to the appropriate bit position. Upper rule two is then transferred during beat one , however, rule two again does not get to finish completely being transferred during beat one. Therefore lower rule two is transferred during beat two . Then chunk padding  is transferred to align the rule to the appropriate bit position. Then rule three is transferred during beat two . Rule three does finish being transferred during beat two and chunk padding  is transferred after rule three to align the next rule to the appropriate bit boundary. In this particular example, the chunk padding  is at the end of beat two, so the next rule begins at the beginning of the next beat. Rules of the chunk  continue to be stored in the chunk  in this manner, until rule X . The last beat transfers lower rule X , where the upper rule X (not shown) is transferred in the previous beat. Since rule X is the last rule, the last beat is filled with end of chunk padding , which is filled with zeros.","Embodiments or aspects of the present invention may be implemented in the form of hardware, software, or firmware. If implemented in software, the software may be any form of software capable of performing operations consistent with the example embodiments disclosed herein. The software may be stored in any non-transient computer readable medium, such as RAM, ROM, magnetic disk, or optical disk. When loaded and executed by processor(s), the processor(s) are configured to perform operations consistent with the example embodiments disclosed herein. The processor(s) may be any form of processor(s) capable of being configured to execute operations as disclosed herein.","While this invention has been particularly shown and described with references to example embodiments thereof, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing will be apparent from the following more particular description of example embodiments of the invention, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, emphasis instead being placed upon illustrating embodiments of the present invention.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 2A-2C"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3D"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 4A-B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIGS. 9-11"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 14A"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 14B"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 20A"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 20B"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 20C"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 21A"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 21B"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 21C"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 21D"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 21E"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 21F"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 21G"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 21H"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 24A"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 24B"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 25"}]},"DETDESC":[{},{}]}
