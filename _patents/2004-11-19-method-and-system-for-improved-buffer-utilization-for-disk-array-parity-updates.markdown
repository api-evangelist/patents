---
title: Method and system for improved buffer utilization for disk array parity updates
abstract: During a parity update of a parity stripe in a disk array, constant values used in finite field arithmetic are algebraically combined in order to reduce the number of buffers and steps needed to update multiple parity values when a change in data occurs. In one implementation, for example, the contents of a buffer that stores the product of a delta value associated with the change in data and a first constant, which is used to update a first parity value, are multiplied by a value representative of the ratio of a second constant, which is used to update a second parity value, and the first constant.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07290199&OS=07290199&RS=07290199
owner: International Business Machines Corporation
number: 07290199
owner_city: Armonk
owner_country: US
publication_date: 20041119
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is related to the following U.S. patent applications all filed on even date herewith by Carl Edward Forhan, Robert Edward Galbraith and Adrian Cuenin Gerhard: Ser. No. 10\/994,088, entitled \u201cMETHOD AND SYSTEM FOR ENHANCED ERROR IDENTIFICATION WITH DISK ARRAY PARITY CHECKING,\u201d Ser. No. 10\/994,099, entitled \u201cRAID ENVIRONMENT INCORPORATING HARDWARE-BASED FINITE FIELD MULTIPLIER FOR ON-THE-FLY XOR,\u201d Ser. No. 10\/994,098, entitled \u201cMETHOD AND SYSTEM FOR INCREASING PARALLELISM OF DISK ACCESSES WHEN RESTORING DATA IN A DISK ARRAY SYSTEM,\u201d and Ser. No. 10\/994,097, entitled \u201cMETHOD AND SYSTEM FOR RECOVERING FROM ABNORMAL INTERRUPTION OF A PARITY UPDATE OPERATION IN A DISK ARRAY SYSTEM.\u201d Each of these applications is incorporated by reference herein.","The present invention relates to data protection methods for data storage and, more particularly, to systems implementing RAID-6 and similar data protection and recovery strategies.","RAID stands for Redundant Array of Independent Disks and is a taxonomy of redundant disk array storage schemes which define a number of ways of configuring and using multiple computer disk drives to achieve varying levels of availability, performance, capacity and cost while appearing to the software application as a single large capacity drive. Typical RAID storage subsystems can be implemented in either hardware or software. In the former instance, the RAID algorithms are packaged into separate controller hardware coupled to the computer input\/output (\u201cI\/O\u201d) bus and, although adding little or no central processing unit (\u201cCPU\u201d) overhead, the additional hardware required nevertheless adds to the overall system cost. On the other hand, software implementations incorporate the RAID algorithms into system software executed by the main processor together with the operating system, obviating the need and cost of a separate hardware controller, yet adding to CPU overhead.","Various RAID levels have been defined from RAID-0 to RAID-6, each offering tradeoffs in the previously mentioned factors. RAID-0 is nothing more than traditional striping in which user data is broken into chunks which are stored onto the stripe set by being spread across multiple disks with no data redundancy. RAID-1 is equivalent to conventional \u201cshadowing\u201d or \u201cmirroring\u201d techniques and is the simplest method of achieving data redundancy by having, for each disk, another containing the same data and writing to both disks simultaneously. The combination of RAID-0 and RAID-1 is typically referred to as RAID-0+1 and is implemented by striping shadow sets resulting in the relative performance advantages of both RAID levels. RAID-2, which utilizes Hamming Code written across the members of the RAID set is not now considered to be of significant importance.","In RAID-3, data is striped across a set of disks with the addition of a separate dedicated drive to hold parity data. The parity data is calculated dynamically as user data is written to the other disks to allow reconstruction of the original user data if a drive fails without requiring replication of the data bit-for-bit. Error detection and correction codes (\u201cECC\u201d) such as Exclusive-OR (\u201cXOR\u201d) or more sophisticated Reed-Solomon techniques may be used to perform the necessary mathematical calculations on the binary data to produce the parity information in RAID-3 and higher level implementations. While parity allows the reconstruction of the user data in the event of a drive failure, the speed of such reconstruction is a function of system workload and the particular algorithm used.","As with RAID-3, the RAID scheme known as RAID-4 consists of N data disks and one parity disk wherein the parity disk sectors contain the bitwise XOR of the corresponding sectors on each data disk. This allows the contents of the data in the RAID set to survive the failure of any one disk. RAID-5 is a modification of RAID-4 which stripes the parity across all of the disks in the array in order to statistically equalize the load on the disks.","The designation of RAID-6 has been used colloquially to describe RAID schemes that can withstand the failure of two disks without losing data through the use of two parity drives (commonly referred to as the \u201cP\u201d and \u201cQ\u201d drives) for redundancy and sophisticated ECC techniques. Although the term \u201cparity\u201d is used to describe the codes used in RAID-6 technologies, the codes are more correctly a type of ECC code rather than simply a parity code. Data and ECC information are striped across all members of the RAID set and write performance is generally lower than with RAID-5 because three separate drives must each be accessed twice during writes. However, the principles of RAID-6 may be used to recover a number of drive failures depending on the number of \u201cparity\u201d drives that are used.","Some RAID-6 implementations are based upon Reed-Solomon algorithms, which depend on Galois Field arithmetic. A complete explanation of Galois Field arithmetic and the mathematics behind RAID-6 can be found in a variety of sources and, therefore, only a brief overview is provided below as background. The Galois Field arithmetic used in these RAID-6 implementations takes place in GF(2). This is the field of polynomials with coefficients in GF(2), modulo some generator polynomial of degree N. All the polynomials in this field are of degree N-1 or less, and their coefficients are all either 0 or 1, which means they can be represented by a vector of N coefficients all in {0,1}; that is, these polynomials \u201clook\u201d just like N-bit binary numbers. Polynomial addition in this Field is simply N-bit XOR, which has the property that every element of the Field is its own additive inverse, so addition and subtraction are the same operation. Polynomial multiplication in this Field, however, can be performed with table lookup techniques based upon logarithms or with simple combinational logic.","Each RAID-6 check code (i.e., P and Q) expresses an invariant relationship, or equation, between the data on the data disks of the RAID-6 array and the data on one or both of the check disks. If there are C check codes and a set of F disks fail, F\u2266C, the failed disks can be reconstructed by selecting F of these equations and solving them simultaneously in GF(2) for the F missing variables. In the RAID-6 systems implemented or contemplated today there are only 2 check disks\u2014check disk P, and check disk Q. It is worth noting that the check disks P and Q change for each stripe of data and parity across the array such that parity data is not written to a dedicated disk but is, instead, striped across all the disks.","Even though RAID-6 has been implemented with varying degrees of success in different ways in different systems, there remains an ongoing need to improve the efficiency and costs of providing RAID-6 protection for data storage. The mathematics of implementing RAID-6 involve complicated calculations that are also repetitive. Accordingly, efforts to improve the simplicity of circuitry, the cost of circuitry and the efficiency of the circuitry needed to implement RAID-6 remains a priority today and in the future.","For example, one drawback with conventional RAID-6 designs relates to the throughput of parity updates in such designs due to comparatively higher buffer requirements for performing such updates. A parity update, in this context, refers to updating the parity information stored in a given parity stripe in a disk array in response to a change in the data stored in the parity stripe.","By way of comparison, in a RAID-5 design, a parity update operation typically requires, first, that the old data to be updated be retrieved from the appropriate disk and compared to the new data to calculate a delta value \u0394, e.g., by performing an exclusive-OR (XOR) operation with the old and new data. This delta value \u0394 is then used to update the parity, e.g., by performing an XOR operation with the old parity value and the delta value \u0394.","Of note, the two XOR operations performed during a RAID-5 parity update can be implemented using only two buffers. Specifically, a first buffer can be used to initially store the new data to be written, with a second buffer used to store the delta value \u0394 generated from the XOR of the new data stored in the first buffer and old data retrieved from the appropriate disk (which can be fed directly to XOR logic, and thus does not need to be buffered). Once the new data is written to the appropriate disk, the first buffer can then be reused to store the result of the XOR operation between the delta value \u0394 stored in the second buffer and the old parity value retrieved from the appropriate disk (which also can be fed directly to XOR logic without buffering). After this second XOR operation, the first buffer stores the new parity value, which can then be read out of the first buffer and written to the appropriate disk.","On the other hand, in a RAID-6 environment, where two disks include parity data for each parity stripe, parity update operations typically require at least one additional buffer to store interim data associated with such operations. In particular, while RAID-6 parity updates still require the calculation of a delta value \u0394, updating both of the parity values for a given parity stripe require that the delta value \u0394 be multiplied or scaled by different constants that are respectively associated with the different parity stripe equations that relate the parity values to the data in the parity stripe equation. These different constants are conventionally designated as constants Kand K, and as such, one parity value P for a parity stripe is typically calculated by performing an XOR of the old parity value P and the product of constant Kand delta value \u0394 (i.e., K\u0394), while the other parity value Q for the same parity stripe is typically calculated by performing an XOR of the old parity value Q and the product of constant Kand delta value \u0394 (i.e., K\u0394).","In a conventional RAID-6 implementation, three or more buffers are used, with a first buffer initially storing the new data to be written, and with a second buffer used to store the delta value \u0394 generated from the XOR of the new data stored in the first buffer and old data retrieved from the appropriate disk. Since the delta value \u0394 is required for both parity values, a third buffer is used to store the product K\u0394 of the delta value \u0394 stored in the second buffer and constant K. Also, similar to a RAID-5 implementation, after the new data is written to the appropriate disk, the first buffer is reused to store the result of an XOR operation between the product K\u0394 stored in the third buffer and the old parity value P retrieved from the appropriate disk, which result is then written back out to the appropriate disk as the new parity value P. To update parity value Q, after the parity value P is updated, the third buffer is then reused to store the product K\u0394 of the delta value \u0394 stored in the second buffer and constant K, and the first buffer is then reused to store the result of an XOR operation between the product K\u0394 now stored in the third buffer and the old parity value Q retrieved from the appropriate disk. This result, now stored in the first buffer, is then written back out to the appropriate disk as the new parity value Q.","Utilizing three buffers for a RAID-6 parity update, however, increases buffer requirements by 50% over the two buffers required for RAID-5 designs. As a result, in situations where the number of buffers is constrained, a RAID-6 design typically can have only \u2154the number of parity update operations in progress in comparison to a RAID-5 design, thus reducing throughput and limiting overall performance.","The invention addresses these and other problems associated with the prior art by algebraically combining multiple constant values used in updating multiple parity values for a parity stripe such that a product used in the generation of one parity value is effectively derived from the product used in the generation of the other parity value. By doing so, the delta value that is common to both products need not be separately stored in a buffer to calculate each product, thus eliminating the need for such a buffer. As a result, parity updates made to multiple parity values may be performed with a reduced number of required buffers, thus limiting the potential bottlenecks associated with the buffers, and improving overall throughput and performance.","By way of example, in one exemplary RAID-6 implementation consistent with the invention, where P and Q parity values are calculated by XOR'ing old P and Q values with separate products K\u0394 and K\u0394, the product K\u0394 is derived from the product K\u0394 by multiplying the product K\u0394 by a value (designated herein as K) representative of the ratio of Kand K(i.e., K\/K). As a result, the need for a separate buffer to store the delta value \u0394 for use in calculating each of the products K\u0394 and K\u0394 is eliminated.","Therefore, consistent with the invention, parity values for a parity stripe in a disk array are updated in association with storing new data in the parity stripe, where the disk array is of the type where the parity stripe includes at least first and second parity values related to data stored in the parity stripe by at least one parity stripe equation, and where the first parity value is capable of being updated based upon the new data using a first constant derived from the at least one parity stripe equation, and the second parity value is capable of being updated based upon the new data using a second constant derived from the at least one parity stripe equation. The parity values are updated by storing in a first buffer a first value representative of a product of the first constant and a delta value representative of a difference between the new data and old data previously stored in the parity stripe, updating the first parity value using the first value stored in the first buffer, storing in a second buffer a second value representative of a product of the first value stored in the first buffer and a third constant representative of a ratio of the second constant to the first constant, and updating the second parity value using the second value stored in the second buffer.","The embodiments discussed hereinafter reduce the number of buffers required to perform parity updates in RAID-6 and similar environments by algebraically combining multiple constant values used in updating multiple parity values for a parity stripe such that a product used in the generation of one parity value is effectively derived from the product used in the generation of the other parity value. By doing so, the need to separately store a delta value, representative of the difference between new and old data in a parity stripe, is often eliminated, thus reducing buffer requirements and improving performance.","Presented hereinafter are a number of embodiments of a disk array environment implementing the parity update operations consistent with the invention. However, prior to discussing such embodiments, a brief background on RAID-6 is provided, followed by a description of an exemplary hardware environment within which parity update operations consistent with the invention may be implemented.","General RAID-6 Background","The nomenclature used herein to describe RAID-6 storage systems conforms to the most readily accepted standards for this field. In particular, there are N drives of which any two are considered to be the parity drives, P and Q. Using Galois Field arithmetic, two independent equations can be written:\n\n\u03b1+\u03b1+\u03b1+. . . +\u03b1=0\u2003\u2003(1)\n\n\u03b1+\u03b1+\u03b1+. . . +\u03b1=0\u2003\u2003(2)\n\nwhere the \u201c+\u201d operator used herein represents an Exclusive-OR (XOR) operation.\n","In these equations, \u03b1is an element of the finite field and dis data from the xdisk. While the P and Q disk can be any of the N disks for any particular stripe of data, they are often noted as dand d. When data to one of the disks (i.e., d) is updated, the above two equations resolve to:\n\n\u0394=(old )+(new )\u2003\u2003(3)\n\n(new )=(old )+((\u03b1+\u03b1)\/(\u03b1+\u03b1))\u0394\u2003\u2003(4)\n\n(new )=(old )+((\u03b1+\u03b1)\/(\u03b1+\u03b1))\u0394\u2003\u2003(5)\n","In each of the last two equations the term to the right of the addition sign is a constant multiplied by the change in the data (i.e., \u0394). These terms in equations (4) and (5) are often denoted as K\u0394 and K\u0394, respectively.","In the case of one missing, or unavailable drive, simple XOR'ing can be used to recover the drive's data. For example, if dfails then dcan be restored by\n\n+. . . \u2003\u2003(6)\n","In the case of two drives failing, or being \u201cexposed\u201d, the above equations can be used to restore a drive's data. For example, given drives 0 through X and assuming drives A and B have failed, the data for either drive can be restored from the remaining drives. If for example, drive A was to be restored, the above equations reduce to:\n\n=((\u03b1+\u03b1)\/(\u03b1+\u03b1))+((\u03b1+\u03b1)\/(\u03b1+\u03b1))+. . . +((\u03b1+\u03b1)\/(\u03b1+\u03b1))\u2003\u2003(7)\n\nExemplary Hardware Environment\n","With this general background of RAID-6 in mind, attention can be turned to the drawings, wherein like numbers denote like parts throughout the several views.  illustrates an exemplary computer system in which a RAID-6, or other disk array, may be implemented. For the purposes of the invention, apparatus  may represent practically any type of computer, computer system or other programmable electronic device, including a client computer, a server computer, a portable computer, a handheld computer, an embedded controller, etc. Moreover, apparatus  may be implemented using one or more networked computers, e.g., in a cluster or other distributed computing system. Apparatus  will hereinafter also be referred to as a \u201ccomputer\u201d, although it should be appreciated the term \u201capparatus\u201d may also include other suitable programmable electronic devices consistent with the invention.","Computer  typically includes at least one processor  coupled to a memory . Processor  may represent one or more processors (e.g., microprocessors), and memory  may represent the random access memory (RAM) devices comprising the main storage of computer , as well as any supplemental levels of memory, e.g., cache memories, non-volatile or backup memories (e.g., programmable or flash memories), read-only memories, etc. In addition, memory  may be considered to include memory storage physically located elsewhere in computer , e.g., any cache memory in a processor , as well as any storage capacity used as a virtual memory, e.g., as stored on the disk array  or on another computer coupled to computer  via network  (e.g., a client computer ).","Computer  also typically receives a number of inputs and outputs for communicating information externally. For interface with a user or operator, computer  typically includes one or more user input devices  (e.g., a keyboard, a mouse, a trackball, a joystick, a touchpad, and\/or a microphone, among others) and a display  (e.g., a CRT monitor, an LCD display panel, and\/or a speaker, among others). Otherwise, user input may be received via another computer (e.g., a computer ) interfaced with computer  over network , or via a dedicated workstation interface or the like.","For additional storage, computer  may also include one or more mass storage devices accessed via a storage controller, or adapter, , e.g., removable disk drive, a hard disk drive, a direct access storage device (DASD), an optical drive (e.g., a CD drive, a DVD drive, etc.), and\/or a tape drive, among others. Furthermore, computer  may include an interface with one or more networks  (e.g., a LAN, a WAN, a wireless network, and\/or the Internet, among others) to permit the communication of information with other computers coupled to the network. It should be appreciated that computer  typically includes suitable analog and\/or digital interfaces between processor  and each of components , , ,  and  as is well known in the art.","In accordance with the principles of the present invention, the mass storage controller  advantageously implements RAID-6 storage protection within an array of disks .","Computer  operates under the control of an operating system , and executes or otherwise relies upon various computer software applications, components, programs, objects, modules, data structures, etc. (e.g., software applications ). Moreover, various applications, components, programs, objects, modules, etc. may also execute on one or more processors in another computer coupled to computer  via a network , e.g., in a distributed or client-server computing environment, whereby the processing required to implement the functions of a computer program may be allocated to multiple computers over a network.","In general, the routines executed to implement the embodiments of the invention, whether implemented as part of an operating system or a specific application, component, program, object, module or sequence of instructions, or even a subset thereof, will be referred to herein as \u201ccomputer program code,\u201d or simply \u201cprogram code.\u201d Program code typically comprises one or more instructions that are resident at various times in various memory and storage devices in a computer, and that, when read and executed by one or more processors in a computer, cause that computer to perform the steps necessary to execute steps or elements embodying the various aspects of the invention. Moreover, while the invention has and hereinafter will be described in the context of fully functioning computers and computer systems, those skilled in the art will appreciate that the various embodiments of the invention are capable of being distributed as a program product in a variety of forms, and that the invention applies equally regardless of the particular type of computer readable signal bearing media used to actually carry out the distribution. Examples of computer readable signal bearing media include but are not limited to recordable type media such as volatile and non-volatile memory devices, floppy and other removable disks, hard disk drives, magnetic tape, optical disks (e.g., CD-ROM's, DVD's, etc.), among others, and transmission type media such as digital and analog communication links.","In addition, various program code described hereinafter may be identified based upon the application within which it is implemented in a specific embodiment of the invention. However, it should be appreciated that any particular program nomenclature that follows is used merely for convenience, and thus the invention should not be limited to use solely in any specific application identified and\/or implied by such nomenclature. Furthermore, given the typically endless number of manners in which computer programs may be organized into routines, procedures, methods, modules, objects, and the like, as well as the various manners in which program functionality may be allocated among various software layers that are resident within a typical computer (e.g., operating systems, libraries, API's, applications, applets, etc.), it should be appreciated that the invention is not limited to the specific organization and allocation of program functionality described herein.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 2","FIG. 1"],"b":["16","202","208","12","210","212","218","204","212","218","212","218","212","218","202","210","210","212","210","212","218","202","206","206","202","206"]},"It will be appreciated that the embodiment illustrated in  is merely exemplary in nature. For example, it will be appreciated that the invention may be applicable to other disk array environments where multiple parity values are associated with each parity stripe. It will also be appreciated that a disk array environment consistent with the invention may utilize a completely software-implemented control algorithm resident in the main storage of the computer, or that some functions handled via program code in a computer or controller can be implemented in hardware logic circuits, and vice versa. Therefore, the invention should not be limited to the particular embodiments discussed herein.","Buffer Reduction For RAID-6 Parity Updates","In a RAID-6 system, six I\/O operations are generated for every normal parity update. These I\/O operations can be summarized as:","1) read an old data, dfrom a disk;","2) write new data, dto the disk;","3) read old parity, dfrom a disk;","4) write new parity, dto the disk;","5) read old parity, dfrom a disk, and","6) write new parity, dto the disk.","The new data and parity values are calculated according to the equations (3), (4) and (5). Typically, these operations require a number of buffers as shown in Table I below. The column refers to three different buffers A, B, C and the rows are different sequential steps of the operation of updating the parity.",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE I"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Buffer A","Buffer B","Buffer C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"get new data, d",{},{}]},{"entry":[{},{},"\u0394 = (old d) + A"]},{"entry":[{},"Write new data, d"]},{"entry":[{},{},{},"K\u0394 = K* B"]},{"entry":[{},"d= (old d) + C"]},{"entry":[{},"Write new parity, d"]},{"entry":[{},{},{},"K\u0394 = K* B"]},{"entry":[{},"d= (old d) + C"]},{"entry":[{},"write new parity, d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"In the above table, the addition (or XOR) steps are performed via an XOR engine in which data that is not in a buffer is read directly from a drive into the XOR engine. Compared to RAID-5, the parity update of RAID-6 utilizes additional buffers and, therefore, performs at about \u2154 the throughput in a buffer constrained environment.","Accordingly embodiments of the present invention include a different buffer arrangement that improves throughput of the parity update operation in a RAID-6 environment. In particular, rather than keep the delta value \u0394 in buffer B the entire time, simple algebra may be used to calculate the delta value \u0394 when generating new parity, d. Table II shown below, which represents a modification of Table I, illustrates how the values or products K\u0394 and K\u0394 (refer to equations (4) and (5)) can be manipulated to reduce the reliance on buffers in RAID-6 parity updates.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE II"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Buffer A","Buffer B","Buffer C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"get new data, d",{},{}]},{"entry":[{},{},"\u0394 = (old d) + A"]},{"entry":[{},"write new data, d",{},"NOT"]},{"entry":[{},"K\u0394 = K* B",{},"USED"]},{"entry":[{},{},"d= (old d) + A"]},{"entry":[{},{},"write new parity, d"]},{"entry":[{},{},"K\u0394 = K*A"]},{"entry":[{},"d= (old d) + B"]},{"entry":[{},"write new parity, d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"As can be seen from the table, a value Kis defined and stored such that K=K\/K. When the value Kis multiplied with the product K\u0394, the result is equal to K\u0394. Thus, by simple algebraic manipulation according to the above table, the RAID-6 parity update is accomplished using only two buffers, which will be appreciated can increase performance and throughput by limiting bottlenecks due to constrained buffer requirements.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 3","b":["302","304","306","308"],"sub":["x ","x ","x","1","1"]},"In step , the new parity P is calculated by XOR'ing the old parity P retrieved from disk dwith the contents of buffer A, and in step , the new parity P is written to disk d. Then, in step , the second value or product K\u0394 is calculated by multiplying the contents of buffer A by the constant K, which is set to equal K\/K, and stored in buffer B. Then, in step , the new parity Q is calculated by XOR'ing the old parity Q retrieved from disk dwith the contents of buffer B, and in step , the new parity Q is written to disk d. The parity update operation is then complete.","Thus, embodiments of the present invention provide a method and system, within a RAID-6 or similar environment where multiple parity values are associated with each parity stripe, that perform parity updates utilizing a reduced number of buffers. Various modifications may be made to the illustrated embodiments without departing from the spirit and scope of the invention. Therefore, the invention lies in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
