---
title: Touch support for remoted applications
abstract: Touch, multi-touch, gesture, flick and stylus pen input may be supported for remoted applications. For example, a touch capable client device may receive touch input for a remoted application executing on a server. In such an instance, the touch input may be transmitted to the server for processing. The server may modify the application display or the application functionality and provide an output to the client device. In some arrangements, the output may correspond to instructions for modifying a display of the application while in other examples, the output may correspond to an image of the changed application display. Additionally or alternatively, determining a functionality associated with touch input may be performed based on user definitions, user preferences, server definitions (e.g., operating system on the server), client definitions (e.g., operating system on the client) and the like and/or combinations thereof. Aspects may also include resolving latency and enhancing user experience.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09110581&OS=09110581&RS=09110581
owner: Citrix Systems, Inc.
number: 09110581
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20111005
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of priority from U.S. Provisional Application No. 61\/389,874, entitled \u201cMULTI-TOUCH SUPPORT FOR REMOTE APPLICATIONS,\u201d filed Oct. 5, 2010. The content of the above-noted application is hereby incorporated by reference in its entirety.","Aspects described herein generally relate to supporting touch input in an application. For example, aspects relate to providing touch input support for remoted applications.","Devices, both stationary and mobile, may provide touch support for applications and operating systems executing thereon. Additionally or alternatively, applications and operating systems may be touch-compatible or incompatible with touch input. In some arrangements, the applications may be remoted applications that are executed on a server device. The remoted applications may allow interactions by a user through a client device without requiring the client device to store or execute the application. Instead, the client device may receive application output and data from the server device and display the application output on the local display.","In some instances, the client device may be touch input compatible and thus, a user may wish to control the application using touch input. Because the application is executed at the server device, touch input directed to the application may be passed to the server for appropriate processing in the context of the application. However, in some arrangements, touch input may be handled in a proprietary or private manner according to an underlying operating system. For example, touch input data may be stored in a non-public memory area that might only be accessible by the operating system or functions thereof. An application may retrieve the touch input data by calling functions provided by the operating system. Accordingly, in some examples, passing touch input events from one device to another device may cause processing obstacles due to a potential inability to store the touch input data in the non-public memory areas of the operating system and retrieve the data using the operating system functions.","The following presents a simplified summary of the disclosure in order to provide a basic understanding of some aspects. It is not intended to identify key or critical elements of the disclosure or to delineate the scope of the disclosure. The following summary merely presents some concepts of the disclosure in a simplified form as a prelude to the more detailed description provided below.","According to one or more aspects, touch, multi-touch, flick, stylus pen input and gestures may be supported in remoted applications by providing the touch input data to the server executing the remoted application. In one example, the server may provide hooks that detect execution of a first function call intended to retrieve touch input data from private address spaces and to replace the first function call with a second function call to a public address space. In another example, the server may simulate or generate touch input events using a driver configured to access private address spaces of the operating system and store touch input data therein. In yet another example, on some server operating systems, the server may simulate or generate touch input events using an API designed for input injection. In some arrangements, the touch, multi-touch, gesture, flick and stylus pen support may be provided for applications remoted from one local device (e.g., a tablet or phone) to another local device (e.g., another tablet, PC or other device having a larger screen for input and viewing).","According to another aspect, touch input may be supported for legacy applications by converting the touch input into mouse events.","According to yet another aspect, touch input may be processed locally by the client or remotely by the server for a remoted application depending on a variety of factors. In one example, if latency is above a specified threshold, touch input may be processed locally. In another example, a user, application, server, client device or other entity may specify where touch input is to be processed.","According to another aspect, touch input may be translated into different functions depending on various factors including an operating system of the client device, an operating system of the server, user preferences, application requirements, and the like, and\/or combinations thereof.","According to still other aspects, applications may be input-type or input-source aware. Accordingly, even if the application is not compatible with touch input, if the input event originates from a touch-input device, the application may modify its display or interface or execute a function differently than if the input event originated from a non-touch input device.","Aspects described herein also include support for flick commands. Flick commands may be self-contained events, e.g., events that do not reference an address space on the device. The self-contained events may store the touch input data including coordinates, direction, pressure, etc. within the notification message. Touch or gesture input data may further include support for stylus\/pen input. For example, the touch or gesture input data may include coordinates, orientation, pressure (e.g., of the pen or stylus on the touch sensitive surface) and the like.","According to some aspects, a method for providing a shared session environment may be provided. The method may include facilitating the establishment of a first connection with a first remote computing device to provide access to a shared session window to the first device and facilitating the establishment of a second connection with a second remote computing device to provide access to the shared session window to the second device. The method may further include negotiating gesture capabilities with the first and second remote computing devices, receiving via the first connection data corresponding to a first gesture inputted at the shared session window displayed at the first device to interact with the shared session window and receiving via the second connection data corresponding to a second gesture inputted at the shared session window displayed at the second device to interact with the shared session window. Additionally, the method may include reconciling the data corresponding to the first and second gestures to generate a modification instruction representing the operations defined by the interactions with the shared session windows at the first and second remote computing devices, and transmitting a modified shared session window over the first and second connections to the first and second computing devices.","In some arrangements, the method may further include obtaining a first normalization timestamp from the first device and a second normalization timestamp from the second device, wherein the reconciliation step may include aligning a timestamp of the received first gesture based on the first normalization timestamp, and aligning a timestamp of the received second gesture based on the second normalization timestamp. Additionally, the reconciling step may include employing a mapping table that maps the data corresponding to the first gesture to a first shared session command and that maps the data corresponding to the second gesture to a second shared session command and\/or formatting the raw multi-touch information into a format compatible with the shared session window. The formatting, in some instances, may account for the negotiated gesture capabilities for the first remote computing device. In some examples, the first connection may include a screen sharing channel and a first input channel and the second connection may include the screen sharing channel and a second input channel. Moreover, the data corresponding to the first gesture may include raw multi-touch information. In yet other examples, the reconciliation step may include queuing, tossing, and\/or coalescing the first and\/or second gestures in low-bandwidth network conditions. Still further, the reconciling step may include, determining a difference in time of receipt between the first and second gesture; and discarding one of the first and second gesture in response to determining that the difference in time is lower than a threshold amount of time.","According to still further aspects, the negotiating step may include aggregating the capabilities of the first and second remote computing devices. Aggregating capabilities may, for example, include summing the number of touch inputs the first remote computing device is capable of receiving and the number of touch inputs the second remote computing device is capable of receiving.","According to other aspects, the data corresponding to the first gesture may be formatted for interpretation through processing of raw multi-touch information at the first remote computing device. In some examples, the data corresponding to the first gesture may correspond to a flick and\/or a stylus event coming from a pen or finger touch.","According to yet other aspects, a method for providing a shared session environment may include facilitating the establishment of a first connection with a first remote computing device to provide access to a shared session window to the first device, facilitating the establishment of a second connection with a second remote computing device to provide access to the shared session window to the second device, negotiating gesture capabilities with the first remote computing device, and receiving via the first connection data corresponding to a gesture inputted at the shared session window displayed at the first device to interact with the shared session window. Additionally, the method may include receiving via the second connection data corresponding to a non-gesture inputted at the shared session window displayed at the second device to interact with the shared session window, reconciling the data corresponding to the gesture and non-gesture to generate a modification instruction representing the operations defined by the interactions with the shared session windows at the first and second remote computing devices, and transmitting a modified shared session window over the first and second connections to the first and second computing devices. For example, the non-gesture may correspond to a mouse-click or a keyboard entry and the data corresponding to the first gesture may correspond to raw multi-touch information. In a particular example, the first gesture may be a flick or may be a stylus event coming from a pen or finger touch. The method may further include obtaining a first normalization timestamp from the first device and a second normalization timestamp from the second device, wherein the reconciliation step includes aligning a timestamp of the received gesture based on the first normalization timestamp, and aligning a timestamp of the received non-gesture based on the second normalization timestamp. The reconciling step may, alternatively or additionally, include employing a mapping table that maps the data corresponding to the gesture to a first shared session command and that maps the data corresponding to the non-gesture to a second shared session command. In some examples, the reconciling step may include formatting the raw multi-touch information into a format compatible with the shared session window and may account for the negotiated gesture capabilities for the first remote computing device. Still further, the reconciling step may include queuing, tossing, and\/or coalescing the first and\/or second gestures in low-bandwidth network conditions.","According to another aspect, the first connection comprises a screen sharing channel and a first input channel and the second connection comprises the screen sharing channel and a second input channel. Additionally or alternatively, the negotiation may include aggregating the capabilities of the first and second remote computing devices. For example, aggregating the capabilities may include summing the number of touch inputs the first remote computing device is capable of receiving and the number of touch inputs the second remote computing device is capable of receiving. According to yet other aspects, the data corresponding to the first gesture may be formatted for interpretation through processing of raw multi-touch information at the first remote computing device.","In still other arrangements, devices, systems and apparatuses having hardware components and software providing the functionality and features described herein may be provided. For example, a device may include a network interface for establishing one or more connection with other devices and a processor configured to execute software. The software may, for example, cause the device or apparatus to provide one or more functions, features or other aspects described herein.","The details of these and other embodiments of the present disclosure are set forth in the accompanying drawings and the description below. Other features and advantages of the disclosure will be apparent from the description and drawings, and from the claims.","Applications may be executed remotely by a first computing device for use at a second computing device (e.g., a client device). By using a remoted application, the client device may use processing power by the first computing device to execute the functionality and features of the remoted application. Additionally, data and applications may be served at a location that is accessible from multiple remote locations (e.g., through a public and\/or private network).",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 1A","b":["101","102","102","102","106","106","106","102","106"]},"In one example, the computing environment  can include an appliance (e.g., a device or apparatus) installed between the server(s)  and client machine(s) . This appliance can manage client\/server connections, and in some cases can load balance client connections amongst a plurality of backend servers.","The client machine(s)  may, in some examples, be a single client machine  or a single group of client machines , while server(s)  may be a single server  or a single group of servers . In one example, a single client machine  may communicate with more than one server , while in another example, a single server  may communicate with more than one client machine . In yet another example, a single client machine  might only communicate with a single server .","A client machine  may, in some examples, be referenced by any one of the following terms: client machine(s) ; client(s); client computer(s); client device(s); client computing device(s); local machine; remote machine; client node(s); endpoint(s); endpoint node(s); or a second machine. The server , in some examples, may be referenced by any one of the following terms: server(s), local machine; remote machine; server farm(s), host computing device(s), or a first machine(s).","According to one or more arrangements, the client machine  may be a virtual machine C. The virtual machine C may be any virtual machine, while in some configurations, the virtual machine C may be any virtual machine managed by a hypervisor developed by XenSolutions, Citrix Systems, IBM, VMware, or any other hypervisor. In other examples, the virtual machine C can be managed by any hypervisor, while in still other examples, the virtual machine C can be managed by a hypervisor executing on a server  or a hypervisor executing on a client .","The client machine  may, in some examples, execute, operate or otherwise provide an application such as: software; a program; executable instructions; a virtual machine; a hypervisor; a web browser; a web-based client; a client-server application; a thin-client computing client; an ActiveX control; a Java applet; software related to voice over internet protocol (VoIP) communications like a soft IP telephone; an application for streaming video and\/or audio; an application for facilitating real-time-data communications; a HTTP client; a FTP client; an Oscar client; a Telnet client; or any other set of executable instructions. Accordingly, in at least some arrangements, remoting an application may include a client device  receiving and displaying application output generated by an application remotely executing on a server  or other remotely located machine or computing device. For example, the client device  may display program output in application program window, a browser, or other output window. In one example, the program is a desktop or virtual desktop, while in other examples the program is an application. As used herein, a desktop refers to a graphical environment or space in which one or more applications may be hosted and\/or executed. A desktop may include a graphical shell providing a user interface for an instance of an operating system in which local and\/or remote applications can be integrated. Applications, as used herein, are programs that execute after an instance of an operating system (and, optionally, also the desktop) has been loaded. Each instance of the operating system may be physical (e.g., one operating system per device) or virtual (e.g., many instances of an OS running on a single device). Each application may be executed on a local device, or executed on a remotely located device (e.g., remoted). Applications may be remoted in multiple ways. In one example, applications may be remoted in a seamless manner in which windows are created on the client device so as to make the application display seem as if it were running locally on the client device and the desktop thereof. In another example, a remoted application may be provided in a windowed mode where a desktop is remoted to the client device and the application is displayed as an application executing in the remoted desktop. Various other remoting methods and techniques may also be implemented or used.","According to some aspects, the server  may execute a remote presentation client or other client or program that uses a thin-client or remote-display protocol to capture display output generated by an application executing on a server  and to subsequently transmit the application display output to a remote client . The thin-client or remote-display protocol can be any one of the following protocols (or other suitable protocol): the Independent Computing Architecture (ICA) protocol manufactured by Citrix Systems, Inc. of Ft. Lauderdale, Fla.; or the Remote Desktop Protocol (RDP) manufactured by the Microsoft Corporation of Redmond, Wash.","The computing environment can include more than one server A-N such that the servers A-N are logically and\/or physically grouped together into a server farm . In one example, the server farm  can include servers  that are geographically dispersed and logically grouped together in a server farm , or, in another example, servers  that are located proximate to each other and logically grouped together in a server farm . Geographically dispersed servers A-N within a server farm  can, in some examples, communicate using a WAN, MAN, or LAN, where different geographic regions can be characterized as: different continents; different regions of a continent; different countries; different states; different cities; different zip codes; different neighborhoods; different campuses; different rooms; or any combination of the preceding geographical locations. In some examples, the server farm  may be administered as a single entity, while in other examples, the server farm  can include multiple server farms .","A server farm  may include servers  that execute a substantially similar type of operating system platform (e.g., WINDOWS NT, manufactured by Microsoft Corp. of Redmond, Wash., UNIX, LINUX, or SNOW LEOPARD.) In other examples, the server farm  can include a first group of servers  that execute a first type of operating system platform, and a second group of servers  that execute a second type of operating system platform. The server farm , in other examples, can include servers  that execute different types of operating system platforms.","The server , in some examples, may be of any server type. In other examples, the server  can be any of the following server types: a file server; an application server; a web server; a proxy server; an appliance; a network appliance; a gateway; an application gateway; a gateway server; a virtualization server; a deployment server; a SSL VPN server; a firewall; a web server; an application server or as a master application server; a server  executing an active directory; or a server  executing an application acceleration program that provides firewall functionality, application functionality, or load balancing functionality. In some examples, a server  may be a RADIUS server that includes a remote authentication dial-in user service. In arrangements where the server  includes an appliance, the server  may be an appliance manufactured by any one of the following manufacturers: the Citrix Application Networking Group; Silver Peak Systems, Inc; Riverbed Technology, Inc.; F5 Networks, Inc.; or Juniper Networks, Inc. Some examples include a first server A that receives requests from a client machine , forwards the request to a second server B, and responds to the request generated by the client machine  with a response from the second server B. The first server A may acquire an enumeration of applications available to the client machine  as well as address information associated with an application server  hosting an application identified within the enumeration of applications. The first server A may then present a response to the client's request using a web interface, and communicate directly with the client  to provide the client  with access to an identified application.","The server  may, in some examples, execute any one of the following applications: a thin-client application using a thin-client protocol to transmit application display data to a client; a remote display presentation application; any portion of the CITRIX ACCESS SUITE by Citrix Systems, Inc. like the METAFRAME or CITRIX PRESENTATION SERVER; MICROSOFT WINDOWS Terminal Services manufactured by the Microsoft Corporation; or an ICA client, developed by Citrix Systems, Inc. Another example includes a server  that is an application server such as: an email server that provides email services such as MICROSOFT EXCHANGE manufactured by the Microsoft Corporation; a web or Internet server; a desktop sharing server; a collaboration server; or any other type of application server. Still other examples include a server  that executes any one of the following types of hosted servers applications: GOTOMEETING provided by Citrix Online Division, Inc.; WEBEX provided by WebEx, Inc. of Santa Clara, Calif.; or Microsoft Office LIVE MEETING provided by Microsoft Corporation.","Client machines  may, in some examples, be a client node that seeks access to resources provided by a server . In other examples, the server  may provide clients  or client nodes with access to hosted resources. The server , in some examples, functions as a master node such that it communicates with one or more clients  or servers . In some examples, the master node may identify and provide address information associated with a server  hosting a requested application, to one or more clients  or servers . In still other examples, the master node may be a server farm , a client , a cluster of client nodes , or an appliance.","One or more clients  and\/or one or more servers  may transmit data over a network  installed between machines and appliances within the computing environment . The network  may comprise one or more sub-networks, and may be installed between any combination of the clients , servers , computing machines and appliances included within the computing environment . In some examples, the network  may be: a local-area network (LAN); a metropolitan area network (MAN); a wide area network (WAN); a primary network  comprised of multiple sub-networks  located between the client machines  and the servers ; a primary public network  with a private sub-network ; a primary private network  with a public sub-network ; or a primary private network  with a private sub-network . Still further examples include a network  that may be any of the following network types: a point to point network; a broadcast network; a telecommunications network; a data communication network; a computer network; an ATM (Asynchronous Transfer Mode) network; a SONET (Synchronous Optical Network) network; a SDH (Synchronous Digital Hierarchy) network; a wireless network; a wireline network; or a network  that includes a wireless link where the wireless link may be an infrared channel or satellite band. The network topology of the network  may differ within different examples, possible network topologies include: a bus network topology; a star network topology; a ring network topology; a repeater-based network topology; or a tiered-star network topology. Additional examples may include a network  of mobile telephone networks that use a protocol to communicate among mobile devices, where the protocol may be any one of the following: AMPS; TDMA; CDMA; GSM; GPRS UMTS; or any other protocol able to transmit data among mobile devices.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 1B","FIG. 1A"],"b":["100","102","106","100","100","150","121","122","128","123","124","124","116","118","128","120","123","126","127","123","130","130"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 1C","FIG. 1A"],"b":["100","102","106","100","100","150","170","130","170","121","121","130","122","140","121","103"]},"Examples of the computing machine  may include a central processing unit  characterized by any one of the following component configurations: logic circuits that respond to and process instructions fetched from the main memory unit ; a microprocessor unit, such as: those manufactured by Intel Corporation; those manufactured by Motorola Corporation; those manufactured by Transmeta Corporation of Santa Clara, Calif.; the RS\/6000 processor such as those manufactured by International Business Machines; a processor such as those manufactured by Advanced Micro Devices; or any other combination of logic circuits. Still other examples of the central processing unit  may include any combination of the following: a microprocessor, a microcontroller, a central processing unit with a single processing core, a central processing unit with two processing cores, or a central processing unit with more than one processing core.","While  illustrates a computing device  that includes a single central processing unit , in some examples the computing device  may include one or more processing units . In these examples, the computing device  may store and execute firmware or other executable instructions that, when executed, direct the one or more processing units  to simultaneously execute instructions or to simultaneously execute instructions on a single piece of data. In other examples, the computing device  may store and execute firmware or other executable instructions that, when executed, direct the one or more processing units to each execute a section of a group of instructions. For example, each processing unit  may be instructed to execute a portion of a program or a particular module within a program.","In some examples, the processing unit  may include one or more processing cores. For example, the processing unit  may have two cores, four cores, eight cores, etc. In one example, the processing unit  may comprise one or more parallel processing cores. The processing cores of the processing unit , may in some examples access available memory as a global address space, or in other examples, memory within the computing device  may be segmented and assigned to a particular core within the processing unit . In one example, the one or more processing cores or processors in the computing device  may each access local memory. In still another example, memory within the computing device  may be shared amongst one or more processors or processing cores, while other memory may be accessed by particular processors or subsets of processors. In examples where the computing device  includes more than one processing unit, the multiple processing units may be included in a single integrated circuit (IC). These multiple processors, in some examples, may be linked together by an internal high speed bus, which may be referred to as an element interconnect bus.","In examples where the computing device  includes one or more processing units , or a processing unit  including one or more processing cores, the processors may execute a single instruction simultaneously on multiple pieces of data (SIMD), or in other examples may execute multiple instructions simultaneously on multiple pieces of data (MIMD). In some examples, the computing device  may include any number of SIMD and MIMD processors.","The computing device , in some examples, may include a graphics processor or a graphics processing unit (Not Shown). The graphics processing unit may include any combination of software and hardware, and may further input graphics data and graphics instructions, render a graphic from the inputted data and instructions, and output the rendered graphic. In some examples, the graphics processing unit may be included within the processing unit . In other examples, the computing device  may include one or more processing units , where at least one processing unit  is dedicated to processing and rendering graphics.","In one example, computing machine  may include a central processing unit  that communicates with cache memory  via a secondary bus also known as a backside bus, while another example of the computing machine  includes a central processing unit  that communicates with cache memory via the system bus . The local system bus  may, in some examples, also be used by the central processing unit to communicate with more than one type of I\/O device A-N. In some examples, the local system bus  may be any one of the following types of buses: a VESA VL bus; an ISA bus; an EISA bus; a MicroChannel Architecture (MCA) bus; a PCI bus; a PCI-X bus; a PCI-Express bus; or a NuBus. Alternatively or additionally, computing machine  may include an I\/O device A-N that is a video display  that communicates with the central processing unit . Still other versions of the computing machine  include a processor  connected to an I\/O device A-N via any one of the following connections: HyperTransport, Rapid I\/O, or InfiniBand. Further examples of the computing machine  include a processor  that communicates with one I\/O device A using a local interconnect bus and a second I\/O device B using a direct connection.","The computing device , in some examples, includes a main memory unit  and cache memory . The cache memory  may be any memory type, and in some examples may be any one of the following types of memory: SRAM; BSRAM; or EDRAM. Other examples include cache memory  and a main memory unit  that may be any one of the following types of memory: Static random access memory (SRAM), Burst SRAM or SynchBurst SRAM (BSRAM); Dynamic random access memory (DRAM); Fast Page Mode DRAM (FPM DRAM); Enhanced DRAM (EDRAM), Extended Data Output RAM (EDO RAM); Extended Data Output DRAM (EDO DRAM); Burst Extended Data Output DRAM (BEDO DRAM); Enhanced DRAM (EDRAM); synchronous DRAM (SDRAM); JEDEC SRAM; PC100 SDRAM; Double Data Rate SDRAM (DDR SDRAM); Enhanced SDRAM (ESDRAM); SyncLink DRAM (SLDRAM); Direct Rambus DRAM (DRDRAM); Ferroelectric RAM (FRAM); or any other type of memory. Further examples include a central processing unit  that may access the main memory  via: a system bus ; a memory port ; or any other connection, bus or port that allows the processor  to access memory .","In one or more arrangements, computing device  may provide support for any one of the following installation devices : a CD-ROM drive, a CD-R\/RW drive, a DVD-ROM drive, tape drives of various formats, USB device, a bootable medium, a bootable CD, a bootable CD for GNU\/Linux distribution such as KNOPPIX\u00ae, a hard-drive or any other device suitable for installing applications or software. Applications may, in some examples, include a client agent , or any portion of a client agent . The computing device  may further include a storage device  that may be either one or more hard disk drives, or one or more redundant arrays of independent disks; where the storage device is configured to store an operating system, software, programs applications, or at least a portion of the client agent . Computing device  may also include an installation device  that is used as the storage device .","The computing device  may further include a network interface  to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., 802.11, T1, T3, 56 kb, X.25, SNA, DECNET), broadband connections (e.g., ISDN, Frame Relay, ATM, Gigabit Ethernet, Ethernet-over-SONET), wireless connections, or some combination of any or all of the above. Connections may also be established using a variety of communication protocols (e.g., TCP\/IP, IPX, SPX, NetBIOS, Ethernet, ARCNET, SONET, SDH, Fiber Distributed Data Interface (FDDI), RS232, RS485, IEEE 802.11, IEEE 802.11a, IEEE 802.11b, IEEE 802.11g, CDMA, GSM, WiMax and direct asynchronous connections). One version of the computing device  includes a network interface  able to communicate with additional computing devices \u2032 via any type and\/or form of gateway or tunneling protocol such as Secure Socket Layer (SSL) or Transport Layer Security (TLS), or the Citrix Gateway Protocol manufactured by Citrix Systems, Inc. Versions of the network interface  may comprise any one of: a built-in network adapter; a network interface card; a PCMCIA network card; a card bus network adapter; a wireless network adapter; a USB network adapter; a modem; or any other device suitable for interfacing the computing device  to a network capable of communicating and performing the methods and systems described herein.","According to one or more aspects, computing device  may include any one of the following I\/O devices A-N: a keyboard ; a pointing device ; mice; track pads; an optical pen; trackballs; microphones; drawing tablets; video displays; speakers; inkjet printers; laser printers; and dye-sublimation printers; or any other input\/output device able to perform the methods and systems described herein. An I\/O controller  may in some examples connect to multiple I\/O devices A-N to control the one or more I\/O devices. In some examples, I\/O devices A-N may be configured to provide storage or an installation medium , while others may provide a universal serial bus (USB) interface for receiving USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry, Inc. Additionally or alternatively, computing device  may include I\/O device  that may be a bridge between the system bus  and an external communication bus, such as: a USB bus; an Apple Desktop Bus; an RS-232 serial connection; a SCSI bus; a FireWire bus; a FireWire  bus; an Ethernet bus; an AppleTalk bus; a Gigabit Ethernet bus; an Asynchronous Transfer Mode bus; a HIPPI bus; a Super HIPPI bus; a SerialPlus bus; a SCI\/LAMP bus; a FibreChannel bus; or a Serial Attached small computer system interface bus.","In some examples, the computing machine  may connect to multiple display devices A-N, in other examples the computing device  may connect to a single display device , while in still other examples the computing device  connects to display devices A-N that are the same type or form of display, or to display devices that are different types or forms. Examples of the display devices A-N may be supported and enabled by the following: one or multiple I\/O devices A-N; the I\/O controller ; a combination of I\/O device(s) A-N and the I\/O controller ; any combination of hardware and software able to support a display device A-N; any type and\/or form of video adapter, video card, driver, and\/or library to interface, communicate, connect or otherwise use the display devices A-N. The computing device  may in some examples be configured to use one or multiple display devices A-N, these configurations include: having multiple connectors to interface to multiple display devices A-N; having multiple video adapters, with each video adapter connected to one or more of the display devices A-N; having an operating system configured to support multiple displays A-N; using circuits and software included within the computing device  to connect to and use multiple display devices A-N; and executing software on the main computing device  and multiple secondary computing devices to enable the main computing device  to use a secondary computing device's display as a display device A-N for the main computing device . Still other examples of the computing device  may include multiple display devices A-N provided by multiple secondary computing devices and connected to the main computing device  via a network.","According to one or more arrangements, the computing machine  may execute any operating system including: versions of the MICROSOFT WINDOWS operating systems such as WINDOWS 3.x; WINDOWS 95; WINDOWS 98; WINDOWS 2000; WINDOWS NT 3.51; WINDOWS NT 4.0; WINDOWS CE; WINDOWS XP; and WINDOWS VISTA; the different releases of the Unix and Linux operating systems; any version of the MAC OS manufactured by Apple Computer; OS\/2, manufactured by International Business Machines; any embedded operating system; any real-time operating system; any open source operating system; any proprietary operating system; any operating systems for mobile computing devices; or any other operating system. In some examples, the computing machine  may execute multiple operating systems. For example, the computing machine  may execute PARALLELS or another virtualization platform that may execute or manage a virtual machine executing a first operating system, while the computing machine  executes a second operating system different from the first operating system.","The computing machine  may be embodied in any one of the following computing devices: a computing workstation; a desktop computer; a laptop or notebook computer; a server; a handheld computer (e.g., a tablet computer such as the iPad and iPad 2 manufactured by Apple Computer); a mobile telephone; a portable telecommunication device; a media playing device; a gaming system; a mobile computing device; a netbook; a device of the IPOD family of devices manufactured by Apple Computer; any one of the PLAYSTATION family of devices manufactured by the Sony Corporation; any one of the Nintendo family of devices manufactured by Nintendo Co; any one of the XBOX family of devices manufactured by the Microsoft Corporation; or any other type and\/or form of computing, telecommunications or media device that is capable of communication and that has sufficient processor power and memory capacity to perform the methods and systems described herein. In other examples the computing machine  may be a mobile device such as any one of the following mobile devices: a JAVA-enabled cellular telephone or personal digital assistant (PDA), such as the i55sr, i58sr, i85s, i88s, i90c, i95cl, or the im1100, all of which are manufactured by Motorola Corp; the 6035 or the 7135, manufactured by Kyocera; the i300 or i330, manufactured by Samsung Electronics Co., Ltd; the TREO 180, 270, 600, 650, 680, 700p, 700w, or 750 smart phone manufactured by Palm, Inc; any computing device that has different processors, operating systems, and input devices consistent with the device; or any other mobile computing device capable of performing the methods and systems described herein. In still other examples, the computing device  may be any one of the following mobile computing devices: any one series of Blackberry, or other handheld device manufactured by Research In Motion Limited; the iPhone manufactured by Apple Computer; Palm Pre; a Pocket PC; a Pocket PC Phone; or any other handheld mobile device.","In some examples, the computing device  may have different processors, operating systems, and input devices consistent with the device. For example, in one example, the computing device  is a TREO 180, 270, 600, 650, 680, 700p, 700w, or 750 smart phone manufactured by Palm, Inc. In some of these examples, the TREO smart phone is operated under the control of the PalmOS operating system and includes a stylus input device as well as a five-way navigator device.","According to one or more configurations, the computing device  may be a mobile device, such as a JAVA-enabled cellular telephone or personal digital assistant (PDA), such as the i55sr, i58sr, i85s, i88s, i90c, i95cl, or the im1100, all of which are manufactured by Motorola Corp. of Schaumburg, Ill., the 6035 or the 7135, manufactured by Kyocera of Kyoto, Japan, or the i300 or i330, manufactured by Samsung Electronics Co., Ltd., of Seoul, Korea. In some examples, the computing device  is a mobile device manufactured by Nokia of Finland, or by Sony Ericsson Mobile Communications AB of Lund, Sweden.","In some examples, the computing device  may be a Blackberry handheld or smart phone, such as the devices manufactured by Research In Motion Limited, including the Blackberry 7100 series, 8700 series, 7700 series, 7200 series, the Blackberry 7520, or the Blackberry Pearl 8100. In yet other examples, the computing device  is a smart phone, Pocket PC, Pocket PC Phone, or other handheld mobile device supporting Microsoft Windows Mobile Software. Moreover, the computing device  may be any workstation, desktop computer, laptop or notebook computer, server, handheld computer, mobile telephone, any other computer, or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.","Additionally or alternatively, the computing device  may be a digital audio player. For example, the computing device  is a digital audio player such as the Apple IPOD, IPOD Touch, IPOD NANO, and IPOD SHUFFLE lines of devices, manufactured by Apple Computer of Cupertino, Calif. In another of these examples, the digital audio player may function as both a portable media player and as a mass storage device. In other examples, the computing device  is a digital audio player such as the DigitalAudioPlayer Select MP3 players, manufactured by Samsung Electronics America, of Ridgefield Park, N.J., or the Motorola m500 or m25 Digital Audio Players, manufactured by Motorola Inc. of Schaumburg, Ill. In still other examples, the computing device  is a portable media player, such as the Zen Vision W, the Zen Vision series, the Zen Portable Media Center devices, or the Digital MP3 line of MP3 players, manufactured by Creative Technologies Ltd. In yet other examples, the computing device  is a portable media player or digital audio player supporting file formats including, but not limited to, MP3, WAV, M4A\/AAC, WMA Protected AAC, RIFF, Audible audiobook, Apple Lossless audio file formats and .mov, .m4v, and .mp4 MPEG-4 (H.264\/MPEG-4 AVC) video file formats.","The computing device  may, alternatively or additionally, include a combination of devices, such as a mobile phone combined with a digital audio player or portable media player. In one of these examples, the computing device  is a Motorola RAZR or Motorola ROKR line of combination digital audio players and mobile phones. In another of these examples, the computing device  is an iPhone smartphone, manufactured by Apple Computer of Cupertino, Calif.","Application Display Management","Referring now to , the block diagram illustrates an example system for displaying a plurality of resources on one or more display devices. The system includes a mobile computing device  that may communicate with one or more external display devices -. The example in  shows a mobile computing device  with a native display , although devices without native displays may also be used. The mobile computing device  executes a plurality of resources -(collectively, ). The window management system  and virtual graphics driver  manage the locations and sizes of the display of output data associated with each of the plurality of resources in a user-configurable display layout. In many examples, the mobile computing device  transmits the output data associated with each of the plurality of resources  to an external display device . In some of these examples, the mobile computing device  transmits the output data upon establishing a connection with the external display device . Alternatively or additionally, the mobile computing device  transmits the output data associated with each of the plurality of resources  to the device's native display . For example, the mobile computing device  might only transmit the output data to the device's native display or only transmit the output data to one or more of the external display devices -. In some examples, the mobile computing device  transmits the output data associated with certain of the plurality of resources  to the native display  and transmits the output data associated with other ones of the plurality of resources  to the external display devices -","Mobile computing device  may be configured to execute a plurality of resources . In one example, the mobile computing device  is a client  as described above in connection with . In another example, the mobile computing device  displays the output data associated with a resource in a plurality of resources -executed by the mobile computing device . In some examples, the mobile computing device  displays the output data associated with each of the plurality of resources .","A resource in the plurality of resources  may include, without limitation, a data file, an executable file, configuration files, an application, a desktop environment (which may itself include a plurality of applications for execution by the user), a computing environment image (such as a virtual machine image), and\/or operating system software or other applications needed to execute a computing environment image.","According to one or more arrangements, mobile computing device  includes a window management service  allowing an external display device  to display the output data associated with each of a plurality of resources  executed on the mobile computing device . The window management service  may also allow multiple resources running on the mobile computing device  to be viewed on an external display device  or the native display  at substantially the same time, as opposed to allowing the output of one resource  to be viewed exclusively on the native display  or external display device . In one example, the window management service , in conjunction with a virtual graphics driver , manages the display layout of the windows displayed on the external display device  and the native display . In some examples, the virtual graphics driver  is a driver-level component that manages a virtual screen frame buffer storing output data that will be displayed by the native display  on the mobile computing device  or an external display device . The window management service , in conjunction with the virtual graphics driver , may further manage the boundaries and size of a screen space used to display output data and on which display device the output data is displayed.","In some examples, an external display device  receives output data associated with each of the plurality of resources  and displays the output data in a user-configurable display layout. In one example, the external display device  includes a dock to which the mobile computing device  connects. In another example, the external display device  includes a receiver for communicating with the mobile computing device  wirelessly, for example, via BLUETOOTH, Wi-Fi or other networking protocols, as described above in connection with . In still another example, the external display device  may be a display device  as described above in connection with .","Referring now to , the block diagram illustrates an example system for mapping the display of one or more resources  of the mobile computing device  on one or more display devices  and\/or . In various examples, the window management service  manages a virtual screen space . The virtual screen space  may map to the native display  and one or more external display devices . The window management service  may position output data associated with the user interfaces of one or more resources  on the virtual screen space  to specify where each user interface will be displayed. In some examples, the window management service  positions the output data according to a user preference. In additional examples, the window management service  positions the output data according to a policy. In various examples, the window management service  positions the output data based on the resource  associated with the output data.","The window management service  communicates with the virtual graphics driver  to transmit output data associated with user interfaces of resources  to the native display  and one or more external display devices . In some examples, the window management service  may transmit output data and associated coordinates from the virtual screen space  to the virtual graphics driver . In various examples, the virtual graphics driver  stores the output data in a virtual screen frame buffer. In many examples, the virtual graphics driver  transmits the entries in the virtual screen frame buffer to the native display  and external display devices . In many examples, the virtual graphics driver  transmits an entry in the virtual screen frame buffer to a native display  or an external display device  based on the position of the entry in the frame buffer.","Referring now to , the user interface illustrates an example user-configurable display layout in which the external display device  displays the output data of the resources . In this example, the output data of the resources  is displayed in a grid display layout. The grid display layout may include one or more cells in an arrangement. A cell may display output data associated with a resource. In some examples, more than one cell displays output data associated with the same resource.","Additionally, in some examples, the cells are uniformly sized, whereas in other examples, the cells have different sizes. The cells may be arranged in any configuration. In some examples, the cells may be arranged in rows, columns, or both. A cell may have a descriptor associated with the cell's position in the grid. The descriptor may indicate the position of a cell within a row. In the example depicted in , the cell for resource may have the descriptor \u201c-,\u201d the cell for resource may have the descriptor \u201c-,\u201d the cell for resource may have the descriptor \u201c-,\u201d the cell for resource may have the descriptor \u201c-,\u201d and the cell for resource may have the descriptor \u201c-.\u201d In other examples, the cells may be numbered, e.g. \u201cCell ,\u201d \u201cCell ,\u201d etc. However, any system of choosing descriptors known to those of ordinary skill in the art may be used.","In various examples, the window management service  configures a grid display layout according to the resources  being displayed on the native display  or the external display device . In some examples, the service  configures a grid display layout according to the number of resources  being displayed. In other examples, the service  configures a grid display layout according to the size or amount of content in the user interfaces of the resources . For example, if an external display device  will display four resources with comparable amounts of content, the window management service  may configure a grid display layout with four uniform cells. In another example, if an external display device  will display four resources and one resource includes three times as much content as the others, the window management service  may configure a grid display layout with three uniform cells in a first row and a single cell in a second row. The single cell in the second row may be three times as wide as the cells in the first row. In various examples, the window management service  may configure a grid display layout to reserve a cell for displaying information about the resources being displayed, such as a menu of the resources. In many examples, the window management service  may configure a grid display layout to reserve a cell for allowing a user to configure the grid display layout.","Referring now to , a user interface illustrates an example user-configurable display layout providing a dynamic display layout in which the external display device  displays the output data associated with the plurality of resources . In this example, windows on the external display device  that display output data for resources  may be dynamically positioned and sized. The window management service  may position a user interface for a resource at a default position and with a default size chosen according to a policy, the resource , or any other method. The window management service  may order overlapping user interfaces such that higher-order user interfaces obscure lower-order user interfaces. The window management service  may transmit output data to the virtual graphics driver  reflecting the obfuscation. The user may re-position or re-size a window by, for example, clicking and dragging the window or a window edge. In these examples, the virtual graphics driver  may detect the user's change to the window, and transmit information about the user's change to the window management service . The window management service  may process the change and transmit updated output data to the virtual graphics driver . In some examples, the user moves the user interface for a resource  to any location on a native display  or external display device . In some examples, the user moves the user interface for a resource  to a different display device. In some examples, the updated output data indicates that one user interface's size has been increased or location has been adjusted to obscure another user interface. In other examples, the updated output data indicates that one user interface's size has been decreased or location has been adjusted such that more of another user interface shall be visible.","Referring now to , a block diagram illustrates example virtual screen spaces  provided by a mobile computing device attached to one or more external display devices. As shown in , the mobile computing device  includes a virtual graphics driver  and a virtual screen . The virtual screen  includes a plurality of virtual screen spaces  and -. Virtual screen space  may be a native display screen space for the native display  on the mobile computing device . The other virtual screen spaces -may be extended screen spaces that correspond to the displays of external display devices . The window management service  and virtual graphics driver  manage the virtual screen . In one example, the virtual graphics driver  uses a virtual screen frame buffer to manage the mobile computing device's native display  and change the native display's  screen resolution. In another example, the virtual graphics driver  uses a virtual screen frame buffer to manage an extended screen space  and to change a resolution of the extended screen .","In some examples, the virtual graphics driver  allocates and manages a plurality of virtual screen spaces , -and virtual screen frame buffers. In some of these examples, each virtual screen space and virtual screen frame buffer has a resolution independent of the other screen spaces and frame buffers. In one of these examples, output data associated with each of the plurality of resources  may reside within any of the virtual screen spaces , -. In another of these examples, each of the extended screen spaces -is associated with at least one external display device , depending on the capabilities of the device.","In various examples, the window management service  and the virtual graphics driver  allocate and manage the display, on a plurality of external display devices , of output data associated with a plurality of resources. For example, output data associated with a resource displays on a mobile computing device , output data associated with a resource displays on one external display device , and output data associated with a resource display on another external display device . In another of these examples, the window management device  identifies one of the external display devices  for displaying output data generated by a resource based upon a type of the resource . For example, the window management service  may determine that a type of resource rendering a video may display on a television screen, while a type of resource rendering a word processing application may render on a display of a laptop computer.","Referring now to , a block diagram illustrates an example mobile computing device  providing a virtual screen  with virtual screen spaces , -of varying resolutions. In this example, the virtual screen  includes a native display screen space  corresponding to the native display  of the mobile computing device  with a resolution of 320 pixels\u00d7240 pixels. The virtual screen  also includes an extended screen corresponding to the display of an external display device  with a resolution of 1024 pixels\u00d7768 pixels, an extended screen 1 corresponding to the display of an external display device  with a resolution of 800 pixels\u00d7600 pixels, and an extended screen corresponding to the display of an external display device  with a resolution of 640 pixels\u00d7480 pixels. In many examples, the virtual screen  may include a native display screen space  and any number of extended screens  of any resolution. The entire virtual screen space  may be mapped into a single virtual screen frame buffer, although examples that map into multiple buffers may be used.","Referring now to , the block diagram illustrates an example logical representation of a plurality of virtual screen spaces managed by a virtual graphics driver. In this example, the virtual graphics driver  manages multiple virtual screen spaces with different resolutions in a virtual screen frame buffer. In this example, the native display  of the mobile computing device is the primary display and the external display device , corresponding to the extended screen , is a secondary display. In various examples, output data associated with resources  on the native display screen space  will be displayed on the native display  and output data associated with resources  on the extended screen space will be displayed on the external display device  associated with the extended screen spaces . In other examples, all output data associated with resources  may be displayed on the native display . In still other arrangements, all output data associated with resources  may be displayed on an external display device such as external display device .","Supporting Touch Input in Remoting Applications",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 5","FIG. 5","FIG. 2B"],"b":["102","501","102","102","204","102","102","102","206","102","208","204","102","102","208","210","210","102","201","102","204","102","501","505","505","505","505","501","510","505","102","505","102"],"i":"a"},"According to one or more arrangements, resources  executing on the mobile device  and\/or resources A-N may be applications configured to accept data inputted by a touch screen. For example, the applications may be modified versions of applications that typically do not receive data from a touch screen. These modified applications  may receive data inputted by a user via a touch screen of the mobile device , and may be modified to accommodate typical touch screen input functions like a virtual keyboard and a virtual scroll menu. For example, a modified version of SAFARI, a web browser published by APPLE, may be modified to pan up when a user selects or gives focus to an edit control such as a text box. SAFARI pans the application upwards to accommodate the virtual keyboard displayed over the browser and so that a user may view the text box while typing on the virtual keyboard.","Touch input may include a variety of instrument, hand or finger movements and actions including touching a point on the screen, stylus pen inputs, swiping movements, flicking movements, multi-finger or multi-touch actions (e.g., pinching, expansion) and gestures and the like. The touch input may trigger different functionalities depending on the type of application receiving the input. For example, some applications may receive a flicking action as closing the application while other applications may interpret a flicking input as moving the application window in a certain direction. Each application may define its own interpretation of different types of touch input or may use a standard definition provided by an underlying operating system.","According to one or more configurations, the mobile device  may communicate with remote computer  in a variety of ways. The remote computer  may be a server, a client or any other computing machine. In some examples the remote computer  may be a remote application server that executes one or more applications for mobile device . Accordingly, in some examples, the mobile device  may communicate with the remote computer  over one or more virtual channels. In some examples, virtual channels may be established over a network and may be referred to as a control virtual channel. In other examples, the virtual channel may be a seamless virtual channel. A control virtual channel may be used to remote control commands and other miscellaneous commands (e.g., for an application) while the seamless virtual channel may be used to remote application windows, a taskbar, a systray, etc. Thus, in some examples, each virtual channel may remote different functions and content. In still other examples, the virtual channel may be established by a window management service  executing on the mobile device , or the virtual channel may be established by both the window management service  and a remoting client  executing on the remote computer . The virtual channel may in some examples facilitate communication sent using the ICA protocol.","In some examples, the remote computer  may execute a remoting client . The remoting client  may be a control virtual channel or a seamless virtual channel and may be a remoting application that corresponds to the virtual channel used by the client  to transmit data to and receive data from the mobile device . In some examples, the remoting client  may collaborate with the window management service  (of the mobile computing device ) to modify remote applications  for remote display on the mobile device . The window management service  may be, for example, a CITRIX RECEIVER published by CITRIX SYSTEMS. In some examples, the remoting client  may communicate with the remote applications  to intercept event providing notifications and data generated by the remote applications . In particular, the remoting client  may perform event-based detection of one or more controls using application programming interfaces provided by one or more of the remote applications . For example, at least one remote application  may be an operating system executing on the remote computer . Another remote application B may be executing on the remote computer  and within the context of the operating system . In these examples, the remoting client  may intercept events generated by controls within the remote application B using application program interfaces made available by the operating system . The controls may be selected by the remoting client  based on whether the control has focus on or is on a predetermined list of controls of interest. A control, in some examples, may be an object within an application that a user interacts with, e.g. a text box, drop down menu, radio button, button, check box, edit box, combo box etc. The control may further be referred to as a field or interactive element. In some examples, the remoting client  may intercept the control-generated events by registering with a communication interface associated with the application B to receive notifications when a focus-change event occurs within the application B. For example, the remoting client  may receive a notification when an object or control receives focus, e.g., indicating that a user selected a text box within the application.","In some examples, the remoting client  may communicate with the window management service  over the virtual channel. In a particular example, the remoting client  may send intercepted event notifications over the virtual channel to the window management service . In other examples, the remoting client  may transmit location coordinates for a control, the type of control, the contents of a control, the window handle of a control, and\/or parent window information for a control. Window handles or other identification information for elements within an interface or application may include a globally unique identifier (GUID). The window management service  may receive information from the remoting client  and adjust or modify display of an application  on the native display  using the received information. Adjusting the display may include panning, zooming (in or out), scrolling or otherwise modifying the display of the application .","In some examples, the remote computer  may execute one or more resources . These resources, in some examples, may be applications. In other examples, at least one resource may be an operating system executing on the remote computer . In those examples, the other applications  may execute within the context of the operating system. In some instances, the applications  may correspond to remote applications  from the perspective of device  and one or more of applications  may be remoted to mobile device  for use by the user at mobile device .",{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 6","b":["600","206","102","501","605","501","610","615","501","620","625"]},{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 7","b":["700","705","710"]},"If the client device determines that the type of application is a locally executed application, the client device may forward the notification message to the application in step  for local processing by the application and\/or the underlying operating system. If, however, the client device determines that the touch input is issued to an application window or user interface element corresponding to a remoted application or desktop, the operating system can ignore that input. Ignoring the input may cause the invocation of a default window procedure (e.g. DefWindowProc) which handles the input by trying to convert the gesture and multi-touch input into mouse events. In one or more examples, the client device (or a window management service thereof) may be configured to include a sub-function or module that may handle touch (e.g., multi-touch), flick, stylus pen and gesture events for remoted applications. In such a configuration, the window management service of the client device may intercept touch (e.g., gesture and multi-touch) events issued to an application window or other interface element corresponding to a remotely executing application or desktop and\/or ignored by the local operating system in step .","The window management service of the client device, in response to intercepting or detecting a touch, multi-touch or gesture input message corresponding to a remoted application, may extract information about the gesture or touch input in step . Extracting the gesture information may include extracting the information from a HGESTUREINFO IPara parameter of WM_GESTURE using or hooking into the GetGestureInfo( ) function of the operating system API. The information extracted can include: the gesture state; a gesture identifier (e.g. GID_BEGIN, GID_END, GID_ZOOM, GID_PAN, GID_ROTATE); a target window handle (e.g. a handle of a corresponding window on the server); coordinates of the window and the area of the touch input; a sequence identifier; any additional arguments. Applications typically use a public GetGestureInfo( ) rather than the memory associated with the HGESTUREINFO IPara parameter because this parameter points to an undocumented memory structure. The window management service of the client device may further call a CloseGestureInfoHandle( ) API to free up resources. Using the extracted touch input information, the client device may generate and transmit a notification message to the server in step . In some examples, the notification message may include the notification message or a portion thereof intercepted by the window management service. The notification message may, for instance, retain some or all of the original formatting (e.g., format as intercepted).","According to some arrangements, steps   may be implemented differently based on the operating system of the client device. In a particular example, on the Windows 8 client operating system, the window management service  of the client device may execute in the Windows Runtime (WinRT) Platform, e.g., as a Metro Style application, and can retrieve the touch input using the PointerPoint interface. For example, the window management service  can retrieve common data such as contact ID, pixel location, and can also retrieve input-specific data from a property bag. The window management service  may also use the GestureRecognizer interface to register to receive events about gestures and configure the gestures themselves. The window management service  can retrieve raw touch input or gestures or both, separately or at the same time. Further, the window management service  can use the PointerDevice interface to retrieve various capabilities and properties, e.g., the type of input device, weather it is integrated or external, maximum input count, or get the supported HID usages of the device.","Similarly, on the Windows 8 client operating system, the window management service  of the client device may execute in the Win32 platform as a Desktop application, and can handle the WM_POINTER message (the equivalent of the WinRT PointerPoint) and retrieve the raw input data using the GetPointerInfo( ) API and related functions. The window management service  may also use the InteractionContext interface to retrieve componentized gesture recognition. The window management service  may retrieve raw touch input or gestures or both, separately or at the same time. The window management service  may also use the Win32 Pointer Device APIs to query the pointer devices in the client environment.","In another particular example, on the iOS operating system the window management service  of the client device may be implemented as an iOS application. The multi-touch interface of iOS devices generates low-level events when a user touches views of the iOS application. The window management service application may send these events (as UIEvent objects) to the view on which the touches occurred. A UIEvent object of type UIEventTypeTouches may represent a touch event. That view of the window management service application may analyze the touches represented by each event object and prepare them for transmission to the server as raw touch input. The view may interpret the touches as a common gesture, such as a tap or swipe gesture. The client application may make use of UIKit classes called gesture recognizers, each of which is designed to recognize a specific gesture, e.g., UITapGestureRecognizer for tapping, UIPinchGestureRecognizer for pinching in and out (zooming), (UIPanGestureRecognizer) for panning or dragging, UISwipeGestureRecognizer for swiping, UIRotationGestureRecognizer for rotation, UILongPressGestureRecognizer for press-and-hold, etc. Moreover, if the window management service application needs a UIKit object to respond to events differently, it may create and use a subclass of that framework class and override the appropriate event-handling methods. The window management service may also implement a completely custom gesture recognizer by subclassing UIGestureRecognizer, analyzing the stream of events in a multi-touch sequence to recognizing a distinct gesture. The window management service  can retrieve raw touch input or gestures or both, separately or at the same time.","After transmitting the touch event notification message to the server, the client device may receive, in step , one or more instructions indicating a manner in which to modify the application window or other user interface element to which the touch input is directed. The one or more instructions may be received from the server and indicate a display modification command such as zoom, scroll, pan, move, expand, shrink, minimize, maximize and the like. In step , the client device (or window management service) may modify the application interface element in accordance with the specified instructions. In one example, the one or more instructions may include an image of the updated application display or portion thereof and\/or commands for modifying the application display window.","In one particular example, a client device may remote touch events, e.g. WM_TOUCH messages, that are issued to windows registered to accept raw touch input. When the client device sends the touch input, the window management service of the client device extracts the raw touch info from the (HTOUCHINPUT) lParam parameter of WM_TOUCH into an array of TOUCHINPUT structures using the GetTouchInputInfo( ) API. The number of touch points may be indicated by the wParam parameter of WM_TOUCH. In some embodiments, the client device may also send: an identifier for the touch contact sequence from the point a contact comes down until it comes back up, this identifier allows for multiple simultaneous sequences or multi-touch (multiple fingers or people); X and Y coordinates to the hundredth of a pixel of physical screen coordinates, this provides high precision for applications that require fine resolution (e.g. handwriting recognition); width and height of contact area; timestamp; whether this is a primary touch point, e.g. first touch point established; various aspects of the touch\/point sequence such as down, move, up or hover events, whether input was coalesced, whether it was from the user's palm, etc.; and a device handle that can be used to retrieve information about the input device. In some arrangements, the device handle can be used to retrieve information about the client device. The window management service of the client device may further call a CloseTouchInputHandle( ) API to free up resources. After the server receives the touch input, the server may replay the touch input to a corresponding application window on the server (e.g. using SendMessage( ), SendMessageTimeout( ), SendNotifyMessage( ) or PostMessage( ) APIs to send WM_TOUCH), as described in further detail with respect to .","Additionally or alternatively, if a window management service intercepts or receives a GESTURENOTIFY message from an operating system executing on the client device and issued to an application window displaying a remotely executing application or desktop, the window management service may block a return from a local message handler. The window management service may then transmit the GESTURENOTIFY message to the server where the message is replayed for an application window corresponding to the application window of the client device. In some embodiments, the server may replay the message with a SendMessageTimeout( ) function call so that the application corresponding to the application window can set gesture configuration options, e.g. using the SetGestureConfig( ) function. The configuration is captured, transmitted to the client device and applied to the remote window displaying the application output. The window management service may then call the DefWindowProc function and return from the local message handler. In some arrangements, the remoting application may proactively call the GESTURENOTIFY on the application window on the server to trigger calling the SetGestureConfig( ) function. Thus, the configuration information may be determined in advance (e.g., of receiving touch input event notifications) and sent to the client device where it is cached.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 8","FIG. 6"],"b":["800","805","810","815"]},"In step , the server may generate a local message in a specified format notifying the determined application of the received touch input event. In one or more examples, the client device or a digitizer executing on the server may create the notification message based on a touch or gesture notification message format such as WM_TOUCH or WM_GESTURE. The notification message may, in a particular example, duplicate or replay the WM_TOUCH or WM_GESTURE message generated by the client device, however replacing the undocumented address used by the client device to hold the touch input data with the server shared memory space or location identifier, which holds the transmitted touch input data at the server. In some examples, touch or gesture notification messages may be blocked by an underlying operating system if the message does not refer to an appropriate address space. Accordingly, the format of the notification message may be different from a native touch or gesture input notification message format to avoid being blocked by the operating system from transmission to the application as being an improper touch or gesture notification message. Upon creating the notification message, the server (or a remoting client executing thereon) may send the event notification and touch input information to a target application or window thereof in step . For example, the target window may be an application output window displaying application output generated by the application. In a particular example, if the application window displayed on the client device is a MICROSOFT EXPLORER window displaying application output generated by an instance of MICROSOFT EXPLORER executing on the server, then the target window is an application output window of the server that corresponds to that instance of MICROSOFT EXPLORER.","Alternatively or additionally, the server may generate the notification message by reverse-engineering the touch information received from the client device (e.g. the touch information in the undocumented memory structure.) In particular, the server may recreate the internal memory structure from the protocol (e.g., in a shared memory area rather than a private kernel memory area).","In step , the server may detect initiation of a function call by the application to process the notification message. For example, the application may call a DefWindowProc function to process the message. Because the DefWindowProc function might not understand the notification message since the notification message is provided in the specified format (e.g., a non-traditional gesture or touch input notification message format), the server may or remoting client thereof may replace the function call with an alternate function in step . The alternate function may be configured to convert the notification message into a format native to the underlying operating system and understood by the originally called function (e.g., DefWindowProc) as a gesture or touch input event notification. Once the message has been converted to the native or traditional input event notification format, the originally called function (e.g., the replaced function) may be executed by the application upon receipt of the converted message in step . For example, the originally called function may be configured to identify an action to be taken based on the contents and format of the notification message. In one example, the function may determine that the message corresponds to a touch input event notification and instruct the application to execute a further function to extract the touch input data.","Accordingly, in step , the server may detect the application initiating a function call to extract touch input data once the application has processed the notification message. In the above example where WM_GESTURE and\/or WM_TOUCH are used as the notification format, the function call may correspond to GetGestureInfo( ) and\/or CloseGestureInfoHandle( ). Because WM_TOUCH and WM_GESTURE messages generally include a handle or pointer to an undocumented, private (e.g., non-publicly accessible) memory area or structure where the touch input data is stored, the function call may be used to retrieve the touch event data. However, because the undocumented memory area or structure is located on the client device and not the server, executing the GetGestureInfo( ) and\/or CloseGestureInfoHandle( ) function may result in an error. Accordingly, upon detecting the application initiating execution of a data retrieval function, the server may, in step , identify and execute another alternative function configured to access a memory space of the server (or another storage device) and retrieve the touch input data stored therein. For example, as noted above, the memory space may be a shared memory space provided on the server or another storage device. The memory space where the touch input data is stored may be identified based on the association stored between the undocumented address specified in the notification message and the memory address where the server stores the touch input data.","In some examples, a touch or multi-touch hook DLL managed by the remoting client application executing on the server or virtual digitizer may be injected into one or more or every process address space such that the DLL hooks all calls made by or to the undocumented memory structure. Thus, when one or more specified functions are called responsive to interpreting the notification message sent to the target window and application, the server may hook the function call and replace it with an alternative function. This alternative function may be specific to the remoting client application or a virtual-digitizer-specific function such as CTXGetGestureInfo( ) and CTXCloseGestureInfoHandle( ). In other examples, multi-touch DLL may hook all calls issued to obtain the touch input information and may replace these calls with system-specific implementations, e.g. replace GetTouchInputInfo( ) and CloseTouchInputHandle( ) with CtxGetTouchInputInfo( ) and CtxCloseTouchInputHandle( ), respectively. Thus, when the application calls the GetTouchInputInfo( ) function, the function may be replaced with the CtxGetTouchInputInfo( ) which converts the touch input formatted in a system specific format into a public format that the application can process. Similarly, when the application calls CloseTouchInputHandle( ), the function may be replaced by the multi-touch DLL with the CtxCloseTouchInputHandle( ) which frees up allocated resources.","According to some configurations, the touch or multi-touch hook DLL may use an AppInit_DLLs registry key method. In other arrangements, the touch or multi-touch hook DLL may use the CreateRemoteThread( ) or SetWindowHookEx( ) methods to inject the hook into processes that have a user interface. In still other arrangements, the touch or multi-touch hook DLL may also hook the SetGestureConfig( ) function and replace it with an alternative, system-specific function such as CTXSetGestureConfig( ) function. The SetGestureConfig( ) function may be called, for example, to notify an operating system of the supported memory structures by passing the operating system an array of GESTURECONFIG memory structures that define messages for a certain gesture. For example, memory structures may be passed to the operating system such as memory structures defining aspects of the following gestures: panning; rotation; inertia; etc. The structures may control aspects of the touch input or gestures such as allowing for horizontal but not vertical panning, or not permitting inertia. Upon sending the operating system these memory structures, the operating system may then be configured to support the particular touch input or gestures defined in the memory structures. In some examples, the server may remote SetGestureConfig\/CTXSetGestureConfig( ) calls to the client device, and the client device may apply the memory structures passed during the function call to an operating system executing thereon. This is accomplished when a window management service of the client device calls the SetGestureConfig( ) function on the application window displayed. For example, if an instance of GOOGLE CHROME fails to support rotation, then the server may transmit a SetGestureConfig( )\/CTXSetGestureConfig( ) that includes a memory structure which identifies application output windows associated with that instance of GOOGLE CHROME as not supporting rotation. This function call is transmitted to the client device which in turn issues a local SetGestureConfig( ) function call having an argument that states that rotation is not supported, to an application output window displaying the application output generated by the instance of GOOGLE CHROME executing on the server.","In some arrangements, the function executed in step  may further be configured to convert the retrieved touch input information into a public format recognizable by applications executing on the server. When, for example, the CTXGetGestureInfo( ) function is called by an application, the function may convert the touch input information from the undefined memory structure format (e.g., a system-specific format) into a public GESTUREINFO structure. In one example, the system-specific format may include raw input data while the public format may correspond to application-compatible commands (e.g., pan, zoom, scroll, expand, etc.). Additionally or alternatively, the manner in which system-specific touch input information and data is processed may depend on the type of application to which the touch input is directed, a type of operating system of the client device or of the server and\/or a type of client device on which the application is being displayed. For example, touch input may be translated into a first type of command for a first application or type of application and a second type of command for a second application or type of application.","After the touch input data is retrieved from the specified memory area and\/or converted, a function such as the public CloseGestureInfoHandle( ) API may be called to close the resources associated with the gesture information handle in step . In one or more arrangements, the function for closing the resources may also be replaced with an alternate function configured to transmit a message to the client device to close the resources provided by the client side. Alternatively, in one or more arrangements, the client device frees the touch input resources shortly after sending the input to the server and does not rely on notification from the server to free its resources. Additionally, the memory areas used by the server may also be closed upon execution of the alternate resource closing function. Moreover, in step , the server may modify the application and\/or a display thereof in accordance with the publicly formatted touch input information and commands. For example, if the touch input information is a zoom command, the server may expand the application window and\/or the contents thereof. Additionally, the modification to the application and\/or display thereof may be transmitted to the client device in step  in the form of instructions for modifying the remoted application display at the client device. In some arrangements, the server may further translate touch input based on an operating system on the client device or an operating system on which the application is executed. For example, the server may, in various examples, default to a touch function as defined in the operating system of the client device. Thus, a press-and-hold gesture may be interpreted as a delete function if the client device is operating iOS even though the application may be executing on WINDOWS, where by default press-and-hold is instead interpreted as a mouse right-click. In such a case, the server may translate the touch input into a touch input having the equivalent functionality in WINDOWS. For example, the server may translate the press-and-hold gesture into an up-left flick gesture, which by default means delete, or directly send a delete key input to the application. In another example, the server may default to a particular operating system such as WINDOWS. Accordingly, if the server is using iOS, touch input may be translated into WINDOWS touch input and functions based on WINDOWS touch input definitions. The server may store a table or mapping between touch input and functions for the various operating system and cross-reference the mappings as necessary. Users may also specify the configuration to use. For example, a user may specify that all touch input should be treated under an iOS scheme or a WINDOWS environment. The server may then translate the touch input, if necessary, based on the user selection of an operating system or preferred set of touch definitions. In a particular example, the user may define his or her own preferred set of touch input definitions and request that the server translate touch input according to those definitions.","Flick input may also be processed in similar fashion. For example, flick input may have one set of definitions at the client device or on a first operating system and have a second set of definitions at the server or on a second operating system. Accordingly, the user may configure what definitions are to be used. Alternatively, the definitions used may be controlled by the operating system on the client device or the server. In some configurations, flick input may be self-contained. That is, flick input may store input location data and other information within a flick input notification message rather than referencing an address space of the underlying system (e.g., as may be the case for touch or gesture inputs). Accordingly, flick input might not need to be processed in the same manner when remoted to the server. In one example, the flick input may be transmitted to the application without hooking a function call or replacing the address space with a shared memory space.",{"@attributes":{"id":"p-0123","num":"0122"},"figref":["FIG. 9","FIG. 9"]},"The remoting server, in some instances, may also be configured to convert touch input received from a touch-capable client device into non-touch input if the remoted application is not operating on a touch-compatible operating system. In an example, a tablet PC may transmit touch input to a remoting server using an operating system that is touch incompatible (e.g., does not understand touch input). Accordingly, the server may translate the touch input into mouse events or other types of operating system compatible commands (e.g., for modifying an appearance of the application, invoking a function of the application and the like) and forward those to the intended application.",{"@attributes":{"id":"p-0125","num":"0124"},"figref":"FIG. 10A","b":["1000","1001","1003","1005","1007","1009","1001","1003","1001","1","1005","1003","1007","1009","1007","1003"]},{"@attributes":{"id":"p-0126","num":"0125"},"figref":["FIG. 10B","FIG. 10A"],"b":["1050","1051","1009","1051","1053","1055","1057","1053","1059","1051","1057","1055","1051","1059","1053"]},"All applications might not be configured to accept touch input. However, users may want to use touch input regardless of the configuration of the application. Accordingly, in some examples, the touch input may be converted into mouse events or other types of input events for an application that is not configured to receive and process touch input.",{"@attributes":{"id":"p-0128","num":"0127"},"figref":"FIG. 11","b":["1100","1105"]},"In instances where the remote application cannot handle touch input, the input or messages may be propagated to a default window procedure which causes an operating system executing on the server to convert the touch input into mouse events in step  and forward the mouse events to an intended application in step . For example, the server may store a mapping between types of touch input or gestures and different types of mouse events\/inputs. In a particular example, a vertical panning gesture may cause the operating system to detect scroll bars and corresponding Ctrl-Scroll Wheel command generation. The operating system can also detect editable areas in the application window and upon receiving the touch input may cause a touch keyboard option, etc. to be generated and displayed. For example, the server may convert the touch input into a mouse-click event directed to an editable area. The mouse-click event on the editable area may then cause the virtual keyboard or other input element to be displayed and activated.","If the remoted application is capable of handling touch input, the server may forward the touch event notification to the remoted application in step  for processing as described in further detail herein (e.g., according to the process of ).","In some configurations, instead of or in addition to hooking replacement or alternative functions into a system-specific touch information retrieval function, the server may perform manipulation to extract the raw touch input and forward it to the appropriate application window. For example, the server may reverse-engineer the undocumented data structure in which the raw touch input is stored by the underlying operating system. This can include recreating a windows-internal memory structure that approximates the undocumented data structure, then sending the WM_TOUCH message to the appropriate application window where the message points to the newly created memory structure. Another method may include re-creating the touch input information in terms of either an array of public touch input structures, or in terms of a system-specific format, e.g. a CITRIX format. Upon re-creating the touch input, the remoting server may send the WM_TOUCH message to a target window. In a particular example, the server may invoke a hardware driver that executes within the operating system and emulates touch input hardware data. The multi-touch hook DLL can also hook the GetRawInputDeviceInfo API which based on the device handle previously communicated by the client can be used to retrieve information about the input device, e.g., name, type, device-specific info.","Moreover, in one or more arrangements, an underlying operating system may provide one or more public interfaces or functions for creating touch or gesture input data in a native space and format. For example, an operating system may provide a function for creating a private address space in which touch or gesture input data may be stored and later retrieved by other public functions and calls. Thus, instead of or in addition to application\/function hooks and\/or emulation drivers, functions and interfaces provided by the operating system may be used to create touch or gesture input data and store that data in operating system designated locations. In a particular example, on the Windows 8 Server operating system, the remoting client  may use the raw touch input injection APIs, such as InitializeTouchInjection and InjectTouchInput, and provide an array of POINTER_TOUCH_INFO structures, containing information about pointer type, e.g., touch or stylus pen, contact ID, pixel location, etc. Applications running in the Windows Runtime (WinRT) Platform on the server, such as Metro Style applications, may then seamlessly retrieve the touch input using the PointerPoint interface. For example, applications may retrieve common data such as contact ID, pixel location, and can also retrieve input-specific data from a property bag. Metro Style applications running on the server may also seamlessly use the GestureRecognizer interface to register to receive events about gestures and configure the gestures themselves. Further, applications may use the PointerDevice interface to retrieve various capabilities and properties, e.g., the type of input device, weather it is integrated or external, maximum input count, or get the supported HID usages of the device. Similarly, applications running in the Win32 platform on the server (Desktop applications), may handle the WM_POINTER message (the equivalent of the WinRT PointerPoint) and retrieve the raw input data using the GetPointerInfo( ) API and related functions. Desktop applications can also use the InteractionContext interface to retrieve componentized gesture recognition, and can also use the Win32 Pointer Device APIs to query the virtual pointer devices in the server environment.","The function call replacement features of , the hardware driver touch input event creation features and the public operating system interface features may be used in conjunction with another or may be used exclusively of the other techniques. For example, function call replacement may be used in some circumstances while hardware driver creation or public operating system interfacing may be used in other circumstances. In a particular example, function call replacement may be used in situations where touch input may require special gesture translation between the client device and the server, direct gesture injection, translation into a mouse event or other non-touch event.","Some applications may be input-aware but not touch-compatible or touch-aware. As such, such applications may modify the application display or invoke various application functions based on the source of the input rather than the actual type of input received. For example, if an application is not compatible with touch input, touch input received may be converted to mouse events for the application. The application may modify the display or invoke a function based not only on the mouse event received, but also based on the source of the input such as a touch-sensitive display, a mouse, a keyboard, a touchpad and the like. Accordingly, if the source of the touch input corresponds to a touch input device, the application may modify the display in a manner specific to touch input sources or invoke a function particular to touch input sources despite the input received by the application being a mouse event. In a particular example, menus or input areas may be expanded to facilitate touch input upon detecting the source of an input event being a touch input device. In contrast, a mouse event from a mouse input device might not elicit such expansion of the menu or input area. In some configurations, mouse events may always be sent in parallel to gesture\/touch events.  illustrates an example interface for modifying an input-aware application in response to determining the type of input received. For example, when the input received is mouse input, the Destination List is smaller (e.g. the left list  is smaller than the right ). However, when the input received is touch input, the Destination List is larger (e.g. the right list  is larger than the left ). In some examples, determining the type of input may include calling the GetMessageExtraInfo( ) function to obtain additional information associated with a message or input. Additionally or alternatively, an operating system may tag mouse movements with a special signature. Still further, applications may mask the extra information with a mask such as 0xFFFFFF80. Thus, when the resulting value is, for example, 0xFF515780, then the input may be considered touch. In some examples, the remote applications may be input aware and may therefore modify their user interface when a particular type of input is received. In some embodiments, an application may be input-aware, but might not be gesture-aware. In such instances, the gestures may be propagated to a default window procedure where the gestures are modified into mouse events. Although the gestures are handled by a default window procedure, they may still be tagged as touch input. Thus, the application or desktop may still determine that the input is touch input and can modify its user interface accordingly.","The server executing the application may also invoke various functions of the application or modify the application display without requiring the application to be input-aware. Thus, if the server is aware that the input source is a touch sensitive device, the server may automatically expand the application or a portion thereof (e.g., an input field) even though the application might not be touch-input compatible. In particular, if the server recognizes that the application is not touch compatible, the server may transmit a mouse event to the application while instructing the application display to expand the input area.  illustrates an example user interface including a scratch pad application window supporting multi-touch. The multiple lines on the scratch pad correspond to different touch input, e.g. four fingers or four styluses. Further, the multiple lines illustrate inputting multiple touch events simultaneously. The methods and systems described herein can support any number of simultaneous multi-touch inputs. In some examples, this support may be limited only by the hardware of the mobile device , the operating system of the mobile device  or the drivers of the mobile device.",{"@attributes":{"id":"p-0136","num":"0135"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0137","num":"0136"},"figref":["FIGS. 15A and 15B","FIG. 15A","FIG. 15B"],"b":"206"},"Because aspects described herein operate over a network (e.g., between a client device and a remoting server), latency may pose an issue as well as low bandwidth. Accordingly, remoting touch input and gestures may include latency compensation processes.  illustrates an example process by which zero-latency or substantially zero-latency may be achieved in an environment having a high latency connection. In step , the client device (receiving the remoted application) may determine a latency (e.g., transmission time) of a network connection between the client device and the server providing a remoted application. In one example, the client device may send a message such as a ping request to the server to determine a round-trip-time associated with the message. The latency may then be determined based on the magnitude of the determined round-trip-time and may be determined upon receipt of an input event, a specified number of input events, based on a specified interval or on aperiodic schedules. For example, the latency may be determined and\/or refreshed every 30 seconds, every 5 seconds, every 10 seconds, on a schedule where a second determination is made 5 seconds after the first and a third determination is made 10 seconds after the second and\/or the like. In step , the client device may determine whether the latency is greater than a specified threshold. The threshold may be set, for instance, at a value of round trip time at which a user may experience significant lag between providing the touch input and receiving a response in terms of the application display being modified according to that touch input. If the latency is below the specified threshold, the client device may process the touch input without latency compensation (e.g., forwarding notification of the touch input event to the server) as show in step . If the latency is above the specified threshold, the client device may use one or more of multiple processes to compensate for the latency.","A first latency-resolution technique may include processing touch input locally at the client device. For example, a window management service or other client application executing on the client device may provide local feedback (e.g., display modification instructions) to application windows displaying remotely executing applications. This local feedback can be determined based on historical or approximated information and in some instances can be followed by true feedback from the remotely executing application. Configuring a window management service or other client application to be able to respond locally may include communicating to the window management service or other client application the capabilities of a window and the application's ability to handle specific gestures, as shown in step . However, the communication of the application\/window capabilities may be communicated prior to determination of latency or at other times in the process. In step , the client device may determine an application function corresponding to the received touch input. For example, the client device may call a gesture API of the underlying operating system to interpret the raw touch input into a gesture command.","In step , the client device may then compare the application function to the determined application capabilities to determine if the application supports the touch input command. If the application is compatible with the touch input command, the client device may process the input command locally in step . For example, the client device may, if a window can handle scrolling and zooming and it is determined that the network latency is above a predetermined threshold, call and\/or execute the function corresponding the touch input substantially immediately upon detecting the touch input or gesture. In some examples, the window management service or other client application may handle the gesture locally using graphics from a video or image buffer and by performing StretchBitBit or BitBit operations on the client area of the application window. The non-client areas may remain intact and untouched. For example, the window management service or other client application could zoom in on a picture displayed in the application window but could permit the title and borders of the window to remain intact. Additionally, in step , the client device may further transmit the gesture or touch input to the remoted application at the server so that the remoted application is updated at the execution source\/location. Once the remote application handles the gesture, the remote application can transmit the application output to the client device which receives the application output and updates the application window to display the application's true response to the gesture input.","In cases where the application does not support the touch input command or a function associated therewith, the client device may transmit the touch input information to the server (as in step ) for handling remotely without local processing. Alternatively, the client device may discard the touch input without processing the touch input locally and without sending the input to the server.","Another latency or session-interactivity resolution process may include queuing and tossing touch input events in low-bandwidth and\/or high latency conditions. For example, in step , the client device may add touch input events into a queue to be sent to the server. At specified times, the client device may review the queue (e.g., as shown in step ) to identify touch input events having at least a specified age. For example, the age of each touch input event may be defined and\/or determined by an amount of time the touch input event has been in the queue, an amount of time since the touch input event was received and the like. The client device may then discard touch input events having at least a specified age in step . For example, the client device may discard all touch input events having an age of at least 1 second, 30 milliseconds, 2 seconds, etc. Alternatively or additionally, the client device may remove touch input events in the queue based on a maximum number of touch input events to be included in the queue. Accordingly, if the maximum limit of touch input events to be stored in the queue is 10, the client device may discard the oldest touch input event(s) to reduce the number of events in the queue to 10. Queuing and discarding may help to coalesce raw touch input events to prevent overloading a transmission pipeline and to preserve the interactivity of a remote session in low-bandwidth conditions or when the speed of application execution (e.g., of touch input events) is slow. For example, in some cases, applications might be slow in interpreting the touch input, even though bandwidth to the server may be sufficient, e.g., if the server load is high, in which case the server might coalesce the input in order to preserve interactivity of the application. Without coalescing, the application might be busy digesting a potentially long queue of stale gestures and reacting with a delay to the user.","Arbitration of touch input between a client device and a server device may also be performed for non-latency based issues. For example, the client device may determine which device will process the touch input (server or client) depending on factors such as operating system compatibility, rules specified by the client, the server or the user, application specified rules and the like. In some examples, the touch input may be processed both by the client device and the server. In a particular example, a particular gesture (e.g., a four finger wipe) may correspond to switching between executing application. This gesture may be processed by both the client device and server to result in seamless switching between application executing locally on the client device and remoted applications executing on the server. In other instances, a particular type of touch input might never been remoted (e.g., sent to the server) or may always be sent to the server. The various rules for where touch input is to be processed might also depend on whether the client device is compatible (e.g., understands) the touch input. If not, the touch input may be transmitted to the server instead. Further, users may wish to use local or remote UI elements or interaction rules. Accordingly, the user may specify that certain types of touch input (or all touch input) is to be processed locally or remotely.","In some arrangements, an application or system may wish to determine the touch screen capabilities of a device or other type of hardware such as an input digitizer, e.g. an input digitizer of the client device. Accordingly, in one example, a window management service may use a GetSystemMetrics API with index SM_DIGITIZER to query the capabilities of the input digitizer, such as support for multi-touch, pen or touch, whether the device is ready, whether it is integrated or external, how many simultaneous inputs are supported. In some embodiments, the received information may inform the window management service about the touch capabilities of the mobile device. These capabilities can be transmitted to a server where they may be used by remote applications to modify their user interface according to the mobile (or other client) device's capabilities. In some embodiments, this may include having the multi-touch DLL hook a GetSystemMetrics API and replace with a system specific API which can query the mobile device's capabilities. Upon querying for the capabilities, the server may receive the capabilities and make them available to applications executing on the server.","According to another aspect, an operating system may provide applications that facilitate manipulation and inertia processing. Manipulation may include processing of multiple\/complex transformations at the same time, e.g., rotation, scaling, translation\/panning with any number of fingers at the same time using a 2D affine transformation matrix. An application may feed raw data into a manipulation processor and receive transformation matrices. Gestures may be boiled down into individual manipulations. Inertia may be used in various ways, including to specify deceleration speed or end point, boundaries, etc. The inertia API may generate fake events from a simulated user but they may be handled by the application in the same way as real events. Default manipulation and inertia applications may be replaced by applications that customize the manipulation and inertia handling. In some examples, inertia and manipulation can be handled on the mobile (e.g., client) device, while in other examples, inertia and manipulation can be handled on the server.","In some embodiments, the methods and systems described above may be ported to multiple client platforms such as: iPhone, iPad, Android, Blackberry, etc. Just as the methods and systems described herein can be modified to customize a user's experience, so can the features on a client platform be modified. For example, show the local\/native client touch keyboard, then remote the keystrokes to the host, as opposed to showing the keyboard in the remote session itself and remoting the touch events. The capabilities of the methods and systems described herein can vary depending on the client\/mobile device. For example, the client multi-touch platform abstraction may have to do its own gesture-recognition from raw events if the OS does not natively support it. Also, it may have to disable local processing, e.g., zooming\/panning, and delegate it to the remote session.","Remoting of applications and touch input may further include support for coordinate translation to resolve discrepancies in screen locations, sizes, resolutions and the like between the client device and the server. An application output window displayed on a client device (e.g., mobile device ) and displaying application output generated by a remotely executing application, e.g. a seamless window, may in some instances assume a null initial position of [0,0]. Further, the seamless window may create a remote session that has substantially the same resolution as the display of the client device. This resolution, in some embodiments, may be the combined desktop resolution for multi-monitor environments. When the application output window displays portions or a whole remote desktop, the application output window may have offset coordinates relative to the local physical display. In some instances, this may be true for both windowed and even full-screen remote desktop (in the case of a multi-monitor environment.) Accurate handling of multi-touch and gesture input can therefore require the client device or the window management service executing thereon to translate physical screen coordinates into logical screen coordinates before sending them to the host as part of gesture or raw touch events. For example if the physical coordinates of a gesture or touch input are [PhysicalX, PhysicalY] and the remote desktop's top left corner is at physical offset [DesktopX, DesktopY], then the logical coordinates within the desktop, which are sent to the host, are [PhysicalX\u2212DesktopX, PhysicalY\u2212DesktopY].","In addition to coordinate translation, the client device or the window management service may perform coordinate scaling. For example, for a gesture or touch input issued to a window that has a position from the top left corner at [WindowX, WindowY] and scaled at a factor [ScaleX, ScaleY], the resulting logical coordinate sent to the host can be: [WindowX\u2212DesktopX+(PhysicalX\u2212WindowX)\/ScaleX, WindowY\u2212DesktopY+(PhysicalY\u2212WindowY)\/ScaleY]. Similar translations and scaling can be performed for panning input or scaling a desktop window to fit a client device window size. Coordinate translation and\/or scaling may be performed by the client or by the server or both.","According to one or more configurations, the methods and systems described above can further support passthrough technology. Passthrough technology includes permitting data to pass through multiple protocol hops during a transmission between a client device and a remoting server. According to some aspects, the methods and systems described herein can support passthrough technology without any additional modifications. For example, a client running in a session can act as another application which receives gesture or multi-touch input and can relay the input to another session or another client executing in the other session. The digitizer capabilities can be presented to applications in all sessions including subsequent network nodes (e.g. protocol hops).","In some arrangements, the methods and systems described above may further or alternatively support three-dimensional image remoting, e.g. three dimensional images and desktops that use three dimensional images such as Aero technology. In these embodiments, three dimensional drawing commands can be transmitted from the server to the client device, and the window management service may handle rendering three dimensional images from the three dimensional drawing commands. In some embodiments, the window management service can draw the three dimensional images on an off-screen surface and then inject the surface or rendered images into a three dimensional command stream. These embodiments can require mitigating the lack of a discernible association between surfaces and windows in a three dimensional command stream. In some embodiments, remoting three dimensional images can include providing raw touch input support by remoting a raw, touch input stream to the server where server can use the coordinates of the touch input to determine on which corresponding host window the input should be replayed. In some instances, this support can include translating raw touch events into gestures for those application windows that are touch-incapable.","According to another aspect, multiple users or clients devices may interact with a single application session (e.g., a single instance of an application executing at the remote server). Accordingly, the users and client devices may collaborate on a document or image or other application function. The input received from the multiple users and\/or client devices may include touch input, stylus pen input, mouse input, keyboard input, joystick input and the like. The various inputs from the users may be sent to the server and resolved to determine a modification to the application display that will be transmitted to each of the users. In one example, one computer (e.g., client device) may shadow another computer, e.g. CITRIX SMART AUDITOR, CITRIX SMART AUDITOR PLAYER, CITRIX XENAPP, OR CITRIX XENDESKTOP. In these embodiments, an application can be used to replay application content generated during a remote or local user session. For example, a user can log into a user session at the remoting server and an application executing within the user session can record the application output generated by applications executing within the user session. In some embodiments, the recorder can store the recorded application output for future review or can substantially simultaneously transmit the recorded output to another session or computer where the recorded output is displayed. Viewing application output in real-time as it is generated can sometimes be referred to as shadowing. When multiple users shadow another user's session, shadowing can be configured to permit the multiple shadow users (shadowers) to interact with applications executing within the shadowed user (e.g. shadowee). Accordingly, in some arrangements, shadowing may be used to provide collaborative functionality between multiple users in the same application instance and user session.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":"FIG. 17","b":["1700","1705","1710","1715"]},"In step , the server may receive a request from another client to shadow the first client's user session or application instance. Upon receiving the request from the other client, the server may begin recording the application output and transmitting the output to the other client in step . In some arrangements, this recording and transmitting process may be performed in real-time or substantially in real-time. In some instances, an artificial delay may be introduced between modifying the application output and transmitting the output to the other device. In other instances, the output may be transmitted as soon as the application is modified and the output is recorded. In step , the server may further generate multiple instances of one or more virtual channels associated with the user or application session. Each instance may correspond to a different one of the client devices sharing the user or application session. For example, the initial user or client device (requesting the user session) may use a first instance of a virtual channel while another user or client device (e.g., the shadower) may user a second instance of a virtual channel. Accordingly, in one example where 3 shadowers request permission to shadow an initial user, 4 instances of a virtual channel may be created, each instance of the virtual channel corresponding to a different one of the group including the shadowers and shadowee. As described, the virtual channel instances may be used to transmit input including touch input, mouse input, key input and the like to the server.","In step , the server may aggregate and reconcile the capabilities for the multiple client devices associated with the user session. For example, the server may request, receive and aggregate the capabilities of each client device shadowing or hosting (e.g., the shadowee) the user session. For example, if the first client device supports two simultaneous touch inputs but the second client device supports ten, then the shared user session environment at the server will report to the hosted applications a virtual digitizer capability of twelve simultaneous touch inputs. Capability information may include a type of input (e.g., a particular type of gesture or set of raw input data) and a corresponding function. Since each client device may have different touch capabilities, the touch input may be interpreted in different ways by the client devices. To address these potentially different interpretations of similar input from different devices, the server may create a mapping table that maps the function to be performed (e.g., stretch, pan, zoom, switch application, close application, minimize application, etc.) to the client device and a type of input received. In some arrangements, the aggregation of device capabilities may be performed upon a client device joining a session for that joining device. Alternatively or additionally, device capabilities may be refreshed or re-aggregated upon each client device joining (e.g., shadowing) the user session. Furthermore, the same or a different mapping may associate\/map a client device's touch input identifiers to user session input identifiers (e.g., identifiers unique within the user session) to avoid potential collisions or conflicts between touch inputs received from different devices having the same client-specified input identifier. Furthermore, reconciling multiple client-reported primary touch points may involve considering the first point reported as primary from any client as the de facto primary touch point (e.g., for a particular touch input event or command) in the shared user session. In other examples, the last point reported may be considered the de factor primary touch point. Other rules may be defined for determining the primary touch point (e.g., other time-based rules). A primary touch point may correspond to a first touch point of a multi-touch input event. For example, for a display rotation multi-touch input event, the primary touch point may correspond to a center of the rotational movement.","In step , multiple inputs may be received through the multiple instances of the virtual channel (e.g., at least one input each from two or more channel instances). Upon receipt, the server may begin processing the inputs as described in steps -. For example, the server may temporally align the inputs according to a timestamp in step . In one example, the server may identify a time at which the input was received and subtract time differences between each client or user's time and a base time. In one example, the base time may correspond to the shadowee's local time. In other examples, the base time may correspond to a server time. The timestamps may thus be normalized based on subtracting these differences from the receipt time of the input.","In step , the server may determine whether to process each of the multiple inputs. In one example, the server may determine whether the difference in timestamps between two inputs is below a specified threshold. For example, if two inputs are received within 1 second or less of each other, only one of the two inputs may be processed to avoid potential conflicts in modifying the application display or other output, or executing an application functionality. Various thresholds may be used and the threshold applied may depend on the type of input, functionality of the application or resulting modification to the application. For example, zooming an application window may require 2 seconds to complete (e.g., required time for the visual animation). Accordingly, other input received within 2 second of a zoom input may be discarded or otherwise ignored.","If one or more inputs are to be ignored, the server may select inputs to be processed in step . For example, the server may always process the shadowee's inputs over a shadower's input. In another example, the server may process the first input (time-wise) of two or more conflicting inputs. Other rules may, alternatively or additionally, be implemented to resolve conflicts between inputs. In step , the server may subsequently process the received inputs or selected inputs within the context of the application (e.g., to affect a function or display of the application) and transmit the output to the participating devices and users.","According to some aspects, any number (e.g., N number) of user inputs may be received and processed for multiple different applications, application windows, user interface controls, or portions of application displays in parallel. Multiple simultaneous inputs may be received and processed from either the same user or from multiple users. For example, a first user may enter input for a first application (such as a word processing application) while a second user may enter input for a second application (such as a calculator application) for the same user session in parallel. The server or other device executing the applications may then process the received input for each of the applications and return the results (e.g., modification of an application display or desktop) to both the first and second users. Alternatively, a modification of an application display resulting from a user input might only be provided to the user from which the input was received. In some instances, the first and second users may enter input through the same device (e.g., same touch screen of a tablet or other computing device) or may enter input through different devices. Accordingly, in the above example of collaboration through shadowing, users may also enter input into multiple disparate applications rather than interacting with the same application of the user session. In some examples, a single user input may be directed to and processed for multiple applications in parallel. As such, in a particular example, a user may enter an application close command (e.g., a touch or gesture command) for closing multiple applications or application windows. The server may receive the close command and duplicate or otherwise process the command multiple times, once for each of the multiple applications.","The various features described herein may be used in other environments beyond a client device and remote server system. For example, the server may correspond to a phone or tablet while a client may correspond to another tablet or stationary personal computer. Applying the features described herein to such an environment, a user may use a larger display of the other tablet or stationary personal computer or other computing device to operate or control a device (e.g., a phone or tablet or other computing device) having a smaller display. Accordingly, in some examples, the two devices may be local to one another (e.g., in same building, same room) or remote from each other.","The methods and features recited herein may further be implemented through any number of computer readable media that are able to store computer readable instructions. Examples of computer readable media that may be used include RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, DVD or other optical disk storage, magnetic cassettes, magnetic tape, magnetic storage and the like.","Moreover, while many of the aspects and features described herein include the use of a mobile device, stationary or fixed location devices may also include the same or similar aspects and features. For example, a personal computer or workstation (e.g., plugged into a wall socket) may include touch input controls and provide access to a remoted application from a remote computing device. Accordingly, similar native control elements may be generated and used from the personal computer or workstation in similar fashion to a mobile device such as a tablet computer.","Additionally or alternatively, in at least some examples, the methods and features recited herein may be implemented through one or more integrated circuits (ICs). An integrated circuit may, for example, be a microprocessor that accesses programming instructions or other data stored in a read only memory (ROM). In some such examples, the ROM stores programming instructions that cause the IC to perform operations according to one or more of the methods described herein. In at least some other examples, one or more of the methods described herein are hardwired into an IC. In other words, the IC is in such cases an application specific integrated circuit (ASIC) having gates and other logic dedicated to the calculations and other operations described herein. In still other examples, the IC may perform some operations based on execution of programming instructions read from ROM or RAM, with other operations hardwired into gates and other logic of IC. Further, the IC may output image data to a display buffer.","Although specific examples of carrying out various features have been described, those skilled in the art will appreciate that there are numerous variations and permutations of the above-described systems and methods that are contained within the spirit and scope of the disclosure as set forth in the appended claims. Additionally, numerous other examples, modifications and variations within the scope and spirit of the appended claims will occur to persons of ordinary skill in the art from a review of this disclosure."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present disclosure is illustrated by way of example and not limited in the accompanying figures in which like reference numerals indicate similar elements and in which:",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1B","FIG. 1C"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2D"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIGS. 15A and 15B"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
