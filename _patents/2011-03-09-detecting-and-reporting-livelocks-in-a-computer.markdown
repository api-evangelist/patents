---
title: Detecting and reporting livelocks in a computer
abstract: Tasks executing on a computer can livelock. To detect a livelocked task, the amount of computing resources consumed by the task is sampled to determine whether the task is consuming an inordinate amount of resources. In addition, the task is examined to determine whether it is making tangible progress. This examination can include inspecting registers of a processor executing the task. If the task is livelocked, state data describing the livelock event is collected. The state data can include a memory dump describing the state of the livelocked task and data describing other tasks executing on the computer. A livelock report including the collected state data is generated and transmitted to a server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08626904&OS=08626904&RS=08626904
owner: Symantec Corporation
number: 08626904
owner_city: Mountain View
owner_country: US
publication_date: 20110309
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of Art","The present invention generally relates to the field of computer performance monitoring and more specifically to detecting and reporting livelock events.","2. Background of the Invention","Modern computers can execute multiple applications simultaneously. While the computer has limited computing resources, the operating system allocates these resources among the executing applications so that each can perform its associated functions. For example, the computer may simultaneously execute a web browser, a messaging application, and a media player, all while a security application scans for malicious software in the background.","Occasionally, an application will enter a \u201clivelock\u201d state characterized by using a high amount of processor or other computer resources while providing no tangible progress. For example, the media player might inexplicably use 99% of available processor resources while failing to respond to user input or playing any media. The livelock condition degrades the performance of the computer. Not only does the livelocked application fail to make tangible progress, but the other applications executing on the computer may receive fewer resources and their performance can degrade as well. Accordingly, livelocks can be very frustrating to computer users.","Application developers strive to avoid livelocks in their products. However, livelocks still occur due at least in part to the wide variety of computing environments in which applications can run. An application that behaves properly on one type of computer hardware and operating system may livelock occasionally on other hardware and\/or software. Thus, even if the developers receive anecdotal evidence that their applications are livelocking, the livelock events generally are not reproducible due to environmental, configuration, or data-related factors that are specific to the computing environments in which the livelocks occurred. Therefore, the developers are unable to determine why their applications livelock and find it difficult to improve this aspect of their products.","The above and other issues are addressed by a method, computer-readable storage medium storing executable computer program modules, and a computer system that perform livelock detection on a computer. An embodiment of the method comprises detecting a livelock event involving a task executing on the computer and, responsive to detecting a livelock event, collecting state data describing the detected livelock event. Additionally, the method generates a livelock report including the collected state data and transmits the report to a server.","An embodiment of the computer-readable storage medium stores executable computer program instructions for reporting a livelock event occurring on a computer, the instructions performing steps comprising detecting a livelock event involving a task executing on the computer and, responsive to detecting a livelock event, collecting state data describing the detected livelock event. Additionally, the steps comprise generating a livelock report including the collected state data and transmitting the report to a server.","An embodiment of the computer system for reporting a livelock event comprises a non-transitory computer-readable storage medium storing executable computer program instructions for performing steps comprising detecting a livelock event involving a task executing on the computer and, responsive to detecting a livelock event, collecting state data describing the detected livelock event. Additionally, the steps comprise generating a livelock report including the collected state data and transmitting the report to a server. The computer system further comprises a processor for executing the computer program instructions.","The Figures (FIGS.) and the following description describe certain embodiments by way of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein. Reference will now be made to several embodiments, examples of which are illustrated in the accompanying figures.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","100","125","105","135","105","135","105","135","105","105","105","105","105","105"],"i":["a","a","b","c"]},"The client  is a computer or other electronic device used by one or more users to execute applications for performing various activities. For example, the client  can be a desktop, notebook, or tablet computer, a mobile telephone, or television set-top box. The applications executed by the client  may include web browsers, word processers, media players, spreadsheets, image processors, security software, etc.","Occasionally, one or more of the applications executed by the client  may enter a livelock state. The livelock is characterized by the application consuming an inordinate amount of computing resources without showing any tangible progress. For example, a livelocked application may consume 99% of available processor resources without producing any tangible results. The application may also become non-responsive to user input during the livelock, although this is not necessarily the case.","As shown in , the client includes a livelock reporting module  (the \u201creporting module\u201d) for detecting when an application enters a livelock state. Upon detecting such a livelock event, the reporting module  collects associated data describing the event, including data describing the state of the computer and the livelocked application, and transmits a livelock report containing the data to the server . In some embodiments the reporting module  is incorporated into an operating system executing on the client  while in other embodiments the reporting module  is a standalone application or part of another product.","The server  receives livelock reports from the reporting modules  of the clients . The server  aggregates and\/or processes the data in the reports to provide information for identifying the causes of the livelocks. For example, the server  may store the reports in a relational or other type of database. The server  may then analyze the stored reports to identify the causes of the livelocks. For example, the server  can perform regression analysis using variables such as the livelocked application, computer hardware, applications executing when the livelocks occurred, data being processed when the livelocks occurred, and\/or other variables described in the reports from the clients .","Application developers may use the results of the analysis to improve their applications and reduce the frequency of the livelock events. For example, the developer of an application can use the analysis performed by the server  to identify a bug or other fault in the application and update the application to resolve the issue. The update can be distributed to the clients  using the server  or via other distribution channels.","The network  represents the communication pathway between clients  and server . In one embodiment, the network  uses standard communications technologies and\/or protocols and can include the Internet. Thus, the network  can include links using technologies such as Ethernet, 802.11, worldwide interoperability for microwave access (WiMAX), 2G\/3G\/4G mobile communications protocols, digital subscriber line (DSL), asynchronous transfer mode (ATM), InfiniBand, PCI Express Advanced Switching, etc. Similarly, the networking protocols used on the network  can include multiprotocol label switching (MPLS), the transmission control protocol\/Internet protocol (TCP\/IP), the User Datagram Protocol (UDP), the hypertext transport protocol (HTTP), the simple mail transfer protocol (SMTP), the file transfer protocol (FTP), etc. The data exchanged over the network  can be represented using technologies and\/or formats including the hypertext markup language (HTML), the extensible markup language (XML), JavaScript, VBScript, FLASH, the portable document format (PDF), etc. In addition, all or some of links can be encrypted using conventional encryption technologies such as secure sockets layer (SSL), transport layer security (TLS), virtual private networks (VPNs), Internet Protocol security (IPsec), etc. In another embodiment, the entities on the network  can use custom and\/or dedicated data communications technologies instead of, or in addition to, the ones described above.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","105","135","202","204","204","250","255","206","213","250","218","213","208","210","214","216","255","200","206","202"]},"The storage device  is a non-transitory computer-readable storage medium such as a hard drive, compact disk read-only memory (CD-ROM), DVD, or a solid-state memory device. The memory  holds instructions and data used by the processor . The pointing device  is used in combination with the keyboard  to input data into the computer system . The graphics adapter  displays images and other information on the display device . In some embodiments, the display device  includes a touch screen capability for receiving user input and selections. The network adapter  couples the computer system  to the network . Some embodiments of the computer  have different and\/or other components than those shown in . For example, the server  may be formed of multiple blade servers and lack a display device, keyboard, and other components.","As used herein, the term \u201cmodule\u201d refers to computer program instructions and other logic used to provide the specified functionality. Thus, a module can be implemented in hardware, firmware, and\/or software. In one embodiment, program modules formed of executable computer program instructions are stored on the storage device , loaded into the memory , and executed by the processor  as one or more processes. A process, in turn, is formed of one or more threads of execution. This description also uses the term \u201ctask\u201d to refer to the execution of a process and\/or thread by the processor .","The modules executed by the computer  include modules implementing the operating system and modules implementing applications. The operating system acts as an intermediary between the applications and the computer hardware. In addition, the operating system provides a variety of interfaces, including application programming interfaces (APIs) that modules can use to obtain state information about the computer .","The state information describes the configuration of the computer . The state information may describe, for example, the hardware configuration of the computer , tasks being executed by the computer, contents of the memory , values stored in registers of the processor , processor  time (\u201cCPU time\u201d) consumed by one or more tasks, the elapsed real time execution of one or more tasks, a task owner (e.g. program module, system or user), and\/or other data associated with the execution of a task or operation of the computer . The state information changes over time as the computer  processes data.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["115","105","115","115","305","315","320","325"]},"The detection module  detects livelock events. As mentioned above, a livelock event is characterized by a task of a process or thread consuming an inordinate amount of computing resources without making tangible progress. To detect livelocks, an embodiment of the detection module  uses one or more APIs provided by the operating system to obtain state information about the client . The detection module  analyzes the state information to determine whether tasks executing on the client  are in a livelock state. Depending upon the embodiment, the detection module  may be configured to determine whether any tasks on the client  are livelocked, or whether any of a specified subset of tasks on the client are livelocked. Furthermore, embodiments of the detection module  can use techniques other than interfacing with the operating system to determine whether a task is livelocked.","In one embodiment, the detection module  determines whether a task is livelocked by periodically inspecting the task to determine whether it is using an inordinate amount of computing resources. For example, the detection module  can interface with the operating system to periodically obtain data about (i.e., sample) the resources being consumed by the task at that instant. If the task is consuming an inordinate amount of resources across a set of sequential samples describing the resource consumption over a length of time, the detection module  queues the task for additional inspection. The level of resource utilization considered \u201cinordinate\u201d is established using one or more pre-specified thresholds and\/or via other techniques. In one embodiment, an \u201cinordinate\u201d amount is most or all of a resource.","For example, in one embodiment the detection module  determines whether a task is consuming an inordinate amount of CPU time. The detection module  periodically interfaces with the operating system to sample the CPU time consumed by the task. If the task exceeds a threshold amount of CPU time (e.g., 95% of available time from one core of the processor ), for a threshold number of sequential samples (e.g., 10 samples and\/or 30 seconds worth of samples), the detection module  places the task in a queue of tasks to be inspected.","Different embodiments of the detection module  sample the operating system to determine utilization of other computing resources, and use different thresholds for different resources and\/or tasks. Thus, the detection module  can use different thresholds for a task known to be a heavy resource consumer than it uses for a task known to be a light resource consumer. In addition, the detection module  can use different thresholds for different resources to determine whether to queue the task for additional inspection.","The detection module  inspects queued tasks to determine whether the tasks are making tangible progress. The detection module  determines whether a task is making progress over the time window of detailed inspection. In this context, \u201cmaking progress\u201d means working toward a goal, be it analyzing a file for malicious software, playing a video, or saving a file to the storage device .","The detection module  can use a variety of techniques to determine whether a task is making tangible progress. In one embodiment, the task queued for inspection is associated with a process, and the detection module  identifies the busiest thread or threads of the process as part of the inspection. The detection module  inspects the register contexts associated with the one or more busiest threads to determine whether the threads are making progress.","In one embodiment, this inspection is performed by sampling the register contents of the thread periodically, and grouping the state of the instruction pointer (i.e., the address of the code in memory the processor  is executing) with the state of the data registers. The detection module  analyzes the register contents over the multiple samples for evidence that the thread is livelocked.","For example, for a given thread, the detection module  may determine whether the contents of multiple registers associated with the thread are changing over time. Generally, the contents of the instruction pointer and data registers should change over time as the processor  processes data for the thread. Hence, static register contents are evidence that the thread is not making progress and is therefore livelocked.","Similarly, the detection module  may determine whether the contents of only one data register are changing over time as the processor  processes data for the thread. This situation often indicates that the thread is using the changing register as a counter. However, if the register is constantly counting but the contents of the other data registers do not change, then the single changing register is evidence that the thread execution is stuck in a counting state and therefore the thread is livelocked.","The detection module  may also determine whether the contents of the registers are changing in a cyclical pattern, or in a small set of patterns. Typically, register contents will not follow repeating patterns while the processor  processes data for the thread. Repeating patterns are evidence is that the thread execution is stuck in a loop and therefore the thread is livelocked. Other embodiments of the detection module  can use other techniques to examine the thread and associated registers for evidence that the thread is livelocked.","The detection module  analyzes the information described above to determine whether a task is livelocked. For example, if the detection module  identifies a process as consuming an inordinate amount of CPU time, and further analysis of the process shows that the register contents of one of its threads changes in a repeating pattern, the detection module  declares the process and thread livelocked. Depending upon the embodiment, the detection module  may combine or weight different types of evidence differently when making the livelock determination. Likewise, other embodiments can use different and\/or additional techniques to determine whether a task is livelocked.","Furthermore, one embodiment of the detection module  uses one or more techniques to mitigate possible false-positive detections of livelocked tasks. In one embodiment, if resource utilization (e.g., processor  utilization or CPU time) falls below the livelock threshold at any time during the inspection, the detection module  concludes that the task has escaped livelock. Therefore, the detection module  discards its current inspection of the task and begins inspecting anew.","In addition, an embodiment of the detection module  incorporates the \u201cidleness\u201d of the user of the client  when determine whether a task is livelocked. The detection module  can use a variety of metrics to determine whether the user is presently using the client , such as whether mouse and\/or keyboard input has been received within a specified time interval. If the user is not present (i.e., is idle), the livelock of a task is less noticeable. Accordingly, an embodiment of the detection module  aborts livelock detection while the user is idle. Another embodiment of the detection module  uses different detection thresholds depending upon whether the user is idle. For example, the detection module  can use a threshold that specifies a high rate of resource utilization over a greater number of sampling intervals if the user is idle than the number of sampling intervals used if a user is not idle.","The detection module  can also incorporate the amount of computing resources available at the client  when determining whether a task is livelocked. For example, if the client  includes a single-core processor and\/or is performing many tasks simultaneously, these conditions might cause the operating system to report misleading resource utilization information. If the client  has only a single core processor, the operating system might report that a task is utilizing an inordinate amount of CPU time even though the task is functioning normally. In such circumstances, an embodiment of the detection module  adjusts by raising the utilization threshold and\/or lowering the utilization rate reported by the operating system.","The data collection module  collects data describing a detected livelock event. In general, the data collection module  collects data that can be used by an application developer to determine the cause of an application's livelock. The specific types of collected data can vary in different embodiments. The data collection module  collects the data by interfacing with the operating system and\/or via other techniques. In addition, some of the collected data may be gathered by the detection module  in the course of detecting the livelock event.","In one embodiment, the data collection module  collects a memory dump describing the state of the livelocked task. The memory dump contains the state of the working memory of the task when the livelock is detected. Thus, it can include the contents of the address space allocated to a process having a livelocked thread. In addition, the memory dump collected by the data collection module  may also include the thread times showing the amount of processor resources consumed by the threads of the process. The memory dump may also include handle information describing file handles open at the time of the livelock.","The data collection module  may also collect logs from one or more applications executing on the client  when the livelock is detected. Many applications maintain logs describing the operations performed by the applications. These logs are useful for determining the cause of a livelock event because they may indicate the specific operation during which the livelock occurred. The data collection module  may collect only the log of the application that had the livelocked task or collect logs from multiple different applications executing on the client .","An embodiment of the data collection module  further collects data describing other tasks executing on the client  when the livelock is detected. These data may include a list of running processes and performance data for those processes. For example, the data collection module  can collect data describing the processor and\/or memory resources consumed by each of the other running processes.","The data collection module  may also collect identification data that can be used to uniquely identify the livelock event. These data can include a unique identifier (ID) of the client . This ID can be assigned by the reporting module  or by another module on the client . In one embodiment, the ID is anonymous and allows livelock events from the client  to be identified without revealing other information about the client and\/or user. The data for identifying the livelock event can also include an identifier of a non-operating system module on the stack of the livelocked thread, the name of the process in which the module on the stack is running (i.e., the process associated with the address space in which the module on the stack is running), and the most common module offset detected on the stack of the module on the stack of the livelocked thread. The data collection module  can gather this stack information by, e.g., using stack-walking APIs provided by the operating system.","The report generation module  generates and transmits livelock reports to the server  via the network . A livelock report describes a livelock event detected at the client . The livelock report for an event includes all or some of the data collected by the data collection module  for that event. The report generation module  may transmit the report to the server  upon detection of the event, or at other times such as when the client  is idle.","In one embodiment, the report generation module  generates an ID for the report using the identification data collected by the data collection module . This ID may be based on a hash of the identification data. The report generation module  may generate the hash using locality-sensitive hashing techniques so that hashes based on similar identification data are similar. Thus, reports from similar livelock events from different clients  will have similar IDs. This similarity allows an analyst at the server  to group livelock reports based on similarity, which may assist in determining the causes of the livelock events.","The data storage module  stores data used by the reporting module  during its operation. The stored data can include sample data, thresholds, and inspection data obtained and used by the detection module  to detect livelock events. The stored data can also include data describing the livelock events and identification data collected by the data collection module , as well as reports generated by the report generation module . The data storage module  may include a relational or other form of database to enable efficient storage and retrieval of the data. In one embodiment the data storage module  stores the data on the storage device  of the client .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 4","b":["115","115"]},"The reporting module  detects  a livelock event by analyzing state information about the client  to identify a task executing on the client that is livelocked. This analysis involves periodically inspecting the task to determine whether it is using an inordinate amount of computing resources. The reporting module  also determines whether the task is making tangible progress by, e.g., inspecting register contents associated with the task.","If a livelock event is detected, the reporting module  collects  data describing the livelock event. These data include, e.g., a memory dump describing the state of the livelocked task, logs from one or more applications executing on the client , and data describing other tasks executing on the client. The reporting module  also collects  identification data for uniquely identifying the livelock event. The reporting module  generates  a livelock report describing the livelock event. In one embodiment, the generated report is identified using a hash generated from the identification data for the livelock event. The reporting module  transmits  the livelock report to the server .","The above description is included to illustrate the operation of certain embodiments and is not meant to limit the scope of the invention. The scope of the invention is to be limited only by the following claims. From the above discussion, many variations will be apparent to one skilled in the relevant art that would yet be encompassed by the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
