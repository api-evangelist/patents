---
title: Registration method for supporting bytecode modification
abstract: A method is described that comprises receiving from a classfile registration information. The registration information comprises a class name and a different method name for each of the class's methods. Each of the methods are modified with at least one additional byte code instruction to cause, for its respective method, a plug-in module's handler method to provide output function treatment for the respective method. Also, a plug-in pattern is referred to in order to determine which of a plurality of plug-in modules are appropriate for each of the class's methods. The plug-in pattern lists for each of the plug-in modules those of the methods that are to be handled with its corresponding output function treatment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07743367&OS=07743367&RS=07743367
owner: SAP AG
number: 07743367
owner_city: Walldorf
owner_country: DE
publication_date: 20031230
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS","1.0. Architectural Overview","2.0. Modified Bytecode Runtime Flow","3.0. Example of Modified Bytecode","4.0. Dispatch Unit, Plug-In Modules and Handlers","5.0. Implementing Bytecode Modification"],"p":["1. Field of the Invention","The field of invention relates generally to the software arts; and, more specifically, to a registration method for supporting bytecode modification.","2. Description of the Related Art","1. Bytecode","Certain software technologies, such a JAVA, emphasize the use of a special interpreter (which may also be referred to as a \u201cvirtual machine\u201d) that allows generic processor instructions to be executed on a particular type of processor. Here, each hardware platform (e.g., each computer) that the generic instructions are expected to \u201crun on\u201d typically includes a virtual machine that is responsible for converting the generic processor instructions (which are typically referred to as \u201cbytecode\u201d) into instructions that are specially targeted for the hardware platform's particular processor(s). Software technologies that embrace the execution of bytecode on a virtual machine may be referred to as \u201cvirtual machine-based\u201d software.","As a classic instance of the benefit of the JAVA virtual machine with respect to Internet usage, a first PC that is powered by an Intel processor may download from the Internet the same JAVA bytecode instructions as a second PC that is powered by a PowerPC processor. Here, the first PC's JAVA virtual machine converts the JAVA bytecode into instructions that are specific to an Intel processor while the second PC's JAVA virtual machine converts the same JAVA bytecode into instructions that are specific to a PowerPC processor. Thus, through the use of JAVA bytecode and processor specific JAVA virtual machines, an Internet server is able to maintain only a single type of code (the JAVA bytecode) without concern of client compatibility.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 1","FIG. 1"],"i":["a ","a","a","a ","a "],"b":["105","105","101","101","103","102","104","105","106"]},"2. Object Oriented Programming and Classfiles","Certain software technologies, including JAVA, are \u201cobject oriented.\u201d According to an object oriented approach, the subject matter that is processed by a computer program is organized into classes of likeness. For example, the software used to sell items to customer X might belong to the same class of software (e.g., a class named \u201csales\u201d) that is used to sell items to customer Y. Here, given that a significant degree of overlap is expected to exist regarding the methods and data types used to process sales for both customers X and Y (e.g., an \u201cupdate billing about sale\u201d method, an \u201cupdate accounting about sale\u201d method, a \u201cpart number\u201d data type, a \u201cquantity\u201d data type . . . etc.) it is deemed more efficient to organize such methods and data types into a generic \u201csales\u201d class from which specific instances of the class (e.g., an instance for selling to customer X and an instance for selling to customer Y) can be defined and created.","Each specific instance of a class is referred to as an object; and, each object assumes the characteristics of the class from which it is defined. Thus, a first object could be created from the generic sales class to create a \u201csell to customer X\u201d object; and, a second object could be created from the generic sales class to create a \u201csell to customer Y\u201d object. Both objects would be able to execute the methods defined by the class. For example, the \u201csell to customer X\u201d object could execute the \u201cupdate accounting about sale\u201d method to update an accounting department about a sale to customer X; and, the \u201csell to customer Y\u201d object could also execute the \u201cupdate accounting about sale\u201d method to update an accounting department about a sale to customer Y.","In general, the runtime execution of any computer program can be viewed as the execution of a sequence of methods. With respect to an object-oriented approach, such a sequence of methods can be implemented by calling upon a sequence of objects and invoking one or more methods at each object. In order to invoke the method of an object, a representation of the object is typically created beforehand. In virtual machine-based object-oriented software environments, classfiles are bytecode level data structures from which such representations are created. A classfile can be viewed as a bytecode level description of a class; and, therefore, a classfile can be used as a template for the formation of an object, at the bytecode level, that is a member of the class. As specific methods can be attributed to specific classes, each classfile is made to contain the sequence of bytecode instructions that correspond to each of the class's specific methods.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 1","FIG. 1","FIG. 1","FIG. 1","FIG. 1","FIG. 1"],"i":["b ","b ","b ","b ","b ","a ","a","b ","b ","a ","a","b"],"b":["101","103","101","101","103","103","107","130","108","109"]},"Compilation  of the source code level class description results in the formation of the bytecode level classfile . Among other possible items not shown in (e.g., rev codes, constant pools, . . . etc), a classfile may contain field information structures  for each of the class's variables and method information structures , ,  that contain the bytecode level instructions , ,  for each of the class's methods. Both the source code level commands and the bytecode level instructions for the class's methods are illustrated in as simple lines for illustrative convenience.","Over the course of discussion of various inventive aspects set forth in the detailed description that follows, comparisons will be made against each of and . illustrates, in more detail, exemplary JAVA source code level commands and corresponding JAVA bytecode level instructions for the \u201cGetMax\u201d method that was first presented in . The \u201cGetMax\u201d method is designed to return the greater of two variables \u2018a\u2019 and \u2018b\u2019 (i.e., if \u2018a\u2019 is greater, \u2018a\u2019 is returned; if \u2018b\u2019 is greater, \u2018b\u2019 is returned).","Note that both the source code level and bytecode level implementations for the \u201cGetMax\u201d method have a single entry point , (i.e., the method starts at locations , ) and a pair of exit points , and , (i.e., the method can end at locations , and , \u2014noting that a \u201creturn\u201d command\/instruction causes an output to be presented; which, in turn, can be viewed as the completion of the method). Those of ordinary skill will be able to recognize that: (1) the source code level depiction of the GetMax method observed in articulates a method written in JAVA source code language that returns the greater of two values (i.e., a and b); and, likewise, (2) the bytecode level depiction of the GetMax method observed in articulates a corresponding method written in JAVA bytecode language that returns the greater of two values (i.e., the values a and b which are respectively loaded on the top of an operand stack by the initial \u201ciload_\u201d and \u201ciload_\u201d instructions).","A method having a single entry point  and a pair of exit points , , like the \u201cGetMax\u201d method, can be represented by depiction  where the top surface  corresponds to an entry point of the method and side edges  and  correspond to exit points. shows a schematic representation of the process flow for an exemplary object oriented process. The exemplary process flow of depicts four methods , , ,  depicted similarly to the representation  observed in (noting that method_  has a structure that is identical to the structure  of ).","Entry points are depicted at the top surfaces , , ,  of methods , , , ; and, exit points are depicted as side ports of methods , , ,  (i.e., side ports , ,  for method_ ; side ports ,  for method_ ; side ports ,  for method_ ; and, side ports , , ,  for method_ ) and bottom ports of methods ,  and  (i.e., bottom port  for method_ ; bottom port  for method_ ; and, bottom port  for method_ ).","According to the object oriented process flow depiction of , a first object  is called in order to execute method_ ; then, a second object  is called in order to execute method_ ; then, a third object  is called in order to execute method_ ; then, a fourth object  is called in order to execute method_ . Each of the methods commence at their respective entry points , , , . Method_ exits at a exit point , method_ exits at exit point , method_ exits at exit point ; and, method_ exits at exit point  endeavors.","3. Enterprise Systems","Traditional client-server systems employ a two-tiered architecture such as that illustrated in . Applications  executed on the client side  of the two-tiered architecture are comprised of a monolithic set of program code including a graphical user interface component, presentation logic, business logic and a network interface that enables the client  to communicate over a network  with one or more servers . A database  maintained on one of the servers  provides non-volatile storage for the data accessed and\/or processed by the application .","As is known in the art, the \u201cbusiness logic\u201d component of the application represents the core of the application, i.e., the rules governing the underlying business process (or other functionality) provided by the application. The \u201cpresentation logic\u201d describes the specific manner in which the results of the business logic are formatted for display on the user interface. The \u201cdatabase\u201d  includes data access logic used by the business logic to store and retrieve persistent data.","The limitations of the two-tiered architecture illustrated in become apparent when employed within a large enterprise. For example, installing and maintaining up-to-date client-side applications on a large number of different clients is a difficult task, even with the aid of automated administration tools. Moreover, a tight coupling of business logic, presentation logic and the user interface logic makes the client-side code very brittle. Changing the client-side user interface of such applications is extremely hard without breaking the business logic, and vice versa. This problem is aggravated by the fact that, in a dynamic enterprise environment, the business logic may be changed frequently in response to changing business rules. Accordingly, the two-tiered architecture is an inefficient solution for enterprise systems.","In response to limitations associated with the two-tiered client-server architecture, a multi-tiered architecture has been developed, as illustrated in . In the multi-tiered system, the presentation logic , business logic  and database  are logically separated from the user interface  of the application. These layers are moved off of the client  to one or more dedicated servers on the network . For example, the presentation logic , the business logic , and the database  may each be maintained on separate servers, ,  and , respectively.","This separation of logic components and the user interface provides a more flexible and scalable architecture compared to that provided by the two-tier model. For example, the separation ensures that all clients  share a single implementation of business logic . If business rules change, changing the current implementation of business logic  to a new version may not require updating any client-side program code. In addition, presentation logic  may be provided which generates code for a variety of different user interfaces , which may be standard browsers such as Internet Explorer\u00ae or Netscape Navigator\u00ae.","The multi-tiered architecture illustrated in may be implemented using a variety of different object-oriented application technologies at each of the layers of the multi-tiered architecture, including those based on the JAVA 2 Enterprise Edition\u2122 (\u201cJ2EE\u201d). In a J2EE environment, the business layer , which handles the core business logic of the application, is comprised of ENTERPRISE JAVA BEAN (\u201cEJB\u201d) components with support for EJB containers. Within a J2EE environment, the presentation layer  is responsible for generating servlets and JAVA Server Pages (\u201cJSP\u201d) interpretable by browsers at the user interface layer  (e.g., browsers with integrated JAVA virtual machines).","Although the multi-tiered system illustrated in provides a more flexible and scalable architecture, it also results in significant additional complexity. For example, monitoring, testing and\/or debugging multiple clusters of presentation layer servers, business layer servers and databases, and the dependencies between them requires a significant amount of management overhead. As such, the ability to efficiently monitor, test and\/or debug object-oriented, virtual-machine-based enterprise software, such as the software employed in a J2EE environment, is critical for efficient software development and\/or implementation.","A method is described that comprises receiving from a classfile registration information. The registration information comprises a class name and a different method name for each of the class's methods. Each of the methods are modified with at least one additional byte code instruction to cause, for its respective method, a plug-in module's handler method to provide output function treatment for the respective method. Also, a plug-in pattern is referred to in order to determine which of a plurality of plug-in modules are appropriate for each of the class's methods. The plug-in pattern lists for each of the plug-in modules those of the methods that are to be handled with its corresponding output function treatment.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 3","FIG. 4"],"i":["a","b "]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 3","FIG. 4"],"b":["355","350","352","350","353","352","350","353","330","360","360","360","360","331","331","331","331","381","381","350"],"i":"a ","sub":["1 ","Z","1 ","2 ","1","N","1","N ","1","N "]},"Developers, based on their particular testing, debugging and\/or monitoring needs, may customize design and implement plug-in modules. This modular plugin architecture provides a flexible and scalable solution for evaluating program code, and may be particularly useful for evaluating program code on large enterprise platforms (e.g., such as J2EE-based platforms).","One particular type of function performed by a plug-in handler is an output function that records one or more properties about the method and\/or causes one or more properties associated with the method to be recorded. For example, one type of output function performed by a plug-in handler (e.g., plug-in handler ) involves recording the time that each method started at an entry point and\/or exited at an exit point. Developers may use this recorded timing information to determine, for example, the sequence of methods just prior to a \u201ccrash\u201d of the software. Similarly, if a particular method or sequence of methods take an inordinate amount of time to complete, the developer may determine the reasons why and\/or change the program code to operate more efficiently. As such, the recording of when method entry points and method exit points are reached allows a precise method history sequence to be reconstructed.","In addition to timing information, the parameters that are passed to a method when it starts (e.g., its input parameters) and\/or the parameters that are passed by a method when it exits (e.g., its output\/returned values) may also be recorded by a plug-in handler to enhance the recorded history of the execution flow (e.g., a returned value or a thrown exception). For example, applications may often crash because of an incorrect or incompatible parameter value. By recording parameter values that are passed in and out of the application's methods over the course of the application's execution flow, the appearance and\/or source of an incorrect\/incompatible parameter value can be readily flagged.","Thus, not only can start\/stop times be recorded on a method-by-method basis; but also, parameters can be recorded on a method-by-method basis. Of course, the identity of the methods themselves may also be recorded. A plug-in handler that records the start and\/or end times of a method and\/or records the parameter flow in and\/or out of a method may be referred to as a \u201ctracing\u201d plug-in handler because aspects of the method history of a software routine can be \u201ctraced\u201d through the recordation of its method start\/end times and its method parameter values.","Another type of output function that may be performed by a plug-in handler (e.g., plug-in handler ) involves maintaining a counter for each bytecode modified method and incrementing the counter each time its corresponding method is used (e.g., incrementing the counter for a bytecode modified method each time the bytecode modified method makes a function call to the dispatch unit  from its entry point). As applications (and, in particular, enterprise applications) involve complicated \u201clogic,\u201d cross-method interdependencies, etc., it is possible that certain sections of code are never executed (i.e., are \u201cdead\u201d or \u201cunreachable\u201d) or are almost never executed because of a flaw in the design of the application.","Counting each time a method is used allows dead\/unreachable or hardly used regions of the software to be readily identified. In addition, for monitoring purposes, counting each time a method is used allows a software manager to comprehend \u201cusage\u201d rates of the software's individual methods. A plug-in handler that is capable of maintaining a counter for an individual method may be referred to as a \u201ccoverage\u201d plug-in handler because the frequency of usage of various regions of the software can be gauged by counting each time a method is used. In related embodiments, a single coverage plug-in handler may be designed to maintain separate counters for a plurality of methods.","In the examples described herein, the various functional components illustrated in operate together as a service (e.g., a J2EE service) which may be used by programmers and\/or developers to test, debug and\/or monitor program code on an enterprise network using bytecode modification techniques.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 4","FIG. 4","FIGS. 3 and 4"],"i":["a ","a","b. "],"b":["451","452","330","430"]},"Once the methods to be modified have been modified , the modified bytecode is executed  with the help of a virtual machine interpreter. The execution of the bytecode may also be referred to as \u201cruntime\u201d. During runtime , as explained in more detail further below, the dispatch unit , responds to each invocation from a modified method by ensuring that the runtime execution process flows to the appropriate plug-in(s) for the invoking method. As a consequence, the invocations made to the dispatch unit ,  cause the appropriate plug-in handler(s) to perform their designated functions (e.g., such as the output functions described above). Note that each plug-in handler can be viewed as including a specialized body of instructions that, when executed, cause the plug-in handler's particular function to be performed.","For the purpose of illustration, one example of system operation is set forth in . Like , shows a schematic representation of a process flow for an exemplary object-oriented process. However, in contrast to , graphically illustrates each of the bytecode modified methods  through  invoking the dispatch unit  at the their corresponding entry point (i.e., entry points  through ) and exit point (i.e., exit points  through ).","Thus, as a consequence of the bytecode modification, for a process flow that performs the substantive equivalent of that observed in (i.e., from object_\/method_ \/ to object_\/method_ \/ via exit point  of method_ ; from object_\/method_ \/ to object_\/method_ \/ via exit point  of method_ ; from object_\/method_ \/ to object_\/method_ \/ via exit point  of method_ ; and, exiting from exit point  of method_ ), the process flow is directed from each method entry and exit point to the dispatch unit . The dispatch unit  then causes the runtime process flow to flow to an appropriate plug-in handler for each method whose corresponding handlers perform their designated function, as described herein.","Note that as bytecode modifications are made at each entry and exit point for each of methods -, the associated plug-in handlers may still record information for each of methods - even if the runtime process flow were to flow through a different set and\/or sequence of method entry and exit points than those observed in ","In the particular example illustrated in , methods ,  and  have been configured to receive \u201ctracing\u201d treatment by plug-in module A ; and, only method  is configured to receive both \u201ctracing\u201d treatment and \u201ccoverage\u201d treatment by plug-in module B . As such, the process flow for methods ,  and  involves from each of their respective entry , ,  and exit , ,  points: (1) invoking the dispatch unit ; (2) dispatching the invocation to plug-in module A ; (3) executing tracing method(s) with the handler  of plug-in module A  (e.g., record a start time and\/or input parameters identified with the invoking method if the invoking method is invoking from an entry point; or, record an end time and\/or output parameters and\/or returned value identified with the invoking method if the invoking method is invoking from an exit point); and, (4) returning back to the entry or exit point that made the original invocation.","By contrast, the process flow for method  involves from its entry  and exit  points: (1) invoking dispatch unit ; (2) dispatching the invocation to plug-in module B ; (3) executing tracing method(s) with handler  (i.e., record a start time and\/or input parameters if invocation is from entry point ; or, record an end time and\/or output parameters if invocation is from exit point ); (5) executing coverage method(s) with handler  (i.e., increment a counter maintained for method_ ) and, (5) return back to the entry or exit point that made the original invocation.","The above example demonstrates that the embodiment of the dispatch unit  referred to above is responsible for being conscious of an appropriate plug-in module for each invoking method and causing the runtime process flow to be directed to the appropriate plug-in module for each invoking method. As observed in , the same plug-in module (e.g., plug-in module )' may be \u201cre-used\u201d across a plurality of methods (e.g., methods ,  and ); and, some plug-in modules may contain only a single handler (such as plug-in module ) while others may contain more than one handler (such as plug-in module ). Moreover, as described in more detail below, more than one plug-in module may be associated and dispatched to from the entry point and\/or exit point of a single method.","Note that appropriate coverage monitoring may be gained by the coverage plug-in handler  at either a method's entry point or a method's exit point (e.g., rather than executing the coverage plug-in handler  at both the method's entry and exit points as suggested by ). That is, as the coverage plug-in handler  counts each time method  is used, a proper count may be determined by incrementing the counter maintained for method  only when method  starts (i.e., coverage is triggered at entry point ); or, only when method  ends (i.e., coverage is triggered at exit point ). In one embodiment, coverage is triggered at entry point  to ensure that the count that is maintained for method  is accurate even if the software happens to crash during execution of method .",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIGS. 5","FIG. 5","FIG. 5","FIG. 5"],"i":["a ","b ","a ","b ","a"],"b":["5","501","502"]},"In response to the invocation, the dispatch unit  identifies the appropriate plug-in module for the method through recognition of the invoking method (e.g., by way of a class ID and a method ID) and causes the process flow to be dispatched to an appropriate plug-in module  by returning a reference to the appropriate plug-in module for the invoking method (e.g., a reference to an object that the plug-in module corresponds to). The invoking method uses the reference to call upon the plug-in module; which, in turn, causes the plug-in module's handler method(s) to be executed. The handler(s) execute their recordation method(s) ; and, the process flow returns to the remainder of the invoking method's instructions . In the case of where the first block of bytecode-level instructions  in the modified method are for invoking the dispatch unit, the first instruction in the remainder of the invoking method's instructions  may be the first instruction generated for the method by the standard source code-to-bytecode compilation  process (i.e., the first instruction of the method prior to modification).","According to the methodology of , a bytecode-modified method can exit  as a consequence of various events (e.g., the method calculates a value to be returned, the method invokes another method, etc.). In the particular embodiment of , the block of bytecode level instructions  that correspond to the modification that invokes the dispatch unit is located just prior to an instruction  that corresponds to an exit from the method. Alternate embodiments may choose (for whatever reason) to insert the block of instructions that invoke the dispatch unit at a point deeper up into the method's sequence of instructions that are inevitably executed if the method is to reach the exit point .","In response to the invocation at the method's exit, the dispatch unit identifies the appropriate plug-in module for the method through recognition of the invoking method and provides back to the invoking method a reference to the appropriate plug-in module. The invoking method uses the reference to call the appropriate plug-in module . The plug-in module's handler(s) execute their recordation method(s) ; and, the process flow returns to exit the method.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 6","FIG. 1","FIG. 6","FIG. 4","FIG. 6","FIG. 1"],"i":["a ","b ","b ","c","b ","a ","b ","a","b","b","b ","b ","a ","c "],"b":["620","120","620","120","452","650","643","644","645","646","150"]},"For additional information and ease of understanding, an equivalent source code method that could be compiled to directly produce the bytecode modified version is also shown in . The equivalent source code method has been provided because source code syntax is generally considered easier to follow than bytecode syntax. It should be realized, however, that the equivalent source code need not be generated for complying with the underlying principles of the invention (i.e., only bytecode-level methods, such as bytecode level method , may be used for modification purposes).","Comparing the pre-modification bytecode method of with the post modification bytecode method of , note that additional blocks of instructions , , and have been introduced by the bytecode modification process . Recalling that the modification process involves adding instructions that invoke the dispatch unit , and that the code observed in and are written in the JAVA language, each of the additional blocks of instructions , , and correspond to blocks of bytecode-level instructions that are designed to at least invoke the dispatch unit .",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 6","FIG. 4"],"i":"a","b":"430"},"Blocks of instructions through are shown in because, typically, some instruction level processing is performed prior to a jump to an invoked method. This pre-processing helps \u201cset up\u201d the process flow jump. For example, methods typically require input parameters (which may also be referred to as \u201carguments\u201d) that are used as a basis for execution. At the bytecode level, the arguments for invoking the dispatch unit's methods should be suitably prepared just prior to the actual invocation instruction (e.g., an invokestatic instruction).","This may involve, for example, the placing of these arguments on top of an operand stack. In a further embodiment, because the dispatch unit  may also be geared to recognize the invoking method based upon (at least in part) the invoking method's own arguments, the additional instruction-level processing that sets up the invocation to the dispatch unit may also create an object made to contain the invoking method's own arguments (note that this same object may then be used by a plug-in module's handler to record the invoking method's arguments at the time the method starts). Regardless of how the arguments for the dispatch unit's methods are prepared, the procedures for doing so require the execution of instructions; and, therefore, modifying a bytecode-level method with invocations to another method typically requires additional instructions, per invocation, beyond each specific invocation instruction (e.g., beyond each added invokestatic instruction).","Because invocations to the dispatch unit are made from modified method entry and exit points, shows the bytecode modification as the insertion of instruction blocks at the entry and exit points of the method . With respect to the exit points, instruction block is placed at the exit caused by the value \u201ca\u201d being returned; and instruction block is placed at the exit caused by the value \u201cb\u201d being returned (recalling that the method is designed to return whichever of a and b is the greater value). Because (for purposes of illustrative convenience) the variable stack values for the bytecode level methodology of have not been provided, the parameters associated with the inserted instruction blocks , that invoke the dispatch unit are better understood by referring to the equivalent source code syntax ","Note that two different methods of the dispatch unit are invoked: dispatchunit.entry and dispatchunit.exit , . Here, the dispatchunit.entry method is invoked for those invocations made from a method entry point; and, the dispatchunit.exit method is invoked for those invocations made from a method exit point. Invoking different methods depending on whether the method is at an entry point or exit point allows for different or customized dispatch unit responses depending on whether the method resides at an entry or exit.","Other possible differences between the .entry and .exit method embodiments referred to in may be recognized by focusing on the differences in their arguments. Specifically, note that the embodiment of the .entry method includes the following arguments:","1. classid;","2. methodid;","3. object this pointer; and,","4. object [ ] param.","By contrast, the embodiments of the .exit methods , include the following arguments:","1. classid;","2. methodid;","3. returned value","4. thrown exception [which is normally null, and becomes non-null when the method has returned abruptly, i.e. by throwing an exception]","From the above note that both the .entry and .exit methods include an identification of the class that the invoking method  belongs to (classid) and an identification of the invoking method  itself (methodid). In an embodiment, the classid and methodid parameters are sufficient to identify the invoking method. In other embodiment, however, the classid, the methodid and a description of the invoking method's own arguments (which are referenced through an object identified by the \u201cobject [ ] param\u201d argument) are used by the dispatch unit's .entry method to identify the appropriate plug-in module treatment. As alluded to above with respect to and and as described in more detail below with respect to , the dispatch unit  maintains information that correlates each method with the one or more plug-in modules that are supposed to treat it.","The .entry method and .exit methods may differ, however, in that the .entry method may also identify (e.g., via the \u201cobject this pointer\u201d argument) the object associated with the invoking method (noting that if the invoking method is a class (i.e. static) method the \u201cobject this pointer\u201d argument may be represented as a null); yet, the .exit method may make no such identification. As described above with respect to the embodiments of -, a reference for an appropriate plug-in module may be returned to an invoking method in response to the invoking method's initial call of the dispatch unit's .entry method. In order to return the reference to the invoking method, the identity of the object to which the invoking method belongs should be known to the dispatch unit. Once the identity is known by the dispatch unit, it need not be repeated. Better said, the identity of the object to which the calling method belongs can be grasped by way of the .entry method; and, therefore, can be thereafter used by the dispatch unit for the subsequent .exit method.","The \u201cobject this pointer\u201d parameter therefore does not need to be provided for .exit methods. The .entry method and .exit methods may also differ in that the .entry method may describe the invoking method's own arguments as part of its invocation to the dispatch unit (i.e., in the case of the \u201cGetMax\u201d method, a and b as found in \u201cobject[param]\u201d), whereas the .exit methods may only describe the returned output value as part of the invocation. This allows for different plug-in module treatment as between entry points and exit points of the same method. In one embodiment of the invention, if a method throws an exception, an .exit method event may be processed.","Referring back to the bytecode instruction level coding , note that a third exit point and associated instruction level coding is also depicted . According to the approach alluded to in , the third exit point and associated instruction level coding corresponds to an additional exit point that is added by the modification process  so as to effectively install a \u201ccatch block\u201d around the entire method. A \u201ccatch block\u201d is coding that automatically causes the software process flow to jump to a section of the coding designed to deal with errors (e.g., a location in the bytecode of a method) if an error occurs in the execution of the coding surrounded by the \u201ctry-catch\u201d block (which, in the embodiment of , corresponds to the entire GetMax method).","In summary, the modification process  implemented by bytecode modifier , besides installing blocks of instructions , , for dispatching unit invocations at naturally existing method entry and exit points, may also be configured to install an artificial exit (i.e., one that would not exist were it not for the modification process) and associated instructions that are tailored to respond to an error condition, should one arise, during execution of the method. In such a case, the \u201ci cmp\u201d instruction (which is the instruction that signifies whether \u201ca\u201d is greater than \u201cb\u201d or if \u201cb\u201d is greater than \u201ca\u201d) triggers an error condition; which, in turn, would cause instructions to be executed.","Referring to both the bytecode level and source code level codings of the GetMax method, note that the error handling instructions correspond to an invocation to the dispatch unit . Here, an .exit method is used to invoke the dispatch unit. Note that a \u201cthrown\u201d value (i.e., an error indication) is provided as part of the invocation. This allows a unique plug-in module to be utilized to in the case of an error condition. The error handling instructions also include a generic thrown command that, when executed, raises an error state in the current thread, which can either be caught or propagated up the execution stack.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":["FIG. 6","FIG. 4","FIG. 6","FIG. 4","FIG. 1","FIG. 6"],"i":["b ","a","b ","a","b ","b","a ","b "],"b":["452","451","103","650"]},"The unmodified classfile in shows both an unmodified constructor method information structure and a depiction of the unmodified information structure for the \u201cGetMax\u201d method . A constructor method is a method which is always executed with the creation of an object. In a typical application, a constructor method is executed in order to initialize the other method (such as setting variables to specific values). The constructor method associated with unmodified classfile may be viewed as being necessary to execute before the execution of the GetMax method or another method found within classfile ","The exemplary bytecode modified classfile includes the following elements: (1) a \u201cclassid\u201d field information structure ; (2) a method information structure  for a method that registers with the dispatch unit when the modified classfile is loaded during runtime execution; (3) a method information structure for a modified version  of the constructor method; and (4) a method information structure for the modified version of the GetMax method that was discussed above with respect to . A discussion of each follows immediately below.","The additional classid field information structure  and the additional method information structure  (for the dispatch unit registration method) will be discussed together. Specifically, in an embodiment, when the modified classfile is loaded it automatically registers with the dispatch unit. In a further embodiment, the registration process entails providing the dispatch unit with the name of the class that the classfile represents, the name of its methods and the number and type of each method's arguments. In return, the dispatch unit provides the classfile with a numeric \u201cclassid\u201d value that is to be used for invocations made to the dispatch unit during a runtime invocation. The classid value then becomes part of the classfile's constant pool. Accordingly, the additional method information structure  may include instructions for the registration method described just above; and, the classid information structure is used for the returned numeric \u201cclassid\u201d parameter provided by the dispatch unit.","Viewing the constructor method prior to modification as a simple \u201cstraight through\u201d method having a single entry point and a single exit point, indicates that the instructions  for the method may be modified so as to include a block of instructions  at its entry to invoke the dispatch unit; and, a block of instructions  at its exit to invoke the dispatch unit. Here, the handler(s) of the appropriate plug-in module(s) (that are called upon as a consequence of invocations made to the dispatch unit from additional instruction blocks , ) may be tailored to report the initialized values for a method as determined by the constructor method. The exit block of instructions  may also be followed by another block of instructions that correspond to the placement of a try-catch block around the constructor method. The modified version of the GetMax method has already been discussed with respect to ","Recall from the background that, in general, the runtime execution of any computer program can be viewed as the execution of a sequence of methods; and that, with respect to an object oriented approach, such a sequence of methods can be implemented by calling upon a sequence of objects and invoking one or more methods at each object. Referring back to , implementing the bytecode modification approach in an object-oriented environment may take on many forms.","In one embodiment, the dispatch unit ,  is implemented as a class whose entry and .exit methods are static methods of the dispatch unit class. In this same embodiment, each of the plug-in modules through , through are instantiated as separate objects from a \u201cplug-in\u201d class; and, the individual handlers of each plug-in module object correspond to its operable methods.","4.1. Dispatch Unit Implementation","The dispatch unit  may be implemented to refer to, as illustrated in , a dictionary, table or similar data structure  (hereinafter \u201cdictionary\u201d) to support the dispatch unit in its central role of dispatching invocations made by each of the modified bytecode methods to its appropriate one or more plug-in modules. The dictionary  of  includes a listing of information sufficient to uniquely identity any potential invoking or calling method (methodid and classid); and, an entry for each listing that includes a reference to the appropriate plug-in module(s). Different dictionary's may be maintained for .entry and .exit methods. In further embodiments (e.g., as suggested by the source code representations of ), the information that is sufficient to identify an invoking method may be made to further include arguments of the invoking method (e.g, via the \u201cobject[param]\u201d for the .entry method).","In response to the reception of the information, a method responsible for accessing the dictionary (e.g., a .entry or a .exit method) identifies the reference(s) that is listed for the invoking method; and, returns the reference(s) to the invoking method. Thus, from the perspective of an invoking method, an invocation is made to the dispatch unit , ; which, in response, returns to the invoking method the reference to the appropriate plug-in module -, -. The process flow then jumps to the plug-in module(s), causing the corresponding handler instructions to be executed.",{"@attributes":{"id":"p-0114","num":"0113"},"figref":["FIG. 7","FIG. 4","FIG. 7","FIG. 7"],"b":["701","405","406","407","408","405","406","407","2","408","3","460","470"],"i":"b","sub":["x","y"]},"It is also worthwhile to point out that more than one plug-in module may be used for any single invocation from a modified method. For example, referring briefly back to , consider a situation where the same treatment is desired for each of methods  through  as originally discussed (i.e., methods  and  are to receive only tracing treatment and method  is to receive both tracing treatment and coverage treatment), however, plug-in module  is configured so as to only include the coverage handler  (i.e., tracing handler  simply does not exist in plug-in module ).","In this case, method  could still receive both tracing and coverage treatment by configuring the dictionary entry for method  to list both plug-in module A  (PIM_A) and plug-in module B  (PIM_B). By so doing, the process flow of would change so as to touch upon both of plug-in modules A and B ,  for each of the invocations stemming from bytecode modifications  and . Here, if the approach of and were being implemented, the dispatch unit  would return references to both of the plug-in modules ,  to method  for each invocation to the dispatch unit.","4.2. Extensions of Plugins and GUI Viewers","As mentioned above with respect to , unique plugins may be developed based on the specific needs of each user. By way of example,  illustrates an embodiment in which three different plugins are used: an application trace plugin ; a user-configurable plugin ; and a distributed statistical records (\u201cDSR\u201d) plugin.","The application trace plugin  of this embodiment identifies a particular application to the bytecode modifier  (e.g., in response to user input). In response, the bytecode modifier  modifies the entire application, by inserting function calls at entry points and exit points of each of the application's methods (e.g., using the bytecode modification techniques described herein).","Following modification, the application is executed, and the application trace handler  collects the timing data and, potentially, other method-related information, which it provides to a graphical user interface (\u201cGUI\u201d) . In one embodiment, tree generation logic  within the GUI  generates a method invocation tree  such as that illustrated in , (which shows a method invocation tree  for a simple calculator application.","The invocation tree  graphically displays information related to each invoked method, such as the time that it takes each method to complete and\/or parameters used for each method, in a structured hierarchy. For the calculator application, three separate headings , , and  are generated, each of which identify a different thread of the calculator application (e.g., \u201cSAPEngine_Application_Thread_\u201d). Entries for methods associated with each application thread are arranged beneath each respective thread heading. For example, method entry  is arranged directly beneath heading ; method entries  are arranged directly beneath heading ; and method entry  is arranged beneath heading .","Method entries ,  and  represent \u201cindependent\u201d methods in that they are not tied to the execution of another method (i.e., they are not invoked within the context of another method). By contrast, several \u201cdependent\u201d method entries -, i.e., representing methods that are dependent on the method represented by entry , are graphically arranged under entry  within the invocation tree . For example, method entry  is dependent on method entry ; method entry  is dependent on method entry ; and method entries  are each dependent on method entry . As is known in the art, a first method is \u201cdependent\u201d on a second method if the first method is executed within the context of the second method. For example, the method represented by entry  is only executed within the method represented by entry . Thus, as indicated by dependency arrow , the dependency of methods increases as one moves towards the right within the invocation tree (i.e., methods towards the right are dependent on entries which are relatively further to the left).","In addition, as indicated by the time arrow  in , in one embodiment, the tree generation logic  generates the invocation tree  so that entries towards the bottom of the invocation tree occur relatively later in time in relation to entries towards the top of the invocation tree. This graphical representation of method invocations based on time and dependency is a logical and useful way to display information related to method invocations.","As mentioned above, various different types of information may be displayed for each entry within the invocation tree . In the example shown in , each entry includes an indication of how long the method took to complete (i.e., based on the measured start\/stop times). For example, an indication that method \u201cCalcProxy.GetResults( )\u201d took 44,651 \u03bcs to complete is provided in method entry . In addition, an indication of certain input\/output parameters used in the method may also be provided (e.g., \u201c3,\u201d \u201c423,\u201d \u201c1\u201d for method entry ). Various other types of method-related information may be included within the invocation tree  while still complying with the underlying principles of the invention (e.g., the counter value for the method).","In one embodiment, a filtering module  is employed to filter timing data and other method-related information, based on the needs of the end user. For example, a user may choose to filter all method invocations from the method invocation tree  except for those methods associated with a particular application component, package or class. Similarly, in one embodiment, the filtering parameters may be applied so that only specific types of method-related information are displayed within the invocation tree . For example, the filtering parameters may specify that only each method's timing information is to be displayed whereas other information (e.g., the method's input\/output variables, the counter value, . . . etc), is to be filtered out. Thus, the filtering module  provides a more precise level of control over the types of method's and the types of method-related information to be displayed within the graphical user interface .","An exemplary graphical user interface (\u201cGUI\u201d) for viewing information related to modified bytecode is illustrated in -. For the purpose of explanation, the GUI displays different aspects of the modified calculator application described above with respect to . The exemplary GUI includes a first window  comprised of a list of services which may be selected by the end user. As indicated, the application tracing service  has been selected, thereby generating information related to application tracing in a second window .","Different information related to the bytecode modification may be displayed in the second window via a set of tabs . In , for example, an \u201cApplications\u201d tab is selected, thereby displaying a list of applications. For each application, an indication is provided identifying whether the application is started or stopped and, if started, whether the application is running in bytecode modified mode. The highlighted entry  indicates that the calculator application is currently running in bytecode modified mode. In addition, an action menu  is illustrated which includes entries for stopping the highlighted application  or restarting the application normally (i.e., in a non-modified mode). In one embodiment, the action menu  includes an option for restarting the application in bytecode modified mode (not shown) if the highlighted application is currently running in a non-modified mode.",{"@attributes":{"id":"p-0128","num":"0127"},"figref":["FIG. 9","FIG. 9","FIG. 9","FIG. 9"],"i":["c ","a","d ","e "],"b":["900","946","944","947","94","948","944"]},"It should be noted that the specific GUI-based features described above are for the purpose of illustration only. Information related to bytecode modification may be displayed in a variety of additional and\/or different ways while still complying with the underlying principles of the invention.","As described above, the application tracing plugin  instructs the bytecode modifier to modify all of an application's methods. While this may be sufficient for tracing\/debugging a relatively small application, a higher level of precision may be desirable, particularly when working with large enterprise applications.","Thus, in contrast to the application tracing plugin  which causes the bytecode modifier  to modify all of the methods within a particular application, the user-configurable plugin  illustrated in  provides a finer level of granularity for tracing program flow. An \u201capplication\u201d may be built from a plurality of packages (typically *.jar files in a JAVA environment); each package may be built from a plurality of classes (i.e., class files); and each class include a plurality of methods. As indicated in , the user-configurable plugin  allows the end-user to identify specific packages, classes and\/or individual methods to be modified by the bytecode modifier , thereby providing significantly greater precision for tracing and debugging operations. By way of example, if a coding problem is isolated to within a specific package, then only that package need be modified. Similarly, if the problem can be isolated to within a particular class or method, then only that class\/method need be modified. In one embodiment, the different packages, classes and\/or methods are selected and modified via one of the interfaces described below with respect to -","The method timing data and\/or other method-related information may then be displayed within a method invocation tree  similar to that illustrated in . For example, an output handler  associated with the user-configurable plugin  may be designed to provide the method-related information to the invocation tree generation logic . Thus, when the user-configurable plugin  is employed (as opposed to the application tracing plugin ), the method invocation tree does not include entries for all of the methods of an application. Rather, it only includes entries for methods within the particular package or class, or the individual methods selected by the end-user.","In addition, in one embodiment of the invention, a distributed statistical records (\u201cDSR\u201d) plugin  is employed to collect statistical data related to program execution across application servers, databases and\/or external systems. Several specific examples of DSR tracing will now be described with respect to -, which shows how certain critical entry\/exit methods may be tracked to collect statistical data.",{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 10","i":"a ","b":["1010","1020","1011","1010","1000"]},"In the specific example shown in , certain specific method invocations, identified graphically as blocks -, within the application components  are modified to facilitate tracking of client requests and responses through the system. The timing for each of the relevant method invocations is identified in the timing diagram illustrated in ","The client's 's initial request triggers a first method invocation  within the application components . The request may be, for example, a request for a particular record within the database. After additional application-layer processing, the application components  generate a database request via method invocation  which is received and processed by the database components . A single request\/response transaction with a client may involve multiple method-based interactions between the application server  and the database server . Thus, another method  is invoked in response to a communication from the database server ; a response to the database server is generated as method invocation  and a final response from the database server  is received as method invocation . Finally, the application responds to the client via method invocation  (e.g., which may provide a Web page containing the requested data to the client).","As indicated in , throughout the request\/response transaction, each of the bytecode modified methods - reports statistical timing data and other method-related information back to the dispatch unit , which forwards the information to the DSR plugin . One or more DSR handlers  associated with the DSR plugin  formats the information for the DSR system  and\/or provides the information to the DSR system  via a DSR interface . In one embodiment, the DSR interface  translates the method-related information into a format usable by the DSR system. The information may be stored within a set of DSR files  and\/or viewed and analyzed via a DSR viewer  (e.g., to determine whether the system is operating correctly).","The method-related information may also be provided to the GUI  which then generates an appropriate method invocation tree, and\/or displays the method-related information in one or more additional ways (as described above). Although not illustrated in , a different DSR handler may be employed to format and forward the DSR-based information to the GUI .",{"@attributes":{"id":"p-0139","num":"0138"},"figref":["FIGS. 11","FIG. 11","FIGS. 10"],"i":["a","b ","a","b","a","b"],"b":["1111","1110","1120","1100","1101","1111","1111","1103","1130","1130","1130"]},"The external system  then processes the request and provides the results back to the application components via method invocation . Finally, the application components respond to the client  via method invocation .","As in the examples shown in -, each time a bytecode-modified method is invoked, timing data and other method-related information is provided to the dispatch unit , which forwards the method-related information to the DSR plugin . The appropriate handlers (e.g., handler ) then format and\/or forward the method-related information to the DSR system  via the DSR interface . The DSR interface  may translate the information into a format interpretable by the DSR system, if necessary. The information may then be stored within a set of DSR files  and\/or viewed and analyzed via a DSR viewer . In addition, as in the embodiment shown in , the method related information may also be sent to the GUI  for viewing within an invocation tree and\/or may be displayed in any other convenient manner.",{"@attributes":{"id":"p-0142","num":"0141"},"figref":["FIG. 12","FIG. 12"],"b":["452","1211","1232","1250","1200","1227","1228","1201","1201","1202","1229","1230","1231","1232","1213","1214","1216","1215","1203","1202","1233","1234","1219","1220","1202","1204","1221","1222","1204","1207","1211","1212","1223","1224","1202","1205","1225","1226","1206","1217","1218"]},"The specific functions performed by each of the modules\/components illustrated in  are well defined and are not necessary for an understanding of the underlying principles of the present invention. For example, the JDBC component  is a well known interface that allows JAVA applications to access a database via the structured query language (\u201cSQL\u201d). The JCo component  is an interface that allows a JAVA application to communicate with systems designed by SAP AG (e.g., an R\/3 system). As described above, HTTP logic  and servlet\/JSP components  perform various well defined presentation-layer functions and the EJB components  perform various well define business layer functions. Further details related to each of these modules\/components can be found from various sources including the JAVA website.","For the purpose of the present application,  is significant because it shows how specific entry\/exit points between the various services\/components - may be tracked using the bytecode modification techniques described herein. For example, the individual methods highlighted in  may be selected for modification via a plugin such as the user-configurable plugin  illustrated in . As the methods are executed, timing data and other information related to each of the methods (e.g., method parameters) are collected by the dispatch unit  and forwarded to the appropriate plugin handlers (e.g., handler ). The handler(s) then forward the information to a GUI  or other output destinations for analysis. If a DSR plugin  is used, the dispatch unit  may forward the method information to an appropriate the DSR handler  which, in turn, may format and\/or transmit the information to a specified DSR system via a DSR interface (e.g., such as DSR system , and DSR interface , respectively).","Some end users may want to export the results of the bytecode modification techniques described herein to a standardized format, so that the results may be viewed and\/or analyzed on other systems. To this end, as illustrated in , one embodiment of the invention includes a markup language conversion module  for converting the method invocation tree generated by the tree generation logic  into a markup language format . For example, in one embodiment, the markup language conversion module  converts the method timing data and other method-related information from the invocation tree into an extensible markup language (\u201cXML\u201d) format. XML provides a similar tag structure as the hypertext markup language (\u201cHTML\u201d) used for standard Web pages; however, while HTML defines how elements are displayed, XML defines what those elements contain. In addition, while HTML uses predefined tags, XML allows tags to be defined by the developer of the page. Thus, all method-related data from the invocation tree (e.g., method execution times, method parameters, counter values, . . . etc) may be easily represented within an XML file using a set of hierarchical data tags. The markup-formatted invocation data may then be viewed, edited and\/or analyzed via a GUI which supports the specified markup language (e.g., current browsers, if the markup language used is XML).","Instead of converting the invocation tree generated by the tree generation logic  into a markup language format, one embodiment of the markup language conversion module  receives the method-related data directly from the a handler , , . This embodiment may be more efficient in that it circumvents the intermediate tree generation by the invocation tree generation logic .","The discussions presented above focus upon characteristics of modified bytecode and the runtime execution flow of modified bytecode. The present section, by contrast, focuses on techniques for actually modifying the bytecode. Better said, referring back to , whereas prior sections focused upon what the \u201coutput\u201d of the bytecode modification process  might look like and how modified bytecode might execute  during runtime, the present section focuses on methodologies that may be used to implement the actual bytecode modification process . Specifically, Section 5.1 discusses techniques for modifying classfiles; Section 5.2 discusses dispatch unit configuration; and, Section 5.3 discusses interfaces for specifying customized plug-in modules.","5.1 Processes For Modifying Classifies",{"@attributes":{"id":"p-0149","num":"0148"},"figref":["FIG. 14","FIG. 4","FIG. 1","FIG. 14","FIG. 15","FIG. 1"],"b":["452","103","1401","103"],"i":["a","b ","b","a","b ","b "]},"Referring to the exemplary classfile of and the corresponding collection of objects of , note that the \u201chierarchy\u201d of objects observed in attempts to mirror the hierarchy of the bytecode level classfile illustrated in . Object oriented programming has an \u201cinheritance\u201d property by which objects of a class inherit the properties defined for a class (e.g., the types of variables that the object can entertain specific values for). Given the existence of the inheritance property, attempts to demonstrate an example of how the various features of the \u201csales\u201d classfile of may be organized into specific classes of objects were principles of inheritance are observed.","Specifically, suggests the creation of a separate class for each of the major features of the \u201csales\u201d classfile ; and, the creation of specific instances (i.e., objects) of these classes so as to create an object oriented representation of the classfile. For example, a specific class  may be created for field information structures and a specific class  may be created for method information structures. The field information structure class  can then be used as a template to form separate \u201cPN\u201d, \u201cQTY\u201d, \u201c$\u201d and \u201cCUSTOMER\u201d objects , , , that respectively represent the \u201cPN\u201d, \u201cQTY\u201d, \u201c$\u201d and \u201cCUSTOMER\u201d field information structures  found in the \u201csales\u201d classfile ","Likewise, the method information structure class  can be used as a template to form separate \u201cUPDATE ACCOUNTING\u201d, \u201cUPDATE BILLING\u201d and \u201cGetMax\u201d objects , , that respectively represent the \u201cUPDATE ACCOUNTING\u201d, \u201cUPDATE BILLING\u201d and \u201cGetMax\u201d method information structures , ,  found in the \u201csales\u201d classfile . also elaborates on the content of the GetMax object . Here, the method information structure class  is assumed to specify that each of its object offspring (e.g., objects , , ) are to be associated with objects that correspond to bytecode level instructions for the method that it represents. Each of the objects  observed in correspond to the listed matter maintained by the GetMax object . Note that the listed matter observed in corresponds precisely to the bytecode level instructions for the GetMax method first depicted in ","Referring back to , the collection of objects is then modified  to reflect the bytecode modifications. provides a corresponding example showing how the objects associated with the GetMax object of can be modified  to represent the modified GetMax bytecode that has been provided in . Specifically, note that the listed objects has been expanded so as to include\u2014in their proper locations\u2014representations of the additional bytecode instructions , , ,  that invoke the dispatch unit. For illustrative simplicity, only shows the insertion of a single invocation instruction (\u201cinvokestatic\u201d) , , ,  for each of instruction blocks , , and of ","It should be recognized however that if blocks of multiple instructions are to be inserted for each dispatch unit invocation (e.g., as suggested by instruction blocks , , and of ); then, likewise, a corresponding list of instructions would be inserted at each of locations , , , .  shows a method that can be executed to make modifications to a collection of objects that are representative of a classfile (such as the modifications observed in ) so as to reflect the appropriate modifications to be made to a method's bytecode instructions.","According to the methodology of , modifications are inserted that are representative of additional instructions (e.g., a block of instructions) that invoke the dispatch unit at positions in the collection of objects that represent the following method locations: 1) a method entry point  (e.g., as represented by modification  of ); 2) a method exit point  (e.g., as represented by modifications ,  of ); and, 3) the end of a method's instructions for purposes of introducing try-catch block instructions (e.g., as represented by modification  of ).","The example referred to in and and the methodology of  indicate that specific methods may be represented by specific objects and their corresponding bytecode instructions may be represented by other objects that they are associated with. It is important to recognize that a collection of objects configured to represent a classfile may be modified in other aspects so as to fully represent a completely modified classfile. For example, referring back to , recall that other bytecode level modifications may be made besides installing dispatch unit invocations at method entry and exit points and besides installing try-catch blocks around methods themselves.","Specifically, an entire method information structure may be inserted into the classfile (such as a method information structure  for a dispatch unit registration method); and, a new field information structure may be inserted into the classfile (such as a field information structure  for a classid value). In keeping with the approach outlined above with respect to and , where a separate object is created for each method information structure and for each field information structure, note that the insertion of an additional method information structure would correspond to the creation of a first object in the collection of objects (e.g., a \u201cdispatch unit registration\u201d object); and, the insertion of an additional field information structure would correspond to the creation of a second object in the collection of objects (e.g., a \u201cclassid\u201d object).","Thus, whereas the modifications to the class methods themselves might involve modifying the collection of objects associated with each object made to represent a method, constructing a complete collection of objects that are representative of a completely modified classfile might involve the creation of objects having no counterpart to the pre-modified bytecode (e.g., the pre-modified bytecode has no \u201cdispatch unit registration\u201d method information structure nor \u201cclassid\u201d field information structure).","Referring back to , irrespective of how a collection of objects are made to represent a modified classfile, the collection of objects is converted into a bytecode level classfile . As a consequence, a fully modified classfile is created. The conversion of a classfile into a collection of objects and the reconversion of a collection of objects into an actual classfile is a well known process, also referred to as parsing\/serialization of a classfile.","5.2. Dispatch Unit Configuration","In one embodiment of the invention, in order for the dispatch unit ,  to properly dispatch an invocation from a specific method to its appropriate plug-in during runtime, the dispatch unit is configured beforehand with the appropriate information. For example, before supporting an actual runtime flow of modified bytecode, the dispatch unit  may run through internal processes that \u201cset up\u201d information (e.g., a dictionary) that correlates each bytecode modified method with one or more appropriate plug-in modules. Recall that an embodiment of such a dictionary that correlated each modified bytecode method with an appropriate plug-in module has already been discussed with respect to .  describe some possible approaches that enable the dispatch unit  to configure itself to support a runtime flow invocation from a bytecode modified method.",{"@attributes":{"id":"p-0162","num":"0161"},"figref":["FIG. 17","FIG. 6","FIG. 17"],"b":["1701","1701","1703","1703","1704","1704","1703","1703","1702","1702"],"sub":["1 ","N ","1 ","N ","1 ","N","1 ","N "],"i":"b"},"By way of example, as illustrated in , modified classfile sends the dispatch unit  its class name and the names and argument types of each of its methods ; modified classfile sends the dispatch unit  its class name and the names and argument types of each of its methods ; and modified classfile sends the dispatch unit  its class name and the names and argument types of each of its methods . Registration may invoke any feature of the dispatch unit's class such as a field, an object or a method.","In an embodiment, registration occurs as a consequence of a modified classfile being \u201cloaded.\u201d The loading of a classfile can be viewed as the preparing of a class for subsequent use. In a typical case, a classfile is loaded before the classfile is used as a template for creating an object that is a member of the class that the classfile defines. In a further embodiment, a registration process is executed for a classfile before any of the classfile's modified methods are executed. So doing causes the dispatch unit  to be properly updated for any subsequent invocation that arises from the execution of any of the class's modified methods.","The dispatch unit  uses the class name, method names and method specific argument types received from any particular classfile as a stimulus for updating its internal information that correlates specific methods to specific plug-in modules (e.g., an internal dictionary). In various embodiments, the dispatch unit  correlates class methods to their appropriate plug-in strictly numerically (i.e., without the use of character strings). For example, the dictionary of  may be configured to reference each classid (c), each methodid (m) as a number rather than its given character string name.","In order to reference classes and methods strictly numerically, therefore, each character string based class name (e.g., \u201cSales\u201d) is converted into a number (e.g., integer ); and, each character string based method name (e.g., \u201cGetMax\u201d, \u201cUPDATE ACCOUNTING\u201d, \u201cUPDATE BILLING\u201d) is converted into a corresponding number (e.g., integer , integer , integer ).  suggests such an approach in that each registering classfile through sends its class name to the dispatch unit (e.g., in the form of its given character string (e.g., \u201cSales\u201d for classfile )); and, in response, the dispatch unit  returns a numeric classid through to each of the registering classfiles, respectively.","The numeric classids are configured into the dispatch unit's plug-in correlation dictionary; and, subsequent invocations made to the dispatch unit  by way of a modified method are made to use the numeric classid value rather than the given character string for the name. In further embodiments the numeric references are embodied as integers in order to improve processing speeds. Moreover, the numeric classid may be simply derived from the position at which a registering classfile registers with respect to a consecutive sequence of classfiles that register with the dispatch unit (e.g., the first classfile to register with the dispatch unit is given a classid of \u201c1\u201d, the second classfile to register with the dispatch unit is given a classid of \u201c2\u201d, etc.).","With respect to the conversion of character string method names into an appropriate number, in an embodiment, both the registering classfiles through and the dispatch unit  are made to understand that methods are referred to numerically in a sequential order. For example, according to one approach, the methods are referred to by the order in which their corresponding information structures are listed in the classfile. helps to envision such an approach. Referring to (and assuming that the classfile of is modified as observed in ) note that the method information structures are listed in the following order: \u201cGetMax\u201d, \u201cUPDATE ACCOUNTING\u201d, \u201cUPDATE BILLING\u201d. One way to refer to the methods in the order of their listing in the classfile is as follows: 1) \u201cGet Max\u201d=integer ; 2) \u201cUPDATE ACCOUNTING\u201d=integer ; 3) \u201cUPDATE BILLING\u201d=integer . According to such an approach, the same method names are used by different classes (i.e., classid  has methods ,  and ; and, class  has methods , , ). Combining classid and methodid, however, will still produce unique \u201cper method\u201d identification.","By making the classfiles and the dispatch unit understand the same ordered numeric naming scheme, methods can be properly referenced between the classfiles and the dispatch unit in a manner that is consistent with the method\/plug-in-handler correlation entries that are maintained by the dispatch unit. For example, if classfile corresponds to the \u201cSales\u201d classfile of , and if, the dispatch unit  returns a classid value of \u201cinteger: \u201d to the \u201cSales\u201d classfile , then: 1) the modified \u201cGetMax\u201d method will invoke the dispatch unit  with a classid, methodid set of 1,1; 2) the modified \u201cUPDATE ACCOUNTING\u201d method will invoke the dispatch unit  with a classid, methodid set of 1,2; and, 3) the modified \u201cUPDATE BILLING\u201d method will invoke the dispatch unit  with a classid, methodid set of 1,3. Likewise, the dispatch unit would correlate identical numerical entries listed above to the proper plug-in handler treatment for each of the three methods.","In an embodiment, during the registration process, a registering classfile sends method names in character string form to the dispatch unit  in an order that allows the dispatch unit  to properly deduce the correct numeric methodid values. For example, continuing with the above example, the \u201cSales\u201d classfile would send method character string names in the following order: \u201cGetMax\u201d, \u201cUPDATE ACCOUNTING\u201d, \u201cUPDATE BILLING\u201d. By sending the character string names in the order listed above, both the registering classfile and the dispatch unit could independently recognize that the \u201cGetMax\u201d method is be given a methodid value of 1; the \u201cUPDATE ACCOUNTING\u201d method is to be given a value of 2; and, the \u2018UPDATE BILLIG\u2019 method is to be given a value of 3.","Even though the dispatch unit  can deduce the proper numeric naming scheme simply from knowing the order of the methods, explicit character strings are sent to the dispatch unit  to also assist the dispatch unit in the updating of its method\/plug-in module correlation scheme.  helps explore this aspect in more detail.  shows a registering classfile  and a dispatch unit . Consistent with the preceding discussion concerning , note that the registering classfile can be regarded as sending  the class names and method names  in character string format (e.g., \u201cSales\u201d, \u201cGetMax\u201d, \u201cUPDATE ACCOUNTING\u201d, \u201cUPDATE BILLING\u201d). In response, the dispatch unit's registration method  refers to a plug-in pattern  to identify which plug-in modules are to be applied to which methods . The plug-in pattern, in an embodiment, includes a list, for each plug-in module, of every method (e.g., by class name and method name in character string format) it is expected to treat.","For example, referring back to , recall that plug-in module A  was configured to treat methods ,  and  while plug-in module B was configured to treat only the third method . In such an instance, the substantive content of the lists maintained by the plug-in pattern  would be as follows:","1) PlugIn_A ()\n\n","2) PlugIn_B ():\n\n","In an embodiment, the plug-in pattern  is a body of information maintained (e.g., by way of an object) by the same class that the dispatch unit  is associated with.","Once one or more appropriate plug-in modules have been identified by the dispatch unit's registration methodology , the scheme used to correlate specific methods to their appropriate plug-in module(s) during runtime (e.g., dictionary ) is updated  to account for all the methods of the registering classfile. The argument types for each method that are provided by a registering classfile can be added to the classid and methodid in each listing. If strictly numeric references are to be used for the classids and methodids, the character string-to-numeric conversion should be performed prior to the actual update . For example, numeric methodids should be assigned based on the order of reception of method names from the registering classfile ; and, a suitable numeric classid should be identified. In an embodiment, the numeric classid is determined simply by incrementing a counter for each new registering classfile. The numeric classid is then sent  to the registering classfile .","Given that the embodiment of the plug-in pattern described above identifies methods through their corresponding character strings, the dispatch unit's registration method  would need a registering classfile  to identify its methods with these same character strings so that the correct correlation between a modified method and its proper plug-in treatment could be carried out. Here, the use of character strings is emphasized because some form of \u201cuser\u201d  (e.g., a test or development engineer or maintenance Information Science (IS) personal) ultimately determines which methods are to receive which treatment from which plug-in modules.","For example, in the case of Distributed Statistical Records (DSR), typically, only a subset of eligible methods are selected for modification (e.g., \u201cthe important ones\u201d). The intelligent selection of specific methods for modification ultimately boils down to their being listed by the plug-in pattern . Accordingly, since methods and classes are most often dealt with by a user at a source code level or higher (e.g., GUI) with character strings\u2014it is natural to expect that a \u201clist\u201d of methods to be treated as determined by a user would be listed in a character string format. Of course, in alternate embodiments, an initial list of character string names could be pre-formulated prior to registration so as to be represented purely in numeric form. This, in turn, may obviate registering with character strings.","5.3 Interfaces","Bytecode modification may be accomplished using a variety of different techniques and interfaces. As indicated in , in one embodiment, an application programming interface (\u201cAPI\u201d) of the bytecode modifier  is exposed, thereby providing direct access to end users. As indicated in and , the API may be published, thereby providing access the various classfiles of the API via a standard Web browser . Similarly, as illustrated in and , the API may be accessed and bytecode may be modified via a standard command line interface . The command line interface  is particularly suitable for batch files or environments in which running a graphical user interface (e.g., such as that described below) would be undesirable due to weak hardware, for example, or an operating system which is primarily console-oriented.","As illustrated in and , in one embodiment, extensions  are provided to the Apache Ant builder application . Apache Ant is a well known open-source build tool for compiling, packaging, copying, etc.\u2014in one word \u201cbuilding\u201d\u2014JAVA applications. The extensions  to the Ant builder application  allow the end user to generate modified bytecode as part of the build process. For example, an ant task may be particularly suitable for automatic build scripts in which it is used to modify one or more classes after compilation (e.g., within a J2EE engine).","In addition, in one embodiment, a wizard-based GUI is provided for simplifying the bytecode modification process. Referring to , the user is initially provided with a source data field  to identify a particular directory or file containing packages, classes or methods to be modified; and a output data field , to identify a destination directory or file for the results of the bytecode modification process. In one embodiment, a check box  is provided to allow the user to set the output directory or file to be the same as the source directory or file. In the particular example illustrated in , the user selects the \u201cutil\u201d package, identified by the *.jar file \u201ciq-lib.jar.\u201d",{"@attributes":{"id":"p-0183","num":"0186"},"figref":["FIG. 19","FIG. 19"],"i":["c ","d "],"b":["1920","1921","1923","1924","1922","1930"]},"Embodiments of the invention may include various steps as set forth above. The steps may be embodied in machine-executable instructions which cause a general-purpose or special-purpose processor to perform certain steps. Alternatively, these steps may be performed by specific hardware components that contain hardwired logic for performing the steps, or by any combination of programmed computer components and custom hardware components.","Elements of the present invention may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium may include, but is not limited to, tangible storage media such as hard-disk drives, flash memory, optical disks, CD-ROMs, DVD ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards. The machine-readable medium may also include propagation media or other type of machine-readable media suitable for storing electronic instructions. For example, the present invention may be downloaded as a computer program which may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).","Throughout the foregoing description, for the purposes of explanation, numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent, however, to one skilled in the art that the invention may be practiced without some of these specific details.","Accordingly, the scope and spirit of the invention should be judged in terms of the claims which follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained from the following detailed description in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","i":"b "},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","i":"c "},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1","i":"d "},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2","i":"a "},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","i":"b "},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 4","i":"a "},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4","i":"b "},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5","i":"a "},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 5","i":"b "},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6","i":"a "},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 6","i":"b "},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 9","i":"a "},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 9","i":["b","e "]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIGS. 10","i":["a","b "]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 11","i":["a","b "]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 15","i":"a "},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 15","i":"b "},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIGS. 19","i":["a","g "]}]},"DETDESC":[{},{}]}
