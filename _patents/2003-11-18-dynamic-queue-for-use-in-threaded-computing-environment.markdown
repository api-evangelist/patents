---
title: Dynamic queue for use in threaded computing environment
abstract: The present invention provides a dynamic queue for managing jobs in a threaded computing environment. Jobs may be placed in the queue, which may be maintained within a context of the computing environment, at a given priority level. The priority of jobs within the queue and the receipt time of each job is maintained. A job may also be placed within the queue with triggers that, if met, will result in the priority of the job being changed or will result in the job being removed from the queue entirely. Methods in accordance with the present invention also provide a method for raising an exception should multiple threads seek to access objects within a single context. Methods in accordance with the present invention also provide compatibility with prior computing systems and methodologies by providing for integration of prior static queues with dynamic queues in accordance with the present invention, and by providing methods for a given thread to be pinned to a particular context of a computing environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07823157&OS=07823157&RS=07823157
owner: Microsoft Corporation
number: 07823157
owner_city: Redmond
owner_country: US
publication_date: 20031118
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["None.","None.","The present invention relates to the field of computer software. More particularly, the present invention relates to the dynamic management of job queues within a context of a threaded computing environment.","Computing has become a ubiquitous part of every day life. Computing systems, such as personal computers, have become a fixture in both the home and office. As the capabilities of computing hardware has increased, and as the complexity of tasks performed on computers has increased, the demands upon the operating systems that manage operations in a computing environment have likewise increased.","A modern personal computer may typically be capable of operating multiple processes simultaneously, with each process performing jobs using one or more threads. The threads of a process perform the individual tasks of computing, which may be broken into specific jobs to be processed.","Each job to be processed may be placed in one of a plurality of queues to await processing, the jobs in a queue potentially, but not necessarily, being interrelated. Queues may be prioritized, so that jobs having a high priority will be processed before jobs having a lower priority. A queue of jobs to be performed may exist within a programming construct often referred to by those skilled in the art as a context. A context may contain a variety of objects, and may further contain a queue of jobs to be processed, and other information relevant to performing operations within that context. One context that may be familiar to many computer users is the user interface context. The user interface context is the context within which output is provided to a user, for example through a computer screen, and through which input is received, for example via a keyboard or mouse. Any number of other contexts may exist within a computing system beyond a user interface context.","To maintain the integrity of computer processing and computer data, care must be taken in the design of a computing system. This is particularly true in the design of an operating system that coordinates the allocation of computing resources. For example, an operating system may require that only one thread may manipulate an object or data at a given time. If multiple threads seek to access or manipulate the same object or the same data simultaneously, the result to the data and to the operations of a computing system are unpredictable, and can include data corruption.","Beyond assuring that only one thread may access a given object or data at a single time, a computer operating system should also seek to optimize the performance of a computing system. One way to optimize the performance of a computing system is to assign a priority to jobs when they are received into a queue within a context. The jobs may thereafter be performed by threads in priority order. In this scenario, a job remains in the queue at its assigned priority until the job is performed by a thread. While such a static queue model has served well in past computing systems and operating systems, a dynamic queue model may be beneficial given the increasing complexity of computing systems.","Even as new approaches to computing systems and operating systems are being developed to take advantage of new computing capabilities, it is useful to maintain what is referred to in the art as backward compatibility as much as possible. Backward compatibility refers to the ability of a computer system to operate prior generations of software applications in a newer operating system. While a number of approaches may be used to obtain backward compatibility, many of these approaches can increase the resources required to run the operating system and add to the complexity of the system, with corresponding increased opportunity for system failures and system crashes. Accordingly, it is often desirable to provide for backward compatibility in an elegant fashion that maintains the stability of the new operating system while still permitting older software applications to operate.","The present invention provides a dynamic queue that permits the priority assigned to jobs to be altered while a job is pending in the queue. The dynamic queue in accordance with the present invention may further maintain both a priority and a receipt time for each pending job, so that jobs having the same priority may be processed the order in which they where received. Various triggers may be provided to alter the priority assigned to a job pending in a queue or to abort the job and remove it from the queue entirely. Methods in accordance with the present invention may be used to require a thread to obtain exclusive access to a context before operating on an object in the context. An exception may be raised if a thread accessing an object has not obtained exclusive access to the context containing the object. Further methods in accordance with the present invention may allow information, such as settings and dictionaries, to be maintained by contexts and be temporarily assigned to a thread while a thread is operating within a context to allow backward compatibility. Further methods in accordance with the present invention providing for backward compatibility include the integration of a dynamic queue in accordance with the present invention with a static queue such that jobs may be performed in a logical fashion from both the dynamic queue and the static queue.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a computing device, such as computing device . In its most basic configuration, computing device  typically includes at least one processing unit  and memory . Depending on the exact configuration and type of computing device, memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. This most basic configuration is illustrated in  by dashed line . Additionally, device  may also have additional features\/functionality. For example, device  may also include additional storage (removable and\/or non-removable) including, but not limited to, magnetic or optical disks or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Memory , removable, removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tap, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .","Device  may also contain communication connection(s)  that allow the device to communicate with other devices. Communication connection(s)  is an example of communication media. Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media.","Device  may include a variety of computer readable media. Computer readable media can be any available media that can be accessed by a computer and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer. Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.","Device  may also have input device(s)  such as key board, mouse, pin, voice input device, touch input device, stylus, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. All these devices are well known in the art and need not be discussed at length here.","Referring now to , a hierarchical representation of computing operations  is illustrated. Computing process  may have one or more thread  operating under it. In the application domain  of the computing environment  there exists contexts, such as context  and the user interface context . Objects may exist within context  and user interface context . Objects within a context are accessed by threads to perform computing operations.","Referring now to , a computing environment  comprising a plurality of contexts is illustrated. A first context  may comprise a first tree  comprising a first object , a second object , and a third object . Context  may also contain a second tree  comprising a first object , a second object , and a third object . Context  may also comprise a context queue , a context dictionary , and context settings . Queue  may comprise a prioritized set of jobs to be performed within context  by threads. Dictionary  and settings  may comprise a single entity containing data associated with context . Dictionary  may comprise information from any source that may be useful for a thread performing jobs from queue . Data included in dictionary  need not be understood by the operating system. Settings  may comprise well known data, such as cultural information, with defined uses that may be useful in job processing performed by threads in context . Data in settings  may be accessed by application programming interfaces often referred to as APIs.","Computing environment  may further comprise a second context . Second context  may comprise a first tree  comprising a first object , a second object , and a third object . Context  may further comprise a second tree  comprising a first object , a second object , and a third object . Context  may further comprise a third tree  comprising a first object , a second object , and a third object . Context  may also comprise a context queue , a context dictionary , and context settings . Queue  may comprise a prioritized set of jobs to be performed within the context  by threads. Dictionary  and settings  may comprise a single entity containing data associated with context . Dictionary  may comprise information from any source that may be useful for a thread performing jobs from queue . Data included in dictionary  need not be understood by the operating system. Settings  may comprise well known data, such as cultural information, with defined uses that may be useful in job processing performed by threads in context . Data in settings  may be accessed by application programming interfaces often referred to as APIs.","Computing environment  may further comprise a third context . Third context  may comprise a tree  comprising a first object , a second object , and a third object . Context  may also comprise a context queue , a context dictionary , and context settings . Queue  may comprise a prioritized set of jobs to be performed within context  by threads. Dictionary  and settings  may comprise a single entity containing data associated with context . Dictionary  may comprise information from any source that may be useful for a thread performing jobs from queue . Data included in dictionary  need not be understood by the operating system. Settings  may comprise well known data, such as cultural information, with defined uses that may be useful in job processing performed by threads in context . Data in settings  may be accessed by application programming interfaces often referred to as APIs.","With further reference to , one skilled in the art will realize that a computing environment such as environment  may have more or fewer than the three contexts illustrated in . One skilled in the art will further realize that a tree may contain more or fewer than three objects, as is illustrated for convenience in . Further, the number of trees and objects within a context may vary beyond the ranges illustrated in , which are presented for exemplary purposes only.","Referring now to , the first context  of  is illustrated with a plurality of threads. The first context  may be the user interface context. A first thread  has entered context  to access object . An example of pseudo-code one skilled in the art could use to represent the process of obtaining access to context  containing object , wherein object  is referred to as object A, is:\n\n","One way to determine whether a thread may access a context is through the use of a context record, associated with each thread. Such a context record may be, for example, a data field associated with a thread. The context record may be updated when the thread with which the context record is associated is allowed to access a context, such that the most recent entry in the context record will indicate the context presently being accessed by the thread. When a thread accesses an object within a context, the thread's context record may be checked to verify that the most recent entry in the context matches the context containing the object and, if they do not match an exception may be raised.","Referring now to , a thread  is illustrated in greater detail. Thread  may include historical information  and thread settings . Historical information  and thread settings  may comprise data fields associated with thread . Thread settings  may contain information, such as cultural information, that may be useful to thread  in processing jobs. Thread settings  may include one or more dictionaries. Historical information  may contain information regarding the history of the threads operations, such as contexts accessed by thread , and may be used as a context record. While all information necessary for the operation of a thread, such as thread , may be in thread settings , methods in accordance with the present invention allow information useful to threads in processing jobs to be context specific, rather than thread specific.","Referring now to , thread  is shown accessing context . Context  may be the user interface context. While operating within context  the thread settings  may become the context settings  maintained within context . Context dictionary  maintained within context  may likewise be placed within thread settings  while thread  operates within context . Thread settings  may comprise a data field associated with thread . Thread settings  may be restored to their prior content when thread  departs context . The system and method of adapting thread settings  to include the settings  and dictionary  from context  allows settings and dictionary information to be specified at the context level, rather than on a thread by thread basis. The use of context settings  and context dictionary  as thread settings  further allows additional services, such as catching exceptions caused by thread  while executing within context , to be provided. Historical information  may be updated when a thread enters and\/or leaves context .","Referring now to , a queue  in accordance with the present invention, such as may be maintained within a context, is illustrated. Within the queue  illustrated in , several jobs are pending, and are designated with letters A through L. A job may comprise a process to be executed, a priority, and a receipt time. A job may further comprise a trigger defining an event which will require an action to be taken with the job within the queue if the event occurs and an action to be taken with the job if the event defined by the trigger occurs. Each job within the queue is placed at a given priority in  ranging, in this example, from priority one to priority eleven, although one skilled in the art will realize that other designations may be used. One skilled in the art will realize that any number of priority levels may be used, and that the eleven priority levels illustrated in  and  are for exemplary purposes only. One skilled in the art will further realize that the number of jobs pending in queue  illustrated in  and  is exemplary only, and will further realize that any number of jobs may pend in a queue such as queue . As is further illustrated, each job in the queue corresponds to a given time. As illustrated in  and , time progresses from left to right. Accordingly, each job in queue  has both a priority and a time corresponding to that job.","In , for example, job A arrived at the first time increment and was placed at priority level eleven, the lowest priority level in queue . For example, priority level eleven may be \u201cinactive\u201d meaning that the job is to be deferred until an event, referred to herein as a trigger, occurs that will result in the priority level of the job being changed.","In processing jobs from the queue, jobs are processed in priority order from the highest priority, priority one, to the lowest priority, priority eleven. Thus, in processing jobs from queue  illustrated in , jobs having priority one will be processed first, meaning that job C would be processed before the other jobs in queue . After a job has been processed, it is removed from queue . Accordingly, after processing job C, no jobs having priority one will remain. Processing will then move to the next priority level, priority two, and job K will be processed. Work on jobs in the queue will continue, with the highest priority job being processed and then removed from queue , until queue  is empty or computing processes terminate. When multiple jobs having the same priority are present in the queue, the job having the earliest time will be processed first.",{"@attributes":{"id":"p-0041","num":"0043"},"figref":["FIG. 8","FIG. 7","FIG. 8"],"b":["700","700","700","700","700"]},"One example of pseudo-code one skilled in the art could use to manipulate an item within queue  is:\n\n","Triggers that result in the removal or change in priority of a job in a queue such as queue  may take a variety of forms. For example, a trigger that may be used in accordance with the present invention is a timeout. A timeout may occur if a predetermined amount of time expires after a job has been placed in a queue. For example, when a job is placed in a queue it may be placed in the queue at a given priority with instructions as to how long a timer to associated and the action to take with a job if the timer expires without the job being completed.","In further reference to  and , job A may have been placed at priority eleven when a process operating in the computing environment determined that job A would, at a later time, need to be performed in the context corresponding to queue . Job A may have been placed in queue  at priority eleven with a timeout value of fifty milliseconds and instructions to promote job A to priority three after fifty milliseconds pass. In this way, job A would not be processed from queue  earlier than necessary, but, because jobs of equal priority are processed in receipt time order, job A would be processed before other priority three jobs in queue , effectively holding the place for job A in queue  without requiring processing resources to be expired on job A until necessary.","Other triggers may be, for example, the completion of other processing, the receipt of a notification from the operating system, or nearly any other event in the computing environment. For example, job I may have been placed in queue , as shown in , at priority eleven with instructions to promote job I to priority six when the process placing job I in queue  returned a given value. One skilled in the art will appreciate that a variety of other triggers may be defined, and that triggers such as timeouts and the return of processing values may be used in a variety of ways to effectively manage jobs within a queue, such as queue . One skilled in the art will also appreciate that jobs may be lowered in priority as well as increased in priority as result of a trigger.","As is further illustrated in  and , jobs may be aborted by removing them from a queue such as queue  entirely. This is illustrated, for example, with regard to job B. A variety of reasons may lead to a job being removed from queue . One example of the many circumstances wherein a job may be aborted from a queue is the rendering of computer animation to coincide with other output of a computing application. If the animation is not rendered to coincide with audio or other output there is no need to proceed with rendering the animation. Accordingly, a trigger may provide for the removal of such a job from queue  altogether.","One skilled in the art should note that, in accordance with the present invention, a thread may perform operations on a queue without being in the context containing the queue, meaning that the queue is thread safe. A thread outside of a context may post work to the context quickly, without having to wait to enter the context to post the work. Other queue operations, such as posting, aborting and changing the priority of job may likewise be performed by a thread without the thread entering the context containing the queue.","Queues in accordance with the present invention may be particularly useful with user interface messages. One skilled in the art will appreciate, however, that queues in accordance with the present invention may be used for purposes other than the queuing of user interface messages.","Referring now to , a computing environment  is illustrated wherein jobs are being processed from queues within contexts, the processing of jobs being managed by one or more dispatchers. A first dispatcher  manages processing in a first context  and a second context . First context  may contain any number of objects, a context dictionary , a context queue , and context settings . Second context  may contain any number of objects, a context dictionary , a context queue , and context settings . A second dispatcher  manages the processing of jobs in a third context . Third context  may contain any number of objects, a context dictionary , a context queue , and context settings . Within the computing environment , a variety of threads may be operating. Some of these threads, including a first thread , a second thread  and a third thread  are illustrated in . A dispatcher, such as the first dispatcher , may use a thread to process jobs within the context queue, such as queue . In this example, dispatcher  may use any thread to process a job from queue . However, in some computing applications, it may be useful or necessary to process all jobs from a queue within a context, such as queue  within context , using the same thread. As illustrated in , first dispatcher  has accessed  the third thread  to establish a pin  of the third thread  to the second context . The pin  will require that all jobs within queue  of the second context  be processed using thread . A pin such as pin  may last for various periods of time, for example until the application requiring the pin is concluded.","Referring now to , a method of integrating a dynamic queue in accordance with the present invention with a static queue to obtain backward compatibility while processing jobs from both the dynamic and the static queue in a logical fashion is illustrated. As illustrated in , the static queue  comprises five priority levels designated priority A, priority B, priority C, priority D, and priority E. The dynamic queue  is shown with priority levels ranging from priority one to priority eleven. One skilled in the art will appreciate that both the dynamic queue  and the static queue  may have varying numbers of priorities associated with them other than those illustrated in . While not necessary, dynamic queue  may be a dynamic queue that includes both a priority designation and a receipt time for jobs within the queue.","As illustrated in , in processing jobs from the dynamic queue  a dispatcher or other system periodically checks the static queue  to determine whether there exists any jobs to be performed at a given priority level. This check of the static queue  occurs prior to checking given priority levels in the dynamic queue . For example, as illustrated in , before checking for jobs in priority one of dynamic queue , a dispatcher checks  whether there are any jobs in priority A of the static queue . If there are no jobs in priority A, or if all jobs in priority A have been processed, the dispatcher returns  to priority one of dynamic queue . After processing all jobs at priority one of dynamic queue , jobs at priority two of dynamic queue  may be processed. In the example illustrated in , prior to checking to determine whether there are priority three jobs to be performed in dynamic queue , dispatcher checks  priority B jobs in the static queue . If there are no priority B jobs to be performed, or if all priority B jobs have been processed, dispatcher returns  to process any priority three jobs in the dynamic queue . After processing all jobs at priority three in the dynamic queue , priority four and then priority five jobs in the dynamic queue  may be processed in turn. As further illustrated in the example shown in , prior to checking for priority six jobs in dynamic queue  to dispatcher checks  for priority C jobs in the static queue . If there are no priority C jobs to process, or if all priority C jobs have been processed, dispatcher returns  to process any priority six jobs in dynamic queue . After processing all jobs at priority six of the dynamic queue , jobs at priority seven of the dynamic queue  may be processed. In the example illustrated in , before dispatcher checks for priority eight jobs in dynamic queue , dispatcher checks  for priority D jobs in static queue . If there are no priority D jobs to be performed, or if all priority D jobs have been processed, dispatcher returns  to check for priority eight jobs in dynamic queue . After processing all jobs at priority eight in the dynamic queue , jobs at priority nine of the dynamic queue  may be processed. As further illustrated in the example of , before checking for priority ten jobs in dynamic queue , dispatcher checks  for priority E jobs in static queue . If there are no priority E jobs to process, or if all priority E jobs have been processed, dispatcher returns  to check for priority ten jobs in dynamic queue . After processing all jobs at priority ten in the dynamic queue , jobs at priority eleven of the dynamic queue  may be processed. Of course, the correspondence between priority levels in the dynamic queue  and the static queue  may vary from the correspondence illustrated in . The correspondence between priority levels may be simplified by grouping the priority levels of the static queue  into a smaller number of groups, such as two groups, and defining a correspondence between the groups of priority levels of the static queue  and the priority levels of dynamic queue .","The method of integrating a dynamic queue  and a static queue  illustrated in  may be implemented using a variety of approaches. For example, messages corresponding to jobs in the dynamic queue  may be posted to the static queue  at two priorities, such as foreground and background or high and low. Messages may be posted using APIs such as PostItem and SetTimer. The dispatcher may then process the static queue , and when a posted message is dispatched from the static queue  the corresponding job may be dispatched from the dynamic queue . Another example of suitable approach for integrating a dynamic queue  and a static queue  is to control the processing of each using a dispatcher and to dispatch jobs in priority order using a predefined relationship between the priority levels of the static queue  and the dynamic queue , such as the relationship illustrated in .","In further reference to , one skilled in the art will appreciate that the correspondence of priorities in the dynamic queue  and the static queue  may vary. For example, a dispatcher need not check  for priority B jobs in the static queue  prior to beginning to process priority three jobs in the dynamic queue . Rather, the relationship between the priority levels of a static queue such as static queue  and a dynamic queue, such as dynamic queue  may be determined so as to best fit the needs of a computer application or an operating system.","One skilled in the art will appreciate that static queue  may comprise a Win32 message queue. If static queue  is a Win32 message queue, the retrieval of only the high-priority items in the Win32 message queue may be performed using the Win32 PeekMessage API by passing a predefined message as a parameter.","As can be seen, the present invention and its equivalents are well-adapted to providing an improved method and system for establishing a dynamic queue, integrating a dynamic queue and a static queue, changing the priority of pending jobs in a dynamic queue, aborting pending jobs in a dynamic queue, and managing the access of threads to a context. Many different arrangements of the various components depicted, as well as components not shown, are possible without departing from the spirit and scope of the present invention.","The present invention has been described in relation to particular embodiments, which are intended in all respects to be illustrative rather than restrictive. Alternative embodiments will become apparent to those skilled in the art that do not depart from its scope. Many alternative embodiments exist but are not included because of the nature of this invention. A skilled programmer may develop alternative means of implementing the aforementioned improvements without departing from the scope of the present invention.","It will be understood that certain features and subcombinations are of utility and may be employed without reference to other features and subcombinations and are contemplated within the scope of the claims. Not all steps listed in the various figures need be carried out in the specific order described. Not all steps of the aforementioned flow diagrams are necessary steps."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
