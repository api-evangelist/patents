---
title: System and method for processing graphics operations with graphics processing unit
abstract: Disclosed is a system and method for processing graphic operations on a plurality of data structures of an image with a graphics processing unit and memory. The disclosed techniques of the system and method create an accumulation buffer of the data structures for accumulating changes to the data structures. A separate buffer is then created from at least a portion of the data structures of the accumulation buffer. The disclosed techniques read the data structures from the separate buffer with the graphics processing unit. The graphics processing unit operates on the data structures read from the separate buffer with the operation. Then, the disclosed techniques write the results of the operation onto the portion of the accumulation buffer corresponding to the separate buffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08009176&OS=08009176&RS=08009176
owner: Apple Inc.
number: 08009176
owner_city: Cupertino
owner_country: US
publication_date: 20110405
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","A. Technology and Nomenclature","B. Core Imaging API from the Programmer Perspective","C. Core Imaging and the Core Imaging API","D. Basic Functions of a Core Imaging Embodiment","E. Optimizing","1. Caching of Intermediary Results","2. Graph Re-Writing to Reduce or Simplify the Graph","3. An Embodiment for Combining Two Nodes","4. Limiting Computation and Storage to the Domain of Definition","5. Limiting Computation and Storage to the Region of Interest","6. ROI and DOD Example Embodiments","7. Recursive Execution Embodiments","F. Simple Code Examples","G. Core Imaging Producing CPU and GPU Code","H. Emulation: Core Imaging Producing CPU Code","I. Compiling GPU Programs Directly to Machine Code","1. A Specific Example Embodiment","2. Slabs","3. Texture Look Ups","4. Setups","J. Multiple CPUs","K. Byte-Coded Virtual Machine","L. Emulating a Subset of Functionality","M. Sample Filter List"],"p":["This is a continuation of U.S. application Ser. No. 12\/689,485, filed Jan. 19, 2010 and entitled \u201cSystem and Method for Processing Graphics Operations with Graphics Processing Unit,\u201d which is a continuation of U.S. application Ser. No. 11\/696,674, now U.S. Pat. No. 7,667,709, filed Apr. 4, 2007 and entitled \u201cSystem and Method for Processing Graphics Operations with Graphics Processing Unit,\u201d which is a continuation of U.S. application Ser. No. 10\/866,360, now U.S. Pat. No. 7,248,265, filed Jun. 11, 2004 and entitled \u201cSystem and Method for Processing Graphics Operations with Graphics Processing Unit,\u201d which is a continuation-in-part of U.S. application Ser. No. 10\/826,762, filed Apr. 16, 2004 and entitled \u201cHigh-Level Program Interface For Graphics Operations,\u201d which are each incorporated by reference in their entirety and to which priority is claimed.","The following table shows a source code file that is provided as a computer program listing electronically in read only format, which is incorporated herein by reference in its entirety.",{"@attributes":{"id":"p-0004","num":"0003"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Computer Program Listing Appendix"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#","File","Size","Type","Last Modified"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["1","Filters","97 KB","Text File","11\/2\/2009 1:53 PM"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Over the past several years there have been increasing demands placed upon graphics subsystems in all variety of hardware. For example, in the general computing area, even traditionally mundane programs, like presentation software, are including animation and other tools that are requiring faster and more complex graphics computation. In addition, the traditional graphics-intense applications like video, photo editing and gaming are growing both in scope and graphics-intensity. Moreover, vertical systems such as gaming and graphics dedicated computing (e.g. Nintendo Gamecube etc.) have accelerated even faster driving competition with the general computing architecture for graphics supremacy.","During this same time period, hardware manufacturers have sought to meet and exceed the growing demand with dedicated graphics processors having ever-increasing capability. Right now, there are several commercially available graphics processing units (GPUs) that are programmable. While both programmable and non-programmable GPUs offer enhanced speed for graphics calculations, programmable GPUs differ in that they offer a high measure of flexibility. For example, prior to programmable GPUs, an application programmer might decide between using CPU time to render a more interesting graphic or using the GPU to increase overall application performance at the cost of displaying a less ideal graphic. Programmable GPUs have combined the speed advantage of prior GPUs with a significant measure of flexibility. In practical terms, programmability is an important advantage because it allows programs to use the graphics chip in ways similar to the system microprocessor. By using the GPU this way, the system can generate virtually infinite graphics effects without loading the system CPU.","Programmable GPUs run programs that are generally called fragment programs. The name \u201cfragment\u201d program derives from the fact that the unit of data being operated upon is generally a pixel\u2014i.e. a fragment of an image. The GPUs can run a fragment program on several pixels simultaneously to create a result, which is generally referred to by the name of the buffer in which it resides. GPUs use data input generally called textures, which is analogous to a collection of pixels.","Also, during the same time period that GPUs were contemplated and developed, there have been efforts under way to provide some programming interfaces for application programs desiring to use the graphics-dedicated hardware. One such effort is commonly known as OpenGL. The goal of OpenGL is to make graphic function accessible to the programmer independent of the hardware. In doing so, OpenGL operates like a state machine. In particular, a program using the OpenGL library must set states such as current color, lighting, blending etc. When the program is run, the resultant context will be a combination of the states and input textures, such combination depending upon what was programmed. Given the state machine type operation, the result of an operation isn't always readily predictable.","As computers migrate toward more visually rich content, image processing becomes more important. As a consequence, the programmer's ease of accessing these tools and the efficiency of graphics calculations continues to grow in importance. While the combination of OpenGL and programmable GPUs have provided wide advances to graphics programmability, there remains a need for a higher level interface to the graphics subsystem. This need is heightened for applications directly involved in image processing (e.g. PhotoShop, AfterEffects or similar software). In these applications and others, it is desirable to have an abstraction layer that hides the complexity of graphics hardware from those exploiting that infrastructure. Furthermore, operating systems may wish to facilitate an overall rich user graphics experience by presenting such an abstraction layer to all applications.","Such an interface should allow a programmer or program to simply apply a filter or effect to a given image. Implicit in the need for a higher level API is the need to implement that API in a way that is both fast and efficient. In order to be efficient, a system should have a mechanism to conceptualize graphics programming in a way that is easy to understand and easy to operate upon. Furthermore, such a system should minimize the use of memory and computation time, while also efficiently dividing work between the CPU and GPU. Finally, it is desirable to have a system that may be emulated on a single processor so that programs built for dual processor systems (GPU and CPU) can run on legacy systems having only a CPU.","In addition to filters or effects, graphics operations are also an inherent component of image editing. Graphics operations (or more specifically, cumulative graphics operations) commonly used in image editing include paint strokes, spotlights, warping, caustics, particle rendering, or ray tracing. For example, users may apply paint strokes to an image. In addition, users may use multiple light sources to produce stage-like presentations and add drama to an image they are editing. Image warping is also a useful cumulative graphics operation available to users and is one of the more popular operations that users apply to images. Current techniques for performing cumulative graphics operations implemented on CPUs may use more processing and memory space than desired. In addition, various cumulative graphics operations involve data in complicated data structures, such as high-intensity-definition color (light), vector offsets, and metaball field values. The data in these complicated data structures are more amenable to being calculated by the GPU. In short, the GPU can perform such cumulative graphics operations with substantially more processing speed and with sufficient accuracy. Therefore, a need exists for performing cumulative graphics operations with a GPU. However, GPUs cannot perform exclusive read\/modify\/write sequences on the same buffer, which hinders the GPU from processing such cumulative graphics operations.","The subject matter of the present disclosure is directed to overcoming, or at least reducing the effects of, one or more of the problems set forth above.","Among other advances, the invention seeks to solve the problems and meet the needs and desires described above. In doing so, some embodiments of the invention include a high-level program interface for graphics operations, or potentially other operations that may exploit a secondary processor resource. In a more specific embodiment of this type, a high-level program interface comprises graphics filtering functions that may be called by a user or program in the system. The program or user exploits the high-level program interface by creating effects or specifying filter functions from a pre-defined list. In alternative embodiments, the programmer or program may gain access to an extensible infrastructure to add filters to the pre-defined list.","In one general embodiment of the invention, software will exploit a selected processor in the system to compose a graph-like description of an image task. The graph-like description may be a node and link representation of an image, where nodes may represent operators and links may represent intermediary results and the storage necessary to hold those results. In greater particularity, nodes in the graph-like description may ultimately comprise threads or programs for computing a portion of the overall image operation on another processor. Furthermore, having a graph-like description of the overall image task allows use of an optimizing compiler to reduce the necessary resources for the overall image task. This compiling function is especially useful since the node programs will generally run on a processor other than that which runs the compiler. Involving software, embodiments of the present invention can include a computer-readable device having computer executable instructions for performing the techniques disclosed herein.","The forgoing general embodiment may be described in the context of a contemporary pairing of a single CPU with a single GPU. This embodiment proposes software running on the CPU for assessing the overall image task and constructing a graph-like description of same. This may be visually represented as a tree graph of nodes and links with associations as described above. Since the node-programs may execute on the GPU, the construction of the program accounts for properties of the GPU. Most notably, and in a general sense, programmable GPUs operate several parallel execution streams so the node-programs may be expressed in parallelizable languages. For example, node programs may be GPU fragment programs. After construction of the graph representing the overall image task, the graph may be optimized by virtue of a compiler running on the CPU. Alternatively, the graph may be optimized by a compiler in distinct pieces, as the graph is created. The purpose of optimizing is to minimize memory usage and CPU or GPU time or otherwise gain efficiency when the image is computed.","According to varying embodiments of the invention, optimization may have many functional characteristics. For example, optimization may include caching intermediary results, consolidating multiple fragment programs into one, limiting memory and computation to areas within a confined domain of definition and region of interest, or optimizing division of computation between processors.","Applying these techniques in the contemporary graphics context is highly efficient and allows developers to write filters by expressing the operations to be performed on an element (e.g. pixel) or elements without concern for the specific hardware in a system\u2014that will be accounted by the compiler. In addition, having created an API and efficient processing infrastructure for deployment in a multi-processor system, many embodiments also include functionality to exploit that the API on single processor systems. In a very general sense, this is accomplished by emulation.","1. Technology","The inventive embodiments described herein may have implication and use in all types of multi-processor computing systems and, in particular, where differing types of processors are exploited in a system. Most of the discussion herein focuses on a common computing configuration having a CPU resource and a GPU resource. The discussion is only for illustration and not intended to confine the application of the invention to other systems having either: no GPU, multiple CPUs and one GPU, multiple GPUs and one CPU or multiple GPUs and multiple CPUs. With that caveat, we shall provide information regarding a typical hardware and software operating environment.","Referring to , a common hardware computing configuration is shown. Very generally, a Microprocessor  is coupled to chipset support integrated circuits  and . The microprocessor may be any microprocessor or controller such as one of the Intel Pentium family or IBM\/Motorola PowerPC chips such as the 23, 24 or 25. The chipset ICs (expressed here as North Bridge  and South Bridge ) may be implemented in one or more ICs. The chipset ,  generally couples to the microprocessor through a bus  or by direct links, which are well known in the art at this time. If the chipset ,  is implemented in more than one IC, it is common for North Bridge functionality (AGP, memory management etc) to have a more direct connection to the processor by either connection to a common bus or the aforementioned links. A separate chip containing the South Bridge functionality is very commonly coupled to the microprocessor  through the North Bridge. However, we do not wish to preclude other configurations that exist now or may exist in the future. Some potential South Bridge functionality includes an ATA bus  for peripheral attachments such as disk drives; a PCI bus  for attachment of all manner of peripherals; a USB controller  for attachment of USB devices; a network interface controller  for supporting Ethernet or potentially other networks; and audio support . More relevantly, typical North Bridge functionality includes a memory controller to support main memory  and an accelerated graphics port  for support of a video subsystem. Memory is typically any of a variety of types of dynamic random access memory, but may also, in alternative configurations be static RAM, magnetic memory, optical memory or any other suitable storage medium that exists or may exist in the future. AGP  is a special port placed in the chipset so that the graphics subsystem has rapid access to the system resources such as the microprocessor and main memory. There are various emerging flavors of AGP and certainly other methods to accelerate the speed of interaction between core resources and the graphics subsystem. This discussion is not intended to limit use to any particular method for performing similar functions. Lastly,  shows alternative computing hardware configurations  and , which are intended for loose association with 24 and 25 microprocessors respectively.","As noted above, embodiments of the inventions disclosed herein include software. As such, we shall provide a description of common computing software architecture as expressed in layer diagrams of . Like our hardware examples, these are not intended to be exclusive in any way but rather illustrative. This is especially true for layer-type diagrams, which software developers tend to express in somewhat differing ways. In this case, we express layers starting with the O\/S kernel so we have omitted lower level software and firmware. Our notation is generally intended to imply that software elements shown in a layer use resources from the layers below and provide services to layers above. However, in practice, all components of a particular software element may not behave entirely in that manner.","With those caveats regarding software, referring to  (), layer  is the O\/S kernel, which provides core O\/S functions in a highly protected environment Above the O\/S kernel, there is layer  O\/S core services, which extend functional services to the layers above such as disk and communications access. Layer  is inserted here to show the general relative positioning of the OpenGL library and similar resources. Layer  is an amalgamation of functions typically expressed as two layers: applications frameworks and application services. For purposes of our discussion, both these layers provide high-level and often functional support for application programs with reside in the highest layer shown here . Item  is intended to show the relative positioning of \u201cCore Imaging,\u201d a software suite and moniker, which provides a vehicle for describing many embodiments of the current invention (when referring to a software suite that comprises some, any or all or the inventive embodiments, we will generally use the term \u201cCore Imaging\u201d).","Referring now to  (), item  represents the relative positioning of the Core Imaging suite. It is evident in the diagram  () that, by comparison to  (), a layer has been added  for another graphics function\u2014compositing. It is the compositor's job to perform window composition and management in a windowing system, like that which is discussed for many embodiments.","2. Trees and Graphs","In mathematics and other computational sciences, problems may be expressed in a parsed fashion, which lends itself to machine-performed computation and the programming of such machine. An example of parsed expression is a generalized tree structure such as that shown in . Referring to , tree structure  is comprised of: links, which represent the result of the nearest subservient node (, , , , , , , , , , ,  and ); and two types of nodes. There are leaf nodes that represent pre-existing computational input (e.g. operands), , , , , ,  and . Alternatively, there are functional nodes that represent computational functions (e.g. operators) , , , , , ,  and . As an overall example, referring to , link  serves as an input to functional node  and represents the result of leaf node  (the result of a leaf node, simply being the leaf).","Referring now to , another tree is shown using rectangular nodes rather than circles. However, the representative nature of the diagram is the same: leaf nodes  are analogous to operands; functional nodes , , and  represent operators, and the links , , ,  and  represent results.","At various places in this disclosure we use trees like those in , and we discuss those trees in the context of \u201cgraphs\u201d being used or assembled within a computer system. We generally do not intend to imply that the computer system is constructing or using the graphical tree that is pictured, but rather that the system makes, maintains or uses some representation of the graphical tree that we draw for human illustrative purposes.","Furthermore, we generally use the trees (or graphs) in the context of discussing graphics technology and software. From the perspective of an application program or programmer, an image that is defined by a tree or graph is usually indistinguishable from an image defined by an array of pixels. Both types of images define the same ultimate object and it is the object that the application program associates with the image. In some respects, the same is true regarding the perspective of Core Imaging (or other software embodying the inventions herein). Therefore, Core Imaging may evaluate an image calculation task by evaluating a graph. In that respect, the result of the root node of the graph is the ultimate result. Referring to , nodes  and  are the respective root nodes of the graphs.","In describing the embodiments of the invention and Core Imaging, we frequently reference these illustrative tools. Therefore, by way of introduction regarding many of the embodiments discussed herein, referring to , the following associations are generally appropriate in the context of our discussion: (i) the tree shown is generally referred to a low-level graph; (ii) functional nodes , , , , , ,  and  represent \u201ckernels\u201d or fragment programs that run on a microprocessor such as a GPU; (iii) leaf nodes , , , , ,  and  generally represent images, which is to say a collection of pixels or a representation of same; and (iv) links , , , , , , , , , , ,  and  represent results, although in the context of an operation that will actually occur, those results are usually associated with a buffer for storing same.","In addition, for introduction purposes regarding many of the embodiments discussed herein, referring to , the following associations are appropriate in the context of our discussion: (i) the tree shown is generally referred to as a high-level graph; leaf nodes  represent images; functional nodes , , and  represent high-level filters, which are typically pre-defined filters; and the links , , ,  and  represent results of the filter, but unlike the low-level graph, are not necessarily associated with buffers.","Many embodiments of the invention involve object oriented programming and make four types of objects available to a programmer. These object types are images; filters, context, and vectors. Each is discussed briefly and with an effort not to limit its generality.","Images are either the two dimensional result of rendering (a pixel image) or a representation of the same. In high-level program operations, we often maintain objects that represent images in that those objects require computation to become the actual pixel values. Differing embodiments of the invention may exploit either or both of pixel-value images and un-computed images as a definition of image. The specific meaning derives quite easily from the contextual use (having no relation to the \u201ccontext\u201d object). In a general sense, during discussions relating to filters, images should be interpreted as inputs to a function or filter.","Filters are high-level functions that are used to affect images. Filters may comprise one or more of the pre-defined filters listed at the end of this disclosure. Filters may be analogized to fragment programs, which similarly affect images (or more precisely, typically textures), however producing only one pixel at a time. In many of the inventive embodiments, Core Imaging compiles filter-based image manipulation so that such manipulation can occur on a GPU using fragment programs. There is not necessarily a one-to-one correspondence between filters and fragment programs.","Context is a space such as a defined place in memory in which the result of a filtering operation resides. If images are assumed to be inputs as suggested above, then context is assumed to be output.","A Vector is a collection of floating point numbers. For most embodiments discussed herein, Vectors are associated with four floating point numbers, each number having the same fixed number of bits\u2014commonly 32. In graphics, vectors may be employed to represent (i) the four dimensions required to describe pixel appearance (R (red); G (green); B (blue); and Alpha (transparency)); or (ii) the two or three dimensions required to describe two-space, three-space, or four-space (homogeneous) coordinates respectively: X, Y, Z, and W.","Core Imaging is a software suite comprising many routines and functioning as, among other things, a high-level programming language or API built for graphics functions but applicable to other functionality such as math alone (e.g. convolution operations). Recall, that we use the moniker Core Imaging to refer to any one embodiment or any group of embodiments and we do not intent to confine the invention to any particular comment regarding \u201cCore Imaging.\u201d Similarly, we may refer to a routine or process as or within Core Imaging and by that, we do not intend to imply this such software is implemented as a single unit or layer.","Core Imaging includes a high-level language or API for communicating with a graphics framework and graphics-focused applications services suite. This also includes a compiler for producing assembly from the high-level language. The language\/API is platform and hardware independent because the graphics framework and subservient software layers may account for platform or hardware differences. The API allows programmers to apply effects to images without concern for (1) the states and other parameters required by OpenGL or like interfaces, or (2) assembly language for the GPU or other resource performing graphics rendering.","When conceptualized as software, Core Imaging (or an embodiment of the API and associated compiler) may be viewed as a suite of graphics services routines positioned generally between application programs and the operating systems. Since layered software conceptualizations are subject to varying interpretations, this discussion is not intended to be exclusive of other ways to conceptualize the layered position of Core Imaging (or any graphics services software suite according to an embodiment of the invention). With that caveat, referring to ) and (), graphics services software suites  and  are respectively shown.","The positioning of these graphic services  and  implies that these suites may include components for application frameworks, application services and graphics resources. In short, the intention in this positioning is to imply that Core Imaging  and  may interact with: Applications in layers  and ; other frameworks or services in layers  and ; resources such as OpenGL in layers  and ; the compositor in layer ; and O\/S services in layers  and .","In a general sense, as applied to graphics, Core Imaging allows programmers and programs to implement an effect by either (1) using a pre-defined high-level filter or (2) by assembling a series of pre-defined filters using the API or one or more other embodiments of this invention. In the latter case, the programmer or program makes API calls to Core Imaging for high-level descriptions of zero or more of the pre-defined filters. The program or programmer places those high-level descriptions (or reference thereto) in a data structure that we shall call a high-level graph. The high-level graph is assembled by the programmer or program creating a new filter. The high-level graph defines relationships between the pre-defined filters and images being employed in the new filter. When the programmer or program has completed building its high-level graph, it has effectively completed its tasks for creating the new filter. That is to say that all the information necessary to create the new filter is embodied in the high-level graph.","In an alternative embodiment, as a programmer or program assembles a graph in cooperation with Core Imaging, the graph created may be a low-level graph or substantially a low-level graph. For example, from the perspective of the program or programmer, a request may be made for a high-level filter, however, Core imaging may create and deliver an object that is a low-level filter or some interim step between a low-level filter and a high-level filter. Since the program or programmer does not actually inspect the object, Core Imaging can respond to requests for high-level code with low-level code. In this manner, Core Imaging may assemble a low-level graph while a program believes to be working with high-level filters and objects.","Core Imaging has the additional tasks of ultimately optimizing and compiling the high-level graph (along with any applicable input parameters) to yield a GPU-ready program. The compiling step may be performed just in time for use of the ultimate image. In summary, the programmer or program has used high-level language of the API (including pre-defined filters) to create and effect, which is essentially a new filter comprised of various other filters and inputs. The programmer or programmer may also programmatically apply this filter to an image. Various embodiments of the invention contemplate various divisions of work between the GPU and CPU. Generally, the CPU will run Core Imaging and the GPU will run the ultimate product of Core Imaging. However, depending upon hardware abilities and ultimate optimizations, Core Imagine may create tasks for the CPU and GPU. Furthermore, if there is no programmable GPU in the system, Core Imaging may create an object for the CPU to render the image to context.","Looking now more fully at the capabilities of Core Imaging, in one embodiment, the API provides six high-level functions for the programmer and ultimately a user of an application program: creation of a context; creation of an image; creation of a filter; the ability to set parameters associated with filters (e.g. the arguments of a filter function); the ability to ask for the output of a filter or group of filters that has been assembled; and the ability to render an image to a context.","1. Creating a Context.","We refer generally to an output as a context, so the ability to create a context is derived from tools that allow definition of an object in memory. The definition of such an object is necessary so that there may be a destination for the results of an operation. For example, a context can be associated with a bitmap in main memory or with an OpenGL view. These associated image containers are used as a destination for rendering. While the invention primarily contemplates memory such as video memory associated with a system's graphics functions, the concepts discussed here apply equally to any memory or storage found elsewhere in the system or accessible to the system. Therefore, without limitation, memory may include all types of solid state memory such as dynamic memory or static memory whether specifically associated with the graphics subsystem, shared with the graphics subsystem or nominally dedicated to the main system or another subsystem accessible by the main system. Furthermore, while speed is certainly an issue, the concepts herein do not intend to exclude magnetic or optical memory.","As example of creating a context, we can assume that an application program wishes to ultimately display something to screen. Assume Apple's iPhoto application desires to display an image of the sea shore in response to a user command. iPhoto may exploit the Core Imaging API by calling a function to request creation of a context. Core Imaging will return, among other possible things, a handle of identification of the created context. Let's assume that handle is \u201cempty context.\u201d","2. Creating an Image.","We refer generally to an input as an image, because coordinates or pixels in an image may be sampled to yield relevant values. Using an embodiment of the inventive API, images may be created from nothing or from another image. An image is created from nothing by providing a mechanism for creating pixel values. For example, an image may be created from nothing by simply defining the image as a color or a mathematical combination of colors (like a checkerboard or striped page). An image, more commonly, may be created from another image by applying one or more filters to the existing image.","Following our iPhoto example from above, iPhoto may create an image by asking graphic services to take an existing image of children on a sea shore and apply a filter (e.g. a blur) to some area outside of the children. Upon application of this filter, a new image is created. For clarity, this is an un-computed image in that new pixel values have not been calculated, but rather, the blur filter has been programmatically applied and resides or is referenced in the image buffer where all the other elements necessary to calculate the pixels are either stored or referenced.","3. Create a Filter.","We refer generally to a filter as any function that may be performed on zero or more images (ultimately a pixel). In slightly more particularity, a filter may be a function that accepts images and other parameters (associated with and dependent upon the particular filter) as inputs and yields a new image. The API currently provides several dozen filters that are listed and described elsewhere in this disclosure. However, an embodiment of the invention calls for an extensible nature so the inventors continue to develop filters and have provided an ability of others to develop filters as well. While the invention contemplates extensibility that allows for addition of pre-defined type filters, our discussion will focus on new filters created by the combination and manipulation of zero or more pre-defined filters.","One manner contemplated for the creation of a filter is for a programmer or program to begin by using an embodiment of the inventive API to tie together one or more of the API's pre-defined filters and any other items or functions that the programmer wishes to apply. As mentioned earlier, to create a new filter, the program or programmer may create a high-level graph comprising representations of all images and pre-defined filters that will be used and the relationship between those objects. In some embodiments, the pre-defined filters are intended to be as comprehensive as possible of rudimentary graphics functions, so as to minimize the need or incentive for the programmer or program to write assembly for the GPU. Indeed, an overall benefit of Core Imaging is the ability to program at the application layer without reference to the specific graphics hardware.","Once a new filter is defined with a high-level graph, an application program or user (at the CPU level) may call Core Imaging to implement the high-level graph (effect the filters referenced in the graph on the images referenced in the graph in a manner defined by the graph). Of course, the high-level graph may have been written to incorporate more than one image, but the technique is the same. When implementing the filter, Core Imaging may require other input data because filters commonly have filter-specific inputs such as a blur radius for blurs, geometric parameters or any other inputs like those specified in the filter definitions listed later.","An important function of Core Imaging is to then return one or more objects to the application program or user. According to varying embodiments of the invention the returned objects may be rendered or ready for computation on the GPU, the CPU or some combination of those two. In one alternative embodiment, Core Imaging builds all or part of the low-level graph while responding to application program requests for high-level elements. In this embodiment, the application program believes it is asking for higher level code, while core imaging is delivering lower-level code (the application program cannot detect the difference because it does not analyze the objects delivered by Core Imaging). Alternatively, in a preferred embodiment, the returned objects may be an optimized low-level graph ready for just-in-time compilation, when the application requires the image in a context. In some embodiments, Core Imaging will return only one object, which is to be compiled just-in-time and run on the GPU. In order to do so, Core Imaging must convert (and generally optimize) the high-level graph and convert the image(s) to a texture(s) (GPUs use textures, not images for computation). In converting an image to a texture, the Core Imaging uses the CPU to first convert the image to a sampler. A sampler is an image plus its state, so converting to a sampler comprises the steps of incorporating state information such as the following: (1) wrap mode such as transparent, clamp or replicate; (ii) interpolation mode such as using values from the nearest whole pixel to the subject pixel, or interpolating across a grid of four pixels surrounding the subject pixel; and (iii) affine transform such as rotate, scale, skew, translate, mirror. The sampler may then easily be converted to a texture for use by the GPU. With all this as input, the CPU, running Core Imaging, creates an object comprising a GPU program that, when executed, will implement the filter on actual pixels (provided by the textures created above).","Referring now to , we shall proceed through a general example of filter creation. Recalling back to our iPhoto sea shore example, a user may ask iPhoto to auto-enhance a photo. Assume, purely for illustration purposes that the auto enhance requires the following filter creation. This is purely for illustration in that the current iPhoto enhance feature would actually not operate in this way. iPhoto will first create its desired filter. This process might start by calling Core Imaging to allocate the base image , which at this point may be in graph or pixel form. We see this in step one of  and the high-level graph tree diagram. Next iPhoto calls Core Imaging to add a program step (and corresponding tree position) to apply color correction filter  to the image . We see this in  step  and the high-level graph tree diagram. Note that the output of step  in  is defined as Placeholder CC (for color corrected) sea shore. Since, at this point, it is uncertain when and if this intermediary result (CC sea shore) will ever exist, we do not allocate a buffer but rather place a placeholder in the high-level graph indicating the possibility of an intermediary result. In furtherance of the auto-enhance feature, iPhoto might further apply a false color filter  to the result of the  filtering. As before, iPhoto will call Core Imaging to get the high-level false color filter and insert same in the mounting high-level graph (and tree in  for illustration purposes). Next, in order to round out the auto enhance function, iPhoto might choose to average the result of the  filtering (FC CC sea shore) with the original sea shore image (), so an appropriate filter  would be called from Core Imaging and inserted in high-level graph. This is seen both in the tree graph of  and the sample program steps.","In our example, iPhoto now has a high-level graph for its desired result of an auto enhance sea shore image. In order to make that result usable in accordance with the embodiment of this example, iPhoto may sequentially call routines in Core Imaging (or Core Imaging may act alone) to convert, optimize or compile the high-level program as described above. For illustrative purposes, a result expressed in a simple form (analogous to ) is displayed in . We see in  that the fragment programs (,  and ) need not analogize well to the high-level pre-defined filters that comprise the high-level tree for auto enhance shown in . Each high-level filter may comprise one or more fragment programs to effect its purpose. Furthermore, when the program is optimized, it is possible for fragment programs to be replaced, re-ordered or eliminated. Lastly we see that the GPU implementation shown in  begins with a texture rather than an image, and ends by placing the result in a physical place (a buffer\u2014no more place holders).","4. Set Values for a Filter.","As referenced earlier, each high-level filter, whether created as above or pre-defined as in the list herein, may have a set of input values that are necessary and defined by the filter function. In our sea shore example, we showed these input parameters as a vector \u201cparameters (X,Y,Z,W) to represent generic inputs (see ). Another and less generic example would be a blur filter, which would nearly certainly require the radius of a blur as an input parameter. Yet other examples are input color, input intensity, input saturation etc. (see list of filters for more examples in context). The API for Core Imaging necessarily provides programmers and programs the ability to set these input parameters, which allows the predictable creation or editing of an image","Referring to our iPhoto seashore example, we were performing a blur on an area of our photo. While precise input parameters would depend upon the specific blur filter, iPhoto would most likely need to supply a radius of blur.","5. Ask for Output of a Filter.","In one embodiment, once a graph exists for a particular filter, a program or programmer may call Core Imaging for the output of that filter. In response, Core Imaging will create an object ready for just-in-time compilation and then execution typically just on the GPU. This output of the high-level filter is simply an un-calculated or representative image. In alternative embodiments, Core Imaging may either optimize the graph or calculate the image at this point. The prior embodiment is often preferred because, optimization requires processing cycles and calculation will use processing cycles and memory. These resources are usually better to preserve until we are certain that the image must be rendered to context.","Referring to our iPhoto example in the typically more preferred embodiment (saving memory and processor time), iPhoto would call Core Imaging to produce the un-calculated image, ready for just-in-time compilation and execution.","a. A Caveat to Creating the Filter Output.","Like many graphic processing engines, Core Imaging may likely be built to operate in only one color space, for example \u201clight linear.\u201d Therefore, in order to process a graph, some embodiments must convert the color space to light linear, and before returning a result, must convert the color space back to its original color. In some embodiments, this conversion is effected on a high-level graph by placing appropriate color conversion high-level filter at the input(s) and output of the high-level graph. In other embodiments, this occurs on a low-level graph, but in a very similar fashion. In the case of the low-level graph a \u201ckernel\u201d or fragment program node for color conversion is placed on the input(s) and output of the graph. On most embodiments where nodes are placed into the graphs (high or low-level), the situation dictates that the result of that color conversion node is very likely to be helpful in the future. Therefore, the results of color conversion nodes should be cached in most embodiments. An alternative to creating graph nodes for color conversion is to program such conversion into one of the Core Imaging routines.","6. Render an Image to Context.","Ultimately, most images are created for visual use, such as display. Therefore, an extremely common step in this embodiment of image creation is to call for the rendering of the image into some defined context. For most embodiments, Core Imaging will perform optimization of the graph at this point. In short, optimization may involve any or all of the following: (1) producing a low-level graph, where for conceptualization purposes, nodes of the graph represent fragment programs and the low-level graph defines the relationship between images and fragment programs (this is contrasted to high-level graph that comprises images and high-level filters and their inter-relationship); (2) optimizing for domain of definition; (3) optimizing for region of interest; (4) combining fragment programs to reduce the size of the graph and ultimately the memory space that its execution will require: and (5) comparing the execution requirements of the optimized low-level graph with the resident hardware (GPU, CPU, memory etc.). Once optimized, the low-level graph is compiled and one or more executable objects are produced. As we have discussed, typically there is one executable object for the GPU, however, during optimization or compiling, it may be determined that multiple processors should be employed. After compiling the resulting objects are executed and the image is rendered to the specified context","Referring again to our iPhoto example, in order to put the image on the screen, iPhoto will call Core Imaging to render the object to the screen. In a typical embodiment, this step involves the GPU code running on all the relevant pixels in the image and producing the enhanced photo image. The image may be placed on the screen by placing it in a buffer that is associated with the screen display.","Optimization is the process of analyzing and changing a program or task so that when the task is actually performed, it is performed most efficiently or easily. In the context of most embodiments discussed herein, we seek to use one microprocessor to optimize program code for another microprocessor. In yet more specific embodiments, we seek to use a system CPU resource to optimize a program to be run on the GPU. In even more specific embodiments, the CPU analyzed a graphics task (typically the application of an effect to an image) expressed as a graph, and optimizes the graph, so that when the graph is just-in-time compiled, it runs most efficiently on the GPU.","We have discussed optimization and compilation in both general and specific contexts. Without limiting the scope of the prior disclosure, we will now discuss embodiments of core imaging involving any one of four different general techniques for optimizing. Those four general techniques are: caching of intermediary results; limiting computation and storage to the domain of definition; limiting computation and storage to the region of interest; and graph re-writing to reduce or simplify the graph.","Since optimization deals with savings in real-world items like CPU cycles, GPU cycles and memory space, we will usually discuss the optimization techniques with reference to the lowest level (closest to hardware) conceptual illustration tool that we have introduced. That tool is the low-level graph. However, these techniques should not be viewed as limited to a single level of conceptualization. Indeed, these techniques may apply and realize efficiencies at higher levels and lower levels of illustrative abstraction (e.g. on higher-level graphs or on compiled code).","The disclosed optimization techniques may be useful when employed in various orders and even hybrids of order where sequential techniques are recursively applied to one node at a time or sections of a graph. However, in order to be most clearly illustrative, we introduce the techniques in a logical sequential order as shown in . Referring now to , Core imaging receives a graphics task from an application program at step . To the extent that the task is not already embodied in a low-level graph, in step , Core Imaging must create a low-level graph. Next, in step , Core Imaging performs node reduction analysis and eliminates nodes where possible. After unnecessary (or collapsible) nodes are optimized, Core Imaging moves to step  where optimization is performed to ultimately limit the size of buffers and image inputs. This step involves intersecting two regions called domain of definition (\u201cDOD\u201d) and region of interest (\u201cROI\u2019). After the ROI\/DOD optimization, the graph is ready to compile in step . Finally, all this prior work having been run on the CPU, the program is sent to the GPU for rendering (as we have discussed throughout, some embodiments may compile and send portions of a graph to the CPU as well).","In discussing aforementioned optimization techniques, there may be use in a deeper understanding of embodiments of the nodes in a graph. We shall illustrate with respect to nodes in the low-level graph, but the concepts apply to any similar representation. Thus far, we have discussed nodes as functions, filters and fragment programs. However, in order to effect analysis on a graph, we require a node representation with more specific and richer information. Therefore, in varying embodiments of the invention, based upon desirability or necessity, low-level graph nodes have the following associated information: (i) a program like the fragment programs that have been discussed; (ii) arguments for the program, that may comprise, samplers (images with states), and one or more vectors (recall a vector is a collection of floating point numbers); (iii) domain of definition for the output of the node; and (iv) an ROI function that provides an accurate prediction of the input shape for the node, given an output shape (both shapes defined in a coordinate system, perhaps the same global coordinate system).","For reasons inherent to contemporary computing, application programs will frequently request calculation of identical or similar images time after time. Application programs also often request calculation of images that are subsets or supersets of previously calculated images. For this reason, Core Imaging exploits caching techniques to prevent unnecessary work. In most embodiments, graph nodes form our basis for cache management. In particular, recall that we have discussed high-level graphs such as that which is represented by the tree in . We have also mentioned low-level graphs which can be conceptualized as the trees shown in  and . For some embodiments, we assume that each node in a graph is immutable and defined by the portion of the graph below it (i.e. the objects and calculations required to resolve a node). Having made that assumption, we can cache the result of a node (typically an image) and then determine if the same node (defined as the sum of the graph below it) is in queue to be re-calculated. Rather than recalculate the node, we can simply fetch the result from memory. According to varying embodiments, this may be done for all nodes. In order to use memory efficiently, we may elect to delete caches at differing times (e.g. when memory usage is high, or when cached entries are old, or when associated application programs are closed, or when system is shut down). In addition, for efficient use of memory, we may use alternative storage. In most embodiments, we primarily use static or dynamic memory allocated to the video subsystem or the GPU. However, we can choose to place these caches in any accessible storage, such as system memory, hard drives or other magnetic memory in the system or even possibly network accessible storage.","In varying embodiments, caching may be exploited during optimization (e.g. on the CPU), during rendering (e.g. on the GPU) or at both times.","Another efficiency technique exploited in some embodiments of the invention is to optimize the graph by eliminating unnecessary nodes. When successful, this can be profound in its savings because it will generally eliminate an entire temporary image and the corresponding need for a buffer. In addition, consolidating or eliminating a node will save processing cycles during execution.","In order to consolidate, Core Imaging must find adjacent pairs of nodes that may be reduced. Generally, two nodes may be reduced into one if the output of the one node is the input of the second node. For example, if the output of node Alpha is defined as Alpha Buffer and the input of Node Beta is a texture stored in Alpha Buffer, then the two nodes may be combined.","In terms of computational cycles, it may be a relatively expensive analysis to determine if two nodes may be combined. Therefore, when a determination is made regarding whether two nodes may be combined, that determination may be cached. To be clear, some embodiments cache both a negative and positive result so the program may use the cache not only to find a cached combination, but to determine if a combination is not possible so that time is not wasted performing the analysis. An example embodiment is shown in . In performing a combine inquiry , the first step  is to determine if a result of an analysis on these nodes has been done before and is resident in the cache. Therefore, at step  the system checks cache for a pre-analyzed combine result. In addition, since the routine we are discussing typically runs on the CPU, this cache will use system memory in many embodiments. Lastly, as an example of how the cache may be tagged, in one embodiment, the cache key has four pieces of data: (1 & 2) representation of the two node programs, (3) a representation of the texture unit index in the superior node program, which will receive the output from the subservient node program; and (4) a representation of a Boolean value specifying whether the output values should be clamped to the range 0,1.","Returning to step , there are three possible paths at this decision step. First, the results may be cached and the nodes may be combined. In this event, control passes to step  and the combine is performed using the cached result. Control would then pass to step  to find and analyze to the next node. Second, the results may be cached but the nodes may not be combined. In this case, control goes directly to next node step . Third, finally, the results may not be in the cache. In this case control passes to step  to determine if a combination of the proposed nodes is possible. As indicated by step , whether or not the combination is possible, the result is cached (indicating either combination is not possible or combination is possible and storing the result). At step , if combination is possible, it is performed in step , although in practice some embodiments will perform combination during analysis. After combination is performed control passes to  for the next node. Finally if step  determines that combination is not possible, then control passes to step  for the next node.","Referring to  and , assume that Core Imaging will analyze whether nodes  and  may be combined. Beginning at step , in most embodiments, Core Imaging will attempt to combine these nodes if the output of node  is the close enough in nature to the input of node . In many embodiments, the output of node  must be the same as the input of node  in that the output buffer must be the place in which the input texture resides. However, in other embodiments, Core Imaging may evaluate whether such output and input are sufficiently similar to yield a correct result, or in yet other embodiments, a close-to-correct result.","Returning to decision , if the respective output and input are not sufficiently similar, then the nodes may not be combined as indicated in step . However, if the respective output and input are sufficiently similar, then control moves to step  to check each line of the fragment program associated with the second node (in this example, node ). We will discuss line checking later but, for this level of process, we assume that each line is checked to see that it does not negate the possibility of combining nodes  and . In addition, minor changes are made in certain lines to facilitate combination. Therefore, if the line check at step  results in negating a node combination, then the nodes  and  will not be combined as indicated in stem . Alternatively, if the line check at step  indicates a continued possibility for a node combination, then control moves to decision step  where it is determined whether the hardware can handle the combined nodes. In a general sense, this may refer to any hardware limitation in the system, such as memory, the nature of any microprocessor or the system status. In a more particular sense, most embodiments need only check the capabilities of the resident GPU to see if the are too many look-ups or registers required. Clearly, (unless emulation is used) if step  determines that the resident hardware can not process a combination of nodes  and , then the combination can not be made as indicated in step . Alternatively, if step  determines that the hardware can handle the combined nodes then control passes to step  where a series of tasks begins to finalize the combination of the nodes.","In step  the program code for the nodes is actually concatenated. In step , a standard pre-compiler optimizer program is applied. This is not the optimization that is the subject of some embodiments to this invention. Rather, this is a readily available pre-compile optimization routine. Next, in step , instructions are applied to allocate registers. Finally, in step  the results are cached for future combination analysis.","In discussing this example, there has been only minor attention paid to step , which is the checking of each line in the second program. Referring now to , we shall explore that process in greater detail. At step , Core Imaging seeks the next program line for analysis. The next line may be the first line of the program representing the second node . Control moves to decision step  where Core Imaging determines if there are local variables in the program line. If there are such local variables, then control moves to step  because such local variables must be renamed so they do not conflict with the local variable in the first program (that program representing node  in this example). In some embodiments, all local variables are numbered with sequential integers starting from zero in each fragment program. Therefore, in renaming local variables in the second fragment program (that representing node ), (1) the first new name is derived by simply adding to the highest numbered local variable in the first program; and (2) subsequent local variables are named sequentially using the first re-named local variable as a base name.","Once the local variables in a program line are renamed, control moves to decision step  where Core Imaging looks for texture references in the program line. It is noteworthy that, decision step  also leads to step  if there were no local variables requiring renaming. In either case the, at decision step , Core Imaging looks for any texture references in the program line. If no texture reference is found, then control moves to decision step . If a texture reference is found, control moves to step  to see if the found texture reference is a product of the first node's ('s) processing. If the found texture reference is not a product of the first node's processing, then control moves to step , to rename the texture if necessary.","Assuming that the found texture is a product of the first node's processing, then control passes from step  to step  to replace that texture with a single pixel. In a general sense, we replace a texture with a single pixel because, while fragment programs have whole textures for inputs and whole buffers for outputs, the fragment programs process only one pixel at a time. Therefore, if Core Imaging will combine or concatenate two fragment programs, those programs must be re-written to pass the same pixel through the entire extended length of the combined programs\u2014there can not be an intermediate buffer created by a single (combined or otherwise) fragment program. As a consequence, in some embodiments, step  involves eliminating any reference to the subject input texture and replacing it with a register reference that will hold the pixel under operation. After step  is complete, control passes to step  to rename the texture if necessary.","Texture renaming is the same principle and process as local variable renaming so no further comment is needed on substance. After texture renaming occurs, control move to decision step .","At decision step , Core Imaging checks for any reference to a pixel in the input texture that is identified by a register. To elaborate on this step, assume that the input texture to the second node () was texture Alpha. Assume also, that texture Alpha has been written out of the program in favor of a pixel in register Beta. At step , Core Imaging is looking for any reference to a pixel of texture Alpha, other than the pixel stored in register beta. This is because, the combination of two fragment programs will eliminate the creation of texture Alpha (an intermediary image), and, at runtime, the system's only reference to texture Alpha will be the single pixel in register beta. Therefore, if the program underlying the second node () has substantive reference to pixel other than the pixel in register beta, then the combination can not happen and must abort as shown in step . If there is no reference to such a pixel, then program control moves to step , to move to the next line.","In reviewing the program steps described here, it should be noted that there are many ways to process lines of code with the functions and changes described. For example, the program may look at one item at a time in each line and process through all options for a particular item before moving to the next item in the same line until a single line is finished. For another example, the program may read a first item and: check if it's a local variable and if so rename it; check if it's a texture reference and if so, check if the reference is to the output of the first program and so on. The point is that given the disclosed technique, a skilled programmer can decide how to proceed through the analysis and line checking.","In a general sense, images are not bounded by anything other than the coordinate system in which they exist. For most coordinate systems, this \u201cboundary\u201d does not apply useful limitation. Therefore, when considering an image, we may consider it's domain of definition. The domain of definition of an image is a representation of all places in which the image is defined (thus the name \u201cdomain of definition\u201d). A practical way to think about domain of definition is as a representation of all places in an image that are explicitly defined and not transparent. One example of a domain of definition is the geometric shape in which all non-transparent pixels lie.","In developing optimization techniques, the domain of definition (\u201cDOD\u201d) is interesting because there is no need to compute or draw pixels outside the DOD. Therefore, in optimizing a graph, there is use in first calculating the DOD of the root node (the very highest node, for example node  of ). Once you have the DOD of the root node, you may intersect that shape with the substantive result of the node and eliminate from the rendering and drawing task all portions of the substantive result that reside outside of the DOD. Unfortunately, the DOD of a node is not always available, and when such is the case, the DOD must be considered infinite.","In a general sense, the DOD of the root node is calculated by propagating from the bottom of the graph upward. Referring to , we calculate the DOD of root node  by starting with the leaf nodes , , , ,  and . Since leaf nodes represent images that have been already defined, they may have a DOD without reference to a lower node (as a practical matter, a leaf node is usually a read command in the graph). The DOD of the higher level nodes is calculated using the inputs to the node and the function the node performs. In practice of some embodiments, each node type in a system has a function call to determine its DOD in view of its possible inputs (this is one way of viewing the earlier statement that a node may include its output DOD). In alternative embodiments, the optimizing program calculates the DOD itself, during optimization. In yet another embodiment, the DOD for some nodes is calculated directly during optimization and other nodes are calculated indirectly by calling a function. For example, one embodiment may directly calculate DOD for easy nodes (those where the input and output shapes are the same) and make function calls for difficult nodes (those where the input to output shape changes). For illustration, we shall very briefly review calculation of DODs.","This calculation of DODs varies slightly depending upon the type of node being analyzed. For example, if the function of node  is simply a color conversion, then the DOD of node  will be the same as DOD of leaf node . This same example applies to all operations that do not change the shape of the input image DOD (i.e. range alterations, color space conversions and image tints). However, some nodes may be more complex to calculate because they either have multiple inputs or because the function changes the shape of the input node's DOD (e.g. a geometric change). Looking at the multiple node issue first, assume we wish to calculate the DOD for node , already having the DODs for nodes ,  and . The DOD for node  is a simple function of the input nodes' DODs and is commonly either the union or the intersection of the input nodes' DODs. Whether the result DOD is the intersection, union, or some slightly more complex function is dependent on the function of the node and is easy for any programmer to assess.","In calculating DODs, Changes in image shape caused by the function demand more consideration. These types of functions include, without limitation, items like blurs where the image changes shape due to the pure operation of the function (like a blur or a scale operation\u2014typically a blur will make an image bigger). Alternatively, the function may simply re-orient the image (rotate, offset etc.), which operation may change the location in the coordinate system. In either case, most embodiments will require a function to call the DOD for an output based upon any possible inputs. Any skilled programmer can write such functions.","Finally, recall that some nodes will not have defined DOD. In those cases, most embodiments will assign infinite as the value of the DOD.","Having the DOD for nodes, we can now determine the region of interest (\u201cROI\u201d) for associated nodes. In summary, the region of interest is the portion of the input image that is necessary to compute the given output DOD. Therefore, while each node has a DOD on its output, it has an ROI for EACH input (in viewing a graph, you can conceptualize this as an ROI for every link). As an example of an ROI, assume a node function that is a blur, with an input image that is \u201cLarge Rectangle\u201d and an output DOD that is \u201cSmall Rectangle.\u201d The ROI function for this blur will return a shape that defines what portion of the input image \u201cLarge Rectangle\u201d is relevant for calculating the portion of the blur result in the output DOD. The value of understanding this ROI region is that we only need to store the relevant portion of the input image, so we save memory for storing intermediary results (and some on the ultimate result as well), and processing time applying effects to pixels that may ultimately be irrelevant. For example, the buffer that would occur at link  need only store the relevant result, which is the intersection of the output DOD of node  and the ROI of node \u2014such intersection being an optimized result region.","Like DOD calculations, in practice of some embodiments, a function is used to determine the ROI of a node. Also, like DODs, some ROIs are easy to determine in that they are simply identical to a value found on a link across a node. For example, if link  has an ROI of \u201cAlpha\u201d and node  is a color conversion, then the ROI for link  is also Alpha, However, if node  is a blur, then determining the ROI for link  is more difficult (it is very likely different from Alpha and probably smaller). In some embodiments, a function associated with the node will be called to resolve a hard-to-determine ROI. In alternative embodiments, the optimizing routine calculates the ROIs itself, during optimization. In yet another embodiment, the ROIs for some links are calculated directly during optimization and other links are calculated indirectly by calling a function. For example, one embodiment may directly calculate ROIs for easy links (those where the input and output shapes are the same) and make function calls for difficult links (those where the output shape is different than the input shape). For illustration, we shall very briefly discuss calculation of ROIs","Like DOD calculations, ROI calculations must be propagated through the graph tree, although as implied above from the root down (not from the leaves up, like DODs). When Core Imaging is asked to perform a graphics task, the asking entity provides an ROI for the output, so we can assume that the root node (e.g. ) is known. To determine the other ROIs we simply propagate backward through the graph tree. For example, to calculate the ROI for input\/link , we consider the \u201cknown\u201d ROI at the result and the function of .","As discussed earlier, application programs will construct high-level graphs using the Core Imaging API. Either using one of those graphs, or by other means, a programmer of application program will submit a graphics task to Core Imaging. Referring to ), assume that task is to draw Result ROI. Referring to ), the first task for Core Imaging is to create a low-level graph, step . While there is more involved in creating the low-level graph (shown as a tree in ()), for purposes of this example, it is only important to know that output DODs, including the global DOD (DOD of the root node ) will be calculated and represented in the nodes at the end of this step . Next, in step , Core Imaging finds the intersection of the Global DOD and Result ROI. For convenience we shall call this \u201cResult Intersection.\u201d","Core Imaging then continues to decision step  to determine if there are more nodes to examine. This determination  may be made in any suitable manner that will be clear to a skilled programmer. If there are no further nodes to examine, then the program is finished with this optimization task in step , and is ready for just-in-time compiling. Returning to \u201cMore Nodes?\u201d decision , if there are more nodes to optimize, Core Imaging will determine the ROIs for the inputs of the next node. There are a variety of well know ways to determine which node is next in walking a tree, so we will not discuss that topic here.","For purposes of our  example, we remain at node  and step  with the task of calculating the input ROIs for node \u2014the root node. As discussed earlier, this might be determined directly or by calling a function. In either event the ROIs for links  and  are determined and inserted in the graph.","After ROIs are determined for node  inputs, Core Imaging returns to decision  to answer the query \u201cMore Nodes?\u201d There are more nodes in this case, the Core imaging moves to step  to determine the Input ROI of node . Note that since Node  is a leaf node and has no inputs, there is no ROI calculation for node . Therefore, the input ROIs are determined for links  and  and inserted in the graph.","Core Imaging returns to step  and determines there are more nodes so moves on to step  again to determine the ROI for node . Note again that  is a leaf node, so no calculation is necessary. The ROI for  is determined and entered in the graph.","Control returns to decision node  and determines there are no more nodes (node  is a leaf). Core Imaging moves on to step , Done!","The Graph is now optimized for ROI and DOD, but other optimizations, such as node consolidation and caching, may be layered on this or could have been performed simultaneously.","As mentioned earlier, programmers may find efficiency in organizing the optimization techniques in various orders. However, some embodiments of the current invention practice one or more of the techniques in defined sequences across only portions of a graph. In particular, the same (or a similar) program sequence may be applied recursively to a portion of the graph, one portion at a time. This method allows for efficiency gains by providing opportunities for memory re-use and sequential processing (to some extent). For simplicity, the concept of caching is largely omitted from the discussion of these embodiments. However, given the disclosure herein, one skilled in the art will understand where caching steps should be implemented.","For illustration, refer to  where a flow chart is shown for a recursive execution embodiment of the invention to arrive at a result. Stated alternatively, the purpose of the example is to calculate the root node. At step , Core Imaging attempts to combine the root node with adjacent nodes. If nodes may be combined, that process is executed possibly absorbing multiple nodes along each input link to the root node. Control moves to step , where Core Imaging determines the DOD for the (possibly merged) root node. Once DOD is known, control passes to step  where ROI is computed for the children links to the root node. Having ROI and DOD, the two may be intersected to determine the result region. Control passes to step  now to generate textures for the inputs of the root node. These input textures are necessary in order to render the root node. Many times, however, the input textures of the node will be un-calculated and represented only by a graph. In those cases, Core Imaging may need to recursively process, on each subservient node, similar steps to those described in this example. Therefore, the process illustrated in  may be applied in nested fashion to move down a graph and resolve nodes that are ultimately necessary to resolve in order to calculate the root node. Alternatively stated, the process for resolving a node is applied in nested fashion until control resolves all nodes necessary to compute the textures for the inputs to the root node. After the root node input textures are calculated, control moves to step  for creation of a buffer for the result. Finally, control moves to step  where the GPU is used to render the result to the buffer created in step .","It should be understood that the notion of caching was intentionally omitted from the prior illustration in order to focus on the recursive process. However, caching may be employed in a variety of places, including without limitation for node results and node-combination analysis and results.","Yet another recursively processed embodiment is shown by the flow chart in . Referring then to , step  indicates that we are attempting to compute the root node. In doing so, step  determines if it is possible to combine the root node with and adjacent node. According to step , if combination is possible, the combination is performed and combinations continue to occur (through steps ,  and ) until it is determined that no further combinations are possible. After such determination, control passes to steps  and  for DOD and ROI optimization. Next, decision step  determines if it is now possible to render the root node. It will only be possible to render the root node if all the inputs to the root node are calculated. Therefore, assuming the answer to decision  is no, control passes to step  for the task of generating the missing child textures that are necessary for resolving the root node. It is noteworthy here that the ensuing process under  is very similar to the overall process for resolving the root node. In particular, the same routines are used to resolve sub-nodes and root nodes. However, those routines may be called in nested fashion to resolve multiple nodes in a graph. Alternatively, those routines may be run in parallel to resolve several nodes at once, even nodes in non-related graphs","Returning now to step , the next child node must be determined, which is simply appropriately choosing the next node to analyze. Steps  and  analogize to steps  and . Steps ,  and  analogize to steps ,  and . Step  analogizes (for brevity) to steps  and . Step  indicates that when a sub-node may not be rendered due to the unavailability of its input textures, that the next node (step ) will likely be calculated in a nested computation. Similarly, step  indicates the likelihood of un-nesting a level after a node has been resolved and rendered.","Ultimately, at step , if there are no more children to resolve, control may pass to steps  and  where a buffer is made for the result of the root node and the root node is rendered to context.","For yet another alternative embodiment or recursive operation, refer to , and assume the graph shown in  must be optimized and rendered by Core imagine. Starting at the root node , Core Imaging may begin at step  by calculating the global ROI intersection with the Global DOD. Control moves to Step  to determine if there is a next node. If there is no next node, then processing is done as indicated in step . However, in this case, the root node  is the next node. Control passes to step  to get the input ROI for node  on input link . Having obtained such input ROI, control passes to decision  to determine if the result of \/ROI is in cache. If the \/ROI image is in cache, control passes back to decision block  to check if there are further nodes to process (recall that if that result is found in cache system needn't process the entire graph below the found node). In this case, assume that the result of \/ROI was not in cache so control passes to buffer allocation step . At this step, a buffer is defined and may be allocated for the size of  input ROI. Control then passes to decision step  to determine if the node () may be rendered at this time. In practice this may be a command to render node  into the buffer that was just previously defined.","As we see from , node  is the root node and is not ready to render. We will deal later with the Y decision on step . Since node  is not ready to render, control passes to step  to determine if the next adjacent node may be collapsed into node . At the step, the system must determine if node  may be collapsed into the next adjacent node (as discussed in greater detail earlier). As discussed elsewhere herein, the combine decision and operation may involve a second caching system whereby the system can lookup whether two nodes may be collapsed and, if so, the result of the collapse.","Returning to the decision at step , if  may be combined with and adjacent node, then control moves to step  and the combination is effected. Control then passes back to node , where the next node for analysis is the newly created . If step  determines that a combination is not possible, then control passes back to decision step  to determine the next node for analysis. In the practice of some embodiments, a \u201cNO\u201d at step , leaves node  un-resolved and the return to step  runs the routine on the next node in a nested fashion. The nesting may go infinitely deep and will ultimately resolve by de-nesting (one nest at a time) at the next node step .","Returning now to step , we determine that the next node is , so control proceeds to step  to retrieve or calculate the input ROI for Node . Once ROI is determined, control passes to decision node  where the \/ROI combination is checked in the cache. Assuming there is a cache miss, control passes to step  and a buffer is allocated. Control then passes to step  for the decision if render is possible (again, in practice this may simply be an attempt to render ).  tells us that node  can not render, so control passes to step  for a determination regarding the possibility of collapsing a node. Assume that determination is also negative, and control returns to step  (in some embodiments for a second nest of the routine).","At , next node is determined to be node . The input ROI is determined at step  and control moves to the cache check at step . Now assume that we have a cache hit so that node  and all below it is resolved and stored. Control then moves back to step  where the next node becomes node  (node  remains unable to render because of the small portion of the tree following link ). With respect to , input ROI is determined at step  and we shall assume a cache miss at decision . At step  we define a buffer for the  ROI and at step  will find that node  may be rendered (nodes  and  are tree leaves or input images so they do not prevent rendering of node ).","In view of the ability to render node , control passes to step  for ROI\/DOD optimization. Here we intersect the output DOD of node  with the input ROI of node  to minimize the size of our ultimate buffer that will be written during rendering. In some embodiments will adjust the buffer settings made in step . Node  is then passes to the compiler (step ) and the compiled result is rendered (step ). After rendering (or at some points in this process), many embodiments will re-consider memory usage caused by buffers and whether that space may be set free or re-used. We represent this consideration in step .","Control now returns to step , where it will ultimately be determined that node  is ready to render (step ). Rendering will occur as previously described and control will ultimately pass back to step  for consideration of node . If we assume that the node \/ROI is cached, then rendering will ultimately occur on our result node .","For illustration the following is an example in code showing how Core Imaging API may be used for a simple exposure filter:","CIImage *image, *result;","CIFilter *bright;","CIContext *context;","CGImageRef cgImage;","context=[CIContext contextWithCGLContext: someGLContext];","image=[CIImage imageFromCGImage: someCGImage];","bright=[CIFilter filterWithName:@\u201cCIExposureFilter\u201d];","\/\/ filter parameters set via key\/value coding","[bright setValue: image forKey: @\u201cinputImage\u201d];","[bright setValue: [NSNumber numberWithFloat: \u22122.0] forKey:","@\u201cinputExposure\u201d];","result=[bright outputImage]; \/\/ result is still just a \u201cpromise\u201d","[context render: result]; \/\/ forces evaluation","Also for illustration, the following is an example of combining fragments according to an embodiment of the invention.",{"@attributes":{"id":"p-0141","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"program 1:",{}]},{"entry":[{},"MOV r0, program.local[0];","-- r0 = local variable 0"]},{"entry":[{},"MUL r1, r0, program.local[1];","-- r1 = r0 * local variable 1"]},{"entry":[{},"MOV result.color, r1;","-- output pixel is r1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0142","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["program 2:",{}]},{"entry":["MOV r0, program.local[0];",{}]},{"entry":["TEX r1, fragment.texcoord[0], texture[0], RECT;","\u2003-- r1 = sample (texture"]},{"entry":["0, coord 0)",{}]},{"entry":["MUL r2, r0, r1;","-- r2 = r0 * r1"]},{"entry":"MOV result.color, r2;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0143","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["combined program:",{}]},{"entry":["MOV r0, program.local[0];",{}]},{"entry":["MUL r1, r0, program.local[1];",{}]},{"entry":["MOV r256, r1;","-- save output pixel"]},{"entry":["MOV r0, program.local[2];",{}]},{"entry":["MOV r1, r256;","-- replace texture lookup by previous"]},{"entry":["output",{}]},{"entry":["MUL r2, r0, r1;",{}]},{"entry":"MOV result.color, r2;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In compiling high-level filter combinations, Core Imaging may yield multiple objects for execution during rendering. This feature of Core Imaging may be widely applicable to systems with multiple heterogeneous processors. For example, it may be useful to perform just-in-time compilation to divide a weather forecast calculation being performed on an operating aircraft. Just-in-time compilation allows an efficiency algorithm to account for the status of the aircraft (flying) when determining which processing resources to use. This general process may be summarized in seven steps although an effective system could operate on a subset of these steps: (1) check which resources are available for employment, such as processors, controllers and memory spaces; (2) evaluate the capabilities of each of the resources: (3) check the operating status of each resource; (4) evaluate the requirements of the current task; (5) analyze the requirements of the task with respect to some or all of the available resources; (6) optimize and compile the software to meet the requirements of the task while increasing the overall efficiency of hardware usage in the system (generally reducing the resources used by the task, but perhaps using under utilized or otherwise un-used resources): and (7) execute the compiled code. It is noteworthy that, depending upon the embodiment, steps one through five may occur at execution time or before, while steps six and seven may be most useful in the process if occurring at or near execution time.","There are virtually infinite applications for this process (whole or truncated) that can consider hardware capabilities, the nature and difficulty of the task and real-time status in determining an efficient division of work. Notwithstanding those virtually infinite applications, there are three common reasons that Core Imaging will produce CPU code. One of those is for emulating a GPU on the CPU and that is discussed later. The second reason is for strict efficiency by using the CPU to do offline rendering. The final reason is for absolute necessity, such as when the task exceeds the hardware ability of the GPU (this is also discussed some in a later place).","Given that the first and third reasons are discussed elsewhere, we briefly discuss the second reason here by providing an example. A central benefit to multiple processors is the ability to work in parallel. When the application program presents tasks requiring serial application of filtering routines, parallelism is most easily established. By example, referring to ), there is a chart show the timing of a CPU and GPU working serially on a 6 frame sequence. For purposes of this example, there are two effects being sequentially applied to each frame, the CPU applied the first effect and the GPU applies the second effect. The GPU starts frame one while the GPU is idle or working on something else. After the first effect is applied to frame , the frame is passed to the GPU to apply the second effect. While the GPU applies the second effect to frame , the CPU is applying the first effect to frame . The process continues (shown in chart ()) so that simple parallelism is used to very efficiently exploit hardware and quickly apply two effects to a stream. Referring to ) and (), there are shown similar charts conveying the efficiency of applying four effects either with four processors ()) or two processors ()). It is noteworthy that the nesting in ) can be arranged in many ways and applied to any number of processors with any number of effects. The efficiency is realized through serializing the application of effects. The efficiency can be further enhanced if the work required for each effect is optimally suited for the processor performing the task. For example, in ), if the CPU were better suited for applying the second effect, then the order of frame processing between the CPU and GPU would be reversed.","As previously discussed, during the past several years flexible graphics-related hardware and software technologies have evolved and provided basis for even more useful technologies such as many embodiments of this invention. In particular, the advent of technologies such as OpenGL and programmable GPUs have provided tools for many of the innovations described herein. However, these tools are not necessarily backward compatible, in that all of Core Imaging's functionality may not be able to run on every platform for lack of an enabling infrastructure (e.g. a programmable GPU). Therefore, if there are programmers or programs that rely on Core Imaging's services, those programmers or programs may be compromised on a particular platform if some or all of Core Imaging's services are unavailable.","As a practical example, if one designs an operating system to provide functions like that of Core Imaging, then presumably applications will be designed to make high-level graphics calls like those described in many of the embodiments herein. However, a problem arises when you envision the attempt to run those applications on older computers, even assuming a new operating system has been employed. Specifically, a problem arises if a call is made to Core Imaging, for which the GPU would normally provide rendering. For this reason, it is useful for Core Imaging to comprise an emulation ability, so that all or a maximum of its functionality may be available on any platform.","Therefore, from a very high-level (system functionality) we can see that there are times when an emulator will be very useful, if not necessary. However, while the legacy applicability of Core Imaging provides incentive for this disclosure, the innovations herein are not so limited. Therefore, we shall have a brief discussion regarding the more precise circumstances in which an emulator may be employed. In particular, we have already alluded to the usefulness of an emulator in the absence of a programmable GPU or any GPU at all. However, in addition, even systems comprising GPUs may have beneficial use for emulation. In particular, problems may exceed the resource limits of a particular GPU. For example, in contemporary GPUs, images beyond 2048\u00d72048 are generally too big. In addition, the accuracy of results may require the CPU (some GPUs such as those currently available from ATI use only 24 bit floating point). Of course, there are numerous other hardware limitations and possibly low-level software considerations that may make an emulator useful to resolve a particular graph or node","1. Making the Decision to Emulate","The decision to emulate may be made at various times depending upon the nature of the host system and the reason for emulation. For example, in a system lacking programmable GPU support, a software switch may permanently set the configuration to emulate appropriate graphics calls. Alternatively, the decision may be made after Core Imaging has been called for a specific task. In this case, the nature of the task may be considered as well as the specific capabilities of the resident GPU, and possibly even the status of processes and hardware items. In some particular embodiments, Core Imaging makes the decision regarding emulation at the time of a graphics call. In some of those embodiments, emulation is used when there is either no resident GPU or the resident GPU is not programmable. In others of those embodiments, the decision is made after graph optimization has been at least partially applied and it is determined that either the GPU is unable to process a particular fragment, or such particular fragment is more advisable to process through emulation on the CPU. In yet another embodiment, the decision to emulate may depend upon the source of the graphics request or the destination of the output. This is because overall system response to a graphics request may be improved by improving the rate of memory operations. For example, if Core Imaging is asked to render a result to system memory, that ultimate destination is one factor tending toward emulation because emulation takes place on the CPU. Access to main memory is generally faster from the CPU than from the GPU. Likewise, memory operations in the video ram will generally be faster from the GPU. Therefore, if Core Imaging is asked to render to VRAM, that is a factor tending toward using the GPU.","2. Emulation as a Layer in the Software Stack","Referring to ) and () we have described Core Imaging as generally providing services in the area  and . For many embodiments of the Core Imaging emulator, we can refer to a service that exists in the layer of OpenGL  or . Therefore the emulator of those embodiments provides services generally at the same level at OpenGL. This is a distinction from other embodiments wherein the emulator provides services below OpenGL. The distinction occurs because the former embodiments achieve performance, in part, by providing emulation on only a subset of OpenGL's (or similarly situated services) functions. In alternative embodiments, the emulator may be part of an OpenGL (or similar) implementation. In yet another alternative embodiment, the emulator may be below OpenGL (or a similar service) and provide more comprehensive coverage. Of course, this may be at the expense of performance.","In discussing emulator embodiments of the current invention, we shall provide more specific discussion regarding two sets of embodiments. One set of embodiments involves compiling GPU programs (e.g. fragment programs) directly to machine code for the target CPU or CPUs. The second set of embodiments involves a byte-coded virtual machine where each GPU instruction is modeled by a function in a high-level programming language (such as 3). In either type of embodiment, it is preferred, although unnecessary, to begin with a low-level graph. Furthermore, since graph optimization as discussed previously may reduce nodes, memory and calculations, it is also preferred to begin with an optimized graph. Since the emulators work with fragment programs that may be a portion of a node, the emulator task may be viewed as layered below the graph walking and resolution techniques previously described.","Once a decision has been made to emulate, many embodiments use the following general process for a CPU-ready program. Given our prior discussion, it should be clear that we assume a beginning with GPU code. In greater particularity, this may usually be fragment programs associated with nodes in a graph. Each fragment program has one or more GPU instructions. (we may call these lines). Each line in the program is then translated to a CPU-equivalent instruction. Many lines, such as those comprising an add instruction, may have single instruction CPU equivalents. Other lines require more intense emulation in that a single line of fragment code must translate into multiple CPU instructions. Either type of translation (one-to-one or one-to-many) may be accomplished in a any variety of manner that a skilled programmer may recognize. In one preferred embodiment, instruction translation occurs through a large \u201cif\u201d statement. In another embodiment, a table and lookup are used to align GPU instructions with equivalent one or more CPU instructions.","During the translation step, GPU code may be translated from any level of GPU instruction to any level of CPU instruction. For example, the translation may occur from GPU assembly into CPU assembly. In one preferred embodiment, the translation occurs between GPU assembly and CPU machine code, which is binary in current implementation.","Once the program is expressed as CPU instruction, the code may be unrolled. Code unrolling and ultimately instruction scheduling are fairly standard optimization techniques to take advantage of instruction-level parallelism (\u201cILP\u201d). The general purpose of ILP is to increase the amount of hardware parallelism exploited by software instructions. One way this is accomplished is to re-arrange instructions to maximize performance. More specifically, groups of instructions having no interdependence may be executed in parallel. Loop unrolling is a class of ILP techniques whereby efficiency is gained by exploiting the parallelism inherent in a loop. This is important in a graphic operation because a single fragment, or more particularly, its CPU-emulated equivalent, will run many, many loops in order to resolve numerous pixels (one loop per pixel). In loop unrolling, n instances of the loop are unrolled\u2014that is, n instances of the loop code are written in program lines (e.g. if there are 10 lines in the loop and n is 4, then there would be 40 lines of unrolled code). Finally, the unrolled code must be set up to run in this form, meaning that there may be necessary adjustments to the increments of variables and the branch or goto command that restarts the loop. After unrolling, program scheduling is then used to optimize the unrolled code for maximum parallelism on the subject hardware. When the unrolled code is ultimately run, it will need only loop one nth the number of times of the original loop and each new loop will run with far less stall events.","Once unrolled, the next three steps on the code are standard optimization, register allocation and program\/instruction scheduling. A skilled programmer will recognize how all these steps may be performed, however, we shall provide very brief descriptions. Our descriptions are not intended to be exhaustive or exclusive. There may be many techniques that we do not mention. Furthermore, all the techniques we do mention may not be performed under the categorization that we state. Standard program optimization is aimed at improving time and memory performance through many techniques such as code compactions and elimination of duplicates. Register allocation is performed to avoid conflicts, minimize the number of registers used and throw out instructions with no output effects. Finally, program\/instruction scheduling optimizes the code for the pipelining and parallelism of the particular hardware.","Having accomplished so much by this point, the code is cached so in the future, this work is unnecessary.","Referring to , there is a sample program flow for an embodiment of the inventive emulator. The program flow and description are intended only for illustration. Actual embodiments may use object oriented approaches that may not be readily described with a flat flow chart.","Referring to step , a program calls Core Imagine to request rendering or creation of an image that is typically bounded as a polygon. Control moves to decision  where it is determined whether or not the emulator should be employed. If the emulator will not be employed, control moves to step , where we would be done for the purpose of this illustration. Of course, the disclosure discusses alternatives to emulation elsewhere.","Having previously discussed considerations for employing emulation, we shall assume that step  determines to use the emulator and control passes to step  where data is pushed to the emulator from other routines in Core Imaging. In particular, the data is the following: the subject fragment program; textures needed to render the fragment program; local variables; and state. After these items are made available to the emulator, control moves to decision  to see if CPU machine codes have already been generated for this task. The fragment program is used as an index into the cache. However, there are varying ways to implement the cache. In some embodiment the cache lookup will comprise the formats for all the necessary data. For example, the cache may key off of a table storing information such as the pixel format of the output (32 bits per pixel, RGBA, etc.), and\/or the pixel format and state of each texture.","Returning to decision , if there is a cache hit, then control skips to step . For completeness of illustration, assume a cache miss and control moves to step  for conversion of the GPU fragment code to CPU code. Since techniques for this conversion are described above, we only briefly address the issue. In most embodiments, this step  performs all of conversion, unroll, standard optimization, register allocation, and program\/instruction scheduling. However, other embodiments may perform more or fewer functions depending upon what steps have been completed earlier. Similar caveat applies to the next step , where the CPU code result is cached. While most embodiments cache the binary machine code, the skilled programmer may find reason to cache a less processed result.","Moving now to step , the machine code is placed in an N length loop for pixel evaluation. The job of this loop is to evaluate L pixels. In a preferred embodiment, L is 128. While the inventions described herein applied to nearly any value for L, the inventors have found that, in their implementation an L value of 128 provides good performance in balancing various consideration (the desire to do many pixels at once, with the larger overhead caused by texture lookups and dealing with partial blocks). Therefore, If the loop of step  is to evaluate L pixels, then the unrolled code must be looped a number of times equal to L divided by N, where N is the number of iterations of the loop that are expressed in the unrolled code. Ultimately then, N equals L\/n. Therefore, if we use our preferred embodiment of 128 pixels per full loop, and we assume 4 unrolled iterations, then the unrolled code must be looped 32 times.","Moving now to step , the emulator causes the creation of slabs. In a preferred embodiment, this may be accomplished through a function call. The term slab is used for its relatively common meaning in the graphics art. However, in this embodiment, slabs are formed by drawing horizontal lines at all vertices on the output polygon. For example, see  where there is shown in ), a tilted rectangle and the same titled rectangle divided into slabs. ) shows two trapezoids having the same relationship; one is shown with slabs drawn in.","After slabs are created, control moves to step  for rendering. In a preferred embodiment, the slabs are rendered one at a time. In particular, each slab is rendered by running the pixel loop created in step  on L sequential pixels found on a scan line in a slab. In even more particularity, the polygon is rendered by: (i) selecting a first slab (assuming an X,Y,Z global coordinate system, in a preferred embodiment section may proceed from the smallest to largest Y value); (ii) selecting a first scan line on such first slab (assuming an X,Y,Z global coordinate system, in a preferred embodiment section may proceed from the smallest to largest Y value); (iii) using the loop created in step  to render the first L pixels of the scan line and then repeating this step until the scan line is all rendered; (iv) moving to subsequent scan lines (including for portions of L pixels) until all scan lines in a slab are complete; (v) completing all subsequent slabs in similar fashion. In addition, since Core Imaging's choice of L pixels is arbitrary to the service requestor (e.g. application program), some embodiments write out rendered results to one or more buffers, one pixel at a time. The ultimate result can then be placed in the requested destination in desired pieces. For example, the result can be moved to the requested destination after the completion of L pixels, or after completion of a whole portion (such as a slab), or after completion of the whole polygon. This extra step also creates a convenient place for any post processing such as format conversions (between the buffer and the requested destination).","In discussing the rendering across scan lines, a question may arise regarding the handling of scan lines where the pixel count is not a multiple of L. While skilled programmers may devise a variety of methods for implementing this case, some embodiments of the invention account for this issue within the framework of the process shown in . In one particular example, the pixel loop of step  loops a number of times according to a variable, say Alpha. Therefore, if there are 128 pixels and the loop is unrolled 4 times, then Alpha will be 32. However, if there are only 48 pixels (e.g. after processing several 128 bit groups across a scan line), then Alpha may be set to 12. Alternatively, if there are 66 pixels, Alpha may be set to 16 for processing the first 64 pixels, then Alpha may be set to one to process the 65th pixel and the 66th pixel. In summary, these embodiments call for using a variable to control looping and adjusting that variable to deal with varying amounts of pixels.","Another method for handling non-multiples of L pixels, is to provide unrolled code segments for varying amounts of pixels. For example, if the main loop has 4 unrolled segments, there may also be code created with three unrolled segments, two unrolled segments and one unrolled segment. Therefore, if there are 3 pixels, the three-pixel code can be used. If there is one pixel, then the one-pixel code may be used.","There are also embodiments that combine the forgoing techniques. For example, if there are 66 pixels, Alpha may be set to 16 for processing the first 64 pixels, then the two-pixel code may be run to handle the 65th and the 66th pixels. Alternatively, if there are 67 pixels, Alpha may be set to 16 for processing the first 64 pixels, then the one-pixel code may be run 3 times to handle the 65th, 66th, and 67th pixels.","Many embodiments use slabs. As an alternative to slabs, an entire polygon could be rendered, in the same fashion as described. However, slabs provide a significant advantage in texture calculations. In particular, texture coordinates are known for the vertices of the output polygons. In most embodiments, this is because the layer above (e.g. the graph optimizer) provides this information. However, typically, the hardware can map the vertices of its base unit polygon (typically a triangle) to the relevant texture map; and the vertices of the hardware's base unit polygon must coincide with the vertices of the output polygon. Referring to ) and (), these vertices are shown as circular dots. Referring to ) and () again, when slabs are formed they typically comprise one or more vertices that were not vertices on the original polygon. In all of , these \u201cnew\u201d vertices are shown as triangles. Therefore, in one or more embodiments, when slabs are formed, the texture values of the new vertices (triangles in  may by calculated by a variety of techniques. Some embodiments calculate the texture coordinates for the new vertices by interpolating the coordinate values from the known polygon vertices. In a preferred embodiment, linear interpolation is used to interpolate down the edges of split-up slabs. Each slab then will have three or four vertices with known texture coordinates. With three or four known coordinates at the vertices of the slabs, the texture value of any pixel on a slab may be determined by mathematical techniques such as interpolation, or more particularly, linear interpolation.","Ultimately, since the slabs are smaller than the polygons, they provide a significantly easier calculation of texture values. In particular, as described to this point, slabs comprise a portion of the result polygon and occur as either a triangle or a four-sided polygon. In the case of a triangle, once the texture coordinates for all vertices are known, the coordinates (and ultimately value) of any point may be calculated with math (e.g. interpolation or linear interpolation). Furthermore, when the slab is a polygon, the program may use multiple mathematical schemes to devise the texture coordinates of a point in the polygon. For example, in some embodiments, the program will choose three vertices and perform linear interpolation.","The advantages of slabs may be realized through different shapes. For example, in some embodiments, the result polygon may be divided into all triangles for rendering. This can simplify the texture lookups in that there are always only three vertices. Therefore, there is never a need to make a decision regarding which three vertices of a four-sided polygon should be used for interpolation. In addition, a skilled programmer might apply the concepts taught herein to other schemes whereby the result polygon is divided for rendering.","We have discussed texture lookups, for example, in the context of slab and polygon vertices. We shall now discuss further detail regarding how to efficiently incorporate texture lookups into some of the embodiments that have been disclosed. We must first provide background for this detailed discussion by describing two relevant types of texture lookups and then providing a context that may be analogized to prior discussions.","In the emulation task, there are two general types of texture lookups that may be encountered. There are independent texture lookups which are coordinates into a known texture. For example, an independent texture lookup may be a place in code referring to given coordinates in a known texture. Alternatively, there are dependent texture lookups, which are texture lookups that depend upon some other item or event, so coordinates are typically programmatically placed in a register. For example, this may be a place in code where the coordinates into a given texture are found in a register. The texture lookup is dependent on the result of some other operation that will populate the register.","In setting context for the texture lookup techniques, we look more closely at the activity inside the main loop of the emulator described for varying embodiments. More particularly, this is generally analogized to the loop we discuss with reference to  as . By that analogy and reference to , in setting up the loop in step , there is more to accomplish than simply placing the unrolled code in a loop to effect the processing of 128 pixels. In particular, for each group of pixels (slab, scan line or preferably L or remainder group of pixels), code must be set up. As discussed earlier, part of setting up code may be that when a scan lines comprises a pixel length that is not multiples of 128 (L), the code may account of the remainder pixels. In addition, the code may be set up for texture lookups.","Focusing more directly now on the subject of texture lookups, a preferred embodiment of the emulator will set up the main loop for texture lookups. In one embodiment, such setup is performed for every L pixels and involves separately setting up for independent and dependent texture references. For these embodiments, during set up, each independent texture reference is looked up, preferably in the same step. And, for each dependent texture reference, a function is inserted in the code to perform the lookup after the dependency has been met. To be clear, a function call is inserted into the code for each lookup. A function is created for every texture unit accessed by a dependent texture reference in the program. The only values passed to the texture lookup function are the coordinate to lookup and the texture to use. More precisely, this inserted piece of code will call outside the loop, such function essentially emulating the GPU texture lookup ability. In one preferred embodiment, the function call from within the loop passes the texture, state and coordinates; and the function returns a vector. However, this function call may be otherwise implemented.","While we have discussed setting up code a number of times already, we shall provide some illustrative embodiments. For example, in a given embodiments there may be portions of code that will be set up for each polygon, and portions that will be set up for each slab, and portions that will be setup of each scan line, and portions that will be setup for each pixel group (e.g. L or remainder group). The various activities in a given setup may be extrapolated from the other discussion herein.","Embodiments following techniques similar to the prior example are extremely well suited for multiple CPUs. This is because the loop machine code created at step  () may be run in separate instances on different slabs or different polygons. In particular, Core Imaging or another suitable program can greatly speed graphics rendering on a multiprocessor system by dividing the task between processors. In a preferred embodiment, the increment of task that would be sent to each processor is a slab (or other subdivision). However, the increments could be smaller (e.g. scan lines) or larger (e.g. whole polygons).","A virtual machine may also be used to emulate the GPU code on the CPU. A virtual machine is a process that behaves like hardware in that it can accept instructions and emulate processor resources to another processor. In a general sense, the advantage of a virtual machine emulator solution is that the virtual machine is more portable. In particular, a virtual machine may be written in a high-level language and then compiled for any platform. Alternatively, the embodiments that compile GPU programs to machine code may be custom written for each hardware platform.","In one preferred embodiment, the invention calls for a byte-code virtual machine emulator. The adjective \u201cbyte-code\u201d adds the meaning that the virtual machine process accepts compiled code, or in the case of some embodiments code at a low-level that is analogous to that which hardware would accept At a high-level, the virtual machine may be analogized to the CPU in the embodiments discussing a GPU-to-machine-code emulators. In greater particularity, the virtual machine may be conceptualized as lying beneath the higher-level functions and techniques previously described. Therefore, all of the emulation and other methods and techniques previously described can be analogized and applied to the disclosed virtual machine emulators. However, there are interesting aspects of the virtual machine embodiments that merit independent consideration.","In one embodiment, the virtual machine includes very large virtual registers for building the output pixels. In particular, now freed from the constraint of hardware, the virtual machine can use register sizing that meets the demands of other criteria, such as efficiency. Therefore, in some embodiments, the virtual machine will set up a register for pixels that is L pixels wide (referring back to our example of 128 pixels processed along a scan line). A register this wide provides many options for main loop processing. At one extreme, the register may function as an output buffer with one pixel being processed at a time (single pixel loop). At the other extreme, each step in the main loop may be effected on each pixel before moving to the next step (this would be analogous to fully unrolling the loop). As a balance between these extremes, some embodiments will implement the virtual machine to conceptually unroll the loop as much as possible, without incurring dependency issues. Depending upon system considerations, the pixel register may be a multiple of L or fraction of L. Furthermore, the pixel register may also be implemented dynamically to match the size of a scan line or polygon working-segment (such as a slab).","In practice, when an embodiment of the emulator is running it receives an instruction from a higher layer, which is preferably a higher layer of Core Imaging. Conceptually, the instruction may be at any level but for a preferred embodiment, the instruction will be low-level such as byte code. The virtual machine must then convert the instruction to a task for the CPU. The first part of such conversion is an \u201cif\u201d statement or jump table that effects a direct conversion to CPU cognizable instructions. In one preferred embodiment, the virtual machine models a GPU instruction as a C function. In this type of embodiment, each GPU instruction to be emulated may correspond with a C function. The C function may then be converted to CPU-cognizable code with an ordinary compiler. Most commonly, in a preferred embodiment, each emulated GPU instruction is modeled in a high-level language such as C. The high-level models are compiled and the results are incorporated into an \u201cif\u201d statement of jump table to be used during operation of the virtual machine emulator. Lastly, when operating on an element during emulation (such as a pixel), a CPU vector register may preferably be used to store the vector.","In order to yield performance, many embodiments do not emulate all possible low-level graphics calls. In general, by emulating only a subset of possible graphics instruction, the implementation can make more assumptions about the supported calls and therefore avoid some contingencies thereby saving work. For example, in some embodiments, Core Imaging has no need for perspective correct interpolations. In particular, OpenGL typically requires at least one divide instruction for every pixel per interpolated texture coordinate. Divides are very expensive computationally and since these embodiments of Core Imaging don't have perspective, the divides are unnecessary. Another example of performance gained by supporting only a subset of operations is that some embodiments of Core Imaging only support a small number of texture formats and destination formats. This limits data conversions and allows easier inline code generation.","As an example of supporting only a subset of functions, in one embodiment the emulator supports only a subset of OpenGL's functionality as follows: (i) drawing four-sided polygons; (ii) binding textures; (iii) binding programs; (iv) setting local variables; and (v) setting destinations.","There are several ways to practically apply this type abbreviated support. Foremost, the defined high-level API may only support these functions so that there is no possibility of receiving commands that can not be emulated. For example, if Core Imaging only supports a subset of functions, then the Core Imaging emulator need not support more. In that case, if programs or programmers wish to use non-supported graphics calls they must do so through another mechanism, such as direct calls to OpenGL or direct use of the GPU. Alternatively, one emulation technique might be used for the enumerated subset of functions (or some other subset) and another technique may be used for all other graphics calls. For example, the five emulated functions may be emulated through an embodiment using the GPU-to-machine technique, while other functions may be emulated through the virtual machine embodiments. This arrangement allows for highest performance on the most common graphics calls and easier portability and programming for supporting other calls. Of course, this division can be drawn along other criteria, such as difficulty of servicing the call, or the suitability of call servicing by respective techniques. In addition, the two sets of techniques (virtual machine and CPU-to-machine) can similarly share responsibility for implementing one or more subsets of overall graphics function in a system","Another service of Core Imaging that allows a GPU to process graphic information and enhances image processing is disclosed below. In addition to performing filters on an image, fragment programming can be used on GPUs to perform graphics operations (or more specifically, cumulative graphics operations). Example cumulative graphics operations include, but are not limited to, paint strokes, spotlights, warping, caustics, particle rendering, or ray tracing. Such cumulative graphics operations can be implemented on the CPU.","Referring to , a first technique of using programs on a CPU to process cumulative graphics operations is schematically illustrated. The disclosed technique creates an accumulation buffer , which is a texture of the original canvas or image. In general, the accumulation buffer  corresponds to a canvas. For example, the accumulation buffer  can be one layer of the original image, the entire original image, a collection of pixels from the original image, or a vector field of the original image, such as a displacement buffer. The accumulation buffer  includes data in a plurality of data structures for pixels of the original image. A data structure (R,G,B,A, or X,Y,Z,W) for a pixel can be a vector of four, 16-bit values. The accumulation buffer  is used to accumulate changes to the original image. For example, paint dabs applied to the original image may be accumulated in the accumulation buffer  by incorporating each paint dab into the aggregate of data structures of the buffer  while accounting for the effect of prior dabs (or \u201cpaint strokes\u201d). The accumulation buffer  can then be incorporated into the original image.","When painting, a user can make a number of cumulative graphics operations, such as making a paint stroke of color, applying a spot light, or warping a portion of the image. To use the accumulation buffer , \u201citems\u201d are incorporated into the accumulation buffer  by use of \u201coperations.\u201d As used herein, an item refers to something applied to the accumulation buffer . Example items include, but are not limited to, a brush stroke, a dab, a light, a warp, or a local blur. As used herein, an operation refers to the process of how an item is incorporated into the accumulation buffer . Examples of operations include, but are not limited to, addition of a light field, addition of a vector displacement field, or overlay of brush colors. While a user paints, many operations are performed with many items to incorporate the items into the accumulation buffer .","For illustrative purposes, a dab  is schematically shown in . The dab  can correspond to an individual color field application of a paint stroke by a user. The paint stroke can include an overlay of a plurality of such color field applications or dabs. According to the disclosed technique, the CPU uses programs  to incorporate the result of an item and operation on data in the data structures into the accumulation buffer . The programs  on the CPU read pixel data in the data structures from the accumulation buffer  and read the items. Then, the programs  on the CPU modify the pixel data in the data structures by combining the operations with the items and operating on the data in the data structures. Then, the program  on the CPU writes the modified pixel data in the structure back to the accumulation buffer , which can then be incorporated into the original image.","Although a suitable technique for processing cumulative graphics operations, the technique of using the programs on the CPU disclosed above may use more resources and memory than desirable. In a preferred embodiment, fragment programs similar to those disclosed herein are used with a GPU to process cumulative graphics operations. As noted previously, using a fragment program, the GPU can perform the same operation on multiple entries at the same time.","Referring to , a technique of using fragment programs on a GPU to process cumulative graphics operations is schematically illustrated. As noted above, painting involves many operations performed with many items to incorporate the items into the accumulation buffer . CPUs are capable of performing exclusive read\/modify\/write (RMW) sequences on the same buffer. The exclusive RMW sequences can prevent other processes from reading, modifying, and writing data in the same pixel data structures from a buffer at the same time. However, GPUs cannot currently perform such exclusive RMW sequences. Namely, the GPU lacks a memory or register lock and lacks the ability of atomic instruction, which would enable the GPU read\/modify\/write in one instruction while also limiting access to a memory location until the GPU completes the instruction. Thus, the GPU cannot read\/write\/modify data in a data structure without ensuring integrity of the data. Accordingly, the technique of using fragment programs on the GPU disclosed below preferably also uses fence limitations, which are techniques known in the art for preventing access to data in a buffer while other processes are performing read\/modify\/write operations on the same buffer.","As schematically shown in , the disclosed technique of using fragment programs on the GPU to process cumulative graphics operations creates an accumulation buffer . Typical procedures create a 32-bit buffer for the original canvas or image. The 32-bit buffer consists of data structures with four, 8-bit components. In contrast, the accumulation buffer  created with the disclosed technique preferably has data structures with more than 8-bits per component. For example, the data structures in the accumulation buffer  can have 16-bit integer, 16-bit floating point, and 32-bit floating point components for data. The accumulation buffer  with more than 8-bits per component is intended for complicated data structures amenable to GPU calculations. The complicated data structures include, but are not limited to, high-intensity-definition colors (light), vector offsets, and metaball field values. Because the accumulation buffer  is intended for complicated data structures amenable to GPU calculations, the item applied to the accumulation buffer  may be an individual distortion or warp, an individual spot light, or a two-dimensional metaball, for example. Therefore, the accumulation buffer  can be any one of a color buffer, a vector buffer, or a scalar buffer and can be either 2, 3, or 4-dimensional. The accumulation buffer  can typically be stored in VRAM but can be stored in a number of locations. The graph optimizer disclosed herein that optimizes the graphs of the fragment programs can determine the most suitable location for storing the accumulation buffer .","As before, a dab  is schematically shown in  for illustrative purposes. The dab  can correspond to an individual color field application of a paint stroke. The paint stroke can include an overlay of a plurality of such color field applications or dabs. Applying cumulative graphics operations to images is distinct from applying effects or filters discussed above to images. For example, painting allows a user to overlay many paint strokes onto an original canvas or image. On a computer, the original canvas is represented as a bitmap, and the paint strokes are represented by fields of color applied to the bitmap. While painting, the user may overlay numerous paint strokes onto the bitmap. Although painting is distinct from simply applying effects, each field color, however, is similar to a single application of an effect. Thus, the numerous paint strokes can be represented as a heavy overlay of multiple effects.","In processing an effect with a CPU, the bit-depth resolution at which the effect is internally calculated is typically greater than the bit-depth resolution of the resulting internal representation of the effect. Consequently, each application of each effect causes a loss in bit-depth resolution. While implementing cumulative graphics operations on the CPU, the losses of bit-depth resolution associated with cumulative graphics operation, such as painting, are typically mitigated by (i) using dithering when overlaying a paint stroke on the canvas and (ii) using non-linear applications of color, such as density or dye-based methods. These methods employ a different spacing of color levels.","The disclosed techniques for processing cumulative graphics operations on a GPU use the fragment programming techniques disclosed herein to substantially prevent loss of bit-depth resolution associated with implementing such cumulative graphics operations on a CPU. Furthermore, the disclosed techniques for processing cumulative graphics operations on the GPU can conserve memory space by operating on an item and directly writing the computed item into the accumulation buffer . Because GPUs cannot perform exclusive read\/modify\/write sequences, the disclosed technique creates a separate area-of-effect buffer . The area-of-effect buffer  can typically be stored in VRAM but can be stored in a number of locations. The graph optimizer disclosed herein that optimizes the graphs of the fragment programs can determine the most suitable location for storing the area-of-effect buffer .","To create the area-of-effect buffer , the disclosed technique determines an area-of-effect  from the accumulation buffer . The area-of-effect  is the relevant portion of the accumulation buffer  to which an item, such as a paint stroke or dab, is applied. The area-of-effect is used because having the GPU process the area-of-effect  rather than the entire accumulation buffer  is more efficient. For a paint stroke, the area-of-effect  is an area having the portion of the canvas under the stroke. For a spotlight operation, for example, the area-of-effect  is an area having the portion of the canvas illuminated by the spotlight. The data structures embody what is known about such portions of the canvas affected by the stroke or spotlight, for example.","The disclosed technique copies the area-of-effect  into a separate, area-of-effect buffer . The fragment programs  on the GPU use the area-of-effect buffer  as their source for reading information and use the accumulation buffer  as their destination for writing information. Thus, the fragment programs  on the GPU similar to those disclosed herein read data formatted in data structures from the area-of-effect buffer , and the fragment programs  read the items or produce the items directly using a fragment program. The fragment programs  on the GPU then modify the data in the data structures by combining the items with operations and operating of the data in the data structures. Then, the fragment programs  on the GPU write the results or modified data in the data structures to the accumulation buffer . Eventually, the fragment programs  of the disclosed techniques accumulate the sequential effects on the area-of-effect  and then apply the accumulation buffer  to the original canvas or image.","Referring to , exemplary steps  for processing a paint stroke with the disclosed technique using fragment programs on a GPU are illustrated. Although the cumulative graphics operation is a paint stroke in the example discussed below, it will be appreciated that exemplary steps can apply other cumulative graphics operations. The disclosed technique preferably initializes the accumulation buffer with data structures having more than 8-bits per component, although data structures with lower bit resolution may still be used (Step ). Next, the disclosed technique computes the paint stroke by the user by overlaying the individual color field applications or dabs (Step ). For each dab, the disclosed technique performs a number of steps (Steps -). The disclosed technique reads an area-of-effect into a separate buffer. The area-of-effect is only the amount of the accumulation buffer under the dab, for example.","The dab result is then computed by a fragment program (Step ). By using a fragment program, and not constraining the dab to 8-bit components, loss of bit-depth resolution can be substantially avoided. Since the accumulation buffer has more than 8 bits per component, we provide all additional items accumulated into the buffer in greater than 8-bit-per-component definition to retain the accuracy. The disclosed technique then uses fragment programs similar to those disclosed herein to calculate the result of the item, such as field of color or dab mask (Step ). As disclosed herein, the fragment programs on the GPU can be substantially more accurate than standard techniques. The result of the dab and the separate, area-of-effect buffer are combined using another fragment program (Step ). Finally, the result of the combination of the dab and the area-of-effect buffer is written into the accumulation buffer so that only the area under the dab is affected (Step ). The combination and the write are simultaneously accomplished with a fragment program. Example combinations include, but are not limited to, color interpolation, Porter-Duff SourceOver compositing, and color density addition and interpolation. Ultimately, the user can make a number of paint strokes (Step ). Similar steps disclosed above can be applied to other cumulative graphics operations.","Although the disclosed techniques for using the GPU have been described for processing graphics operations (or more specifically, cumulative graphics operations) on the GPU, the disclosed techniques are also available to accomplish other processing operations on data in data structures other than image data using the GPU. Because the disclosed techniques overcome the limitation of the GPU's inability to maintain data integrity and perform exclusive RMW sequences, the disclosed techniques allow the GPU to process other information besides image information.","At various points in the specification, we have referred to an illustrative list of filters. The computer program listing incorporated herein by reference lists  filters. This list and the accompanying parameters are provided for illustration and completeness of discussion. Regarding the inventors' implementations of the aforementioned innovations, each of the listed filters may or may not be used or modified. Furthermore, more filters may be created and those may differ materially from that disclosed.","The following U.S. applications are hereby incorporated by reference: application Ser. No. 10\/826,596, entitled \u201cIMPROVED BLUR COMPUTATION ALGORITHM\u201d by Mark Zimmer and filed Apr. 16, 2004; application Ser. No. 10\/826,744, entitled \u201cSYSTEM FOR EMULATING GRAPHICS OPERATIONS\u201d by John Harper and filed Apr. 16, 2004; application Ser. No. 10\/825,694, entitled \u201cSYSTEM FOR OPTIMIZING GRAPHICS OPERATIONS\u201d by John Harper, Mark Zimmer, Ralph Brunner, Peter Graffagnino and filed Apr. 16, 2004; and application Ser. No. 10\/826,773, entitled \u201cSYSTEM FOR REDUCING THE NUMBER OF PROGRAMS NECESSARY TO RENDER AN IMAGE\u201d by John Harper and filed Apr. 16, 2004."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 2(","i":["a","b"],"b":"2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 3(","i":["a","b"],"b":"3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11(","i":"a"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11(","i":"b"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 15(","i":["a","b"],"b":"15"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 15(","i":"c"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 17(","i":["a","b"],"b":"17"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
