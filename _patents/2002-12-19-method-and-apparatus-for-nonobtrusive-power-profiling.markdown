---
title: Method and apparatus for non-obtrusive power profiling
abstract: Systems and methods for improved power profiling of embedded applications are presented. These inventions provide the ability to unobtrusively measure the power consumption of an embedded application as the application is executing on its target hardware. The unobtrusiveness is achieved by using programmable emulation circuitry in the target system processor and available device debug terminals on the test port.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07149636&OS=07149636&RS=07149636
owner: Texas Instruments Incorporated
number: 07149636
owner_city: Dallas
owner_country: US
publication_date: 20021219
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is related to and claims priority under 35 USC \u00a7119 (e)(1) to Provisional Application Ser. No. 60\/369,596, \u201cPower Profiler\u201d filed on Apr. 4, 2002 and Provisional Application Ser. No. 60\/401,128, \u201cPower Profiler\u201d filed on Aug. 5, 2002. This application is also related to co-pending applications Ser. No. 10\/325,024 \u201cPower Profiling System and Method for Correlating Runtime Information\u201d and Ser. No. 10\/326,436 \u201cSystem and Method for Power Profiling of Tasks.\u201d","This invention generally relates to microprocessors, and more specifically to improvements in profiling the power consumption of a microprocessor application.","Power is a critical constraint in the design of embedded applications. For example, in the world of portable electronics, one of the key concerns for consumers is the time they can operate their devices on battery power. Therefore, a top priority in the portable electronics industry is designing low power devices. To support this endeavor, various techniques for measuring the power consumption of these applications have been developed. Many of these techniques focus solely on the hardware components of the application and ignore the impact of the software components on the overall power consumption.","Software impacts power consumption at various design levels. At the highest level, the partitioning of application functionality between hardware and software has implications on total power consumption. The choice of algorithm and other higher-level design decisions for the software components also affect system power consumption. The choice of programming language constructs in implementing the design also affects the power cost of the software.","Some techniques, with varying levels of effectiveness, have been developed to analyze power consumption from the software perspective. For example, some estimation techniques are based on architectural level analysis of the processor. Power costs are assigned to architectural components such as datapath execution units, control units, and memory elements. Then, the power cost of a hardware module is determined by the estimated average capacitance that would switch when the module is activated based on a statistical power model. Activity factors for the modules are obtained from functional simulation over typical input streams. Power costs are assigned to individual modules, in isolation from one another, ignoring the correlations between the activities of different modules during execution of real programs.","In another technique, power analysis is done at the instruction level. In this type of analysis, power models of programs are created from a set of base costs for the instructions in the processor instruction set and the power costs of inter-instruction effects such as stalls and cache misses. These models require the generation of the base instruction costs and the inter-instruction effects on a processor-by-processor basis and their accuracy is limited by the accuracy in determining the impact of the dynamic behavior of an application.","In addition to these model-based techniques, some methods for measuring power consumption during actual execution of the embedded application at varying levels of granularity have been developed. In one method, the power consumption of a selected single range of instructions can be measured. In another, the power consumption of selected functions can be measured but the application is halted after each function is executed.","The present invention seeks to provide systems and methods for unobtrusively measuring the power consumption of an embedded application. A digital system is provided that is enabled to support power profiling. This system is comprised of a processor and triggering circuitry for providing a signal to trigger a power measurement device. This triggering circuitry is connected to test port circuitry of the processor. This test port circuitry comprises a plurality of device debug interface terminals used to receive test commands from a host computer system. The test port circuitry is connected to emulation circuitry on the processor that is operable to detect bus events.","An illustrative method provides for unobtrusively capturing power usage data of a software application executing on a target system comprised a processor with emulation circuitry operable to detect bus events and a debug interface comprising a plurality of device debug interface terminals. In this method, the emulation circuitry is programmed to detect a first bus event indicating that power measurement is to be initiated and a second bus event indicating that power measurement is to be terminated. When the first bus event is detected, a signal is sent to initiate power measurement in a manner that does not disturb the execution of the software application. Similarly when the second bus event is detected, a signal is sent to terminate power measurement in a manner that does not disturb the execution of the software application.","A second illustrative method, in further refinement of the above method, operates when at least a first terminal of the plurality of device debug terminals is available to export a signal derived from a bus event without interfering with the debug functionality of the remainder of the device debug terminals. Here, when the first bus event is detected, a signal is sent on the first terminal to initiate power measurement. Similarly, when the second bus event is detected, a signal is sent on the first terminal to terminate power measurement.","Corresponding numerals and symbols in the different figures and tables refer to corresponding parts unless otherwise indicated.","Systems and methods for improved power profiling of embedded applications are described below. These inventions provide the ability to measure the power consumption of an embedded application at varying levels of software granularity as the application is executing on the target hardware. Methods and apparatus are provided to permit such measurements in both real-time and non-real-time.","The embodiments of the systems and methods presented below are exemplary and are presented in relation to target hardware incorporating digital signal processing technology and advanced emulation technology. Details of the general construction of such digital systems are well known and may be found readily elsewhere. For example, U.S. Pat. No. 5,072,418 issued to Frederick Boutaud, et al, describes a digital signal processor (DSP) in detail. U.S. Pat. No. 5,329,471 issued to Gary Swoboda, et al, describes in detail how to test and emulate a DSP. Other embodiments using differing processor and\/or emulation technology should be apparent to one skilled in the art.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 1A\u20131C","b":["1000","1018","1004","1000","1018","1004","1004","1018","1008","1002"]},"In , target system  is comprised of at least one digital signal processor (DSP) . DSP  comprises emulation circuitry providing a standard JTAG debug interface with two additional terminals or pins (interchangeably referred to as nET and nET or EMU and EMU) supporting various extended debugging capabilities. Such emulation circuitry is well known in the art and is described in detail in U.S. Pat. No. 5,828,824 issued to Gary Swoboda. These terminals may be used to export trigger signals from DSP  without interfering with any other functionality of the standard JTAG debug interface. These terminals are made available for triggering a power measurement device by latch  residing between JTAG port  and emulation controller .","The emulation circuitry of DSP  further comprises emulation components that may be programmed to generate the trigger signals.  presents one possible configuration of emulation components. These emulation components comprise logic that monitors activity such as event detector  and auxiliary event detector , logic that records activity such as counters and state machines (block ), logic that permits pin sharing such as scan adapter  and pin manager , logic that imports data such as RTDX , logic that accelerates transmission such as local oscillator , logic that exports data such as RTDX  and trace export , logic that captures execution activity such as trace collection , and logic that directs traffic such as trigger builder .","In , target system  is comprised of at least one digital signal processor (DSP) . Circuitry connected to an I\/O pin of DSP  is provided to permit the use of the pin for transmitting trigger signals to a power measurement device.","Various types of power measurement devices, e.g. oscilloscopes, multimeters, special purpose boards, etc., and means for connecting the devices to the system may be employed. In , the power measurement device is oscilloscope . Oscilloscope  is connected by current probe  to a power measurement point on target system . It receives signals to start and stop power measurements via trigger  connected to EMU and EMU on target system  via latch . Oscilloscope  is also connected to host computer  via General Purpose Interface Board (GPIB)  to permit collection of power measurement data. In , the power measurement device is again oscilloscope  but here trigger  is connected to a pin of DSP . The DSP pin may be an XF pin, any general purpose I\/O (GPIO) pin or any user configurable pin that can be controlled through software. The connection to host computer  is also GPIB . In , the power measurement device is special purpose power measurement board  with the capability to capture, amplify, convert, and store power data. Measurement board  is connected by current probe  to a power measurement point on target system . It receives signals to start and stop power measurements via trigger  connected to EMU and EMU on target system  via latch . Measurement board  is connected to host computer  via parallel port interface  to permit collection of power measurement data. Alternatively, measurement board  may also be connected to host computer  with a USB connection.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3","b":["1006","1010","0","1014","1","1014"]},"To perform power measurements, target system  may need to be modified to permit connection of current probe  at an appropriate power measurement point.  illustrates a typical modification. Wire loop , which is kept as short as possible while still accommodating the connection of current probe , is placed between the output of power supply  and load . If there are any large capacitors on the output of power supply , they should be on the same side as the output of the power supply. Such capacitors filter the output of the power supply and slow down its response to increases or decreases in the current demand of load . Placing these capacitors on the input side of current probe  will permit the inclusion of any additional current that such capacitors add as current demands change.  shows a block diagram of target system  appropriately modified and connected up to measure power consumption. Additional background information regarding setting up a power profiling system such as those described in the above embodiments is provided in Texas Instruments Incorporated application report SPRA074 entitled \u201cTarget System Power Profiling Via Code Composer Studio.\u201d This application report is available at http:\/\/www-s.ti.com\/sc\/techlit\/spra074 and is incorporated herein by reference.","Power profiling software , in conjunction with other software executing on the host computer, provides the user interface for setting up power profiling operations and for displaying the resulting power measurement data. In the preferred embodiment, three modes of power profiling are provided: single-range real-time (SR), multifunction non-real-time (MNR), and multifunction real-time (MR).","SR profiling mode allows the user to measure the power consumed by an application while it is executing between two user-selected addresses. This profiling is done in real-time, meaning that target system  is not halted between the two selected addresses. The resulting power measurement data is displayed when execution is halted. MNR and MR profiling modes permit power measurement of user-selected functions in the embedded application. In MNR profiling mode, the application is halted after power measurement data is collected for a selected function and the resulting power measurement data is displayed. In MR profiling mode, power measurement data for each selected function is collected with minimal impact while the application is executing and is displayed when the application completes execution and\/or is halted.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 6","b":"1018"},"At step , power profiling software  is invoked.  illustrates selecting the Power Dissipation option from the Profiler drop-down menu on the main screen to invoke a power profiling window. , B, and C present power profiling window . The left side of power profiling window  contains buttons for selecting a mode of instrumentation, displaying power measurement graphs, and selecting various options. When the Mode button is selected, menu  is presented to permit the user to select the desired mode of instrumentation. When the Options button is selected, menu  is presented to permit the user to do such things as modifying the settings, clearing or saving results, or saving raw data. Title bar  presents the column titles for the information that power profiling software  collects and displays. This information includes the selected address range or function associated with the data, the total power in millijoules consumed during execution, including any called functions (inclusive count), the total power consumed during execution of the selected function, excluding any called functions (exclusive count), and the maximum and average power values measured within the address range\/function. If status data, i.e., their on\/off status, is collected for peripherals such as timers, multichannel buffered serial ports and direct memory access channels, window  will also show that information.","The next step, , is to perform some general setup of the profiling software.  illustrates settings window  which is invoked by selecting the Settings entry of menu  as illustrated in . Using data collection options , the user may select whether the data is to be collected in milliwatts (power) or milliAmps (current). Collecting data as milliAmps is useful when the voltage changes during execution, i.e., the application is performing dynamic voltage scaling. Using triggering options , the user may select the trigger pin to be used to trigger power measurement device  or  and the voltage of the power supply at the point where current is to be measured on target system . The triggering option selected must correspond to the capabilities of target system . For example, if the power system configuration is that of  or , EMU\/EMU may be selected as the triggering option. If the configuration is that of , a DSP pin may be selected as the triggering option. The voltage entered will be multiplied with the measured current to compute power values.","At step , the power measurement device is initialized. In this embodiment, the device is oscilloscope . As  illustrates, scope tab  of control properties window  provides options for selecting the channel for collecting data from current probe  and for the trigger channel of oscilloscope  connected to trigger .","At step , the user may elect to enable or disable collection of peripheral status data. As  shows, the user may select peripherals tab  of control properties window  to access this option. The user may specify the number of peripherals for which status information is to be collected and information about each peripheral. Setting the number of peripherals to be 0 denotes that no peripheral information is to be collected.","In steps  and , the embedded application is modified to support the mode of power profiling the user wants to use. For all three power profiling modes, a target system specific runtime support library must be added. Each runtime support library provides initialization routines for the selected triggering option and trigger functions for doing the actual triggering of the power measurement device and to do any other special processing required by the power profiling mode.","If the user wants to do SR power profiling, the beginning and end points of the range of instructions to be profiled is set at this time.  illustrates how the user sets this profiling range. First, the user selects the source code file of the embedded application where the profiling is to be initiated and its contents are displayed in pane . The user places the mouse on the source code line where profiling is to be started and right clicks. Popup menu  is presented. The user selects the Power Profiler option from the menu and the Begin Power Profiling Range option from profiler submenu . Analogous actions are taken to set the end of the profiling range. In response to these user actions, power profiling software  inserts calls to the required trigger functions provided by the runtime support library in the source code of the embedded application at the selected points.","For MNR and MR power profiling modes, a special compiler option is used to compile the embedded application. This option instructs the compiler to insert NOP instructions at the beginning and end of each function in the application. The number of NOPs inserted is target dependent and based on the calling sequence of the triggering support functions. Also, the application is linked with a special linker option that forces the required support code to be included. These special options eliminate any requirement for the application developer to alter the application source code manually to provide explicit references to the triggering support routines. If MR mode is to be used, a support library for transferring data from target system  to host system  must also be included in the application. For the embodiments of , the data transfer mechanism is industry standard RTDX.","Once the embedded application has been appropriately modified as described above, it is recompiled, relinked, and downloaded to target system . At step , the instrumentation mode is selected.  illustrates the popup menu for selecting the power measurement instrumentation mode presented when the user selects mode button  in power profiling window . At this point, power profiling software  performs any initialization that may be required for the selected mode. If MNR or MR profiling mode is selected at step , the embedded application is automatically instrumented by power profiling software . This instrumentation comprises replacing the NOPs inserted by the compiler at the beginning and end of each function with the calling sequences for the required trigger functions. Once the application is instrumented, the user may optionally select functions not to measure at step  if MR mode is selected or at step  if MNR mode is selected. Power profiling software  uninstruments the functions selected at step  or  by replacing the inserted calling sequences with NOP instructions.","At step , the embedded application is executed. Power measurement data and other execution data is collected, correlated if necessary, and presented to the user.  present examples of power measurement data collected from the execution of an embedded application instrumented for one of the multi-function power profiling modes in tabular and graphical formats respectively.","Multi-Function Real-Time Profiling","From a high level, in an embodiment, the control flow for multi-function real-time profiling is as follows:\n\n",{"@attributes":{"id":"p-0047","num":"0060"},"figref":"FIG. 15","b":"1002"},"At step , the identity of the function associated with a program counter value is determined. At step , a test is made to determine if the program counter value corresponds to the entry or exit of the identified function. If it is an entry point, then step  is executed next. Here, a check is made to determine if the call stack is empty. If it is, then step  is executed and the function identifier is pushed on top of the stack. Processing of the set of program counter values then continues at step  with the next program counter value. If the call stack is not empty at step , then the next power measurement in the time ordered set of power measurements is attributed to the function on top of the call stack and processing continues at step . If the program counter value is not an entry point at step , then it is an exit point. At step , the function at the top of the call stack is popped off the stack and the next power measurement in the set of power measurements is attributed to that function. Processing then continues at step  with the next program counter value.","Consider the application of this correlation method to the example C program in Table 1.",{"@attributes":{"id":"p-0050","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"main ()","{","\/* ","PC1 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . . . ","\/* measurement M1 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"func1 ()",";"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . . . ","\/* measurement M5 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}","\/* PC6 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"func1 ()","{","\/* PC2 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},". . . .","\/* measurement M2 *\/"]},{"entry":[{},"func2 () ;"]},{"entry":[{},". . . . ","\/* measurement M4 *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}","\/* PC5 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"func2 ()","{","\/* PC3 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . . . ","\/* measurement M3 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}","\/* PC4 *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In this example, three functions are executed, main, func, and func. Assuming that all three functions are profiled, _TSPP_MRtriggerXXX is called six times. This causes six program counter values (PC\u2013PC) to be transferred from the target to the host. The ordering of these program counter values corresponds to the execution order of the functions. This example also produces five separate power measurements (M\u2013M). The ordering of the measurements also corresponds to the execution order of the functions. Note that there is always one more program counter value than there are power measurements. This is because no measurement is taken prior to entering the first function profiled (main in this example).","Table 2 presents the initial state of the call stack and the sets of program counter values and power measurements for the example of Table 1.",{"@attributes":{"id":"p-0053","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","<empty>"]},{"entry":[{},"Program Counter Value Set","PC1, PC2, PC3, PC4, PC5, PC6"]},{"entry":[{},"Power Measurement Set","M1, M2, M3, M4, M5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"First, the identity of the function associated with PC, in this case main, is determined. PC corresponds to the entry point for main, so step  is executed. The call stack is initially empty so step  is skipped and no power measurement is consumed. The function main is pushed onto the call stack. Table 3 illustrates the state of the call stack and the measurement sets after the processing of PC.",{"@attributes":{"id":"p-0055","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","main"]},{"entry":[{},"Program Counter Value Set","PC2, PC3, PC4, PC5, PC6"]},{"entry":[{},"Power Measurement Set","M1, M2, M3, M4, M5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Resuming the method at step , the function associated with PC, func, is determined. PC corresponds to the entry point for func (step ), so processing proceeds to step . The call stack is not empty, so power measurement M is attributed to the function on top of the call stack, main, at step . Func is then pushed on top of the call stack at step . Table 4 illustrates the state of the call stack and the measurement sets after the processing of PC.",{"@attributes":{"id":"p-0057","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","func1, main"]},{"entry":[{},"Program Counter Value Set","PC3, PC4, PC5, PC6"]},{"entry":[{},"Power Measurement Set","M2, M3, M4, M5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At step , func is found to be the function associated with PC. Again, PC is an entry point and the call stack is not empty, so power measurement M is attributed to the function at the top of the stack, func. Func is then pushed onto the stack. Table 5 illustrates the state of the call stack and the measurement sets after the processing of PC.",{"@attributes":{"id":"p-0059","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","func2, func1, main"]},{"entry":[{},"Program Counter Value Set","PC4, PC5, PC6"]},{"entry":[{},"Power Measurement Set","M3, M4, M5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Resuming at step , PC is determined to be associated with func. At step , it is found to be an exit point rather than an entry point, so step  is executed. The function identifier at the top of the stack, func, is popped and the power measurement M is attributed to it. Table 6 illustrates the state of the call stack and the measurement sets after the processing of PC.",{"@attributes":{"id":"p-0061","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","func1, main"]},{"entry":[{},"Program Counter Value Set","PC5, PC6"]},{"entry":[{},"Power Measurement Set","M4, M5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Returning to step , PC is now processed. PC corresponds to the exit point for func, so again step  is executed. The function identifier at the top of the stack, func, is popped and power measurement M is attributed to it. Table 7 illustrates the state of the call stack and the measurement sets after the processing of PC.",{"@attributes":{"id":"p-0063","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","main"]},{"entry":[{},"Program Counter Value Set","PC6"]},{"entry":[{},"Power Measurement Set","M5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Returning to step , PC is now processed. PC corresponds to the exit point for main, so again step  is executed. The function identifier at the top of the stack, main, is popped and power measurement M is attributed to it. Table 8 illustrates the state of the call stack and the measurement sets after the processing of PC.",{"@attributes":{"id":"p-0065","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","<empty>"]},{"entry":[{},"Program Counter Value Set","<empty>"]},{"entry":[{},"Power Measurement Set","<empty>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"From a high level, in an embodiment, the control flow for multi-function non real-time profiling is as follows:\n\n",{"@attributes":{"id":"p-0067","num":"0093"},"figref":"FIG. 16","b":"1002"},"To build the call stack, power profiling software  determines what function called _TSPP_MNRtriggerXXX, and whether the call was made from the function's entry point or just prior to the function's exit point. At step , the identity of the function calling the trigger function is determined based on the return address of trigger function. At step , a test is made to determine if the return address corresponds to the entry or exit of the identified function. If it is an entry point, then step  is executed next. Here, a check is made to determine if the call stack is empty. If it is, then step  is executed and the function identifier is pushed on top of the stack. The method then terminates. If the call stack is not empty at step , then the current power measurement is attributed to the function on top of the call stack and processing continues at step , where the current function identifier is pushed on the call stack. If the return address is not an entry point at step , then it is an exit point. At step , the function at the top of the call stack is popped off the stack and the current power measurement is attributed to that function. The method then terminates.","Consider the application of this correlation method to the example C program in Table 9.",{"@attributes":{"id":"p-0070","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"main ()","{","\/* ","RA1 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . . . ","\/* measurement M1 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"func1 ()",";"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . . . ","\/* measurement M5 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}","\/* RA6 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"func1 ()","{","\/* RA5 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},". . . .","\/* measurement M2 *\/"]},{"entry":[{},"func2 () ;"]},{"entry":[{},". . . . ","\/* measurement M4 *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}","\/* RA2 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"func2 ()","{","\/* RA3 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . . . ","\/* measurement M3 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}","\/* RA4 *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In this example, three functions are executed, main, func, and func. Assuming that all three functions are profiled, _TSPP_MNRtriggerXXX is called six times and six breakpoints occur. There will be six return address (RA\u2013RA) and five power measurements (M\u2013M) to be correlated. Table 10 presents the initial state of the call stack prior to the execution of the example of Table 9.",{"@attributes":{"id":"p-0072","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 10"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","<empty>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"When function main is executed, TSPP_MNRtriggerXXX is called and the first breakpoint occurs. First, at step , the identity of the function associated with RA , in this case main, is determined. RA corresponds to the entry point for main, so step  is executed. The call stack is initially empty so step  is skipped. The function main is pushed onto the call stack. Execution of the application is then resumed. Table 11 illustrates the state of the call stack after the processing of RA.",{"@attributes":{"id":"p-0074","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","main"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At the next breakpoint, the function associated with RA, func, is determined at step . RA corresponds to the entry point for func (step ), so processing proceeds to step . The call stack is not empty, so the current power measurement M is attributed to the function on top of the call stack, main, at step . Func is then pushed on top of the call stack at step . Execution of the application is then resumed. Table 12 illustrates the state of the call stack and the measurement sets after the processing of PC.",{"@attributes":{"id":"p-0076","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 12"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","func1, main"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At the next breakpoint, func is found to be the function associated with RA. Again, RA is an entry point and the call stack is not empty, so the current power measurement M is attributed to the function at the top of the stack, func. Func is then pushed onto the stack. Execution of the application is then resumed. Table 13 illustrates the state of the call stack and the measurement sets after the processing of PC.",{"@attributes":{"id":"p-0078","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 13"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","func2, func1, main"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At the next breakpoint, RA is determined to be associated with func. At step , it is found to be an exit point rather than an entry point, so step  is executed. The function identifier at the top of the stack, func, is popped and the current power measurement M is attributed to it. Execution of the application is then resumed. Table 14 illustrates the state of the call stack and the measurement sets after the processing of RA.",{"@attributes":{"id":"p-0080","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 14"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","func1, main"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At the next breakpoint, RA is processed. RA corresponds to the exit point for func, so again step  is executed. The function identifier at the top of the stack, func, is popped and current power measurement M is attributed to it. Execution of the application is then resumed. Table 15 illustrates the state of the call stack and the measurement sets after the processing of RA.",{"@attributes":{"id":"p-0082","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 15"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","main"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At the final breakpoint, RA is processed. RA corresponds to the exit point for main, so again step  is executed. The function identifier at the top of the stack, main, is popped and current power measurement M is attributed to it. Execution of the application is then resumed. Table 16 illustrates the state of the call stack and the measurement sets after the processing of RA.",{"@attributes":{"id":"p-0084","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 16 "]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call Stack","<empty>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"From a high level, the control flow for multi-function non real-time profiling is as follows:\n\n","The user can choose a special form of single range profiling that supports multiple executions of the embedded application. In this case, power profiling software  will execute the application multiple times without user intervention. The final results are the average power consumption for all the executions.","To use this form of profiling, the user tells power profiling software  how many times the application is to be executed when SR mode is selected. When performing multiple executions, power profiling software  initiates each execution.",{"@attributes":{"id":"p-0088","num":"0119"},"figref":["FIG. 17","FIGS. 1A and 1C"],"b":["1010","1010","0","1","1002","1700","1702","1706","0","1702","1704","1708","1"]},{"@attributes":{"id":"p-0089","num":"0120"},"figref":"FIG. 18","b":["1006","1800","0","1014","1804","1802","1","1006"]},"In addition to the above described methods for measuring the power consumption of discrete software units such as address ranges or functions of an embedded application, methods have been developed for measuring the power consumption of the software tasks performed during execution.","Task-Level Real-Time Profiling","Task-level real-time profiling (TR) allows measurement of the power consumption of each task executed in an embedded application. This includes both statically and dynamically created tasks.  presents a flowgraph of a method for task-level real-time power profiling of an embedded application. At step , the embedded application is instrumented to permit power profiling of all tasks that will be executed when the application is run. In an embodiment such as that of , this instrumentation consists of linking in profile support code tailored to target hardware  and trigger  be used on host computer , downloading the application to target hardware , and selecting the TR profiling mode in power profiling software . Power profiling software  replaces the current address of the task switch hook function provided by the operating system of the embedded application with the address of a trigger function _TSPP_switchfxn_XXX_tr. This causes the trigger function to be executed each time there is a task context switch while the embedded application is executing.","Task hook functions are well known to those skilled in the art. Such hook functions are provided by an operating system to permit an application to specify functions to be called whenever the state of a task changes, such as when a task is created, deleted, exited, or when a context switch occurs. One implementation of such hook functions is described in more detail in Section 2.25 of \u201cTMS320C6000DSP\/BIOS Application Programming Interface (API) Reference Guide\u201d. This section is incorporated herein by reference as background material. The entire document is available at http:\/\/www-s.ti.com\/sc\/psheets\/spru403d\/spru403d.pdf.","More specifically, in an embodiment, when replacing the task switch hook function, power profiling software  performs the following steps:\n\n","After the embedded application is instrumented for TR profiling, the user starts execution. During this execution, steps \u2013 of the method are performed. Any task context switch that occurs transfers control to the trigger function _TSPP_switchfxn_XXX_tr. Each invocation of the trigger function causes the following steps to occur:\n\n","As indicated by step , the task handles are transferred to the host computer while the application is executing. The actual method for retrieving the task handles and other data depends on the transfer method used by target system . For an embodiment, the transfer method is RTDX.","Either while the application is executing, or when execution completes, power profiling software  retrieves power measurement data from the measurement device. If the measurement device is oscilloscope , the set of power measurements is retrieved when the application completes execution. If the measurement device is high-speed measurement board , the power measurement data may be retrieved while the application is still running.","When execution of the application is complete, the power measurement data is correlated with the collected task handles at step  to attribute specific power measurements to specific tasks. When the application finishes execution (or execution is manually halted), power profiling software  has a set of power measurements in the order they were taken, and a set of task handles that specify the execution order of the tasks. The ordering of the set of task handles and the set of power measurements is such that there is a one-to-one correspondence between the respective elements of the sets. This is possible because the first call to the profile support routine occurs before any measurement is taken. The support routine initiates the transfer of the task handle of the task that will start executing when the task switch is complete (i.e. the handle for the new task). It does not transfer the handle of the task that was executing when the switch occurred (i.e. the old task handle). On all subsequent context switches, the power measurement that has just been taken corresponds to the old task. This task is the same task whose handle was transferred in the previous task switch. In other words, the new task in the nth context switch is also the old task in the nth+1 context switch.","Using this information, a specific power measurement may be correlated to the exact task that was executing when the power measurement was taken.  illustrates one such method for correlating power measurements with the appropriate tasks. For each task handle in the set of task handles, the steps  and  are executed. At step , the task associated with the task handle is identified and at step , the next power measurement in the ordered set of power measurements is attributed to that task. For example, if an application has tasks T, T, T, and T whose execution order is: T, T, T, T, T, T, T, T, the set of task handles and the set of power measurements will be TH, TH, TH, TH, TH, TH, TH, TH and M, M, M, M, M, M, M, M respecectively. When the method is applied, measurement M is attributed to T, M is attributed to T, etc. Note that TH is the task handle for T, TH is the task handle for TH, etc.","In an implementation of the above method, power profiling software   maintains a hash table of pointers to ProfileTask objects. The keys to this hash table are based on the task handles. For each task handle, the hash table is checked to see if this particular task handle has already been encountered. If it has not, a new ProfileTask object is created. The task associated with the task handle is identified by looking it up in the symbol table created when the embedded application was created and the task name is stored in the ProfileTask object. The next power measurement in the set of power measurement is also stored in the ProfileTask object. If the task handle has already been encountered, the ProfileTask object associated with the task handle is updated with the next power measurement in the set of power measurements.","The method of  is limited in that it cannot distinguish among tasks that are created with duplicate task handles. Such duplication only occurs when an application is allocating tasks dynamically.  presents an enhanced version of this method that overcomes this limitation. In this enhanced method, step  includes further instrumentation of the embedded application. In addition to replacing the task switch hook function with a trigger support function, the task create hook function is also replaced with a profile support function that will be called each time a new task is created. This support function will cause the task handle of a newly created task to be captured as illustrated by added step . The task handles for the created tasks are transmitted to host computer  at step . Because there are now task handles being captured at task creation and at each context switch, there must be a way to distinguish between the two modes of capture for purposes of correlating the power measurements with the task handles. One possible means of distinguishing is to provide an identifying header when the task handles are transferred to host computer .",{"@attributes":{"id":"p-0101","num":"0140"},"figref":["FIG. 24","FIG. 23"],"b":["1002","2400","2402","2404","2406","2408","2400"]},"If the check at step  determines that the task handle was not captured at task creation, then it was captured at task execution and step  is executed. At step , the ProfileTask object for the task handle is located in the hash table. And, at step , the next power measurement in the set of power measurements is attributed to the task represented by that ProfileTask object. Processing of the set of task handles then continues at step .","For example, consider an embedded application having tasks T, T, T, T, and T where T and T are dynamically allocated tasks. Assume that the task execution order is: T, T, T, T, T, T, T, T and that T and T are given the same task handle, TH, when they are created. The set of task handles and the set of power measurements will be THc, THc, THc, TH, THc, TH, TH, TH, THc, TH, TH, TH, TH and M, M, M, M, M, M, M, M respectively. THcx indicates a task handle captured when the associated task Tx is created and THx indicates a task handle captured when the associated task Tx is executed.",{"@attributes":{"id":"p-0104","num":"0143"},"figref":"FIG. 25","b":["2400","4","4","1","2520","2510","2402","2404","4","2500","2502","1","2","1","4","2","3","2520","2512","2514","2500","2508","2504","2400","4","2410","1","1","2400","3","4","2520","2516","2506","2522","2506","4","3","4","2","3","2","1","3","4","2","1","2400","3","5","2520","2518","2402","2404","2506","3","2406","2506","5","2400","3","2510","5","2512","5","4","2","1","6","7","8"]},"Task-Level Non-Real-Time Profiling","Task-level non-real-time profiling (TNR) permits measurement of power consumption for all tasks, whether statically or dynamically allocated, that are executed in an embedded application. The primary difference between TNR profiling and TR profiling is that the target system is halted at each task context switch and the power consumption display is updated.  presents a flowgraph of a method for task-level non-real-time power profiling of an embedded application. At step , the embedded application is instrumented to permit power profiling of all tasks that will be executed when the application is run. In an embodiment such as that of , this instrumentation consists of linking in profiling support code tailored to target hardware  and trigger  be used on host computer , downloading the application to target hardware , and selecting the TNR profiling mode in power profiling software . Power profiling software  replaces the current address of the task switch hook function provided by the operating system of the embedded application with the address of the trigger function _TSPP_switchfxn_XXX_tnr. This will cause the trigger function to be called each time there is a task context switch while the embedded application is executing. Power profiling software  also sets a breakpoint at the address specified by the symbol _TSPP_switchfxn_halt_XXX_tnr.","More specifically, in an embodiment, when replacing the task switch hook function, power profiling software  performs the following steps:\n\n","After the embedded application is instrumented for TNR profiling, the user starts execution. During this execution, steps \u2013 of the method are performed at each context switch (step ). Any task context switch that occurs transfers control to the trigger function _TSPP_switchfxn_XXX_tnr. Each invocation of the trigger function will cause the following steps to occur:\n\n","When the embedded application is halted at the _TSPP_switchfxn_halt_xxx_tnr breakpoint, power profiling software  correlates the most recent power measurement to the task that was executing when the measurement was taken.  illustrates one method for correlating power measurements with the appropriate tasks. At step , the current power measurement is attributed to the currently executing task by updating the entry for that task in the task handle data structure maintained by power profiling software . In an embodiment, power profiling software  knows which task is currently executing because it maintains a variable containing the task handle of the currently executed task. If the task handle received by power profiling software  is a new one (step ), i.e., this is the first time the task will be executed, the task associated with the new task handle is identified and at step , an entry for the new task handle is created in the task handle data structure. And, in an embodiment, the variable tracking the currently executing task is updated to contain the new task handle.","For example, if an application has tasks T, T, T, and T whose execution order is: T, T, T, T, T, T, T, T, the task handles and power measurements received by host computer  during execution of the application will be TH, TH, TH, TH, TH, TH, TH, TH and M, M, M, M, M, M, M, M respectively. When the method is applied at the first breakpoint in the first context switch, an entry for TH will be created in the task handle data structure as this is the first execution of T. No power measurement will be attributed as no task has yet been executed. At the next context switch, power measurement M is attributed to T and an entry for TH is created in the task handle data structure. At the next context switch, M is attributed to T and an entry for TH is created in the task handle data structure, etc. Note that TH is the task handle for T, TH is the task handle for TH, etc.",{"@attributes":{"id":"p-0110","num":"0161"},"figref":"FIG. 28","b":["1002","2800","2802","2804","2806","2808"]},"The method of  is limited in that it does not distinguish among tasks that are created with duplicate task handles. Such duplication only occurs when an application is allocating tasks dynamically.  presents an enhanced version of the method that overcomes this limitation. In this method, step  includes further instrumentation of the embedded application. In addition to replacing the task switch hook function with a trigger support function, the task create hook function is also replaced with a task creation support function that is called each time a new task is created and a breakpoint is set in this support function. This support function will cause the task handle of a newly created task to be captured and received by host computer  each time this breakpoint is hit during execution of the embedded application as illustrated by added steps \u2013. The task handles for the created tasks are received by host computer  at step  and used to update the task handle data structure. Because there are now task handles being captured at task creation and at each context switch, there must be a way to distinguish between the two modes of capture for purposes of correlating the power measurements with the task handles. One possible means of distinguishing is to provide an identifying header when the task handles are transferred to host computer .",{"@attributes":{"id":"p-0112","num":"0163"},"figref":["FIG. 30","FIG. 29"],"b":["1002","3000","3002","3004","3006","3008"]},"If the check at step  determines that the task handle was not captured at task creation, then it was captured at task execution and step  is executed. The ProfileTask object for the task handle of the currently executing task is located in the hash table. And, at step , the current power measurement is attributed to that task by updating the ProfileTask object.","For example, consider an embedded application having tasks T, T, T, T, and T where T and T are dynamically allocated tasks. Assume that the task execution order is: T, T, T, T, T, T, T, T and that T and T are given the same task handle, TH, when they are created. The task handles and power measurements received by host computer  will be THc, THc, THc, TH, THc, TH, TH, TH, THc, TH, TH, TH, TH and M, M, M, M, M, M, M, M respectively. THcx indicates a task handle captured when the associated task Tx is created and THx indicates a task handle captured when the associated task Tx is executed.",{"@attributes":{"id":"p-0115","num":"0166"},"figref":"FIG. 25","b":["3000","4","4","1","2520","2510","3002","3004","4","2500","2502","1","2","1","4","2","3","2520","2512","2514","2500","2508","2504","3000","4","3010","1","1","3","3000","3","4","2520","2516","2506","2522","2506","4","3","4","2","3","2","1","3","4","2","1","3000","3","5","2520","2518","3002","3004","2506","3","3006","2506","05","3000","3","2510","5","3012","5","5","4","2","1","6","7","8"]},{"@attributes":{"id":"p-0116","num":"0167"},"figref":["FIG. 19","FIG. 1B","FIGS. 1A and 1C"],"b":["0","1","1002","1900","1902","1904","1908","0","1902","1904","1906","1"]},"In SR mode, latch  operates as discussed previously for the unobtrusive method of single range power profiling.  illustrates the operation of latch  during MNR or MR power profiling. When the instruction at the start address of the profile support routine is executed, EMU is pulsed at point  to clear the trigger signal. The trigger signal remains low, as indicated by trigger width , until the execution of the instruction at the end address of the profile support routine. Then, at end point , EMU is pulsed. This 15 ns pulse causes the trigger signal to latch, sending a signal via trigger  to the attached power measurement device. The trigger signal remains high, as indicated by trigger width , until the next execution of the instruction at the start address of the profile support routine, i.e. when the next function to be profiled is executed.","In other embodiments of the above methods and systems for power profiling, the power measurement data collected is refined to permit more accurate profiling of power consumption, both for target systems that perform dynamic voltage scaling and those that do not. In power profiling systems such as those depicted in , if power measurement devices  and  have only one input means, such as a channel on an oscilloscope, then the power measurement data captured is generally a current measurement. Since power P is actually calculated by the formula P=V*I where V is voltage and I is current, the voltage value must be provided some other way. As illustrated above in , one approach is to ask the user of the system to specify a value for V. This specified voltage value is then used as a constant in the ensuing power calculations.","However, it is unlikely that voltage is actually a constant while an application is executing. Typically, voltage will fluctuate between plus or minus 5\u201310%. And, if the target hardware supports dynamic voltage scaling, the application may deliberately cause voltage changes. If power measurement devices  and  have a second input means, both voltage and current values may be captured by providing both a current probe and a voltage probe. The power measurement data collected as the application is executing then comprises both actual voltage and actual current values, thus providing a more accurate measurement of power consumption.","While the above inventions have been described with reference to illustrative embodiments, these descriptions should not be construed in a limiting sense. Various other embodiments of the invention will be apparent to persons skilled in the art upon reference to this description. For example, the methods for measuring the power consumption of functions are clearly applicable to any analogous software unit in a high level programming language. The task level power profiling methods may be used in applications where portions of the application are dynamically linked and loaded. Also, the basic triggering scheme, the capturing of power and execution data, and the correlation methods may be readily extended to measure power consumption of applications executing on target hardware comprising multiple processors. Some example scenarios include: 1) a configuration in which a single power supply feeds multiple processors and the aggregate power measurement is taken from all the processors; 2) a configuration in which a single power supply feeds multiple processors where each processor is connected to a separate power measurement device; 3) a configuration with a multi-core chip in which each core on the chip has a separate power supply and the inter-processor interconnect is passive routing; and 4) a configuration with a multi-core chip in which each core on the chip has a separate power supply and the inter-processor interconnect comprises an active logic interconnect that is also separately powered. It is therefore contemplated that the appended claims will cover any such modifications of the embodiments as fall within the true scope and spirit of the invention."],"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Particular embodiments in accordance with the invention will now be described, by way of example only, and with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 1A","b":["1","1"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 7","b":["8","8","8","9","10","11","12","13","14"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 15","b":["16","17","19","21","22","23","24","26","27","28","29","30"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 25"}]},"DETDESC":[{},{}]}
